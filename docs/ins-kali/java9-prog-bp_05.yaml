- en: Sunago - A Social Media Aggregator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sunago - 社交媒体聚合器
- en: For our next project, we'll try something a bit more ambitious; we'll build
    a desktop application that aggregates data from various social media networks
    and displays it in one seamless interaction. We're also going to try something
    new, and we're going to give this project a name, something that might be a bit
    more appealing than the dry, albeit accurate, `description-turned-name` that we've
    used to date. This application, then, we'll call Sunago, which is the phonetic
    spelling of the (Koine) Greek word συνάγω, which means **I gather together**,
    **collect**, **assemble**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将尝试一些更有雄心的东西；我们将构建一个桌面应用程序，它可以从各种社交媒体网络中聚合数据，并以一种无缝的交互方式显示出来。我们还将尝试一些新的东西，并且给这个项目起一个名字，这个名字可能比迄今为止使用的干巴巴但准确的`描述转换名称`更有吸引力。那么，这个应用程序，我们将其称为Sunago，这是（Koine）希腊语单词συνάγω的音标拼写，意思是**我聚集在一起**，**收集**，**组装**。
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序将涵盖几个不同的主题，有些熟悉，有些新的。该清单包括以下内容：
- en: JavaFX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Internationalization and localization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: '**Service Provider Interfaces** (**SPI**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供商接口**（**SPI**）'
- en: REST API consumption
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API消费
- en: '`ClassLoader` manipulation'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassLoader`操作'
- en: Lambdas, lambdas, and more lambdas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式，lambda表达式，还有更多的lambda表达式
- en: As usual, those are the just the highlights with a number of interesting items
    sprinkled throughout.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这些只是一些亮点，其中还有许多有趣的内容。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'As with every application, before we get started, we need to think about what
    we want the application to do. That is, what are the functional requirements?
    At a high level, the description tells us what we want to achieve in broad terms,
    but, more specifically, we want the user to be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个应用程序一样，在开始之前，我们需要考虑一下我们希望应用程序做什么。也就是说，什么是功能需求？在高层次上，描述告诉我们我们希望以广义的术语实现什么，但更具体地，我们希望用户能够做到以下几点：
- en: Connect to several different social media networks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到几个不同的社交媒体网络
- en: Determine, on a network-by-network basis, which group of data (users, lists,
    and more) to retrieve
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个网络确定要检索的数据组（用户、列表等）
- en: See list of items from each network in a consolidated display
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个整合显示中查看来自每个网络的项目列表
- en: Be able to determine from which network an item came
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定项目来自哪个网络
- en: Click on an item and have it loaded in the user's default browser
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击项目并在用户默认浏览器中加载它
- en: 'In addition to this list of things the application **should** do, the things
    it **shouldn''t** do include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序应该做的事情清单之外，它不应该做的事情包括以下几点：
- en: Respond/reply to items
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回复项目
- en: Comment on items
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论项目
- en: Manage friends/following lists
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理朋友/关注列表
- en: These features would be great additions to the application, but they don't offer
    much that would be architecturally interesting beyond the basic application detailed
    previously, so, to keep things simple--and moving along--we'll limit the scope
    to the given basic set of requirements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能将是应用程序的很好的补充，但除了之前详细介绍的基本应用程序之外，它们并没有提供太多有趣的架构内容，因此，为了保持简单并使事情顺利进行，我们将限制范围到给定的基本需求集。
- en: 'So where to start on the application? As in the previous chapters, we''re going
    to make this a desktop application, so let''s start there, with a JavaFX application.
    I''m going to tip my hand a little bit here to make things easier later on: this
    will be a multi-module project, so we first need to create the parent project.
    In NetBeans, click on File | New Project..., and select the `Maven` category,
    as seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应用程序从哪里开始呢？与之前的章节一样，我们将把这个应用程序做成一个桌面应用程序，所以让我们从那里开始，使用JavaFX应用程序。我在这里稍微透露一点底牌，以便以后更容易：这将是一个多模块项目，因此我们首先需要创建父项目。在NetBeans中，点击文件
    | 新建项目...，并选择`Maven`类别，如下截图所示：
- en: '![](img/bf651e9f-2210-43e1-b027-b6ba1d98b8f7.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf651e9f-2210-43e1-b027-b6ba1d98b8f7.png)'
- en: 'Click on the Next button, and fill in the project details, as shown next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步按钮，并填写项目详细信息，如下所示：
- en: '![](img/35d2db60-289b-4589-9598-3c7e81523bc8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35d2db60-289b-4589-9598-3c7e81523bc8.png)'
- en: 'When you click on Finish, you will be presented with an empty project. Once
    we add modules to this project, differentiating them might become difficult, so
    something I do as a matter of practice is to give each module a distinct, "namespaced"
    name. That is to say, each module has its own name, of course, but I prefix that
    with the name of the project. For example, since this is the base POM of the project,
    I call it `Master`. To reflect that, I modify the generated POM to look something
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单击完成后，您将看到一个空项目。一旦我们向该项目添加模块，区分它们可能会变得困难，因此作为一种惯例，我会给每个模块一个独特的“命名空间”名称。也就是说，每个模块都有自己的名称，当然，我会在项目名称前加上前缀。例如，由于这是项目的基本POM，我将其称为`Master`。为了反映这一点，我修改生成的POM，使其看起来像这样：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s really not much to this yet. The advantage that a parent POM like
    this gives us is that we can build all the projects with one command if we so
    desire, and we can move any shared configuration to this shared parent POM to
    reduce duplication. What we need to add now, though, is a module, which NetBeans
    helps us do, as seen in this screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有太多内容。像这样的父POM给我们带来的好处是，如果我们愿意，我们可以用一个命令构建所有项目，并且我们可以将任何共享配置移动到这个共享的父POM中，以减少重复。不过，现在我们需要添加的是一个模块，NetBeans可以帮助我们做到这一点，如下截图所示：
- en: '![](img/795d1477-a580-4f9f-9d51-aa8f7493db24.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/795d1477-a580-4f9f-9d51-aa8f7493db24.png)'
- en: After clicking on Create New Module..., you will be presented with the familiar
    New Project window, from which you'll want to select Maven | JavaFX Application,
    and click on Next. In the New Java Application screen, enter `app` for the project
    name, and click on Finish (all of the other defaults are acceptable as-is).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '单击创建新模块后，您将看到熟悉的新项目窗口，从中您将选择Maven | JavaFX应用程序，并单击下一步。在新的Java应用程序屏幕中，输入`app`作为项目名称，并单击完成（所有其他默认设置均可接受）。 '
- en: 'Again, we want to give this module a meaningful name, so let''s modify the
    generated `pom.xml` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们希望给这个模块一个有意义的名称，所以让我们修改生成的`pom.xml`如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When NetBeans creates the project, it will generate several artifacts for us--two
    classes, `FXMLController` and `MainApp`, as well as the resources, `fxml/Scene.xml`
    and `styles/Styles.css`. While this may be stating the obvious, artifacts should
    have names that clearly communicate their purpose, so let's rename these.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当NetBeans创建项目时，它会为我们生成几个构件--两个类`FXMLController`和`MainApp`，以及资源`fxml/Scene.xml`和`styles/Styles.css`。虽然这可能是显而易见的，但构件应该具有清晰传达其目的的名称，所以让我们将它们重命名。
- en: The class `FxmlContoller` should be renamed to `SunagoController`. Perhaps the
    quickest and easiest way to do this is to open the class by double-clicking on
    it in Project View, then, in the source editor, click on the name of the class
    in the class declaration, and press *Ctrl* + *R*. The Rename Class dialog should
    appear, in which you need to enter the new name, and press *Enter*. This will
    rename the class and the file for you. Now repeat that process for `MainApp`,
    renaming it to `Sunago`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类`FxmlContoller`应该重命名为`SunagoController`。也许最快最简单的方法是在项目视图中双击打开类，然后在源编辑器中点击类声明中的类名，并按下*Ctrl*
    + *R*。重命名类对话框应该会出现，您需要输入新名称，然后按*Enter*。这将为您重命名类和文件。现在重复这个过程，将`MainApp`重命名为`Sunago`。
- en: We also want to rename the generated FXML file, `Scene.xml`, to `sunago.fxml`.
    To do that, right-click on the file in Project View and select Rename... from
    the context menu. Enter the new name (without the extension) in the Rename dialog,
    and press *Enter*. While we're at it, let's also rename `Styles.css` to `styles.css`
    so that the case is consistent. It's a minor thing, but consistency in the code
    can help produce confidence in you in whoever might take over your code in the
    future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想将生成的FXML文件`Scene.xml`重命名为`sunago.fxml`。要做到这一点，在项目视图中右键单击文件，然后从上下文菜单中选择重命名...。在重命名对话框中输入新名称（不包括扩展名），然后按*Enter*。在这个过程中，让我们也将`Styles.css`重命名为`styles.css`，以保持一致。这只是一个小事，但代码的一致性可以帮助您和未来接手您代码的人产生信心。
- en: 'Unfortunately, renaming these files doesn''t adjust the references to them
    in the Java sources, so we need to edit `Sunago.java` to point to these new names,
    which is done as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，重命名这些文件不会调整Java源文件中对它们的引用，因此我们需要编辑`Sunago.java`，将它们指向这些新名称，操作如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note also that we changed the title to something more appropriate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们将标题更改为更合适的内容。
- en: Setting up the user interface
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户界面。
- en: If we wanted to, we could now run our application. It would be very boring,
    but it would run. Let's try to fix the boring part.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，现在可以运行我们的应用程序。这将非常无聊，但它可以运行。让我们试着修复无聊的部分。
- en: 'The default FXML created is just an AnchorPane with two children, a Button
    and a Label. We don''t need any of those, so let''s get rid of them. Our main
    user interface will be pretty simple--basically, just a vertical stack of components--so
    we can use a VBox as our root component. Perhaps, the easiest way to change the
    root component from the AnchorPane that''s there to a VBox is to use Scene Builder
    to wrap that component in a VBox, and then delete the AnchorPane:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认创建的FXML只是一个带有两个子元素的AnchorPane，一个按钮和一个标签。我们不需要这些，所以让我们摆脱它们。我们的主用户界面将非常简单--基本上只是一堆垂直的组件--所以我们可以使用VBox作为我们的根组件。也许，将根组件从那里的AnchorPane更改为VBox的最简单方法是使用Scene
    Builder将该组件包装在VBox中，然后删除AnchorPane：
- en: '![](img/34cca0dd-2582-4fa2-96ad-6d3089fdbaa2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34cca0dd-2582-4fa2-96ad-6d3089fdbaa2.png)'
- en: To do that, open the FXML file in Scene Builder by double-clicking on the file
    (assuming you've configured NetBeans correctly so that it knows where to find
    Scene Builder. If not, refer back to [Chapter 1](../Text/b9fd4346-066b-47b1-9404-84a8a04b2902.xhtml),
    *Introduction*). In Scene Builder, right-click on AnchorPane in the Document section
    of the accordion on the left, select Wrap in, and then VBox, as shown in the preceding
    screenshot. Scene Builder will then modify the FXML file, making AnchorPane a
    child of VBox as expected. Once that's done, you can right-click on AnchorPane,
    and click on Delete to remove it and its children. This leaves us with an empty
    user interface that's more boring than it was when we began. We can fix that now
    by adding a couple of controls--a MenuBar and a ListView. We do that by clicking
    on each component in the Controls section of the accordion and dragging them to
    VBox. If you drop the components on VBox, they will be appended to its list of
    children. Make sure that MenuBar comes before ListView, or you'll have a very
    strange user interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，通过双击文件在Scene Builder中打开FXML文件（假设您已经正确配置了NetBeans，以便它知道在哪里找到Scene Builder。如果没有，请参考[第1章](../Text/b9fd4346-066b-47b1-9404-84a8a04b2902.xhtml)，*介绍*）。在Scene
    Builder中，在左侧手风琴的文档部分中右键单击AnchorPane，选择Wrap in，然后选择VBox，如前面的屏幕截图所示。然后，Scene Builder将修改FXML文件，使AnchorPane作为预期的VBox的子元素。完成后，您可以右键单击AnchorPane，然后单击删除以删除它及其子元素。这样我们就得到了一个比开始时更无聊的空用户界面。现在我们可以通过添加一些控件来修复它--一个菜单栏和一个列表视图。我们可以通过单击手风琴中控件部分中的每个组件，并将它们拖动到VBox中来实现。如果您将组件放在VBox上，它们将被追加到其子元素列表中。确保MenuBar在ListView之前，否则您将得到一个非常奇怪的用户界面。
- en: Let's configure these components a bit now before we return to the code. Selecting
    VBox from the Document section on the left, we then need to select the Layout
    section in the accordion on the right. For Min Width and Min Height, enter `640`
    and `480` respectively. This will make the window's default size larger and more
    user-friendly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在返回代码之前，让我们稍微配置一下这些组件。从左侧的文档部分选择VBox，然后需要在右侧手风琴中选择布局部分。对于最小宽度和最小高度，分别输入`640`和`480`。这将使窗口的默认大小更大和更用户友好。
- en: For MenuBar, we need to expand its entry under Document, then expand each of
    its Menu children, which should reveal one MenuItem per Menu. Click on the first
    Menu, then, on the right, set `Text` to `_File`, and check Mnemonic Parsing. This
    will allow the user to press *Alt* + *F* to activate (or show) this menu. Next,
    click on its `MenuItem` child, setting `Text` to `_Exit`, and check Mnemonic Parsing.
    (If the text for a `Menu`, `MenuItem`, `Button`, and more has an underscore in
    it, make sure that Mnemonic Parsing is checked. For brevity's sake, I won't flag
    this explicitly again.) Open the Code section, and set the On Action value to
    `closeApplication`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MenuBar，我们需要展开其在Document下的条目，然后展开其每个Menu子项，这样应该会显示每个Menu的一个MenuItem。点击第一个Menu，然后在右侧将`Text`设置为`_File`，并勾选Mnemonic
    Parsing。这将允许用户按下*Alt* + *F*来激活（或显示）此菜单。接下来，点击其`MenuItem`子项，将`Text`设置为`_Exit`，并勾选Mnemonic
    Parsing。（如果`Menu`、`MenuItem`、`Button`等的文本中有下划线，请确保勾选了Mnemonic Parsing。出于简洁起见，我不会再明确标记这一点。）打开Code部分，将On
    Action值设置为`closeApplication`。
- en: The second `Menu` should have its Text value set to `_Edit`. Its `MenuItem`
    should be labeled `_Settings`, and have an On Action value of `showPreferences`.
    Finally, the third `Menu` should be labeled `_Help`, and its `MenuItem` labeled
    `About` with an On Action of `showAbout`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Menu`的Text值应设置为`_Edit`。它的`MenuItem`应标记为`_Settings`，并具有`showPreferences`的On
    Action值。最后，第三个`Menu`应标记为`_Help`，其`MenuItem`标记为`About`，具有`showAbout`的On Action值。
- en: Next, we want to give `ListView` an ID, so select that on the left, make sure
    the Code section is expanded on the right, and enter `entriesListView` for fx:id.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要给`ListView`一个ID，所以在左侧选择它，确保右侧展开了Code部分，然后输入`entriesListView`作为fx:id。
- en: The last edit we need to make is to set the controller. We do that in the accordion
    on the left, in the Controller section at the very bottom. Expand that, and make
    sure that the Controller class value matches the Java class and package we just
    created in NetBeans, then save the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个编辑是设置控制器。我们在左侧的手风琴中进行，找到最底部的Controller部分。展开它，并确保Controller类的值与我们在NetBeans中刚刚创建的Java类和包匹配，然后保存文件。
- en: Setting up the controller
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制器
- en: 'Back in NetBeans, we need to fix up our controller to reflect the changes we
    just made in our FXML. In `SunagoController`, we need to add the `entriesListView`
    property as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回到NetBeans，我们需要修复我们的控制器，以反映我们刚刚在FXML中所做的更改。在`SunagoController`中，我们需要添加`entriesListView`属性如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that the parameterized type is `SocialMediaItem`. That''s a custom model
    we''ll create in just a few moments. Before we tackle that, though, we need to
    finish wiring together our user interface. We defined three `onAction` handlers
    in the FXML. The corresponding code is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数化类型是`SocialMediaItem`。这是我们马上要创建的自定义模型。在我们着手处理之前，我们需要完成将用户界面连接在一起。我们在FXML中定义了三个`onAction`处理程序。相应的代码如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Closing the application is as simple as calling the `exit` method on the `Platform`
    class. Showing the "about" box is also fairly simple, as we see in the `showAbout`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭应用程序就是简单地在`Platform`类上调用`exit`方法。显示“关于”框也相当简单，正如我们在`showAbout`方法中看到的：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the built-in `Alert` class, we construct an instance, and set the values
    appropriate for an About screen, then display it modally via `showAndWait()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`Alert`类，我们构建一个实例，并设置适用于关于屏幕的值，然后通过`showAndWait()`模态显示它。
- en: The preferences window is a much more complicated piece of logic, so we wrap
    that up in a new controller class, and call its `showAndWait()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首选项窗口是一个更复杂的逻辑，所以我们将其封装在一个新的控制器类中，并调用其`showAndWait()`方法。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing the model class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型类
- en: 'Before we look at that, though, there are a few more items in the main controller
    that we need to take care of. The first is the model class mentioned earlier,
    `SocialMediaItem`. As you can probably imagine, the structure of the data returned
    from a social network can be quite complex, and certainly, varied. The data requirements
    for a tweet, for example, are likely to be quite different from those for an Instagram
    post. What we''d like to be able to do, then, is to hide those complexities and
    differences behind a simple, reusable interface. In the real world, such a simple
    abstraction is not always possible, but, for our purposes here, we have such an
    interface in `SocialMediaItem`, as you can see in this piece of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看这个之前，主控制器中还有一些项目需要处理。首先是之前提到的模型类`SocialMediaItem`。你可能可以想象到，从社交网络返回的数据结构可能非常复杂，而且多种多样。例如，推文的数据需求可能与Instagram帖子的数据需求大不相同。因此，我们希望能够将这些复杂性和差异隐藏在一个简单、可重用的接口后面。在现实世界中，这样一个简单的抽象并不总是可能的，但是在这里，我们有一个名为`SocialMediaItem`的接口，你可以在这段代码中看到：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One of the problems with abstractions is that, to make them reusable, you, occasionally,
    have to structure them in such a way that they expose properties that may not
    be used by every implementation. It's not obvious yet, but that is certainly the
    case here. It's a scenario that some consider to be unacceptable, and they may
    have a point, but it's really a question of trade-offs. Our options include a
    slightly bloated interface or a complex system in which each network support module
    (which we'll get to shortly) provides its own renderer, and the application has
    to interrogate each module, looking for the renderer that can handle each item
    while drawing `ListView`. There are likely others, of course, but faced with (at
    least) those two, for the sake of simplicity and performance, we'll take the first
    option. When faced with similar situations while designing your own systems, though,
    you'll need to evaluate the various requirements of your project, and make an
    appropriate choice. For our needs here, the simple approach is more than adequate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的一个问题是，为了使它们可重用，偶尔需要以这样的方式构造它们，以便它们暴露可能不被每个实现使用的属性。尽管目前还不明显，但在这里肯定是这种情况。有些人认为这种情况是不可接受的，他们可能有一定道理，但这确实是一个权衡的问题。我们的选择包括略微臃肿的接口或一个复杂的系统，其中每个网络支持模块（我们很快就会介绍）都提供自己的渲染器，并且应用程序必须询问每个模块，寻找可以处理每个项目的渲染器，同时绘制`ListView`。当然还有其他选择，但至少有这两个选择，为了简单和性能的缘故，我们将选择第一种选择。然而，在设计自己的系统时面临类似情况时，您需要评估项目的各种要求，并做出适当的选择。对于我们这里的需求，简单的方法已经足够了。
- en: 'At any rate, each social media network module will implement that interface
    to wrap its data. This will give a common interface for the application to consume
    without needing to know exactly where it came from. We do, though, now need to
    tell the `ListView` how to draw a cell containing a `SocialMediaItem`. We can
    do that with this line of code in the `initialize()` method of our controller,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，每个社交媒体网络模块都将实现该接口来包装其数据。这将为应用程序提供一个通用接口，而无需知道确切的来源。不过，现在我们需要告诉`ListView`如何绘制包含`SocialMediaItem`的单元格。我们可以在控制器的`initialize()`方法中使用以下代码来实现：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obviously, that''s a lambda. For the curious, the pre-lambda version of the
    preceding method would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个lambda。对于好奇的人来说，前面方法的lambda之前的版本将如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finishing up the controller
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成控制器
- en: 'Before we look at `SocialMediaItemViewCell`, there are two more controller
    items. The first is the list that holds the `ListView` data. Remember that `ListView`
    operates from an `ObservableList`. This lets us make changes to the data in the
    list, and have it automatically reflected in the user interface. To create that
    list, we''ll use a JavaFX helper method when we define the class property as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`SocialMediaItemViewCell`之前，还有两个控制器项目。第一个是保存`ListView`数据的列表。请记住，`ListView`是从`ObservableList`操作的。这使我们能够对列表中的数据进行更改，并自动反映在用户界面中。为了创建该列表，我们将在定义类属性时使用JavaFX辅助方法，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we need to connect that `List` to our `ListView`. Back in `intialize()`,
    we have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将该`List`连接到我们的`ListView`。回到`initialize()`，我们有以下内容：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To finish off the rendering of `SocialMediaItem` interfaces, let''s define
    `SocialMediaItemViewCell` like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`SocialMediaItem`接口的呈现，让我们这样定义`SocialMediaItemViewCell`：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's a fair amount happening here, but `updateItem()` is our first point
    of interest. This is the method that is called every time the row is updated on
    the screen. Notice that we check to see if `item` is null. We do that because
    `ListView` calls this method not for every item in its `List`, but for every row
    in `ListView` that's visible, whether there's data for it or not. That means that,
    if `List` has five items but `ListView` is tall enough to show ten rows, this
    method will be called ten times, with the last five calls being made with a null
    `item`. In those cases, we call `setGraphic(null)` to clear out any item that
    may have been previously rendered.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但`updateItem()`是我们首要关注的地方。这是每次在屏幕上更新行时调用的方法。请注意，我们检查`item`是否为空。我们这样做是因为`ListView`不是为其`List`中的每个项目调用此方法，而是为`ListView`中可见的每一行调用，无论是否有数据。这意味着，如果`List`有五个项目，但`ListView`足够高以显示十行，此方法将被调用十次，最后五次调用将使用空的`item`进行。在这种情况下，我们调用`setGraphic(null)`来清除先前呈现的任何项目。
- en: If `item` is not null, though, we need to build the `Node` to display the item,
    which is done in `buildItemCell()`. For each item, we want to render three items--the
    social media network icon (so users can tell at a glance where the item is from),
    any image embedded in the item, and, finally, any text/caption from the item.
    To help arrange that, we start with an `HBox`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`item`不为空，我们需要构建用于显示项目的`Node`，这是在`buildItemCell()`中完成的。对于每个项目，我们希望呈现三个项目--社交媒体网络图标（用户可以一眼看出项目来自哪里）、项目中嵌入的任何图像，以及最后，项目中的任何文本/标题。为了帮助安排，我们从`HBox`开始。
- en: Next, we try to find an icon for the network. If we had a formal contract written
    up, we would include language in it that would stipulate that the module include
    a file called `icon.png`, which is in the same package as the module's `SocialMediaItem`
    implementation. Using the `ClassLoader` for the implementation, then, we try to
    get an `InputStream` for the resource. We check for null, just to make sure the
    image was actually found; if so, we create an `ImageView`, set some properties,
    then wrap the resource in an `Image`, hand that to `ImageView`, then add `ImageView`
    to `HBox`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试查找网络的图标。如果我们有一份正式的合同书，我们将在其中包含语言，规定模块包含一个名为`icon.png`的文件，该文件与模块的`SocialMediaItem`实现在同一个包中。然后，使用实现的`ClassLoader`，我们尝试获取资源的`InputStream`。我们检查是否为空，只是为了确保实际找到了图像；如果是，我们创建一个`ImageView`，设置一些属性，然后将资源包装在`Image`中，将其交给`ImageView`，然后将`ImageView`添加到`HBox`中。
- en: Adding an image for the item
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目添加图像
- en: If the item has an image, we handle it in the same way that we did with the
    network icon image. This time, though, we actually wrap the `ImageView` in another
    `HBox` before adding it to the outer `HBox`. We do that so that we can add padding
    around the image (via `picture.setPadding(new Insets()`) to give this image some
    space between it and the network icon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该项目有图片，我们会以与网络图标图片相同的方式处理它。不过，这一次，我们实际上是在将`ImageView`添加到外部`HBox`之前将其包装在另一个`HBox`中。我们这样做是为了能够在图像周围添加填充（通过`picture.setPadding(new
    Insets())`）以便在图像和网络图标之间留出一些空间。
- en: Finally, we create a `Label` to hold the item's body. We set the font size of
    the text to `20` points via `label.setFont(Font.font(null, 20))`, and add it to
    our `HBox`, which we then return to the caller, `updateItem()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`Label`来容纳项目的正文。我们通过`label.setFont(Font.font(null, 20))`将文本的字体大小设置为`20`点，并将其添加到我们的`HBox`，然后将其返回给调用者`updateItem()`。
- en: Any time you have a `ListView`, you are likely going to want a custom `ListCell`
    implementation like we have here. In some cases, calling `toString()` on the `List`
    contents might be appropriate, but that's not always the case, and you certainly
    can't have a complex `ListCell` structure like we have here without implementing
    `ListCell` yourself. If you're planning on doing much JavaFX development, you
    would be well advised to get comfortable with this technique.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有一个`ListView`时，您可能会想要一个像我们这里一样的自定义`ListCell`实现。在某些情况下，调用`List`内容的`toString()`可能是合适的，但并不总是如此，而且您肯定不能在没有自己实现`ListCell`的情况下拥有像我们这里一样复杂的`ListCell`结构。如果您计划进行大量的JavaFX开发，最好熟悉这种技术。
- en: Building the preferences user interface
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建首选项用户界面
- en: 'We''re finally **finished** with the main controller, and we can turn our attention
    to the next big piece, `PreferencesController`. Our preferences dialog will be,
    as is usually expected, a modal dialog. It will offer a tabbed interface with
    one tab for general settings, then a tab for each supported social network. We
    start that work by adding a new FXML file and controller to our project, and NetBeans
    has a great wizard for that. Right-click on the desired package, and click on
    New | Other. From the Categories list, select `JavaFX`, and then, from the File
    Types lists, select `Empty FXML` as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了主控制器，现在可以把注意力转向下一个重要部分，`PreferencesController`。我们的首选项对话框通常是一个模态对话框。它将提供一个带有一个用于常规设置的选项卡，然后是每个支持的社交网络的选项卡的选项卡界面。我们通过向项目添加新的FXML文件和控制器来开始这项工作，NetBeans有一个很好的向导。右键单击所需的包，然后单击New
    | Other。从类别列表中，选择`JavaFX`，然后从文件类型列表中选择`Empty FXML`，如下面的屏幕截图所示：
- en: '![](img/bc7b7536-4970-4c03-9740-36023c951ae8.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc7b7536-4970-4c03-9740-36023c951ae8.png)'
- en: 'After clicking on Next, you should see the FXML Name and Location step. This
    will allow us to specify the name of our new file and the package in which it
    is created, as seen in this screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”后，您应该会看到FXML名称和位置步骤。这将允许我们指定新文件的名称和创建它的包，就像在这个屏幕截图中看到的那样：
- en: '![](img/f80f3d0b-47e9-4791-9a1f-1d553fc6c25d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f80f3d0b-47e9-4791-9a1f-1d553fc6c25d.png)'
- en: 'Clicking on Next brings us to the Controller Class step. Here we can either
    create a new controller class, or attach our file to an existing one. Since this
    is a new dialog/window for our app, we need to create a new controller as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”将带我们到控制器类步骤。在这里，我们可以创建一个新的控制器类，或将我们的文件附加到现有的控制器类。由于这是我们应用程序的一个新对话框/窗口，我们需要创建一个新的控制器，如下所示：
- en: '![](img/5315164e-af28-4892-803d-c3a72a365bfd.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5315164e-af28-4892-803d-c3a72a365bfd.png)'
- en: Check the Use Java Controller checkbox, enter `PreferencesController` for the
    name, and select the desired package. We could click on Next, which would take
    us to the Cascading Style Sheet step, but we're not interested in specifying that
    for this controller, so, we end the wizard by clicking on Finish, which will take
    us to the source of our newly created controller class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选“使用Java控制器”复选框，输入`PreferencesController`作为名称，并选择所需的包。我们可以点击“下一步”，这将带我们到层叠样式表步骤，但我们对于这个控制器不感兴趣，所以我们通过点击“完成”来结束向导，这将带我们到我们新创建的控制器类的源代码。
- en: Let's start by laying out the user interface. Double-click on the new `prefs.fxml`
    file to open it in Scene Builder. Like our last FXML file, the default root element
    is AnchorPane. For this window, we'd like to use a BorderPane, so we use the same
    technique that we did last time to replace AnchorPane--right-click on the component,
    and click on Wrap in | BorderPane. The AnchorPane is now nested in BorderPane,
    so we right-click on it again and select Delete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从布局用户界面开始。双击新的`prefs.fxml`文件以在Scene Builder中打开它。与我们上一个FXML文件一样，默认的根元素是AnchorPane。对于这个窗口，我们想要使用BorderPane，所以我们使用了与上次替换AnchorPane相同的技术--右键单击组件，然后单击Wrap
    in | BorderPane。AnchorPane现在嵌套在BorderPane中，所以我们再次右键单击它，然后选择删除。
- en: To build the user interface, we now drag a TabPane control from the accordion
    on the left, and drop it in the CENTER area of BorderPane. This will add a TabPane
    with two tabs to our user interface. We only want one right now, so delete the
    second one. We want to give our tab a meaningful label. We can do that by double-clicking
    on the tab in the preview window (or selecting the Text property in the Properties
    section of the Inspector) and typing `General`. Finally, expand the Inspector's
    Code section, and enter `tabPane` for fx:id.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建用户界面，我们现在从左侧的手风琴中拖动一个TabPane控件，并将其放在BorderPane的CENTER区域。这将在我们的用户界面中添加一个具有两个选项卡的TabPane。我们现在只想要一个，所以删除第二个。我们想要给我们的选项卡一个有意义的标签。我们可以通过双击预览窗口中的选项卡（或在检查器的属性部分中选择Text属性）并输入`General`来实现。最后，展开检查器的代码部分，并输入`tabPane`作为fx:id。
- en: Now we need to provide a means by which the user can close the window, and either
    save or discard changes. We implement that by dragging a ButtonBar component to
    our border pane's BOTTOM area. That will add a ButtonBar with one button, but
    we need two, so we drag another button on to the ButtonBar. The nice thing about
    this control is that it will handle button placement and padding for us, so, when
    we drop the new button, it's automatically added in the proper place on the right.
    (This behavior can be overridden, but it works exactly how we want it to, so we
    can just accept the defaults.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要提供一种方式，让用户可以关闭窗口，并保存或放弃更改。我们通过将ButtonBar组件拖动到边界面的BOTTOM区域来实现这一点。这将添加一个带有一个按钮的ButtonBar，但我们需要两个，所以我们将另一个按钮拖到ButtonBar上。这个控件的好处是它会为我们处理按钮的放置和填充，所以当我们放置新按钮时，它会自动添加到正确的位置。
    （这种行为可以被覆盖，但它正是我们想要的，所以我们可以接受默认值。）
- en: For each `Button`, we need to set three properties--`text`, `fx:id`, and `onAction`.
    The first property is in the Properties section of the inspector, and the last
    two in the Code section. The values for the first button are `Save`, `savePrefs`,
    and `savePreferences`. For the second button, the values are `Cancel`, `cancel`,
    and `closeDialog`. Select the Layout section for the `ButtonBar` in the inspector,
    and set the right padding to 10 to make sure `Button` is not pressed against the
    edge of the window.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`Button`，我们需要设置三个属性--`text`，`fx:id`和`onAction`。第一个属性在Inspector的Properties部分中，最后两个在Code部分。第一个按钮的值分别是`Save`，`savePrefs`和`savePreferences`。对于第二个按钮，值分别是`Cancel`，`cancel`和`closeDialog`。在Inspector中选择`ButtonBar`的Layout部分，并将右填充设置为10，以确保`Button`不会紧贴窗口边缘。
- en: Finally, we'll add our only preference at this point. We want to allow the user
    to specify the maximum number of items to retrieve from each social media network
    for a given request. We do that for those scenarios where the application hasn't
    been used in a while (or ever). In those cases, we don't want to try to download,
    for example, thousands of tweets. To add support for this, we add two controls,
    `Label` and `TextField`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在这一点上添加我们唯一的偏好设置。我们希望允许用户指定从每个社交媒体网络中检索的最大项目数。我们这样做是为了那些应用程序长时间未被使用（或从未被使用）的情况。在这些情况下，我们不希望尝试下载成千上万条推文。为了支持这一点，我们添加两个控件，`Label`和`TextField`。
- en: 'Getting the position of the Label control right is pretty simple, as it''s
    the first component. Scene Builder will provide red guidelines to help you position
    the component exactly where you want it, as shown in this screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将Label控件的位置设置正确非常简单，因为它是第一个组件。Scene Builder将提供红色指南线，以帮助您将组件放置在所需位置，如下截图所示：
- en: '![](img/0c1cdf3f-96b1-49b5-917d-9033d21b1b47.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c1cdf3f-96b1-49b5-917d-9033d21b1b47.png)'
- en: Making sure that `TextField` is lined up with the label can be trickier. By
    default, when you drop a component on TabPane, Scene Builder will add an AnchorPane
    to hold the new components. An HBox might be a better choice, but we'll go ahead
    and use AnchorPane to demonstrate this feature of Scene Builder. If you drag a
    TextField onto TabPane and try to position it, you should see more red lines show
    up. Positioned just right, you should see a red line running through the middle
    of the Label and the `TextField`, indicating that the two components are vertically
    aligned. This is what we want, so make sure there is a small space between `TextField`
    and the label and drop it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`TextField`与标签对齐可能会更加棘手。默认情况下，当您将组件放置在TabPane上时，Scene Builder会添加一个AnchorPane来容纳新组件。HBox可能是一个更好的选择，但我们将继续使用AnchorPane来演示Scene
    Builder的这个特性。如果您将TextField拖放到TabPane并尝试定位它，您应该会看到更多的红线出现。定位正确后，您应该会看到一条红线穿过标签和`TextField`的中间，表示这两个组件在垂直方向上对齐。这正是我们想要的，所以确保`TextField`和标签之间有一小段空间，然后放置它。
- en: We need to give Label some meaningful text, so double-click on it in the preview
    window, and enter `Number of items to retrieve`. We also need to give `TextField`
    an ID so that we can interact with it, so click on the component, expand the Code
    section in the Inspector, and set fx:id to `itemCount`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给Label一些有意义的文本，所以在预览窗口中双击它，输入`要检索的项目数量`。我们还需要为`TextField`设置一个ID，以便与之交互，所以点击组件，在Inspector中展开Code部分，将fx:id设置为`itemCount`。
- en: Our user interface, while basic, is now as complete as we can make it here,
    so save the file, close Scene Builder, and return to NetBeans.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面虽然基本，但在这里已经尽可能完整，所以保存文件，关闭Scene Builder，并返回到NetBeans。
- en: Saving user preferences
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存用户偏好设置
- en: 'To allow our newly-defined user interface to be wired into our controller,
    we need to create instance variables to match the controls with the `fx:id` attributes
    set, so, we add these to `PreferencesController` as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们新定义的用户界面与我们的控制器连接，我们需要创建与设置了`fx:id`属性的控件相匹配的实例变量，因此，我们将这些添加到`PreferencesController`中，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `initialize()` method, we need to add support for loading the saved value
    for our `itemCount` field, so we need to talk a little bit about preferences.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，我们需要添加对加载保存值的支持，因此我们需要稍微讨论一下偏好设置。
- en: Java, being the general-purpose language that it is, makes it possible to write
    any preference storing strategy that you can image. Fortunately, though, it also
    offers a couple of different standard APIs that allow you to do so in a more easily
    portable manner, those being `Preferences` and `Properties`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java作为通用语言，使得可以编写任何偏好存储策略。幸运的是，它还提供了一些不同的标准API，允许您以更容易移植的方式进行操作，其中包括`Preferences`和`Properties`。
- en: The `java.util.Properties` class has been in the JDK since version 1.0, and
    while its basic, no-frills API might make that obvious, it's still a very useful
    abstraction. At its heart, `Properties` is a `Hashtable` implementation to which
    methods have been added for loading its data from input streams and readers, and
    writing its data to output streams and writers (in addition to a handful of other
    related methods). All the properties are treated as `String` values with `String`
    keys. Since `Properties` is a `Hashtable`, you can still use `put()` and `putAll()`
    to store non-string data, but that will result in `ClassCastException` should
    you call `store()`, so, it's probably best to avoid doing that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Properties`类自JDK 1.0版本以来就存在，虽然它的基本、简约的API可能很明显，但它仍然是一个非常有用的抽象。在其核心，`Properties`是一个`Hashtable`的实现，它添加了从输入流和读取器加载数据以及将数据写入输出流和写入器的方法（除了一些其他相关的方法）。所有属性都被视为`String`值，具有`String`键。由于`Properties`是一个`Hashtable`，您仍然可以使用`put()`和`putAll()`来存储非字符串数据，但如果调用`store()`，这将导致`ClassCastException`，因此最好避免这样做。'
- en: The `java.util.prefs.Preferences` class was added in Java 1.4, and it's a much
    more modern API. Whereas with properties we have to handle persistence separately,
    preferences handle that for us opaquely--we don't need to worry about how or when
    it's written. In fact, the call to set a preference may return immediately, while
    the actual persistence may not occur for quite some time. The contract of the
    `Preferences` API guarantees that preferences will be persisted even if the JVM
    shuts down, assuming it's a normal, ordered shutdown (by definition, there's not
    much that can be done if the JVM process suddenly dies).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.prefs.Preferences`类是在Java 1.4中添加的，它是一个更现代的API。与属性不同，我们必须单独处理持久性，偏好设置为我们不透明地处理这一点--我们不需要担心它是如何或何时写入的。实际上，设置偏好设置的调用可能会立即返回，而实际的持久性可能需要相当长的时间。`Preferences`
    API的契约保证了即使JVM关闭，偏好设置也会被持久化，假设这是一个正常的、有序的关闭（根据定义，如果JVM进程突然死机，几乎没有什么可以做的）。'
- en: Additionally, the user also need not worry about how preferences are saved.
    The actual backing store is an implementation-specific detail. It could be a flat
    file, an OS-specific registry, a database or some sort of directory server. For
    the curious, the actual implementation is chosen by using the class name, if specified,
    in the `java.util.prefs.PreferencesFactory` system property. If that's not defined,
    the system will look for the file `META-INF/services/java.util.prefs.PreferencesFactory`
    (a mechanism known as SPI, which we will look at in depth later), and use the
    first class defined there. Finally, failing that, the implementation for the underlying
    platform is loaded and used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户也不需要担心偏好设置是如何保存的。实际的后备存储是一个特定于实现的细节。它可以是一个平面文件，一个特定于操作系统的注册表，一个数据库或某种目录服务器。对于好奇的人，实际的实现是通过使用类名来选择的，如果指定了的话，在`java.util.prefs.PreferencesFactory`系统属性中。如果没有定义，系统将查找文件`META-INF/services/java.util.prefs.PreferencesFactory`（这是一种称为SPI的机制，我们稍后会深入研究），并使用那里定义的第一个类。最后，如果失败，将加载和使用底层平台的实现。
- en: So which to choose? Either will work as well as the other, but you have to decide
    if you want control of where the information is stored (`Properties`) or ease
    of implementation (`Preferences`). To a certain degree, portability might also
    be a concern. For example, if you have Java code running in some sort of a mobile
    or embedded device, you might not have permissions to write to the filesystem,
    and you might not have a filesystem at all. To show how similar the two implementations
    might be, though, we'll implement both.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应该选择哪一个呢？两者都可以正常工作，但您必须决定是否要控制信息存储的位置（`Properties`）或实现的便利性（`Preferences`）。在一定程度上，可移植性也可能是一个问题。例如，如果您的Java代码在某种移动设备或嵌入式设备上运行，您可能没有权限写入文件系统，甚至可能根本没有文件系统。然而，为了展示这两种实现可能有多相似，我们将同时实现两者。
- en: 'To put my cards on the table a little bit, I would like for as much of this
    code as possible to be reusable in an Android environment. To help facilitate
    that, we''ll create a very simple interface as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了坦率一点，我希望尽可能多的代码可以在Android环境中重复使用。为了帮助实现这一点，我们将创建一个非常简单的接口，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're only dealing with strings and integers, as the needs of the application
    are pretty basic. With the interface defined, how do we get a reference to an
    implementation? For that, we'll use a technique we've already seen mentioned briefly--the
    Service Provider Interface (SPI).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只处理字符串和整数，因为应用程序的需求非常基本。接口定义好了，我们如何获取对实现的引用呢？为此，我们将使用一种我们已经简要提到过的技术--服务提供者接口（SPI）。
- en: Plugins and extensions with the Service Provider Interface
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务提供者接口的插件和扩展
- en: We've already seen SPI mentioned before when we looked at the `Preferences`
    class, and how the implementation is selected and loaded, but what exactly is
    it? The Service Provider Interface is a somewhat generic term for an interface
    that a third party can implement (or a class, abstract or not, that can be extended)
    to provide extra functionality, replace existing components, and more.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经在查看`Preferences`类时提到过SPI，以及如何选择和加载实现，但它到底是什么呢？服务提供者接口是一个相对通用的术语，用于指代第三方可以实现的接口（或者可以扩展的类，无论是否抽象），以提供额外的功能，替换现有组件等。
- en: In a nutshell, the author of the target system (for example, the JDK itself
    in our previous example) defines and publishes an interface. Ideally, this system
    would provide a default implementation, but that's not necessary in all cases.
    Any interested third party could then implement this interface, register it, and
    the target system could then load and use it. One of the advantages of this approach
    is that the target system can be extended easily, with no coupling to the third
    party. That is to say, while the third party knows about the target system via
    the interface, the target system has no knowledge at all of the third party. It's
    merely operating off the interface it defined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，目标系统的作者（例如，我们之前的例子中的JDK本身）定义并发布一个接口。理想情况下，该系统会提供一个默认实现，但并非所有情况都需要。任何感兴趣的第三方都可以实现这个接口，注册它，然后目标系统可以加载和使用它。这种方法的一个优点是，目标系统可以很容易地进行扩展，而不需要与第三方进行耦合。也就是说，虽然第三方通过接口了解目标系统，但目标系统对第三方一无所知。它只是根据自己定义的接口进行操作。
- en: How are these third-party plugins registered with the target system? The third-party
    developer would create a text file using a specific file in a specific directory.
    The file has the same name as the interface being implemented. For the `Preferences`
    class example, one would be implementing the `java.util.prefs.PreferencesFactory`
    interface, so that would be the name of the file, which would be in the `META-INF/services`
    directory in the root of the libraries classpath. In a Maven-based project, the
    file would be found in `src/main/resources/META-INF/services`. The file contains
    just the name of the class implementing the interface. It's also possible to have
    more than one class listed in the services file, each on a new line. It's up to
    the consuming system, though, as to whether or not each of those might be used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些第三方插件是如何注册到目标系统的？第三方开发人员将在特定目录中使用特定文件创建一个文本文件。该文件的名称与正在实现的接口相同。例如，对于`Preferences`类的示例，将实现`java.util.prefs.PreferencesFactory`接口，因此该文件的名称将是该接口的名称，该文件将位于类路径根目录中的`META-INF/services`目录中。在基于Maven的项目中，该文件将在`src/main/resources/META-INF/services`中找到。该文件只包含实现接口的类的名称。也可以在服务文件中列出多个类，每个类占一行。但是，是否使用其中的每一个取决于消费系统。
- en: So what does all of this look like for us? As noted earlier, we're going to
    take a rare opportunity to show multiple implementations for our `Preferences`
    support. Both classes are small enough that we can show the uses of both `Properties`
    and `Preferences`, and use SPI to pick one to use.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对于我们来说，所有这些是什么样子的呢？正如前面所述，我们将有一个难得的机会展示我们的`Preferences`支持的多个实现。这两个类都足够小，我们可以展示`Properties`和`Preferences`的用法，并使用SPI来选择其中一个使用。
- en: 'Let''s start with the `Properties`-based implementation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于`Properties`的实现开始：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we start by implementing our `SunagoPreferences` interface.
    We then create an instance of the `Properties` class, and we also define a constant
    for the file name and location, which we put--in a system-independent manner--in
    the user's home directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先实现了我们的`SunagoPreferences`接口。然后我们创建了一个`Properties`类的实例，并且我们还为文件名和位置定义了一个常量，我们将其以一种与系统无关的方式放在用户的主目录中。
- en: Resource handling with try-with-resources
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try-with-resources进行资源处理
- en: 'The constructor shows something interesting that we haven''t talked about--try-with-resources.
    Prior to Java 8, you might have written something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数显示了一个有趣的东西，我们还没有讨论过--try-with-resources。在Java 8之前，你可能会写出这样的代码：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This preceding, incredibly verbose code declares an `InputStream` outside the
    try block, then does some work with it in the `try` block. In the `finally` block,
    we try to close the `InputStream`, but we first have to check to see if it's null.
    If, say, the file doesn't exist (as it won't be the first time this class is created),
    an `Exception` will be thrown, and `input` will be null. If it's not null, we
    can call `close()` on it, but that might throw `IOException`, so we have to wrap
    that in a `try/catch` block as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码在try块外声明了一个`InputStream`，然后在`try`块中对其进行了一些处理。在`finally`块中，我们尝试关闭`InputStream`，但首先必须检查它是否为null。例如，如果文件不存在（因为这是该类创建的第一次），将抛出`Exception`，并且`input`将为null。如果它不为null，我们可以在其上调用`close()`，但这可能会引发`IOException`，因此我们还必须将其包装在`try/catch`块中。
- en: Java 8 introduced the try-with-resources construct that makes this much smaller.
    If an object is an instance of `AutoCloseable`, then it can be defined **inside**
    the `try` declaration, and it will be closed automatically when the `try` block
    scope terminates regardless of whether or not an `Exception` was thrown. That
    allows us to take what would normally be fourteen lines of code, and express the
    exact same functionality in four with much less noise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了try-with-resources结构，使得代码变得更加简洁。如果一个对象是`AutoCloseable`的实例，那么它可以在`try`声明中被定义，无论是否抛出`Exception`，当`try`块范围终止时，它都会被自动关闭。这使我们可以用更少的噪音将通常需要十四行代码来表达的功能表达为四行代码。
- en: Aside from `AutoCloseable`, note that we load any existing values in the file
    into our `Properties` instance via `Properties.load(InputStream)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AutoCloseable`之外，注意我们通过`Properties.load(InputStream)`将文件中的任何现有值加载到我们的`Properties`实例中。
- en: 'Moving on, what we see next are pretty straightforward getters and setters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到的是非常简单的getter和setter：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final method is the one that writes our preferences back out, which is
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是将我们的偏好设置重新写出的方法，如下所示：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This last method looks a lot like our constructor, but we create an `OutputStream`,
    and call `Properties.store(OutputStream)` to write our values out to a file. Note
    that we call this method from every put method to make sure, insofar as possible,
    that the user preferences are faithfully persisted to disk.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一个方法看起来很像我们的构造函数，但我们创建了一个`OutputStream`，并调用`Properties.store(OutputStream)`将我们的值写入文件。请注意，我们从每个put方法调用此方法，以尽可能确保用户偏好设置被忠实地保存到磁盘上。
- en: What would a Preferences-based implementation look like? Not much different.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基于偏好设置的实现会是什么样子？并没有太大的不同。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Two things to note. First, we don't need to handle persistence, as `Preferences`
    does that for us. Second, the instantiation of the `Preferences` instance needs
    some attention. Clearly, I think, we want these preferences to be scoped to the
    user, so we start with `Preferences.userRoot()` to get the root preference node.
    Then we ask for the node in which we want to store our preferences, which we have
    chosen to name after the package of our class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事需要注意。首先，我们不需要处理持久性，因为`Preferences`已经为我们做了。其次，`Preferences`实例的实例化需要一些注意。显然，我认为，我们希望这些偏好设置是针对用户的，因此我们从`Preferences.userRoot()`开始获取根偏好设置节点。然后我们要求存储我们偏好设置的节点，我们选择将其命名为我们类的包的名称。
- en: Where does that put things? On Linux, the file might look something like `~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml`
    (yes, that's a directory name). On Windows, those preferences are saved in the
    Windows Registry under the key `HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com.steeplesoft.sunago.app`.
    Unless you want to interact directly with these files, though, their exact location
    and format are merely implementation details. Sometimes, though, it's a good thing
    to know.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样放置的东西在哪里？在Linux上，文件可能看起来像`~/.java/.userPrefs/_!':!bw"t!#4!cw"0!'`!~@"w!'w!~@"z!'8!~g"0!#4!ag!5!')!c!!u!(:!d@"u!'%!~w"v!#4!}@"w!(!=/prefs.xml`（是的，那是一个目录名）。在Windows上，这些偏好设置保存在Windows注册表中，键为`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com.steeplesoft.sunago.app`。但是，除非您想直接与这些文件交互，否则它们的确切位置和格式仅仅是实现细节。不过，有时候了解这些是件好事。
- en: 'We have two implementations, so how do we pick which one to use? In the file
    (including the source root for clarity) `src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences`,
    we can put one of these two lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种实现，那么我们如何选择使用哪一种？在文件（包括源根以便清晰）`src/main/resources/META-INF/service/com.steeplesoft.sunago.api.SunagoPreferences`中，我们可以放置以下两行之一：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can list both, but only the first will be chosen, which we''ll see now.
    To make things simple, we''ve wrapped this up in a utility method as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以列出两者，但只会选择第一个，我们现在将看到。为了简化，我们已经将其封装在一个实用方法中，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In what may be a bit of an overkill for our purposes here, we've implemented
    a singleton by declaring the instance of the `SunagoPreferences` interface as
    a private static, and made it available via a synchronized method, which checks
    for `null`, and creates the instance if needed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可能有点过度，我们通过将`SunagoPreferences`接口的实例声明为私有静态实现了单例，并通过一个同步方法使其可用，该方法检查`null`，并在需要时创建实例。
- en: While that's interesting, don't let it distract you from the meat of the method.
    We use the `ServiceLoader.load()` method to ask the system for any implementations
    of the `SunagoPreferences` interface. It's worth noting again, just to be clear,
    that it won't pick up **any** implementation in the system, but **only** those
    listed in the services file we described earlier. Using the `ServiceLoader<SunagoPreferences>`
    instance, we grab an iterator, and if it has an entry (`iterator.hasNext()`),
    we return that instance (`iterator.next()`). If it does not, we return `null`.
    There is a chance here for a `NullPointerException` since we are returning `null`,
    but we're also providing an implementation, so we avoid that risk. However, in
    your own code, you need to either ensure you have an implementation as we've done
    here, or to make sure that the consuming code is `null`-ready.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有趣，但不要让它让你分心。我们使用`ServiceLoader.load()`方法向系统请求`SunagoPreferences`接口的任何实现。值得再次注意的是，为了明确起见，它不会捡起**任何**系统中的实现，而只会捡起我们之前描述的服务文件中列出的**那些**。使用`ServiceLoader<SunagoPreferences>`实例，我们获取一个迭代器，如果它有一个条目（`iterator.hasNext()`），我们返回该实例（`iterator.next()`）。如果没有，我们返回`null`。这里有一个`NullPointerException`的机会，因为我们返回`null`，但我们也提供了一个实现，所以我们避免了这种风险。然而，在您自己的代码中，您需要确保像我们在这里所做的那样有一个实现，或者确保消费代码是`null`-ready。
- en: Adding a network - Twitter
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个网络 - Twitter
- en: So far, we have a pretty basic application, which can save and load its preferences,
    but let's get down to what we're here for and start connecting to social networks.
    What we hope to develop is a framework that makes it easy to add support for different
    social networks. Technically, as we'll soon see, the **network** need not even
    be social as the only thing that will imply a specific type of source is the name
    of the classes and interfaces involved. However, we will, in fact, focus on social
    networks, and we'll use a couple of different ones to show some variety. To that
    end, we'll start with Twitter, the massively popular microblogging platform, and
    Instagram, the increasingly photo-focused network that is now part of Facebook.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个非常基本的应用程序，可以保存和加载其偏好设置，但让我们开始连接社交网络，这才是我们在这里的目的。我们希望开发一个框架，使得轻松添加对不同社交网络的支持成为可能。从技术上讲，正如我们很快会看到的那样，**网络**甚至不需要是社交的，因为唯一会暗示特定类型来源的是所涉及的类和接口的名称。然而，事实上，我们将专注于社交网络，并且我们将使用一些不同的社交网络来展示一些多样性。为此，我们将从Twitter开始，这是一个非常受欢迎的微博平台，以及Instagram，这是一个越来越注重照片的网络，现在已经成为Facebook的一部分。
- en: Speaking of Facebook, why are we not demonstrating integration with that social
    network? Two reasons--One, it's not significantly different from Twitter, so there
    would not be much that was new to cover; two, most importantly, the permissions
    that Facebook offers make it virtually impossible to integrate with it in a way
    that would be of interest here. For example, the permission to read a user's home
    timeline (or wall) is only granted to applications targeted at those platforms
    where Facebook is not currently available, and not at all to desktop applications,
    which is our target here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Facebook，为什么我们不演示与该社交网络的集成？有两个原因--一，它与Twitter没有显著不同，因此没有太多新内容需要涵盖；二，更重要的是，Facebook提供的权限几乎不可能以对我们感兴趣的方式集成。例如，读取用户的主页时间线（或墙）的权限仅授予针对那些Facebook当前不可用的平台的应用程序，而且根本不授予桌面应用程序，而这正是我们的目标。
- en: As noted previously, we'd like to expose a way to add more networks without
    having to change the core application, so we need to develop an API. What we'll
    cover here is that API in a more or less **finished** state (is any software every
    truly finished?). However, while you will see a reasonably complete API, a word
    of caution--attempts to create an abstraction that start with that abstraction--that
    is, writing the abstraction from scratch--rarely end well. It is usually best
    to write a specific implementation to get a better understanding of the details
    required, then extract an abstraction. What you will see here is the end result
    of that process, so that process will not be covered here in any depth.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望能够在不更改核心应用程序的情况下公开添加更多网络的方法，因此我们需要开发一个API。我们将在这里介绍一个或多或少**完成**状态的API（任何软件真的会完成吗？）。然而，虽然您将看到一个相当完整的API，但需要注意一点——试图从头开始创建一个抽象的尝试很少有好的结果。最好是编写一个具体的实现来更好地理解所需的细节，然后提取一个抽象。您在这里看到的是这个过程的最终结果，因此这个过程不会在这里深入讨论。
- en: Registering as a Twitter developer
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册为Twitter开发者
- en: 'To create an application that integrates with Twitter, we need to create a
    Twitter developer account, and then create a Twitter application. To create the
    account, we need to visit [https://dev.twitter.com](https://dev.twitter.com/),
    and click on the Join button. Once you''ve created your developer account, you
    can click the My Apps link to go to [https://apps.twitter.com](https://apps.twitter.com/).
    Here, we need to click on the Create New App button, which will get us a form
    that looks a bit like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个与Twitter集成的应用程序，我们需要创建一个Twitter开发者帐户，然后创建一个Twitter应用程序。要创建帐户，我们需要访问[https://dev.twitter.com](https://dev.twitter.com/)，然后点击加入按钮。创建开发者帐户后，您可以点击我的应用链接转到[https://apps.twitter.com](https://apps.twitter.com/)。在这里，我们需要点击创建新应用程序按钮，这将为我们提供一个看起来有点像这样的表单：
- en: '![](img/e752561f-28a8-4dcc-a226-30986a4e13a8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e752561f-28a8-4dcc-a226-30986a4e13a8.png)'
- en: While the application we're developing is called *Sunago*, you won't be able
    to use that name, as it's already taken; you'll have to create a unique name of
    your own, assuming you're planning to run the application yourself. Once you've
    created the application, you'll be taken to the Application Management page for
    your new app. From this page, you can manage your app's permissions and keys,
    and, if needed, you can delete your app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在开发的应用程序被称为*Sunago*，但您将无法使用该名称，因为它已经被使用；您将需要创建一个自己独特的名称，假设您打算自己运行该应用程序。创建应用程序后，您将被带到新应用程序的应用程序管理页面。从这个页面，您可以管理应用程序的权限和密钥，如果需要，还可以删除应用程序。
- en: One thing to note on this page, as we'll need this soon, is where to find your
    application's Consumer Key and Secret. These are long, alphanumeric strings that
    your application will use to authenticate with Twitter's services. To interact
    with Twitter on behalf of a user--our ultimate goal--requires a different set
    of tokens, which we'll fetch shortly. Your Consumer Key and Secret--especially,
    Consumer Secret--should be kept, well, secret. If this combination is ever revealed
    publicly, other users will be able to masquerade as your app, potentially causing
    you serious headaches if they abuse the service. For that reason, you won't see
    the key/secret combination I generated anywhere in this book or the source code,
    which is why you will need to generate your own.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上需要注意的一件事是，我们很快就会需要的应用程序的Consumer Key和Secret的位置。这些是长的，包含字母和数字的字符串，您的应用程序将使用它们来验证Twitter的服务。代表用户与Twitter互动的最终目标需要一组不同的令牌，我们很快就会获取。您的Consumer
    Key和Secret，尤其是Consumer Secret，应该保密。如果这个组合被公开，其他用户就可以冒充您的应用程序，如果他们滥用服务，可能会给您带来严重的麻烦。因此，您不会在本书或源代码中看到我生成的密钥/秘钥组合，这就是为什么您需要生成自己的组合。
- en: Armed now with our Consumer Key and Secret, we need to decide how to talk to
    Twitter. Twitter offers a public REST API, which they document on their site.
    If we were so inclined, we could pick an HTTP client of some sort, and start making
    calls. In the interests of simplicity and clarity, though, not to mention robustness,
    fault tolerance, and so on, we might be better served using a higher-level library
    of some sort. As luck would have it, there is a such a library, Twitter4J, which
    will make our integration much simpler and cleaner (for the curious, Twitter4J
    has over 200 Java classes. While we won't need all of the functionality represented
    there and exposed via the REST API, it should give you an idea of the scope of
    the effort required to write a reasonable wrapper for Twitter's REST interface).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在拥有了我们的Consumer Key和Secret，我们需要决定如何与Twitter交流。Twitter提供了一个公共的REST API，在他们的网站上有文档。如果我们愿意，我们可以选择某种HTTP客户端，并开始调用。然而，出于简单和清晰的考虑，更不用说健壮性、容错性等等，我们可能更好地使用某种更高级的库。幸运的是，有这样一个库，Twitter4J，它将使我们的集成更简单、更清晰（对于好奇的人来说，Twitter4J有200多个Java类。虽然我们不需要所有这些功能，但它应该让您了解编写Twitter的REST接口的合理封装所需的工作范围）。
- en: 'As mentioned earlier, we want to be able to add networks to Sunago without
    having to change the core application, so we will write our Twitter integration
    in a separate Maven module. This will require that some of the code we''ve already
    written for Sunago be extracted into yet another module. Both our Twitter module
    and the main application module will then add a dependency on this new module.
    Since we''ll have multiple modules at play here, we''ll be sure to indicate to
    which module each class belongs. When we''re finished, our project dependency
    graph will look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望能够在不更改核心应用程序的情况下向Sunago添加网络，因此我们将在一个单独的Maven模块中编写我们的Twitter集成。这将需要将我们已经为Sunago编写的一些代码提取到另一个模块中。然后我们的Twitter模块和主应用程序模块将依赖于这个新模块。由于我们将有多个模块参与，我们将确保指出每个类属于哪个模块。完成后，我们的项目依赖图将如下所示：
- en: '![](img/f6941c98-9f1e-449b-b2be-2dfad92ae836.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6941c98-9f1e-449b-b2be-2dfad92ae836.png)'
- en: Technically, the only reason we show a dependency between the Application module
    and the Instagram and Twitter modules is because we're building them as part of
    the same project. A third-party developer, as we'll see, could easily develop
    an independent module, add it to the application's runtime classpath, and see
    the change in the application, all without this build-level dependency. Hopefully,
    though, this graph helps explain how the modules are related.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们之所以显示应用程序模块和Instagram和Twitter模块之间的依赖关系，是因为我们正在将它们作为同一项目的一部分构建。正如我们将看到的那样，第三方开发人员可以轻松地开发一个独立的模块，将其添加到应用程序的运行时类路径中，并在不涉及构建级别依赖的情况下看到应用程序的变化。不过，希望这个图表能帮助解释模块之间的关系。
- en: Adding Twitter preferences to Sunago
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Twitter偏好添加到Sunago
- en: 'Let''s start by adding Twitter to our preferences screen. Before we can do
    any integration, we need to be able to configure the application, or, more accurately,
    the Twitter module, so that it can connect as a specific user. To enable that,
    we''ll add a new interface to the API module as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在偏好设置屏幕上添加Twitter开始。在我们进行任何集成之前，我们需要能够配置应用程序，或者更准确地说，Twitter模块，以便它可以连接为特定用户。为了实现这一点，我们将向API模块添加一个新接口，如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This interface will give Sunago two hooks into the module--one giving the module
    a chance to draw its own preferences user interface, and one to allow it to save
    those preferences. We can then implement that in our module. Before we do so,
    though, let''s see how the application will find these implementations so that
    they can be used. For that, we will again turn to SPI. In Sunago''s `PreferencesController`
    interface, we add this code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口将为Sunago提供两个钩子进入模块--一个是让模块有机会绘制自己的偏好用户界面，另一个是允许它保存这些偏好。然后我们可以在我们的模块中实现它。不过，在我们这样做之前，让我们看看应用程序将如何找到这些实现，以便它们可以被使用。为此，我们将再次转向SPI。在Sunago的`PreferencesController`接口中，我们添加了这段代码：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have an instance variable to hold a list of any `SocialMediaPreferencesController`
    instances we find. Next, in `initialize()`, we call the now familiar `ServiceLoader.load()`
    method to find any implementations, which we then add to the `List` that we created
    previously. Once we have our list of controllers, we call `getTab()` on each of
    them, adding the returned `Tab` instance to the `PreferencesController` interface's
    `tabPane`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个实例变量来保存我们找到的任何`SocialMediaPreferencesController`实例的列表。接下来，在`initialize()`中，我们调用现在熟悉的`ServiceLoader.load()`方法来查找任何实现，然后将其添加到我们之前创建的`List`中。一旦我们有了我们的控制器列表，我们就对每个控制器调用`getTab()`，将返回的`Tab`实例添加到`PreferencesController`接口的`tabPane`中。
- en: 'With the loading part clarified, let''s now take a look at the Twitter preferences
    user interface implementation. We start by implementing the controller that will
    back this part of the user interface as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 加载部分澄清后，让我们现在来看一下Twitter偏好用户界面的实现。我们首先要实现控制器，以支持用户界面的这一部分，如下所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll take a look at `TwitterClient` in a moment, but, first, a note on `getTab()`.
    Notice that we create the `Tab` instance, which we need to return, but we delegate
    the creation of its contents to the `getNode()` method. `Tab.setContent()` allows
    us to completely replace the contents of the tab with a single call, something
    we''ll make use of next. The `getNode()` method looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快看一下`TwitterClient`，但首先，关于`getTab()`的一点说明。请注意，我们创建了`Tab`实例，我们需要返回它，但我们将其内容的创建委托给`getNode()`方法。`Tab.setContent()`允许我们完全替换选项卡的内容，这是我们接下来要使用的。`getNode()`方法看起来像这样：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the user has already authenticated, then we want to present some configuration
    options. If not, then we need to offer a means to connect to Twitter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经进行了身份验证，那么我们希望呈现一些配置选项。如果没有，那么我们需要提供一种连接到Twitter的方式。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this simple user interface, we create an `HBox` primarily so we can add some
    padding. Without the `new Insets(10)` instance we pass to `setPadding()`, our
    button would be pressed right up against the top and left edges of the window,
    which is not visually appealing. Next, we create the `Button`, and set the `onAction`
    handler (ignore that constructor parameter for now).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的用户界面中，我们创建了一个`HBox`主要是为了添加一些填充。如果没有我们传递给`setPadding()`的`new Insets(10)`实例，我们的按钮将紧贴窗口的顶部和左边缘，这在视觉上是不吸引人的。接下来，我们创建了`Button`，并设置了`onAction`处理程序（暂时忽略构造函数参数）。
- en: 'The interesting part is hidden away in `connectToTwitter`, as shown in this
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分隐藏在`connectToTwitter`中，如下所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: OAuth and logging on to Twitter
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth和登录到Twitter
- en: 'We''ll take a detour into `LoginController` in just a moment, but first, let''s
    make sure we understand what''s going on here. To log on to Twitter on behalf
    of a user, we need to generate an OAuth request token from which we get an authorization
    URL. The details of which are hidden nicely behind the Twitter4J API, but it is,
    basically, the OAuth authorization URL listed on the Application Management page
    with a request token passed as a query string. As we''ll see, this URL is opened
    in a `WebView`, which prompts the user to authenticate against Twitter, and then
    authorize the application (or decline to):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快进入`LoginController`，但首先，让我们确保我们理解这里发生了什么。为了代表用户登录到Twitter，我们需要生成一个OAuth请求令牌，从中获取授权URL。这些细节被很好地隐藏在Twitter4J
    API的后面，但基本上，它是在应用程序管理页面上列出的OAuth授权URL，带有作为查询字符串传递的请求令牌。正如我们将看到的那样，这个URL在`WebView`中打开，提示用户对Twitter进行身份验证，然后授权应用程序（或拒绝）：
- en: '![](img/fc55781d-1f06-44c5-8e30-9a1fc0cce901.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc55781d-1f06-44c5-8e30-9a1fc0cce901.png)'
- en: 'If the user successfully authenticates and authorizes the application, the
    `WebView` is redirected to a success page, which displays a numeric code that
    we need to capture to finish gathering the authentication/authorization credentials
    needed. The success page might look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功进行了身份验证并授权了应用程序，`WebView`将被重定向到一个成功页面，显示一个我们需要捕获的数字代码，以完成收集所需的身份验证/授权凭据。成功页面可能如下所示：
- en: '![](img/348599c5-134b-469d-87de-5f1b287bce0a.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/348599c5-134b-469d-87de-5f1b287bce0a.png)'
- en: For those not familiar with OAuth, what this allows us to do is to authenticate
    as the user, now and at any arbitrary moment in the future, without needing to
    store the user's actual password. The end result of this handshake between our
    application and Twitter is a token and token secret, which we'll pass to Twitter
    for authentication. As long as this token is valid--the user can invalidate it
    at any time via Twitter's web interface--we can connect and act as that user.
    Should the key ever be compromised, the user can revoke the key, affecting only
    the intended app and anyone attempting to use the stolen key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉OAuth的人来说，这允许我们在现在和将来的任意时刻作为用户进行身份验证，而无需存储用户的实际密码。我们的应用程序与Twitter之间的这次握手的最终结果是一个令牌和令牌密钥，我们将传递给Twitter进行身份验证。只要这个令牌是有效的——用户可以随时通过Twitter的网络界面使其失效——我们就可以连接并作为该用户进行操作。如果密钥被泄露，用户可以撤销密钥，只影响预期的应用程序和任何试图使用被盗密钥的人。
- en: '`LoginController`, which is part of the API module, handles all of the boilerplate
    code for us, as seen in this code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginController`是API模块的一部分，它为我们处理所有样板代码，如下所示：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This preceding code is a basic FXML-backed JavaFX controller, but we do have
    a static helper method to handle the details of creating, configuring, and showing
    an instance. We load the scene using FXML, get the controller (which is an instance
    of the enclosing class), set the `loginSuccessTest` and `handler` properties,
    and then show the dialog.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个基本的FXML支持的JavaFX控制器，但我们有一个静态的辅助方法来处理创建、配置和显示实例的细节。我们使用FXML加载场景，获取控制器（它是封闭类的实例），设置`loginSuccessTest`和`handler`属性，然后显示对话框。
- en: Do `loginSuccessTest` and `handler` look odd? They are instances of the Java
    8 functional interfaces `Predicate<T>` and `Consumer<T>`. `Predicate` is a functional
    interface that takes a type, `WebEngine` in our case, and returns a `boolean`.
    It is designed to check for a certain condition given a variable of the specified
    type. In this instance, we call `WebEngine.executeScript().contains()` to extract
    a piece of the document, and see if it contains a certain piece of text indicating
    that we've been redirected to the login success page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`loginSuccessTest`和`handler`看起来奇怪吗？它们是Java 8功能接口`Predicate<T>`和`Consumer<T>`的实例。`Predicate`是一个功能接口，它接受一个类型，我们的情况下是`WebEngine`，并返回一个`boolean`。它旨在检查给定指定类型的变量的某个条件。在这种情况下，我们调用`WebEngine.executeScript().contains()`来提取文档的一部分，并查看它是否包含指示我们已被重定向到登录成功页面的某个文本片段。'
- en: '`Consumer<T>` is a functional interface (or, in our case, a lambda) that takes
    a single parameter of the specified type, and returns void. Our handler is a `Consumer`,
    which is called once our `Predicate` returns true. The lambda extracts the code
    from the HTML page, calls `saveTwitterAuthentication()` to finish authenticating
    the user, then `showConfigurationUI()` to change the user interface so that the
    user can configure Twitter-related settings.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>`是一个功能接口（或者在我们的情况下，是一个lambda），它接受指定类型的单个参数，并返回void。我们的处理程序是一个`Consumer`，一旦我们的`Predicate`返回true，就会被调用。Lambda从HTML页面中提取代码，调用`saveTwitterAuthentication()`完成用户身份验证，然后调用`showConfigurationUI()`来更改用户界面，以便用户可以配置与Twitter相关的设置。'
- en: 'The method `saveTwitterAuthentication()` is very straightforward, and is given
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveTwitterAuthentication()`方法非常简单，如下所示：'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method `twitter.getAccessToken()` takes our request token and the code we
    extracted from the web page, and sends an HTTP `POST` to a Twitter REST endpoint,
    which generates the token secret we need. When that request returns, we store
    the token and token secret to our `Preferences` store (again, oblivious to where
    and how).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`twitter.getAccessToken()`方法接受我们的请求令牌和我们从网页中提取的代码，并向Twitter REST端点发送HTTP `POST`，生成我们需要的令牌密钥。当该请求返回时，我们将令牌和令牌密钥存储到我们的`Preferences`存储中（再次，不知道在哪里和如何）。'
- en: The method `showConfigurationUI()` and the related method should also be familiar.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`showConfigurationUI()`方法和相关方法也应该很熟悉。'
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One new item in this preceding method is the listener we add to the `selectedProperty`
    of the `CheckBox`. Any time the selected value changes, our listener is called,
    which sets the value of the `showHomeTimeline` boolean.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中的一个新项目是我们添加到`CheckBox`的`selectedProperty`的监听器。每当选定的值发生变化时，我们的监听器被调用，它设置`showHomeTimeline`布尔值的值。
- en: 'The `ListView` also needs special attention. Notice the parameterized type,
    `SelectableItem<UserList>`. What is that? That''s an abstract class we''ve created
    to wrap items for use in `CheckBoxListCell`, which you can see in the call to
    `setCellFactory()`. That class looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`也需要特别注意。注意参数化类型`SelectableItem<UserList>`。那是什么？那是我们创建的一个抽象类，用于包装`CheckBoxListCell`中使用的项目，你可以在对`setCellFactory()`的调用中看到。该类看起来像这样：'
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class, which lives in the API module, is a simple wrapper around an arbitrary
    type that adds a `SimpleBooleanProperty`. We see how this property is manipulated
    when the cell factory is set up--`lv.setCellFactory(CheckBoxListCell .forListView(item
    -> item.getSelected()))`. We expose `SimpleBooleanProperty` via the `getSelected()`
    method, which the `CheckBoxListCell` uses to set and read the state of each line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类位于API模块中，是一个简单的包装器，包装了一个任意类型，添加了一个`SimpleBooleanProperty`。我们看到当设置单元格工厂时如何操作这个属性——`lv.setCellFactory(CheckBoxListCell
    .forListView(item -> item.getSelected()))`。我们通过`getSelected()`方法公开`SimpleBooleanProperty`，`CheckBoxListCell`使用它来设置和读取每行的状态。
- en: 'Our final user interface-related method is this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个与用户界面相关的方法是这样的：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the same `SelectableItem` class, we request from Twitter all of the lists
    the user might have created, which we wrap in `SelectableUserList`, a `SelectableItem`
    child that overrides the `toString()` method to provide user-friendly text in
    `ListView`. We load any checked lists from preferences, set their respective booleans/checkboxes,
    and update our `ObservableList` and, thus, the user interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的`SelectableItem`类，我们从Twitter请求用户可能创建的所有列表，我们将其包装在`SelectableUserList`中，这是`SelectableItem`的子类，覆盖`toString()`方法以在`ListView`中提供用户友好的文本。我们从首选项加载任何选中的列表，设置它们各自的布尔值/复选框，并更新我们的`ObservableList`，从而更新用户界面。
- en: 'The final method we need to implement to satisfy the `SocialMediaPreferencesController`
    contract is `savePreferences()`, which is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个方法来满足`SocialMediaPreferencesController`合同是`savePreferences()`，如下所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a mostly straightforward saving of the user's options to preferences,
    but the list handling is worth pointing out. Rather than manually iterating over
    each item in the list, we can use a stream and apply a couple of `filter()` operations
    to strip out entries that are of no interest to us, `map()` each `SelectableUserList`
    that makes it through to `Long` (which is the list's ID), then collect them in
    a `List<String>`. We join that `List` using `String.join()`, and write it out
    to our preferences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是将用户的选项保存到偏好设置中，但是列表处理值得一提。我们可以使用流并应用一对`filter()`操作来剔除对我们没有兴趣的条目，然后将通过的每个`SelectableUserList`映射到`Long`（即列表的ID），然后将它们收集到`List<String>`中。我们使用`String.join()`连接该`List`，并将其写入我们的偏好设置。
- en: Adding a model for Twitter
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Twitter添加一个模型
- en: 'There are still a couple of other interfaces that we need to implement to finish
    our Twitter support. The first, and simpler, one is `SocialMediaItem`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他接口我们需要实现来完成我们的Twitter支持。第一个，也是更简单的一个是`SocialMediaItem`：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This preceding interface provides us with a nice abstraction over the various
    types of data that a social network might return without being too heavily burdened
    with fields that aren''t used by most (or many, at least) networks. The Twitter
    implementation of this `Tweet` class is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前面的接口为我们提供了一个很好的抽象，可以在不太拖沓的情况下返回社交网络可能返回的各种类型的数据，而不会被大多数（或至少很多）网络不使用的字段所拖累。这个`Tweet`类的Twitter实现如下：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Taking the Twitter4J class `Status`, we extract information of interest to
    us, and store it in instance variables (whose getters are not shown, as they''re
    just simple getters). For the `getImage()` method, we make a reasonable effort
    to extract any image from the tweet, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Twitter4J类`Status`提取我们感兴趣的信息，并将其存储在实例变量中（它们的getter没有显示，因为它们只是简单的getter）。对于`getImage()`方法，我们会合理努力从推文中提取任何图像，如下所示：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementing a Twitter client
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Twitter客户端
- en: 'The second interface is `SocialMediaClient`. This interface serves not only
    as an abstraction that Sunago can use to interact with an arbitrary social network
    integration, but also as a guideline for interested developers to show them the
    minimum requirements for the integration. It looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个接口是`SocialMediaClient`。这个接口不仅作为Sunago可以用来与任意社交网络集成交互的抽象，还作为一个指南，向有兴趣的开发人员展示集成的最低要求。它看起来像这样：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For Twitter support, this preceding interface is implemented by the class `TwitterClient`.
    Most of the class is pretty basic, so we won''t reproduce that here (you can peruse
    it in the source repository if you''d like details), but one implementation detail
    might be worth spending some time over. That method is `processList()`, which
    is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Twitter支持，这个前面的接口由类`TwitterClient`实现。大部分类都很基本，所以我们不会在这里重复（如果您想了解详情，可以在源代码库中查看），但是一个实现细节可能值得花一些时间。那个方法是`processList()`，如下所示：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are several things going on in this last method. First, we want to limit
    how many tweets we actually retrieve. If this is the first time the app is used,
    or the first time that it's used in a long time, there could be a significant
    number of tweets. Retrieving all of them would be quite expensive in terms of
    network usage, memory and, perhaps, processing time. We implement that limit using
    the `Paging` object from Twitter4J.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的方法中有几件事情。首先，我们想限制实际检索的推文数量。如果这是应用程序首次使用，或者长时间以来首次使用，可能会有大量的推文。检索所有这些推文在网络使用、内存和处理时间方面都会非常昂贵。我们使用Twitter4J的`Paging`对象来实现这个限制。
- en: We also don't want to retrieve tweets we already have, so, for each list, we
    keep a `sinceId`, which we can pass to the Twitter API. It will use this to find
    up to the specified number of tweets whose ID is greater than `sinceId`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不想检索我们已经拥有的推文，所以对于每个列表，我们保留一个`sinceId`，我们可以传递给Twitter API。它将使用这个来查找ID大于`sinceId`的指定数量的推文。
- en: Wrapping all of this up in the `Paging` object, we call either `twitter.getHomeTimeline()`
    if the list ID is `-1` (an internal ID we've used to identify the home timeline)
    or `twitter.getUserListStatus()` for a user-defined list. For each `Status` returned,
    we update `sinceId` (which we've modeled using an `AtomicLong`, as any method
    variable used inside a lambda must be final or effectively final), and add the
    tweet to our `List`. Before exiting, we store `sinceId` for the list in our in-memory
    store, and then return the tweets for the Twitter list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些封装在`Paging`对象中，如果列表ID为`-1`（我们用来标识主页时间线的内部ID），我们调用`twitter.getHomeTimeline()`，或者对于用户定义的列表，我们调用`twitter.getUserListStatus()`。对于每个返回的`Status`，我们更新`sinceId`（我们使用`AtomicLong`对其进行建模，因为在lambda内部使用的任何方法变量必须是final或有效final），并将推文添加到我们的`List`中。在退出之前，我们将列表的`sinceId`存储在我们的内存存储中，然后返回Twitter列表的推文。
- en: A brief look at internationalization and localization
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和本地化的简要介绍
- en: 'While somewhat basic, our integration with Twitter is now complete, as it fulfills
    our functional requirements for the network. However, there is one more piece
    of code that we need to take a quick look at. Earlier, in some of the code samples,
    you might have noticed code that looks like this: `MessageBundle.getInstance().getString("homeTimelineCB")`.
    What is that, and what does it do?'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些基本，但我们与Twitter的集成现在已经完成，因为它满足了我们对网络的功能要求。然而，还有一段代码需要我们快速看一下。在之前的一些代码示例中，您可能已经注意到了类似这样的代码：`MessageBundle.getInstance().getString("homeTimelineCB")`。那是什么，它是做什么的？
- en: 'The `MessageBundle` class is a small wrapper around the internationalization
    and localization facilities (also known as i18n and l10n, where the numbers represent
    the number of letters dropped from the words to make the abbreviation) provided
    by the JDK. The code for this class is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBundle`类是JDK提供的国际化和本地化设施（也称为i18n和l10n，其中数字代表从单词中删除的字母数量以缩写）的一个小包装器。该类的代码如下：'
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are two main items of interest here. We'll start at the end of the class
    with the `getInstance()` method. This is an example of what is known as the **initialize
    on demand holder** (**IODH**) pattern. There is a single, static instance of the
    class `MessageBundle` in the JVM. It is not initialized, however, until the `getInstance()`
    method is called. This is accomplished by taking advantage of how the JVM loads
    and initializes statics. As soon as a class is referenced in any way, it is loaded
    into `ClassLoader`, at which point any statics on the class will be initialized.
    The private static class `LazyHolder` is **not** initialized until the JVM is
    sure that something needs to access it. Once we call `getInstance()`, which references
    `LazyHolder.INSTANCE`, the class is initialized and the singleton instance created.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个主要的注意事项。我们将从`getInstance()`方法的类末尾开始。这是所谓的**按需初始化持有者**（**IODH**）模式的一个示例。在JVM中有一个`MessageBundle`类的单个静态实例。但是，直到调用`getInstance()`方法之前，它才会被初始化。这是通过利用JVM加载和初始化静态的方式实现的。一旦类以任何方式被引用，它就会被加载到`ClassLoader`中，此时类上的任何静态都将被初始化。私有静态类`LazyHolder`直到JVM确信需要访问它之前才会被初始化。一旦我们调用`getInstance()`，它引用`LazyHolder.INSTANCE`，类就被初始化并创建了单例实例。
- en: It should be noted that are ways around the singleton nature we're trying to
    implement (for example, via reflection), but our use case here does not warrant
    any worries over such an attack.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们正在尝试实现的单例性质有办法绕过（例如，通过反射），但是我们在这里的用例并不需要担心这样的攻击。
- en: The actual functionality is implemented in the first line of the class, which
    is as follows
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际功能是在类的第一行实现的，如下所示
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `ResourceBundle` files, in the words of the Javadoc, *contain locale-specific
    objects*. Usually, this means Strings, as it does in our case. The `getBundle()`
    method will attempt to find and load a bundle with the name given for the specified
    locale. In our case, we're looking for a bundle named `Messages`. Technically,
    we're looking for a bundle in a family of bundles with the shared base name `Messages`.
    The system will use the `Locale` specified to find the correct file. This resolution
    will follow the same lookup logic that `Locale` uses, so the `getBundle()` method
    will return the bundle with the most specific matching name available.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceBundle`文件在Javadoc的话语中*包含特定于区域设置的对象*。通常，这意味着字符串，就像在我们的情况下一样。`getBundle()`方法将尝试查找并加载具有指定区域设置的给定名称的包。在我们的情况下，我们正在寻找一个名为`Messages`的包。从技术上讲，我们正在寻找一个具有共享基本名称`Messages`的包系列中的包。系统将使用指定的`Locale`来查找正确的文件。此解析将遵循`Locale`使用的相同查找逻辑，因此`getBundle()`方法将返回具有最具体匹配名称的包。'
- en: 'Let''s say we''re running this application on my computer. I live in the United
    States, so my system''s default locale is `en_US`. Following the rules of the
    `Locale` lookup, then, `getBundle()` will try to locate files in this order:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在我的计算机上运行此应用程序。我住在美国，因此我的系统默认区域设置是`en_US`。然后，根据`Locale`查找规则，`getBundle()`将尝试按照以下顺序定位文件：
- en: '`Messages_en_US.properties`.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages_en_US.properties`。'
- en: '`Messages_en.properties`.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages_en.properties`。'
- en: '`Messages.properties`.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Messages.properties`。'
- en: 'The system will go from the most specific file to the least until it finds
    the key requested. If it''s not found in any file, `MissingResourceException`
    is thrown. Each file consists of key/value pairs. Our `Messages.properties` file
    looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将从最具体的文件到最不具体的文件，直到找到所请求的键。如果在任何文件中找不到，将抛出`MissingResourceException`。每个文件都由键/值对组成。我们的`Messages.properties`文件如下所示：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is just a simple mapping of keys to localized text. We could have `Messages_es.properties`
    with this line:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个简单的键到本地化文本的映射。我们可以在`Messages_es.properties`中使用这一行：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If that were the only entry in the file, that one label in the file would be
    in Spanish, with everything else being in the default from `Message.properties`,
    which, in our case, is English.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是文件中唯一的条目，那么文件中的一个标签将是西班牙语，其他所有内容都将是默认的`Message.properties`，在我们的情况下是英语。
- en: Making our JAR file fat
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作我们的JAR文件变得臃肿
- en: With that, our implementation is now complete. Before this can be used in the
    way we intend, though, we need to make a build change. If you recall the discussion
    of the requirements at the beginning of the chapter, we want to build a system
    that easily allows third-party developers to write modules that will add support
    for arbitrary social networks without the need to modify the core application.
    To deliver that functionality, these developers would need to offer a JAR that
    Sunago users could drop in a folder. When the application is started, the new
    functionality is now available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的实现现在已经完成。但在可以按照我们的意图使用之前，我们需要进行构建更改。如果您回忆一下本章开头对需求的讨论，我们希望构建一个系统，可以轻松让第三方开发人员编写模块，以添加对任意社交网络的支持，而无需修改核心应用程序。为了提供这种功能，这些开发人员需要提供一个JAR文件，Sunago用户可以将其放入文件夹中。启动应用程序后，新功能现在可用。
- en: 'That leaves us, then, with the task of bundling all of the required code. As
    the project stands now, a single JAR is created, which holds just our classes.
    That''s not entirely sufficient, though, as we depend on the Twitter4J jar. Other
    modules could have even more dependencies. Requiring users to drop in, say, half
    a dozen or more jars is probably asking a bit much. Fortunately, Maven has a mechanism
    that will allow us to avoid that problem altogether: the shade plugin.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要打包所有所需的代码。目前，项目创建了一个单一的JAR，其中只包含我们的类。不过，这还不够，因为我们依赖于Twitter4J jar。其他模块可能有更多的依赖项。要求用户放入半打甚至更多的jar可能有点过分。幸运的是，Maven有一个机制，可以让我们完全避免这个问题：shade插件。
- en: 'By configuring this plugin in our build, we can generate a single jar that
    holds our classes and resources, plus those of every dependency declared in the
    project. This is often called a **fat jar**, and is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的构建中配置这个插件，我们可以生成一个单一的jar文件，其中包含我们项目中声明的每个依赖项的类和资源。这通常被称为**fat jar**，具体如下：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is an official Maven plugin, so we can omit `groupId`, and we've defined
    a property, `plugin.shade`, somewhere up the POM's inheritance tree. When the
    package phase is run, the shade goal of this plugin will execute and build our
    fat jar.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个官方的Maven插件，所以我们可以省略`groupId`，并且我们在POM的继承树上定义了一个名为`plugin.shade`的属性。当运行package阶段时，该插件的shade目标将执行并构建我们的fat
    jar。
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The original jar, which is considerably smaller, is renamed to `original-twitter-1.0-SNAPSHOT.jar`,
    and the fat jar receives the configured final name. It is this fat jar that is
    installed in the local maven repository, or deployed to an artifact manager, such
    as Artifactory.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的jar文件，大小相当小，被重命名为`original-twitter-1.0-SNAPSHOT.jar`，而fat jar接收配置的最终名称。就是这个fat
    jar被安装在本地maven仓库中，或者部署到像Artifactory这样的构件管理器中。
- en: 'There is a small bug, though. Our twitter module depends on the API module
    so that it can see the interfaces and classes exposed by the application. Currently,
    even those are included in the fat jar, which we don''t want, as that can cause
    some `ClassLoader` issues down the road in some situations. To prevent that, we
    mark that dependency as `provided`, as shown next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有一个小bug。我们的twitter模块依赖于API模块，以便它可以看到应用程序暴露的接口和类。目前，即使这些都包含在fat jar中，我们也不希望这样，因为在某些情况下，这可能会导致一些`ClassLoader`问题。为了防止这种情况，我们将该依赖标记为`provided`，如下所示：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we issue a `mvn clean install` now, we'll have a nice fat jar with only the
    classes we need to bundle, and one that's ready for distribution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行`mvn clean install`，我们将得到一个只包含我们需要捆绑的类的漂亮的fat jar，并且准备好进行分发。
- en: 'To make things as simple as possible, we''re just going to declare a dependency
    on this jar in Sunago''s app module, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简单，我们只需要在Sunago的应用模块中声明对这个jar的依赖，如下所示：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run Sunago now, we'll see Twitter added to our settings screen, and, once
    connected and configured, we'll see tweets showing up on the main screen. We'll
    also notice that the main screen is a little plain, and, more importantly, doesn't
    provide any way of refreshing the contents, so let's fix that.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行Sunago，我们将看到Twitter添加到我们的设置屏幕上，并且一旦连接和配置，我们将看到推文显示在主屏幕上。我们还会注意到主屏幕有点单调，更重要的是，没有提供任何刷新内容的方式，所以让我们来解决这个问题。
- en: Adding a refresh button
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个刷新按钮
- en: 'In the Projects window, find `sunago.fxml`, right-click on it, and select `Edit`.
    We''ll make this user interface change by hand, only for the sake of experience.
    Scroll down until you find the closing `Menubar` tag (`</Menubar>`). On the line
    right after that, insert these lines:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中，找到`sunago.fxml`，右键单击它，然后选择`Edit`。我们将手动进行这个用户界面的更改，只是为了体验。向下滚动，直到找到关闭的`Menubar`标签(`</Menubar>`)。在那之后的一行，插入这些行：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `SunagoController`, we need to add the instance variables as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SunagoController`中，我们需要添加实例变量如下：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, in `initialize()`, we need to set them up like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`initialize()`中，我们需要像这样设置它们：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that we're doing a bit more than setting up an action handler. The first
    thing we do is call `setGraphic()`. Remember from our discussion of the Twitter
    preference tab, calling `setGraphic()` will replace the child nodes with the `Node`
    that you specify. In these two cases, that `Node` is an `ImageView`, and comes
    from the `getButtonImage()` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们做的不仅仅是设置一个动作处理程序。我们做的第一件事是调用`setGraphic()`。从我们讨论的Twitter首选项选项卡中记得，调用`setGraphic()`将用你指定的`Node`替换子节点。在这两种情况下，该`Node`是一个`ImageView`，来自`getButtonImage()`方法。
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After we set the action handler, we also set a tooltip. This will give our
    graphical buttons a textual description when the user hovers over the button with
    the mouse, as seen in this screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置动作处理程序之后，我们还设置了一个工具提示。当用户用鼠标悬停在按钮上时，这将为我们的图形按钮提供一个文本描述，如下图所示：
- en: '![](img/dcf381cf-be06-40e4-bdc5-42afe47ba32e.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf381cf-be06-40e4-bdc5-42afe47ba32e.png)'
- en: 'The action handler for the refresh button is worth looking at, and is given
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新按钮的动作处理程序值得一看，如下所示：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the same method that we call from `initialize()`. Using the Service
    Provider Interface that we discussed earlier, we iterate over each `SocialMediaClient`
    available in the system. If the client has authenticated against its network,
    we call the `getItems()` method, and add whatever it may return to a local variable,
    `items`. Once we've queried all of the networks configured in the system, we then
    sort our list. This will cause the entries of the various networks to be intermingled,
    as they're sorted by their timestamps in descending chronological order. This
    sorted list is then added to our `ObservableList` at the head, or the zeroth element,
    to cause them to appear at the top of the list in the user interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从`initialize()`中调用的相同方法。使用我们之前讨论过的服务提供者接口，我们遍历系统中可用的每个`SocialMediaClient`。如果客户端已对其网络进行了身份验证，我们调用`getItems()`方法，并将其返回的任何内容添加到本地变量`items`中。一旦我们查询了系统中配置的所有网络，我们就对列表进行排序。这将导致各种网络的条目交错在一起，因为它们按照时间戳按降序排列。然后，将排序后的列表添加到我们的`ObservableList`的头部，或者第零个元素，以使它们出现在用户界面的顶部。
- en: Adding another network - Instagram
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加另一个网络 - Instagram
- en: So that we can see another type of integration, as well as to demonstrate how
    the interfaces we've defined make adding new networks relatively quick and easy,
    let's add one more network to Sunago--Instagram. While Instagram is owned by Facebook,
    at the time of this writing, its APIs are much more permissive than the social-media
    giant's, so we'll be able to add an interesting integration relatively easily.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们定义的接口如何使添加新网络相对快速和容易，以及让我们看到另一种集成类型，让我们向Sunago添加一个网络--Instagram。尽管Instagram是Facebook旗下的，但在撰写本文时，其API比这家社交媒体巨头更为宽松，因此我们能够相对轻松地添加一个有趣的集成。
- en: Much like with Twitter, we have a choice to make about how our interactions
    with the Instragram API will be handled. Just like Twitter, Instagram offers a
    public REST API that is secured using OAuth. Also, just like Twitter, though,
    manually implementing a client to consume those APIs is not an attractive proposition
    due to the level of effort required. Again, unless there's a compelling reason
    to write your own client library, I would suggest that using some sort of client
    wrapper should be the preferred route if one is available. Fortunately, there
    is--jInstagram.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与Twitter一样，我们需要考虑如何处理与Instragram API的交互。就像Twitter一样，Instagram提供了一个使用OAuth进行保护的公共REST
    API。同样，手动实现一个客户端来消费这些API并不是一个吸引人的选择，因为需要付出大量的努力。除非有充分的理由编写自己的客户端库，否则我建议如果有可用的客户端包装器，应该优先使用。幸运的是，有--jInstagram。
- en: Registering as an Instagram developer
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册为Instagram开发者
- en: 'Before starting to write our client, we need to register a new Instagram client
    with the service. We do that by first creating, if needed, an Instagram developer
    account at [https://www.instagram.com/developer](https://www.instagram.com/developer).
    Once we have an account, we need to register our application either by clicking
    the Register Your Application button on the page, or by visiting [https://www.instagram.com/developer/clients/manage/](https://www.instagram.com/developer/clients/manage/)
    directly. From here, we need to click on Register a New Client, which will present
    this form:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写我们的客户端之前，我们需要在服务中注册一个新的Instagram客户端。我们可以通过首先在[https://www.instagram.com/developer](https://www.instagram.com/developer)创建（如果需要）一个Instagram开发者帐户。一旦有了帐户，我们需要通过单击页面上的“注册您的应用程序”按钮或直接访问[https://www.instagram.com/developer/clients/manage/](https://www.instagram.com/developer/clients/manage/)来注册我们的应用程序。从这里，我们需要单击“注册新客户端”，将呈现此表单：
- en: '![](img/c71218c7-fd93-42a3-a406-0fd6450b5365.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c71218c7-fd93-42a3-a406-0fd6450b5365.png)'
- en: Once you've registered your new client, you can click on the Manage button on
    the resulting web page to get your client ID and secret. Hold on to those, as
    you'll need them in a moment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新客户端后，您可以单击生成的网页上的“管理”按钮，获取客户端ID和密钥。记住这些信息，因为您一会儿会用到它们。
- en: 'Next, we''ll start the actual client by creating a new module just like we
    did for the Twitter module. This one, though, we''ll call `Sunago - Instagram`
    and the `artifactIdinstagram`. We''ll also go ahead and add the jInstagram dependency
    as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个新模块来启动实际的客户端，就像我们为Twitter模块所做的那样。不过，这次我们将把它命名为`Sunago - Instagram`和`artifactIdinstagram`。我们还将添加jInstagram依赖，如下所示：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we have the Sunago `api` dependency added as well already, scoped
    as provided. We also need to add the Shade plugin configuration, which looks just
    like it does in the Twitter module, so it's not shown here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经添加了Sunago `api`依赖项，并将其范围设置为提供。我们还需要添加Shade插件配置，它看起来与Twitter模块中的配置相同，因此这里不再显示。
- en: Implementing the Instagram client
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Instagram客户端
- en: With our new module created, we need to create three specific items to fulfill
    the contract provided by the Sunago API module. We need `SocialMediaPreferencesController`,
    `SocialMediaClient`, and `SocialMediaItem`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新模块后，我们需要创建三个特定的项目来满足Sunago API模块提供的合同。我们需要`SocialMediaPreferencesController`、`SocialMediaClient`和`SocialMediaItem`。
- en: 'Our `SocialMediaPreferencesController` instance is `InstagramPreferencesController`.
    It has the same `getTab()` method required by the interface, which is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SocialMediaPreferencesController`实例是`InstagramPreferencesController`。它具有与接口所需的相同的`getTab()`方法，如下所示：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To save time and space, for this example, we''ve left the Instagram implementation
    much more basic than the one we created for Twitter, so the user interface definition
    does not hold much of interest. However, the authentication handling is interesting,
    as, while it has the same OAuth flow that Twitter uses, the data is returned in
    a manner that is much more easily consumed. The connect button calls this method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和空间，对于本示例，我们将Instagram的实现留得比我们为Twitter创建的实现更基本，因此用户界面定义并不那么有趣。但是，认证处理很有趣，因为尽管它使用与Twitter相同的OAuth流程，但返回的数据更容易消化。连接按钮调用此方法：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This uses the `LoginController` that we saw with Twitter, but our `Predicate`
    and `Consumer` are much more concise. The page to which the user is redirected
    has the code in the URL as a query parameter, so there''s no need to scrape the
    HTML. We can just pull it straight from the URL as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了我们在Twitter中看到的`LoginController`，但是我们的`Predicate`和`Consumer`要简洁得多。用户被重定向到的页面在URL中有代码作为查询参数，因此无需解析HTML。我们可以直接从URL中提取它如下：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once we have the code, we use an API on our `instagram` object to get the access
    token, which we then use to authenticate the user. So what does the `instagram`
    object look like? Like `TwitterClient`, `InstagramClient` is a `SocialMediaClient`
    that wraps the jInstagram API.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了代码，我们就可以使用`instagram`对象上的API来获取访问令牌，然后我们使用它来验证用户。那么`instagram`对象是什么样子的呢？像`TwitterClient`一样，`InstagramClient`是一个包装jInstagram
    API的`SocialMediaClient`。
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The jInstagram API has two objects that we need to use. `InstagramService`
    encapsulates the OAuth logic. We get an instance of it using a builder as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: jInstagram API有两个我们需要使用的对象。`InstagramService`封装了OAuth逻辑。我们使用构建器获取它的实例如下：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As discussed earlier, to run the application locally, you''ll need to provide
    your own API key and secret pair. The only use we have for the callback URL is
    to provide Instagram with a place to redirect our client to. Once it does that,
    we pull the code from the query parameters as we saw previously. Finally, we have
    to provide a list of scopes, which is what Instagram calls permissions, roughly.
    This list will allow us to get a list of the accounts that the authenticated user
    follows, which we''ll use to get images:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要在本地运行应用程序，您需要提供自己的API密钥和密钥对。我们对回调URL的唯一用途是为Instagram提供一个重定向我们客户端的地方。一旦它这样做，我们就从查询参数中提取代码，就像我们之前看到的那样。最后，我们必须提供一个权限列表，这就是Instagram称之为权限的东西。这个列表将允许我们获取经过身份验证的用户关注的帐户列表，我们将用它来获取图片：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you read the jInstagram documentation, you'll be tempted to use the method
    `instagram.getUserFeeds()`, and if you do, you'll get what I got--a `404` error
    page. Instagram has done some work on their API that jInstagram has not yet reflected.
    What we need to do, then, is implement our own wrapper for that, which jInstagram
    makes fairly simple. Here, we get a list of the people that the user follows.
    For each user, we call `processMediaForUser()` to fetch and store any pending
    images.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读了jInstagram文档，您可能会想使用`instagram.getUserFeeds()`方法，如果您这样做，您会得到我得到的东西-一个`404`错误页面。Instagram已经对其API进行了一些工作，而jInstagram尚未反映。因此，我们需要为此实现自己的包装器，jInstagram使这变得相当简单。在这里，我们获取用户关注的人的列表。对于每个用户，我们调用`processMediaForUser()`来获取和存储任何待处理的图片。
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using the same **since ID** and max count approach we used for the Twitter client,
    we request any recent media for the user. Each returned item is wrapped (via the
    lambda) in a `Photo` instance, which is our `SocialMediaItem` child for Instagram.
    Once we have our list, if it is not empty, we grab the first `Photo`, which we
    know is the oldest, because that's how the Instagram API returns its data, and
    we get the ID, which we store as the since ID for the next time this method is
    called. Finally, we return the `List` so that it can be added to the main `Photo`
    list given earlier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Twitter客户端相同的**since ID**和最大计数方法，我们请求用户的任何最新媒体。每个返回的项目都被（通过lambda）包装成`Photo`实例，这是我们的Instagram的`SocialMediaItem`子类。一旦我们有了列表，如果它不为空，我们就获取第一个`Photo`，我们知道它是最老的，因为这是Instagram
    API返回数据的方式，然后我们获取ID，将其存储为下次调用此方法时的since ID。最后，我们返回`List`，以便将其添加到之前给出的主`Photo`列表中。
- en: Loading our plugins in Sunago
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Sunago中加载我们的插件
- en: 'With that, our new integration is done. To see it in action, we add the dependency
    to Sunago''s POM as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的新集成就完成了。要看它的运行情况，我们将依赖项添加到Sunago的POM中如下：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We then run the application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行应用程序。
- en: 'Clearly, adding a dependency for each new integration is not an ideal solution,
    if for no other reason than that the user won''t be running the application from
    an IDE or with Maven. What we need, then, is a way for the application to find
    any modules (or plugins, if you prefer that term) at runtime on the user''s machine.
    The simplest solution would be to launch the application via a shell script like
    this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为每个新集成添加一个依赖项并不是一个理想的解决方案，即使只是因为用户不会从IDE或Maven中运行应用程序。因此，我们需要一种方法让应用程序在用户的机器上在运行时找到任何模块（或插件，如果您更喜欢这个术语）。最简单的解决方案是通过像这样的shell脚本启动应用程序：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This preceding shell script creates a classpath using the main Sunago jar, plus
    any JARs found in `~/.sunago`, and then runs the application. This is simple and
    effective, but does require per-operating system versions. Fortunately, that just
    means this shell script for Mac and Linux, plus a batch file for Windows. That's
    not hard to do or difficult to maintain, but it does require that you have access
    to those operating systems to test and verify your scripts.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 上述shell脚本使用主Sunago jar和`~/.sunago`中找到的任何JAR来创建类路径，然后运行应用程序。这很简单有效，但需要每个操作系统版本。幸运的是，这只需要为Mac和Linux编写这个shell脚本，以及为Windows编写一个批处理文件。这并不难做或难以维护，但需要您能够访问这些操作系统来测试和验证您的脚本。
- en: Another option is to make use of classloaders. As simple as it may seem to say
    it out loud, a `ClassLoader` is simply an object that is responsible for loading
    classes (and other resources). There are several classloaders at work in any given
    JVM, all arranged in a hierarchical fashion, starting with the bootstrap `ClassLoader`,
    then the platform `ClassLoader`, and, finally, the system--or application--`ClassLoader`.
    It is possible that a given application or runtime environment, such as a **Java
    Enterprise Edition** (**Java EE**) application server, might add one or more `ClassLoader`
    instances as children of the application `ClassLoader`. These added `ClassLoader`
    instances may themselves be hierarchical or they may be **siblings**. Either way,
    they are almost certainly children of the application `ClassLoader`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是利用类加载器。尽管大声说出来可能很简单，但`ClassLoader`只是负责加载类（和其他资源）的对象。在任何给定的JVM中，都有几个类加载器以分层方式工作，从引导`ClassLoader`开始，然后是平台`ClassLoader`，最后是系统--或应用程序--`ClassLoader`。可能一个给定的应用程序或运行时环境，比如**Java企业版**（**Java
    EE**）应用服务器，可能会将一个或多个`ClassLoader`实例添加为应用程序`ClassLoader`的子级。这些添加的`ClassLoader`实例可能是分层的，也可能是**同级**。无论哪种情况，它们几乎肯定是应用程序`ClassLoader`的子级。
- en: 'A full treatment of classloaders and all that they entail is well beyond the
    scope of this book, but suffice it to say that we can create a new `ClassLoader`
    to allow the application to find the classes and resources in our **plugin** jars.
    To do this, we need to add a few methods--three to be exact--to our application
    class, Sunago. We''ll start with the constructor:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对类加载器及其所涉及的所有内容的全面处理远远超出了本书的范围，但可以说，我们可以创建一个新的`ClassLoader`来允许应用程序在我们的**插件**jar中找到类和资源。为此，我们需要向我们的应用程序类Sunago添加几种方法--确切地说是三种。我们将从构造函数开始：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Typically (though not always), when a JavaFX application starts, the `public
    static void main` method is run, which calls the `launch()` static method on the
    `Application` class, which we subclass. According to the Javadoc for `javafx.application.Application`,
    the JavaFX runtime performs the following steps when starting an application:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（虽然并非总是如此），当JavaFX应用程序启动时，会运行`public static void main`方法，该方法调用`Application`类上的`launch()`静态方法，我们对其进行子类化。根据`javafx.application.Application`的Javadoc，JavaFX运行时在启动应用程序时执行以下步骤：
- en: Constructs an instance of the specified `Application` class.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造指定的`Application`类的实例。
- en: Calls the `init()` method.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`init()`方法。
- en: Calls the `start(javafx.stage.Stage)` method.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`start(javafx.stage.Stage)`方法。
- en: 'Waits for the application to finish, which happens when any of the following
    occur:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待应用程序完成，当发生以下任何一种情况时：
- en: The application calls `Platform.exit()`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用`Platform.exit()`。
- en: The last window has been closed, and the `implicitExit` attribute on platform
    is true.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个窗口已经关闭，平台上的`implicitExit`属性为true。
- en: Calls the `stop()` method.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`stop()`方法。
- en: 'We want to perform our `ClassLoader` work at step 1, in the constructor of
    our `Application`, to make sure that everything that follows has an up-to-date
    `ClassLoader`. That work is done in the second method that we need to add, which
    is this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在第1步，在我们的`Application`的构造函数中执行我们的`ClassLoader`工作，以确保后续的一切都有最新的`ClassLoader`。这项工作是我们需要添加的第二种方法，就是这个：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We start by getting a list of the jar files (we'll see that code in a moment),
    then, if the array is non-null, we need to build an array of `URL`s, so, we iterate
    over the `File` array, and call `.toURI().toURL()` to do so. Once we have our
    `URL` array we create a new `ClassLoader` (`URLClassLoader.newInstance(urls)`),
    then set the `ClassLoader` for the current Thread via `Thread.currentThread().setContextClassLoader()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要获取一个jar文件列表（我们马上就会看到那段代码），然后，如果数组不为空，我们需要构建一个`URL`数组，所以我们遍历`File`数组，并调用`.toURI().toURL()`来实现。一旦我们有了`URL`数组，我们就创建一个新的`ClassLoader`（`URLClassLoader.newInstance(urls)`），然后通过`Thread.currentThread().setContextClassLoader()`为当前线程设置`ClassLoader`。
- en: 'This is our final additional method `getFiles()`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最后的额外方法`getFiles()`：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This last method simply scans the files in `$HOME/.sunago`, looking for a file
    that ends with `.jar`. A list of zero or more jar files is returned to our calling
    code for inclusion in the new `ClassLoader`, and our work is done.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后的方法只是简单地扫描`$HOME/.sunago`中的文件，寻找以`.jar`结尾的文件。返回零个或多个jar文件的列表供我们的调用代码包含在新的`ClassLoader`中，我们的工作就完成了。
- en: So there you have two ways of adding plugin jars to the runtime dynamically.
    Each has its strengths and weaknesses. The first requires multi-platform development
    and maintenance, while the second is a bit riskier, as classloaders can be tricky.
    I have tested the second approach on Windows and Linux and Java 8 and 9 with no
    errors detected. Which approach you use will, of course, depend on your unique
    environment and requirements, but you have at least two options with which to
    start your evaluation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你有两种动态将插件jar添加到运行时的方法。每种方法都有其优点和缺点。第一种需要多平台开发和维护，而第二种有点风险，因为类加载器可能会有些棘手。我已经在Windows和Linux以及Java
    8和9上测试了第二种方法，没有发现错误。你使用哪种方法，当然取决于你独特的环境和要求，但至少你有两种选项可以开始评估。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With all of that said, our application is complete. Of course, hardly any software
    is truly complete, and there's much more that could be done to Sunago. Twitter
    support could be expanded to include direct messages. The Instagram module needs
    some configuration options added. While the capabilities exposed via the Facebook
    API are limiting, some sort of meaningful Facebook integration could be added.
    Sunago itself could be modified to, say, add support for in-application viewing
    of social media content (as opposed to shelling out to the host operating system's
    default browser). There are a handful of minor user experience bugs that could
    be addressed. And the list can go on and on. What we do have, though, is a moderately
    complex, networked application, that demonstrates a number of features and capabilities
    of the Java platform. We've built an extensible, internationalized JavaFX application
    that demonstrates the use of the Service Provider Interface and `ClassLoader`
    magic, and offers many more examples of lambdas, stream operations, and functional
    interfaces.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们的应用程序已经完成。当然，几乎没有软件是真正完成的，Sunago还有很多可以做的事情。Twitter支持可以扩展到包括直接消息。Instagram模块需要添加一些配置选项。虽然Facebook
    API公开的功能有限，但可以添加某种有意义的Facebook集成。Sunago本身可以进行修改，比如添加对社交媒体内容的应用内查看支持（而不是切换到主机操作系统的默认浏览器）。还有一些可以解决的小的用户体验问题。列表可以继续下去。然而，我们所拥有的是一个相当复杂的网络应用程序，它展示了Java平台的许多功能和能力。我们构建了一个可扩展的、国际化的JavaFX应用程序，展示了服务提供者接口和`ClassLoader`魔术的使用，并提供了许多关于lambda、流操作和函数接口的更多示例。
- en: In the next chapter, we're going to build on the ideas presented here, and build
    an Android port of Sunago so that we can take our social media aggregation on-the-go
    with us.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在这里提出的想法基础上构建，并构建Sunago的Android移植版，这样我们就可以随时随地进行社交媒体聚合。
