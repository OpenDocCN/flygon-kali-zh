- en: Writing Testable Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可测试的代码
- en: In [Chapter 1](2cce7b7c-f5dc-4ad0-b6b8-940ef3dafd3a.xhtml), *Exploring Test-Driven
    Development*, pitfalls that should be avoided when writing code to prevent code
    smell were explained. While writing good code is in itself an art, the process
    of writing code that can be efficiently tested requires extra efforts and commitment
    on the part of the developers to write clean code that can be repeatedly tested
    without any hassle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](2cce7b7c-f5dc-4ad0-b6b8-940ef3dafd3a.xhtml)中，*探索测试驱动开发*，解释了编写代码以防止代码异味的陷阱。编写良好的代码本身就是一种艺术，而编写可以有效测试的代码的过程需要开发人员额外的努力和承诺，以编写可以反复测试而不费吹灰之力的干净代码。
- en: It is true that practicing TDD improves code production and encourages writing
    good code that is robust and maintainable. Nevertheless, time spent doing TDD
    can be wasted and the technique's return on investment might not be obtained if
    developers involved in software projects write code that is untestable. This can
    usually be traced to the use of bad code design architecture and not adequately
    or effectively using object-oriented design principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 练习TDD可以提高代码生产效率，鼓励编写健壮且易于维护的良好代码是事实。然而，如果参与软件项目的开发人员编写不可测试的代码，那么花在TDD上的时间可能是浪费的，该技术的投资回报可能无法实现。这通常可以追溯到使用糟糕的代码设计架构，以及未充分或有效地使用面向对象设计原则。
- en: Writing tests is as important as writing the main code. It is stressful and
    really difficult writing tests for code that is untestable, which is the reason
    why untestable code should be avoided in the first place. Code can be untestable
    for different reasons, such as when the code does too much (**Monster Code**),
    it violates the single responsibility principle, there is wrong use of architecture,
    or faulty object-oriented design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试和编写主要代码一样重要。为不可测试的代码编写测试非常累人且非常困难，这就是为什么首先应该避免不可测试的代码的原因。代码之所以不可测试，可能有不同的原因，比如代码做得太多（**怪兽代码**），违反了单一职责原则，架构使用错误，或者面向对象设计有缺陷。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Warning signs when writing untestable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不可测试代码的警告信号
- en: Law of Demeter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迪米特法则
- en: The SOLID architecture principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID架构原则
- en: Setting up DI Container for ASP.NET Core MVC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为ASP.NET Core MVC设置DI容器
- en: Warning signs when writing untestable code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写不可测试代码的警告信号
- en: Effective and continuous practice of TDD can improve the code-writing process,
    making testing easier, which results in improved code quality and robust software
    application. However, when a project's code base contains portions of codes that
    are untestable, writing unit or integration tests becomes extremely difficult
    or nearly impossible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有效和持续的TDD实践可以改善编写代码的过程，使测试变得更容易，从而提高代码质量和软件应用的健壮性。然而，当项目的代码库包含不可测试的代码部分时，编写单元测试或集成测试变得极其困难，甚至几乎不可能。
- en: Software development teams cannot emphatically validate the consistent behavior
    of the functionalities and features of an application when there is untestable
    code in a software project's code base. To avoid this preventable situation, writing
    code that is testable is not an option but a must for every serious development
    team that values quality software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件项目的代码库中存在不可测试的代码时，软件开发团队无法明确验证应用程序功能和特性的一致行为。为了避免这种可预防的情况，编写可测试的代码不是一个选择，而是每个重视质量软件的严肃开发团队的必须。
- en: Untestable code results from the violation of common standards, practices, and
    principles that have been proven and tested to improve the quality of code. While
    professionalism comes with repeated use of good practices and experience, there
    are some common bad code designs and writing approaches that are common sense
    even to a beginner, such as the use of global variables when not required, tight
    coupling of code, hard-coding dependencies, or values that can change in code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不可测试的代码是由于违反了已被证明和测试可以提高代码质量的常见标准、实践和原则而产生的。虽然专业素养随着良好实践和经验的反复使用而来，但有一些常见的糟糕代码设计和编写方法即使对于初学者来说也是常识，比如在不需要时使用全局变量、代码的紧耦合、硬编码依赖关系或可能在代码中发生变化的值。
- en: In this section, we will discuss some common anti-patterns and pitfalls that
    you should watch out for when writing code as they can make writing tests for
    your production code difficult.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些常见的反模式和陷阱，当编写代码时应该注意，因为它们可能会使为生产代码编写测试变得困难。
- en: Tight coupling
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧耦合
- en: '**Coupling** is the extent to which objects depend on or are closely related
    to one another. To explain this further, when a `LoanProcessor` class is tightly
    coupled to `EligibilityChecker`, changing the latter can affect the behavior or
    modify the state of the former.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**耦合**是对象相互依赖或密切相关的程度。进一步解释，当`LoanProcessor`类与`EligibilityChecker`紧密耦合时，更改后者可能会影响前者的行为或修改其状态。'
- en: The majority of untestable code is usually a result of inherent dependencies
    scattered in different portions of the codes, usually through the use of concrete
    implementations of dependencies causing a mixing of concerns that otherwise should
    be separated across application boundaries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不可测试的代码通常是由于不同部分的代码中存在的固有依赖关系造成的，通常是通过使用依赖关系的具体实现，导致了本应在应用程序边界上分离的关注点混合在一起。
- en: Unit testing code with tightly coupled dependencies will lead to testing the
    different objects that are tightly coupled. Dependencies that should ideally be
    easy to mock when injected into the constructor, during unit testing will not
    be possible. This can often slow down the overall testing process as all the dependencies
    would have to be constructed in the code under test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具有紧密耦合依赖关系的单元测试代码将导致测试紧密耦合的不同对象。在单元测试期间，应该在构造函数中注入的依赖关系理想情况下应该很容易模拟，但这将是不可能的。这通常会减慢整体测试过程，因为所有依赖关系都必须在受测试的代码中构建。
- en: 'In the following snippet, `LoanProcessor` is tightly coupled to `EligibilityChecker`.
    This is because `EligibilityChecker` has been instantiated with the new keyword
    in the `LoanProcessor` constructor. Changes made to `EligibilityChecker` will
    affect `LoanProcessor`, which can cause it to break. Also, unit testing any method
    contained in `LoanProcessor` will always cause `EligibilityChecker` to be constructed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`LoanProcessor` 与 `EligibilityChecker` 紧密耦合。这是因为 `EligibilityChecker`
    在 `LoanProcessor` 构造函数中使用了 new 关键字进行实例化。对 `EligibilityChecker` 的更改将影响 `LoanProcessor`，可能导致其出现故障。此外，对
    `LoanProcessor` 中包含的任何方法进行单元测试都将导致 `EligibilityChecker` 被构造：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An approach to resolve the tight coupling in `LoanProcessor` is through the
    use of **Dependency Injection** (**DI**). Since `LoanProcessor` cannot be tested
    in isolation, as `EligibilityChecker` object will have to be instantiated in the
    constructor, `EligibilityChecker` will be injected into `LoanProcessor`, through
    the constructor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 `LoanProcessor` 中紧密耦合的一种方法是使用**依赖注入**（**DI**）。由于 `LoanProcessor` 无法在隔离环境中进行测试，因为
    `EligibilityChecker` 对象将必须在构造函数中实例化，所以可以通过构造函数将 `EligibilityChecker` 注入到 `LoanProcessor`
    中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `EligibilityChecker` injected, testing `LoanProcessor` becomes easier as
    this allows you to write a test where you mock the implementation of `EligibilityChecker`,
    allowing you to test `LoanProcessor` in isolation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入 `EligibilityChecker`，测试 `LoanProcessor` 变得更容易，因为这使您可以编写一个测试，其中模拟 `EligibilityChecker`
    的实现，从而允许您在隔离环境中测试 `LoanProcessor`。
- en: 'Alternatively, `EligibilityChecker` can be injected through properties or members
    of the `LoanProcessor` class instead of passing the dependency through the `LoanProcessor`
    constructor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，可以通过 `LoanProcessor` 类的属性或成员注入 `EligibilityChecker`，而不是通过 `LoanProcessor`
    构造函数传递依赖项：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the dependency injected either through the constructor or property, `LoanProcessor`
    and `EligibilityChecker` have now become loosely coupled, thereby making the writing
    of unit tests and mocking `EligibilityChecker` easy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造函数或属性注入依赖后，`LoanProcessor` 和 `EligibilityChecker` 现在变得松散耦合，从而使得编写单元测试和模拟
    `EligibilityChecker` 变得容易。
- en: To make a class loosely coupled and testable, you have to ensure that the class
    does not instantiate other classes and objects. Instantiating objects inside constructors
    or methods of a class can result in preventing the injection of mock or dummy
    objects while attempting to get the code under a test harness.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使类松散耦合且可测试，必须确保该类不实例化其他类和对象。在类的构造函数或方法中实例化对象可能会导致无法注入模拟或虚拟对象，从而使代码无法进行测试。
- en: Monster Constructor
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物构造函数
- en: To test a method, you have to instantiate or construct the class containing
    the method. The most common mistake developers make is to create what I call **Monster
    Constructor**, which is simply a constructor that does too much work or real work,
    such as performing I/O operations, database calls, static initialization, reading
    some large files, or establishing communication with external services.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个方法，您必须实例化或构造包含该方法的类。开发人员最常见的错误之一是创建我所谓的**怪物构造函数**，它只是一个做了太多工作或真正工作的构造函数，比如执行
    I/O 操作、数据库调用、静态初始化、读取一些大文件或与外部服务建立通信。
- en: When you have a class designed with a constructor that initializes or instantiates
    objects other than value objects (list, array, and dictionary), the class technically
    has a nonflexible structure. This is a bad class design because the class automatically
    becomes strongly tied to the classes it is instantiating, making unit testing
    difficult. Any class with this design also violates the single responsibility
    principle, because the creation of an object graph is a responsibility that can
    be delegated to another class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类设计有一个构造函数，用于初始化或实例化除值对象（列表、数组和字典）之外的对象时，该类在技术上具有非灵活的结构。这是糟糕的类设计，因为该类自动与其实例化的类紧密耦合，使得单元测试变得困难。具有这种设计的任何类也违反了单一责任原则，因为对象图的创建是可以委托给另一个类的责任。
- en: 'Testing methods in a class with a constructor that does a great deal of work
    comes with great costs. In essence, to test the methods in a class with the preceding
    design, you are compelled to go through the pain of creating the dependent objects
    in the constructor. If the dependent object makes a database call when constructed,
    this call will be repeated each time a method in that class is tested, making
    testing slow and painful:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有做大量工作的构造函数的类中测试方法会带来巨大的成本。实质上，要测试具有上述设计的类中的方法，您被迫要经历在构造函数中创建依赖对象的痛苦。如果依赖对象在构造时进行数据库调用，那么每次测试该类中的方法时，这个调用都会被重复，使得测试变得缓慢和痛苦：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the object graph construction is being done in
    the `LoanProcessor` constructor, which will definitely make the class difficult
    to test. It is a good practice to have a lean constructor, that does little work
    and has little knowledge of other objects, especially what they can do but not
    how they do it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，对象图的构建是在 `LoanProcessor` 构造函数中完成的，这肯定会使得该类难以测试。最好的做法是拥有一个精简的构造函数，它做很少的工作，并且对其他对象的了解很少，特别是它们能做什么，但不知道它们是如何做到的。
- en: Sometimes developers use a test hack, which involves creating multiple constructors
    for a class. One of the constructors will be designated as a test-only constructor.
    While using this approach can allow the class to be tested in isolation, there
    is a bad side to it. For example, the class created with multiple constructors
    can have other classes referencing it and instantiating it using the constructor
    that does a lot of work. This can make testing those dependent classes very difficult.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时开发人员使用一种测试技巧，即为一个类创建多个构造函数。其中一个构造函数将被指定为仅用于测试的构造函数。虽然使用这种方法可以使类在隔离环境中进行测试，但也存在不好的一面。例如，使用多个构造函数创建的类可能会被其他类引用，并使用做大量工作的构造函数进行实例化。这可能会使得测试这些依赖类变得非常困难。
- en: 'The following code snippet illustrates the bad design of creating a separate
    constructor solely for the purpose of testing the class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了为了测试类而创建单独构造函数的糟糕设计：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are important warning signs that can aid you in designing a loosely coupled
    class with a constructor that does little work. Avoid the use of the `new` operators
    in the constructor, to allow the injection of dependent objects. You should initialize
    and assign to the appropriate fields all objects injected through the constructor.
    Lightweight value objects instantiation should also be done in the constructor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的警告信号可以帮助您设计一个构造函数工作量较小的松散耦合类。避免在构造函数中使用`new`操作符，以允许注入依赖对象。您应该初始化并分配通过构造函数注入的所有对象到适当的字段中。轻量级值对象的实例化也应该在构造函数中完成。
- en: Also, avoid static method calls, this is because static calls cannot be injected
    or mocked.  Also, the use of iterations or conditional logic inside the constructor
    should be avoided; each time the class is tested, the logic or loop will be executed,
    causing excessive overhead.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应避免静态方法调用，因为静态调用无法被注入或模拟。此外，应避免在构造函数中使用迭代或条件逻辑；每次测试类时，逻辑或循环都将被执行，导致过多的开销。
- en: Design your class with testing in mind, don't create dependent objects or collaborators
    in the constructor. When your classes need to be dependent on other classes, inject
    the dependencies. Ensure the creation of value objects only. When you create object
    graphs in your code, use *factory methods* to achieve this. Factory methods are
    used for creating objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类时要考虑测试，不要在构造函数中创建依赖对象或协作者。当您的类需要依赖其他类时，请注入依赖项。确保只创建值对象。在代码中创建对象图时，使用*工厂方法*来实现。工厂方法用于创建对象。
- en: Classes with more than one responsibility
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有多个责任的类
- en: Ideally, a class should have only one responsibility. When you design your class
    with more than one responsibility, it is possible to have interactions between
    responsibilities in the class that will make code modifications difficult and
    testing the interactions in isolation nearly impossible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个类应该只有一个责任。当您设计的类具有多个责任时，可能会在类之间产生交互，使得代码修改变得困难，并且几乎不可能对交互进行隔离测试。
- en: There are indicators that can clearly point out that a class is doing too much
    and has more than one responsibility. For example, when you are struggling with
    giving a class a name and you probably end up with the word `and` in the class
    name, it's a clue that the class does too much.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些指标可以清楚地表明一个类做了太多事情并且具有多个责任。例如，当您在为一个类命名时感到困难，最终可能会在类名中使用`and`这个词，这表明该类做了太多事情。
- en: Another sign of a class with multiple responsibilities is when the fields in
    the class are used only in some methods or when the class has static methods that
    operate only on parameters and not on the class fields. Additionally, a class
    does too much when it has a long list of fields or methods and many dependent
    objects passed into the class constructor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有多个责任的类的另一个标志是，类中的字段仅在某些方法中使用，或者类具有仅对参数而不是类字段进行操作的静态方法。此外，当一个类具有长列表的字段或方法以及许多依赖对象传递到类构造函数中时，表示该类做了太多事情。
- en: 'The `LoanProcessor` class in the following snippet has the dependencies neatly
    injected into the constructor, making it loosely coupled with the dependencies.
    However, the class has more than one reason to change; the class has a mix of
    both methods with code for data retrieval and business rules processing:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，`LoanProcessor`类的依赖项已经整洁地注入到构造函数中，使其与依赖项松散耦合。然而，该类有多个改变的原因；该类既包含用于数据检索的代码，又包含业务规则处理的代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `GetCarLoans` method should not be in `LoanProcessor` in order to make the
    class maintainable and be easily tested. `LoanProcessor` should be refactored
    with `GetCarLoans` in a data access layer class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使类易于维护并且易于测试，`GetCarLoans`方法不应该在`LoanProcessor`中。应该将`LoanProcessor`与`GetCarLoans`一起重构到数据访问层类中。
- en: Classes with the qualities described in this section can be difficult to debug
    and test. Also, it might be difficult for new team members to understand the inner
    workings of the class quickly. If you have a class with these attributes in your
    code base, it is advisable to refactor it by identifying the responsibilities
    and separating them into different classes and naming the classes as per their
    responsibilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 具有本节描述的特征的类可能很难进行调试和测试。新团队成员可能很难快速理解类的内部工作原理。如果您的代码库中有具有这些属性的类，建议通过识别责任并将其分离到不同的类中，并根据其责任命名类来进行重构。
- en: Static objects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态对象
- en: 'Using **static variables**, **methods**, and **objects** in code can be useful
    as these allow the objects to have the same value throughout all instances of
    the object, as only one copy of the object is created and put in memory. However,
    testing code containing statics, especially static methods, can create testing
    issues because you cannot override static methods in a subclass and using mocking
    frameworks to mock static methods is a very daunting task:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用**静态变量**、**方法**和**对象**可能是有用的，因为这些允许对象在所有实例中具有相同的值，因为只创建了一个对象的副本并放入内存中。然而，测试包含静态内容的代码，特别是静态方法的代码，可能会产生测试问题，因为您无法在子类中覆盖静态方法，并且使用模拟框架来模拟静态方法是一项非常艰巨的任务：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you create static methods that maintain states, such as in the `CalculateCarLoanRate`
    method in `LoanProcessor` in the preceding snippet, the static methods cannot
    be subclassed or extended using polymorphism. Also, the static method cannot be
    defined using interfaces, thereby making mocking impossible, since most mocking
    frameworks work effectively with interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建维护状态的静态方法时，例如在前面片段中的`LoanProcessor`中的`CalculateCarLoanRate`方法，静态方法无法通过多态进行子类化或扩展。此外，静态方法无法使用接口进行定义，因此使得模拟变得不可能，因为大多数模拟框架都有效地使用接口。
- en: Law of Demeter
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迪米特法则
- en: Software applications are complex systems made up of different components that
    communicate to achieve the overall purposes of solving real-life problems and
    business process automations. In reality, the components have to coexist, interact,
    and share information across the component's boundary without the different concerns
    getting mixed up, to promote component reusability and overall system flexibility.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序是由不同组件组成的复杂系统，这些组件进行通信以实现解决现实生活问题和业务流程自动化的整体目的。实际上，这些组件必须共存、互动，并在组件边界之间共享信息，而不会混淆不同的关注点，以促进组件的可重用性和整体系统的灵活性。
- en: In software programming, there are technically no hardcore laws defined that
    must be stringently followed. However, various principles and laws have been formulated
    that serve as guidelines and can assist software developers and practitioners,
    and facilitate building software applications that have components with high cohesion
    and loose coupling to encapsulate data adequately and ensure that quality source
    codes are produced that can be easily understood and extended, thereby reducing
    the maintenance costs of software. One of these laws is the **Law of Demeter**
    (**LoD**).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件编程中，技术上没有严格遵循的硬性法律。然而，已经制定了各种原则和法律，作为指导方针，可以帮助软件开发人员和从业者，促进构建具有高内聚性和松耦合性的组件的软件应用程序，以充分封装数据，并确保产生易于理解和扩展的高质量源代码，从而降低软件的维护成本。其中之一就是**迪米特法则**（**LoD**）。
- en: 'LoD, also known as the **principle of least knowledge**, is an important design
    approach or rule for developing object-oriented software applications. The rule
    was formulated at *Northeastern University in 1987 by Ian Holland*. With the proper
    knowledge of this principle, software developers can write code that is easy to
    test and build software applications with fewer or no bugs. The formulation of
    the law is that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LoD，也称为**最少知识原则**，是开发面向对象软件应用程序的重要设计方法或规则。该规则于1987年由Ian Holland在东北大学制定。通过正确理解这一原则，软件开发人员可以编写易于测试的代码，并构建具有更少或没有错误的软件应用程序。该法则的制定是：
- en: 'Each unit should have only limited knowledge about other units: only units
    "closely" related to the current unit.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元只应对当前单元“密切”相关的单元有限了解。
- en: Each unit should only talk to its friends; don't talk to strangers.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元只能与其朋友交谈；不要与陌生人交谈。
- en: LoD emphasizes low coupling, which effectively means an object should have little
    or very limited information about another object. Relating LoD to a typical class
    object, the methods in a class should only have limited knowledge about other
    methods of closely related objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: LoD强调低耦合，这实际上意味着一个对象对另一个对象的了解应该很少或非常有限。将LoD与典型的类对象联系起来，类中的方法只应对密切相关对象的其他方法有限了解。
- en: LoD serves as heuristics for software developers to facilitate information-hiding
    in modules and components of software. LoD has two forms—the **object or dynamic
    form** and **class or static form**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: LoD作为软件开发人员的启发式，以促进软件模块和组件中的信息隐藏。LoD有两种形式——**对象或动态形式**和**类或静态形式**。
- en: 'The class form of LoD is formulated as:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LoD的类形式被公式化为：
- en: 'A **method** (**M**) of a **class** (**C**) should only send messages to objects
    of the following classes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**（**C**）的**方法**（**M**）只能向以下类的对象发送消息：'
- en: Argument classes of M including C
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M的参数类，包括C
- en: Instance variables of C
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C的实例变量
- en: Classes of instances created within M
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在M中创建的实例的类
- en: Properties or fields of C
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C的属性或字段
- en: 'And the object form of LoD is formulated as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: LoD的对象形式被公式化为：
- en: 'Within an M, messages can only be sent to the following objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在M中，消息只能发送到以下对象：
- en: Parameters of M, which include the enclosing object.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M的参数，包括封闭对象。
- en: 'An immediate part-object, which is the object that M called on the enclosing
    object returns, including attributes of the enclosing object, or an element of
    a collection that is an attribute of the enclosing object:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M调用封闭对象返回的即时部分对象，包括封闭对象的属性，或者封闭对象的属性集合的元素：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code clearly violates LoD, this is because `LoanProcessor` does
    not really care about `LoanCalculator` as it does not keep any reference to it.
    In the code, `LoanProcessor` is already talking to `LoanCalculator`, a stranger.
    This code is not really reusable because both `CurrencyConverter` and `LoanProcessor`
    will be required by any class or code attempting to reuse them, though technically
    `LoanCalculator` is not used beyond the constructor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码明显违反了LoD，这是因为`LoanProcessor`实际上并不关心`LoanCalculator`，因为它没有保留任何对它的引用。在代码中，`LoanProcessor`已经在与`LoanCalculator`进行交流，一个陌生人。这段代码实际上并不可重用，因为任何试图重用它们的类或代码都将需要`CurrencyConverter`和`LoanProcessor`，尽管从技术上讲，`LoanCalculator`在构造函数之外并未被使用。
- en: Writing unit tests for `LoanProcessor` will require that the object graph be
    created. `LoanCalculator` should be created in order for `CurrencyConverter` to
    be available. This creates coupling in the system, if `LoanCalculator` is refactored,
    which is possible anyway, so there is the risk that this might break `LoanProcessor`,
    causing the unit test to stop running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对`LoanProcessor`编写单元测试，需要创建对象图。必须创建`LoanCalculator`以便`CurrencyConverter`可用。这会在系统中创建耦合，如果`LoanCalculator`被重构，这是可能的，那么可能会导致`LoanProcessor`出现故障，导致单元测试停止运行。
- en: While the `LoanCalculator` class can be mocked, to test `LoanProcessor` in isolation,
    this can sometimes make the test unreadable, it is better that the coupling is
    avoided so that you can write code that is flexible and can be easily tested.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculator`类可以被模拟，以便单独测试`LoanProcessor`，但这有时会使测试变得难以阅读，最好避免耦合，这样可以编写灵活且易于测试的代码。'
- en: 'To refactor the preceding code snippet, and make it comply with LoD and take
    its dependencies from the class constructor, thereby eliminating an extra dependency
    on `LoanCalculator` and reduce coupling in the code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构前面的代码片段，并使其符合LoD并从类构造函数中获取其依赖项，从而消除对`LoanCalculator`的额外依赖，并减少代码的耦合：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Train Wreck
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火车失事
- en: 'Another anti-pattern that violates LoD is what is called **Train Wreck** or
    **Chain Calls**. This is a chain of functions and occurs when you have a series
    of C# methods that are appended to each other all in a single line of code. You
    will know you have written a code with Train Wreck when you are spending time
    trying to figure out what the line of code does:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个违反LoD的反模式是所谓的**火车失事**或**链式调用**。这是一系列函数的链，并且当你在一行代码中追加了一系列C#方法时就会发生。当你花时间试图弄清楚一行代码的作用时，你就会知道你写了一个火车失事的代码：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might be wondering how this phenomenon violates LoD. First, the code lacks
    readability and it is not maintainable. Also, the line of code is not reusable
    as there are three method calls in only a single line of code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这种现象如何违反了LoD。首先，代码缺乏可读性，不易维护。此外，代码行不可重用，因为一行代码中有三个方法调用。
- en: 'This line of code can be refactored by minimizing the interactions and eliminating
    the method chaining so as to make it comply with the principle of *don''t talk
    to strangers*. This principle explains that a calling point or method should only
    interact with one object at a time. With the elimination of the methods chain,
    the resulting code can be reused elsewhere without having to struggle to understand
    what the piece of code does:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码可以通过减少交互和消除方法链来进行重构，以使其符合“不要和陌生人说话”的原则。这个原则解释了调用点或方法应该一次只与一个对象交互。通过消除方法链，生成的代码可以在其他地方重复使用，而不必费力理解代码的作用：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An object should have limited knowledge and information of other objects. Also,
    methods in an object should have little awareness of the object graph of the application.
    Through conscious efforts, using LoD, you can build software applications that
    are loosely coupled and maintainable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象应该对其他对象的知识和信息有限。此外，对象中的方法应该对应用程序的对象图具有很少的认识。通过有意识的努力，使用LoD，你可以构建松散耦合且易于维护的软件应用程序。
- en: The SOLID architecture principles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID架构原则
- en: Software application development procedures and methodologies, from the first
    step to the last step, should be simple and easily understood by both novices
    and experts. These procedures, when used in combination with the right principles,
    make the process of developing and maintaining software applications easy and
    seamless.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序开发的程序和方法，从第一步到最后一步，应该简单易懂，无论是新手还是专家都能理解。这些程序，当与正确的原则结合使用时，使开发和维护软件应用程序的过程变得简单和无缝。
- en: Developers from time to time adopt and use different development principles
    and patterns in order to simplify complexities and make software applications
    code bases maintainable. One such principle is the SOLID principle. This principle
    has proven to be very useful and a must-know for every serious programmer of object-oriented
    systems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员不时采用和使用不同的开发原则和模式，以简化复杂性并使软件应用程序代码库易于维护。其中一个原则就是SOLID原则。这个原则已经被证明非常有用，是每个面向对象系统的严肃程序员必须了解的。
- en: 'SOLID is an acronym of the five basic principles of developing object-oriented
    systems. The five principles are for class design and are denoted as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是开发面向对象系统的五个基本原则的首字母缩写。这五个原则是用于类设计的，表示为：
- en: '**S**: Single Responsibility Principle'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：单一职责原则'
- en: '**O**: Open-Closed Principle'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：开闭原则'
- en: '**L**: Liskov Substitution Principle'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：里氏替换原则'
- en: '**I**: Interface Segregation Principle'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：接口隔离原则'
- en: '**D**: Dependency Inversion Principle'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：依赖反转原则'
- en: The principles were first consolidated under the acronym SOLID and popularized
    by *Robert C. Martins* (popularly known as **Uncle Bob**) in the early 2000s.
    The five principles are meant for class design, and when abided by, can assist
    with dependency management, which will avoid the creation of rigid code bases
    tangled with dependencies here and there.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则首次被整合成SOLID的首字母缩写，并在2000年代初由*罗伯特·C·马丁*（通常被称为**鲍勃叔叔**）推广。这五个原则是用于类设计的，遵守这些原则可以帮助管理依赖关系，避免创建混乱的、到处都是依赖的僵化代码库。
- en: Proper understanding and use of the SOLID principles can enable software developers
    to achieve a very high degree of cohesion and write quality code that can be easily
    understood and maintained. With SOLID principles, you can write clean code and
    build software applications that are robust and scalable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对SOLID原则的正确理解和运用可以使软件开发人员实现非常高的内聚度，并编写易于理解和维护的高质量代码。有了SOLID原则，你可以编写干净的代码，构建健壮且可扩展的软件应用程序。
- en: Indeed, Uncle Bob clarified that SOLID principles are not laws or rules but
    are heuristics that have been observed to work in several cases. To use the principles effectively,
    you have to search your code and check for portions where the principles are violated
    and then refactor them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，鲍勃叔叔澄清了SOLID原则不是法律或规则，而是已经观察到在几种情况下起作用的启发式。要有效地使用这些原则，你必须搜索你的代码，检查违反原则的部分，然后进行重构。
- en: Single Responsibility Principle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The **Single Responsibility Principle** (**SRP**) is the first of the five SOLID
    principles. The principle states that a class must at any point in time have only
    one reason to change. This simply means that a class should only perform one duty
    at a time or have one responsibility.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）是五个SOLID原则中的第一个。该原则规定一个类在任何时候只能有一个改变的理由。这简单地意味着一个类一次只能执行一个职责或有一个责任。'
- en: The business requirements of software projects are not usually fixed. Before
    a software project is shipped and, indeed, throughout the life cycle of a software,
    requirements change from time to time and developers have to adapt the code base
    to the changes. In order for the software application to meet its business needs
    and adapt to changes, it is imperative that flexible design patterns are used
    and classes have a single responsibility at all times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目的业务需求通常不是固定的。在软件项目发布之前，甚至在软件的整个生命周期中，需求会不时地发生变化，开发人员必须根据变化调整代码库。为了使软件应用程序满足其业务需求并适应变化，必须使用灵活的设计模式，并且类始终只有一个责任。
- en: Additionally, it is important to understand that when a class has more than
    one responsibility, making even the minutest change can have a great impact on
    the entire code base. Changes made to the class can cause ripple effects leading
    to functionalities or other methods that have been working earlier to break. For
    example, if you have a class that parses a `.csv` file, while at the same time
    it makes a call to a web service to retrieve information that is not related to
    the `.csv` file parsing, the class has more than one reason to change. Changes
    in the web service call will affect the class, though the changes are not related
    to the `.csv` file parsing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要理解，当一个类有多个责任时，即使进行最微小的更改也会对整个代码库产生巨大影响。对类的更改可能会导致连锁反应，导致之前工作的功能或其他方法出现故障。例如，如果你有一个解析`.csv`文件的类，同时它还调用一个Web服务来检索与`.csv`文件解析无关的信息，那么这个类就有多个改变的原因。对Web服务调用的更改将影响该类，尽管这些更改与`.csv`文件解析无关。
- en: 'The design of the `LoanCalculator` class in the following snippet clearly violates
    SRP. `LoanCalculator` has two responsibilities—the first is to calculate house
    and car loans and the second is to parse loan rates from XML files and XML strings:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的`LoanCalculator`类的设计明显违反了SRP。`LoanCalculator`有两个责任——第一个是计算房屋和汽车贷款，第二个是从XML文件和XML字符串中解析贷款利率：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The dual responsibility status of the `LoanCalculator` class creates several
    issues. First, the class becomes very volatile, because changes to one responsibility
    might affect the other. For instance, a change to the structure of the XML contents
    to be parsed for the rates might necessitate that the class be rewritten, tested,
    and redeployed; despite that, changes have not been made to the second concern,
    which is the loan calculation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculator`类的双重责任状态会产生一些问题。首先，该类变得非常不稳定，因为对一个责任的更改可能会影响另一个责任。例如，对要解析的XML内容结构的更改可能需要重写、测试和重新部署该类；尽管如此，对第二个关注点——贷款计算——并没有进行更改。'
- en: 'The tangled code in the `LoanCalculator` class can be fixed by redesigning
    the class and separating the responsibilities. The new design will be to move
    the responsibility of XML rates parsing into a new `RateParser` class and leaving
    the loan calculation concern in the existing class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculator`类中的混乱代码可以通过重新设计类并分离责任来修复。新设计将是将XML利率解析的责任移交给一个新的`RateParser`类，并将贷款计算的关注点留在现有类中：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the `RateParser` class extracted from `LoanCalculator`, `RateParser` can
    now be used as a dependency in `LoanCalculator`. Changes made to any method in
    `RateParser` will not affect `LoanCalculator` since they now handle different
    concerns and each class has only one reason to change:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`LoanCalculator`中提取`RateParser`类，`RateParser`现在可以作为`LoanCalculator`中的一个依赖使用。对`RateParser`中的任何方法的更改不会影响`LoanCalculator`，因为它们现在处理不同的关注点，每个类只有一个改变的原因：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having the concerns separated creates great flexibility in the code base and
    allows for easy testing of the two classes. With the new design, changes made
    to `RateParser` cannot affect `LoanCalculator` and the two classes can be unit
    tested in isolation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将关注点分开在代码库中创造了很大的灵活性，并允许轻松测试这两个类。通过新的设计，对`RateParser`的更改不会影响`LoanCalculator`，这两个类可以独立进行单元测试。
- en: Responsibilities should not be mixed in a class. You should avoid muddling up
    responsibilities together in a class, which leads to monster classes that do too
    much. Instead, if you can think of a reason or motivation to change a class, then
    it already has more than one responsibility; split the class into classes, each
    containing only a single responsibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 责任不应该混在一个类中。你应该避免在一个类中混淆责任，这会导致做太多事情的怪兽类。相反，如果你能想到一个改变类的理由或动机，那么它已经有了多个责任；将类分成每个只包含单一责任的类。
- en: 'In a similar manner, a first glance at the `LoanRepository` class in the following
    snippet might not outrightly indicate that concerns are muddled up. But if you
    carefully examine the class, both data access and business logic codes are mixed
    in the class, making it violate SRP:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对以下代码片段中的`LoanRepository`类的第一印象可能不会直接表明关注点混淆。但是，如果仔细检查该类，数据访问和业务逻辑代码都混在一起，这使得它违反了SRP：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The class can be refactored by separating the business logic code of calculating
    a car loan rate into a new class—`LoanService`, this will allow the `LoanRepository`
    class to only contain code related to the data layer, thereby making it adhere
    to SRP:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以通过将计算汽车贷款利率的业务逻辑代码分离到一个新的类——`LoanService`中来重构，这将允许`LoanRepository`类只包含与数据层相关的代码，从而使其符合SRP：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the business logic code separated into the `LoanService` class, the `LoanRepository`
    class now has has only one dependency, which is the `DbContext` entity framework.
    Going forward, `LoanRepository` can be easily maintained and tested. The new `LoanService`
    class also adheres to SRP:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将业务逻辑代码分离到`LoanService`类中，`LoanRepository`类现在只有一个依赖，即`DbContext`实体框架。未来，`LoanRepository`可以很容易地进行维护和测试。新的`LoanService`类也符合SRP：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you have concerns in your code well-managed, the code base will have high
    cohesion and will be flexible and easy to test and maintain in the future. With
    high cohesion, the classes will be loosely coupled and changes to the classes
    will have little probability of breaking the entire system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码中的问题得到很好的管理时，代码库将具有高内聚性，并且将来会更加灵活、易于测试和维护。有了高内聚性，类将松散耦合，对类的更改将很少可能破坏整个系统。
- en: Open-Closed Principle
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: The approach for designing and eventually writing production code should be
    the one that allows new functionalities to be added to a project's code base without
    having to make many changes, change several portions or classes of the code base,
    or break existing functionalities that were already working and in good condition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和最终编写生产代码的方法应该是允许向项目的代码库添加新功能，而无需进行多次更改、更改代码库的几个部分或类，或破坏已经正常工作且状态良好的现有功能。
- en: If, for any reason, you make changes to a method in a class and as a result
    of the changes, changes have to be made to several parts or modules, it's an indication
    of a problem with the code design. This is what the **Open-Closed Principle** (**OCP**)
    addresses, to allow your code base design to be flexible, so that you can easily
    make modifications and enhancements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于对类中的方法进行更改而导致必须对多个部分或模块进行更改，这表明代码设计存在问题。这就是**开闭原则**（OCP）所解决的问题，允许您的代码库设计灵活，以便您可以轻松进行修改和增强。
- en: The OCP states that software entities, such as classes, methods, and modules,
    should be designed to be open for extension, but closed for modification. This
    principle can be achieved through inheritance or design patterns, such as factory,
    observer, and strategy patterns. It is where classes and methods can be designed
    to allow the addition of new functionalities to be used by the existing code,
    without actual modification or changes made to the existing code but by extending
    the behavior of the existing code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: OCP规定软件实体（如类、方法和模块）应设计为对扩展开放，但对修改关闭。这个原则可以通过继承或设计模式（如工厂、观察者和策略模式）来实现。这是指类和方法可以被设计为允许添加新功能，以供现有代码使用，而无需实际修改或更改现有代码，而是通过扩展现有代码的行为。
- en: In C#, with the proper use of object abstraction, you can have sealed classes
    that are closed for modification while the behavior of the classes can be extended
    through derived classes. Derived classes are children or subclasses of the sealed
    classes. Using inheritance, you can create classes that add more features by extending
    their base class without modifying the base class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，通过正确使用对象抽象，您可以拥有封闭的类，这些类对修改关闭，而类的行为可以通过派生类进行扩展。派生类是封闭类的子类。使用继承，您可以创建通过扩展其基类添加更多功能的类，而无需修改基类。
- en: Consider the `LoanCalculator` class in the following snippet, which has a `CalculateLoan`
    method that must be able to calculate the loan details for any type of loan passed
    into it. Without using the OCP, the requirement can be computed with the use of
    `if..else if` statements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段中的`LoanCalculator`类，它具有一个`CalculateLoan`方法，必须能够计算传递给它的任何类型的贷款的详细信息。在不使用OCP的情况下，可以使用`if..else
    if`语句来计算要求。
- en: 'The `LoanCalculator` class has a rigid structure, which necessitates much work
    when a new type is to be supported. For example, if you intend to add more types
    of customer loans, you have to modify the `CalculateLoan` method and add additional
    `else if` statements to accommodate the new types of loans. `LoanCalculator` violates
    the OCP since the class is not closed for modification:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculator`类具有严格的结构，当需要支持新类型时需要进行大量工作。例如，如果您打算添加更多类型的客户贷款，您必须修改`CalculateLoan`方法并添加额外的`else
    if`语句以适应新类型的贷款。`LoanCalculator`违反了OCP，因为该类不是封闭的以进行修改：'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make the `LoanCalculator` class open for extension and closed for modification,
    we can use inheritance to simplify the refactoring. `LoanCalculator` will be refactored
    to allow subclasses to be created from it. Making `LoanCalculator` a base class
    will facilitate the creation of two derived classes, `HouseLoanCalculator` and
    `CarLoanCalulator`. The business logic for calculating the different types of
    loans has been removed from the `CalculateLoan` method and implemented in the
    two derived classes, as seen in the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`LoanCalculator`类对扩展开放而对修改关闭，我们可以使用继承来简化重构。 `LoanCalculator`将被重构以允许从中创建子类。将`LoanCalculator`作为基类将有助于创建两个派生类，`HouseLoanCalculator`和`CarLoanCalulator`。计算不同类型贷款的业务逻辑已从`CalculateLoan`方法中移除，并在两个派生类中实现，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `If` conditions have been removed from the `CalculateLoan` method in the
    `LoanCalculator` class. Instead of having the `if(loanDTO.LoanType==LoanType.CarLoan)`
    line of code, the new `CarLoanCaculator` class now contains logic for obtaining
    car loan calculations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculator`类中的`If`条件已从`CalculateLoan`方法中移除。现在，新的`CarLoanCaculator`类包含了获取汽车贷款计算的逻辑：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `HouseLoanCalculator` class has been created from `LoanCalculator` with
    a `CalculateLoan` method that overrides the base `CalculateLoan` method in `LoanCalculator`.
    Any changes made to `HouseLoanCalculator` will not affect the `CalculateLoan`
    method of its base class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`HouseLoanCalculator`类是从`LoanCalculator`创建的，具有覆盖基类`LoanCalculator`中的`CalculateLoan`方法的`CalculateLoan`方法。对`HouseLoanCalculator`进行的任何更改都不会影响其基类的`CalculateLoan`方法：'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If a new type of loan is introduced, let's say a postgraduate study loan, a
    new class, `PostGraduateStudyLoan`, can be created to extend `LoanCalculator`
    and implement the `CalculateLoan` method without having to make any modifications
    to the `LoanCalculator` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引入了新类型的贷款，比如研究生学习贷款，可以创建一个新类`PostGraduateStudyLoan`来扩展`LoanCalculator`并实现`CalculateLoan`方法，而无需对`LoanCalculator`类进行任何修改。
- en: Technically, observing the OCP implies that classes and methods in your code
    should be opened for extension, meaning the classes and methods can be extended
    to add new behaviors to support new or changing application requirements. And
    the classes and methods are closed for modification, which means you can't make
    changes to the source code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，观察OCP意味着您的代码中的类和方法应该对扩展开放，这意味着可以扩展类和方法以添加新的行为来支持新的或不断变化的应用程序需求。而且类和方法对于修改是封闭的，这意味着您不能对源代码进行更改。
- en: 'In order to make `LoanCalculator` open for changes, we made it a base class
    that other types were derived from. Alternatively, we can create an `ILoanCalculator`
    abstraction, instead of using classical object inheritance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`LoanCalculator`对更改开放，我们将其作为其他类型的基类派生。或者，我们可以创建一个`ILoanCalculator`抽象，而不是使用经典的对象继承：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `CarLoanCalculator` class can now be created to implement the `ILoanCalculator`
    interface. Which will necessitate that the methods and properties defined in the
    interface will be explicitly implemented by the `CarLoanCalculator` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarLoanCalculator`类现在可以被创建来实现`ILoanCalculator`接口。这将需要`CarLoanCalculator`类明确实现接口中定义的方法和属性。'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `HouseLoanCalculator` class can also be created to implement `ILoanCalculator`,
    with the `IRateParser` object injected into it through the constructor, similar
    to `CarLoanCalculator`. The `CalculateLoan` method can be implemented with the
    specific code required to calculate a house loan. Any other type of loan can be
    added by simply creating the class and making it implement the `ILoanCalculator`
    interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`HouseLoanCalculator`类也可以被创建来实现`ILoanCalculator`，通过构造函数将`IRateParser`对象注入其中，类似于`CarLoanCalculator`。`CalculateLoan`方法可以被实现为具有计算房屋贷款所需的特定代码。通过简单地创建类并使其实现`ILoanCalculator`接口，可以添加任何其他类型的贷款：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using OCP, you can create software applications that are flexible with behaviors
    that can be easily extended, thereby avoiding a code base that is rigid and lacks
    reusability. Through appropriate use of OCP, by effectively using code abstraction
    and objects polymorphism, you can make changes to a code base without having to
    change many parts and with little effort. You really don't have to recompile the
    code base to achieve this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OCP，您可以创建灵活的软件应用程序，其行为可以轻松扩展，从而避免代码基础僵化且缺乏可重用性。通过适当使用OCP，通过有效使用代码抽象和对象多态性，可以对代码基础进行更改，而无需更改许多部分，并且付出很少的努力。您真的不必重新编译代码基础来实现这一点。
- en: Liskov Substitution Principle
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: The **Liskov Substitution Principle** (**LSP**), which can sometimes referred
    to as **Design by Contract**, is the third of the SOLID principles and was first
    put forward by *Barbara Liskov*. LSP states that a derived or subclass should
    be substitutable for the base or superclass without having to make modifications
    to the base class or generating any runtime errors in the system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**（LSP），有时也称为**按合同设计**，是SOLID原则中的第三个原则，最初由*Barbara Liskov*提出。LSP规定，派生类或子类应该可以替换基类或超类，而无需对基类进行修改或在系统中生成任何运行时错误。'
- en: LSP can be further explained using the following mathematical notation—let S
    be a subset of T, an object of T could be substituted for an object of S without
    breaking the existing working functionalities of the system or causing any type
    of errors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: LSP可以通过以下数学符号进一步解释——假设S是T的子集，T的对象可以替换S的对象，而不会破坏系统的现有工作功能或引起任何类型的错误。
- en: To illustrate the concepts of LSP, let's consider a `Car` super class with a
    `Drive` method. If `Car` has two derived classes, `SalonCar` and `JeepCar`, both
    having an overridden implementation of the `Drive` method, wherever `Car` is requested,
    both `SalonCar` and `JeepCar` should be usable in place of the `Car` class. The
    derived classes have an *is a* relationship with `Car`, because `SalonCar` is
    a `Car` and `JeepCar` is a `Car`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明LSP的概念，让我们考虑一个带有`Drive`方法的`Car`超类。如果`Car`有两个派生类，`SalonCar`和`JeepCar`，它们都有`Drive`方法的重写实现，那么无论何时需要`Car`，都应该可以使用`SalonCar`和`JeepCar`来替代`Car`类。派生类与`Car`有一个*是一个*的关系，因为`SalonCar`是`Car`，`JeepCar`是`Car`。
- en: In order to design your classes and implement them to be LSP-compliant, you
    should ensure that the derived classes elements are designed by contract. The
    derived classes method definitions should be somewhat similar to that of the base
    class, though the implementation can be different because of the different business
    requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计您的类并实现它们以符合LSP，您应该确保派生类的元素是按照合同设计的。派生类的方法定义应该与基类的相似，尽管实现可能会有所不同，因为不同的业务需求。
- en: Also, it is important that the implementation of the derived classes doesnot
    violate whatever constraints are implemented in the base classes or interfaces.
    When you partially implement an interface or base class, by having methods that
    are not implemented, you are violating LSP.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是派生类的实现不违反基类或接口中实现的任何约束。当您部分实现接口或基类时，通过具有未实现的方法，您正在违反LSP。
- en: 'The following code snippet has a `LoanCalculator` base class, with a `CalculateLoan`
    method and two derived classes, `HouseLoanCalculator` and `CarLoanCalculator`,
    which have `CalculateLoan` methods and can have different implementations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段具有`LoanCalculator`基类，具有`CalculateLoan`方法和两个派生类，`HouseLoanCalculator`和`CarLoanCalculator`，它们具有`CalculateLoan`方法并且可以具有不同的实现：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If LSP is not violated in the preceding snippet, the `HouseLoanCalculator`
    and `CarLoanCalculator` derived class can be used in place of `LoanCalculator`
    wherever a reference to `LoanCalculator` is required. This is demonstrated in
    the `Main` method, shown in the following snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前面的代码片段中没有违反LSP，那么`HouseLoanCalculator`和`CarLoanCalculator`派生类可以在需要`LoanCalculator`引用的任何地方使用。这在以下代码片段中的`Main`方法中得到了证明：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interface Segregation Principle
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The **Interface** is an object-oriented programming construct that is used by
    objects to define the methods and properties they expose, and to facilitate interactions
    with other objects. An interface contains related methods with empty bodies but
    no implementation. An interface is a useful construct in object-oriented programming
    and design; it allows the crafting of software applications that are flexible
    and loosely coupled.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种面向对象的编程构造，被对象用来定义它们公开的方法和属性，并促进与其他对象的交互。接口包含相关方法，具有空的方法体但没有实现。接口是面向对象编程和设计中的有用构造；它允许创建灵活且松耦合的软件应用程序。
- en: The **Interface Segregation Principle** (**ISP**) states that interfaces should
    be modest, by containing definitions for only properties and methods that are
    needed, and clients should not be forced to implement interfaces that they don't
    use, or depend on methods they don't need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）规定接口应该是适度的，只包含所需的属性和方法的定义，客户端不应被强制实现他们不使用的接口，或依赖他们不需要的方法。
- en: To implement the ISP in your code base effectively, you should favor the creation
    of simple and thin interfaces that have methods that are logically grouped together
    to solve a specific business case. With the creation of thin interfaces, the methods
    contained in the class code can be easily implemented with great flexibility while
    keeping the code base clean and elegant.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地在代码库中实现ISP，您应该倾向于创建简单而薄的接口，这些接口具有逻辑上分组在一起以解决特定业务案例的方法。通过创建薄接口，类代码中包含的方法可以轻松实现，同时保持代码库的清晰和优雅。
- en: On the other hand, if you have fat or bloated interfaces that have methods with
    functionalities that are not required in the classes that implement the interface,
    you are more likely to violate the ISP and create coupling in the code, which
    will result in a code base that cannot be easily tested.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您的接口臃肿或臃肿，其中包含类不需要的功能的方法，您更有可能违反ISP并在代码中创建耦合，这将导致代码库无法轻松测试。
- en: Instead of having a bloated or fat interface, you can create two or more thin
    interfaces with the methods logically grouped and have your class implement more
    than one interface, or let the interfaces inherit from other thin interfaces,
    a phenomenon known as multiple inheritance, supported in C#.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其拥有臃肿或臃肿的接口，不如创建两个或更多个薄接口，将方法逻辑地分组，并让您的类实现多个接口，或让接口继承其他薄接口，这种现象被称为多重继承，在C#中得到支持。
- en: 'The `IRateCalculator` interface in the following snippet violates the ISP.
    It can be considered a polluted interface because the only class it implements
    does not require the `FindLender` method as it is not needed by the `RateCalculator`
    class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段中的`IRateCalculator`接口违反了ISP。它可以被视为一个污染的接口，因为唯一实现它的类不需要`FindLender`方法，因为`RateCalculator`类不需要它：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `RateCalculator` class has the `GetYearlyCarLoanRate` and `GetYearlyHouseLoanRate`
    methods that are required to fulfill the requirements of the class. By implementing `IRateCalculator`,
    `RateCalculator` is forced to have an implementation for the `FindLender` method,
    which is not needed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`RateCalculator`类具有`GetYearlyCarLoanRate`和`GetYearlyHouseLoanRate`方法，这些方法是必需的以满足类的要求。通过实现`IRateCalculator`，`RateCalculator`被迫为`FindLender`方法实现，而这并不需要：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding `IRateCalculator` can be refactored into two cohesive interfaces
    that have methods that can be logically grouped together. With the small interfaces,
    the code can be written with great flexibility and unit testing the classes that
    implement the interface is easy:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的`IRateCalculator`可以重构为两个具有可以逻辑分组在一起的方法的连贯接口。通过小接口，可以以极大的灵活性编写代码，并且易于对实现接口的类进行单元测试：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With `IRateCalculator` refactored into two interfaces, `RateCalculator` can
    be refactored to remove the `FindLender` method that is not required:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`IRateCalculator`重构为两个接口，`RateCalculator`可以被重构以删除不需要的`FindLender`方法：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: An anti-pattern to watch out for while implementing interfaces that comply with
    the ISP is the creation of one interface per method, in an attempt to create thin
    interfaces; these can lead to the creation of several interfaces, resulting in
    a code base that will be difficult to maintain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现符合ISP的接口时要注意的反模式是为每个方法创建一个接口，试图创建薄接口；这可能导致创建多个接口，从而导致难以维护的代码库。
- en: Dependency Inversion Principle
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: Rigid or bad designs can make changes to components or modules of software applications
    very difficult and create maintenance issues. These nonflexible designs can often
    break functionalities that might earlier be working. These can come in the forms
    of incorrect use of principles and patterns, bad code, and coupling of different
    components or layers, thereby making the maintenance process a very difficult
    one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 刚性或糟糕的设计可能会使软件应用程序的组件或模块的更改变得非常困难，并创建维护问题。这些不灵活的设计通常会破坏先前正常工作的功能。这可能以原则和模式的错误使用、糟糕的代码和不同组件或层的耦合形式出现，从而使维护过程变得非常困难。
- en: When you have a rigid design in an application code base, examining the code
    closely will reveal that the modules are tightly coupled, making changes difficult.
    Making changes to any of the modules can create the risk of breaking another module
    that was working before. Observing the last of the SOLID principles—the **Dependency
    Inversion Principle** (**DIP**) can eliminate any coupling of modules, making
    the code base flexible and easy to maintain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序代码库中存在严格的设计时，仔细检查代码将会发现模块之间紧密耦合，使得更改变得困难。对任何模块的更改可能会导致破坏先前正常工作的另一个模块的风险。观察SOLID原则中的最后一个——依赖反转原则（DIP）可以消除模块之间的任何耦合，使代码库灵活且易于维护。
- en: 'The DIP has two forms, both intended to achieve code flexibility and loose
    coupling between objects and their dependencies:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: DIP有两种形式，都旨在实现代码的灵活性和对象及其依赖项之间的松耦合：
- en: High-level modules should not depend on low-level modules; both should depend
    on abstractions
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应依赖于低级模块；两者都应依赖于抽象
- en: Abstractions should not depend on details; details should depend on abstractions
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节；细节应依赖于抽象
- en: When high-level modules or entities are directly coupled to low-level modules,
    making changes to the low-level modules can often have a direct impact on the
    high-level modules, causing them to change, creating a ripple effect. In practical
    terms, it is when changes are made to higher level modules that the low-level
    modules should change.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当高级模块或实体直接耦合到低级模块时，对低级模块进行更改通常会直接影响高级模块，导致它们发生变化，产生连锁反应。在实际情况下，当对高级模块进行更改时，低级模块应该发生变化。
- en: 'Also, you can apply DIP wherever you have classes that have to talk to or send
    messages to other classes. The DIP advocates the well-known principle of layering,
    or separation of concerns, in application development:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在需要类与其他类通信或发送消息的任何地方应用DIP。DIP倡导应用程序开发中众所周知的分层原则或关注点分离原则：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `AuthenticationManager` class in the preceding code snippet represents a
    high-level module, while the `DbContext` Entity Framework that was passed to the
    class constructor is a low-level module responsible for CRUD and data layer activities.
    While a nonprofessional developer might not see anything wrong in the code structure,
    it violates the DIP. This is because the `AuthenticationManager` class depends
    on the `DbContext` class and an attempt to makes changes to the inner code of
    `DbContext` will trickle up to `AuthenticationManager`, causing it to change which
    will result in the violation of the OCP.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`AuthenticationManager`类代表了一个高级模块，而传递给类构造函数的`DbContext` Entity Framework是一个负责CRUD和数据层活动的低级模块。虽然非专业的开发人员可能不会在代码结构中看到任何问题，但它违反了DIP。这是因为`AuthenticationManager`类依赖于`DbContext`类，并且对`DbContext`内部代码进行更改的尝试将会传播到`AuthenticationManager`，导致它发生变化，从而违反OCP。
- en: 'We can refactor the `AuthenticationManager` class to have a good design and
    comply with the DIP. This will necessitate the creation of an `IDbContext` interface and
    make `DbContext` implement the interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构`AuthenticationManager`类，使其具有良好的设计并符合DIP。这将需要创建一个`IDbContext`接口，并使`DbContext`实现该接口。
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`AuthenticationManager` can be coded against the interface, thereby breaking
    the coupling or direct dependence on `DbContext` and instead depending on the
    abstraction. Coding `AuthenticationManager` against `IDbContext` means the interface
    will be injected in the constructor of `AuthenticationManager` or by using *Property
    Injection*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationManager`可以根据接口编码，从而打破与`DbContext`的耦合或直接依赖，并且依赖于抽象。对`AuthenticationManager`进行编码，使其针对`IDbContext`意味着接口将被注入到`AuthenticationManager`的构造函数中，或者使用*属性注入*：'
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the refactoring done, `AuthenticationManager` now uses dependency inversion
    and depends on abstraction—`IDbContext`. In future, if changes are made to the
    `DbContext` class, it can no longer affect the `AuthenticationManager` class and
    will not violate the OCP.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重构完成后，`AuthenticationManager`现在使用依赖反转，并依赖于抽象—`IDbContext`。将来，如果对`DbContext`类进行更改，将不再影响`AuthenticationManager`类，并且不会违反OCP。
- en: 'While `IDbContext` injected to `AutheticationManager` through the constructor
    is very elegant, the `IDbcontext` can also be injected into `AuthenticationManager`
    through a public property:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过构造函数将`IDbContext`注入到`AutheticationManager`中非常优雅，但`IDbcontext`也可以通过公共属性注入到`AuthenticationManager`中：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Additionally, DI can be done through *Interface Injection*, where object references
    are passed using interface actions. It simply means interfaces are used to inject
    dependencies. The following snippet explains the concept of dependency using an
    interface injection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DI也可以通过*接口注入*来实现，其中对象引用是使用接口操作传递的。这简单地意味着使用接口来注入依赖项。以下代码片段解释了使用接口注入来实现依赖的概念。
- en: '`IRateParser` is created with the `ParseRate` method definition. A second interface, `IRepository`,
    is created containing the `InjectRateParser` method, which accepts `IRateParser`
    as an argument and will inject the dependency:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRateParser`是使用`ParseRate`方法定义创建的。第二个接口`IRepository`包含`InjectRateParser`方法，该方法接受`IRateParser`作为参数，并将注入依赖项。'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s create the `LoanRepository` class to implement the `IRepository`
    interface and have a code implementation for `InjectRateParser`, to inject the `IRateParser`
    repository into the `LoanRepository` class as dependency for use in the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`LoanRepository`类来实现`IRepository`接口，并为`InjectRateParser`创建一个代码实现，以将`IRateParser`存储库作为依赖项注入到`LoanRepository`类中以供代码使用：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we can create concrete implementations of the `IRateParser` dependency,
    `XmlRateParser` and `RestServiceRateParser`, which both contain implementations
    of the `ParseRate` method for parsing loan rates from XML and REST sources:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建`IRateParser`依赖的具体实现，`XmlRateParser`和`RestServiceRateParser`，它们都包含了从XML和REST源解析贷款利率的`ParseRate`方法的实现：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To wrap it up, we can test the *Interface Injection* concept using the interfaces
    and the classes created in the preceding snippets. A concrete object of `IRateParser`
    is constructed, which is injected into the `LoanRepository` class, through the
    `IRepository` interface, and any of the two implementations of the `IRateParser`
    interface can be used to construct it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以使用在前面的代码片段中创建的接口和类来测试*接口注入*概念。创建了`IRateParser`的具体对象，它被注入到`LoanRepository`类中，通过`IRepository`接口，并且可以使用`IRateParser`接口的两种实现之一来构造它。
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Any of the three techniques described in this section can be effectively used
    to inject dependencies into your code wherever it is required. Appropriate and
    effective use of DIP can facilitate the creation of loosely coupled applications
    that can be easily maintained.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中描述的任何三种技术都可以有效地用于在需要时将依赖项注入到代码中。适当有效地使用DIP可以促进创建易于维护的松散耦合的应用程序。
- en: Setting up a DI container for ASP.NET Core MVC
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ASP.NET Core MVC设置DI容器
- en: Central to ASP.NET Core is DI. The framework provides built-in DI services to
    allow developers to create loosely coupled applications and prevent instantiation
    or construction of dependencies. Using the built-in DI services, your application
    code can be set up to use DI, and dependencies can be injected into methods in
    the `Startup` class.  While the default DI container has some cool features, you
    can still use other known, matured DI containers in ASP.NET core applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的核心是DI。该框架提供了内置的DI服务，允许开发人员创建松散耦合的应用程序，并防止依赖关系的实例化或构造。使用内置的DI服务，您的应用程序代码可以设置为使用DI，并且依赖项可以被注入到`Startup`类中的方法中。虽然默认的DI容器具有一些很酷的功能，但您仍然可以在ASP.NET
    Core应用程序中使用其他已知的成熟的DI容器。
- en: 'You can configure your code to use DI in two modes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将代码配置为以两种模式使用DI：
- en: '**Constructor Injection**: The interfaces required by a class are passed or
    injected via the class''s public constructor. Constructor injection is not possible
    using a private constructor, an `InvalidOperationException` will be thrown when
    this is attempted. In a class with an overloaded constructor, only one of the
    constructors can be used for DI.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：类所需的接口通过类的公共构造函数传递或注入。使用私有构造函数无法进行构造函数注入，当尝试这样做时，将引发`InvalidOperationException`。在具有重载构造函数的类中，只能使用一个构造函数进行DI。'
- en: '**Property Injection**: Dependencies are injected into a class by using public
    interface properties in the class. Any of the two modes can be used to request
    dependencies, which will be injected by the DI container.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性注入**：通过在类中使用公共接口属性将依赖项注入到类中。可以使用这两种模式之一来请求依赖项，这些依赖项将由DI容器注入。'
- en: A DI container, also known as an **Inversion of Control** (**IoC**) container,
    is typically a class or factory that can create classes with their associated
    dependencies. Before a class with injected dependencies can be successfully constructed,
    the project must be designed or set up to use DI, and the DI container must have
    been configured with the dependency types. In essence, the DI will have a configuration
    containing mappings of the interfaces to their concrete classes and will use this
    configuration to resolve the requested dependencies for the classes that require
    them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器，也称为**控制反转**（**IoC**）容器，通常是一个可以创建具有其关联依赖项的类的类或工厂。在成功构造具有注入依赖项的类之前，项目必须设计或设置为使用DI，并且DI容器必须已配置为具有依赖类型。实质上，DI将具有包含接口到其具体类的映射的配置，并将使用此配置来解析所需依赖项的类。
- en: 'The ASP.NET Core built-in IoC container is depicted by the `IServiceProvider`
    interface and you can configure it using the `ConfigureService` method in the
    `Startup` class. The container has a default support for constructor injection.
    In the `ConfigureService` method, services and platform features such as Entity
    Framework core and ASP.NET MVC core can be defined:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core内置的IoC容器由`IServiceProvider`接口表示，您可以使用`Startup`类中的`ConfigureService`方法对其进行配置。容器默认支持构造函数注入。在`ConfigureService`方法中，可以定义服务和平台功能，例如Entity
    Framework Core和ASP.NET MVC Core：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The ASP.NET Core inbuilt container has some extension methods, such as `AddDbContext`,
    `AddIdentity`, and `AddMvc`, that you can use to add additional services. The
    application dependencies can be configured using the `AddTransient` method, which
    takes two generic-type arguments, the first is the interface and the second is
    the concrete class. The `AddTransient` method maps the interface to the concrete
    class, so the service is created every time it is requested. The container uses
    this configuration to inject the interfaces for every object that requires it
    in the ASP.NET MVC project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core内置容器具有一些扩展方法，例如`AddDbContext`、`AddIdentity`和`AddMvc`，您可以使用这些方法添加其他服务。可以使用`AddTransient`方法配置应用程序依赖项，该方法接受两个泛型类型参数，第一个是接口，第二个是具体类。`AddTransient`方法将接口映射到具体类，因此每次请求时都会创建服务。容器使用此配置为在ASP.NET
    MVC项目中需要它的每个对象注入接口。
- en: 'Other extension methods for configuring services are the `AddScoped` and `AddSingleton`
    methods. `AddScoped` only creates a service once per request:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置服务的其他扩展方法是`AddScoped`和`AddSingleton`方法。`AddScoped`每次请求只创建一次服务：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `AddSingleton` method creates a service only the first time it is requested
    and keeps it in memory, making it available for use for subsequent requests of
    the service. You can instantiate the singleton yourself or simply leave it for
    the container to do:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton`方法只在首次请求时创建服务，并将其保存在内存中，使其可供后续请求使用。您可以自行实例化单例，也可以让容器来处理：'
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The built-in IoC container for ASP.NET Core is lightweight and has limited features,
    but basically you can use it for DI configuration in your applications. However,
    you can replace it with other IoC containers available in .NET, such as **Ninject**
    or **Autofac**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的内置IoC容器轻量级且功能有限，但基本上您可以在应用程序中使用它进行DI配置。但是，您可以将其替换为.NET中可用的其他IoC容器，例如**Ninject**或**Autofac**。
- en: Using DI will simplify your application development experience and enable you
    to craft code that is loosely coupled and can easily be tested. In a typical ASP.NET
    Core MVC application, you should use DI for dependencies, such as **Repositories**,
    **Controllers**, **Adapters**, and **Services**, and avoid static access to services
    or `HttpContext`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DI将简化应用程序开发体验，并使您能够编写松散耦合且易于测试的代码。在典型的ASP.NET Core MVC应用程序中，您应该使用DI来处理依赖项，例如**存储库**、**控制器**、**适配器**和**服务**，并避免对服务或`HttpContext`进行静态访问。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using the object-oriented design principles in this chapter will assist you
    in mastering the skills required to write clean, flexible, easy-to-maintain, and
    easy-to-test code. The LoD and the SOLID principles explained in the chapter can
    serve as guidelines for creating loosely coupled, object-oriented software applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的面向对象设计原则将帮助您掌握编写清晰、灵活、易于维护和易于测试代码所需的技能。本章中解释的LoD和SOLID原则可以作为创建松散耦合的面向对象软件应用程序的指导原则。
- en: In order to reap the benefits of a TDD cycle, you must write code that is testable.
    The SOLID principles covered describes appropriate practices that can facilitate
    the writing of testable code that can be easily maintained and then enhanced when
    needed. The last section of the chapter focused on setting up and using a dependency-injection
    container for an ASP.NET Core MVC application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得TDD周期的好处，您必须编写可测试的代码。所涵盖的SOLID原则描述了适当的实践，可以促进编写可轻松维护并在需要时进行增强的可测试代码。本章的最后一节着重介绍了为ASP.NET
    Core MVC应用程序设置和使用依赖注入容器。
- en: In the next chapter, we will discuss the attributes of a good unit test, the
    .NET ecosystem of unit testing frameworks available for use in creating tests,
    what to consider when unit testing ASP.NET MVC Core projects, and we will delve
    into the unit testing property on the .NET Core platform using the xUnit library.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论良好单元测试的属性，.NET生态系统中可用于创建测试的单元测试框架，以及在单元测试ASP.NET MVC Core项目时需要考虑的内容，我们还将深入探讨在.NET
    Core平台上使用xUnit库进行单元测试的属性。
