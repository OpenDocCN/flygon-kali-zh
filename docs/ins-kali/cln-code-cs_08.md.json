["```cs\nvar foregroundThread = new Thread(SomeMethodName);\nforegroundThread.Start();\n```", "```cs\nvar backgroundThread = new Thread(SomeMethodName);\nbackgroundThread.IsBackground = true;\nbackgroundThread.Start();\n```", "```cs\nprivate static int Add(int a, int b)\n{\n return a + b;\n}\n```", "```cs\nprivate static void ThreadParametersExample()\n{\n    int result = 0;\n    Thread thread = new Thread(() => { result = Add(1, 2); });\n    thread.Start();\n    thread.Join();\n    Message($\"The addition of 1 plus 2 is {result}.\");\n}\n```", "```cs\ninternal static void Message(string message)\n{\n    Console.WriteLine(message);\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    ThreadParametersExample();\n    Message(\"=== Press any Key to exit ===\");\n    Console.ReadKey();\n}\n```", "```cs\nprivate static void MethodOne()\n{\n    Message($\"MethodOne Executed: Thread Id({Thread.CurrentThread.ManagedThreadId})\");\n}\n\nprivate static void MethodTwo()\n{\n    Message($\"MethodTwo Executed: Thread Id({Thread.CurrentThread.ManagedThreadId})\");\n}\n\nprivate static void MethodThree()\n{\n    Message($\"MethodThree Executed: Thread Id({Thread.CurrentThread.ManagedThreadId})\");\n}\n```", "```cs\nprivate static void UsingTaskParallelLibrary()\n{\n    Message($\"UsingTaskParallelLibrary Started: Thread Id = ({Thread.CurrentThread.ManagedThreadId})\");\n    Parallel.Invoke(MethodOne, MethodTwo, MethodThree);\n    Message(\"UsingTaskParallelLibrary Completed.\");\n}\n```", "```cs\nprivate static void Method()\n{\n    Message($\"Method Executed: Thread Id({Thread.CurrentThread.ManagedThreadId})\");\n}\n```", "```cs\nprivate static void UsingTaskParallelLibraryFor()\n{\n    Message($\"UsingTaskParallelLibraryFor Started: Thread Id = ({Thread.CurrentThread.ManagedThreadId})\");\n    Parallel.For(0, 1000, X => Method());\n    Message(\"UsingTaskParallelLibraryFor Completed.\");\n}\n```", "```cs\nprivate static void WaitCallbackMethod(Object _)\n{\n    Message(\"Hello from WaitCallBackMethod!\");\n}\n```", "```cs\nprivate static void ThreadPoolQueueUserWorkItem()\n{\n    ThreadPool.QueueUserWorkItem(WaitCallbackMethod);\n    Message(\"Main thread does some work, then sleeps.\");\n    Thread.Sleep(1000);\n    Message(\"Main thread exits.\");\n}\n```", "```cs\nprivate static readonly Mutex _mutex = new Mutex();\n```", "```cs\nprivate static void ThreadSynchronisationUsingMutex()\n{\n    try\n    {\n        _mutex.WaitOne();\n        Message($\"Domain Entered By: {Thread.CurrentThread.Name}\");\n        Thread.Sleep(500);\n        Message($\"Domain Left By: {Thread.CurrentThread.Name}\");\n    }\n    finally\n    {\n        _mutex.ReleaseMutex();\n    }\n}\n```", "```cs\nprivate static void MutexExample()\n{\n    for (var i = 1; i <= 10; i++)\n    {\n        var thread = new Thread(ThreadSynchronisationUsingMutex)\n        {\n            Name = $\"Mutex Example Thread: {i}\"\n        };\n        thread.Start();\n    }\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    SemaphoreExample();\n    Console.ReadKey();\n}\n```", "```cs\nprivate static readonly Semaphore _semaphore = new Semaphore(2, 4); \n```", "```cs\nprivate static void StartSemaphore(object id)\n{\n    Console.WriteLine($\"Object {id} wants semaphore access.\");\n try\n {\n _semaphore.WaitOne();\n Console.WriteLine($\"Object {id} gained semaphore access.\");\n Thread.Sleep(1000);\n Console.WriteLine($\"Object {id} has exited semaphore.\");\n }\n finally\n {\n _semaphore.Release();\n }\n}\n```", "```cs\nprivate static void SemaphoreExample()\n{\n    for (int i = 1; i <= 10; i++)\n    {\n        Thread t = new Thread(StartSemaphore);\n        t.Start(i);\n    }\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    SemaphoreExample();\n    Console.ReadKey();\n}\n```", "```cs\nprivate static void AssignCores(int cores)\n{\n    Process.GetCurrentProcess().ProcessorAffinity = new IntPtr(cores);\n}\n```", "```cs\nprivate static void SetMaxThreads(int workerThreads, int asyncIoThreads)\n{\n    ThreadPool.SetMaxThreads(workerThreads, asyncIoThreads);\n}\n```", "```cs\nstatic object _object1 = new object();\n static object _object2 = new object();\n```", "```cs\nprivate static void Thread1Method()\n {\n     Console.WriteLine(\"Thread1Method: Thread1Method Entered.\");\n     lock (_object1)\n     {\n         Console.WriteLine(\"Thread1Method: Entered _object1 lock. Sleeping...\");\n         Thread.Sleep(1000);\n         Console.WriteLine(\"Thread1Method: Woke from sleep\");\n         lock (_object2)\n         {\n             Console.WriteLine(\"Thread1Method: Entered _object2 lock.\");\n         }\n         Console.WriteLine(\"Thread1Method: Exited _object2 lock.\");\n     }\n     Console.WriteLine(\"Thread1Method: Exited _object1 lock.\");\n }\n```", "```cs\nprivate static void Thread2Method()\n {\n     Console.WriteLine(\"Thread2Method: Thread1Method Entered.\");\n     lock (_object2)\n     {\n         Console.WriteLine(\"Thread2Method: Entered _object2 lock. Sleeping...\");\n         Thread.Sleep(1000);\n         Console.WriteLine(\"Thread2Method: Woke from sleep.\");\n         lock (_object1)\n         {\n             Console.WriteLine(\"Thread2Method: Entered _object1 lock.\");\n         }\n         Console.WriteLine(\"Thread2Method: Exited _object1 lock.\");\n     }\n     Console.WriteLine(\"Thread2Method: Exited _object2 lock.\");\n }\n```", "```cs\nprivate static void DeadlockNoRecovery()\n {\n     Thread thread1 = new Thread((ThreadStart)Thread1Method);\n     Thread thread2 = new Thread((ThreadStart)Thread2Method);\n\n     thread1.Start();\n     thread2.Start();\n\n     Console.WriteLine(\"Press any key to exit.\");\n     Console.ReadKey();\n }\n```", "```cs\nstatic void Main()\n {\n     DeadlockNoRecovery();\n }\n```", "```cs\nprivate static void DeadlockWithRecovery()\n {\n     Thread thread4 = new Thread((ThreadStart)Thread4Method);\n     Thread thread5 = new Thread((ThreadStart)Thread5Method);\n\n     thread4.Start();\n     thread5.Start();\n\n     Console.WriteLine(\"Press any key to exit.\");\n     Console.ReadKey();\n }\n```", "```cs\nprivate static void Thread4Method()\n {\n     Console.WriteLine(\"Thread4Method: Entered _object1 lock. Sleeping...\");\n     Thread.Sleep(1000);\n     Console.WriteLine(\"Thread4Method: Woke from sleep\");\n     if (!Monitor.TryEnter(_object1))\n     {\n         Console.WriteLine(\"Thead4Method: Failed to lock _object1.\");\n         return;\n     }\n     try\n     {\n         if (!Monitor.TryEnter(_object2))\n         {\n             Console.WriteLine(\"Thread4Method: Failed to lock _object2.\");\n             return;\n         }\n         try\n         {\n             Console.WriteLine(\"Thread4Method: Doing work with _object2.\");\n         }\n         finally\n         {\n             Monitor.Exit(_object2);\n             Console.WriteLine(\"Thread4Method: Released _object2 lock.\");\n         }\n     }\n     finally\n     {\n         Monitor.Exit(_object1);\n         Console.WriteLine(\"Thread4Method: Released _object2 lock.\");\n     }\n }\n```", "```cs\nprivate static void Thread5Method()\n {\n     Console.WriteLine(\"Thread5Method: Entered _object2 lock. Sleeping...\");\n     Thread.Sleep(1000);\n     Console.WriteLine(\"Thread5Method: Woke from sleep\");\n     if (!Monitor.TryEnter(_object2))\n     {\n         Console.WriteLine(\"Thead5Method: Failed to lock _object2.\");\n         return;\n     }\n     try\n     {\n         if (!Monitor.TryEnter(_object1))\n         {\n             Console.WriteLine(\"Thread5Method: Failed to lock _object1.\");\n             return;\n         }\n         try\n         {\n             Console.WriteLine(\"Thread5Method: Doing work with _object1.\");\n         }\n         finally\n         {\n             Monitor.Exit(_object1);\n             Console.WriteLine(\"Thread5Method: Released _object1 lock.\");\n         }\n     }\n     finally\n     {\n         Monitor.Exit(_object2);\n         Console.WriteLine(\"Thread5Method: Released _object2 lock.\");\n     }\n }\n```", "```cs\nstatic void Main()\n {\n     DeadlockWithRecovery();\n }\n```", "```cs\nstatic void ThreadingRaceCondition()\n {\n     Thread T1 = new Thread(Method1);\n     T1.Start();\n     Thread T2 = new Thread(Method2);\n     T2.Start();\n }\n```", "```cs\nstatic void Method1()\n {\n     for (_alphabetCharacter = 'A'; _alphabetCharacter <= 'Z'; _alphabetCharacter ++)\n     {\n         Console.Write(_alphabetCharacter + \" \");\n     }\n }\n\nprivate static void Method2()\n {\n     for (_alphabetCharacter = 'a'; _alphabetCharacter <= 'z'; _alphabetCharacter++)\n     {\n         Console.Write(_alphabetCharacter + \" \");\n     }\n }\n```", "```cs\nprivate static char _alphabetCharacter;\n```", "```cs\nstatic void Main(string[] args)\n {\n     Console.WriteLine(\"\\n\\nRace Condition:\");\n     ThreadingRaceCondition();\n     Console.WriteLine(\"\\n\\nPress any key to exit.\");\n     Console.ReadKey();\n }\n```", "```cs\nstatic void ThreadingRaceConditionFixed()\n {\n     Task\n         .Run(() => Method1())\n         .ContinueWith(task => Method2())\n         .Wait();\n }\n```", "```cs\nstatic void Main(string[] args)\n {\n     //Console.WriteLine(\"\\n\\nRace Condition:\");\n     //ThreadingRaceCondition();\n     Console.WriteLine(\"\\n\\nRace Condition Fixed:\");\n     ThreadingRaceConditionFixed();\n     Console.WriteLine(\"\\n\\nPress any key to exit.\");\n     Console.ReadKey();\n }\n```", "```cs\npublic class StaticConstructorTestClass\n{\n    private readonly static string _message;\n}\n```", "```cs\npublic static string Message()\n{\n    return $\"Message: {_message}\";\n}\n```", "```cs\nstatic StaticConstructorTestClass()\n{\n    Console.WriteLine(\"StaticConstructorTestClass static constructor started.\");\n    _message = \"Hello, World!\";\n    Thread.Sleep(1000);\n    _message = \"Goodbye, World!\";\n    Console.WriteLine(\"StaticConstructorTestClass static constructor finished.\");\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    var program = new Program();\n    program.StaticConstructorExample();\n    Thread.CurrentThread.Join();\n}\n```", "```cs\npublic static class StaticExampleClass\n{\n    private static int _x = 1;\n    private static int _y = 2;\n    private static int _z = 3;\n}\n```", "```cs\nstatic StaticExampleClass()\n{\n    Console.WriteLine($\"Constructor: _x={_x}, _y={_y}, _z={_z}\");\n}\n```", "```cs\ninternal static void ThreadSafeMethod(int x, int y, int z)\n{\n    Console.WriteLine($\"ThreadSafeMethod: x={x}, y={y}, z={z}\");\n    Console.WriteLine($\"ThreadSafeMethod: {x}+{y}+{z}={x+y+z}\");\n}\n```", "```cs\ninternal static void NotThreadSafeMethod(int x, int y, int z)\n{\n    _x = x;\n    _y = y;\n    _z = z;\n    Console.WriteLine(\n        $\"{Thread.CurrentThread.ManagedThreadId}-NotThreadSafeMethod: _x={_x}, _y={_y}, _z={_z}\"\n    );\n    Thread.Sleep(300);\n    Console.WriteLine(\n        $\"{Thread.CurrentThread.ManagedThreadId}-ThreadSafeMethod: {_x}+{_y}+{_z}={_x + _y + _z}\"\n    );\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    var program = new Program();\n    program.ThreadUnsafeMethodCall();\n    Console.ReadKey();\n}\n```", "```cs\nprivate void ThreadUnsafeMethodCall()\n{\n    for (var index = 0; index < 10; index++)\n    {\n        var thread = new Thread(() =>\n        {\n            StaticExampleClass.NotThreadSafeMethod(index + 1, index + 2, index + 3);\n        });\n        thread.Start();\n    }\n}\n```", "```cs\ninternal class MutableClass\n{\n    private readonly int[] _intArray;\n\n    public MutableClass(int[] intArray)\n    {\n        _intArray = intArray;\n    }\n\n    public int[] GetIntArray()\n    {\n        return _intArray;\n    }\n}\n```", "```cs\nprivate static void MutableExample()\n{\n    int[] iar = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    var mutableClass = new MutableClass(iar);\n\n    Console.WriteLine($\"Initial Array: {iar[0]}, {iar[1]}, {iar[2]}, {iar[3]}, {iar[4]}, {iar[5]}, {iar[6]}, {iar[7]}, {iar[8]}, {iar[9]}\");\n\n    for (var x = 0; x < 9; x++)\n    {\n        var thread = new Thread(() =>\n            {\n                iar[x] = x + 1;\n                var ia = mutableClass.GetIntArray();\n                Console.WriteLine($\"Array [{x}]: {ia[0]}, {ia[1]}, {ia[2]}, {ia[3]}, {ia[4]}, {ia[5]}, {ia[6]}, {ia[7]}, {ia[8]}, {ia[9]}\");\n            });\n            thread.Start();\n    }\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    MutableExample();\n    Console.ReadKey();\n}            \n```", "```cs\ninternal struct ImmutableStruct\n{ \n    private ImmutableArray<int> _immutableArray;\n\n    public ImmutableStruct(ImmutableArray<int> immutableArray)\n    {\n        _immutableArray = immutableArray;\n    }\n\n    public int[] GetIntArray()\n    {\n        return _immutableArray.ToArray<int>();\n    }\n}\n```", "```cs\nprivate static void ImmutableExample()\n{\n    int[] iar = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    var immutableStruct = new ImmutableStruct(iar.ToImmutableArray<int>());\n\n    Console.WriteLine($\"Initial Array: {iar[0]}, {iar[1]}, {iar[2]}, {iar[3]}, {iar[4]}, {iar[5]}, {iar[6]}, {iar[7]}, {iar[8]}, {iar[9]}\");\n\n    for (var x = 0; x < 9; x++)\n    {\n        var thread = new Thread(() =>\n        {\n            iar[x] = x + 1;\n            var ia = immutableStruct.GetIntArray();\n            Console.WriteLine($\"Array [{x}]: {ia[0]}, {ia[1]}, {ia[2]}, {ia[3]}, {ia[4]}, {ia[5]}, {ia[6]}, {ia[7]}, {ia[8]}, {ia[9]}\");\n        });\n        thread.Start();\n    }\n}\n```", "```cs\npublic readonly struct ImmutablePerson\n{\n    public ImmutablePerson(int id, string firstName, string lastName)\n    {\n        _id = id;\n        _firstName = firstName;\n        _lastName = lastName;\n    }\n\n    public int Id { get; }\n    public string FirstName { get;\n    public string LastName { get { return _lastName; } }\n}\n```", "```cs\npublic class LockExample\n{\n    public object _lock = new object();\n\n    public void UnsafeMethod() \n    {\n        lock(_lock)\n        {\n            // Execute unsafe code.\n        }\n    }\n}\n```", "```cs\nprivate static readonly Mutex _mutex = new Mutex();\n```", "```cs\ntry\n{\n    _mutex.WaitOne();\n    // ... Do work here ...\n}\nfinally\n{\n    _mutex.ReleaseMutex();\n}\n```", "```cs\nprivate static readonly Semaphore _semaphore = new Semaphore(2, 4); \n```", "```cs\ntry\n{\n    _semaphore.WaitOne();\n    // ... Do work here ...\n}\nfinally\n{\n    _semaphore.Release();\n}\n```", "```cs\n[MethodImpl(MethodImplOptions.Synchronized)]\n public static void ThisIsASynchronisedMethod()\n {\n      Console.WriteLine(\"Synchronised method called.\");\n }\n```", "```cs\nprivate int i;\n public int SomeProperty\n {\n     [MethodImpl(MethodImplOptions.Synchronized)]\n     get { return i; }\n     [MethodImpl(MethodImplOptions.Synchronized)]\n     set { i = value; }\n }\n```", "```cs\nprivate static long _value = long.MaxValue;\nprivate static int _resourceInUse = 0;\n```", "```cs\nprivate static void CompareExchangeVariables()\n{\n    Interlocked.CompareExchange(ref _value, 123, long.MaxValue);\n}\n```", "```cs\nprivate static void AddVariables()\n{\n    Interlocked.Add(ref _value, 321);\n}\n```", "```cs\nprivate static void DecrementVariable()\n{\n    Interlocked.Decrement(ref _value);\n}\n```", "```cs\nprivate static void IncrementVariable()\n{\n    Interlocked.Increment(ref _value);\n}\n```", "```cs\nprivate static long ReadVariable()\n{\n    // The Read method is unnecessary on 64-bit systems, because 64-bit \n    // read operations are already atomic. On 32-bit systems, 64-bit read \n    // operations are not atomic unless performed using Read.\n    return Interlocked.Read(ref _value);\n}\n```", "```cs\nprivate static void PerformUnsafeCodeSafely()\n{\n    for (int i = 0; i < 5; i++)\n    {\n        UseResource();\n        Thread.Sleep(1000);\n    }\n}\n```", "```cs\nstatic bool UseResource()\n{\n    if (0 == Interlocked.Exchange(ref _resourceInUse, 1))\n    {\n        Console.WriteLine($\"{Thread.CurrentThread.Name} acquired the lock\");\n        NonThreadSafeResourceAccess();\n        Thread.Sleep(500);\n        Console.WriteLine($\"{Thread.CurrentThread.Name} exiting lock\");\n        Interlocked.Exchange(ref _resourceInUse, 0);\n        return true;\n    }\n    else\n    {\n        Console.WriteLine($\"{Thread.CurrentThread.Name} was denied the lock\");\n        return false;\n    }\n}\n```", "```cs\nprivate static void NonThreadSafeResourceAccess()\n{\n    Console.WriteLine(\"Non-thread-safe code executed.\");\n}\n```", "```cs\nstatic void Main(string[] args)\n{\n    CompareExchangeVariables();\n    AddVariables();\n    DecrementVariable();\n    IncrementVariable();\n    ReadVariable();\n    PerformUnsafeCodeSafely();\n}\n```"]