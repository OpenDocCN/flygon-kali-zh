["```cs\naz group create --name \"<YourResourceGroupName>\" --location \"East US\"\n```", "```cs\naz keyvault create --name \"<YourKeyVaultName>\" --resource-group \"<YourResourceGroupName> --location \"East US\"\n```", "```cs\naz keyvault secret set --vault-name \"<YourKeyVaultName>\" --name \"MorningstarApiKey\" --value \"<YourMorningstarApiKey>\"\n```", "```cs\naz keyvault secret show --name \"MorningstarApiKey\" --vault-name \"<YourKeyVaultName>\"\n```", "```cs\n[{\"date\":\"2020-04-13T20:02:22.8144942+01:00\",\"temperatureC\":0,\"temperatureF\":32,\"summary\":\"Balmy\"},{\"date\":\"2020-04-14T20:02:22.8234349+01:00\",\"temperatureC\":13,\"temperatureF\":55,\"summary\":\"Warm\"},{\"date\":\"2020-04-15T20:02:22.8234571+01:00\",\"temperatureC\":3,\"temperatureF\":37,\"summary\":\"Scorching\"},{\"date\":\"2020-04-16T20:02:22.8234587+01:00\",\"temperatureC\":-2,\"temperatureF\":29,\"summary\":\"Sweltering\"},{\"date\":\"2020-04-17T20:02:22.8234602+01:00\",\"temperatureC\":-13,\"temperatureF\":9,\"summary\":\"Cool\"}]\n```", "```cs\n[{\"date\":\"2020-04-13T19:36:26.9794202+00:00\",\"temperatureC\":40,\"temperatureF\":103,\"summary\":\"Hot\"},{\"date\":\"2020-04-14T19:36:26.9797346+00:00\",\"temperatureC\":7,\"temperatureF\":44,\"summary\":\"Bracing\"},{\"date\":\"2020-04-15T19:36:26.9797374+00:00\",\"temperatureC\":8,\"temperatureF\":46,\"summary\":\"Scorching\"},{\"date\":\"2020-04-16T19:36:26.9797389+00:00\",\"temperatureC\":11,\"temperatureF\":51,\"summary\":\"Freezing\"},{\"date\":\"2020-04-17T19:36:26.9797403+00:00\",\"temperatureC\":3,\"temperatureF\":37,\"summary\":\"Hot\"}]\n```", "```cs\nusing CH09_DividendCalendar.Security.Authentication;\nusing System.Threading.Tasks;\n\nnamespace CH09_DividendCalendar.Repository\n{\n    public interface IRepository\n    {\n        Task<ApiKey> GetApiKey(string providedApiKey);\n    }\n}\n```", "```cs\nusing CH09_DividendCalendar.Security.Authentication;\nusing CH09_DividendCalendar.Security.Authorisation;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n```", "```cs\n    public class InMemoryRepository : IRepository\n    {\n        private readonly IDictionary<string, ApiKey> _apiKeys;\n\n        public Task<ApiKey> GetApiKey(string providedApiKey)\n        {\n            _apiKeys.TryGetValue(providedApiKey, out var key);\n            return Task.FromResult(key);\n        }\n    }\n```", "```cs\npublic InMemoryRepository()\n{\n    var existingApiKeys = new List<ApiKey>\n    {\n        new ApiKey(1, \"Internal\", \"C5BFF7F0-B4DF-475E-A331-F737424F013C\", new DateTime(2019, 01, 01),\n            new List<string>\n            {\n                Roles.Internal\n            }),\n        new ApiKey(2, \"External\", \"9218FACE-3EAC-6574-C3F0-08357FEDABE9\", new DateTime(2020, 4, 15),\n            new List<string>\n            {\n                Roles.External\n            })\n        };\n\n    _apiKeys = existingApiKeys.ToDictionary(x => x.Key, x => x);\n}\n```", "```cs\nnamespace CH09_DividendCalendar.Shared\n{\n    public struct ApiKeyConstants\n    {\n        public const string HeaderName = \"X-Api-Key\";\n        public const string MorningstarApiKeyUrl \n            = \"https://<YOUR_KEY_VAULT_NAME>.vault.azure.net/secrets/MorningstarApiKey\";\n    }\n}\n```", "```cs\nusing System.Text.Json;\n\nnamespace CH09_DividendCalendar.Json\n{\n    public static class DefaultJsonSerializerOptions\n    {\n        public static JsonSerializerOptions Options => new JsonSerializerOptions\n        {\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n            IgnoreNullValues = true\n        };\n    }\n}\n```", "```cs\npublic int Id { get; }\npublic string Owner { get; }\npublic string Key { get; }\npublic DateTime Created { get; }\npublic IReadOnlyCollection<string> Roles { get; }\n```", "```cs\npublic ApiKey(int id, string owner, string key, DateTime created, IReadOnlyCollection<string> roles)\n{\n    Id = id;\n    Owner = owner ?? throw new ArgumentNullException(nameof(owner));\n    Key = key ?? throw new ArgumentNullException(nameof(key));\n    Created = created;\n    Roles = roles ?? throw new ArgumentNullException(nameof(roles));\n}\n```", "```cs\npublic class UnauthorizedProblemDetails : ProblemDetails\n{\n    public UnauthorizedProblemDetails(string details = null)\n    {\n        Title = \"Forbidden\";\n        Detail = details;\n        Status = 403;\n        Type = \"https://httpstatuses.com/403\";\n    }\n}\n```", "```cs\npublic static class AuthenticationBuilderExtensions\n{\n    public static AuthenticationBuilder AddApiKeySupport(\n        this AuthenticationBuilder authenticationBuilder, \n        Action<ApiKeyAuthenticationOptions> options\n    )\n    {\n        return authenticationBuilder\n            .AddScheme<ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler>            \n                (ApiKeyAuthenticationOptions.DefaultScheme, options);\n    }\n}\n```", "```cs\npublic class ApiKeyAuthenticationOptions : AuthenticationSchemeOptions\n{\n    public const string DefaultScheme = \"API Key\";\n    public string Scheme => DefaultScheme;\n    public string AuthenticationType = DefaultScheme;\n}\n```", "```cs\npublic class ApiKeyAuthenticationHandler : AuthenticationHandler<ApiKeyAuthenticationOptions>\n{\n    private const string ProblemDetailsContentType = \"application/problem+json\";\n    private readonly IRepository _repository;\n}\n```", "```cs\npublic ApiKeyAuthenticationHandler(\n    IOptionsMonitor<ApiKeyAuthenticationOptions> options,\n    ILoggerFactory logger,\n    UrlEncoder encoder,\n    ISystemClock clock,\n    IRepository repository\n) : base(options, logger, encoder, clock)\n{\n    _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n}\n```", "```cs\nprotected override async Task HandleChallengeAsync(AuthenticationProperties properties)\n{\n    Response.StatusCode = 401;\n    Response.ContentType = ProblemDetailsContentType;\n    var problemDetails = new UnauthorizedProblemDetails();\n    await Response.WriteAsync(JsonSerializer.Serialize(problemDetails, \n        DefaultJsonSerializerOptions.Options));\n}\n```", "```cs\nprotected override async Task HandleForbiddenAsync(AuthenticationProperties properties)\n{\n    Response.StatusCode = 403;\n    Response.ContentType = ProblemDetailsContentType;\n    var problemDetails = new ForbiddenProblemDetails();\n    await Response.WriteAsync(JsonSerializer.Serialize(problemDetails, \n        DefaultJsonSerializerOptions.Options));\n}\n```", "```cs\nprotected override async Task<AuthenticateResult> HandleAuthenticateAsync()\n{\n    if (!Request.Headers.TryGetValue(ApiKeyConstants.HeaderName, out var apiKeyHeaderValues))\n        return AuthenticateResult.NoResult();\n    var providedApiKey = apiKeyHeaderValues.FirstOrDefault();\n    if (apiKeyHeaderValues.Count == 0 || string.IsNullOrWhiteSpace(providedApiKey))\n        return AuthenticateResult.NoResult();\n    var existingApiKey = await _repository.GetApiKey(providedApiKey);\n    if (existingApiKey != null) {\n        var claims = new List<Claim> {new Claim(ClaimTypes.Name, existingApiKey.Owner)};\n        claims.AddRange(existingApiKey.Roles.Select(role => new Claim(ClaimTypes.Role, role)));\n        var identity = new ClaimsIdentity(claims, Options.AuthenticationType);\n        var identities = new List<ClaimsIdentity> { identity };\n        var principal = new ClaimsPrincipal(identities);\n        var ticket = new AuthenticationTicket(principal, Options.Scheme);\n        return AuthenticateResult.Success(ticket);\n    }\n    return AuthenticateResult.Fail(\"Invalid API Key provided.\");\n}\n```", "```cs\npublic struct Roles\n{\n    public const string Internal = \"Internal\";\n    public const string External = \"External\";\n}\n```", "```cs\npublic struct Policies\n{\n    public const string Internal = nameof(Internal);\n    public const string External = nameof(External);\n}\n```", "```cs\npublic class ForbiddenProblemDetails : ProblemDetails\n{\n    public ForbiddenProblemDetails(string details = null)\n    {\n        Title = \"Forbidden\";\n        Detail = details;\n        Status = 403;\n        Type = \"https://httpstatuses.com/403\";\n    }\n}\n```", "```cs\npublic class ExternalAuthorisationHandler : AuthorizationHandler<ExternalRequirement>\n{\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context, \n        ExternalRequirement requirement\n    )\n    {\n        if (context.User.IsInRole(Roles.External))\n            context.Succeed(requirement);\n        return Task.CompletedTask;\n}\n public class ExternalRequirement : IAuthorizationRequirement\n {\n }\n```", "```cs\npublic class InternalAuthorisationHandler : AuthorizationHandler<InternalRequirement>\n{\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context, \n        InternalRequirement requirement\n    )\n    {\n        if (context.User.IsInRole(Roles.Internal))\n            context.Succeed(requirement);\n        return Task.CompletedTask;\n    }\n}\n```", "```cs\npublic class InternalRequirement : IAuthorizationRequirement\n{\n}\n```", "```cs\npublic void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    app.UseRouting();\n    app.UseAuthentication();\n app.UseAuthorization();\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllers();\n    });\n}\n```", "```cs\nservices.AddAuthentication(options =>\n{\n    options.DefaultAuthenticateScheme = ApiKeyAuthenticationOptions.DefaultScheme;\n    options.DefaultChallengeScheme = ApiKeyAuthenticationOptions.DefaultScheme;\n}).AddApiKeySupport(options => { });\n```", "```cs\nservices.AddAuthorization(options =>\n{\n    options.AddPolicy(Policies.Internal, policy => policy.Requirements.Add(new InternalRequirement()));\n    options.AddPolicy(Policies.External, policy => policy.Requirements.Add(new ExternalRequirement()));\n});\n```", "```cs\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class DividendCalendar : ControllerBase\n{\n    [Authorize(Policy = Policies.Internal)]\n    [HttpGet(\"internal\")]\n    public IActionResult GetDividendCalendar()\n    {\n        var message = $\"Hello from {nameof(GetDividendCalendar)}.\";\n        return new ObjectResult(message);\n    }\n\n    [Authorize(Policy = Policies.External)]\n    [HttpGet(\"external\")]\n    public IActionResult External()\n    {\n        var message = \"External access is currently unavailable.\";\n        return new ObjectResult(message);\n    }\n}\n```", "```cs\n[{\"Mic\":\"XLON\",\"Ticker\":\"ABDP\",\"CompanyName\":\"AB Dynamics PLC\",\"DividendYield\":0.0,\"Amount\":0.0279,\"ExDividendDate\":\"2020-01-02T00:00:00\",\"DeclarationDate\":\"2019-11-27T00:00:00\",\"RecordDate\":\"2020-01-03T00:00:00\",\"PaymentDate\":\"2020-02-13T00:00:00\",\"DividendType\":null,\"CurrencyCode\":null},\n\n...\n\n{\"Mic\":\"XLON\",\"Ticker\":\"ZYT\",\"CompanyName\":\"Zytronic PLC\",\"DividendYield\":0.0,\"Amount\":0.152,\"ExDividendDate\":\"2020-01-09T00:00:00\",\"DeclarationDate\":\"2019-12-10T00:00:00\",\"RecordDate\":\"2020-01-10T00:00:00\",\"PaymentDate\":\"2020-02-07T00:00:00\",\"DividendType\":null,\"CurrencyCode\":null}]\n```", "```cs\npublic class Dividend\n{\n    public string Mic { get; set; }\n    public string Ticker { get; set; }\n    public string CompanyName { get; set; }\n    public float DividendYield { get; set; }\n    public float Amount { get; set; }\n    public DateTime? ExDividendDate { get; set; }\n    public DateTime? DeclarationDate { get; set; }\n    public DateTime? RecordDate { get; set; }\n    public DateTime? PaymentDate { get; set; }\n    public string DividendType { get; set; }\n    public string CurrencyCode { get; set; }\n}\n```", "```cs\npublic class Company\n    {\n        public string MIC { get; set; }\n        public string Currency { get; set; }\n        public string Ticker { get; set; }\n        public string SecurityId { get; set; }\n        public string CompanyName { get; set; }\n    }\n```", "```cs\n public class Companies\n {\n     public int Total { get; set; }\n     public int Offset { get; set; }\n     public List<Company> Results { get; set; }\n     public string ResponseStatus { get; set; }\n }\n```", "```cs\npublic class Dividends\n{\n        public int Total { get; set; }\n        public int Offset { get; set; }\n        public List<Dictionary<string, string>> Results { get; set; }\n        public ResponseStatus ResponseStatus { get; set; }\n    }\n```", "```cs\npublic class ResponseStatus\n{\n    public string ErrorCode { get; set; }\n    public string Message { get; set; }\n    public string StackTrace { get; set; }\n    public List<Dictionary<string, string>> Errors { get; set; }\n    public List<Dictionary<string, string>> Meta { get; set; }\n}\n```", "```cs\nprivate DateTime? FormatStringDate(string date)\n{\n    return string.IsNullOrEmpty(date) ? (DateTime?)null : DateTime.Parse(date);\n}\n```", "```cs\nprivate async Task<string> GetMorningstarApiKey()\n{\n    try\n    {\n        AzureServiceTokenProvider azureServiceTokenProvider = new AzureServiceTokenProvider();\n        KeyVaultClient keyVaultClient = new KeyVaultClient(\n            new KeyVaultClient.AuthenticationCallback(\n                azureServiceTokenProvider.KeyVaultTokenCallback\n            )\n        );\n        var secret = await keyVaultClient.GetSecretAsync(ApiKeyConstants.MorningstarApiKeyUrl)\n                                         .ConfigureAwait(false);\n        return secret.Value;\n    }\n    catch (KeyVaultErrorException keyVaultException)\n    {\n        return keyVaultException.Message;\n    }\n}\n```", "```cs\nprivate Companies GetCompanies(string mic)\n{\n    var client = new RestClient(\n        $\"https://morningstar1.p.rapidapi.com/companies/list-by-exchange?Mic={mic}\"\n    );\n    var request = new RestRequest(Method.GET);\n    request.AddHeader(\"x-rapidapi-host\", \"morningstar1.p.rapidapi.com\");\n    request.AddHeader(\"x-rapidapi-key\", GetMorningstarApiKey().Result);\n    request.AddHeader(\"accept\", \"string\");\n    IRestResponse response = client.Execute(request);\n    return JsonConvert.DeserializeObject<Companies>(response.Content);\n}\n```", "```cs\nprivate Dividends GetDividends(string mic, string ticker)\n{\n    var client = new RestClient(\n        $\"https://morningstar1.p.rapidapi.com/dividends?Ticker={ticker}&Mic={mic}\"\n    );\n    var request = new RestRequest(Method.GET);\n    request.AddHeader(\"x-rapidapi-host\", \"morningstar1.p.rapidapi.com\");\n    request.AddHeader(\"x-rapidapi-key\", GetMorningstarApiKey().Result);\n    request.AddHeader(\"accept\", \"string\");\n    IRestResponse response = client.Execute(request);\n    return JsonConvert.DeserializeObject<Dividends>(response.Content);\n}\n```", "```cs\nprivate List<Dividend> BuildDividendCalendar()\n{\n    const string MIC = \"XLON\";\n    var thisYearsDividends = new List<Dividend>();\n    var companies = GetCompanies(MIC);\n    foreach (var company in companies.Results) {\n        var dividends = GetDividends(MIC, company.Ticker);\n        if (dividends.Results == null)\n            continue;\n        var currentDividend = dividends.Results.FirstOrDefault();\n        if (currentDividend == null || currentDividend[\"payableDt\"] == null)\n            continue;\n        var dateDiff = DateTime.Compare(\n            DateTime.Parse(currentDividend[\"payableDt\"]), \n            new DateTime(DateTime.Now.Year - 1, 12, 31)\n        );\n        if (dateDiff > 0) {\n            var payableDate = DateTime.Parse(currentDividend[\"payableDt\"]);\n            var dividend = new Dividend() {\n                Mic = MIC,\n                Ticker = company.Ticker,\n                CompanyName = company.CompanyName,\n                ExDividendDate = FormatStringDate(currentDividend[\"exDividendDt\"]),\n                DeclarationDate = FormatStringDate(currentDividend[\"declarationDt\"]),\n                RecordDate = FormatStringDate(currentDividend[\"recordDt\"]),\n                PaymentDate = FormatStringDate(currentDividend[\"payableDt\"]),\n                Amount = float.Parse(currentDividend[\"amount\"])\n            };\n            thisYearsDividends.Add(dividend);\n        }\n    }\n    return thisYearsDividends;\n}\n```", "```cs\n[Authorize(Policy = Policies.Internal)]\n[HttpGet(\"internal\")]\npublic IActionResult GetDividendCalendar()\n{\n    return new ObjectResult(JsonConvert.SerializeObject(BuildDividendCalendar()));\n}\n```", "```cs\n[{\"Mic\":\"XLON\",\"Ticker\":\"ABDP\",\"CompanyName\":\"AB Dynamics PLC\",\"DividendYield\":0.0,\"Amount\":0.0279,\"ExDividendDate\":\"2020-01-02T00:00:00\",\"DeclarationDate\":\"2019-11-27T00:00:00\",\"RecordDate\":\"2020-01-03T00:00:00\",\"PaymentDate\":\"2020-02-13T00:00:00\",\"DividendType\":null,\"CurrencyCode\":null},\n\n...\n\n{\"Mic\":\"XLON\",\"Ticker\":\"ZYT\",\"CompanyName\":\"Zytronic PLC\",\"DividendYield\":0.0,\"Amount\":0.152,\"ExDividendDate\":\"2020-01-09T00:00:00\",\"DeclarationDate\":\"2019-12-10T00:00:00\",\"RecordDate\":\"2020-01-10T00:00:00\",\"PaymentDate\":\"2020-02-07T00:00:00\",\"DividendType\":null,\"CurrencyCode\":null}]\n```", "```cs\n\"MorningstarNextRunDate\":  null,\n```", "```cs\npublic DateTime? MorningstarNextRunDate { get; set; }\n```", "```cs\npublic static void AddOrUpdateAppSetting<T>(string sectionPathKey, T value)\n{\n    try\n    {\n        var filePath = Path.Combine(AppContext.BaseDirectory, \"appsettings.json\");\n        string json = File.ReadAllText(filePath);\n        dynamic jsonObj = Newtonsoft.Json.JsonConvert.DeserializeObject(json);\n        SetValueRecursively(sectionPathKey, jsonObj, value);\n        string output = Newtonsoft.Json.JsonConvert.SerializeObject(\n            jsonObj, \n            Newtonsoft.Json.Formatting.Indented\n        );\n        File.WriteAllText(filePath, output);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine(\"Error writing app settings | {0}\", ex.Message);\n    }\n}\n```", "```cs\nprivate static void SetValueRecursively<T>(string sectionPathKey, dynamic jsonObj, T value)\n{\n    var remainingSections = sectionPathKey.Split(\":\", 2);\n    var currentSection = remainingSections[0];\n    if (remainingSections.Length > 1)\n    {\n        var nextSection = remainingSections[1];\n        SetValueRecursively(nextSection, jsonObj[currentSection], value);\n    }\n    else\n    {\n        jsonObj[currentSection] = value;\n    }\n}\n```", "```cs\npublic const int ThrottleMonthDay = 25;\n```", "```cs\nprivate string ThrottleMessage()\n{\n    return \"This API call can only be made once on the 25th of each month.\";\n}\n```", "```cs\npublic DividendCalendarController(IOptions<AppSettings> appSettings)\n{\n    _appSettings = appSettings.Value;\n}\n```", "```cs\nvar appSettingsSection = Configuration.GetSection(\"AppSettings\");\nservices.Configure<AppSettings>(appSettingsSection);\n```", "```cs\nprivate DateTime? SetMorningstarNextRunDate()\n{\n    int month;\n    if (DateTime.Now.Day < 25)\n        month = DateTime.Now.Month;\n    else\n        month = DateTime.Now.AddMonths(1).Month;\n    var date = new DateTime(DateTime.Now.Year, month, ApiKeyConstants.ThrottleMonthDay);\n    AppSettings.AddOrUpdateAppSetting<DateTime?>(\n        \"MorningstarNextRunDate\",\n        date\n    );\n    return date;\n}\n```", "```cs\nprivate bool CanExecuteApiRequest()\n{\n    DateTime? nextRunDate = _appSettings.MorningstarNextRunDate;\n    if (!nextRunDate.HasValue) \n        nextRunDate = SetMorningstarNextRunDate();\n    if (DateTime.Now.Day == ApiKeyConstants.ThrottleMonthDay) {\n        if (nextRunDate.Value.Month == DateTime.Now.Month) {\n            SetMorningstarNextRunDate();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\n```", "```cs\n[Authorize(Policy = Policies.Internal)]\n[HttpGet(\"internal\")]\npublic IActionResult GetDividendCalendar()\n{\n    if (CanExecuteApiRequest())\n        return new ObjectResult(JsonConvert.SerializeObject(BuildDividendCalendar()));\n    else\n        return new ObjectResult(ThrottleMessage());\n}\n```"]