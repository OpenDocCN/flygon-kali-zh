- en: '*Chapter 4:* Understanding the Various User-Defined Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章：*理解各种用户定义类型'
- en: In the previous chapter, we learned about control statements and exceptions
    in C#. In this chapter, we will explore the user-defined types in C#. We will
    learn how to create custom user types using classes, structures, and enumerations.
    We will explore what fields, properties, methods, indexers, and constructors are
    in a class. We will study the access modifiers in C# and learn how to use them
    to define the visibility of types and members. We will also learn about two important
    keywords in C#—`this` and `static`—and understand the `ref`, `in`, and `out` parameter
    modifiers for methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了C#中的控制语句和异常。在本章中，我们将探讨C#中的用户定义类型。我们将学习如何使用类、结构和枚举来创建自定义用户类型。我们将探讨类中的字段、属性、方法、索引器和构造函数。我们将研究C#中的访问修饰符，并学习如何使用它们来定义类型和成员的可见性。我们还将学习C#中的两个重要关键字“this”和“static”，并了解方法的“ref”、“in”和“out”参数修饰符。
- en: 'We will explore the following topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下主题：
- en: Classes and objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Enumerations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Namespaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Good knowledge of these concepts is necessary to understand the **object-oriented
    programming** (**OOP**) concepts that we will cover in the next chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些概念的良好了解对于理解我们将在下一章中涵盖的**面向对象编程**（**OOP**）概念是必要的。
- en: Classes and objects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: Before we go further, it is important that you understand these two key concepts.
    A class is a template or a blueprint that specifies the form of an object. It
    contains both data and code that operates on that data. An object is an instance
    of a class. Classes are defined using the `class` keyword and a type that is a
    class is a reference type. The default value for a variable of a reference type
    is `null`. You can assign it as a reference to an instance of the type. Instances—that
    is, objects—are created using the `new` operator.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，重要的是你理解这两个关键概念。类是指定对象形式的模板或蓝图。它包含操作该数据的数据和代码。对象是类的一个实例。类是使用`class`关键字和一个类的类型是引用类型来定义的。引用类型的变量的默认值是`null`。您可以将其分配为类型实例的引用。实例
    - 也就是对象 - 是使用`new`运算符创建的。
- en: Information box
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The terms *class* and *object* are often used interchangeably in different technical
    documentations. They are not the same and it is improper to use them as so. The
    class is the blueprint that specifies the memory layout of objects and defines
    functionalities that operate with that memory. Objects are the actual entities
    created and operated according to the blueprint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*类*和*对象*在不同的技术文档中经常可以互换使用。它们并不相同，这样使用是不正确的。类是指定对象的内存布局并定义与该内存操作的功能的蓝图。对象是根据蓝图创建和操作的实际实体。
- en: 'Take a look at the following code snippet to understand how a class is defined.
    In this example, we are creating an `Employee` class with three fields to represent
    the ID, first name, and last name of an employee:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段，以了解如何定义类。在这个例子中，我们创建了一个`Employee`类，其中包含三个字段，用于表示员工的ID、名字和姓氏：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the `new` keyword to create an instance of the class. The `new`
    operator allocates memory for an object and returns a reference to it at runtime.
    This reference is then stored in the variable that specifies the object's name.
    The object is stored on the heap, and the reference to the object is stored in
    the stack storage location corresponding to the named variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`new`关键字来创建类的实例。`new`运算符在运行时为对象分配内存并返回对其的引用。然后，将该引用存储在指定对象名称的变量中。对象存储在堆上，对象的引用存储在与命名变量对应的堆栈存储位置上。
- en: 'To create an object of the `Employee` class, we will use the following statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Employee`类的对象，我们将使用以下语句：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access the members of a class (fields, properties, methods) using an object,
    we use the dot (`.`) operator. Hence, to assign values to the fields of the object
    (`obj`), we will use the following statements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象访问类的成员（字段、属性、方法），我们使用点（`.`）运算符。因此，要为对象的字段赋值（`obj`），我们将使用以下语句：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram shows, conceptually, what is happening here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概念上显示了这里发生的情况：
- en: '![Figure 4.1 – The conceptual memory layout for the preceding Employee object'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 先前雇员对象的概念内存布局'
- en: '](img/Figure_4.1._B12346.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1._B12346.jpg)'
- en: Figure 4.1 – The conceptual memory layout for the preceding Employee object
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 先前雇员对象的概念内存布局
- en: The **obj** variable of the **Employee** type is allocated on the stack. However,
    the stack does not contain the actual **Employee** object but only a reference
    to it. The object is allocated on the heap and the address of the object is stored
    on the stack so that by using the **obj** variable we can access the object that
    is located on the heap.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Employee**类型的**obj**变量被分配在堆栈上。但是，堆栈不包含实际的**Employee**对象，而只包含对它的引用。对象分配在堆上，并且对象的地址存储在堆栈上，因此通过**obj**变量我们可以访问位于堆上的对象。'
- en: 'Two different instances of a class are two different objects. A reference to
    an object can be assigned to multiple variables. In this case, modifications to
    the object through one variable will be visible through the other variable. This
    is shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类的两个不同实例是两个不同的对象。对象的引用可以分配给多个变量。在这种情况下，通过一个变量对对象的修改将通过另一个变量可见。这在以下示例中显示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have created a first instance of the `Employee` class and only assigned
    a value to `EmployeeId`. Then, we created a second instance and assigned values
    to the first and last name, skipping the identifier. These are two different objects,
    residing in different locations in memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`Employee`类的第一个实例，并且只为`EmployeeId`赋了一个值。然后，我们创建了第二个实例，并为名字和姓氏赋值，跳过了标识符。这是两个不同的对象，驻留在内存中的不同位置。
- en: The properties of an employee are stored in the class in member fields. These
    will be discussed next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 员工的属性存储在类的成员字段中。接下来将讨论这些。
- en: Fields
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: These are variables declared directly inside a class and are, therefore, members
    of the class. Fields are used for storing the state of the object, which is data
    that must live for more than the period of the execution of a class method and
    that should be accessible from multiple methods. Variables that are not used outside
    the scope of a single method should be defined as local variables and not class
    fields.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是直接在类内声明的变量，因此是类的成员。字段用于存储对象的状态，这是必须在类方法执行期间存活并且应该从多个方法中访问的数据。不在单个方法范围之外使用的变量应该被定义为局部变量而不是类字段。
- en: In the preceding section, `EmployeeId`, `FirstName`, and `LastName` are the
    mentioned fields. These are called **instance fields** because they belong to
    the instance of the class, meaning that each object has its own instance of these
    fields. On the other hand, *static fields* belong to the class and are shared
    by all instances of the class. Static members will be discussed in a later section
    of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，`EmployeeId`、`FirstName`和`LastName`是提到的字段。这些被称为**实例字段**，因为它们属于类的实例，这意味着每个对象都有自己的这些字段的实例。另一方面，*静态字段*属于类，并且被所有类的实例共享。静态成员将在本章的后面部分讨论。
- en: These fields have been declared `public`, which means they can be accessed by
    anyone. This is, however, a bad practice. Fields should usually be declared as
    either `private` (to be accessible only to the class members) or `protected` (to
    also be accessible to the derived classes). This ensures better encapsulation,
    which will be discussed further in the next chapter. Fields can be accessed both
    for reading and writing using methods, properties, and indexers. We will discuss
    these in the following sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段已被声明为`public`，这意味着任何人都可以访问它们。然而，这是一个不好的做法。字段通常应该声明为`private`（只能被类成员访问）或者`protected`（也可以被派生类访问）。这确保了更好的封装，这将在下一章进一步讨论。字段可以通过方法、属性和索引器进行读取和写入。我们将在下面的部分讨论这些。
- en: 'Fields that are declared with the `const` specifiers are called **constants**.
    Only built-in types can be constants. Constants are always initialized with a
    literal and are values known at compile time that cannot be changed at runtime:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用`const`修饰符声明的字段称为**常量**。只有内置类型可以是常量。常量始终使用字面值初始化，并且是在编译时已知的值，不能在运行时更改：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Constant fields are substituted for their literal value in the intermediate
    language code, which means you cannot pass a constant field by reference. But
    this has another, more subtle implication: if the constant value is referred in
    assemblies other than the one in which the type is defined and the literal value
    of the constant is changed in a future version, the assemblies referring the constant
    will continue to have the old version until they are recompiled.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 常量字段在中间语言代码中被其字面值替换，这意味着不能通过引用传递常量字段。但这还有另一个更微妙的含义：如果常量值在类型定义的程序集之外的程序集中被引用，并且常量的字面值在将来的版本中被更改，那么引用常量的程序集将继续具有旧版本，直到它们被重新编译。
- en: For instance, if an integer constant defined in assembly A was initially set
    to 42 and it was referred in assembly B, then the value 42 will have been stored
    in assembly B. Changing the value of the constant to something else (let's say
    100) will not be reflected in assembly B, which will continue to store the old
    value until it is recompiled with the new version of assembly A.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在A程序集中定义了一个整数常量并且初始值为42，然后在B程序集中引用了它，那么值42将被存储在B程序集中。将常量的值更改为其他值（比如100）将不会反映在B程序集中，它将继续存储旧值，直到使用新版本的A程序集重新编译。
- en: Fields can also be declared with the `readonly` specifier. These fields can
    only be initialized in a constructor and their value cannot be changed later on.
    They can be thought of as **runtime constants**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字段也可以用`readonly`修饰符声明。这些字段只能在构造函数中初始化，它们的值以后不能被改变。它们可以被看作是**运行时常量**。
- en: 'In the following example, the `EmployeeId` field is a `readonly` field that
    is initialized in the constructor. Only the first and last name fields can be
    changed for an instance of the class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`EmployeeId`字段是一个在构造函数中初始化的`readonly`字段。类的实例只能改变姓和名字段：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how to work with fields, let's learn about methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何使用字段，让我们学习一下方法。
- en: Methods
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are a series of one or more statements that are executed when the method
    is invoked. Instance methods require an object in order to be called. Static methods
    belong to the class and are not called using an object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是在调用方法时执行的一个或多个语句的系列。实例方法需要对象才能被调用。静态方法属于类，不使用对象调用。
- en: 'A method has a so-called *signature* that consists of several parts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方法有一个所谓的*签名*，由几个部分组成：
- en: '`private` by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认为`private`。
- en: '`virtual`, `abstract`, `sealed`, or `static`: These are all optional and will
    be discussed in later sections.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual`、`abstract`、`sealed`或`static`：这些都是可选的，将在后面的部分讨论。'
- en: '`void` if the method does not return any value.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法不返回任何值，则为`void`。
- en: '**A name**: This must be a valid identifier.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名字**：这必须是一个有效的标识符。'
- en: '`ref`, `in`, or `out` specifier.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`、`in`或`out`修饰符。'
- en: 'In the following example, we will add a method to our `Employee` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将在`Employee`类中添加一个方法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have added a method called `GetEmployeeName()`. The access modifier
    is `public`, which allows this method to be called from any part of the code.
    The return type is `string` as the method is returning the name of the employee
    by concatenating the `FirstName` and `LastName` fields separated by a space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`GetEmployeeName()`的方法。访问修饰符是`public`，这允许从代码的任何部分调用这个方法。返回类型是`string`，因为该方法通过连接`FirstName`和`LastName`字段并用空格分隔返回员工的名字。
- en: Methods that simply consist of evaluating an expression, and perhaps returning
    the result of the evaluation, can be written using an alternative syntax called
    `member => expression;` form and are supported for all class members, not just
    methods, but also fields, properties, indexers, constructors, and finalizers.
    The type of the result value of the expression evaluation must match the return
    type of the method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地评估表达式并可能返回评估结果的方法可以使用另一种语法`member => expression;`形式编写，并且支持所有类成员，不仅仅是方法，还包括字段、属性、索引器、构造函数和终结器。表达式评估的结果值类型必须与方法的返回类型匹配。
- en: 'The following code shows the implementation of the `GetEmployeeName()` method
    using an expression body definition:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了使用表达式体定义的`GetEmployeeName()`方法的实现：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Overloaded methods** are multiple methods that have the same name but a different
    signature. Such methods can exist. The return type of these methods is not a part
    of the signature in the context of method overloading. This means that you cannot
    have two methods with the same list of parameters but with different return values.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**重载方法**是具有相同名称但不同签名的多个方法。这样的方法是可以存在的。在方法重载的上下文中，这些方法的返回类型不是签名的一部分。这意味着你不能有两个具有相同参数列表但不同返回值的方法。'
- en: 'In the following example, `GetEmployeeName(bool)` is an overloaded method for
    the previous `GetEmployeeName()` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`GetEmployeeName(bool)`是前一个`GetEmployeeName()`方法的重载方法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method has the same name but a different list of parameters. It takes a
    Boolean value that indicates whether the last name should be put first, or else
    returns the name with the first name followed by the last name, just like the
    previous method did.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与前一个方法同名，但参数列表不同。它接受一个布尔值，指示是否应该先放姓氏，否则返回名字和姓氏，就像前一个方法一样。
- en: Constructors
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: A constructor is a special method defined in a class that is called when we
    instantiate an object for the class. Constructors are used to initialize the members
    of the class upon the object's creation. A constructor cannot have a return type
    and has the same name as the class. Multiple constructors with different parameters
    may exist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是在类中定义的特殊方法，当我们实例化一个类的对象时会调用它。构造函数用于在对象创建时初始化类的成员。构造函数不能有返回类型，并且与类同名。可以存在具有不同参数的多个构造函数。
- en: A constructor without any parameters is called a *default constructor*. Such
    a constructor is provided by the compiler to all classes. The default constructor
    is created at compile time and initializes the member variables to their default
    value. The default value is 0 for numeric data types, `false` for `bool`, and
    `null` for reference types. If we define our own constructor, the compiler will
    no longer provide the default constructor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何参数的构造函数称为*默认构造函数*。编译器为所有类提供了这样的构造函数。默认构造函数在编译时创建并将成员变量初始化为它们的默认值。对于数值数据类型，默认值为0，对于`bool`类型为`false`，对于引用类型为`null`。如果我们定义自己的构造函数，编译器将不再提供默认构造函数。
- en: A constructor can have an access modifier. The default access modifier of a
    constructor is `private`. However, this modifier makes it impossible to instantiate
    the class from outside the class itself. In most cases, the access modifier of
    a constructor is defined as `public` since a constructor is generally called from
    outside of the class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以有访问修饰符。构造函数的默认访问修饰符是`private`。然而，这个修饰符使得在类外部无法实例化类本身。在大多数情况下，构造函数的访问修饰符被定义为`public`，因为构造函数通常是从类的外部调用的。
- en: A private constructor is useful in certain situations. An example is when implementing
    the singleton pattern.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 私有构造函数在某些情况下很有用。一个例子是在实现单例模式时。
- en: 'Let''s try to understand all the concepts covered so far with the help of the
    following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过以下示例来理解到目前为止涵盖的所有概念：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have extended our `Employee` class and included a constructor in it. This
    constructor will accept three parameters to initialize the value of all three
    fields: `EmployeeId`, `FirstName`, and `LastName`. When creating an instance of
    the class, you must specify proper arguments for the class constructor:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`Employee`类并在其中包含了一个构造函数。这个构造函数将接受三个参数来初始化所有三个字段的值：`EmployeeId`、`FirstName`和`LastName`。在创建类的实例时，必须为类的构造函数指定适当的参数：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon execution, this program will give the output shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，该程序将给出以下截图中显示的输出：
- en: '![Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - 显示前面片段输出的控制台截图'
- en: '](img/Figure_4.2._B12346.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2._B12346.jpg)'
- en: Figure 4.2 – A screenshot of the console showing the output of the preceding
    snippet
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 显示前面片段输出的控制台截图
- en: Objects can be initialized in a declarative manner using the so-called *object
    initializer*. You invoke a constructor and, apart from providing the necessary
    arguments to the constructor, you also provide a list of initialization statements
    for accessible members, such as fields, properties, or indexers, within curly
    braces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以使用所谓的*对象初始化器*以声明方式进行初始化。您调用一个构造函数，并且除了为构造函数提供必要的参数之外，还为可访问成员（如字段、属性或索引器）提供一个初始化语句列表，放在花括号内。
- en: 'Considering the `Employee` class without a user-defined constructor, having
    the default (parameterless) constructor provided by the compiler, we can write
    the following code to initialize an instance of the class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`Employee`类没有用户定义的构造函数，由编译器提供的默认（无参数）构造函数，我们可以编写以下代码来初始化类的实例：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far in this chapter, we have used fields to store the state of an object.
    The C# language provides an alternative to fields: properties, which is the topic
    of the next section.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经使用字段来存储对象的状态。C#语言提供了一种替代字段的方法：属性，这是下一节的主题。
- en: Properties
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: A property is a combination of a field and a method to access that field. They
    look like fields but are actually methods called **accessors**. Properties make
    it possible to read or write the class state in a simple manner and hide the implementation
    details, including verification code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是字段和访问该字段的方法的组合。它们看起来像字段，但实际上是称为**访问器**的方法。属性使得以简单的方式读取或写入类状态成为可能，并隐藏实现细节，包括验证代码。
- en: The two accessors that properties define are called `get` (which is used to
    return a value from the property) and `set` (which is used to assign a new value).
    Within the context of the `set` accessor, the `value` keyword defines the value
    being accessed (which is the value assigned from the user code).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义的两个访问器称为`get`（用于从属性返回值）和`set`（用于分配新值）。在`set`访问器的上下文中，`value`关键字定义正在访问的值（即从用户代码分配的值）。
- en: 'In the following example, the `Employee` class shown earlier in this chapter
    is rewritten so that the employee ID, first name, and last name are private fields
    made available to the class clients using properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，本章前面显示的`Employee`类被重写，以便员工ID、名和姓是私有字段，通过属性对类客户端可用：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the property''s `get` and `set` accessors is actually transparent. You
    do not invoke them explicitly, but use the properties just as though they were
    fields. The following example shows how the three properties of the `Employee`
    class are to be accessed for both writing and reading:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用属性的`get`和`set`访问器是透明的。您不会显式调用它们，而是像字段一样使用属性。以下示例显示了如何访问`Employee`类的三个属性进行读写：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implementation of the properties shown in the preceding code is straightforward—it
    just returns or sets the value of a private field. However, accessors are just
    like any other method, so you can write any code, such as parameter verification,
    as in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中显示的属性的实现是直接的——它只返回或设置私有字段的值。但是，访问器就像任何其他方法一样，因此您可以编写任何代码，例如参数验证，如下例所示：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, a property is not required to refer to a corresponding field.
    A property may return values that are not read from one field or that are calculated
    from evaluating different fields. The following example shows a property, `Name`,
    that concatenates the value of the `FirstName` and `LastName` properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，属性不需要引用相应的字段。属性可以返回不从一个字段中读取的值，或者可以从评估不同字段计算出的值。以下示例显示了一个`Name`属性，它连接了`FirstName`和`LastName`属性的值：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that in the case of this property, the `set` accessor is missing. Both
    the `get` and `set` accessors are optional. However, at least one must be implemented.
    On the other hand, a write-only property does not have much value and you might
    want to implement such functionalities as a regular method. Also, the `get` and
    `set` accessors may have different access modifiers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个属性的情况下，缺少`set`访问器。`get`和`set`访问器都是可选的。但是，至少必须实现一个。另一方面，只写属性没有太多价值，您可能希望将这些功能实现为常规方法。此外，`get`和`set`访问器可以具有不同的访问修饰符。
- en: Implementing properties in this manner is cumbersome because you need to explicitly
    define private fields that you do not use elsewhere other than in the properties.
    Moreover, each property has to explicitly implement the `get` and `set` accessors,
    basically repeating the same code over and over again. It is possible to achieve
    the same result with a shorter syntax using *auto-implemented properties*. These
    are properties for which the compiler will provide a private field and the implementation
    of the `get` and `set` accessors, as we did earlier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现属性是很麻烦的，因为您需要明确定义除了属性之外其他地方不使用的私有字段。此外，每个属性都必须明确实现`get`和`set`访问器，基本上是一遍又一遍地重复相同的代码。可以使用*自动实现的属性*以更短的语法实现相同的结果。这些属性是编译器将提供私有字段和`get`和`set`访问器的实现，就像我们之前做的那样。
- en: 'The `Employee` class is re-written with auto-implemented properties, as in
    the following code. This very much resembles our first implementation where we
    were using public fields:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类使用自动实现的属性进行了重写，如下所示。这非常类似于我们第一次实现时使用公共字段的情况：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you do not want to set the values of these properties, you can declare only
    the `get` accessor `public`. In such cases, the `set` accessor would probably
    be `private` and you would provide values through the constructor. Such an example
    is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想设置这些属性的值，可以只声明`get`访问器为`public`。在这种情况下，`set`访问器可能是`private`，并且您将通过构造函数提供值。这里显示了一个示例：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Properties can be implemented using expression body definitions. The `Name`
    property shown earlier can be implemented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用表达式主体定义来实现属性。前面显示的`Name`属性可以实现如下：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a read-only property that only has the `get` accessor. However, you
    can explicitly implement both the `get` and `set` accessors as expression body
    members. This is shown in the following listing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只有`get`访问器的只读属性。但是，您可以显式实现`get`和`set`访问器作为表达式主体成员。这在以下清单中显示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Auto-implemented properties can also be initialized using the syntax shown
    in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现的属性也可以使用以下示例中显示的语法进行初始化：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The value of the `EmployeeId` property is initialized with `1`. Unless otherwise
    explicitly set, all instances of the `Employee` class will have `EmployeeId` set
    to `1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeId`属性的值被初始化为`1`。除非另行明确设置，`Employee`类的所有实例都将`EmployeeId`设置为`1`。'
- en: 'If you are implementing a read-only property using an expression body definition,
    you do not need to specify the `get` accessor. The syntax, in this case, is as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用表达式主体定义实现只读属性，则不需要指定`get`访问器。在这种情况下，语法如下：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This, however, looks very similar to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这看起来与以下内容非常相似：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is a big difference between these syntaxes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语法之间存在很大的区别：
- en: In the former example, where `=>` is used, `EmployeeId` is a *read-only public
    property* with an *expression body definition*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用`=>`时，`EmployeeId`是一个具有*表达式体定义*的*只读公共属性*。
- en: In the latter example, where `=` is used, `EmployeeId` is a *public field* with
    an *initializer*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后面的例子中，使用`=`时，`EmployeeId`是一个*公共字段*，具有*初始化程序*。
- en: There is a special form of property that can take parameters and allow access
    to class instances using the operator `[]`. These are called **indexers** and
    are discussed in the following section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊形式的属性可以接受参数，并允许使用`[]`运算符访问类实例。这些被称为**索引器**，将在下一节中讨论。
- en: Indexers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引器
- en: An indexer allows an object to be indexed like an array. An indexer defines
    a `get` and `set` accessor, similar to a property. An indexer does not have an
    explicit name. It is created by using the `this` keyword. An indexer has one or
    more parameters, which can be of any type. As in the case of properties, the `get`
    and `set` accessors are usually simple and consist of a single statement that
    returns or sets a value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器允许像数组一样对对象进行索引。索引器定义了`get`和`set`访问器，类似于属性。索引器没有显式名称。它是通过使用`this`关键字创建的。索引器有一个或多个参数，可以是任何类型。与属性一样，`get`和`set`访问器通常很简单，由一个返回或设置值的单个语句组成。
- en: 'In the following example, the `ProjectRoles` class contains a mapping of the
    project IDs and roles that an employee has in each project. This mapping is private
    but access to it is available through an indexer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`ProjectRoles`类包含项目ID和员工在每个项目中担任的角色的映射。这个映射是私有的，但可以通过索引器访问：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The indexer is defined with the `public string this[int projectId]` syntax,
    which contains the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器使用`public string this[int projectId]`语法进行定义，其中包含以下内容：
- en: An access modifier
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: The type of the indexer, which is `string`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器的类型，即`string`
- en: The `this` keyword and the list of parameters in square brackets `[]`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`关键字和方括号`[]`中的参数列表'
- en: 'The `get` and `set` accessors are implemented in the same way as for a regular
    property. This `ProjectRoles` class can be used as follows within the `Employee`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`访问器的实现方式与常规属性相同。`ProjectRoles`类可以在`Employee`类中如下使用：'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can access the employee roles using the `Roles[i]` syntax, just as if `Roles`
    was an array. In this example, the parameter is not an index in the array but
    a project identifier, which is actually the key to the dictionary of projects
    and roles. The parameters can be of any type, not just numerical types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Roles[i]`语法访问员工角色，就好像`Roles`是一个数组一样。在这个例子中，参数不是数组中的索引，而是一个项目标识符，实际上是项目和角色字典的键。参数可以是任何类型，不仅仅是数值类型：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output from executing this sample code is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此示例代码的输出显示在以下截图中：
- en: '![Figure 4.3 – Console output from executing the preceding code snippet'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 执行前面代码片段的控制台输出'
- en: '](img/Figure_4.3._B12346.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3._B12346.jpg)'
- en: Figure 4.3 – Console output from executing the preceding code snippet
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 执行前面代码片段的控制台输出
- en: Indexers, including read-only indexers, can be implemented with expression body
    definitions. However, there are no auto-implemented indexers; they have to be
    implemented explicitly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器，包括只读索引器，可以使用表达式体定义。但是，没有自动实现的索引器；它们必须显式实现。
- en: As mentioned, indexers are defined using the `this` keyword. However, this keyword
    has other meanings outside the scope of indexers. This topic will be discussed
    in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，索引器是使用`this`关键字定义的。但是，这个关键字在索引器范围之外还有其他意义。这个主题将在下一节中讨论。
- en: The this keyword
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this关键字
- en: The `this` keyword is used to represent the current instance of a class. When
    a method is called, the reference of the calling object is passed to it using
    `this`. This is not done explicitly, but behind the scenes by the compiler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字用于表示类的当前实例。当调用方法时，使用`this`将调用对象的引用传递给它。这不是显式地完成的，而是由编译器在后台完成的。'
- en: 'The `this` keyword has two important purposes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字有两个重要的目的：'
- en: To qualify class members when parameters or local variables with the same name
    exist
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当参数或局部变量具有相同名称时，限定类成员
- en: To pass a reference to the current instance as a parameter to another method
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对当前实例的引用作为参数传递给另一个方法
- en: 'Let''s look at the following implementation of the `Employee` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Employee`类的以下实现：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the parameters of the constructor have the same name as the
    fields of the class. C# allows us to use the same name for the parameter and instance
    variable. Since the parameter name is local to a method, the local name takes
    precedence over the instance variable. To alleviate this situation, we use the
    `this` keyword to refer to the instance variable for the current method invocation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，构造函数的参数与类的字段具有相同的名称。C#允许我们对参数和实例变量使用相同的名称。由于参数名称是方法局部的，局部名称优先于实例变量。为了缓解这种情况，我们使用`this`关键字来引用当前方法调用的实例变量。
- en: 'So far, we have seen the `this` keyword used for referring to the current instance
    of a class and for declaring indexes. However, it is used for yet another purpose,
    and that is declaring extension methods. These will be discussed in [*Chapter
    8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154), *Advanced Topics*. For now,
    let''s look at another important keyword: `static`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到`this`关键字用于引用类的当前实例和声明索引。但是，它还用于另一个目的，即声明扩展方法。这将在[*第8章*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154)
    *高级主题*中讨论。现在，让我们看看另一个重要的关键字：`static`。
- en: The static keyword
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态关键字
- en: The `static` keyword can be used to declare classes or class members. These
    differ from what we have seen so far because you do not create instances of static
    classes or do not need objects to access static members. We will explore these
    in detail in the following subsections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`关键字可用于声明类或类成员。这与我们目前所见的不同，因为您不创建静态类的实例，也不需要对象来访问静态成员。我们将在以下小节中详细探讨这些内容。'
- en: Static members
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态成员
- en: Fields, properties, methods, and constructors can be declared `static`. Indexers
    and finalizers cannot be declared `static`. A static member does not belong to
    the object (as in the case of an instance member) but rather to the type itself.
    Therefore, you cannot access a static member through an object but through the
    type name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字段、属性、方法和构造函数可以声明为`static`。索引器和终结器不能声明为`static`。静态成员不属于对象（如实例成员的情况），而是属于类型本身。因此，您不能通过对象访问静态成员，而是通过类型名称。
- en: 'In the following example, we have an implementation of the `Employee` class
    that has a static field called `id` and a static method called `Create()`. The
    static field is storing the value of the next employee ID, and the static method
    is used to create a new instance of the class because the constructor is `private`
    and therefore it can only be called from within the class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有一个`Employee`类的实现，其中有一个名为`id`的静态字段和一个名为`Create()`的静态方法。静态字段存储下一个员工ID的值，静态方法用于创建类的新实例，因为构造函数是`private`，因此只能从类内部调用：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can call the `Create()` method as follows to instantiate a new object of
    this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式调用`Create()`方法来实例化这个类的新对象：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first object created like this will have `EmployeeID` set to `1`, the second
    one will have `EmployeeID` set to `2`, and so on. Notice that we used the `Employee.Create()`
    syntax to call the static method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样创建的第一个对象将`EmployeeID`设置为`1`，第二个对象将`EmployeeID`设置为`2`，依此类推。请注意，我们使用了`Employee.Create()`语法来调用静态方法。
- en: Static classes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类
- en: A `static` class is also declared using the `static` keyword. A `static` class
    cannot be instantiated. Since we cannot create instances of a `static` class,
    we access the class members using the class name itself. All members of a static
    class must themselves be static. A static class is basically the same as a non-static
    class, with a `private` constructor and all members declared as `static`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`类也使用`static`关键字声明。`static`类不能被实例化。由于我们无法创建`static`类的实例，因此我们使用类名本身来访问类成员。静态类的所有成员本身必须是静态的。静态类基本上与非静态类相同，具有`private`构造函数和所有成员声明为`static`。'
- en: A `static` class is typically used to define methods that operate only on their
    parameters (if any) and do not rely on class fields. This is often the case with
    utility classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类通常用于定义仅在其参数（如果有）上操作并且不依赖于类字段的方法。这通常是实用类的情况。
- en: 'The following example shows a static class called `MassConverters`, which contains
    static methods to convert between kilograms and pounds:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了一个名为`MassConverters`的静态类，其中包含用于在千克和磅之间转换的静态方法：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because static classes cannot be instantiated, the `this` keyword has no meaning
    within the context of such a class. An attempt to use it would result in a compiler
    error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为静态类不能被实例化，所以`this`关键字在这样的类的上下文中没有意义。尝试使用它将导致编译器错误。
- en: The static constructor
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: 'A class can have a static constructor, whether the class itself is static or
    not. A static constructor has no parameters or access modifiers and cannot be
    called by the user. A static constructor is called by the CLR automatically in
    the following instances:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有静态构造函数，无论类本身是否是静态的。静态构造函数没有参数或访问修饰符，用户无法调用它。CLR在以下情况下自动调用静态构造函数：
- en: In a static class when the first static member of the class is accessed for
    the first time
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静态类中，当第一次访问类的第一个静态成员时
- en: In a non-static class when the class is instantiated for the first time
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非静态类中，当类首次实例化时
- en: Static constructors are useful for initializing static fields. For instance,
    a `static readonly` field can only be initialized during declaration or in the
    static constructor. This is useful especially when the values are taken from configuration
    files, for writing entries to a log file, or for writing wrappers for unmanaged
    code, when the static constructor can call the `LoadLibrary()` API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数对于初始化静态字段非常有用。例如，`static readonly`字段只能在声明期间或在静态构造函数中初始化。当值来自配置文件时，用于将条目写入日志文件，或者用于编写非托管代码的包装器时，静态构造函数可以调用`LoadLibrary()`API，这是非常有用的。
- en: 'In the following example, the previous implementation of the `Employee` class
    is modified such that a static constructor is provided to initialize the value
    of the static `id` field. This constructor is reading the ID of the next employee
    from an application file or initializes it with `1` if the file is not found.
    Every time a new instance of the class is created, the value of the next employee
    ID is written to this file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，修改了`Employee`类的先前实现，提供了一个静态构造函数来初始化静态`id`字段的值。这个构造函数从应用程序文件中读取下一个员工的ID，如果找不到文件，则将其初始化为`1`。每次创建类的新实例时，下一个员工ID的值都将写入此文件：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the following code several times, the first time the IDs of the
    two employees will be `1` and `2`, then `3` and `4`, and so forth:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次运行以下代码，第一次两个员工的ID将是`1`和`2`，然后是`3`和`4`，依此类推：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So far, we have seen how to create methods and constructors. In the next section,
    we will learn about the different ways you can pass parameters to them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建方法和构造函数。在下一节中，我们将学习有关将参数传递给它们的不同方法。
- en: The ref, in, and out parameters
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用、输入和输出参数
- en: When we pass an argument to a method, it is passed by a value. This means a
    copy is made. If the type is a value type, then the value of the argument is copied
    into the method parameter. If the type is a reference type, then the reference
    is copied to the method parameter. When you change the parameter value, it changes
    the local copy. This means changes in arguments of value types are not propagated
    to the caller. As for arguments of reference types, you can change the referred
    object on the heap but you cannot change the reference itself. This behavior can
    be altered using the `ref`, `in`, and `out` keywords.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将参数传递给方法时，它是按值传递的。这意味着会创建一个副本。如果类型是值类型，则参数的值将被复制到方法参数中。如果类型是引用类型，则引用将被复制到方法参数中。当您更改参数值时，它会更改本地副本。这意味着值类型的参数更改不会传播到调用者。至于引用类型的参数，您可以更改堆上的引用对象，但不能更改引用本身。使用`ref`、`in`和`out`关键字可以改变这种行为。
- en: The ref keyword
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ref关键字
- en: The `ref` keyword allows us to create a *call-by-reference mechanism* rather
    than a call-by-value mechanism. A `ref` keyword is specified when we declare and
    invoke the method. The use of the `ref` keyword alters the parameter so that it
    becomes an alias for an argument, which must be a variable. This means you cannot
    pass a property or an indexer (which is actually a method) as an argument for
    a `ref` parameter. A `ref` parameter must be initialized prior to the method call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`关键字允许我们创建*按引用调用*机制，而不是按值调用机制。在声明和调用方法时指定了`ref`关键字。使用`ref`关键字改变参数，使其成为参数的别名，必须是一个变量。这意味着您不能将属性或索引器（实际上是一个方法）作为`ref`参数的参数传递。`ref`参数必须在方法调用之前初始化。'
- en: 'Let''s take a look at the following code sample:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码示例：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this program, we have defined a `Swap` method to swap two integer values.
    We are using the `ref` keyword to declare the method parameters. We defined this
    method as `static` so that we can invoke it without an object reference. Inside
    the `Main` method, we have initialized two integer variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此程序中，我们定义了一个`Swap`方法来交换两个整数值。我们使用`ref`关键字来声明方法参数。我们将此方法定义为`static`，以便我们可以在没有对象引用的情况下调用它。在`Main`方法中，我们初始化了两个整数变量。
- en: 'While invoking the `Swap` method, we have also used the `ref` keyword with
    argument names. These `ref` parameters are passed as a reference and the actual
    value of the `num1` and `num2` variables will be swapped. The change is reflected
    in the variables in the `Main` method. The output of this program is shown in
    the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Swap`方法时，我们还使用了`ref`关键字和参数名称。这些`ref`参数作为引用传递，并且`num1`和`num2`变量的实际值将被交换。这种更改会反映在`Main`方法中的变量中。该程序的输出如下截图所示：
- en: '![Figure 4.4 – Console showing the values of num1 and num2 before and after
    swapping'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 控制台显示交换前后num1和num2的值'
- en: '](img/Figure_4.4._B12346.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4._B12346.jpg)'
- en: Figure 4.4 – Console showing the values of num1 and num2 before and after swapping
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 控制台显示交换前后num1和num2的值
- en: 'The `ref` keyword can be used to specify a reference return value. In this
    case, it must be present in the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`关键字可用于指定引用返回值。在这种情况下，它必须出现在以下位置：'
- en: In the method signature, before the return type.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法签名中，在返回类型之前。
- en: In the return statement, between the `return` keyword and the returned value.
    Such a value is called a *ref return value*.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在返回语句中，在`return`关键字和返回的值之间。这样的值称为*ref返回值*。
- en: In the declaration of a local variable that will receive the returned reference,
    before the variable's type. Such a variable is called a *ref local variable*.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将返回的引用分配给本地变量的声明中，在变量的类型之前。这样的变量称为*ref本地变量*。
- en: Before the call to the method with a `ref` return.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用带有`ref`返回的方法之前。
- en: 'In the following example, the `Project` class has a member field of the `Employee`
    type. A reference to an `Employee` instance is set in the constructor. The `GetOwner()`
    method returns a reference to the member field:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Project`类具有`Employee`类型的成员字段。在构造函数中设置了对`Employee`实例的引用。`GetOwner()`方法返回对成员字段的引用：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be used as follows to retrieve and change the owner of a project.
    In the following code, notice the use of the `ref` keyword in the declaration
    of the local variable and the invocation of the `GetOwner()` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式用于检索和更改项目的所有者。在以下代码中，请注意在本地变量声明和调用`GetOwner()`方法中使用`ref`关键字：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of this program is shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下截图所示：
- en: '![Figure 4.5 – A screenshot of the output from the previous snippet'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 上一段代码的输出截图'
- en: '](img/Figure_4.5._B12346.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5._B12346.jpg)'
- en: Figure 4.5 – A screenshot of the output from the previous snippet
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 上一段代码的输出截图
- en: 'When using `ref` to return a value, you must be aware of the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ref`返回值时，必须注意以下事项：
- en: It is not possible to return a reference to a local variable.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能返回对局部变量的引用。
- en: It is not possible to return a reference to `this`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能返回对`this`的引用。
- en: It is possible to return references to class fields but also to properties without
    a `set` accessor.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以返回对类字段的引用，也可以返回对没有`set`访问器的属性的引用。
- en: It is possible to return a reference to `ref`/`in`/`out` parameters.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以返回对`ref`/`in`/`out`参数的引用。
- en: Returning by reference breaks the encapsulation because the caller gets full
    access to the state, or parts of the state, of an object.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用返回会破坏封装，因为调用者可以完全访问对象的状态或部分状态。
- en: Let's now look at the `in` keyword.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看一下`in`关键字。
- en: The in keyword
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: in关键字
- en: The `in` keyword is very similar to the `ref` keyword. It causes an argument
    to be passed by reference. However, the key difference is that an `in` argument
    cannot be modified by the called method. An `in` parameter is basically a `readonly
    ref` parameter. Should the called method try to modify the value, the compiler
    will issue an error. A variable that is passed as an `in` argument must be initialized
    before being passed as an argument in a method called.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`关键字与`ref`关键字非常相似。它导致参数通过引用传递。然而，关键区别在于`in`参数不能被调用方法修改。`in`参数基本上是一个`readonly
    ref`参数。如果被调用的方法尝试修改值，编译器将发出错误。作为`in`参数传递的变量在传递给调用方法的参数之前必须初始化。'
- en: 'The following sample shows a method that takes two `in` arguments. Any attempt
    to change their value results in a compiler error:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个接受两个“in”参数的方法。任何试图更改它们的值都会导致编译器错误：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Specifying the `in` keyword when passing the arguments to the method is optional.
    In the preceding example, this is omitted.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递参数给方法时，指定`in`关键字是可选的。在上面的例子中，这是被省略的。
- en: The `in` specifier is mostly intended for passing references to value type objects
    on hot paths, that is, functions that are called repeatedly. When you pass a value
    type object to a function, a copy of the value is made on the stack. Typically,
    this does not pose any performance concerns but, when it is happening over and
    over again, performance issues arise. By using the `in` specifier, a read-only
    reference to the object is passed, thereby avoiding the copy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`说明符主要用于在热路径上传递值类型对象的引用，即重复调用的函数。当将值类型对象传递给函数时，在堆栈上会创建一个值的副本。通常，这不会引起任何性能问题，但是当这种情况一再发生时，性能问题就会出现。通过使用`in`说明符，可以传递对象的只读引用，从而避免复制。'
- en: Another benefit of the `in` specifier is the communication of the clear design
    intent that a parameter is not supposed to be modified by a method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`说明符的另一个好处是清晰地传达参数不应该被方法修改的设计意图。'
- en: The out keyword
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: out关键字
- en: The `out` keyword is similar to the `ref` keyword. The difference is that a
    variable passed as an `out` argument does not have to be initialized before the
    method called, but the method taking an `out` parameter must assign a value to
    it before returning. The `out` keyword must be present both in the method definition
    and in the invocation of the method, before the argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字类似于`ref`关键字。不同之处在于，作为`out`参数传递的变量在调用方法之前不必初始化，但是在返回之前，接受`out`参数的方法必须为其分配一个值。在方法定义和方法调用之前，`out`关键字必须都存在。'
- en: Returning an output value is useful in situations when a method needs to return
    more than one value, or when it needs to return a value but also information about
    whether the execution was successful or not. An example is `int.TryParse()`, which
    returns a Boolean indicating whether the parsing was successful and the actual
    parsed value as an `out` parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回输出值在方法需要返回多个值或者需要返回一个值但也需要返回执行是否成功的信息时非常有用。一个例子是`int.TryParse()`，它返回一个布尔值，指示解析是否成功，并将实际解析的值作为`out`参数返回。
- en: 'To see how it works, let''s take a look at the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看它是如何工作的，让我们看下面的例子：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have defined a `static` method to return the square of an integer. The `Square`
    method will accept two parameters. The `int` parameter will be an integer value
    and it will return the square of the input number via the `out` parameter output.
    It can be used as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`static`方法来返回一个整数的平方。`Square`方法将接受两个参数。`int`参数将是一个整数值，并且它将通过`out`参数输出返回输入数字的平方。可以如下使用：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Upon execution, the output of this program will be `100`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，此程序的输出将是`100`。
- en: A variable that is used as an `out` argument can be declared inline in the method
    invocation. This produces simpler and more compact code. The scope of the inline
    variable is the scope in which the method is being invoked.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`out`参数使用的变量可以在方法调用中内联声明。这会产生更简单、更紧凑的代码。内联变量的作用域是调用方法的作用域。
- en: 'The preceding code can be simplified as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以简化如下：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are some restrictions when using these parameter specifiers, which will
    be explained in the following section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些参数说明符时有一些限制，将在下一节中进行解释。
- en: Understanding their limitations
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 了解它们的限制
- en: 'When using the `ref`, `in`, and `out` parameters, you must be aware of several
    limitations. These keywords cannot be used with the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ref`、`in`和`out`参数时，必须注意几个限制。这些关键字不能与以下内容一起使用：
- en: Async methods, defined with the `async` modifier.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`修饰符定义的异步方法。
- en: Iterator methods, which include either `yield return` or `yield break`.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器方法，其中包括`yield return`或`yield break`。
- en: 'On the other hand, the `ref`, `in`, and `out` keywords are not considered a
    part of the method signature in the context of overload resolution. That means
    you cannot have two overloads of the same method: one that takes a `ref` argument
    and one that takes the same argument as an `out` parameter. However, it is possible
    to have overloaded methods if one has a value parameter, and the other has a `ref`,
    `in`, or `out` parameter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在重载解析的上下文中，`ref`、`in`和`out`关键字不被视为方法签名的一部分。这意味着你不能有两个相同方法的重载：一个接受`ref`参数，另一个接受相同参数作为`out`参数。但是，如果一个方法有一个值参数，另一个方法有一个`ref`、`in`或`out`参数，那么可以有重载的方法：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the methods that we have seen so far in this book have a fixed number of
    arguments. The language, however, allows us to define methods that can take a
    variable number of arguments. This topic is discussed next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本书中看到的所有方法都有固定数量的参数。然而，语言允许我们定义可以接受可变数量参数的方法。下面将讨论这个主题。
- en: Methods with a variable number of arguments
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有可变数量参数的方法
- en: So far, we have only seen methods that take zero or a fixed number of arguments.
    However, it is also possible to define methods that take any number of arguments
    of the same type. To do so, you must have an argument that is a single-dimensional
    array preceded by the `params` keyword. This parameter does not have to be the
    only parameter of the method, but no further parameters are allowed after it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了接受零个或固定数量参数的方法。然而，也可以定义接受相同类型任意数量参数的方法。为此，必须有一个由`params`关键字引导的单维数组参数。这个参数不一定要是方法的唯一参数，但在它之后不允许有更多的参数。
- en: 'In the following example, we have two methods—`Any()` and `All()`—that take
    a variable number of Boolean values and return a Boolean value, indicating whether
    any of them is `true`, and respectively, whether all of them are `true`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有两个方法—`Any()`和`All()`—它们接受可变数量的布尔值，并返回一个布尔值，指示它们中是否有任何一个为`true`，以及分别是否它们全部为`true`：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Both of these methods can be invoked with zero, one, or any other number of
    arguments, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以用零个、一个或任意数量的参数来调用，如下所示：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The way the arguments are provided for a method call is flexible. We will look
    at existing possibilities next.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用时提供参数的方式是灵活的。接下来我们将看看现有的可能性。
- en: Named and optional arguments
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名和可选参数
- en: In all of the examples we have seen so far, the arguments for a method call
    were provided in the order of the parameter declaration in the method signature.
    These are called *positional arguments* because they are evaluated based on the
    position they are given. Moreover, all the parameters were mandatory, which means
    that an invocation cannot occur unless an argument is supplied for each parameter
    in the parameters list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有例子中，方法调用的参数都是按照方法签名中参数声明的顺序提供的。这些被称为*位置参数*，因为它们是基于给定位置进行评估的。此外，所有参数都是必需的，这意味着除非为参数列表中的每个参数提供了参数，否则不能发生调用。
- en: 'However, C# supports two more types of arguments: *optional arguments* and
    *named arguments*. These are often used together and enable us to supply only
    some arguments for the parameters in a list of optional parameters. These can
    be used with methods, indexers, constructors, and delegates.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C#支持另外两种类型的参数：*可选参数*和*命名参数*。这些经常一起使用，使我们能够为可选参数列表中的参数提供部分参数。这些可以用于方法、索引器、构造函数和委托。
- en: Optional arguments
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'When declaring a method, constructor, indexer, or delegate, we can specify
    a default value for a parameter. When such a parameter exists, supplying an argument
    for it upon the member invocation is optional. If none is provided, the compiler
    will use the default one. A default value for a parameter must be one of the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明方法、构造函数、索引器或委托时，我们可以为参数指定默认值。当存在这样的参数时，在成员调用时提供参数是可选的。如果没有提供参数，编译器将使用默认值。参数的默认值必须是以下之一：
- en: A constant expression
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量表达式
- en: An expression of the `new T()` form, where `T` is a value type
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new T()`形式的表达式，其中`T`是值类型'
- en: An expression of the `default(T)` form, where `T` is also a value type
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(T)`形式的表达式，其中`T`也是值类型'
- en: A method can have both required and optional parameters. If optional parameters
    are present, they must follow all the non-optional parameters. A non-optional
    parameter cannot follow an optional parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以有必需和可选参数。如果存在可选参数，则它们必须跟在所有非可选参数后面。非可选参数不能跟在可选参数后面。
- en: 'Let''s consider the following implementation of the `Point` structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`Point`结构的以下实现：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The constructor takes two parameters, both of them having the default value
    `0`. This means they are both optional. We can invoke the constructor in any of
    the following forms:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受两个参数，它们都具有默认值`0`。这意味着它们都是可选的。我们可以以以下任何形式调用构造函数：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the first example, no argument to the constructor of `Point` is supplied,
    so the compiler will use `0` for both `x` and `y`. In the second example, a single
    argument is supplied and that will be used to bind to the first constructor parameter.
    Therefore, `x` will be `1` and `y` will be `0`. In the third and last example,
    two arguments are supplied, and they are bound to `x` and `y` in this order. Therefore,
    `x` is 1 and `y` is `2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，没有提供`Point`构造函数的参数，因此编译器将使用`0`作为`x`和`y`的值。在第二个例子中，提供了一个参数，它将用于绑定到第一个构造函数参数。因此，`x`将是`1`，`y`将是`0`。在第三个和最后一个例子中，提供了两个参数，它们按照这个顺序绑定到`x`和`y`。因此，`x`是1，`y`是`2`。
- en: Named arguments
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数
- en: Named arguments enable us to invoke a method specifying the arguments by their
    name and not by their position in the parameters list. Arguments can be specified
    in any order and, in combination with default arguments, we can specify only some
    arguments for a method invocation. Named arguments are provided by specifying
    the parameter name followed by a colon (`:`) and the value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数使我们能够通过它们的名称而不是在参数列表中的位置来调用方法。参数可以以任何顺序指定，并且与默认参数结合使用，我们可以为方法调用指定部分参数。通过指定参数名称后跟冒号（`:`）和值来提供命名参数。
- en: 'Let''s consider the following examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first three constructor invocations are equivalent; `p1`, `p2`, and `p3`
    represent the same point. The invocation of the constructor uses one or more named
    arguments but the effect is the same. When constructing `p4`, on the other hand,
    only the value for `y` is specified. Therefore, `x` will be `0` and `y` will be
    `2`. Lastly, `p5` is created by specifying only a named argument for `x`. Therefore,
    `x` will be `1` and `y` will be `0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个构造函数调用是等效的；`p1`、`p2`和`p3`代表同一个点。构造函数的调用使用了一个或多个命名参数，但效果是相同的。另一方面，构造`p4`时，只指定了`y`的值。因此，`x`将是`0`，`y`将是`2`。最后，通过仅指定`x`的命名参数来创建`p5`。因此，`x`将是`1`，`y`将是`0`。
- en: Access modifiers
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: 'An access modifier is used to define the visibility of a type or member in
    C#. It specifies what other parts of the code in the assembly or other assemblies
    can access the type or the type member. C# defines six types of access modifiers,
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符用于定义C#中类型或成员的可见性。它指定程序集中的其他代码部分或其他程序集可以访问类型或类型成员的内容。C#定义了六种类型的访问修饰符，如下所示：
- en: '`public`: A public field can be accessed by any part of the code in the same
    assembly or in another assembly.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：公共字段可以被同一程序集中的任何代码部分或另一个程序集中的代码访问。'
- en: '`protected`: A protected type or member can be accessed only in the current
    class and in a derived class.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：受保护类型或成员只能在当前类和派生类中访问。'
- en: '`internal`: An internal type or member is accessible only within the current
    assembly.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal`：内部类型或成员只能在当前程序集中访问。'
- en: '`protected internal`: This is a combination of `protected` and `internal` access
    levels. A protected internal type or member is accessible in the current assembly
    or in a derived class.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected internal`：这是`protected`和`internal`访问级别的组合。受保护的内部类型或成员可以在当前程序集中或派生类中访问。'
- en: '`private`: A private type or member can be accessed only inside the class or
    struct. This is the least-accessible level defined in C#.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：私有类型或成员只能在类或结构内部访问。这是C#中定义的最不可访问级别。'
- en: '`private protected`: This is a combination of `private` and `protected` access
    levels. A private protected type or type member is accessible by code in the same
    class, or in a derived class, but only within the same assembly.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private protected`：这是`private`和`protected`访问级别的组合。私有受保护类型或类型成员可以被同一类中的代码或派生类中的代码访问，但只能在同一程序集中。'
- en: Trying to access a type or type member outside its access level will result
    in a compile-time error.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问超出其访问级别的类型或类型成员将导致编译时错误。
- en: 'There are different kinds of rules for accessibility that apply to types and
    type members:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于类型和类型成员的可访问性有不同种类的规则：
- en: '`public` or `internal` (which is the default). Derived classes, on the other
    hand, cannot have greater accessibility than their base types. That means if you
    have an `internal` class `B`, you cannot derive from it a `public` class `D`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`或`internal`（默认）。另一方面，派生类不能比其基类型具有更大的可访问性。这意味着如果有一个`internal`类`B`，则不能从中派生一个`public`类`D`。'
- en: '`public`, `internal`, or `private`. These rules apply to nested structs and
    classes. The default access level for class and struct members is `private`. A
    nested type that is `private` is accessible only from the enclosing type. The
    accessibility of a member cannot be greater than the type that contains it.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`，`internal`或`private`。这些规则适用于嵌套的结构和类。类和结构成员的默认访问级别是`private`。私有的嵌套类型只能从包含类型中访问。成员的可访问性不能大于包含它的类型。'
- en: Moreover, the type of a field, property, or event must be at least as accessible
    as the field itself. Similarly, the return type of a method, indexer, or delegate,
    as well as the type of its parameters, cannot be less accessible than the member
    itself.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，字段、属性或事件的类型必须至少与字段本身一样可访问。类似地，方法、索引器或委托的返回类型以及其参数的类型不能比成员本身更不可访问。
- en: '`public` and `static`. Finalizers cannot have accessibility modifiers. Interfaces
    defined directly in a namespace can be `public` or `internal` (which is the default).
    Access modifiers cannot be applied to any interface members, which are implicitly
    `public`. In a similar manner, enumeration members are implicitly `public` and
    cannot have access specifiers. Delegates are like classes and structs – their
    default access is `internal` when defined directly in a namespace, and `private`
    when nesting in another type.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`和`static`。终结器不能有访问修饰符。直接在命名空间中定义的接口可以是`public`或`internal`（默认）。访问修饰符不能应用于任何接口成员，它们隐式为`public`。类似地，枚举成员隐式为`public`，并且不能有访问修饰符。委托类似于类和结构-当直接在命名空间中定义时，默认访问级别为`internal`，在另一个类型中嵌套时为`private`。'
- en: 'The following code shows various uses of access modifiers for types and type
    members:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了类型和类型成员的访问修饰符的各种用法：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have learned in this chapter how to define custom classes. In all the examples
    so far, the entire class was defined in a single place. However, it is possible
    to split a class across several different definitions, in the same or different
    files, which is what we will look at in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何定义自定义类。到目前为止的所有示例中，整个类都是在一个地方定义的。然而，可以将一个类分割成几个不同的定义，可以在同一个文件或不同的文件中进行，这是我们将在下一节中讨论的内容。
- en: Partial classes
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分类
- en: A partial class allows us to divide our class into multiple class definitions,
    which is useful when a class becomes very large or when we want to separate a
    class logically into multiple parts. This enables technologies such as WPF to
    work better because the user code and the code written by the IDE designers are
    separated into different source files.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类允许我们将类分成多个类定义，当一个类变得非常庞大或者我们想要逻辑上将一个类分成多个部分时，这是非常有用的。这使得诸如WPF之类的技术能够更好地工作，因为用户代码和IDE设计者编写的代码被分隔到不同的源文件中。
- en: Each part can be defined in a different source file using the `partial` keyword.
    This keyword must appear immediately before the `class` keyword. The parts must
    be available at compile time. During compilation, the parts are combined into
    a single type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分可以使用`partial`关键字在不同的源文件中定义。此关键字必须立即出现在`class`关键字之前。这些部分必须在编译时可用。在编译过程中，这些部分被合并成一个单一类型。
- en: The `partial` keyword can be applied not only to classes, but also structures,
    interfaces, and methods. The same rules apply to all of them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`关键字不仅可以应用于类，还可以应用于结构、接口和方法。所有这些都适用相同的规则。'
- en: 'An example of the `partial` class is shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`partial`类的一个示例：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we split the class definition into two `partial` classes. Both `partial`
    classes contain some properties. We can instantiate the `partial` class and use
    its properties similar to a normal class. Refer to the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将类定义分成了两个`partial`类。两个`partial`类都包含一些属性。我们可以实例化`partial`类并像普通类一样使用它的属性。参考以下代码片段：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following list contains properties of partial types, as well as rules for
    them:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含了部分类型的属性，以及它们的规则：
- en: All the parts must have the same accessibility.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有部分必须具有相同的可访问性。
- en: Different parts may specify a different base interface. The final type will
    implement all the listed interfaces.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的部分可以指定不同的基接口。最终类型将实现所有列出的接口。
- en: If multiple parts specify a base class then it must be the same base class,
    as multiple inheritances are not supported in C#. A base class can be specified
    only on one part. It is optional on the others.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个部分指定了一个基类，那么它必须是相同的基类，因为C#不支持多重继承。基类只能在一个部分上指定。其他部分是可选的。
- en: Attributes of all the parts are merged together at compile type. The final type
    will have all the attributes used on all the part declarations.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有部分的属性在编译时合并在一起。最终类型将具有所有部分声明中使用的属性。
- en: Nested classes can also be partial.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类也可以是partial的。
- en: Methods can also be partial. This enables us to provide the signature in one
    part of a `partial` class or structure and the implementation in another. This
    is useful in IDEs to provide method hooks that developers may or may not implement.
    If a partial method does not have an implementation, it is removed from the class
    definition at compile time. Partial methods cannot have an access modifier and
    are implicitly private. Also, a partial method cannot return a value; the return
    type of a partial method must be `void`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以是partial的。这使我们能够在`partial`类或结构的一个部分中提供签名，而在另一个部分中提供实现。这在IDE中很有用，可以提供开发人员可能或可能不实现的方法挂钩。如果一个partial方法没有实现，它将在编译时从类定义中移除。partial方法不能有访问修饰符，它们是隐式私有的。此外，partial方法不能返回值；partial方法的返回类型必须是`void`。
- en: Structures
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: 'The content of this chapter so far has been focused on classes. Types that
    are defined as classes are reference types. However, in .NET and C#, there is
    another category of types: **value types**. Value types have value semantics,
    meaning that the value of the object, and not a reference to the object, is copied
    on assignment.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的内容都集中在类上。作为类定义的类型是引用类型。然而，在.NET和C#中，还有另一类类型：**值类型**。值类型具有值语义，这意味着在赋值时复制的是对象的值，而不是对象的引用。
- en: 'Value types are defined using the `struct` keyword instead of `class`. In most
    aspects, structures are identical to classes and the characteristics presented
    in this chapter for classes apply to structures too. However, there are several
    key differences:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型使用`struct`关键字来定义，而不是`class`。在大多数方面，结构与类是相同的，本章介绍的特性也适用于结构。然而，它们也有一些关键的区别：
- en: Structures do not support inheritance. Although a structure can implement any
    number of interfaces, it cannot derive from another structure. For this reason,
    structure members cannot have the `protected` access modifier. Also, a structured
    method or property cannot be `abstract` or `virtual`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构不支持继承。虽然一个结构可以实现任意数量的接口，但它不能从另一个结构派生。因此，结构成员不能有`protected`访问修饰符。此外，结构的方法或属性不能是`abstract`或`virtual`。
- en: A structure cannot declare a default (parameterless) constructor.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构不能声明默认（无参数）构造函数。
- en: Structures can be instantiated without using the `new` operator.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构可以在不使用`new`运算符的情况下实例化。
- en: In a structure declaration, fields cannot be initialized unless they are declared
    `const` or `static`.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构声明中，除非声明为`const`或`static`，否则字段不能被初始化。
- en: 'Let''s consider the following example where we define a structure called `Point`
    with two integer fields:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例，在这个示例中，我们定义了一个名为`Point`的结构，它有两个整数字段：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can instantiate this either using the `new` operator, which would call the
    default constructor initializing all the member fields with their default value,
    or directly, without the `new` operator. In this case, the member fields would
    remain uninitialized. This could be useful for performance reasons, but such an
    object cannot be used until all of its fields are properly initialized:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`new`运算符来实例化它，这将调用默认构造函数，将所有成员字段初始化为它们的默认值，或者直接在没有`new`运算符的情况下实例化它。在这种情况下，成员字段将保持未初始化状态。这可能对性能有用，但在所有字段正确初始化之前，这样的对象不能被使用：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code uses the `new` operator to create an instance of the type.
    On the other hand, in the following example, the object is created without the
    `new` operator:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`new`运算符来创建类型的实例。另一方面，在下面的例子中，对象是在没有`new`运算符的情况下创建的：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While structures and classes have many things in common, they also differ in
    several key aspects. It is important to understand when you should use classes
    and when you should use structures. A structure should be used in the following
    cases:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结构和类有许多共同之处，但它们在一些关键方面也有所不同。重要的是要理解何时应该使用类，何时应该使用结构。在以下情况下应该使用结构：
- en: When it represents a single value (such as a point, a GUID, and so on)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它表示单个值（例如一个点，一个GUID等）
- en: When it is small (typically no larger than 16 bytes)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它很小（通常不超过16个字节）
- en: When it is immutable
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它是不可变的时候
- en: When it is short-lived
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它是短暂的时候
- en: When it is not used frequently in boxing and unboxing operations (which alter
    performance)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它在装箱和拆箱操作中不经常使用（这会影响性能）
- en: In all the other cases, types should be defined as classes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，类型应该被定义为类。
- en: A variable of a value type cannot be assigned a `null` value. However, for situations
    when no value is a valid value for a value type, a nullable value type (denoted
    as `T?` using shorthand syntax) can be used. Nullable types were discussed in
    [*Chapter 2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and
    Operators*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的变量不能被赋予`null`值。然而，对于值类型来说，当没有值是有效的值时，可以使用可空值类型（使用简写语法表示为`T?`）。可空类型在[*第2章*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036)
    *数据类型和运算符*中已经讨论过。
- en: 'The following shows an example of a nullable `Point` variable assigned with
    `null`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将可空的`Point`变量赋值为`null`的示例：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It is often mentioned in the literature that instances of value types are stored
    on the stack. This statement is only partially true. The stack is an implementation
    detail; it is not part of the characteristics of value types. Local variables
    or temporaries of value types are indeed stored on the stack (unless they are
    not closed over outer variables of a lambda or an anonymous method) and not part
    of an iterator block.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 文献中经常提到值类型的实例存储在堆栈上。这种说法只是部分正确的。堆栈是一个实现细节；它不是值类型的特征之一。值类型的局部变量或临时变量确实存储在堆栈上（除非它们没有封闭在lambda或匿名方法的外部变量中），并且不是迭代器块的一部分。
- en: 'Otherwise, they are typically stored on the heap. However, this is entirely
    an implementation and compiler detail and, in fact, value types can be stored
    in many places: in the stack, in a CPU register, on the FPU frame, on the heap
    managed by the garbage collector, on the loader heap of the AppDomain, or in the
    thread-local storage (if the variable has the `ThreadStorage` attribute).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它们通常存储在堆上。然而，这完全是一个实现和编译器的细节，事实上，值类型可以存储在许多地方：在堆栈中，在CPU寄存器中，在FPU帧上，在垃圾收集器管理的堆上，在AppDomain的加载器堆中，或者在线程本地存储中（如果变量具有`ThreadStorage`属性）。
- en: When a value type object (the storage location contains the value directly)
    is assigned to a reference type object (the storage location contains a reference
    to the actual value), the process of boxing occurs. The other way around the process
    is called unboxing. We have discussed these two previously in this book, in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当将值类型对象（存储位置直接包含值）赋给引用类型对象（存储位置包含实际值的引用）时，会发生装箱的过程。反之，这个过程称为拆箱。我们在本书中之前已经讨论过这两个过程，在[*第2章*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036)
    *数据类型和运算符*中。
- en: 'Take a look at the following example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的例子：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have two variables of the `Point` value type and we want to check whether
    they are equal. To do so, we invoke the `Equals()` method that is defined in the
    `System.Object` base class. When we do this, boxing occurs because the parameter
    of `Equals` is an object, that is, a reference type. Boxing may become a performance
    issue if it is performed very often. There are two ways to avoid boxing for a
    value type.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个`Point`值类型的变量，我们想要检查它们是否相等。为此，我们调用了在`System.Object`基类中定义的`Equals()`方法。当我们这样做时，会发生装箱，因为`Equals`的参数是一个对象，即一个引用类型。如果装箱频繁进行，可能会成为性能问题。有两种方法可以避免对值类型进行装箱。
- en: The first solution is to implement the `IEquatable<T>` interface that contains
    a single `Equals(T)` method. This method allows both value and reference types
    to implement a way that determines whether two objects are equal. This interface
    is used by generic collections for testing for equality in various methods. Therefore,
    for performance reasons, it should be implemented by all types that might be stored
    in generic collections.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案是实现包含单个`Equals(T)`方法的`IEquatable<T>`接口。这个方法允许值类型和引用类型都实现一种确定两个对象是否相等的方式。这个接口被泛型集合用于在各种方法中测试相等性。因此，出于性能原因，所有可能存储在泛型集合中的类型都应该实现这个接口。
- en: 'The implementation of the `Point` structure that implements `IEquatable<T>`
    is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了实现`IEquatable<T>`的`Point`结构如下：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, you should notice that the generic type parameter for `IEquatable`
    is the type itself, `Point`. This is a technique called the *curiously recurring
    template pattern*. The class implements `Equals(Point)`, checking the properties
    of the type. However, it also overrides the `System.Object` virtual methods, `Equals()`
    and `GetHashCode()`, making sure the two implementations are consistent.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你应该注意到`IEquatable`的泛型类型参数是类型本身，即`Point`。这是一种称为*奇异递归模板模式*的技术。该类实现了`Equals(Point)`，检查类型的属性。然而，它还重写了`System.Object`虚拟方法，`Equals()`和`GetHashCode()`，确保这两个实现是一致的。
- en: 'When implementing the `IEquatable<T>` interface, you should keep the following
    in mind:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`IEquatable<T>`接口时，应牢记以下几点：
- en: '`Equals(T)` and `Equals(object)` must return consistent results.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Equals(T)`和`Equals(object)`必须返回一致的结果。'
- en: If the value is comparable, then it should implement `IComparable<T>` too.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值是可比较的，那么它也应该实现`IComparable<T>`。
- en: If the type implements `IComparable<T>`, then it should implement `IEquatable<T>`
    too.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型实现了`IComparable<T>`，那么它也应该实现`IEquatable<T>`。
- en: 'The second solution is to overload the `==` and `!=` operators. This can be
    done as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是重载`==`和`!=`运算符。可以这样做：
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this case, we will no longer use `Equals()` to compare values, but the two
    operators `==` and `!=`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将不再使用`Equals()`来比较值，而是使用两个运算符`==`和`!=`：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is, however, possible to both implement `IEquatable<T>` and overload the
    comparison operators, if you want to be able to check for equality both ways.
    We will discuss operator overloading in more detail in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103),
    *Object-Oriented Programming in C#*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要能够双向检查相等性，也可以同时实现`IEquatable<T>`和重载比较运算符。我们将在[*第5章*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103)
    *C#面向对象编程*中更详细地讨论运算符重载。
- en: Enumerations
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An enumeration is a set of named integral constants. We use the `enum` keyword
    to declare an enumeration. An enumeration is a value type. Enumerations are useful
    when we want to use a limited number of integral values for some particular purpose.
    Defining and using an enumeration has several advantages:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一组命名的整数常量。我们使用`enum`关键字声明枚举。枚举是值类型。当我们想要为某个特定目的使用有限数量的整数值时，枚举非常有用。定义和使用枚举有几个优点：
- en: We use named constants instead of literal values. This makes the code more readable
    and easier to maintain.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用命名常量而不是文字值。这样做使代码更易读和更易于维护。
- en: When you use IDEs, such as Visual Studio, you can see the list of possible values
    that can be assigned to a variable.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用诸如Visual Studio之类的IDE时，可以看到可以分配给变量的可能值列表。
- en: It enforces type safety for using numerical constants.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制使用数字常量进行类型安全。
- en: 'The following example shows an enumeration called `Priority` with four possible
    values:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子显示了一个名为`Priority`的枚举，有四个可能的值：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Each element of an enumeration stands for an integer value. By default, the
    first identifier is assigned to zero (`0`). The value of each successive identifier
    will increase by one. It is also possible to specify explicit values for each
    element. The following rules apply:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的每个元素代表一个整数值。默认情况下，第一个标识符被分配为零（`0`）。每个后续标识符的值将递增一。还可以为每个元素指定显式值。以下规则适用：
- en: These values must be within the range of the underlying type.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些值必须在基础类型的范围内。
- en: The values do not have to be consecutive or in order.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些值不必是连续的或有序的。
- en: Multiple identifiers with the same numerical value can be defined.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义具有相同数值的多个标识符。
- en: 'The enumeration, as defined, is semantically equivalent to the following, where
    values are specified explicitly:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如定义的枚举，语义上等同于以下情况，其中值是显式指定的：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As mentioned earlier, each element of the enumeration can have any numerical
    value. The following example shows a definition of the `Priority` enumeration.
    Where some elements do have explicit values, others are calculated based on them:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，枚举的每个元素都可以具有任何数值。下面的例子显示了`Priority`枚举的定义。其中一些元素具有显式值，其他元素是基于它们计算的：
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this implementation, `Low` is 10, `Normal` is 11, `Important` is 20, and
    `Urgent` is 21.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`Low`是10，`Normal`是11，`Important`是20，`Urgent`是21。
- en: 'The default underlying type of an enumeration is `int`, but any integral type
    can be specified as the underlying type. The `char` type cannot be the underlying
    type for an enumeration. In the following example, `byte` is the underlying type
    for `Priority`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的默认基础类型是`int`，但可以指定任何整数类型作为基础类型。`char`类型不能作为枚举的基础类型。在下面的例子中，`byte`是`Priority`的基础类型：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To use an element of an enumeration, you specify the enumeration name followed
    by a dot (`.`) and the element name, such as `Priority.Normal`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用枚举的元素，需要指定枚举名称，后跟一个点（`.`）和元素名称，例如`Priority.Normal`：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Any value of the underlying type can be assigned to an enumeration variable,
    even if an element with a corresponding numerical value does not exist. This is
    only possible with a cast. However, the literal `0` is implicitly convertible
    to any enumeration type without the need for a cast:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将基础类型的任何值分配给枚举变量，即使不存在具有相应数值的元素。这只能通过强制转换来实现。但是，文字`0`可以隐式转换为任何枚举类型，无需强制转换：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On the other hand, there is no implicit conversion between an enumeration and
    an integral type. To obtain the integer value of an enum identifier, we must use
    an explicit cast, as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，枚举和整数类型之间没有隐式转换。要获得枚举标识符的整数值，必须使用显式转换，如下所示：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Because all the references to the elements of an enumeration are replaced at
    compile time with their literal values, changing the values of the enumeration
    elements will affect referencing assemblies. When the enum type is used in other
    assemblies, the numerical values will be stored in those assemblies. Changes in
    the enumeration will not be reflected in the dependent assemblies unless they
    are recompiled.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因为枚举的所有元素的引用在编译时都被替换为它们的文字值，所以改变枚举元素的值会影响引用的程序集。当枚举类型在其他程序集中使用时，数值将存储在这些程序集中。除非重新编译，否则对枚举的更改不会反映在依赖的程序集中。
- en: 'Should you need to parse an enumeration value from a string, you can use the
    generic `Enum.TryParse()` method, as in the following example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从字符串解析枚举值，可以使用通用的`Enum.TryParse()`方法，如下例所示：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, if you want to parse from a string ignoring the case, then you need
    to use a non-generic overload of the same method, as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果要从字符串中解析并忽略大小写，则需要使用相同方法的非泛型重载，如下所示：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the string `"normal"` is parsed, ignoring the case to identify
    a possible value of the `Priority` enumeration. The value returned in the output
    parameter is `Priority.Normal`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，字符串`"normal"`被解析，忽略大小写以识别`Priority`枚举的可能值。输出参数中返回的值是`Priority.Normal`。
- en: Namespaces
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: We have mentioned namespaces several times in this book already without explaining
    what they really are. Namespaces are used to organize your code in logical units.
    A namespace defines a declaration space that contains types. This declaration
    space has a name that is part of a type's name. For instance, the .NET type `String`
    is declared in the `System` namespace. The complete name of the type is `System.String`.
    This is called the fully-qualified name of the type. Typically, we use only the
    unqualified name of the type (`String`, in this case), because we use `using`
    directives to bring declarations into the current scope from a particular namespace.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们已经多次提到了命名空间，但没有解释它们到底是什么。命名空间用于将代码组织成逻辑单元。命名空间定义了一个包含类型的声明空间。这个声明空间有一个名称，是类型名称的一部分。例如，.NET类型`String`在`System`命名空间中声明。类型的完整名称是`System.String`。这被称为类型的完全限定名称。通常，我们只使用类型的未限定名称（在这种情况下是`String`），因为我们使用`using`指令从特定命名空间将声明引入当前范围。
- en: 'Namespaces are used for two main purposes:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间主要用于两个目的：
- en: To help organize the code. Typically, types that belong together are declared
    in the same namespace.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助组织代码。通常，属于一起的类型在同一个命名空间中声明。
- en: To avoid possible name collisions for types. A program may rely on different
    libraries and it's not unlikely that types with the same name exist in two or
    more of these libraries. By using namespaces with a high degree of uniqueness,
    the chance for name collisions is drastically reduced.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免类型可能的名称冲突。程序可能依赖于不同的库，很可能在这些库中存在同名的类型。通过使用具有高度唯一性的命名空间，可以大大减少名称冲突的机会。
- en: Namespaces are introduced with the `namespace` keyword. They are implicitly
    public and you cannot use access modifiers when declaring them. A namespace can
    contain any number of types (classes, structures, enumerations, or delegates).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间是用`namespace`关键字引入的。它们是隐式公共的，当声明它们时不能使用访问修饰符。命名空间可以包含任意数量的类型（类、结构、枚举或委托）。
- en: 'The following example shows how to define a namespace, called `chapter_04`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何定义一个名为`chapter_04`的命名空间：
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Namespaces can be nested; one namespace can contain other namespaces. An example
    is shown in the following snippet, where the `chapter_04` namespace contains a
    nested namespace called `demo`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以嵌套；一个命名空间可以包含其他命名空间。下面的代码片段中展示了一个例子，其中`chapter_04`命名空间包含一个名为`demo`的嵌套命名空间：
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this example, the fully qualified name of the `foo` type is `chapter_04.demo.foo`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foo`类型的完全限定名称是`chapter_04.demo.foo`。
- en: 'For brevity, nested namespaces can be declared with a shorthand syntax: instead
    of multiple namespace declarations, only one is necessary. The name of the namespace
    is the concatenation of all the namespace names, separated by a dot. The previous
    declaration is equivalent to the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，嵌套命名空间可以用简写语法声明：只需要一个命名空间声明，而不是多个。命名空间的名称是所有命名空间名称的连接，用点分隔。前面的声明等同于以下内容：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To use an instance of this `foo` type, you would have to use its fully-qualified
    name, as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`foo`类型的实例，您必须使用它的完全限定名称，如下所示：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To avoid this, you can use a `using` directive, specifying the namespace name
    as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您可以使用`using`指令，指定命名空间名称如下：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A `using` directive can only be present at a namespace level (not locally to
    a method or type). Typically, you put them at the beginning of a source file,
    in which case its types are available throughout the entire source code defined
    in that file. Alternatively, you can specify them in a particular namespace, in
    which case its types will only be available to that namespace.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`指令只能存在于命名空间级别（而不是局部于方法或类型）。通常，您将它们放在源文件的开头，在这种情况下，它的类型在整个源代码中都可用。或者，您可以将它们指定在特定的命名空间中，在这种情况下，它的类型只对该命名空间可用。'
- en: 'A namespace is said to be open-ended. This means that you can have multiple
    namespace declaration with the same name, either in the same or different source
    files. In this case, all these declarations represent the same namespace and contribute
    to the same declaration space. The following snippet demonstrates an example of
    this case:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间被称为是开放式的。这意味着您可以有多个具有相同名称的命名空间声明，无论是在同一个源文件中还是在不同的源文件中。在这种情况下，所有这些声明都代表同一个命名空间，并且贡献到同一个声明空间。下面的代码片段演示了这种情况的一个例子：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is an implicit namespace that is the root of all namespaces (and contains
    all namespaces and types that are not declared in a named namespace). This namespace
    is called `global`. If you need to include it to specify a fully qualified name,
    then you must separate it with `::` and not with a dot, as in `global::System.String`.
    This can be necessary in situations where namespace names collide. Here is an
    example:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个隐式命名空间，它是所有命名空间的根（包含所有未在命名空间中声明的命名空间和类型）。这个命名空间叫做`global`。如果您需要包含它以指定完全限定名称，那么您必须用`::`而不是点来分隔它，就像`global::System.String`一样。这在命名空间名称冲突的情况下可能是必要的。这里有一个例子：
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this example, without the `global::` alias, the user-defined `chapter_04.System.Console`
    type would be used in the `Main()` function, instead of the expected `System.Console`
    type.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果没有`global::`别名，用户定义的`chapter_04.System.Console`类型将在`Main()`函数中使用，而不是预期的`System.Console`类型。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about the user-defined types in C#. We learned
    about classes and structures that help us to create custom user types in C#. We
    also learned how to create and use fields, properties, methods, indexers, and
    constructors inside a class, and we learned about the `this` and `static` keywords.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习了C#中的用户定义类型。我们学习了类和结构，这些帮助我们在C#中创建自定义用户类型。我们还学习了如何在类中创建和使用字段、属性、方法、索引器和构造函数，以及我们学习了`this`和`static`关键字。
- en: We explored the concepts of access modifiers and understood how we can define
    various levels of access to types and members. We also learned about `ref`, `in`,
    and `out` parameter modifiers, as well as methods with a variable number of arguments.
    Last but not least, we learned about namespace and how to use them to organize
    code and avoid name collisions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了访问修饰符的概念，并了解了如何为类型和成员定义不同级别的访问。我们还学习了`ref`、`in`和`out`参数修饰符，以及具有可变数量参数的方法。最后但同样重要的是，我们学习了命名空间以及如何使用它们来组织代码并避免名称冲突。
- en: In the next chapter, we will learn about **Object-Oriented Programming** (**OOP**)
    concepts. We will explore the building blocks of OOP—encapsulation, inheritance,
    polymorphism, and abstraction. We will also learn about abstract classes and interfaces.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习**面向对象编程**（**OOP**）的概念。我们将探讨OOP的构建模块——封装、继承、多态和抽象。我们还将学习抽象类和接口。
- en: Test what you learned
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: What is a class and what is an object?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类，什么是对象？
- en: What is the difference between classes and structures?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类和结构之间有什么区别？
- en: What is a read-only field?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是只读字段？
- en: What are expression body definitions?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是表达式主体定义？
- en: What is a default constructor and what is a static constructor?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认构造函数是什么，静态构造函数又是什么？
- en: What are auto-implemented properties?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是自动实现属性？
- en: What are indexers and how are they defined?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器是什么，它们如何定义？
- en: What is a static class and what can it contain?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态类是什么，它可以包含什么？
- en: What are the parameter specifiers and how do they differ?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数修饰符是什么，它们有什么不同？
- en: What are enumerations and when are they useful?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是枚举，它们在什么时候有用？
