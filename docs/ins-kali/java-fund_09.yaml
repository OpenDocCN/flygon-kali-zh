- en: '*Chapter 9*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*'
- en: Exception Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this lesson, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本课程结束时，您将能够：
- en: Use exception-throwing libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抛出异常的库
- en: Use exception handling effectively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用异常处理
- en: Acquire and release resources in a way that respects exceptions without creating
    leaks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种尊重异常的方式获取和释放资源，而不会造成泄漏
- en: Implement best practices to incorporate exceptions in Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施最佳实践以在Java中引入异常
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Exception handling is a powerful mechanism for handling erroneous cases that
    occur while our code is running. It enables us to focus on the main execution
    of the program and separate the error-handling code from the expected execution
    path. The Java language forces programmers to write exception-handling code for
    library methods, and IDEs such as IntelliJ, Eclipse, and so on help us generate
    the boilerplate code necessary. However, without proper guidance and understanding,
    standard exception codes may result in more harm than good. This lesson is a practical
    introduction to exceptions that will push you to contemplate various aspects of
    exception handling, and will provide a number of rules of thumb that may be helpful
    when you are dealing with exceptions in your programming life.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是一种处理代码运行时发生错误情况的强大机制。它使我们能够专注于程序的主要执行，并将错误处理代码与预期执行路径分开。Java语言强制程序员为库方法编写异常处理代码，而诸如IntelliJ、Eclipse等的IDE则帮助我们生成必要的样板代码。然而，如果没有适当的指导和理解，标准的异常代码可能会带来更多的害处。本课程是异常的实际介绍，将促使您思考异常处理的各个方面，并提供一些在处理编程生活中的异常时可能有帮助的经验法则。
- en: Motivation behind Exceptions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常背后的动机
- en: 'When we are creating programs, we usually focus on expected scenarios. For
    example, we will get the data from somewhere, we will extract certain information
    from the data that we assume to be there, we will send it to somewhere else, and
    so on. We would like our code to be readable, so that members of our team can
    clearly understand the business logic and can spot mistakes that we may make.
    However, in practice, our assumptions may not hold and there can be deviations
    from expected scenarios. For example, we may not be able to get data because of
    a problem with the network or the disk. We may receive data that does not fit
    our assumptions. Or, we may not be able to send data because of similar problems.
    We have to create programs that behave gracefully in unexpected situations. For
    example: we should enable the user to retry on a broken network connection. Exceptions
    are the way we handle such situations in Java without making our code too complex.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建程序时，通常会关注预期的情况。例如，我们将从某处获取数据，我们将从数据中提取我们假定存在的某些信息，然后将其发送到其他地方，依此类推。我们希望我们的代码能够清晰可读，这样我们团队的成员可以清楚地理解业务逻辑，并且可以发现我们可能犯的错误。然而，在实践中，我们的假设可能不成立，预期情况可能会出现偏差。例如，由于网络或磁盘出现问题，我们可能无法获取数据。我们可能会收到不符合我们假设的数据。或者，由于类似的问题，我们可能无法发送数据。我们必须创建能够在意外情况下优雅地运行的程序。例如：我们应该让用户在网络连接中断时能够重试。异常是我们在Java中处理这种情况的方式，而不会使我们的代码过于复杂。
- en: As programmers, we have to write code that will run well in various unexpected
    situations. However, we also want our code to be clean and understandable. These
    two goals can often compete with each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们必须编写能够在各种意外情况下正常运行的代码。然而，我们也希望我们的代码干净且易于理解。这两个目标经常会相互竞争。
- en: 'We would like to write code that reads clearly, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望编写的代码能够清晰地阅读，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This reflects an optimistic scenario, in which nothing unexpected occurs. However,
    it is often the case that unexpected situations occur. The user''s internet connection
    may be down, a web resource may be down, the client may run out of memory, a disk
    error may occur, and so on. Unless we write code that anticipates these problems,
    our programs may crash when such problems arise. It would be quite difficult to
    anticipate every kind of problem that may happen. Even if we simplify things and
    treat most errors the same way, we still may have to carry out many checks on
    our code. For example: we may have to write code that looks more like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了一个乐观的情景，即没有发生意外情况。然而，通常情况下会发生意外情况。用户的互联网连接可能中断，网络资源可能中断，客户端可能耗尽内存，可能发生磁盘错误，等等。除非我们编写能够预见这些问题的代码，否则当出现这些问题时，我们的程序可能会崩溃。预见每种可能发生的问题可能会非常困难。即使我们简化事情并以相同的方式处理大多数错误，我们仍然可能需要对我们的代码进行许多检查。例如：我们可能不得不编写更像这样的代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can come up with alternative code structures, but once you incorporate the
    extra code to handle errors at every step, your code becomes less readable, less
    understandable, and less maintainable. If you do not include such error-handling
    code, your programs may result in unwanted situations such as crashes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提出替代的代码结构，但一旦您在每个步骤中加入额外的错误处理代码，您的代码就会变得不那么可读，不那么易于理解，也不那么易于维护。如果您不包括这样的错误处理代码，您的程序可能会导致意外情况，例如崩溃。
- en: Here is a function in C that handles errors similar to our preceding pseudo
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在C中处理错误类似于我们之前的伪代码的函数。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you code using primitive languages such as C, you inevitably feel strong
    tension between readability and completeness. Luckily, in most modern programming
    languages, we have exception handling capabilities that reduce this tension. Your
    code can both be readable and can handle errors at the same time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用诸如C之类的原始语言编写代码时，您不可避免地会感到可读性和完整性之间的紧张关系。幸运的是，在大多数现代编程语言中，我们有异常处理能力，可以减少这种紧张关系。您的代码既可以清晰可读，又可以同时处理错误。
- en: The main language construct behind exception handling is the `try-catch` block.
    The code you put after the try is executed line by line. If any of the lines result
    in an error, the rest of the lines in the try block are not executed and the execution
    goes to the catch block, giving you a chance to handle the error gracefully. Here,
    you receive an exception object that contains detailed information about the problem.
    However, if no error happens in the try block, the catch block is never executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理背后的主要语言构造是try-catch块。在try之后放置的代码逐行执行。如果任何一行导致错误，try块中的其余行将不会执行，执行将转到catch块，让您有机会优雅地处理错误。在这里，您会收到一个包含有关问题详细信息的异常对象。但是，如果try块中没有发生错误，catch块将不会执行。
- en: 'Here, we modify our initial example to handle errors using the try-catch block
    instead of many `if` statements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了我们最初的示例，使用try-catch块来处理错误，而不是使用许多if语句：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this version, our code is placed between the try and catch keywords. Our
    code is free from error-handling code that would otherwise prevent readability.
    The default expected path of the code is quite clear: step 1, step 2, and step
    3\. However, if an error happens, the execution moves to the catch block immediately.
    There, we receive information about what the problem was in the form of an exception
    object and we are given a chance to handle the error gracefully.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们的代码被放置在try和catch关键字之间。我们的代码没有错误处理代码，否则会影响可读性。代码的默认预期路径非常清晰：步骤1，步骤2和步骤3。然而，如果发生错误，执行立即转移到catch块。在那里，我们会收到关于问题的信息，以异常对象的形式，并有机会优雅地处理错误。
- en: 'Most of the time, you will have code pieces that depend on one another. So,
    if an error happens in one of the steps, you usually do not want to execute the
    rest of the steps, since they depend on the success of that earlier step. You
    can use `try-catch` blocks creatively to denote code dependencies. For example:
    in the following pseudo code, there are errors in steps 2 and step 5\. The steps
    that successfully get executed are steps 1 and 4\. Since step 4 and later steps
    are independent of the success of the first three steps, we were able to denote
    their dependencies with two separate `try` - `catch` blocks. The error in step
    2 prevented the execution of step 3, but not step 4:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您的代码片段会相互依赖。因此，如果一个步骤发生错误，通常不希望执行其余的步骤，因为它们依赖于较早步骤的成功。您可以创造性地使用try-catch块来表示代码依赖关系。例如：在以下伪代码中，步骤2和步骤5中存在错误。成功执行的步骤是步骤1和步骤4。由于步骤4和后续步骤与前三个步骤的成功无关，我们能够使用两个单独的try-catch块来表示它们的依赖关系。步骤2中的错误阻止了步骤3的执行，但没有阻止步骤4的执行：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If there is an exception and you do not catch it, the error will be propagated
    to the caller. If this is your application, you should never let errors propagate
    out of your code, to prevent your app from crashing. However, if you are developing
    a library that is called by other code, letting errors propagate to the caller
    is sometimes a good idea. We will discuss this in more detail later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常而您没有捕获它，错误将传播到调用者。如果这是您的应用程序，您不应该让错误传播出您的代码，以防止应用程序崩溃。但是，如果您正在开发一个被其他代码调用的库，有时让错误传播到调用者是一个好主意。我们将在稍后更详细地讨论这个问题。
- en: 'Exercise 36: Introducing Exceptions'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：引入异常
- en: 'Now let''s actually see exceptions in action. One of the canonical exceptions
    is to try to divide a number by zero. Here, we will use it to create exceptions
    and verify our pseudo code from earlier:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实际看看异常的作用。其中一个经典的异常是尝试用零除以一个数字。在这里，我们将使用它来创建异常并验证我们之前的伪代码：
- en: 'Create a new `Main` class and add the main method as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Main类，并添加如下的主方法：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write code to print the result of the division of two numbers. Add the `try`
    – `catch` block to handle the exceptions:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码来打印两个数字的除法结果。添加try-catch块来处理异常：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and verify that the output looks like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并验证输出是否如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that results 2 and 5 contain division operations in which we divide a
    number by zero, which results in an exception. This way, we are intentionally
    creating exceptions in these two lines to see how execution progresses in the
    case of exceptions. Here is a breakdown of the expected execution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果2和5包含除以零的除法运算，这将导致异常。这样，我们有意在这两行中创建异常，以查看在异常情况下执行的进展。以下是预期执行的详细情况：
- en: Result 1 should print well.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果1应该正常打印。
- en: During result 2's execution we should get an exception, which should prevent
    result 2 from printing.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结果2的执行过程中，我们应该得到一个异常，这应该阻止结果2的打印。
- en: Because of the exception, execution should jump to the catch block, which should
    prevent result 3 from printing.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于异常，执行应该跳转到catch块，这应该阻止结果3的打印。
- en: Result 4 should print well.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果4应该正常打印。
- en: Just like result 2, during result 5's execution we should get an exception,
    which should prevent result 5 from printing.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像结果2一样，在结果5的执行过程中，我们应该得到一个异常，这应该阻止结果5的打印。
- en: Similarly, because of the exception, the execution should jump to the catch
    block, which should prevent result 6 from printing.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，由于异常，执行应该跳转到catch块，这应该阻止结果6的打印。
- en: With the help of the two `try-catch` blocks, we should skip results 3 and 6
    because of the exceptions on results 2 and 5\. This should leave only results
    1 and 4, which will be executed successfully.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 借助两个try-catch块的帮助，由于结果2和5的异常，我们应该跳过结果3和6。这应该只留下结果1和4，它们将成功执行。
- en: This shows that our preceding discussion was correct. Also, to verify the execution
    order, place a breakpoint in the result 1 line and click step over to watch how
    execution progresses step by step with the `try` - `catch` block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们之前的讨论是正确的。另外，为了验证执行顺序，请在结果1行中设置断点，然后单击“逐步执行”以观察执行如何逐步进行，使用try-catch块。
- en: With the help of exceptions and the `try-catch` block, we are able to write
    code that focuses more on the expected default execution path, while ensuring
    that we handle unexpected error cases and can recover or fail gracefully, depending
    on the severity of the error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过异常和`try-catch`块的帮助，我们能够编写更专注于预期的默认执行路径的代码，同时确保我们处理意外的错误情况，并根据错误的严重程度进行恢复或优雅失败。
- en: An Inevitable Introduction to Exceptions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常的不可避免介绍
- en: Practically, most newbie Java developers meet with exceptions when they call
    an exception-throwing method from a library. Such a method can specify that it
    throws an exception using the throws statement. When you call this kind of method,
    your code will not compile unless you write code that does something about the
    exception that the method may throw.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数新手Java开发者在调用库中抛出异常的方法时会遇到异常。这样的方法可以使用throws语句指定它会抛出异常。当你调用这种方法时，除非你编写处理该方法可能抛出的异常的代码，否则你的代码将无法编译。
- en: So, as a newbie Java developer, all you wanted was to call a method and now
    you are forced to do something about an exception that it may throw. Your IDE
    can generate code that takes care of the exception. However, default generated
    code is usually not the best. A newbie with no guidance and the powers of IDE
    code generation can create code that is quite bad. In this section, you will be
    guided on how best to use IDE-generated exception-handling code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个新手Java开发者，你所想要的只是调用一个方法，现在你被迫处理它可能抛出的异常。你的IDE可以生成处理异常的代码。然而，默认生成的代码通常不是最好的。一个没有指导的新手和IDE代码生成的能力可能会创建相当糟糕的代码。在本节中，你将得到如何最好地使用IDE生成的异常处理代码的指导。
- en: 'Let''s say you wrote the following code to open and read a file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写了以下代码来打开和读取一个文件：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Currently, your code will not compile and your IDE underlined the `FileInputStream`
    constructor in red. This is because it may throw an exception, as specified in
    its source code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的代码将无法编译，你的IDE用红色下划线标出了`FileInputStream`构造函数。这是因为它可能会抛出异常，就像在它的源代码中指定的那样：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, your IDE usually tries to be helpful. When you move the caret
    on to `FileInputStream` and hit *Alt* + *Enter* in IntelliJ, for example, you
    will see two quick-fix options: **Add exception to method signature** and **Surround
    with try/catch**. These correspond to the two options you have when dealing with
    specified exceptions, which we will learn about later in more depth. Here''s what
    the first option converts your code into:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你的IDE通常会试图提供帮助。例如，当你将光标移动到`FileInputStream`上并在IntelliJ中按下*Alt* + *Enter*时，你会看到两个快速修复选项：**在方法签名中添加异常**和**用try/catch包围**。这对应于处理指定异常时你所拥有的两个选项，我们稍后会更深入地学习。第一个选项将你的代码转换为以下内容：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now your main function also specifies that it can throw an exception. Such an
    exception causes the program to exit immediately, which may or may not be what
    you want. If this was a function that you give others as a library, this change
    would prevent their code from compiling, unless they, in turn, did something about
    the specified exception, just like you. Again, this may or may not be what you
    want to do.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的主函数也指定了它可能会抛出异常。这样的异常会导致程序立即退出，这可能是你想要的，也可能不是。如果这是一个你作为库提供给其他人的函数，这个改变将阻止他们的代码编译，除非他们反过来处理指定的异常，就像你一样。同样，这可能是你想要做的，也可能不是。
- en: 'If you selected "**Surround with try/catch**", which was the second option
    that IntelliJ provided, here is what your code would become:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了“**用try/catch包围**”，这是IntelliJ提供的第二个选项，你的代码将变成这样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we are writing code to handle the exception ourselves. This
    feels more appropriate; we are taking responsibility and writing code to do something
    about the exception. However, the code in its current form does more harm than
    good. First of all, it does not actually do anything useful with the exception;
    it just catches it, prints information about it to `stdout`, and continues the
    execution as if nothing happened. Especially in a project that is not a console
    application (like most Java programs), printing to the logs is hardly useful.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在编写代码来自己处理异常。这感觉更合适；我们正在承担责任并编写代码来处理异常。然而，当前形式的代码实际上更有害无益。首先，它实际上并没有对异常做任何有用的事情；它只是捕获它，将有关它的信息打印到`stdout`，然后继续执行，就好像什么都没有发生一样。特别是在一个不是控制台应用程序的项目中（像大多数Java程序一样），打印到日志几乎没有用处。
- en: If we cannot find this file to open, we should think cleverly about what we
    can do. Should we ask the user to look for the file? Should we download it from
    the internet? Whatever we do, taking a note in an obscure log file and sweeping
    the problem under the rug is probably one of the worst ways to handle the problem.
    If we cannot do anything useful, maybe not handling the exception and letting
    our caller deal with it would be a more honest way of dealing with the problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找不到这个文件来打开，我们应该聪明地考虑我们可以做什么。我们应该要求用户查找文件吗？我们应该从互联网上下载吗？无论我们做什么，把问题记录在一个晦涩的日志文件中，然后把问题搁置起来可能是处理问题的最糟糕的方式之一。如果我们无法做任何有用的事情，也许不处理异常，让我们的调用者处理它，可能是更诚实地处理问题的方式。
- en: Notice that there is no silver bullet, or one-size-fits-all suggestion here.
    Every exceptional case, every application, every context, and every user base
    is different, and we should come up with an exception handling strategy that fits
    the current situation best. However, if all you are doing is `e.printStackTrace()`,
    you are probably doing something wrong.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里没有银弹，也没有一刀切的建议。每个特殊情况，每个应用程序，每个上下文和每个用户群体都是不同的，我们应该提出一个最适合当前情况的异常处理策略。然而，如果你所做的只是`e.printStackTrace()`，那你可能做错了什么。
- en: 'Exercise 37: Using an IDE to Generate Exception-Handling Code'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习37：使用IDE生成异常处理代码
- en: 'In this exercise, we will have a look at generating exception handling code
    using an IDE:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看看如何使用IDE生成异常处理代码：
- en: 'Create a new Java console project in IntelliJ. Import `File` and the `FileInputStream`
    class:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ中创建一个新的Java控制台项目。导入`File`和`FileInputStream`类：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a class called `Main` and add the `main()` method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的类并添加`main()`方法：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the file as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式打开文件：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Read the file as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式读取文件：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that, in four places, IntelliJ underlines our code in red. These are functions
    that specify throwing an exception. This prevents your code from executing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在四个地方，IntelliJ用红色下划线标出了我们的代码。这些是指定抛出异常的函数。这会阻止您的代码执行。
- en: 'Go to the first issue (`FileInputStream`), press *Alt* + *Enter*, and select
    "`main` function can throw `FileNotFoundException`, but this was not enough as
    this is not the exception type that the other functions throw. Now go to the first
    remaining issue (`read`), press *Alt* + *Enter*, and select "`input.txt` in the
    meantime, this is what you should see as an output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到第一个问题（`FileInputStream`），按*Alt* + *Enter*，选择"`main`函数可以抛出`FileNotFoundException`，但这还不够，因为这不是其他函数抛出的异常类型。现在转到剩下的第一个问题（`read`），按*Alt*
    + *Enter*，选择"`input.txt`与此同时，这是您应该看到的输出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The exception propagated out of our main function and the JVM caught it and
    logged into the console.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 异常从我们的主函数传播出来，JVM捕获并记录到控制台中。
- en: 'Two things happened here. First, fixing the problem for `read()` was enough
    to eliminate all problems from the code, since both `read` and `close` throw the
    same exception: `IOException`, which is listed in the throws statement in the
    main function''s declaration. However, the `FileNotFoundException` exception that
    we had listed there disappeared. Why?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 两件事情发生了。首先，修复`read()`的问题足以消除代码中的所有问题，因为`read`和`close`都会抛出相同的异常：`IOException`，它在主函数声明的throws语句中列出。然而，我们在那里列出的`FileNotFoundException`异常消失了。为什么呢？
- en: This is because exception classes are in a hierarchy and `IOException` is an
    ancestor class of `FileNotFoundException`. Since every `FileNotFoundException`
    is also an `IOException`, specifying `IOException` was enough. If these two classes
    were not related in that way, IntelliJ would list the possible thrown exceptions
    as a comma-separated list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为异常类是一个层次结构，`IOException`是`FileNotFoundException`的祖先类。由于每个`FileNotFoundException`也是`IOException`，指定`IOException`就足够了。如果这两个类不是以这种方式相关的，IntelliJ将列出可能抛出的异常作为逗号分隔的列表。
- en: 'Now let''s provide the `input.txt` to our program. You can create the `input.txt`
    anywhere in your hard drive and provide a full path in the code; however, we will
    use a simple approach: IntelliJ runs your program inside the main project folder.
    Right-click on your project''s `input.txt` file here and write the text "`abc`"
    in it. If you run your program again, you should see an output similar to this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`input.txt`提供给我们的程序。您可以在硬盘的任何位置创建`input.txt`并在代码中提供完整的路径；但是，我们将使用一个简单的方法：IntelliJ在主项目文件夹中运行您的程序。在这里右键单击您项目的`input.txt`文件，并在其中写入文本"`abc`"。如果您再次运行程序，您应该会看到类似于这样的输出：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Specifying the exceptions was one way to make our program work. Another would
    be to catch them. Let''s try that now. Go back to the following version of your
    file; you can use undo repeatedly to do that:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定异常是使我们的程序工作的一种方法。另一种方法是捕获它们。现在让我们尝试一下。返回到您文件的以下版本；您可以重复使用撤消来做到这一点：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now move the caret on to `FileInputStream`, hit *Alt* + *Enter*, and select
    "`try/catch` block, it actually separated the creation of the reference variable
    from the exception-generating constructor call. This is mainly because `fileInputStream`
    is used later in the code and moving it inside the `try/catch` block would prevent
    it from being visible to those usages. This is actually a common pattern; you
    declare the variable before the `try/catch` block, handle any issues with its
    creation, and make it available for later, if necessary.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将光标移动到`FileInputStream`，按*Alt* + *Enter*，选择"`try/catch`块，它实际上将引用变量的创建与引发异常的构造函数调用分开。这主要是因为`fileInputStream`稍后在代码中使用，并且将其移动到`try/catch`块内将阻止它对这些用法可见。这实际上是一个常见的模式；您在`try/catch`块之前声明变量，处理其创建的任何问题，并在以后如果需要的话使其可用。
- en: 'The current code has a problem: if the `FileInputStream` inside the `try/catch`
    block fails, the `fileInputStream` will continue to be null. After the `try`/`catch`
    block, it will be dereferenced and you will get a null reference exception. You
    have two options: either you place all usages of the object in the `try/catch`
    block, or you check the reference for null. Here is the first of the two options:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前代码存在一个问题：如果`try/catch`块内的`FileInputStream`失败，`fileInputStream`将继续为空。在`try`/`catch`块之后，它将被取消引用，您将获得一个空引用异常。您有两个选择：要么将对象的所有用法放在`try/catch`块中，要么检查引用是否为空。以下是两种选择中的第一种：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We moved the code inside the `try`/ `catch` block to make sure we don''t dereference
    `fileInputStream` while null. However, we still have red underlines under `read()`
    and `close()`. *Alt* + *Enter* on `read()` gives you a couple of options, the
    first of which is to add a `catch` clause:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码移到`try`/`catch`块内，以确保我们不会在`fileInputStream`为空时取消引用。然而，`read()`和`close()`仍然有红色下划线。在`read()`上按*Alt*
    + *Enter*会给你一些选项，其中第一个选项是添加一个`catch`子句：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we have fixed all of the issues with our code and we can actually run it.
    Notice that the second catch clause is placed after the first, because `IOException`
    is a parent class of `FileNotFoundException`. If their order was the other way
    around, exceptions of type `FileNotFoundException` would actually be caught by
    the `IOException` catch block instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了代码中的所有问题，我们实际上可以运行它。请注意，第二个catch子句放在第一个之后，因为`IOException`是`FileNotFoundException`的父类。如果它们的顺序相反，类型为`FileNotFoundException`的异常实际上将被`IOException`捕获块捕获。
- en: 'Here is the second of the two options, not placing all the code inside the
    first try:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是两种选择中的第二种选择，不将所有代码放在第一个try中：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We run the second part of the code if the `fileInputStream` is not null. This
    way, we prevent the second part from running if creating the `FileInputStream`
    was not successful. It does not make a lot of sense to write it separately like
    this, but it would make sense if there was other code in between that is unrelated.
    You cannot put everything in the same `try` block, and in a later code, you may
    have to depend on that `try` block's success. A simple null check such as this
    is useful in that sense.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fileInputStream`不为空，我们就运行代码的第二部分。这样，如果创建`FileInputStream`不成功，我们就可以阻止第二部分运行。单独这样写可能没有太多意义，但如果中间有其他不相关的代码，那么这样写就有意义。你不能把所有东西都放在同一个`try`块中，在以后的代码中，你可能会依赖于那个`try`块的成功。这种简单的空值检查在这方面是有用的。
- en: Our code still has issues, though. Let's *Alt* + *Enter* on the `read()` and
    `close()`, and select `try`/`catch` blocks.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们的代码仍然存在问题。让我们在`read()`和`close()`上使用*Alt* + *Enter*，并选择`try`/`catch`块。
- en: 'A better way would be to place the whole block in a `try`/`catch`. In this
    case, we are giving up after the first error, which is a simpler and usually more
    correct approach:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的方法是将整个代码块放在一个`try`/`catch`中。在这种情况下，我们在第一个错误后放弃，这是一个更简单且通常更正确的方法：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To create this code, we did not rely on IntelliJ's quick fix with *Alt* + *Enter*.
    Since it's quite good usually, you may think that the code it creates is correct.
    However, you have to use your judgement, and sometimes correct the code it creates,
    as in this example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这段代码，我们没有依赖IntelliJ的快速修复功能*Alt* + *Enter*。虽然通常它很好，你可能会认为它创建的代码是正确的。然而，你必须运用自己的判断力，有时要纠正它创建的代码，就像这个例子一样。
- en: Now you have experienced the quick and dirty handling of exceptions using the
    help of an IDE. The skills you gained in this section should guide you when you
    are on a deadline and help you avoid pitfalls when using autogenerated exception
    code using an IDE.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经体验了使用IDE快速而简单地处理异常的方法。在这一节中获得的技能应该在你面临截止日期时指导你，并帮助你避免在使用IDE生成的异常代码时出现问题。
- en: Exceptions versus Error Codes
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常与错误代码
- en: 'Recall the C code example that we gave earlier:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前给出的C代码示例：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are a number of drawbacks to the method of handling errors used here.
    In this code, all we are trying to do is call three functions. However, for each
    function call, we are passing around values to track error states and using `if`
    statements for each function call if there was an error. Furthermore, the return
    value of the function is the error state—you are not allowed to return a value
    of your choosing. All this extra work dilutes the original code and makes it difficult
    to understand and maintain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的错误处理方法存在一些缺点。在这段代码中，我们只是尝试调用三个函数。然而，对于每个函数调用，我们都在传递值来跟踪错误状态，并且对于每个函数调用，如果出现错误，都要使用`if`语句。此外，函数的返回值是错误状态——你不能返回自己选择的值。所有这些额外的工作都使原始代码变得模糊，并且难以理解和维护。
- en: Another limitation of this approach is that a single integer value may not represent
    the error sufficiently. Instead, we may want to have more details about the error,
    when it happened, about which resource, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个局限性是，单个整数值可能无法充分表示错误。相反，我们可能希望有关于错误的更多细节，比如发生时间、关于哪个资源等等。
- en: 'Before exception handling, this was how programmers had to code to ensure the
    completeness of their programs. Exception handling brings a number of benefits.
    Consider this alternate Java code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理之前，程序员们必须编写代码来确保程序的完整性。异常处理带来了许多好处。考虑一下这个替代的Java代码：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we have the three function calls without any error-related code polluting
    them. These are placed in a `try`/`catch` block and error handling is done separately
    from the original code in the `catch` blocks. This is more desirable for the following
    reasons:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个函数调用，没有任何与错误相关的代码污染它们。这些放在了一个`try`/`catch`块中，错误处理是在`catch`块中单独完成的。出于以下原因，这更加可取：
- en: We do not have to have an `if` statement for each function call. We can group
    the exception handling in one place. It does not matter which function raised
    the exception; we catch all of them in one single place.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必为每个函数调用都有一个`if`语句。我们可以将异常处理集中在一个地方。不管是哪个函数引发了异常，我们都在一个地方捕获所有异常。
- en: There is not only one kind of problem that can happen in a function. Each function
    can raise more than one kind of exception. These can be handled in separate catch
    blocks, whereas, without exception handling, this would have required multiple
    if statements per function.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数中可能发生的问题不止一种。每个函数可能引发多种异常。这些可以在单独的catch块中处理，而不是像没有异常处理那样，这将需要每个函数多个if语句。
- en: 'The exception is represented by an object, not a single integer value. While
    an integer can tell us which kind of problem it was, an object can tell us much
    more: the call stack at the time of exception, the related resource, the user-readable
    explanation about the problem, and so on, can all be provided along with the exception
    object. This makes it much easier to act appropriately to exceptions compared
    to a single integer value.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常由对象表示，而不是单个整数值。虽然整数可以告诉我们出了什么问题，但对象可以告诉我们更多：异常发生时的调用堆栈、相关资源、关于问题的用户可读解释等等，都可以与异常对象一起提供。与单个整数值相比，这使得更容易对异常做出适当的反应。
- en: 'Exercise 38: Exceptions Versus Error Codes'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习38：异常与错误代码
- en: 'To complete the discussion about exceptions versus error codes, let''s experience
    both and see which one is simpler to deal with. In this exercise, we have a class
    with two different kinds of functions, with two functions in each kind. The `thFunction1()`
    and `thFunction2()` are functions that can throw exceptions upon errors. `ecFunction1()`
    and `ecFunction2()` are functions that return a value that indicates whether there
    was an error. We are using random numbers to simulate that errors occur sometimes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成关于异常与错误代码的讨论，让我们体验一下两者，看看哪一个更容易处理。在这个练习中，我们有一个类，其中包含两种不同类型的函数，每种函数有两个函数。`thFunction1()`和`thFunction2()`是在发生错误时可以抛出异常的函数。`ecFunction1()`和`ecFunction2()`是返回指示是否发生错误的值的函数。我们使用随机数来模拟有时会发生错误：
- en: 'Import the `IOException` and `Random` classes as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`IOException`和`Random`类如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a class called `Main` with an instance of the `Random` class:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的类，其中包含`Random`类的一个实例：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `thFunction1()` and `thFunction2()` functions, which throw an `IOException`
    as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`thFunction1()`和`thFunction2()`函数，它们抛出`IOException`如下：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare three variables with final values as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个具有最终值的变量如下：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create two functions, `ecFunction1()` and `ecFunction2()`, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个函数`ecFunction1()`和`ecFunction2()`如下：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create `callThrowingFunctions()` as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`callThrowingFunctions()`如下：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a method called `callErrorCodeFunctions()` as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`callErrorCodeFunctions()`的方法如下：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the `main` method as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main`方法如下：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our `main` function, we are first calling the throwing functions, followed
    by the error code functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们首先调用抛出函数，然后是错误代码函数。
- en: 'Run this program a couple of times to observe how errors are handled in each
    case. Here is an example of an error caught using exception handling:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行此程序，观察每种情况下如何处理错误。以下是使用异常处理捕获错误的示例：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that `thFunction2` was started, but not completed. The exception that it
    threw contained information about `thFunction2`. The shared `catch` block did
    not have to know where this exception was coming from; it simply caught the exception.
    This way, a single exception-catching block was able to handle multiple function
    calls. The exception object that was thrown by `thFunction2` and was caught by
    the catch block is able to transfer detailed information about the problem (for
    example, the stack trace). This leaves the default expected execution path clean,
    and the exception-catching block can deal with the problem in a meticulous way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`thFunction2`已经启动，但尚未完成。它抛出的异常包含有关`thFunction2`的信息。共享的`catch`块不必知道此异常来自何处；它只是捕获异常。这样，单个异常捕获块就能够处理多个函数调用。`thFunction2`抛出并被`catch`块捕获的异常对象能够传递有关问题的详细信息（例如堆栈跟踪）。这样，默认的预期执行路径保持干净，异常捕获块可以以细致的方式处理问题。
- en: 'On the other hand, take a look at this sample execution output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，看一下这个示例执行输出：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In `ecFunction1`, an unexpected error occurred. This was signaled simply by
    an error code value that was returned from this function. Note that this function
    could not have returned any other value; employee number, whether something is
    active, and so on, are some examples of things that a function might return. Using
    error codes returned from functions in this way prohibits passing such information
    in the return value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ecFunction1`中，发生了意外错误。这只是通过从该函数返回的错误代码值来表示的。请注意，此函数无法返回任何其他值；员工编号、某物是否活动等都是函数可能返回的一些示例。以这种方式从函数返回的错误代码禁止在返回值中传递此类信息。
- en: Furthermore, since the error is represented simply by a number, we are not able
    to get detailed information in the error-handling code. We also have to have error-handling
    code for each function call, as we would not have a way of differentiating between
    error locations otherwise. This creates code that is much more complicated and
    verbose than it should be.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于错误仅由一个数字表示，我们无法在错误处理代码中获得详细信息。我们还必须为每个函数调用编写错误处理代码，否则我们将无法区分错误位置。这会导致代码变得比应该更复杂和冗长。
- en: Play with the code further, run it many times, and observe its behavior. This
    should give you a better understanding of exceptions versus error codes and why
    exceptions are superior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步使用代码，多次运行它，并观察其行为。这应该让您更好地理解异常与错误代码，以及异常为什么更优越。
- en: 'Activity 36: Handling Mistakes in Numeric User Input'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动36：处理数字用户输入中的错误
- en: Now we will make use of exception handling in a real-world scenario. We will
    create a console application in which we ask for three whole numbers from the
    user, add them together, and print the result. If the user does not enter non-numeric
    text or a fractional number, we will ask the user to provide a whole number instead.
    We will do this for each number separately—a mistake in the third number will
    only require us to re-enter the third number and our program will remember the
    first two numbers just fine.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在一个真实场景中使用异常处理。我们将创建一个控制台应用程序，在其中我们要求用户输入三个整数，将它们相加，并打印结果。如果用户没有输入非数字文本或分数，我们将要求用户提供一个整数。我们将为每个数字分别执行此操作——第三个数字的错误只需要我们重新输入第三个数字，我们的程序将很好地记住前两个数字。
- en: 'These steps will help you complete this activity:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Start with an empty Java console project. Place the following code in it, which
    reads input from the keyboard and prints it back after the user hits the *Enter*
    key.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空的Java控制台项目开始。将以下代码放入其中，该代码从键盘读取输入，并在用户按下*Enter*键后将其打印出来。
- en: Use this as a starting point and convert the input to a number using the `Integer.parseInt()`
    function.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此作为起点，并使用`Integer.parseInt()`函数将输入转换为数字。
- en: Notice that the IDE did not warn us about a possible exception, unlike what
    we had in the earlier examples. This is because there are two types of exceptions,
    which we will learn about in an upcoming topic. For now, be aware that `Integer.parseInt()`
    can raise `java.lang.NumberFormatException`. Using the things we learned before
    wrap this line with a `try/catch` block that expects `NumberFormatException`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，与我们之前的例子不同，IDE没有警告我们可能出现异常。这是因为有两种类型的异常，我们将在接下来的主题中学习。现在，要知道`Integer.parseInt()`可能会引发`java.lang.NumberFormatException`。使用我们之前学到的知识，将这行代码放入一个期望`NumberFormatException`的`try/catch`块中。
- en: Now place this in a `while` loop. It should loop while we do not have a valid
    whole number (integer) input from the user. Once we have such a value, the `while`
    loop should not loop anymore. If the user does not enter a valid whole number,
    print out an appropriate message to the user. Do not print out a raw exception
    message or a stack trace. This way, we insist that we get a whole number from
    the user and will not give up until we get a whole number.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将其放入一个`while`循环中。只要用户没有输入有效的整数（整数），它就应该循环。一旦我们有这样的值，`while`循环就不应再循环。如果用户没有输入有效的整数，向用户打印出适当的消息。不要打印原始异常消息或堆栈跟踪。这样，我们坚持要求用户输入一个整数，并且不会放弃，直到我们得到一个整数。
- en: Using this strategy, get three whole numbers in and sum them up. The program
    should ask again and again if you do not provide a valid whole number for any
    of the inputs. Print the result to the console.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种策略，输入三个整数并将它们相加。如果您没有为任何输入提供有效的整数，程序应该一遍又一遍地询问。将结果打印到控制台。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 365.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在365页找到。
- en: Exception Sources
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常来源
- en: When an exceptional case occurs in code, an exception object is thrown by the
    source of the problem, which is in turn caught by one of the callers in the call
    stack. The exception object is an instance of one of the exception classes. There
    are many such classes, which represent various types of problems. In this topic,
    we will take a look at different types of exceptions, get to know some of the
    exception classes from Java libraries, learn how to create our own exceptions,
    and see how to throw them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码中出现异常情况时，问题源会抛出一个异常对象，然后被调用堆栈中的一个调用者捕获。异常对象是异常类的一个实例。有许多这样的类，代表各种类型的问题。在本主题中，我们将看看不同类型的异常，了解一些来自Java库的异常类，学习如何创建自己的异常，以及如何抛出它们。
- en: 'In the previous topic, we first played with `IOException`. Then, in the activity,
    we played with `NumberFormatException`. There was a difference between these two
    exceptions. The IDE would force us to handle `IOException` and would not compile
    our code otherwise. However, it did not care whether we caught `NumberFormatException`
    or not, it would still compile and run our code. The difference was in the class
    hierarchy. While both of them are descendants of the `Exception` class, `NumberFormatException`
    is a descendant of `RuntimeException`, a subclass of `Exception`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们首先使用了`IOException`。然后，在活动中，我们使用了`NumberFormatException`。这两个异常之间有所不同。IDE会强制我们处理`IOException`，否则代码将无法编译。然而，它并不在乎我们是否捕获了`NumberFormatException`，它仍然会编译和运行我们的代码。区别在于类层次结构。虽然它们都是`Exception`类的后代，但`NumberFormatException`是`RuntimeException`的后代，是`Exception`的子类：
- en: '![Figure 9.1: Hierarchy of the RuntimeException class](img/C09581_09_011.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：RuntimeException类的层次结构](img/C09581_09_011.jpg)'
- en: 'Figure 9.1: Hierarchy of the RuntimeException class'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：RuntimeException类的层次结构
- en: The preceding figure shows a simple class hierarchy. Any class that is a descendant
    of `Throwable` can be thrown and caught as an exception. However, Java provides
    a special treatment for the descendants of `Error` and `RuntimeException` classes.
    We'll explore these further in the upcoming sections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个简单的类层次结构。任何是`Throwable`的后代类都可以作为异常抛出和捕获。然而，Java对`Error`和`RuntimeException`类的后代类提供了特殊处理。我们将在接下来的部分中进一步探讨这些。
- en: Checked Exceptions
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已检查异常
- en: 'Any descendant of `Throwable` that is not a descendant of `Error` or `RuntimeException`
    falls in the category of checked exceptions. For example: `IOException`, which
    we used in the previous topic, is a checked exception. The IDE forced us to either
    catch it or to specify that we throw it in our function.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throwable`的任何后代，如果不是`Error`或`RuntimeException`的后代，都属于已检查异常的范畴。例如：`IOException`，我们在上一个主题中使用过的，就是一个已检查异常。IDE强制我们要么捕获它，要么在我们的函数中指定抛出它。'
- en: To be able to throw a caught exception, your function has to specify that it
    throws the exception.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够抛出已捕获的异常，您的函数必须指定它抛出异常。
- en: Throwing a Checked Exception
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出已检查异常
- en: 'Create a new project and paste the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，并粘贴以下代码：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we created a function and wanted it to throw an `IOException`. However,
    our IDE will not let us do that because this is a checked exception. Here is the
    type hierarchy of it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个函数，并希望它抛出`IOException`。然而，我们的IDE不会让我们这样做，因为这是一个已检查的异常。以下是它的类型层次结构：
- en: '![Figure 9.2: Hierarchy of the IOException class](img/C09581_09_021.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：IOException类的层次结构](img/C09581_09_021.jpg)'
- en: 'Figure 9.2: Hierarchy of the IOException class'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.2：IOException类的层次结构
- en: 'Since `IOException` is a descendant of `Exception`, it is a checked exception
    and every function that throws a checked exception has to specify it. Move the
    caret to the error line, hit *Alt* + *Enter*, and select "**Add exception to method
    signature**". Here''s how the code will look:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`IOException`是`Exception`的后代，它是一个已检查的异常，每个抛出已检查异常的函数都必须指定它。将光标移动到错误行，按下*Alt*
    + *Enter*，然后选择“**将异常添加到方法签名**”。代码将如下所示：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that our code still has a problem. We will continue dealing with it in
    the next exercise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的代码仍然存在问题。我们将在下一个练习中继续处理它。
- en: Another requirement of checked exceptions is that if you call a method that
    specifies a checked exception, you have to either catch the exception or specify
    that you also throw that exception. This is also known as "the catch or specify
    rule."
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 已检查异常的另一个要求是，如果你调用指定了已检查异常的方法，你必须要么捕获异常，要么指定你也抛出该异常。这也被称为“捕获或指定规则”。
- en: 'Exercise 39: Working with catch or Specify'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习39：使用catch或指定
- en: 'Let''s have a look at throwing checked exceptions and calling methods that
    throw them. You should have the project already open:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看抛出已检查异常和调用抛出它们的方法。你应该已经打开了这个项目：
- en: 'If you do not have the preceding example in your IDE, create a project and
    add the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的IDE中没有前面的示例，请创建一个项目并添加以下代码：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that the line with `myFunction()` is underlined in red, because this
    line is calling a checked exception and we are not doing anything about that potential
    exception. We either need to specify that we also throw it, or we need to catch
    and handle it. IntelliJ can help us do either of these. Move the caret over the
    `myFunction1()` line and hit *Alt* + *Enter*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，带有`myFunction()`的那一行被标记为红色下划线，因为这一行调用了一个已检查的异常，而我们没有对潜在的异常做任何处理。我们需要指定我们也抛出它，或者我们需要捕获和处理它。IntelliJ可以帮助我们做这两件事中的任何一件。将光标移动到`myFunction1()`行上，然后按*Alt*
    + *Enter*。
- en: 'Select **Add exception to method signature**, to successfully specify that
    we throw the exception. Here is the code that this generates:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**将异常添加到方法签名**，以成功指定我们抛出异常。这是它生成的代码：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, this compiles and runs just fine. Now undo (*Ctrl* + *Z*) and
    hit *Alt*+ *Enter* again to get the options back.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个编译和运行都很顺利。现在撤销（*Ctrl* + *Z*）然后再次按*Alt*+ *Enter*来获取选项。
- en: 'Alternatively, if we select **Surround with try/catch**, we''ll successfully
    catch the exception. Here is the code that it generates:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果我们选择**用try/catch包围**，我们将成功捕获异常。这是它生成的代码：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While this compiles and runs, remember that simply printing information about
    it is not the greatest way to handle an exception.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个编译和运行，但记住，简单地打印有关它的信息并不是处理异常的最佳方式。
- en: In these exercises, we saw how to throw checked exceptions and how to call methods
    that throw them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，我们看到了如何抛出已检查的异常以及如何调用抛出它们的方法。
- en: Unchecked Exceptions
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未检查异常
- en: 'Recall the top of the exception class hierarchy:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾异常类层次结构的顶部：
- en: '![Figure 9.3: Hierarchy of the RuntimeException class](img/C09581_09_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：RuntimeException类的层次结构](img/C09581_09_03.jpg)'
- en: 'Figure 9.3: Hierarchy of the RuntimeException class'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.3：RuntimeException类的层次结构
- en: Here, the exception classes that are descendants of `RuntimeException` are called
    runtime exceptions. The descendants of `Error` are called errors. Both of these
    are called unchecked exceptions. They do not need to be specified, and if they
    are specified, they do not need to be caught.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`RuntimeException`的后代被称为运行时异常。`Error`的后代被称为错误。这两者都被称为未检查异常。它们不需要被指定，如果被指定了，也不需要被捕获。
- en: Unchecked exceptions represent things that may happen more unexpectedly compared
    to checked exceptions. The assumption is that you have the option to ensure that
    they will not be thrown; therefore, they do not have to be expected. However,
    you should do your best to handle them if you have a suspicion that they may be
    thrown.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查异常代表可能发生的事情，与已检查异常相比更加意外。假设你有选择确保它们不会被抛出；因此，它们不必被期望。但是，如果你怀疑它们可能被抛出，你应该尽力处理它们。
- en: 'Here is the hierarchy of NumberFormatException:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: NumberFormatException的层次结构如下：
- en: '![Figure 9.4: Hierarchy of the NormalFormatException class](img/C09581_09_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：NormalFormatException类的层次结构](img/C09581_09_04.jpg)'
- en: 'Figure 9.4: Hierarchy of the NormalFormatException class'
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.4：NormalFormatException类的层次结构
- en: Since it is a descendant of `RuntimeException`, it is a runtime exception, therefore
    an unchecked exception.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是`RuntimeException`的后代，因此它是运行时异常，因此是未检查异常。
- en: 'Exercise 40: Using Methods That Throw Unchecked Exceptions'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习40：使用抛出未检查异常的方法
- en: 'In this exercise, we will write some code that throws a runtime exception:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一些会抛出运行时异常的代码：
- en: 'Create a project in IntelliJ and paste in the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ中创建一个项目，并粘贴以下代码：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that this code is trying to parse a string as an integer, but the string
    clearly does not contain an integer. As a result, a `NumberFormatException` will
    be thrown. However, since this is an unchecked exception, we do not have to catch
    or specify it. This is what we see when we run the code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码试图将一个字符串解析为整数，但显然该字符串不包含整数。因此，将抛出`NumberFormatException`。但是，由于这是一个未检查的异常，我们不必捕获或指定它。当我们运行代码时，就会看到这种情况：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since we did not catch it, the `NumberFormatException` got thrown from the
    `main` function and crashed the application. Instead, we could catch it and print
    a message about it as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有捕获它，`NumberFormatException`从`main`函数中抛出并使应用程序崩溃。相反，我们可以捕获它并打印关于它的消息，如下所示：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, when we run the code, we get an output that shows that we are aware of
    the situation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行代码时，我们会得到一个输出，显示我们意识到了这种情况：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although catching unchecked exceptions is optional, you should make sure you
    catch them in order to create code that is complete.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管捕获未检查异常是可选的，但你应该确保捕获它们，以便创建完整的代码。
- en: It's practically the same case for errors, which are descendants of the `Error`
    class. In the following section, we talk about the semantic differences between
    runtime exceptions and errors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误来说，情况几乎是一样的，它们是`Error`类的后代。在接下来的部分中，我们将讨论运行时异常和错误之间的语义差异。
- en: Exception Class Hierarchy
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常类层次结构
- en: Any object that can be thrown as an exception is an instance of a class that
    is derived from the `Error` or `RuntimeException` is treated as an unchecked exception,
    while any other class that derives from `Throwable` is a checked exception. Therefore,
    which exception class you use determines the mechanics (checked versus unchecked)
    of exception handling.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以作为异常抛出的对象都是从`Error`或`RuntimeException`派生的类的实例，被视为未经检查的异常，而从`Throwable`派生的任何其他类都是经过检查的异常。因此，您使用哪个异常类决定了异常处理的机制（经过检查与未经检查）。
- en: 'Beyond the mechanics of exception handling, the choice of exception class also
    carries semantic information. For example: if a library method encounters a case
    in which a file that was supposed to be in the hard drive is missing, it would
    throw an instance of `FileNotFoundException`. If there was a problem in a string
    that was supposed to contain a numeric value, the method that you give that string
    to would throw a `NumberFormatException`. The Java class library contains a number
    of exception classes that fit most unexpected situations. The following is a subset
    of classes in this hierarchy:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常处理的机制之外，异常类的选择还携带语义信息。例如：如果库方法遇到一个应该在硬盘上的文件丢失的情况，它会抛出一个`FileNotFoundException`的实例。如果一个字符串中应该包含一个数值，但出现了问题，您给出该字符串的方法会抛出一个`NumberFormatException`。Java类库包含了许多适合大多数意外情况的异常类。以下是此层次结构中的类的一个子集：
- en: '![Figure 9.5: Subset of classes in hierarchy](img/C09581_09_05.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：层次结构中的类子集](img/C09581_09_05.jpg)'
- en: 'Figure 9.5: Subset of classes in hierarchy'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：层次结构中的类子集
- en: If you read through this list, you will notice that there are a lot of exception
    types for various occasions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读此列表，您会注意到各种场合有很多异常类型。
- en: Browsing the Exception Hierarchy
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览异常层次结构
- en: 'In IntelliJ, open any Java project or create a new one. Anywhere in your code,
    create a `Throwable` reference variable as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ中，打开任何Java项目或创建一个新项目。在您的代码中的任何地方，创建一个`Throwable`引用变量如下：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now move the caret over `Throwable` and press `Ctrl` + `H`. The hierarchy window
    should open with the `Throwable` class in focus. It should look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将光标移动到`Throwable`上，然后按`Ctrl` + `H`。层次结构窗口应该打开，并将`Throwable`类放在焦点位置。它应该看起来像这样：
- en: '![Figure 9.6: Hierarchy of Throwable class](img/C09581_09_06.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6：Throwable类的层次结构](img/C09581_09_06.jpg)'
- en: 'Figure 9.6: Hierarchy of Throwable class'
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：Throwable类的层次结构
- en: 'Now expand `Error` and `Exception`, and read through the list of classes. These
    are various throwable classes defined in various libraries that your code has
    access to. As you can see, there is quite a broad list of exceptions to choose
    from. Next to each exception class, there is the package that it belongs to in
    parentheses. As a rule of thumb, if you are going to throw an exception yourself,
    you should try to use exceptions that are in the libraries that you are also using.
    For example: importing `com.sun.jmx.snmp.IPAcl` just so that you can use the `ParseException`
    defined in it is not a good thing to do.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在展开`Error`和`Exception`，并浏览类列表。这些是各种可抛出的类，定义在您的代码可以访问的各种库中。正如您所看到的，有相当广泛的异常列表可供选择。在每个异常类旁边，用括号括起来的是它所属的包。作为一个经验法则，如果您要自己抛出异常，应该尽量使用您也在使用的库中的异常。例如：仅仅为了使用其中定义的`ParseException`而导入`com.sun.jmx.snmp.IPAcl`是不好的做法。
- en: Now you have a better idea about the existing exception classes that are in
    the Java Class Library and what your choice of exception class communicates to
    the users of your code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Java类库中存在的异常类有了更好的了解，以及您选择的异常类对代码用户传达的信息。
- en: Throwing Exceptions and Custom Exceptions
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常和自定义异常
- en: As a programmer, you will write methods that you or others will call. Inevitably,
    there will be things that go wrong in your code in undesirable situations. You
    should throw exceptions in those cases that are instances of appropriate exception
    classes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，您将编写您或其他人将调用的方法。不可避免地，在您的代码中会出现不希望的情况。在这些情况下，您应该抛出适当异常类的实例。
- en: To throw an exception, first, you need to create an instance of a class that
    is an ancestor of `Throwable`. Then, you populate that instance and use the `throw`
    keyword to throw it. Then, the throwable instance will travel up the call stack
    and pop entries until it meets a `try`/`catch` block with a catch statement that
    matches the type of this `Throwable` or is a subclass of it. The throwable is
    given to that catch block as the caught exception, and the execution continues
    from there.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要抛出异常，首先需要创建一个是`Throwable`祖先类的实例。然后，填充该实例并使用`throw`关键字将其抛出。然后，可抛出实例将沿着调用堆栈向上移动并弹出条目，直到遇到一个带有匹配此`Throwable`类型或其子类的catch语句的`try`/`catch`块。可抛出实例将作为捕获的异常给该catch块，并从那里继续执行。
- en: 'Exercise 41: Throwing an Exception'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习41：抛出异常
- en: 'In this exercise, we will use existing exception classes for our exceptions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用现有的异常类来抛出异常：
- en: 'Create a new Java project and add the following code, which has a function
    that expects a string of length one that contains a single digit and prints it.
    If the string is empty, it will throw an `IllegalArgumentException`. If the string
    contains anything other than a single digit, it will throw a `NumberFormatException`.
    Since these are unchecked exceptions, we did not have to specify them:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Java项目，并添加以下代码，其中有一个函数期望一个包含单个数字的长度为一的字符串并打印它。如果字符串为空，它将抛出一个`IllegalArgumentException`。如果字符串包含除了单个数字以外的任何内容，它将抛出一个`NumberFormatException`。由于这些是未经检查的异常，我们不必指定它们：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we will call this function and handle the exceptions that it throws. We
    will intentionally call another function that calls this, and will have catch
    blocks in two different places to demonstrate exception propagation. The full
    code will look as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将调用此函数并处理它抛出的异常。我们故意调用另一个调用此函数的函数，并在两个不同的地方有catch块，以演示异常传播。完整的代码如下所示：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the `main()` method as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main()`方法如下：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that, from `main`, we call `runDigits`, which in turn calls `useDigitString`.
    The main function catches `IllegalArgumentException` and `runDigits` catches `NumberFormatException`.
    Although we throw all the exceptions in `useDigitString`, they are caught in different
    places.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从`main`中调用`runDigits`，然后调用`useDigitString`。主函数捕获`IllegalArgumentException`，`runDigits`捕获`NumberFormatException`。尽管我们在`useDigitString`中抛出了所有异常，但它们被不同的地方捕获。
- en: 'Exercise 42: Creating Custom Exception Classes'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习42：创建自定义异常类
- en: 'In the previous exercise, we used existing exception classes for our exceptions.
    `NumberFormatException` sounded appropriate but `IllegalArgumentException` was
    a bit of an odd choice. Also, they are both unchecked exceptions; perhaps we would
    like to have checked ones instead. Therefore, existing exception classes are not
    suitable for our needs. We can create our own exception classes in this situation.
    Let''s continue on the same course as the previous exercise:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的练习中，我们为我们的异常使用了现有的异常类。`NumberFormatException`听起来合适，但`IllegalArgumentException`有点奇怪。而且，它们都是未经检查的异常；也许我们想要有检查的异常。因此，现有的异常类不适合我们的需求。在这种情况下，我们可以创建自己的异常类。让我们继续沿着上一个练习的路线：
- en: 'Let''s say that we are happy with `NumberFormatException`, but we want an `EmptyInputException`
    that is a checked exception. We can extend `Exception` to do that:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们对`NumberFormatException`感到满意，但我们想要一个是检查的`EmptyInputException`。我们可以扩展`Exception`来实现这一点：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we had extra information to place in this exception, we could have added
    fields and a constructor for that purpose. However, in our case, we just want
    to signal that the input was empty; no other information is necessary for the
    caller. Now let''s fix our code so that our function throws `EmptyInputException`
    instead of `IllegalArgumentException`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有额外的信息要放入此异常中，我们可以为此添加字段和构造函数。但是，在我们的情况下，我们只想表明输入为空；对于调用者来说，不需要其他信息。现在让我们修复我们的代码，使我们的函数抛出`EmptyInputException`而不是`IllegalArgumentException`：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the `main()` method as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加`main()`方法：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Notice that this made our code much simpler—we did not even have to write a
    message, as the name of the exception clearly communicates the problem. Here is
    the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这使我们的代码变得简单得多——我们甚至不必写消息，因为异常的名称清楚地传达了问题。以下是输出：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now you know how to throw exceptions and create your own exception class if
    existing exception classes are insufficient.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何抛出异常并创建自己的异常类（如果现有的异常类不够用）。
- en: 'Activity 37: Writing Custom Exceptions in Java.'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动37：在Java中编写自定义异常。
- en: We will write a program for an admission system for a roller coaster ride. For
    each visitor, we will get their name and age from the keyboard. Then, we will
    print out the name of the visitor and that they are riding the roller coaster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为过山车乘坐的入场系统编写一个程序。对于每位游客，我们将从键盘获取他们的姓名和年龄。然后，我们将打印出游客的姓名以及他们正在乘坐过山车。
- en: 'Since roller coasters are only for adults, we will reject visitors that are
    younger than 15 years old. We will handle the rejection using a custom exception:
    `TooYoungException`. This exception object will contain the name and the age of
    the visitor. When we catch the exception, we will print an appropriate message
    that explains why they were rejected.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过山车只适合成年人，我们将拒绝年龄小于15岁的游客。我们将使用自定义异常`TooYoungException`来处理拒绝。此异常对象将包含游客的姓名和年龄。当我们捕获异常时，我们将打印一个适当的消息，解释为什么他们被拒绝。
- en: We will continue to accept visitors until the name is empty.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续接受游客，直到姓名为空为止。
- en: 'To achieve this, perform the following steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请执行以下步骤：
- en: Create a new class and enter `RollerCoasterWithAge` as the class name.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类，并输入`RollerCoasterWithAge`作为类名。
- en: Also create an exception class, `TooYoungException`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建一个异常类`TooYoungException`。
- en: Import the `java.util.Scanner` package.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`java.util.Scanner`包。
- en: In `main()`, create an infinite loop.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，创建一个无限循环。
- en: Get the user's name. If it is an empty string, break out of the loop.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的姓名。如果是空字符串，则跳出循环。
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的年龄。如果低于15岁，则抛出一个`TooYoungException`，包含姓名和年龄。
- en: Print the name as "John is riding the roller coaster".
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将姓名打印为"John正在乘坐过山车"。
- en: Catch the exception and print an appropriate message for it.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获异常并为其打印适当的消息。
- en: Run the main program.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行主程序。
- en: 'The output should be similar to the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 366.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第366页找到。
- en: Exception Mechanics
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常机制
- en: In the previous topics, we threw and caught exceptions and got a feel for how
    exceptions work. Now let's revisit the mechanics to make sure we got everything
    right.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的主题中，我们抛出并捕获了异常，并对异常的工作原理有了一定的了解。现在让我们重新访问机制，以确保我们做对了一切。
- en: How try/catch Works
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`try/catch`的工作原理'
- en: 'The `try`/`catch` statement has two blocks: the `try` block and the `catch`
    block, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch`语句有两个块：`try`块和`catch`块，如下所示：'
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `try` block is where your main execution path code goes. You optimistically
    write your program here. If an exception happens in any of the lines in the `try`
    block, the execution stops at that line and jumps to the `catch` block:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块是您的主要执行路径代码所在的地方。您可以在这里乐观地编写程序。如果`try`块中的任何一行发生异常，执行将在该行停止并跳转到`catch`块：'
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `catch` block catches throwables if they can be assigned to the exception
    reference it contains (`Exception e`, in this case). So, if you have an exception
    class here that is high up in the exception hierarchy (such as `Exception`), it
    will catch all exceptions. This will not catch errors, which is usually what you
    want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块捕获可分配给其包含的异常引用（在本例中为`Exception e`）的可抛出对象。因此，如果在此处有一个在异常层次结构中较高的异常类（如`Exception`），它将捕获所有异常。这不会捕获错误，这通常是您想要的。'
- en: If you want to be more specific about the types of exceptions that you catch,
    you can provide an exception class that is lower in the hierarchy.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更具体地捕获异常的类型，可以提供一个在层次结构中较低的异常类。
- en: 'Exercise 43: Exception Not Caught Because It Cannot Be Assigned to a Parameter
    in the catch Block'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习43：异常未被捕获，因为它不能分配给catch块中的参数
- en: 'Create a new project and add the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目并添加以下代码：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that this code will not even compile. The code throws an exception, but
    the catch clause expects an `InstantiationException`, which is a descendant of
    `Exception`, to which exception instances cannot be assigned. Therefore, the exception
    is neither caught, nor thrown.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码甚至无法编译。代码抛出异常，但catch子句期望一个`InstantiationException`，它是`Exception`的一个后代，不能分配给异常实例。因此，异常既不被捕获，也不被抛出。
- en: 'Specify an exception so that the code can compile as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个异常，以便代码可以编译如下：
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we run the code, we see that we are not able to catch the exception that
    we threw:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们发现我们无法捕获我们抛出的异常：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Sometimes, you catch one type of a specific exception, but your code can throw
    other types of exceptions as well. You can provide multiple catch blocks in this
    case. The exception types being caught can be in different places in the class
    hierarchy. The first catch block of whose parameter the thrown exception can be
    assigned to is executed. So, if two exception classes have an ancestor relationship,
    the descendant's catch clause has to go before the ancestor's catch clause; otherwise,
    the ancestor would catch the descendant's exceptions as well.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您捕获特定异常的一种类型，但您的代码也可能抛出其他类型的异常。在这种情况下，您可以提供多个catch块。被捕获的异常类型可以在类层次结构的不同位置。被抛出的异常可以分配给其参数的第一个catch块被执行。因此，如果两个异常类具有祖先关系，那么后代的catch子句必须在祖先的catch子句之前；否则，祖先也会捕获后代的异常。
- en: 'Exercise 44: Multiple catch Blocks and Their Order'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习44：多个catch块及其顺序
- en: 'In this exercise, we will have a look at multiple catch blocks in a program
    and their order of execution. Let''s continue with the previous exercise:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看一下程序中的多个catch块及其执行顺序。让我们继续上一个练习：
- en: 'Go back to the initial form of the code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回代码的初始形式：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When we hit *Alt* + *Enter* on `Exception` to add a catch clause for it, it
    is added after the existing one, which is correct:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在`Exception`上按*Alt* + *Enter*添加一个catch子句时，它会在现有的catch子句之后添加，这是正确的：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the thrown exception is an `InstantiationException`, it will be caught by
    the first catch. Otherwise, if it is any other exception, it will be caught by
    the second. Let''s try reordering the catch blocks:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抛出的异常是`InstantiationException`，它将被第一个catch捕获。否则，如果是其他任何异常，它将被第二个catch捕获。让我们尝试重新排列catch块：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now our code will not even compile because instances of `InstantiationException`
    can be assigned to `Exception e`, and they will be caught by the first catch block.
    The second block will never be called—ever. The IDE is smart to catch this problem
    for us.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码甚至无法编译，因为`InstantiationException`的实例可以分配给`Exception e`，并且它们将被第一个catch块捕获。第二个块永远不会被调用。IDE很聪明地为我们解决了这个问题。
- en: Another property of exceptions is that they travel up the call stack. Every
    function that is called essentially returns the execution to its caller, until
    one of them is able to catch the exception.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的另一个属性是它们沿着调用堆栈传播。每个被调用的函数本质上都会将执行返回给它的调用者，直到其中一个能够捕获异常。
- en: 'Exercise 45: Exception Propagation'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习45：异常传播
- en: 'In this exercise, we will go through an example in which we have multiple functions
    calling one another:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过一个例子来看一下多个函数相互调用的情况：
- en: 'We throw the exception from the deepest method, which is caught by one of the
    methods higher in the call stack:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从最深的方法中抛出异常，这个异常被调用堆栈中更高的一个方法捕获：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the `main()` method as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main()`方法如下：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When we run the code, we get this output:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们得到以下输出：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that method 2 and method 3 do not run to completion, while method 1 and
    `main` do. Method 2 throws the exception; method 3 does not catch it and lets
    it propagate up. Finally, method 1 catches it. Method 2 and method 3 abruptly
    return the execution to the method higher in the call stack. Since method 1 and
    main do not let an exception propagate up, they are able to run to completion.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方法2和方法3没有运行到完成，而方法1和`main`运行到完成。方法2抛出异常；方法3没有捕获它，而是让它传播上去。最后，方法1捕获它。方法2和方法3突然返回到调用堆栈中更高的方法。由于方法1和main不让异常传播上去，它们能够运行到完成。
- en: There is one more feature of the catch block that we should talk about. Let's
    say we would like to catch two specific exceptions but not others, but we will
    do the exact same thing in their catch blocks. In this case, we are able to combine
    the catch blocks of these exceptions with a pipe character. This feature was introduced
    in Java 7 and will not work in Java 6 and below.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: catch块的另一个特性是我们应该谈论的。假设我们想要捕获两个特定的异常，但不捕获其他异常，但我们将在它们的catch块中做完全相同的事情。在这种情况下，我们可以使用管道字符组合这些异常的catch块。这个特性是在Java
    7中引入的，在Java 6及以下版本中不起作用。
- en: Multiple Exception Types in One Block
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个块中的多个异常类型
- en: We have dealt with a single type of exception in one block of code. Now we will
    have a look at multiple exception types in one block.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在一段代码中处理了单一类型的异常。现在我们将看一下一段代码中的多个异常类型。
- en: 'Consider the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we have a catch block that can catch either an `IOException` or an `ArithmeticException`
    using the catch block with multiple exception types. When we run the code, we
    see that the `ArithmeticException` that we caused is successfully caught:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个catch块，可以使用多个异常类型的catch块捕获`IOException`或`ArithmeticException`。当我们运行代码时，我们看到我们引起的`ArithmeticException`被成功捕获：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the exception was an `IOException`, it would be caught the same way.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常是`IOException`，它将以相同的方式被捕获。
- en: Now you know more about the mechanics of a `try`/`catch` block, exception propagation,
    multiple catch blocks, and multiple exceptions in a block.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你更了解`try`/`catch`块的机制、异常传播、多个catch块和块中的多个异常。
- en: 'Activity 38: Dealing with Multiple Exceptions in a Block'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动38：处理块中的多个异常
- en: Remember that we wrote a program for an admission system for a roller coaster
    ride earlier? This time, we will also take the visitor's height into account.
    For each visitor, we will get their name, age, and height from the keyboard. Then,
    we will print out the name of the visitor and that they are riding the roller
    coaster.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前为过山车乘坐的入场系统编写了一个程序吗？这一次，我们还将考虑访客的身高。对于每位访客，我们将从键盘获取他们的姓名、年龄和身高。然后，我们将打印出访客的姓名和他们正在乘坐过山车。
- en: 'Since roller coasters are only for adults of a certain height, we will reject
    visitors that are younger than 15 years old or shorter than 130 cm. We will handle
    the rejection using custom exceptions: `TooYoungException` and `TooShortException`.
    These exception objects will contain the name and the relevant property of the
    person (age or height). When we catch the exception, we will print an appropriate
    message that explains why they were rejected.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过山车只适合特定身高的成年人，我们将拒绝15岁以下或低于130厘米的访客。我们将使用自定义异常`TooYoungException`和`TooShortException`来处理拒绝。这些异常对象将包含人的姓名和相关属性（年龄或身高）。当我们捕获异常时，我们将打印一个适当的消息，解释为什么他们被拒绝。
- en: We will continue to accept visitors until the name is empty.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续接受访客，直到姓名为空为止。
- en: 'To achieve this, perform the following steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，执行以下步骤：
- en: Create a new class and enter `RollerCoasterWithAgeAndHeight` as the class name.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类，并输入`RollerCoasterWithAgeAndHeight`作为类名。
- en: Also create two exception classes, `TooYoungException` and `TooShortException`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建两个异常类，`TooYoungException`和`TooShortException`。
- en: Import the `java.util.Scanner` package.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`java.util.Scanner`包。
- en: In `main()`, create an infinite loop.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，创建一个无限循环。
- en: Get the user's name. If it is an empty string, break out of the loop.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的姓名。如果是空字符串，跳出循环。
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的年龄。如果低于15，抛出一个带有这个名字和年龄的`TooYoungException`。
- en: Get the user's height. If it is lower than 130, throw a `TooShortException`
    with this name and age.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的身高。如果低于130，抛出一个带有这个名字和年龄的`TooShortException`。
- en: Print the name as "John is riding the roller coaster."
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将姓名打印为"John正在乘坐过山车"。
- en: Catch the two types of exceptions separately. Print appropriate messages for
    each.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别捕获两种类型的异常。为每种情况打印适当的消息。
- en: Run the main program.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行主程序。
- en: 'The output should be similar to the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 368.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第368页找到。
- en: What Are We Supposed to Do in a Catch Block?
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在catch块中我们应该做什么？
- en: When you catch an exception, you are supposed to do something about it. The
    ideal case is that you can find a strategy that recovers from the error and can
    resume the execution. However, sometimes you cannot do this and may choose to
    specify in your function that you let this exception propagate using a throws
    statement. We saw these in the previous topic.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当你捕获异常时，你应该对它做些什么。理想情况下，你可以找到一种从错误中恢复并恢复执行的策略。然而，有时你无法做到这一点，可能会选择在你的函数中指定让这个异常使用throws语句传播。我们在上一个主题中看到了这些。
- en: 'However, in some cases, you may be in a position to add more information to
    the exception that you will propagate to your caller. For example: let''s say
    that you called a method to parse the user''s age and it threw a `NumberFormatException`.
    If you simply let it propagate to your caller, your caller will not know that
    this was related to the user''s age. Perhaps adding this information to the exception
    before propagating it up would be beneficial. You can do this by catching the
    exception, wrapping it in another exception as the cause, and throwing that exception
    to your caller. This is also called "**chaining exceptions**."'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能有能力向你的调用者添加更多信息到异常中。例如：假设你调用一个方法来解析用户的年龄，它抛出了一个`NumberFormatException`。如果你简单地让它传播给你的调用者，你的调用者将不知道这与用户的年龄有关。也许在将异常传播给你的调用者之前，添加这些信息会有益处。你可以通过捕获异常，将其包装在另一个异常中作为原因，并将该异常抛出给你的调用者来实现这一点。这也被称为“链接异常”。
- en: 'Exercise 46: Chained Exceptions'
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习46：链接异常
- en: 'In this exercise, we will have a look at the workings of chained exceptions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看一下链接异常的工作原理：
- en: 'Create a new project and add this code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目并添加这段代码：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Notice that trying to parse "fifty five" as an integer will result in a `NumberFormatException`.
    We are not catching it and letting it propagate. Here is the output we get as
    a result:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试将"fifty five"解析为整数将导致`NumberFormatException`。我们没有捕获它，而是让它传播。以下是我们得到的输出结果：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that the exception's output does not give any indication that this problem
    was related to the user's age.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，异常的输出没有任何迹象表明这个问题与用户的年龄有关。
- en: 'Catch the exception and chain it to add this information about age:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获异常并链接它以添加关于年龄的信息：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the `main()` method as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤添加`main()`方法：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, here is the output that we get:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是我们得到的输出：
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that this contains information about the age. This is an exception that
    has another exception as the cause. If you want, you can get it using the `e.getCause()`
    method and act accordingly. When simply logged, it prints the exception details
    in order.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这包含有关年龄的信息。这是一个异常，它有另一个异常作为原因。如果你愿意，你可以使用`e.getCause()`方法获取它，并相应地采取行动。当简单记录时，它按顺序打印异常详细信息。
- en: finally Block and Their Mechanics
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后的块及其机制
- en: The `try`/`catch` block is very useful in catching exceptions. However, here
    is a common scenario in which it may have some shortcomings. In our code, we would
    like to acquire some resources. We are responsible for releasing the resources
    when we are done with them. However, a naive implementation may result in a file
    being left open when an exception happens.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch`块在捕获异常时非常有用。但是，在这里有一个常见的情况，它可能有一些缺点。在我们的代码中，我们想获取一些资源。我们负责在完成后释放资源。但是，一个天真的实现可能会导致在发生异常时文件被保持打开状态。'
- en: 'Exercise 47: Leaving a File Open as a Result of an Exception'
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习47：由于异常而保持文件打开
- en: 'In this exercise, we will deal with the `finally` block:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将处理`finally`块：
- en: 'Let''s say we will read the first line of a file and print it. We can code
    this as follows:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们将读取文件的第一行并将其打印出来。我们可以将其编码如下：
- en: '[PRE72]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add the `main()` method as follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main（）`方法如下：
- en: '[PRE73]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note that the `useTheFile` function raises an exception before we had a chance
    to close the file. When we run it, we get this result:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`useTheFile`函数在我们关闭文件之前引发了异常。当我们运行它时，我们会得到这个结果：
- en: '[PRE74]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that we do not see a "closed the file" output because the execution could
    never get past the `useTheFile()` call. After catching the exception, even though
    we do not have access to the `BufferedReader` reference, the operating system
    is still holding the file resources. We just leaked a resource. If we do this
    many times in a loop, our application may crash.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有看到“关闭文件”输出，因为执行永远无法通过`useTheFile（）`调用。捕获异常后，即使我们无法访问`BufferedReader`引用，操作系统仍然持有文件资源。我们刚刚泄漏了一个资源。如果我们在循环中多次执行此操作，我们的应用程序可能会崩溃。
- en: 'You may try to devise various solutions to this resource-leaking problem. For
    example: you may duplicate the file-closing code and paste it to the catch block.
    Now you have it both in the `try` and in the `catch` blocks. If you have multiple
    `catch` blocks, all of them should have it as follows:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以尝试设计各种解决此资源泄漏问题的解决方案。例如：您可以复制文件关闭代码并将其粘贴到catch块中。现在您在`try`块和`catch`块中都有它。如果有多个`catch`块，所有这些都应该如下所示：
- en: '[PRE75]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The preceding code is correct, but it has code duplication, which makes it
    hard to maintain. Instead, you may think that you can close the file after the
    `catch` block in one single place:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码是正确的，但它存在代码重复，这使得难以维护。相反，您可能认为可以在一个地方的`catch`块之后关闭文件：
- en: '[PRE76]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: While this is almost correct, it is missing one possibility. Note that we are
    throwing an exception in the first `catch` block now. That will bypass the code
    after the catch blocks and the file will still be left open.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这几乎是正确的，但它缺少一个可能性。请注意，我们现在在第一个`catch`块中抛出异常。这将绕过catch块后面的代码，文件仍将保持打开状态。
- en: 'Therefore, what we need to do is to ensure that the file closing code will
    run no matter what happens. The `try` / `catch`/ `finally` block is the solution
    to this problem. It is like the `try`/ `catch` block, with an extra finally block
    that executes after we are done with the block, no matter what happens. Here is
    the solution with the `finally` block:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要确保无论发生什么，文件关闭代码都将运行。`try`/`catch`/`finally`块是这个问题的解决方案。它就像`try`/`catch`块，有一个额外的finally块，在我们完成块后执行，无论发生什么。以下是带有`finally`块的解决方案：
- en: '[PRE77]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This new version closes the file whether there was an exception raised or not,
    or if another exception was raised after an exception was originally caught. In
    each case, the file-closing code in the finally block is executed and the file
    resource is released by the operating system appropriately.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本关闭文件，无论是否引发异常，或者在最初捕获异常后引发另一个异常。在每种情况下，finally块中的文件关闭代码都会被执行，并且文件资源会被操作系统适当释放。
- en: There is still one problem with this code. The problem is, an exception might
    be raised while we are opening the file in the `BufferedReader` constructor, and
    the `br` variable may remain null. Then, when we try to close the file, we will
    dereference a null variable, which will create an exception.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还有一个问题。问题是，在`BufferedReader`构造函数中打开文件时可能会引发异常，`br`变量可能仍然为空。然后，当我们尝试关闭文件时，我们将取消引用一个空变量，这将创建一个异常。
- en: 'To avoid this problem, we need to ignore `br` if it is null. The following
    is the complete code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要忽略`br`如果它是空的。以下是完整的代码：
- en: '[PRE78]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Activity 39: Working with Multiple Custom Exceptions'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动39：使用多个自定义异常处理
- en: Remember that we wrote a program for an admission system for a roller coaster
    ride that verified the visitors' age and heights. This time, we will assume that
    we have to escort every applicant outside of the roller-coaster area afterward,
    whether they ride the roller coaster or not.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们为过山车乘坐的入场系统编写了一个程序，该程序验证了访问者的年龄和身高。这一次，我们将假设我们必须在过山车区域之外护送每个申请人，无论他们是否乘坐过山车。
- en: We will admit visitors one by one. For each visitor, we will get their name,
    age, and height from the keyboard. Then, we will print out the name of the visitor
    and that they are riding the roller coaster.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个接纳访客。对于每个访客，我们将从键盘获取他们的姓名，年龄和身高。然后，我们将打印出访客的姓名以及他们正在乘坐过山车。
- en: 'Since roller coasters are only for adults with a certain height, we will reject
    visitors who are younger than 15 years old or shorter than 130 cm. We will handle
    the rejection using custom exceptions: `TooYoungException` and `TooShortException`.
    These exception objects will contain the name and the relevant property of the
    person (age or height). When we catch the exception, we will print an appropriate
    message that explains why they were rejected.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过山车只适合特定身高的成年人，我们将拒绝年龄小于15岁或身高低于130厘米的访客。我们将使用自定义异常`TooYoungException`和`TooShortException`来处理拒绝。这些异常对象将包含人的姓名和相关属性（年龄或身高）。当我们捕获异常时，我们将打印出一个适当的消息，解释为什么他们被拒绝。
- en: Once we have finished with a visitor, whether they ride the roller coaster or
    not, we will print that we are escorting the visitor outside the roller-coaster
    area.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了与游客的互动，无论他们是否乘坐过山车，我们都会打印出我们正在护送游客离开过山车区域。
- en: We will continue to accept visitors until the name is empty.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续接受游客，直到姓名为空。
- en: 'To achieve this, perform the following steps:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，执行以下步骤：
- en: Create a new class and enter `RollerCoasterWithEscorting` as the class name.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，并输入`RollerCoasterWithEscorting`作为类名。
- en: Also create two exception classes, `TooYoungException` and `TooShortException`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建两个异常类，`TooYoungException`和`TooShortException`。
- en: Import the `java.util.Scanner` package.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`java.util.Scanner`包。
- en: In `main()`, create an infinite loop.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，创建一个无限循环。
- en: Get the user's name. If it is an empty string, break out of the loop.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的姓名。如果是空字符串，跳出循环。
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的年龄。如果低于15，抛出一个名为`TooYoungException`的异常。
- en: Get the user's height. If it is lower than 130, throw a `TooShortException`
    with this name and age.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的身高。如果低于130，抛出一个名为`TooShortException`的异常。
- en: Print name as "John is riding the roller coaster."
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将姓名打印为"约翰正在乘坐过山车"。
- en: Catch the two types of exceptions separately. Print appropriate messages for
    each.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别捕获两种类型的异常。为每个打印适当的消息。
- en: Print that you are escorting the user off the premises. You have to be careful
    about the scope of the name variable.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出你正在护送用户离开场地。您必须小心姓名变量的范围。
- en: Run the main program.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行主程序。
- en: 'The output should be similar to the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE79]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 370.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第370页找到。
- en: The try with resource Block
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带资源的try块
- en: 'The `try`/ `catch`/ `finally` block is a great way to handle resources that
    you have allocated. However, you will probably agree that it feels a bit like
    boilerplate. Allocating resources and releasing them in a finally block is a very
    common pattern. Java 7 introduced a new block that simplifies this common pattern—the
    `try with resource` block. In this new block, we place the resource allocations
    between parentheses right after the try block and forget about them. The system
    will automatically call their `.close()` methods:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch`/`finally`块是处理已分配资源的一种很好的方式。然而，您可能会同意，它感觉有点像样板文件。在finally块中分配资源并释放它们是一种非常常见的模式。Java
    7引入了一个新的块，简化了这种常见模式——`try with resource`块。在这个新的块中，我们将资源分配放在try块后面的括号中，然后忘记它们。系统将自动调用它们的`.close()`方法：'
- en: '[PRE80]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: For this to work, all of these resources have to implement the `AutoCloseable`
    interface.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，所有这些资源都必须实现`AutoCloseable`接口。
- en: 'Exercise 48: try with resources Block'
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习48：带资源的try块
- en: 'In this exercise, we will have a look at the try with resource block:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看一下带资源的try块：
- en: 'Import the required classes as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式导入所需的类：
- en: '[PRE81]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `Main` class with the `useTheFile()` method, which takes a string
    parameter as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Main`类，其中包含`useTheFile()`方法，该方法接受一个字符串参数，如下所示：
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Convert our earlier example to use the try with resources block as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们之前的例子转换为使用带资源的try块，如下所示：
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Best Practices
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'While learning about exception handling and its statements, mechanics, and
    classes is required to use it, for most programmers this may not be enough. Usually,
    this set of theoretical information needs practical experience of various cases
    to get a better feel for exceptions. In this regard, some rules of thumb about
    the practical use of exceptions are worth mentioning:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然学习异常处理及其语句、机制和类是使用它所必需的，但对于大多数程序员来说，这可能还不够。通常，这套理论信息需要各种情况的实际经验，以更好地了解异常。在这方面，关于异常的实际使用的一些经验法则值得一提：
- en: Do not suppress exceptions unless you really handled them.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您真正处理了异常，否则不要压制异常。
- en: Inform the user and let them take responsibility unless you can fix things silently.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户并让他们承担责任，除非您可以悄悄地解决问题。
- en: Be aware of the caller's behavior and don't leak exceptions unless it is expected.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意调用者的行为，不要泄漏异常，除非它是预期的。
- en: Wrap and chain with more specific exceptions when possible.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能包装和链接更具体的异常。
- en: Suppressing Exceptions
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压制异常
- en: In your function, when you catch an exception and do no throw anything, you
    are signaling that you took care of the exceptional case and you fixed the situation
    so that it is as if that exceptional case had never happened. If you cannot make
    such a claim, then you should not have suppressed that exception.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的函数中，当您捕获异常并不抛出任何东西时，您正在表明您已经处理了异常情况，并且您已经修复了这种情况，使得好像这种异常情况从未发生过一样。如果您不能做出这样的声明，那么您就不应该压制那个异常。
- en: 'Exercise 49: Suppressing Exceptions'
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习49：压制异常
- en: 'For example: let''s assume that we have a list of strings that we expect to
    contain integer numbers:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：假设我们有一个字符串列表，我们期望其中包含整数数字：
- en: 'We will parse all of them and add them to a corresponding list of integers:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将解析它们并将它们添加到相应的整数列表中：
- en: '[PRE84]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Add a `main()` method as follows:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个如下所示的`main()`方法：
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When we run this, we get this output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们得到这个输出：
- en: '[PRE86]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We should do something about this; at least, we should not let our code crash.
    What is the correct course of action? Should we catch the error inside the `parseIntegers`
    function, or should we catch it in main? Let''s catch it in `parseIntegers` and
    see what happens:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该对此做些什么；至少，我们不应该让我们的代码崩溃。正确的行动是什么？我们应该在`parseIntegers`函数内捕获错误，还是应该在主函数中捕获错误？让我们在`parseIntegers`中捕获它，看看会发生什么：
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add a `main()` method as follows:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个如下所示的`main()`方法：
- en: '[PRE88]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now here is our output:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是我们的输出：
- en: '[PRE89]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: It added 1 and 3 together, and ignored the "two." Is this what we wanted? We
    assumed that the "two" was the correct number and we expected it to be in the
    sum. However, at the moment, we are excluding it from the sum, and we are adding
    a note in the logs. If this was a real-life scenario, probably nobody would look
    at the logs and the result that we provide would be inaccurate. This is because
    we caught the error and did not do anything meaningful about it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 它将1和3相加，忽略了"two"。这是我们想要的吗？我们假设"two"是正确的数字，并期望它包含在总和中。然而，目前我们将它排除在总和之外，并在日志中添加了一个注释。如果这是一个真实的场景，可能没有人会查看日志，我们提供的结果将是不准确的。这是因为我们捕捉了错误，但没有对其进行有意义的处理。
- en: 'What would be a better approach? We have two possibilities here: we either
    can assume that every element in the list should actually be a number, or we can
    assume that there will be mistakes and we should do something about them.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 什么才是更好的方法？我们有两种可能性：要么我们可以假设列表中的每个元素实际上都应该是一个数字，要么我们可以假设会有错误，我们应该对其进行处理。
- en: The latter is a trickier approach. Perhaps we can collect the offending entries
    in another list and return it back to the caller, and then the caller would send
    it back to its origin for re-evaluation. For example, it could show them to the
    user and ask them to be corrected.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是一个更棘手的方法。也许我们可以将有问题的条目收集到另一个列表中，并将其返回给调用者，然后调用者会将其发送回原始位置进行重新评估。例如，它可以将它们显示给用户，并要求他们进行更正。
- en: 'The former is an easier approach: we assume that the initial list contains
    number strings. If this assumption breaks, however, we have to let the caller
    know. So, we should throw an exception, rather than providing a half-correct sum.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是一个更简单的方法：我们假设初始列表包含数字字符串。然而，如果这个假设不成立，我们必须让调用者知道。因此，我们应该抛出异常，而不是提供一半正确的总和。
- en: 'What we should not do is take a third approach: hope that the list contains
    numbers, but ignore the ones that are not numbers. Note that this is a choice
    we made, but that''s not what we thought of when we enumerated our two options
    above. This was convenient to program, but it created an assumption that was not
    there in the original business logic. Be very careful about situations like this.
    Make sure you write down your assumptions and be strict in enforcing them. Do
    not let the convenience of programming force you to accept weird assumptions.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该采取第三种方法：希望列表包含数字，但忽略那些不是数字的元素。请注意，这是我们做出的选择，但这并不是我们在上面列举两个选项时考虑的。这样编程很方便，但它创建了一个原始业务逻辑中不存在的假设。在这样的情况下要非常小心。确保你写下你的假设，并严格执行它们。不要让编程的便利性迫使你接受奇怪的假设。
- en: 'If we take the assumption that the initial list contains number strings, here
    is how we should have coded it:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设初始列表包含数字字符串，我们应该这样编码：
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And the output would simply be as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将简单地如下所示：
- en: '[PRE91]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Keeping the User in the Loop
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让用户参与
- en: The previous rule of thumb advised us not to provide half-correct results by
    sweeping problems under the rug. Now we'll extend it for cases when the program
    is an interactive one. Unless your program is a batch process, it usually has
    some interaction with a user. In that case, having the user be the arbiter of
    a problematic situation is usually the right approach.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的经验法则建议我们不要把问题搁置一边，提供一半正确的结果。现在我们将其扩展到程序是交互式的情况。除非你的程序是批处理过程，通常它与用户有一些交互。在这种情况下，让用户成为问题情况的仲裁者通常是正确的方法。
- en: In our example of a list of string numbers, obviously, one of the strings is
    not parsable as a number and there is not much the program can do. However, if
    the user saw the "two," they could replace it with a "2" to fix the situation.
    Therefore, rather than trying to silently fix things, we should find ways of involving
    the user in the decision-making process and get their help to resolve the problem.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，一个字符串无法解析为数字，程序无法做太多事情。然而，如果用户看到了"two"，他们可以用"2"替换它来解决问题。因此，我们不应该试图悄悄地修复问题，而是应该找到方法让用户参与决策过程，并寻求他们的帮助来解决问题。
- en: 'Exercise 50: Asking the User for Help'
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习50：向用户寻求帮助
- en: 'We can extend our previous example so that we identify the offending entry
    in the list and ask the user to correct it:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们之前的例子，以便我们识别列表中的有问题的条目，并要求用户进行更正：
- en: 'Here is an approach for this:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个处理这种情况的方法：
- en: '[PRE92]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add a `main()` method as follows:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main()`方法如下：
- en: '[PRE93]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And here is a sample output:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出：
- en: '[PRE94]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that we identified the offending element and asked the user to fix it.
    This is a good way to keep the user in the loop and give them a chance to fix
    the problem.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们确定了有问题的元素，并要求用户对其进行修正。这是让用户参与并给他们一个机会来解决问题的好方法。
- en: Do Not Throw Unless It Is Expected
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除非预期会抛出异常
- en: So far, we have been suggesting that throwing exceptions is a good thing and
    that we should not suppress them. However, in some cases, this may not be the
    case. This reminds us that everything about exceptions depends on the context
    and we should think about each situation rather than blindly following patterns.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在建议抛出异常是一件好事，我们不应该压制它们。然而，在某些情况下，这可能并非如此。这提醒我们，关于异常的一切都取决于上下文，我们应该考虑每种情况，而不是盲目地遵循模式。
- en: 'Every now and then, you might use a third-party library and you might provide
    them with classes of yours so that they call your methods. For example: a game
    engine may get your object and call its `update()` method 60 times per second.
    In a case such as this, you should be careful about understanding what it may
    mean if you throw an exception. If it is the case that the exception that you
    throw exits the game, or shows a popup that an error happened, maybe you should
    not throw exceptions about things that are not showstoppers. Let''s say that you
    are not able to calculate a required value in this frame, but maybe it will work
    in the next frame. Is it worth stopping the game for this? Perhaps not.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能会使用第三方库，并且您可能会向它们提供您的类，以便它们调用您的方法。例如：游戏引擎可能会获取您的对象并调用其`update()`方法，每秒60次。在这种情况下，您应该仔细了解如果抛出异常会意味着什么。如果您抛出的异常导致游戏退出，或者显示一个错误发生的弹窗，也许您不应该为不是showstoppers的事情抛出异常。假设您在这一帧无法计算所需的值，但也许在下一帧会成功。这值得为此停止游戏吗？也许不值得。
- en: Especially when you are overriding classes/implementing interfaces and handing
    your object to another entity to manage, you should be mindful about what propagating
    an exception out of your methods entails. If the caller encourages exceptions,
    great. Otherwise you may have to wrap all your methods in a broad `try/catch`
    to ensure that you do not leak exceptions for things that are not showstoppers.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是当您重写类/实现接口并将您的对象交给另一个实体来管理时，您应该注意传播异常出您的方法意味着什么。如果调用者鼓励异常，那很好。否则，您可能需要将所有方法包装在广泛的`try/catch`中，以确保您不会因为不是showstoppers的事情而泄漏异常。
- en: Consider Chaining and Being More Specific When You Let Exceptions Propagate
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑链式和更具体的异常传播
- en: 'When you propagate an exception to your caller, you usually have a chance to
    add more information to that exception so that it will be more useful to the caller.
    For example: you may be parsing the user''s age, phone number, height, and so
    on, from strings that they provided. Simply raising a `NumberFormatException`,
    without informing the caller about which value it was for is not a very helpful
    strategy. Instead, catching the `NumberFormatException` separately for each parse
    operation gives us the chance to identify the offending value. Then, we can create
    a new Exception object, provide more information in it, give the `NumberFormatException`
    as the initial cause, and throw that instead. Then, the caller can catch it and
    be informed about which entity was the offending one.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将异常传播给调用者时，通常有机会向该异常添加更多信息，以使其对调用者更有用。例如：您可能正在从用户提供的字符串中解析用户的年龄、电话号码、身高等。简单地引发`NumberFormatException`，而不告知调用者是哪个值，这并不是一个很有帮助的策略。相反，为每个解析操作单独捕获`NumberFormatException`给了我们识别有问题的值的机会。然后，我们可以创建一个新的异常对象，在其中提供更多信息，将`NumberFormatException`作为初始原因，并抛出该异常。然后，调用者可以捕获它，并了解哪个实体是有问题的。
- en: The earlier exercise, in which we used our custom `NonNumberInListException`
    to identify the index of the offending entry in the list, is a good example of
    this rule of thumb. Whenever possible, it is a better idea to throw a more informative
    exception that we create ourselves, rather than letting the internal exception
    propagate without much context.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的练习中，我们使用我们自定义的`NonNumberInListException`来识别列表中有问题的条目的索引，这是这个经验法则的一个很好的例子。在可能的情况下，最好抛出一个我们自己创建的更具信息性的异常，而不是让内部异常在没有太多上下文的情况下传播。
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, we covered exceptions in Java from a practical point of view.
    First, we discussed the motivation behind exception handling and how it provides
    advantages over other ways of trying to handle erroneous cases. Then, we took
    the point of view of a newbie Java programmer with a powerful IDE and provided
    guidance on how to best handle and specify exceptions. Later, we dived deeper
    into causes of exceptions and various exception types, followed by the mechanics
    of exception handling using the try/catch, try/catch/finally, and try with resource
    blocks. We finish this discussion with a list of best practices to guide your
    decision process in various situations that involve exceptions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们从实际角度讨论了Java中的异常。首先，我们讨论了异常处理背后的动机，以及它如何比其他处理错误情况的方式更有优势。然后，我们以一个新手Java程序员的角度，结合强大的IDE，提供了如何最好地处理和指定异常的指导。之后，我们深入探讨了异常的原因和各种异常类型，以及使用try/catch、try/catch/finally和try
    with resource块处理异常的机制。我们最后讨论了一系列最佳实践，以指导您在涉及异常的各种情况下的决策过程。
