- en: Chapter 4. Working with Three.js Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Three.js材质
- en: 'In the previous chapters, we talked a bit about materials. You learned that
    a material, together with `THREE.Geometry`, forms `THREE.Mesh`. The material is
    like the skin of the object that defines what the outside of a geometry looks
    like. For example, a skin defines whether a geometry is metallic-looking, transparent,
    or shown as a wireframe. The resulting `THREE.Mesh` object can then be added to
    the scene to be rendered by Three.js. Until now, we haven''t really looked at
    materials in much detail. In this chapter, we''ll dive into all the materials
    Three.js has to offer, and you''ll learn how you can use these materials to create
    good-looking 3D objects. The materials we''ll explore in this chapter are shown
    in the following table:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们稍微谈到了材质。您已经了解到，材质与`THREE.Geometry`一起形成`THREE.Mesh`。材质就像物体的皮肤，定义了几何体外观的外部。例如，皮肤定义了几何体是金属外观、透明还是显示为线框。然后，生成的`THREE.Mesh`对象可以添加到场景中，由Three.js渲染。到目前为止，我们还没有真正详细地研究过材质。在本章中，我们将深入探讨Three.js提供的所有材质，并学习如何使用这些材质来创建好看的3D物体。我们将在本章中探讨的材质如下表所示：
- en: '| Name | Description |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MeshBasicMaterial` | This is a basic material that you can use to give your
    geometries a simple color or show the wireframe of your geometries. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| `MeshBasicMaterial` | 这是一种基本材质，您可以使用它来给您的几何体一个简单的颜色或显示几何体的线框。 |'
- en: '| `MeshDepthMaterial` | This is a material that uses the distance from the
    camera to determine how to color your mesh. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `MeshDepthMaterial` | 这是一种使用从相机到网格的距离来确定如何着色的材质。 |'
- en: '| `MeshNormalMaterial` | This is a simple material that bases the color of
    a face on its normal vector. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `MeshNormalMaterial` | 这是一种简单的材质，它基于法向量确定面的颜色。 |'
- en: '| `MeshFacematerial` | This is a container that allows you to specify a unique
    material for each face of the geometry. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `MeshFacematerial` | 这是一个容器，允许您为几何体的每个面指定一个独特的材质。 |'
- en: '| `MeshLambertMaterial` | This is a material that takes lighting into account
    and is used to create *dull* non-shiny-looking objects. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `MeshLambertMaterial` | 这是一种考虑光照的材质，用于创建*暗淡*的非光亮外观的物体。 |'
- en: '| `MeshPhongMaterial` | This is a material that also takes lighting into account
    and can be used to create shiny objects. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `MeshPhongMaterial` | 这是一种考虑光照的材质，可用于创建光亮的物体。 |'
- en: '| `ShaderMaterial` | This material allows you to specify your own shader programs
    to directly control how vertices are positioned and pixels are colored. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `ShaderMaterial` | 这种材质允许您指定自己的着色器程序，直接控制顶点的位置和像素的颜色。 |'
- en: '| `LineBasicMaterial` | This is a material that can be used on the `THREE.Line`
    geometry to create colored lines. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `LineBasicMaterial` | 这是一种可以用在`THREE.Line`几何体上创建彩色线条的材质。 |'
- en: '| `LineDashMaterial` | This is the same as `LineBasicMaterial`, but this material
    also allows you to create a dashed effect. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `LineDashMaterial` | 这与`LineBasicMaterial`相同，但这种材质还允许您创建虚线效果。 |'
- en: If you look through the source code of Three.js, you might run into `THREE.RawShaderMaterial`.
    This is a specialized material that can only be used together with `THREE.BufferedGeometry`.
    This geometry is a specialized form that is optimized for static geometries (for
    instance, vertices and faces don't change). We won't explore this material in
    this chapter, but we will use it in [Chapter 11](ch11.html "Chapter 11. Custom
    Shaders and Render Postprocessing"), *Custom Shaders and Render Postprocessing*,
    when we talk about creating custom shaders. In the code, you can also find `THREE.SpriteCanvasMaterial`,
    `THREE.SpriteMaterial`, and `THREE.PointCloudMaterial`. These are materials you
    use when styling individual points. We won't discuss those in this chapter, but
    we'll explore them in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and
    the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看Three.js的源代码，您可能会遇到`THREE.RawShaderMaterial`。这是一种专门的材质，只能与`THREE.BufferedGeometry`一起使用。这种几何体是一种针对静态几何体进行优化的特殊形式（例如，顶点和面不会改变）。我们不会在本章中探讨这种材质，但在[第11章](ch11.html
    "第11章。自定义着色器和渲染后处理")中，*自定义着色器和渲染后处理*，当我们讨论创建自定义着色器时，我们将使用它。在代码中，您还可以找到`THREE.SpriteCanvasMaterial`，`THREE.SpriteMaterial`和`THREE.PointCloudMaterial`。这些是您在为个别点设置样式时使用的材质。我们不会在本章中讨论这些，但我们将在[第7章](ch07.html
    "第7章。粒子、精灵和点云")中探讨它们，*粒子、精灵和点云*。
- en: Materials have a number of common properties, so before we look at the first
    material, `MeshBasicMaterial`, we'll look at the properties shared by all the
    materials.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 材质有许多共同的属性，因此在我们查看第一个材质`MeshBasicMaterial`之前，我们将先看一下所有材质共享的属性。
- en: Understanding common material properties
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解共同的材质属性
- en: 'You can quickly see for yourself which properties are shared between all the
    materials. Three.js provides a material base class, `THREE.Material`, that lists
    all the common properties. We''ve divided these common material properties into
    the following three categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以快速看到所有材质之间共享的属性。Three.js提供了一个材质基类`THREE.Material`，列出了所有共同的属性。我们将这些共同的材质属性分为以下三类：
- en: '**Basic properties**: These are the properties you''ll use most often. With
    these properties, you can, for instance, control the opacity of the object, whether
    it is visible, and how it is referenced (by ID or custom name).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本属性**：这些是您经常使用的属性。使用这些属性，您可以控制物体的不透明度，它是否可见，以及如何引用它（通过ID或自定义名称）。'
- en: '**Blending properties**: Every object has a set of blending properties. These
    properties define how the object is combined with its background.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合属性**：每个物体都有一组混合属性。这些属性定义了物体如何与其背景相结合。'
- en: '**Advanced properties**: There are a number of advanced properties that control
    how the low-level WebGL context renders objects. In most cases, you won''t need
    to mess with these properties.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级属性**：有许多高级属性控制着低级的WebGL上下文如何渲染物体。在大多数情况下，您不需要去处理这些属性。'
- en: Note that in this chapter, we skip any properties related to textures and maps.
    Most materials allow you to use images as textures (for instance, a wood-like
    or stone-like texture). In [Chapter 10](ch10.html "Chapter 10. Loading and Working
    with Textures"), *Loading and Working with Textures*, we will dive into the various
    texture and mapping options that are available. Some materials also have specific
    properties related to animation (skinning and `morphTargets`); we'll also skip
    those properties. These will be addressed in [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中，我们跳过了与纹理和贴图相关的任何属性。大多数材质允许您使用图像作为纹理（例如，类似木头或石头的纹理）。在[第10章](ch10.html
    "第10章。加载和使用纹理")中，*加载和使用纹理*，我们将深入探讨各种可用的纹理和映射选项。一些材质还具有与动画相关的特定属性（皮肤和`morphTargets`）；我们也会跳过这些属性。这些将在[第9章](ch09.html
    "第9章。动画和移动摄像机")中进行讨论，*动画和移动摄像机*。
- en: 'We start with the first one from the list: the basic properties.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列表中的第一个开始：基本属性。
- en: Basic properties
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本属性
- en: 'The basic properties of the `THREE.Material` object are listed in the following
    table (you can see these properties in action in the section on `THREE.BasicMeshMaterial`):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Material`对象的基本属性列在下表中（您可以在`THREE.BasicMeshMaterial`部分中看到这些属性的实际应用）：'
- en: '| Property | Description |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `id` | This is used to identify a material and is assigned when you create
    a material. This starts at `0` for the first material and is increased by `1`
    for each additional material that is created. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 用于标识材质的属性，在创建材质时分配。第一个材质从`0`开始，每创建一个额外的材质，增加`1`。 |'
- en: '| `uuid` | This is a uniquely generated ID and is used internally. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `uuid` | 这是一个唯一生成的ID，用于内部使用。 |'
- en: '| `name` | You can assign a name to a material with this property. This can
    be used for debugging purposes. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 您可以使用此属性为材质分配一个名称。这可用于调试目的。 |'
- en: '| `opacity` | This defines how transparent an object is. Use this together
    with the `transparent` property. The range of this property is from `0` to `1`.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | 这定义了对象的透明度。与`transparent`属性一起使用。此属性的范围是从`0`到`1`。 |'
- en: '| `transparent` | If this is set to `true`, Three.js will render this object
    with the set opacity. If this is set to `false`, the object won''t be transparent—just
    more lightly colored. This property should also be set to `true` if you use a
    texture that uses an alpha (transparency) channel. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `transparent` | 如果将其设置为`true`，Three.js将以设置的不透明度渲染此对象。如果将其设置为`false`，对象将不透明，只是颜色更浅。如果使用使用alpha（透明度）通道的纹理，则还应将此属性设置为`true`。
    |'
- en: '| `overdraw` | When you use `THREE.CanvasRenderer`, the polygons will be rendered
    a bit bigger. Set this to `true` when you see gaps when using this renderer. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `overdraw` | 当使用`THREE.CanvasRenderer`时，多边形会被渲染得更大一些。当使用此渲染器时看到间隙时，将其设置为`true`。
    |'
- en: '| `visible` | This defines whether this material is visible. If you set this
    to `false`, you won''t see the object in the scene. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 这定义了此材质是否可见。如果将其设置为`false`，则在场景中看不到对象。 |'
- en: '| `Side` | With this property, you can define to which side of the geometry
    a material is applied. The default is `THREE.Frontside`, which applies the material
    to the front (outside) of an object. You can also set this to `THREE.BackSide`,
    which applies is to the back (inside), or `THREE.DoubleSide`, which applies it
    to both sides. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Side` | 使用此属性，您可以定义材质应用于几何体的哪一侧。默认值为`THREE.Frontside`，将材质应用于对象的前面（外部）。您还可以将其设置为`THREE.BackSide`，将其应用于后面（内部），或`THREE.DoubleSide`，将其应用于两侧。
    |'
- en: '| `needsUpdate` | For some updates to the material, you need to tell Three.js
    that the material has been changed. If this property is set to `true`, Three.js
    will update its cache with the new material properties. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `needsUpdate` | 对于材质的一些更新，您需要告诉Three.js材质已更改。如果此属性设置为`true`，Three.js将使用新的材质属性更新其缓存。
    |'
- en: For each material, you can also set a number of blending properties.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种材质，您还可以设置一些混合属性。
- en: Blending properties
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合属性
- en: 'Materials have a couple of generic blending-related properties. Blending determines
    how the colors we render interact with the colors that are behind them. We''ll
    touch upon this subject a little bit when we talk about combining materials. The
    blending properties are listed in the following table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 材质具有一些通用的与混合相关的属性。混合确定我们渲染的颜色如何与它们后面的颜色相互作用。当我们谈论组合材质时，我们会稍微涉及这个主题。混合属性列在下表中：
- en: '| Name | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `blending` | This determines how the material on this object blends with
    the background. The normal mode is `THREE.NormalBlending`, which only shows the
    top layer. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 这决定了此对象上的材质与背景的混合方式。正常模式是`THREE.NormalBlending`，只显示顶层。 |'
- en: '| `blendsrc` | Besides using the standard blending modes, you can also create
    custom blend modes by setting `blendsrc`, `blenddst`, and `blendequation`. This
    property defines how this object (the source) is blended into the background (the
    destination). The default `THREE.SrcAlphaFactor` setting uses the alpha (transparency)
    channel for blending. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `blendsrc` | 除了使用标准混合模式，您还可以通过设置`blendsrc`，`blenddst`和`blendequation`来创建自定义混合模式。此属性定义了对象（源）如何混合到背景（目标）中。默认的`THREE.SrcAlphaFactor`设置使用alpha（透明度）通道进行混合。
    |'
- en: '| `blenddst` | This property defines how the background (the destination) is
    used in blending and defaults to `THREE.OneMinusSrcAlphaFactor`, which means this
    property too uses the alpha channel of the source for blending but uses `1` (alpha
    channel of the source) as the value. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `blenddst` | 此属性定义了背景（目标）在混合中的使用方式，默认为`THREE.OneMinusSrcAlphaFactor`，这意味着此属性也使用源的alpha通道进行混合，但使用`1`（源的alpha通道）作为值。
    |'
- en: '| `blendequation` | This defines how the `blendsrc` and `blenddst` values are
    used. The default is to add them (`AddEquation`). With these three properties,
    you can create your own custom blend modes. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `blendequation` | 这定义了如何使用`blendsrc`和`blenddst`值。默认是将它们相加（`AddEquation`）。使用这三个属性，您可以创建自定义混合模式。
    |'
- en: The last set of properties is mostly used internally and controls the specifics
    of how WebGL is used to render the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组属性主要用于内部使用，控制了如何使用WebGL来渲染场景的具体细节。
- en: Advanced properties
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级属性
- en: 'We won''t go into the details of these properties. These are related to how
    WebGL works internally. If you do want to know more about these properties, the
    OpenGL specification is a good starting point. You can find this specification
    at [http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf](http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf).
    The following table provides a brief description of these advanced properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍这些属性。这些与WebGL内部工作方式有关。如果您确实想了解有关这些属性的更多信息，OpenGL规范是一个很好的起点。您可以在[http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf](http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf)找到此规范。以下表格提供了这些高级属性的简要描述：
- en: '| Name | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `depthTest` | This is an advanced WebGL property. With this property, you
    can enable or disable the `GL_DEPTH_TEST` parameter. This parameter controls whether
    the *depth* of a pixel is used to determine a new pixel''s value. Normally, you
    wouldn''t need to change this. More information can be found in the OpenGL specifications
    we mentioned earlier. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `depthTest` | 这是一个高级的WebGL属性。使用此属性，您可以启用或禁用`GL_DEPTH_TEST`参数。此参数控制是否使用*深度*来确定新像素的值。通常情况下，您不需要更改此设置。有关更多信息，请参阅我们之前提到的OpenGL规范。
    |'
- en: '| `depthWrite` | This is another internal property. This property can be used
    to determine whether this material affects the WebGL depth buffer. If you use
    an object for a 2D overlay (for example, a hub), you should set this property
    to `false`. Usually, though, you shouldn''t need to change this property. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `depthWrite` | 这是另一个内部属性。此属性可用于确定此材质是否影响WebGL深度缓冲区。如果您使用2D叠加对象（例如中心），则应将此属性设置为`false`。通常情况下，您不需要更改此属性。
    |'
- en: '| `polygonOffset`, `polygonOffsetFactor`, and `polygonOffsetUnits` | With these
    properties, you can control the `POLYGON_OFFSET_FILL` WebGL feature. These are
    normally not needed. For an explanation of what they do in detail, you can look
    at the OpenGL specifications. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `polygonOffset`，`polygonOffsetFactor`和`polygonOffsetUnits` | 使用这些属性，您可以控制`POLYGON_OFFSET_FILL`
    WebGL特性。通常不需要这些。要详细了解它们的作用，可以查看OpenGL规范。 |'
- en: '| `alphatest` | This value can be set to a specific value (`0` to `1`). Whenever
    a pixel has an alpha value smaller than this value, it won''t be drawn. You can
    use this property to remove some transparency-related artifacts. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `alphatest` | 可以设置为特定值（`0`到`1`）。每当像素的alpha值小于此值时，它将不会被绘制。您可以使用此属性来消除一些与透明度相关的伪影。
    |'
- en: Now, let's look at all the available materials so that you can see the effect
    these properties have on the rendered output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看所有可用的材质，以便您可以看到这些属性对呈现输出的影响。
- en: Starting with a simple mesh
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个简单的网格开始
- en: 'In this section, we''ll look at a few simple materials: `MeshBasicMaterial`,
    `MeshDepthMaterial`, `MeshNormalMaterial`, and `MeshFaceMaterial`. We start with
    `MeshBasicMaterial`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些简单的材质：`MeshBasicMaterial`，`MeshDepthMaterial`，`MeshNormalMaterial`和`MeshFaceMaterial`。我们从`MeshBasicMaterial`开始。
- en: 'Before we look into the properties of these materials, here''s a quick note
    on how you can pass in properties to configure the materials. There are two options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些材质的属性之前，这里有一个关于如何传递属性以配置材质的快速说明。有两个选项：
- en: 'You can pass in the arguments in the constructor as a parameters object, like
    this:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将参数作为参数对象传递给构造函数，就像这样：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can also create an instance and set the properties individually,
    like this:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您还可以创建一个实例并单独设置属性，就像这样：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Usually, the best way is to use the constructor if we know all the properties'
    values while creating the material. The arguments used in both these styles use
    the same format. The only exception to this rule is the `color` property. In the
    first style, we can just pass in the hex value, and Three.js will create a `THREE.Color`
    object itself. In the second style, we have to explicitly create a `THREE.Color`
    object. In this book, we'll use both of these styles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好的方法是在创建材质时知道所有属性的值时使用构造函数。这两种风格使用的参数格式相同。唯一的例外是`color`属性。在第一种风格中，我们可以直接传入十六进制值，Three.js会自己创建一个`THREE.Color`对象。在第二种风格中，我们必须显式创建一个`THREE.Color`对象。在本书中，我们将使用这两种风格。
- en: THREE.MeshBasicMaterial
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshBasicMaterial
- en: '`MeshBasicMaterial` is a very simple material that doesn''t take into account
    the lights that are available in the scene. Meshes with this material will be
    rendered as simple, flat polygons, and you also have the option to show the geometry''s
    wireframe. Besides the common properties we saw in the earlier section on this
    material, we can set the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshBasicMaterial`是一个非常简单的材质，不考虑场景中可用的光源。使用此材质的网格将呈现为简单的平面多边形，您还可以选择显示几何的线框。除了我们在此材质的早期部分看到的常见属性之外，我们还可以设置以下属性：'
- en: '| Name | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This property allows you to set the color of the material. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 此属性允许您设置材质的颜色。 |'
- en: '| `wireframe` | This allows you to render the material as a wireframe. This
    is great for debugging purposes. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这允许您将材质呈现为线框。这对于调试很有用。 |'
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinewidth` | 如果启用线框，此属性定义线框的宽度。 |'
- en: '| `Wireframelinecap` | This property defines how the ends of lines look in
    wireframe mode. The possible values are `butt`, `round`, and `square`. The default
    value is `round`. In practice, the results from changing this property are very
    difficult to see. This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinecap` | 此属性定义线框模式下线条端点的外观。可能的值为`butt`，`round`和`square`。默认值为`round`。实际上，更改此属性的结果非常难以看到。此属性不受`WebGLRenderer`支持。'
- en: '| `wireframeLinejoin` | This defines how the line joints are visualized. The
    possible values are `round`, `bevel`, and `miter`. The default value is `round`.
    If you look very closely, you can see this in the example using low `opacity`
    and a very large `wireframeLinewidth` value. This property isn''t supported on
    `WebGLRenderer`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLinejoin` | 这定义了线条连接点的可视化方式。可能的值为`round`，`bevel`和`miter`。默认值为`round`。如果您仔细观察，可以在低`opacity`和非常大的`wireframeLinewidth`值的示例中看到这一点。此属性不受`WebGLRenderer`支持。'
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading`, `THREE.NoShading`, and `THREE.FlatShading`. The default
    value is `THREE.SmoothShading`, which results in a smooth object where you won''t
    see the individual faces. This property isn''t enabled in the example for this
    material. For an example, look at the section on `MeshNormalMaterial`. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Shading` | 这定义了如何应用着色。可能的值为`THREE.SmoothShading`，`THREE.NoShading`和`THREE.FlatShading`。默认值为`THREE.SmoothShading`，这会产生一个平滑的对象，您看不到单独的面。此属性在此材质的示例中未启用。例如，请查看`MeshNormalMaterial`部分。'
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. The default value is `THREE.NoColors`. If you set this value
    to `THREE.VertexColors`, the renderer will take the colors set on the colors property
    of `THREE.Geometry` into account.This property doesn''t work on `CanvasRenderer`
    but does work on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where
    we use this property to color the various parts of a line. You can also use this
    property to create a gradient effect for this material type. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 您可以使用此属性为每个顶点定义单独的颜色。默认值为`THREE.NoColors`。如果将此值设置为`THREE.VertexColors`，渲染器将考虑`THREE.Geometry`的`colors`属性上设置的颜色。此属性在`CanvasRenderer`上不起作用，但在`WebGLRenderer`上起作用。查看`LineBasicMaterial`示例，我们在其中使用此属性为线条的各个部分着色。您还可以使用此属性为此材质类型创建渐变效果。'
- en: '| `fog` | This property determines whether this material is affected by global
    fog settings. This is not shown in action, but if this is set to `false`, the
    global fog we saw in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make
    Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t
    affect how this object is rendered. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 此属性确定此材质是否受全局雾设置的影响。这在实际中没有显示，但如果将其设置为`false`，我们在[第2章](ch02.html
    "第2章。构成Three.js场景的基本组件")中看到的全局雾不会影响对象的渲染方式。'
- en: 'In the previous chapters, we saw how to create materials and assign them to
    objects. For `THREE.MeshBasicMaterial`, we do it like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了如何创建材质并将其分配给对象。对于`THREE.MeshBasicMaterial`，我们可以这样做：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new `THREE.MeshBasicMaterial` and initializes the `color` property
    to `0x7777ff` (which is purple).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`THREE.MeshBasicMaterial`并将`color`属性初始化为`0x7777ff`（紫色）。
- en: 'I''ve added an example that you can use to play around with the `THREE.MeshBasicMaterial`
    properties and the basic properties we discussed in the previous section. If you
    open up the `01-basic-mesh-material.html` example in the `chapter-04` folder,
    you''ll see a rotating cube like the one shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个示例，您可以使用它来玩转`THREE.MeshBasicMaterial`属性和我们在上一节中讨论的基本属性。如果您在`chapter-04`文件夹中打开`01-basic-mesh-material.html`示例，您将看到一个如下截图所示的旋转立方体：
- en: '![THREE.MeshBasicMaterial](graphics/2215OS_04_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshBasicMaterial](graphics/2215OS_04_01.jpg)'
- en: 'This is a very simple object. With the menu in the upper-right corner, you
    can play around with the properties and select different meshes (you can also
    change the renderer). For instance, a sphere with `opacity` of `0.2`, `transparent`
    set to `true`, `wireframe` set to `true`, `wireframeLinewidth` of `9`, and using
    `CanvasRenderer` is rendered like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的对象。在右上角的菜单中，您可以玩转属性并选择不同的网格（还可以更改渲染器）。例如，一个球体，`opacity`为`0.2`，`transparent`设置为`true`，`wireframe`设置为`true`，`wireframeLinewidth`为`9`，并使用`CanvasRenderer`渲染如下：
- en: '![THREE.MeshBasicMaterial](graphics/2215OS_04_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshBasicMaterial](graphics/2215OS_04_02.jpg)'
- en: One of the properties you can set in this example is the `side` property. With
    this property, you define to which side of `THREE.Geometry` the material is applied.
    You can test how this property works when you select the plane mesh. Since normally
    a material is only applied to the front side of a material, the rotating plane
    will be invisible half the time (when it shows it's back to you). If you set the
    `side` property to `double`, the plane will be visible the whole time, since the
    material is applied to both sides of the geometry. Note, though, that the renderer
    will need to do more work when the `side` property is set to `double`, so this
    could have an impact on the performance of your scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以设置的一个属性是`side`属性。使用此属性，您可以定义材质应用到`THREE.Geometry`的哪一侧。当您选择平面网格时，您可以测试此属性的工作原理。由于通常材质仅应用于材质的正面，因此旋转平面将在一半时间内不可见（当它向您展示背面时）。如果将`side`属性设置为`double`，则平面将始终可见，因为材质应用于几何体的两侧。但请注意，当`side`属性设置为`double`时，渲染器将需要做更多的工作，因此这可能会影响场景的性能。
- en: THREE.MeshDepthMaterial
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshDepthMaterial
- en: 'The next material on the list is `THREE.MeshDepthMaterial`. With this material,
    the way an object looks isn''t defined by lights or by a specific material property;
    it is defined by the distance from the object to the camera. You can combine this
    with other materials to easily create fading effects. The only relevant properties
    this material has are the following two that control whether you want to show
    a wireframe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个材料是`THREE.MeshDepthMaterial`。使用这种材料，物体的外观不是由灯光或特定的材料属性定义的；而是由物体到摄像机的距离定义的。您可以将其与其他材料结合使用，轻松创建淡出效果。这种材料具有的唯一相关属性是以下两个控制是否要显示线框的属性：
- en: '| Name | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这决定是否显示线框。 |'
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLineWidth` | 这决定线框的宽度。 |'
- en: 'To demonstrate this, we modified the cubes example from [Chapter 2](ch02.html
    "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic Components
    That Make Up a Three.js Scene* (`02-depth-material` from the `chapter-04` folder).
    Remember that you have to click on the **addCube** button to populate the scene.
    The following screenshot shows the modified example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们修改了来自[第2章](ch02.html "第2章。构成Three.js场景的基本组件")的立方体示例（`chapter-04`文件夹中的`02-depth-material`）。请记住，您必须单击**addCube**按钮才能填充场景。以下屏幕截图显示了修改后的示例：
- en: '![THREE.MeshDepthMaterial](graphics/2215OS_04_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshDepthMaterial](graphics/2215OS_04_03.jpg)'
- en: Even though the material doesn't have many additional properties to control
    how an object is rendered, we can still control how fast the object's color fades
    out. In this example, we exposed the `near` and `far` properties of the camera.
    As you probably remember from [Chapter 2](ch02.html "Chapter 2. Basic Components
    That Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*,
    with these two properties, we set the visible area for the camera. Any objects
    that are nearer to the camera than the `near` property aren't shown, and any objects
    further away than the `far` property also fall outside the camera's visible area.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该材料没有许多额外的属性来控制物体的渲染方式，但我们仍然可以控制物体颜色淡出的速度。在本例中，我们暴露了摄像机的`near`和`far`属性。您可能还记得来自[第2章](ch02.html
    "第2章。构成Three.js场景的基本组件")的内容，*构成Three.js场景的基本组件*，通过这两个属性，我们设置了摄像机的可见区域。比`near`属性更接近摄像机的任何对象都不会显示出来，而比`far`属性更远的任何对象也会超出摄像机的可见区域。
- en: 'The distance between the `near` and `far` properties of the camera defines
    the brightness and the rate at which objects fade out. If the distance is very
    large, objects will only fade out a little as they move away from the camera.
    If the distance is small, the fadeout will be much more notable (as you can see
    in the following screenshot):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机的`near`和`far`属性之间的距离定义了物体淡出的亮度和速度。如果距离非常大，物体远离摄像机时只会稍微淡出。如果距离很小，淡出效果将更加明显（如下面的屏幕截图所示）：
- en: '![THREE.MeshDepthMaterial](graphics/2215OS_04_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshDepthMaterial](graphics/2215OS_04_04.jpg)'
- en: 'Creating `THREE.MeshDepthMaterial` is very easy and the object doesn''t require
    any arguments. For this example, we''ve used the `scene.overrideMaterial` property
    to make sure all the objects in the scene use this material without having to
    explicitly specify it for each `THREE.Mesh` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`THREE.MeshDepthMaterial`非常简单，对象不需要任何参数。在本例中，我们使用了`scene.overrideMaterial`属性，以确保场景中的所有对象都使用这种材料，而无需为每个`THREE.Mesh`对象显式指定它：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next part in this chapter isn't really about a specific material, but shows
    a way in which you can combine multiple materials together.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一部分实际上并不是关于特定材料，而是展示了如何将多种材料组合在一起的方法。
- en: Combining materials
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合材料
- en: 'If you look back at the properties of `THREE.MeshDepthMaterial`, you can see
    that there isn''t an option to set the color of the cubes. Everything was decided
    for you by the default properties of the material. Three.js, however, has the
    option to combine materials together to create new effects (this is also where
    blending comes into play). The following code shows how we can combine materials
    together:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾一下`THREE.MeshDepthMaterial`的属性，您会发现没有选项来设置立方体的颜色。一切都是由材料的默认属性为您决定的。然而，Three.js有将材料组合在一起创建新效果的选项（这也是混合发挥作用的地方）。以下代码显示了我们如何将材料组合在一起：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get the following green-colored cubes that use the brightness from `THREE.MeshDepthMaterial`
    and the color from `THREE.MeshBasicMaterial` (open `03-combined-material.html`
    for this example). The following screenshot shows the example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下使用`THREE.MeshDepthMaterial`的亮度和`THREE.MeshBasicMaterial`的颜色的绿色立方体（打开`03-combined-material.html`查看此示例）。以下屏幕截图显示了示例：
- en: '![Combining materials](graphics/2215OS_04_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![组合材料](graphics/2215OS_04_05.jpg)'
- en: Let's look at the steps you need to take to get this specific result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您需要采取哪些步骤才能获得这个特定的结果。
- en: First, we need to create our two materials. For `THREE.MeshDepthMaterial`, we
    don't do anything special; for `THREE.MeshBasicMaterial`, however, we set `transparent`
    to `true` and define a `blending` mode. If we don't set the `transparent` property
    to `true`, we'll just have solid, green objects since Three.js won't know to take
    the already-rendered colors into account. With `transparent` set to `true`, Three.js
    will check the `blending` property to see how the green `THREE.MeshBasicMaterial`
    object should interact with the background. The background in this case is the
    cube rendered with `THREE.MeshDepthMaterial`. In [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*, we'll discuss in
    greater detail the various blend modes that are available.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建两种材质。对于`THREE.MeshDepthMaterial`，我们不需要做任何特殊处理；但是，对于`THREE.MeshBasicMaterial`，我们将`transparent`设置为`true`并定义一个`blending`模式。如果我们不将`transparent`属性设置为`true`，我们将只得到实心的绿色物体，因为Three.js不知道考虑已渲染的颜色。将`transparent`设置为`true`后，Three.js将检查`blending`属性，以查看绿色的`THREE.MeshBasicMaterial`对象应如何与背景交互。在这种情况下，背景是用`THREE.MeshDepthMaterial`渲染的立方体。在[第9章](ch09.html
    "第9章。动画和移动相机")中，*动画和移动相机*，我们将更详细地讨论可用的各种混合模式。
- en: 'For this example, though, we used `THREE.MultiplyBlending`. This blend mode
    multiplies the foreground color with the background color and gives you the desired
    effect. The last line in this code fragment is also an important one. What happens
    when we create a mesh with the `THREE.SceneUtils.createMultiMaterialObject()`
    function is that the geometry gets copied and two exactly the same meshes are
    returned in a group. If we render these without the last line, you should see
    a flickering effect. This can happen sometimes when objects are rendered one on
    top of the other and one of them is transparent. By scaling down the mesh created
    with `THREE.MeshDepthMaterial`, we can avoid this. To do so, use the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个例子，我们使用了`THREE.MultiplyBlending`。这种混合模式将前景颜色与背景颜色相乘，并给出所需的效果。这个代码片段中的最后一行也很重要。当我们使用`THREE.SceneUtils.createMultiMaterialObject()`函数创建一个网格时，几何图形会被复制，并且会返回两个完全相同的网格组。如果我们在没有最后一行的情况下渲染这些网格，您应该会看到闪烁效果。当对象被渲染在另一个对象的上方并且其中一个对象是透明的时，有时会发生这种情况。通过缩小使用`THREE.MeshDepthMaterial`创建的网格，我们可以避免这种情况。为此，请使用以下代码：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next material is also one where we won't have any influence on the colors
    used in rendering.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个材质也是一个我们无法影响渲染中使用的颜色的材质。
- en: THREE.MeshNormalMaterial
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshNormalMaterial
- en: 'The easiest way to understand how this material is rendered is by first looking
    at an example. Open up the `04-mesh-normal-material.html` example from the `chapter-04`
    folder. If you select the sphere as the mesh, you''ll see something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种材质如何渲染的最简单方法是先看一个例子。打开`chapter-04`文件夹中的`04-mesh-normal-material.html`示例。如果您选择球体作为网格，您将看到类似于这样的东西：
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](graphics/2215OS_04_06.jpg)'
- en: 'As you can see, each face of the mesh is rendered in a slightly different color,
    and even though the sphere rotates, the colors stay pretty much at the same place.
    This happens because the color of each face is based on the *normal* pointing
    out from the face. This normal is the vector perpendicular to the face. The normal
    vector is used in many different parts of Three.js. It is used to determine light
    reflections, helps in mapping textures to 3D models, and gives information on
    how to light, shade, and color pixels on a surface. Luckily, though, Three.js
    handles the computation of these vectors and uses them internally, so you don''t
    have to calculate them yourselves. The following screenshot shows all the normal
    vectors of `THREE.SphereGeometry`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，网格的每个面都以稍微不同的颜色呈现，即使球体旋转，颜色也基本保持不变。这是因为每个面的颜色是基于面外指向的*法线*。这个法线是垂直于面的向量。法线向量在Three.js的许多不同部分中都有用到。它用于确定光的反射，帮助将纹理映射到3D模型上，并提供有关如何照亮、着色和着色表面像素的信息。幸运的是，Three.js处理这些向量的计算并在内部使用它们，因此您不必自己计算它们。以下屏幕截图显示了`THREE.SphereGeometry`的所有法线向量：
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](graphics/2215OS_04_07.jpg)'
- en: 'The direction this normal points in determines the color a face gets when you
    use `THREE.MeshNormalMaterial`. Since all normals for the faces of a sphere point
    in a different direction, we get the colorful sphere you can see in the examples.
    As a quick side note, to add these normal arrows, you can use `THREE.ArrowHelper`
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法线指向的方向决定了使用`THREE.MeshNormalMaterial`时面的颜色。由于球体的所有面的法线都指向不同的方向，我们得到了您在示例中看到的多彩球体。作为一个快速的旁注，要添加这些法线箭头，您可以像这样使用`THREE.ArrowHelper`：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this code snippet, we iterate through all the faces of `THREE.SphereGeometry`.
    For each of these `THREE.Face3` objects, we calculate the center (the centroid)
    by adding the vertices that make up this face and dividing the result by 3\. We
    use this centroid, together with the normal vector of the face, to draw an arrow.
    The `THREE.ArrowHelper` takes the following arguments: `direction`, `origin`,
    `length`, `color`, `headLength`, and `headWidth`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们遍历了`THREE.SphereGeometry`的所有面。对于每个`THREE.Face3`对象，我们通过添加构成该面的顶点并将结果除以3来计算中心（质心）。我们使用这个质心和面的法线向量来绘制一个箭头。`THREE.ArrowHelper`接受以下参数：`direction`、`origin`、`length`、`color`、`headLength`和`headWidth`。
- en: 'There are a couple of other properties that you can set on `THREE.MeshNormalMaterial`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`THREE.MeshNormalMaterial`上设置的其他一些属性：
- en: '| Name | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这决定是否显示线框。 |'
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLineWidth` | 这决定线框的宽度。 |'
- en: '| `shading` | This configures shading in the form of flat shading with `THREE.FlatShading`
    and smooth shading with `THREE.SmoothShading`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `shading` | 这配置了平面着色和平滑着色。 |'
- en: 'We''ve already seen `wireframe` and `wireframeLinewidth` but skipped the `shading`
    property in our `THREE.MeshBasicMaterial` example. With the `shading` property,
    we can tell Three.js how to render our objects. If you use `THREE.FlatShading`,
    each face will be rendered as is (as you can see in the previous couple of screenshots),
    or you can use `THREE.SmoothShading`, which smoothens out the faces of our object.
    For instance, if we render the sphere using `THREE.SmoothShading`, the result
    looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`wireframe`和`wireframeLinewidth`，但在我们的`THREE.MeshBasicMaterial`示例中跳过了`shading`属性。使用`shading`属性，我们可以告诉Three.js如何渲染我们的对象。如果使用`THREE.FlatShading`，每个面将按原样呈现（正如您在前面的几个屏幕截图中看到的），或者您可以使用`THREE.SmoothShading`，它会使我们对象的面变得更加平滑。例如，如果我们使用`THREE.SmoothShading`来渲染球体，结果看起来像这样：
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](graphics/2215OS_04_08.jpg)'
- en: We're almost done with the simple materials. The last one is `THREE.MeshFaceMaterial`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了简单的材料。最后一个是`THREE.MeshFaceMaterial`。
- en: THREE.MeshFaceMaterial
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshFaceMaterial
- en: 'The last of the basic materials isn''t really a material but much more a container
    of other materials. `THREE.MeshFaceMaterial` allows you to assign a different
    material to each face of your geometry. For instance, if you have a cube, which
    has 12 faces (remember, Three.js only works with triangles), you can use this
    material to assign a different material (for example, with a different color)
    to each side of the cube. Using this material is really simple, as you can see
    from the following piece of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基本材料中的最后一个实际上不是一个材料，而是其他材料的容器。`THREE.MeshFaceMaterial`允许您为几何体的每个面分配不同的材料。例如，如果您有一个立方体，它有12个面（请记住，Three.js只使用三角形），您可以使用这种材料为立方体的每一面分配不同的材料（例如，不同的颜色）。使用这种材料非常简单，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We first create an array, named `matArray`, to hold all the materials. Next,
    we create a new material, `THREE.MeshBasicMaterial` in this example, with a different
    color for each face. With this array, we instantiate `THREE.MeshFaceMaterial`
    and use it together with the cube geometry to create the mesh. Let''s dive a bit
    deeper into the code and see what you need to do to recreate the following example:
    a simple 3D Rubik''s cube. You can find this example in `05-mesh-face-material.html`.
    The following screenshot shows this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`matArray`的数组来保存所有的材料。接下来，我们创建一个新的材料，在这个例子中是`THREE.MeshBasicMaterial`，每个面的颜色都不同。有了这个数组，我们实例化`THREE.MeshFaceMaterial`，并将它与立方体几何一起使用来创建网格。让我们深入了解一下代码，并看看您需要做什么才能重新创建以下示例：一个简单的3D魔方。您可以在`05-mesh-face-material.html`中找到此示例。以下屏幕截图显示了此示例：
- en: '![THREE.MeshFaceMaterial](graphics/2215OS_04_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshFaceMaterial](graphics/2215OS_04_09.jpg)'
- en: 'This Rubik''s cube consists of a number of smaller cubes: three cubes along
    the *x* axis, three along the *y* axis, and three along the *z* axis. Here''s
    how this is done:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔方由许多小立方体组成：沿着*x*轴有三个立方体，沿着*y*轴有三个立方体，沿着*z*轴有三个立方体。这是如何完成的：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this piece of code, we first create `THREE.Mesh`, which will hold all the
    individual cubes (`group`); next, we create the materials for each face and push
    them to the `mats` array. Remember, each side of the cube consists of two faces,
    so we need 12 materials. From these materials, we create `THREE.MeshFaceMaterial`.
    Then, we create three loops to make sure we create the right number of cubes.
    In this loop, we create each of the individual cubes, assign the material, position
    them, and add them to the group. What you should remember is that the position
    of the cubes is relative to the position of this group. If we move or rotate the
    group, all the cubes will move and rotate with it. For more information on how
    to work with groups, look at [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先创建`THREE.Mesh`，它将容纳所有的单独立方体（`group`）；接下来，我们为每个面创建材料并将它们推送到`mats`数组中。请记住，立方体的每一面都由两个面组成，所以我们需要12种材料。从这些材料中，我们创建`THREE.MeshFaceMaterial`。然后，我们创建三个循环，以确保我们创建了正确数量的立方体。在这个循环中，我们创建每个单独的立方体，分配材料，定位它们，并将它们添加到组中。您应该记住的是，立方体的位置是相对于这个组的位置的。如果我们移动或旋转组，所有的立方体都会随之移动和旋转。有关如何使用组的更多信息，请参阅[第8章](ch08.html
    "第8章 创建和加载高级网格和几何体")*创建和加载高级网格和几何体*。
- en: 'If you''ve opened the example in your browser, you can see that the complete
    Rubik''s cube rotates, and not the individual cubes. This happens because we use
    the following in our rendering loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开了示例，您会看到整个魔方立方体旋转，而不是单独的立方体。这是因为我们在渲染循环中使用了以下内容：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This causes the complete group to rotate around its center (0,0,0). When we
    positioned the individual cubes, we made sure they were positioned around this
    center point. That's why you see the -3 offset in the `cube.position.set(x * 3
    - 3, y * 3, z * 3 - 3);` line of the preceding code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致完整的组围绕其中心（0,0,0）旋转。当我们定位单独的立方体时，我们确保它们位于这个中心点周围。这就是为什么在前面的代码行中看到`cube.position.set(x
    * 3 - 3, y * 3, z * 3 - 3);`中的-3偏移量。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you look at this code, you might wonder how Three.js determines which material
    to use for a specific face. For this, Three.js uses the `materialIndex` property,
    which you can set on each individual face of the `geometry.faces` array. The property
    points to the array index of the materials we add in the constructor of the `THREE.FaceMaterial`
    object. When you create a geometry using one of the standard Three.js geometries,
    Three.js provides sensible defaults. If you want other behavior, you can just
    set the `materialIndex` property yourself for each face to point at one of the
    provided materials.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这段代码，您可能会想知道Three.js如何确定要为特定面使用哪种材料。为此，Three.js使用`materialIndex`属性，您可以在`geometry.faces`数组的每个单独的面上设置它。该属性指向我们在`THREE.FaceMaterial`对象的构造函数中添加的材料的数组索引。当您使用标准的Three.js几何体之一创建几何体时，Three.js会提供合理的默认值。如果您想要其他行为，您可以为每个面自己设置`materialIndex`属性，以指向提供的材料之一。
- en: '`THREE.MeshFaceMaterial` was the last of our basic materials. In the next section,
    we''ll look at some of the more advanced materials available in Three.js.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.MeshFaceMaterial`是我们基本材质中的最后一个。在下一节中，我们将看一下Three.js中提供的一些更高级的材质。'
- en: Advanced materials
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级材质
- en: 'In this section, we''ll look at the more advanced materials Three.js has to
    offer. We''ll first look at `THREE.MeshPhongMaterial` and `THREE.MeshLambertMaterial`.
    These two materials react to light sources and can be used to create shiny and
    dull-looking materials, respectively. In this section, we''ll also look at one
    of the most versatile, but most difficult to use, materials: `THREE.ShaderMaterial`.
    With `THREE.ShaderMaterial`, you can create your own shader programs that define
    how the material and object should be shown.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下Three.js提供的更高级的材质。我们首先会看一下`THREE.MeshPhongMaterial`和`THREE.MeshLambertMaterial`。这两种材质对光源有反应，分别可以用来创建有光泽和无光泽的材质。在这一部分，我们还将看一下最多才多艺，但最难使用的材质之一：`THREE.ShaderMaterial`。使用`THREE.ShaderMaterial`，你可以创建自己的着色器程序，定义材质和物体的显示方式。
- en: THREE.MeshLambertMaterial
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshLambertMaterial
- en: 'This material can be used to create dull-looking, non-shiny surfaces. This
    is a very easy-to-use material that responds to the lighting sources in the scene.
    This material can be configured with a number of properties we''ve seen before:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframeLineJoin`, `vertexColors`,
    and `fog`. We won''t go into the details of those properties, but will focus on
    the ones specific to this material. That just leaves us with the following four
    properties:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材质可以用来创建无光泽的表面。这是一种非常易于使用的材质，可以响应场景中的光源。这种材质可以配置许多我们之前见过的属性：`color`、`opacity`、`shading`、`blending`、`depthTest`、`depthWrite`、`wireframe`、`wireframeLinewidth`、`wireframeLinecap`、`wireframeLineJoin`、`vertexColors`和`fog`。我们不会详细讨论这些属性，而是专注于这种材质特有的属性。这样我们就只剩下以下四个属性了：
- en: '| Name | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `ambient` | 这是材质的*环境*颜色。这与我们在上一章看到的环境光一起使用。这种颜色与环境光提供的颜色相乘。默认为白色。 |'
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `emissive` | 这是材质发出的颜色。它并不真正作为光源，但这是一个不受其他光照影响的纯色。默认为黑色。 |'
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `wrapAround` | 如果将此属性设置为`true`，则启用半兰伯特光照技术。使用半兰伯特光照，光的衰减更加温和。如果有一个有严重阴影的网格，启用此属性将软化阴影并更均匀地分布光线。
    |'
- en: '| `wrapRGB` | When `wrapAround` is set to true, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `wrapRGB` | 当`wrapAround`设置为true时，你可以使用`THREE.Vector3`来控制光的衰减速度。 |'
- en: 'This material is created just like all the other ones. Here''s how it''s done:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材质的创建方式和其他材质一样。下面是它的创建方式：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For an example of this material, look at `06-mesh-lambert-material.html`. The
    following screenshot shows this example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此材质的示例，请查看`06-mesh-lambert-material.html`。以下截图显示了此示例：
- en: '![THREE.MeshLambertMaterial](graphics/2215OS_04_10.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshLambertMaterial](graphics/2215OS_04_10.jpg)'
- en: As you can see in the preceding screenshot, the material looks rather dull.
    There is another material we can use to create shiny surfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的截图中看到的，这种材质看起来相当无光泽。我们还可以使用另一种材质来创建有光泽的表面。
- en: THREE.MeshPhongMaterial
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshPhongMaterial
- en: 'With `THREE.MeshPhongMaterial`, we can create a material that is shiny. The
    properties you can use for that are pretty much the same as for a non-shiny `THREE.MeshLambertMaterial`
    object. We''ll once again skip the basic properties and those already discussed:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframelineJoin`, and `vertexColors`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.MeshPhongMaterial`，我们可以创建一个有光泽的材质。你可以用于此的属性基本上与无光泽的`THREE.MeshLambertMaterial`对象相同。我们再次跳过基本属性和已经讨论过的属性：`color`、`opacity`、`shading`、`blending`、`depthTest`、`depthWrite`、`wireframe`、`wireframeLinewidth`、`wireframeLinecap`、`wireframelineJoin`和`vertexColors`。
- en: 'The interesting properties for this material are shown in the following table:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材质的有趣属性如下表所示：
- en: '| Name | Description |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `ambient` | 这是材质的*环境*颜色。这与我们在上一章看到的环境光一起使用。这种颜色与环境光提供的颜色相乘。默认为白色。 |'
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `emissive` | 这是材质发出的颜色。它并不真正作为光源，但这是一个不受其他光照影响的纯色。默认为黑色。 |'
- en: '| `specular` | This property defines how shiny the materials are and with what
    color it shines. If this is set to the same color as the `color` property, you
    get a more metallic-looking material. If this is set to grey, it results in a
    more plastic-looking material. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `specular` | 此属性定义材质有多光泽，以及以什么颜色发光。如果设置为与`color`属性相同的颜色，你会得到一个更金属质感的材质。如果设置为灰色，会得到一个更塑料质感的材质。
    |'
- en: '| `shininess` | This property defines how shiny the specular highlight is.
    The default value for the shininess is `30`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `shininess` | 此属性定义镜面高光的光泽程度。光泽的默认值为`30`。 |'
- en: '| `metal` | When this property is set to `true`, Three.js uses a slightly different
    way of calculating the color of a pixel to make the object look more like a metal.
    Note that the effect is very minimal. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `metal` | 当此属性设置为`true`时，Three.js使用略有不同的方式来计算像素的颜色，使对象看起来更像金属。请注意，效果非常微小。'
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `wrapAround` | 如果将此属性设置为`true`，则启用半兰伯特光照技术。使用半兰伯特光照，光线的衰减更加微妙。如果网格有严重的黑暗区域，启用此属性将软化阴影并更均匀地分布光线。'
- en: '| `wrapRGB` | When `wrapAround` is set to `true`, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `wrapRGB` | 当`wrapAround`设置为`true`时，您可以使用`THREE.Vector3`来控制光线衰减的速度。'
- en: 'Initializing a `THREE.MeshPhongMaterial` object is done in the same way as
    we''ve already seen for all the other materials and is shown in the following
    line of code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`THREE.MeshPhongMaterial`对象的方式与我们已经看到的所有其他材质的方式相同，并且显示在以下代码行中：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To give you the best comparison, we''ve created the same example for this material
    as we did for `THREE.MeshLambertMaterial`. You can use the control GUI to play
    around with this material. For instance, the following settings create a plastic-looking
    material. You can find this example in `07-mesh-phong-material.html`. The following
    screenshot shows this example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你最好的比较，我们为这种材质创建了与`THREE.MeshLambertMaterial`相同的示例。您可以使用控制GUI来尝试这种材质。例如，以下设置会创建一个看起来像塑料的材质。您可以在`07-mesh-phong-material.html`中找到这个示例。以下屏幕截图显示了这个示例：
- en: '![THREE.MeshPhongMaterial](graphics/2215OS_04_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshPhongMaterial](graphics/2215OS_04_11.jpg)'
- en: The last one of the advanced materials we'll explore is `THREE.ShaderMaterial`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨的高级材质中的最后一个是`THREE.ShaderMaterial`。
- en: Creating your own shaders with THREE.ShaderMaterial
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用THREE.ShaderMaterial创建自己的着色器
- en: '`THREE.ShaderMaterial` is one of the most versatile and complex materials available
    in Three.js. With this material, you can pass in your own custom shaders that
    are directly run in the WebGL context. A shader converts Three.js JavaScript meshes
    to pixels on screen. With these custom shaders, you can define exactly how your
    object should be rendered and how to override or alter the defaults from Three.js.
    In this section, we won''t go into the details yet of how to write custom shaders.
    For more information on that, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Postprocessing*. For now,
    we''ll just look at a very basic example that shows how you can configure this
    material.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial`是Three.js中最多功能和复杂的材质之一。使用这种材质，您可以传递自己的自定义着色器，直接在WebGL上下文中运行。着色器将Three.js
    JavaScript网格转换为屏幕上的像素。使用这些自定义着色器，您可以精确定义对象的渲染方式，以及如何覆盖或更改Three.js的默认设置。在本节中，我们暂时不会详细介绍如何编写自定义着色器。有关更多信息，请参阅[第11章](ch11.html
    "第11章.自定义着色器和渲染后处理"), *自定义着色器和渲染后处理*。现在，我们只会看一个非常基本的示例，展示如何配置这种材质。'
- en: '`THREE.ShaderMaterial` has a number of properties you can set that we''ve already
    seen. With `THREE.ShaderMaterial`, Three.js passes in all the information regarding
    these properties, but you still have to process the information in your own shader
    programs. The following are the properties of `THREE.ShaderMaterial` that we have
    already seen:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial`有许多可以设置的属性，我们已经看到了。使用`THREE.ShaderMaterial`，Three.js传递了有关这些属性的所有信息，但是您仍然必须在自己的着色器程序中处理这些信息。以下是我们已经看到的`THREE.ShaderMaterial`的属性：'
- en: '| Name | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This renders the material as a wireframe. This is great for
    debugging purposes. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这将材质呈现为线框。这对于调试目的非常有用。 |'
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinewidth` | 如果启用线框，此属性定义了线框的线宽。'
- en: '| `linewidth` | This defines the width of the line to be drawn. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `linewidth` | 这定义了要绘制的线的宽度。'
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading` and `THREE.FlatShading`. This property isn''t enabled in
    the example for this material. For example, look at the section on `MeshNormalMaterial`.
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Shading` | 这定义了如何应用着色。可能的值是`THREE.SmoothShading`和`THREE.FlatShading`。此属性在此材质的示例中未启用。例如，查看`MeshNormalMaterial`部分。'
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. This property doesn''t work on `CanvasRenderer` but does work
    on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where we use this
    property to color the various parts of a line. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 您可以使用此属性定义应用于每个顶点的单独颜色。此属性在`CanvasRenderer`上不起作用，但在`WebGLRenderer`上起作用。查看`LineBasicMaterial`示例，我们在该示例中使用此属性来给线的各个部分上色。'
- en: '| `fog` | This determines whether this material is affected by global fog settings.
    This is not shown in action. If this is set to `false`, the global fog we saw
    in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js
    Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t affect how
    this object is rendered. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这决定了这种材质是否受全局雾设置的影响。这并没有展示出来。如果设置为`false`，我们在[第2章](ch02.html "第2章.组成Three.js场景的基本组件"),
    *组成Three.js场景的基本组件*中看到的全局雾不会影响对象的渲染方式。'
- en: 'Besides these properties that are passed into the shader, `THREE.ShaderMaterial`
    also provides a number of specific properties you can use to pass in additional
    information into your custom shader (they might seem a bit obscure at the moment;
    for more details, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders and Render
    Postprocessing"), *Custom Shaders and Render Postprocessing*), which are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些传递到着色器的属性之外，`THREE.ShaderMaterial`还提供了一些特定属性，您可以使用这些属性将附加信息传递到自定义着色器中（它们目前可能看起来有点晦涩；有关更多详细信息，请参见[第11章](ch11.html
    "第11章.自定义着色器和渲染后处理")*自定义着色器和渲染后处理*），如下所示：
- en: '| Name | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fragmentShader` | This shader defines the color of each pixel that is passed
    in. Here, you need to pass in the string value of your fragment shader program.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `fragmentShader` | 此着色器定义了传入的每个像素的颜色。在这里，您需要传递片段着色器程序的字符串值。'
- en: '| `vertexShader` | This shader allows you to change the position of each vertex
    that is passed in. Here, you need to pass in the string value of your vertex shader
    program. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `vertexShader` | 此着色器允许您更改传入的每个顶点的位置。在这里，您需要传递顶点着色器程序的字符串值。|'
- en: '| `uniforms` | This allows you to send information to your shader. The same
    information is sent to each vertex and fragment. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `uniforms` | 这允许您向着色器发送信息。相同的信息被发送到每个顶点和片段。'
- en: '| `defines` | Converts to #define code fragments. With these fragments, you
    can set some additional global variables in the shader programs. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `defines` | 转换为#define代码片段。使用这些片段，您可以在着色器程序中设置一些额外的全局变量。'
- en: '| `attributes` | These can change between each vertex and fragment. They are
    usually used to pass positional and normal-related data. If you want to use this,
    you need to provide information for all the vertices of the geometry. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `attributes` | 这些可以在每个顶点和片段之间改变。它们通常用于传递位置和与法线相关的数据。如果要使用这个，您需要为几何图形的所有顶点提供信息。'
- en: '| `lights` | This determines whether light data should be passed into the shaders.
    This defaults to `false`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `lights` | 这决定了是否应该将光数据传递到着色器中。默认值为`false`。'
- en: 'Before we look at an example, we''ll give a quick explanation about the most
    important parts of `ShaderMaterial`. To work with this material, we have to pass
    in two different shaders:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一个例子之前，我们将简要解释`ShaderMaterial`的最重要部分。要使用这种材质，我们必须传入两种不同的着色器：
- en: '`vertexShader`: This is run on each vertex of the geometry. You can use this
    shader to transform the geometry by moving the position of the vertices around.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexShader`：这在几何图形的每个顶点上运行。您可以使用此着色器通过移动顶点的位置来转换几何图形。'
- en: '`fragmentShader`: This is run on each fragment of the geometry. In `vertexShader`,
    we return the color that should be shown for this specific fragment.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragmentShader`：这在几何图形的每个片段上运行。在`vertexShader`中，我们返回应该显示在这个特定片段上的颜色。'
- en: For all the materials we've discussed until now in this chapter, Three.js provides
    `fragmentShader` and `vertexShader`, so you don't have to worry about those.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们讨论的所有材质，Three.js都提供了`fragmentShader`和`vertexShader`，所以你不必担心这些。
- en: For this section, we'll look at a simple example that uses a very simple `vertexShader`
    program that changes the *x*, *y*, and *z* coordinates of the vertices of a cube
    and a `fragmentShader` program that uses shaders from [http://glslsandbox.com/](http://glslsandbox.com/)
    to create an animating material.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个简单的例子，该例子使用了一个非常简单的`vertexShader`程序，该程序改变了立方体顶点的*x*、*y*和*z*坐标，以及一个`fragmentShader`程序，该程序使用了来自[http://glslsandbox.com/](http://glslsandbox.com/)的着色器创建了一个动画材质。
- en: 'Up next, you can see the complete code for `vertexShader` that we''ll use.
    Note that writing shaders isn''t done in JavaScript. You write shaders in a C-like
    language called **GLSL** (WebGL supports OpenGL ES Shading Language 1.0—for more
    information on GLSL, see [https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)),
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以看到我们将使用的`vertexShader`的完整代码。请注意，编写着色器不是在JavaScript中完成的。您需要使用一种称为**GLSL**的类似C的语言来编写着色器（WebGL支持OpenGL
    ES着色语言1.0——有关GLSL的更多信息，请参见[https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)）：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We won''t go into too much detail here and just focus on the most important
    parts of this code. To communicate with the shaders from JavaScript, we use something
    called uniforms. In this example, we use the `uniform float time;` statement to
    pass in an external value. Based on this value, we change the *x*, *y*, and *z*
    coordinates of the passed-in vertex (which is passed in as the position variable):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细讨论，只关注这段代码的最重要部分。要从JavaScript与着色器通信，我们使用一种称为uniforms的东西。在这个例子中，我们使用`uniform
    float time;`语句来传递外部值。根据这个值，我们改变传入顶点的*x*、*y*和*z*坐标（作为position变量传入）：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `posChanged` vector now contains the new coordinate for this vertex based
    on the passed-in time variable. The last step we need to perform is pass this
    new position back to Three.js, which is always done like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`posChanged`向量现在包含了基于传入的时间变量的这个顶点的新坐标。我们需要执行的最后一步是将这个新位置传递回Three.js，这总是这样完成的：'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `gl_Position` variable is a special variable that is used to return the
    final position. Next, we need to create `shaderMaterial` and pass in `vertexShader`.
    For this, we''ve created a simple helper function, which we use like this: `var
    meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");` in the following
    code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_Position`变量是一个特殊变量，用于返回最终位置。接下来，我们需要创建`shaderMaterial`并传入`vertexShader`。为此，我们创建了一个简单的辅助函数，我们可以像这样使用：`var
    meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");`在下面的代码中：'
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The arguments point to the ID of the `script` element in the HTML page. Here,
    you can also see that we set up a uniforms variable. This variable is used to
    pass information from our renderer into our shader. Our complete render loop for
    this example is shown in the following code snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参数指向HTML页面中`script`元素的ID。在这里，您还可以看到我们设置了一个uniforms变量。这个变量用于将信息从我们的渲染器传递到我们的着色器。我们这个例子的完整渲染循环如下代码片段所示：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see that we increase the time variable by 0.01 each time the render
    loop is run. This information is passed into `vertexShader` and used to calculate
    the new position of the vertices of our cube. Now open up the `08-shader-material.html`
    example, and you''ll see that the cube shrinks and grows around its axis. The
    following screenshot gives a still image of this example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们每次运行渲染循环时都会将时间变量增加0.01。此信息传递到`vertexShader`中，并用于计算我们立方体顶点的新位置。现在打开`08-shader-material.html`示例，您会看到立方体围绕其轴收缩和增长。以下屏幕截图显示了此示例的静态图像：
- en: '![Creating your own shaders with THREE.ShaderMaterial](graphics/2215OS_04_12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.ShaderMaterial创建自定义着色器](graphics/2215OS_04_12.jpg)'
- en: 'In this example, you can see that each of the cube''s faces has an animating
    pattern. The fragment shader that is assigned to each face of the cube creates
    these patterns. As you might have guessed, we''ve used `THREE.MeshFaceMaterial`
    (and the `createMaterial` function we explained earlier) for this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以看到立方体的每个面都具有动画图案。分配给立方体每个面的片段着色器创建了这些图案。正如您可能已经猜到的那样，我们为此使用了`THREE.MeshFaceMaterial`（以及我们之前解释的`createMaterial`函数）：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only part we haven''t explained yet is about `fragmentShader`. For this
    example, all the `fragmentShader` objects were copied from [http://glslsandbox.com/](http://glslsandbox.com/).
    This site provides an experimental playground where you can write and share `fragmentShader`
    objects. I won''t go into the details here, but `fragment-shader-6` used in this
    example looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未解释的部分是关于`fragmentShader`。在此示例中，所有`fragmentShader`对象都是从[http://glslsandbox.com/](http://glslsandbox.com/)复制的。该网站提供了一个实验性的游乐场，您可以在其中编写和共享`fragmentShader`对象。我不会在这里详细介绍，但在此示例中使用的`fragment-shader-6`如下所示：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The color that finally gets passed back to Three.js is the one set with `gl_FragColor
    = color_final`. A good way to get a bit more of a feeling for `fragmentShader`
    is to explore what''s available at [http://glslsandbox.com/](http://glslsandbox.com/)
    and to use the code for your own objects. Before we move to the next set of materials,
    here is one more example of what is possible with a custom `vertexShader` program
    ([https://www.shadertoy.com/view/4dXGR4](https://www.shadertoy.com/view/4dXGR4)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终传递给Three.js的颜色是使用`gl_FragColor = color_final`设置的颜色。更多了解`fragmentShader`的方法是探索[http://glslsandbox.com/](http://glslsandbox.com/)提供的内容，并使用代码创建自己的对象。在我们转移到下一组材质之前，这里是一个使用自定义`vertexShader`程序的更多示例([https://www.shadertoy.com/view/4dXGR4](https://www.shadertoy.com/view/4dXGR4))：
- en: '![Creating your own shaders with THREE.ShaderMaterial](graphics/2215OS_04_13.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.ShaderMaterial创建自定义着色器](graphics/2215OS_04_13.jpg)'
- en: Much more on the subject of fragment and vertex shaders can be found in [Chapter
    11](ch11.html "Chapter 11. Custom Shaders and Render Postprocessing"), *Custom
    Shaders and Render Postprocessing*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有关片段和顶点着色器的更多内容，请参阅[第11章](ch11.html "第11章。自定义着色器和渲染后处理")，“自定义着色器和渲染后处理”。
- en: Materials you can use for a line geometry
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可以用于线几何体的材质
- en: 'The last couple of materials we''re going to look at can only be used on one
    specific geometry: `THREE.Line`. As the name implies, this is just a single line
    that only consists of vertices and doesn''t contain any faces. Three.js provides
    two different materials you can use on a line, which are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后几种材质只能用于特定几何体：`THREE.Line`。顾名思义，这只是一个仅由顶点组成且不包含任何面的单条线。Three.js提供了两种不同的材质，您可以用于线，如下所示：
- en: '`THREE.LineBasicMaterial`: The basic material for a line allows you to set
    the `colors`, `linewidth`, `linecap`, and `linejoin` properties'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineBasicMaterial`：线的基本材质允许您设置`colors`，`linewidth`，`linecap`和`linejoin`属性'
- en: '`THREE.LineDashedMaterial`: This has the same properties as `THREE.LineBasicMaterial`
    but allows you to create a *dash* effect by specifying dash and spacing sizes'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineDashedMaterial`：具有与`THREE.LineBasicMaterial`相同的属性，但允许您通过指定虚线和间距大小来创建*虚线*效果'
- en: We'll start with the basic variant and after that look at the dashed variant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本变体开始，然后再看虚线变体。
- en: THREE.LineBasicMaterial
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineBasicMaterial
- en: 'The materials available for the `THREE.Line` geometry are very simple. The
    following table shows the properties available to this material:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`THREE.Line`几何体可用的材质非常简单。以下表格显示了此材质可用的属性：
- en: '| Name | Description |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This determines the color of the line. If you specify `vertexColors`,
    this property is ignored. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这确定了线的颜色。如果指定了`vertexColors`，则忽略此属性。 |'
- en: '| `linewidth` | This determines the width of the line. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `linewidth` | 这确定了线的宽度。 |'
- en: '| `linecap` | This property defines how the ends of lines look in the wireframe
    mode. The possible values are `butt`, `round`, and `square`. The default is `round`.
    In practice, the results from changing this property are very difficult to see.
    This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `linecap` | 此属性定义了线框模式下线条末端的外观。可能的值是`butt`，`round`和`square`。默认值是`round`。在实践中，更改此属性的结果很难看到。此属性不受`WebGLRenderer`支持。
    |'
- en: '| `linejoin` | Define how the line joints are visualized. The possible values
    are `round`, `bevel`, and `miter`. The default value is `round`. If you look very
    closely, you can see this in the example using low `opacity` and a very large
    `wireframeLinewidth`. This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `linejoin` | 定义线接头的可视化方式。可能的值是`round`，`bevel`和`miter`。默认值是`round`。如果仔细观察，可以在使用低`opacity`和非常大的`wireframeLinewidth`的示例中看到这一点。此属性不受`WebGLRenderer`支持。
    |'
- en: '| `vertexColors` | You can supply a specific color for each vertex by setting
    this property to the `THREE.VertexColors` value. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 通过将此属性设置为`THREE.VertexColors`值，可以为每个顶点提供特定的颜色。 |'
- en: '| `fog` | This determines whether this object is affected by the global fog
    property. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这确定了这个对象是否受全局雾化属性的影响。 |'
- en: 'Before we look at an example of `LineBasicMaterial`, let''s first have a quick
    look at how we can create a `THREE.Line` mesh from a set of vertices and combine
    that with `LineMaterial` to create the mesh, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 `LineBasicMaterial` 的示例之前，让我们先快速看一下如何从一组顶点创建 `THREE.Line` 网格，并将其与 `LineMaterial`
    结合起来创建网格，如下所示的代码：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first part of this code fragment, `var points = gosper(4, 60);`, is used
    as an example to get a set of *x* and *y* coordinates. This function returns a
    gosper curve (for more information, check out [http://en.wikipedia.org/wiki/Gosper_curve](http://en.wikipedia.org/wiki/Gosper_curve)),
    which is a simple algorithm that fills a 2D space. What we do next is we create
    a `THREE.Geometry` instance, and for each coordinate, we create a new vertex,
    which we push into the lines property of this instance. For each coordinate, we
    also calculate a color value that we use to set the `colors` property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第一部分 `var points = gosper(4, 60);` 用作获取一组 *x* 和 *y* 坐标的示例。这个函数返回一个 gosper
    曲线（更多信息，请查看 [http://en.wikipedia.org/wiki/Gosper_curve](http://en.wikipedia.org/wiki/Gosper_curve)），这是一个填充
    2D 空间的简单算法。接下来我们创建一个 `THREE.Geometry` 实例，对于每个坐标，我们创建一个新的顶点，并将其推入该实例的 lines 属性中。对于每个坐标，我们还计算一个颜色值，用于设置
    colors 属性。
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In this example, we''ve set the color using the `setHSL()` method. Instead
    of providing values for red, green, and blue, with HSL, we provide the hue, saturation,
    and lightness. Using HSL is much more intuitive than RGB, and it is much easier
    to create sets of matching colors. A very good explanation of HSL can be found
    in the CSS specification: [http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color](http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `setHSL()` 方法设置颜色。与提供红色、绿色和蓝色的值不同，使用 HSL，我们提供色调、饱和度和亮度。使用 HSL 比
    RGB 更直观，更容易创建匹配的颜色集。关于 HSL 的非常好的解释可以在 CSS 规范中找到：[http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color](http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color)。
- en: 'Now that we have our geometry, we can create `THREE.LineBasicMaterial` and
    use this together with the geometry to create a `THREE.Line` mesh. You can see
    the result in the `09-line-material.html` example. The following screenshot shows
    this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了几何体，我们可以创建 `THREE.LineBasicMaterial`，并将其与几何体一起使用，创建一个 `THREE.Line` 网格。你可以在
    `09-line-material.html` 示例中看到结果。以下截图显示了这个示例：
- en: '![THREE.LineBasicMaterial](graphics/2215OS_04_14.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LineBasicMaterial](graphics/2215OS_04_14.jpg)'
- en: The next and last material we'll discuss in this chapter is only slightly different
    from `THREE.LineBasicMaterial`. With `THREE.LineDashedMaterial`, not only can
    we color lines, but we can also add a *dash* effect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论的下一个和最后一个材质，与 `THREE.LineBasicMaterial` 仅略有不同。使用 `THREE.LineDashedMaterial`，我们不仅可以给线条上色，还可以添加*虚线*效果。
- en: THREE.LineDashedMaterial
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineDashedMaterial
- en: 'This material has the same properties as `THREE.LineBasicMaterial` and two
    additional ones you can use to define the dash width and the width of the gaps
    between the dashes, which are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材质与 `THREE.LineBasicMaterial` 具有相同的属性，还有两个额外的属性，可以用来定义虚线的宽度和虚线之间的间隙，如下所示：
- en: '| Name | Description |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `scale` | This scales `dashSize` and `gapSize`. If the scale is smaller than
    `1`, `dashSize` and `gapSize` increase, and if the scale is larger than `1`, `dashSize`
    and `gapSize` decrease. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '`scale` | 这会缩放 `dashSize` 和 `gapSize`。如果比例小于 `1`，`dashSize` 和 `gapSize` 会增加，如果比例大于
    `1`，`dashSize` 和 `gapSize` 会减少。'
- en: '| `dashSize` | This is the size of the dash. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `dashSize` | 这是虚线的大小。 |'
- en: '| `gapSize` | This is the size of the gap. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `gapSize` | 这是间隙的大小。 |'
- en: 'This material works almost exactly like `THREE.LineBasicMaterial`. Here''s
    how it works:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材质几乎与 `THREE.LineBasicMaterial` 完全相同。它的工作原理如下：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only difference is that you have to call `computeLineDistances()` (which
    is used to determine the distance between the vertices that make up a line). If
    you don''t do this, the gaps won''t be shown correctly. An example of this material
    can be found in `10-line-material-dashed.html` and looks like the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是你必须调用 `computeLineDistances()`（用于确定构成一条线的顶点之间的距离）。如果不这样做，间隙将无法正确显示。这种材质的示例可以在
    `10-line-material-dashed.html` 中找到，并且看起来像以下截图：
- en: '![THREE.LineDashedMaterial](graphics/2215OS_04_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LineDashedMaterial](graphics/2215OS_04_15.jpg)'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Three.js gives you a lot of materials you can use to skin your geometries. The
    materials range from the very simple `(THREE.MeshBasicMaterial`) to the complex
    `(THREE.ShaderMaterial`), where you can provide your own `vertexShader` and `fragmentShader`
    programs. Materials share a lot of basic properties. If you know how to use a
    single material, you'll probably also know how to use the other materials. Note
    that not all materials respond to the lights in your scene. If you want a material
    that takes lighting into effect, use `THREE.MeshPhongMaterial` or `THREE.MeshLamberMaterial`.
    Determining the effect of certain material properties just from code is very hard.
    Often, a good idea is to use a dat.GUI approach to experiment with these properties.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了许多可以用来渲染几何体的材质。这些材质从非常简单的 `(THREE.MeshBasicMaterial)` 到复杂的 `(THREE.ShaderMaterial)`
    都有，其中你可以提供自己的 `vertexShader` 和 `fragmentShader` 程序。材质共享许多基本属性。如果你知道如何使用单个材质，你可能也知道如何使用其他材质。请注意，并非所有材质都会对场景中的光源做出反应。如果你想要一个考虑光照效果的材质，可以使用
    `THREE.MeshPhongMaterial` 或 `THREE.MeshLamberMaterial`。仅仅通过代码来确定某些材质属性的效果是非常困难的。通常，一个好主意是使用
    dat.GUI 方法来尝试这些属性。
- en: 'Also, remember that most of the properties of a material can be modified at
    runtime. Some though (for example, `side`) can''t be modified at runtime. If you
    change such a value, you need to set the `needsUpdate` property to `true`. For
    a complete overview of what can and cannot be changed at runtime, see the following
    page: [https://github.com/mrdoob/three.js/wiki/Updates](https://github.com/mrdoob/three.js/wiki/Updates).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住大部分材质的属性都可以在运行时修改。但有些属性（例如 `side`）是不能在运行时修改的。如果你改变了这样的值，你需要将 `needsUpdate`
    属性设置为 `true`。关于在运行时可以和不可以改变的完整概述，请参考以下页面：[https://github.com/mrdoob/three.js/wiki/Updates](https://github.com/mrdoob/three.js/wiki/Updates)。
- en: In this and the previous chapters, we talked about geometries. We used these
    in our examples and explored a couple of them. In the next chapter, you'll learn
    everything about geometries and how you can work with them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章和前面的章节中，我们谈到了几何体。我们在示例中使用了它们并探索了其中一些。在下一章中，你将学习关于几何体的一切，以及如何与它们一起工作。
