- en: '*Chapter 10*: Creating PodSecurityPolicies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：创建PodSecurityPolicies'
- en: Most of the security discussed so far has focused on protecting Kubernetes APIs.
    Authentication has meant the authentication of API calls. Authorization has meant
    authorizing access to certain APIs. Even the discussion on the dashboard centered
    mostly around how to securely authenticate to the API server by way of the dashboard.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大部分讨论的安全重点都集中在保护Kubernetes API上。身份验证意味着对API调用进行身份验证。授权意味着授权访问某些API。即使在关于仪表板的讨论中，也主要集中在如何通过仪表板安全地对API服务器进行身份验证。
- en: This chapter will be different as we will now shift our focus to securing our
    nodes. We will learn how **PodSecurityPolicies** (**PSPs**) protect the nodes
    of a Kubernetes cluster. Our focus will be on how containers run on the nodes
    of your cluster and how to keep those containers from having more access than
    they should. We'll get into the details of impacts in this chapter by looking
    at how exploits can be used to gain access to a cluster when the nodes aren't
    protected. We'll also explore how these scenarios can be exploited even in code
    that doesn't need node access.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将会有所不同，因为我们现在将把重点转移到保护我们的节点上。我们将学习PodSecurityPolicies（PSPs）如何保护Kubernetes集群的节点。我们的重点将放在容器在集群节点上的运行方式，以及如何防止这些容器获得比它们应该拥有的更多访问权限。在本章中，我们将深入了解影响的细节，看看在节点没有受到保护时，如何利用漏洞来获取对集群的访问权限。我们还将探讨即使在不需要节点访问权限的代码中，这些情景如何被利用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a PSP?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是PSP？
- en: Aren't they going away?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会消失吗？
- en: Enabling pod security policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用pod安全策略
- en: Alternatives to PSPs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSP的替代方案
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples in this chapter, make sure you have a KinD cluster running
    with the configuration from [*Chapter 8*](B15514_08_Final_ASB_ePub.xhtml#_idTextAnchor228),
    *RBAC Policies and Auditing*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的示例，请确保您有一个使用[*第8章*](B15514_08_Final_ASB_ePub.xhtml#_idTextAnchor228)中的配置运行的KinD集群，*RBAC
    Policies and Auditing*。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter10](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter10).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter10](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter10)。
- en: What is a PodSecurityPolicy?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是PodSecurityPolicy？
- en: A PSP is a Kubernetes resource that allows you to set security controls for
    your workloads, allowing you to set limitations on what a pod can do. PSPs are
    evaluated before a pod is allowed to start up and if the pod attempts to do something
    that a PSP forbids, it will not be allowed to start.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PSP是一个Kubernetes资源，允许您为您的工作负载设置安全控制，允许您对pod的操作进行限制。PSP在pod被允许启动之前进行评估，如果pod尝试执行PSP禁止的操作，它将不被允许启动。
- en: Many people have experience with physical and virtual servers, and most know
    how to secure workloads running on them. Containers need to be considered differently
    when you talk about securing each workload. To understand why PSPs and other Kubernetes
    security tools such as the **Open Policy Agent** (**OPA**) exist, you need to
    understand how a container is different from a **virtual machine** (**VM**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人都有使用物理和虚拟服务器的经验，大多数人知道如何保护运行在它们上面的工作负载。当谈到保护每个工作负载时，容器需要被考虑得与众不同。要理解为什么存在PSPs和其他Kubernetes安全工具，如Open
    Policy Agent（OPA），您需要了解容器与虚拟机（VM）之间的区别。
- en: Understanding the difference between containers and VMs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器和虚拟机之间的区别
- en: '"*A container is a lightweight VM*" is often how containers are described to
    those new to containers and Kubernetes. While this makes for a simple analogy,
    from a security standpoint, it''s a dangerous comparison. A container at runtime
    is a process that runs on a node. On a Linux system, these processes are isolated
    by a series of Linux technologies that limit their visibility to the underlying
    system.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '"*容器是轻量级虚拟机*"经常是对于新接触容器和Kubernetes的人描述容器的方式。虽然这样做可以形成一个简单的类比，但从安全的角度来看，这是一个危险的比较。运行时的容器是在节点上运行的进程。在Linux系统上，这些进程通过一系列限制它们对底层系统的可见性的Linux技术进行隔离。'
- en: 'Go to any node in a Kubernetes cluster and run the **top** command and all
    of the processes from containers are listed. As an example, even though Kubernetes
    is running in KinD, running **ps -A -elf | grep java** will show the OpenUnison
    and operator container processes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中的任何节点上运行**top**命令，所有来自容器的进程都会被列出。例如，即使Kubernetes在KinD中运行，运行**ps
    -A -elf | grep java**将显示OpenUnison和operator容器进程：
- en: '![Figure 10.1 – Pod processes from the system console'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 从系统控制台的Pod进程'
- en: '](image/Fig_10.1_B15514.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_10.1_B15514.jpg)'
- en: Figure 10.1 – Pod processes from the system console
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 从系统控制台的Pod进程
- en: In contrast, a VM is, as the name implies, a complete virtual system. It emulates
    its own hardware, has an isolated kernel, and so on. The hypervisor provides isolation
    for VMs down to the silicone layer, whereas by comparison, there is very little
    isolation between every container on a node.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，虚拟机就像其名称所示，是一个完整的虚拟系统。它模拟自己的硬件，有独立的内核等。虚拟机监视器为虚拟机提供了从硅层到上层的隔离，而与此相比，在节点上的每个容器之间几乎没有隔离。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are container technologies that will run a container on their own VM.
    The container is still just a process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些容器技术可以在自己的虚拟机上运行容器。但容器仍然只是一个进程。
- en: When containers aren't running, they're simply a "tarball of tarballs," where
    each layer of the filesystem is stored in a file. The image is still stored on
    the host system, or multiple host systems, wherever the container has been run
    or pulled previously.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器没有运行时，它们只是一个"tarball of tarballs"，其中文件系统的每一层都存储在一个文件中。镜像仍然存储在主机系统上，或者之前容器曾经运行或被拉取的多个主机系统上。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A "tarball" is a file created by the **tar** Unix command. It can also be compressed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"tarball"是由**tar** Unix命令创建的文件。它也可以被压缩。'
- en: A VM, on the other hand, has its own virtual disk that stores the entire OS.
    While there are some very lightweight VM technologies, there's often an order
    of magnitude's difference in the size between a VM and a container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，虚拟机有自己的虚拟磁盘，存储整个操作系统。虽然有一些非常轻量级的虚拟机技术，但虚拟机和容器之间的大小差异通常是数量级的。
- en: While some people refer to containers as lightweight VMs, that couldn't be further
    from the truth. They aren't isolated in the same way and require more attention
    to be paid to the details of how they are run on a node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人将容器称为轻量级虚拟机，但事实并非如此。它们的隔离方式不同，并且需要更多关注它们在节点上的运行细节。
- en: From this section, you may think that we are trying to say that containers are
    not secure. Nothing could be further from the truth. Securing a Kubernetes cluster,
    and the containers running on it, requires attention to detail and an understanding
    of how containers differ from VMs. Since so many people do understand VMs, it's
    easy to attempt to compare them to containers, but doing so puts you at a disadvantage
    since they are very different technologies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一部分，你可能会认为我们在试图说容器不安全。事实恰恰相反。保护Kubernetes集群和其中运行的容器需要注意细节，并且需要理解容器与虚拟机的不同之处。由于很多人都了解虚拟机，因此很容易尝试将其与容器进行比较，但这样做会让你处于不利地位，因为它们是非常不同的技术。
- en: Once you understand the limitations of a default configuration and the potential
    dangers that come from it, you can remediate the "issues."
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了默认配置的限制和由此带来的潜在危险，您就可以纠正这些“问题”。
- en: Container breakouts
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器越狱
- en: 'A container breakout is when the process of your container gets access to the
    underlying node. Once on the node, an attacker now has access to all the other
    pods and any capability the node has in your environment. A breakout can also
    be a matter of mounting the local filesystem into your container. An example from
    [https://securekubernetes.com](https://securekubernetes.com), originally pointed
    out by Duffie Cooley from VMware, uses a container to mount the local filesystem.
    Running this on a KinD cluster opens both reads and writes to the node''s filesystem:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器越狱是指您的容器进程获得对底层节点的访问权限。一旦在节点上，攻击者现在可以访问所有其他的pod和环境中节点的任何功能。越狱也可能是将本地文件系统挂载到您的容器中。来自[https://securekubernetes.com](https://securekubernetes.com)的一个例子，最初由VMware的Duffie
    Cooley指出，使用一个容器来挂载本地文件系统。在KinD集群上运行这个命令会打开对节点文件系统的读写权限：
- en: 'kubectl run r00t --restart=Never -ti --rm --image lol --overrides ''{"spec":{"hostPID":
    true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin":
    true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'''
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'kubectl run r00t --restart=Never -ti --rm --image lol --overrides ''{"spec":{"hostPID":
    true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin":
    true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'''
- en: If you don't see a command prompt, try pressing Enter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到命令提示符，请尝试按Enter键。
- en: 'The **run** command in the preceding code started a container that added an
    option that is key to the example, **hostPID: true**, which allows the container
    to share the host''s process namespace. You may see a few other options, such
    as **–mount** and a security context setting that sets **privileged** to **true**.
    All of the options combined will allow us to write to the host''s filesystem.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '上面代码中的**run**命令启动了一个容器，并添加了一个关键选项**hostPID: true**，允许容器共享主机的进程命名空间。您可能会看到一些其他选项，比如**–mount**和一个将**privileged**设置为**true**的安全上下文设置。所有这些选项的组合将允许我们写入主机的文件系统。'
- en: 'Now that you are in the container, execute the **ls** command to look at the
    filesystem. Notice how the prompt is **root@r00t:/#**, confirming you are in the
    container and not on the host:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你在容器中，执行**ls**命令查看文件系统。注意提示符是**root@r00t:/#**，确认你在容器中而不是在主机上：
- en: root@r00t:/# ls
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: root@r00t:/# ls
- en: '**bin  boot  build  dev  etc  home  kind  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**bin  boot  build  dev  etc  home  kind  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var**'
- en: 'To prove that we have mapped the host''s filesystem to our container, create
    a file called **this is from a container** and exit the container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们已经将主机的文件系统映射到我们的容器中，创建一个名为**this is from a container**的文件，然后退出容器：
- en: root@r00t:/# touch this_is_from_a_container
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: root@r00t:/# touch this_is_from_a_container
- en: root@r00t:/# exit
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: root@r00t:/# 退出
- en: 'Finally, let''s look at the host''s filesystem to see whether the container
    created the file. Since we are running KinD with a single worker node, we need
    to use Docker to **exec** into the worker node. If you are using the KinD cluster
    from the book, the worker node is called **cluster01-worker**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们查看主机的文件系统，看看容器是否创建了文件。由于我们正在运行KinD，只有一个工作节点，我们需要使用Docker **exec**进入工作节点。如果您正在使用本书中的KinD集群，工作节点被称为**cluster01-worker**：
- en: docker exec -ti cluster01-worker ls /
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: docker exec -ti cluster01-worker ls /
- en: '**bin  boot  build  dev  etc  home  kind  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  this_is_from_a_container  tmp  usr  var**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**bin  boot  build  dev  etc  home  kind  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  this_is_from_a_container  tmp  usr  var**'
- en: There it is! In this example, a container was run that mounted the local filesystem.
    From inside of the pod, the **this_is_from_a_container** file was created. After
    exiting the pod and entering the node container, the file was there. Once an attacker
    has access to the node's filesystem, they also have access to the kubelet's credentials,
    which can open the entire cluster up.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，运行了一个容器，挂载了本地文件系统。在pod内部，创建了**this_is_from_a_container**文件。退出pod并进入节点容器后，文件就在那里。一旦攻击者可以访问节点的文件系统，他们也可以访问kubelet的凭据，这可能会打开整个集群。
- en: 'It''s not hard to envision a string of events that can lead to a Bitcoin miner
    (or worse) running on a cluster. A phishing attack gets the credentials a developer
    is using for their cluster. Even though those credentials only have access to
    one namespace, a container is created to get the kubelet''s credentials, and from
    there, containers are launched to stealthily deploy miners across the environment.
    There are certainly multiple mitigations that could be used to prevent this attack,
    including the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想象一系列事件会导致比特币矿工（或更糟）在集群上运行。钓鱼攻击获取了开发人员用于他们集群的凭据。尽管这些凭据只能访问一个命名空间，但还是创建了一个容器来获取kubelet的凭据，然后启动容器在环境中秘密部署矿工。当然，有多种缓解措施可以用来防止这种攻击，包括以下措施：
- en: Multi-factor authentication, which would have kept the phished credentials from
    being used
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多因素身份验证可以防止被钓鱼凭据被使用
- en: Pre-authorizing only certain containers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只预授权特定容器
- en: A PSP, which would have prevented this attack by stopping a container from running
    as **privileged**
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSP可以阻止容器以**privileged**身份运行，从而阻止这种攻击
- en: A properly secured base image
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个经过适当保护的基本镜像
- en: At the core of security is a properly designed image. In the case of physical
    machines and VMs, this is accomplished by securing the base OS. When you install
    an OS, you don't select every possible option during installation. It is considered
    poor practice to have anything running on a server that is not required for its
    role or function. This same practice needs to be carried over to the images that
    will run on your clusters, which should only contain the necessary binaries that
    are required for your application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的核心是一个经过适当设计的镜像。对于物理机和虚拟机来说，这是通过保护基本操作系统来实现的。当你安装操作系统时，你不会在安装过程中选择每一个可能的选项。在服务器上运行任何不需要的东西被认为是不良实践。这种做法需要延续到将在集群上运行的镜像，它们应该只包含应用程序所需的必要二进制文件。
- en: Given how important it is to properly secure images on your cluster, the next
    section explores container design from a security standpoint. Building a locked-down
    container makes managing the security of the nodes much easier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在集群上适当保护镜像的重要性，下一节将从安全的角度探讨容器设计。构建一个安全的容器可以更容易地管理节点的安全。
- en: Properly designing containers
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当设计容器
- en: Before exploring how to build a **PodSecurityPolicy**, it's important to address
    how containers are designed. Often, the hardest part of using a **PodSecurityPolicy**
    to mitigate attacks on the node is the fact that so many containers are built
    and run as root. Once a restricted policy is applied, the container stops running.
    This is problematic at multiple levels. System administrators have learned over
    the decades of networked computing not to run processes as root, especially services
    such as web servers that are accessed anonymously over untrusted networks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨如何构建**PodSecurityPolicy**之前，重要的是要解决容器的设计方式。通常，使用**PodSecurityPolicy**来减轻对节点的攻击最困难的部分在于，许多容器都是以root用户构建和运行的。一旦应用了受限策略，容器就会停止运行。这在多个层面上都是有问题的。系统管理员在几十年的网络计算中学到，不要以root用户身份运行进程，特别是那些通过不受信任的网络匿名访问的web服务器等服务。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All networks should be considered "untrusted." Assuming all networks are hostile
    leads to a more secure approach to implementation. It also means that services
    that need security need to be authenticated. This concept is called zero trust.
    It has been used and advocated by identity experts for years but was popularized
    in the DevOps and cloud native worlds by Google's BeyondCorp whitepaper ([https://cloud.google.com/beyondcorp](https://cloud.google.com/beyondcorp)).
    The concept of zero trust should apply inside your clusters too!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络都应被视为“不受信任的”。假设所有网络都是敌对的，会导致更安全的实施方法。这也意味着需要安全性的服务需要进行身份验证。这个概念被称为零信任。身份专家多年来一直在使用和倡导这个概念，但是在DevOps和云原生领域，谷歌的BeyondCorp白皮书（[https://cloud.google.com/beyondcorp](https://cloud.google.com/beyondcorp)）使其更为流行。零信任的概念也应该适用于您的集群内部！
- en: Bugs in code can lead to access to underlying compute resources, which can then
    lead to breakouts from a container. Running as root in a privileged container
    when not needed can lead to a breakout if exploited via a code bug.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的漏洞可能导致对底层计算资源的访问，然后可能从容器中突破出去。如果通过代码漏洞利用，不需要时以特权容器的root身份运行可能会导致突破。
- en: The Equifax breach in 2017 used a bug in the Apache Struts web application framework
    to run code on the server that was then used to infiltrate and extract data. Had
    this vulnerable web application been running on Kubernetes with a privileged container,
    the bug could have led to the attackers gaining access to the cluster.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年的Equifax泄露事件利用了Apache Struts web应用程序框架中的一个漏洞，在服务器上运行代码，然后用于渗透和提取数据。如果这个有漏洞的web应用程序在Kubernetes上以特权容器运行，这个漏洞可能会导致攻击者获取对集群的访问权限。
- en: 'When building containers, at a minimum, the following should be observed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器时，至少应遵守以下规定：
- en: '**Run as a user other than root**: The vast majority of applications, especially
    micro services, don''t need root. Don''t run as root.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以非root用户身份运行**：绝大多数应用程序，特别是微服务，不需要root权限。不要以root用户身份运行。'
- en: '**Only write to volumes**: If you don''t write to a container, you don''t need
    write access. Volumes can be controlled by Kubernetes. If you need to write temporary
    data, use an **emptyVolume** object instead of writing to the container''s filesystem.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只写入卷**：如果不向容器写入，就不需要写入访问权限。卷可以由Kubernetes控制。如果需要写入临时数据，可以使用**emptyVolume**对象，而不是写入容器的文件系统。'
- en: '**Minimize binaries in your container**: This can be tricky. There are those
    that advocate for "distro-less" containers that only contain the binary for the
    application, statically compiled. No shells, no tools. This can be problematic
    when trying to debug why an application isn''t running as expected. It''s a delicate
    balance.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化容器中的二进制文件**：这可能有些棘手。有人主张使用“无发行版”的容器，只包含应用程序的二进制文件，静态编译。没有shell，没有工具。当尝试调试应用程序为何不按预期运行时，这可能会有问题。这是一个微妙的平衡。'
- en: '**Scan containers for known Common Vulnerability Exposures (CVEs); rebuild
    often**: One of the benefits of a container is that it can be easily scanned for
    known CVEs. There are several tools and registries that will do this for you.
    Once CVEs have been patched, rebuild. A container that hasn''t been rebuilt in
    months, or years even, is every bit as dangerous as a server that hasn''t been
    patched.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描已知的常见漏洞暴露（CVE）的容器；经常重建**：容器的一个好处是可以轻松地扫描已知的CVE。有几种工具和注册表可以为您执行此操作。一旦CVE已修补，就进行重建。几个月甚至几年没有重建的容器与未打补丁的服务器一样危险。'
- en: Important Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Scanning for CVEs is a standard way to report security issues. Application and
    OS vendors will update CVEs with patches to their code that fix the issues. This
    information is then used by security scanning tools to act on when a container
    has a known issue that has been patched.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描CVE是报告安全问题的标准方法。应用程序和操作系统供应商将使用修补程序更新CVE，以修复问题。然后，安全扫描工具将使用此信息来处理已修补的已知问题的容器。
- en: At the time of writing, the most restrictive defaults for any Kubernetes distribution
    on the market belong to Red Hat's OpenShift. In addition to sane default policies,
    OpenShift runs pods with a random user ID, unless the pod definition specifies
    an ID.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，市场上任何Kubernetes发行版中最严格的默认设置属于红帽的OpenShift。除了合理的默认策略外，OpenShift会以随机用户ID运行pod，除非pod定义指定了ID。
- en: It's a good idea to test your containers on OpenShift, even if it's not your
    distribution for production use. If a container will run on OpenShift, it's likely
    to work with almost any security policy a cluster can throw at it. The easiest
    way to do this is with Red Hat's CodeReady Containers ([https://developers.redhat.com/products/codeready-containers](https://developers.redhat.com/products/codeready-containers)).
    This tool can run on your local laptop and launches a minimal OpenShift environment
    that can be used for testing containers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenShift上测试您的容器是个好主意，即使它不是您用于生产的发行版。如果一个容器能在OpenShift上运行，它很可能能够适用于集群可以应用的几乎任何安全策略。最简单的方法是使用红帽的CodeReady
    Containers（[https://developers.redhat.com/products/codeready-containers](https://developers.redhat.com/products/codeready-containers)）。这个工具可以在您的本地笔记本电脑上运行，并启动一个可以用于测试容器的最小OpenShift环境。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While OpenShift has very tight security controls out of the box, it doesn't
    use PSPs. It has its own policy system that pre-dates PSPs, called **Security
    Context Constraints** (**SCCs**). SCCs are similar to PSPs but don't use RBAC
    for associating with pods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OpenShift在出厂时具有非常严格的安全控制，但它不使用PSP。它有自己的策略系统，早于PSP，称为**安全上下文约束**（**SCCs**）。SCCs类似于PSP，但不使用RBAC与pod关联。
- en: PSP details
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PSP详细信息
- en: PSPs are tightly bound to how Linux processes run. The policy itself is a list
    of potential options any Linux process can have.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PSP与Linux进程运行方式紧密相关。策略本身是任何Linux进程可能具有的潜在选项列表。
- en: 'A PSP has several categories of privileges:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PSP具有几个特权类别：
- en: '**Privilege**: Does the pod need to run as a privileged pod? Does the pod need
    to do something that will change the underlying OS or environment?'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特权**：pod是否需要作为特权pod运行？pod是否需要执行会更改底层操作系统或环境的操作？'
- en: '**Host interaction**: Does the pod need to interact with the host directly?
    For instance, does it need host filesystem access?'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机交互**：pod是否需要直接与主机交互？例如，它是否需要主机文件系统访问？'
- en: '**Volume types**: What kind of volumes can this pod mount? Do you want to limit
    it to specific volumes such as secrets but not disks?'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷类型**：这个pod可以挂载什么类型的卷？您是否希望将其限制为特定卷，如密钥，而不是磁盘？'
- en: '**User context**: What user will the process be allowed to run as? In addition
    to determining the allowed user ID and group ID ranges, SELinux and AppArmor contexts
    can be set as well.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户上下文：**进程允许以哪个用户身份运行？除了确定允许的用户ID和组ID范围外，还可以设置SELinux和AppArmor上下文。'
- en: 'A simple, unprivileged policy might look as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的非特权策略可能如下所示：
- en: 'apiVersion: policy/v1beta1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：policy/v1beta1
- en: 'kind: PodSecurityPolicy'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：PodSecurityPolicy
- en: 'metadata:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: pod-security-policy-default'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：pod-security-policy-default
- en: 'spec:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'fsGroup:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: fsGroup：
- en: 'rule: ''MustRunAs'''
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：'必须以此身份运行'
- en: 'ranges:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 范围：
- en: Forbid adding the root group.
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁止添加根组。
- en: '- min: 1'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '- 最小值：1'
- en: 'max: 65535'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：65535
- en: 'runAsUser:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: runAsUser：
- en: 'rule: ''MustRunAs'''
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：'必须以此身份运行'
- en: 'ranges:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 范围：
- en: Forbid adding the root group.
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁止添加根组。
- en: '- min: 1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '- 最小值：1'
- en: 'max: 65535'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：65535
- en: 'seLinux:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: seLinux：
- en: 'rule: RunAsAny'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：RunAsAny
- en: 'supplementalGroups:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助组：
- en: 'rule: ''MustRunAs'''
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：'必须以此身份运行'
- en: 'ranges:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 范围：
- en: Forbid adding the root group.
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁止添加根组。
- en: '- min: 1'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '- 最小值：1'
- en: 'max: 65535'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：65535
- en: 'volumes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 卷：
- en: '- emptyDir'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '- 空目录'
- en: '- secret'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '- 机密'
- en: '- configMap'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '- 配置映射'
- en: '- persistentVolumeClaim'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '- 持久卷索赔'
- en: The spec doesn't mention whether the containers can be privileged, nor does
    it mention any resources from the host that can be accessed. This means that if
    the pod definition attempts to mount the host's filesystem directly or to start
    as root, the pod will fail. Any permissions must be explicitly enabled in order
    for a pod to use them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中没有提到容器是否可以具有特权，也没有提到可以访问主机的任何资源。这意味着如果pod定义尝试直接挂载主机的文件系统或以root身份启动，pod将失败。必须显式启用任何权限，以便pod使用它们。
- en: This policy limits which users a pod can run to anything except root by specifying
    the **MustRunAs** option, which is set to between **1** and **65535**; it does
    not include user 0 (root).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略限制了pod可以以任何用户身份运行，除了root之外，还指定了**MustRunAs**选项，该选项设置为**1**和**65535**之间；不包括用户0（root）。
- en: Finally, the policy allows the mounting of standard volume types that most pods
    might need. Few, if any, pods need to be able to mount the node's filesystem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该策略允许挂载大多数pod可能需要的标准卷类型。很少有pod需要能够挂载节点的文件系统。
- en: 'Having this policy in place would have stopped the breakout we used earlier
    to get access to the node''s filesystem. Here''s a YAML of the pod we tried running
    earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有这样的策略，我们之前用来访问节点文件系统的突破将被阻止。以下是我们之前尝试运行的pod的YAML：
- en: '---'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: 'spec:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: '**hostPID: true**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**hostPID：true**'
- en: 'containers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 容器：
- en: '- name: ''1'''
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '- 名称：''1'''
- en: 'image: alpine'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像：alpine
- en: 'command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 命令：
- en: '- nsenter'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '- nsenter'
- en: '- "--mount=/proc/1/ns/mnt"'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '- "--mount=/proc/1/ns/mnt"'
- en: '- "--"'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '- "--"'
- en: '- "/bin/bash"'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '- "/bin/bash"'
- en: 'stdin: true'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入：true
- en: 'tty: true'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: tty：true
- en: 'imagePullPolicy: IfNotPresent'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像拉取策略：IfNotPresent
- en: '**securityContext:**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全上下文：**'
- en: '**      privileged: true**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**      特权：true**'
- en: 'There are two highlighted settings. The first is **hostPID**, which lets the
    pod share the process ID space with the node. One of the technologies used by
    the Linux kernel to enable containers is cgroups, which isolate processes in containers.
    In Linux, cgroups will give processes in containers a different process ID than
    what it would be if simply run on the node. As shown, the processes for all containers
    can be viewed from the node. Running **ps -A -elf | grep java** from inside the
    pod will have a different ID than what''s coming from the node. Since the **hostPID**
    option wasn''t set to **true** on our policy, the **PodSecurityPolicy** enforcement
    webhook would reject this pod:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个突出显示的设置。第一个是**hostPID**，它允许pod与节点共享进程ID空间。Linux内核用于启用容器的技术之一是cgroups，它隔离容器中的进程。在Linux中，cgroups将为容器中的进程提供与在节点上简单运行时不同的进程ID。如所示，可以从节点查看所有容器的进程。从pod内部运行**ps
    -A -elf | grep java**将得到与来自节点的不同ID。由于我们的策略上没有将**hostPID**选项设置为**true**，**PodSecurityPolicy**执行webhook将拒绝此pod：
- en: '![Figure 10.2 – Process ID from the host and from inside a container'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2-来自主机和容器内的进程ID'
- en: '](image/Fig_10.2_B15514.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_10.2_B15514.jpg)'
- en: Figure 10.2 – Process ID from the host and from inside a container
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2-来自主机和容器内的进程ID
- en: The next highlighted portion is the security context setting privileged to **true**.
    These two settings will allow the container to run as if it's a root user logged
    into a node. Again, the default PSP would have stopped this because privilege
    wasn't enabled. The PSP controller would stop it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个突出显示的部分是将安全上下文设置为true的特权。这两个设置将允许容器运行，就好像它是作为根用户登录到节点一样。再次强调，默认的PSP会阻止这一点，因为特权未启用。PSP控制器会阻止它。
- en: 'Next, examine the NGINX Ingress controller''s recommended PSP from [https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/docs/examples/psp/psp.yaml](https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/docs/examples/psp/psp.yaml):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看NGINX Ingress控制器从[https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/docs/examples/psp/psp.yaml](https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/docs/examples/psp/psp.yaml)推荐的PSP：
- en: 'apiVersion: policy/v1beta1'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: policy/v1beta1'
- en: 'kind: PodSecurityPolicy'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: PodSecurityPolicy'
- en: 'metadata:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '.spec:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '.spec:'
- en: '**allowedCapabilities:**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**allowedCapabilities:**'
- en: '**  - NET_BIND_SERVICE**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**  - NET_BIND_SERVICE**'
- en: '**  allowPrivilegeEscalation: true**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**  allowPrivilegeEscalation: true**'
- en: .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: 'hostPID: false'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'hostPID: false'
- en: '**hostPorts:**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**hostPorts:**'
- en: '**  - min: 80**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**  - min: 80**'
- en: '**    max: 65535**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**    max: 65535**'
- en: In a typical web server running on a host, the process will start as root (or
    at least a privileged user), then downgrades itself to an unprivileged user so
    that it can open ports **80** and **443** for HTTP and HTTPS. These ports are
    under **1024** and so are reserved in Linux for root processes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行在主机上的典型Web服务器中，进程将以root（或至少是特权用户）启动，然后降级为非特权用户，以便它可以打开端口80和443用于HTTP和HTTPS。这些端口在Linux中保留给root进程，因此位于1024以下。
- en: If you're wondering whether a web server needs to be able to run on ports **80**
    or **443** in Kubernetes, it doesn't. As discussed earlier in this book, the vast
    majority of deployments have a load balancer in front of them that can map **80**
    and **443** to any port. This should really be an exception, not the rule. The
    NGINX Ingress controller was released at a time when security wasn't as front
    and center in Kubernetes as it is today. Also, deployment models weren't quite
    as mature.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道在Kubernetes中是否需要能够在端口80或443上运行Web服务器，实际上并不需要。正如本书前面讨论的那样，绝大多数部署都有一个负载均衡器在它们前面，可以将80和443端口映射到任何端口。这应该真的是一个例外，而不是规则。NGINX
    Ingress控制器是在安全性在Kubernetes中并不像今天这样重要的时候发布的。此外，部署模型并不是那么成熟。
- en: To allow similar behavior as an NGINX web server would have running directly
    on a host, NGINX wants to be able to open ports from **80** up and escalate to
    privileged, specifically using the **NET_BIND_SERVICE** privilege so that the
    web server can open ports **80** and **443** without running the entire process
    as root.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许类似于NGINX Web服务器直接在主机上运行的行为，NGINX希望能够从80端口开始打开端口，并升级为特权用户，具体使用NET_BIND_SERVICE特权，以便Web服务器可以在不以root身份运行整个进程的情况下打开端口80和443。
- en: As discussed earlier, the vast majority of containers do not need special privileges.
    Instances of getting access to these special privileges should be few and far
    between and need to be reserved only for specific use cases. When evaluating systems
    that may run on a cluster, it's important to see whether the vendor or project
    provides a PSP that's been tested to work. If not, assume it is unprivileged and
    use the tools discussed later in this chapter to debug a specific policy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，绝大多数容器不需要特殊权限。获得这些特殊权限的情况应该很少，并且只应该为特定用例保留。在评估可能在集群上运行的系统时，重要的是要看供应商或项目是否提供了经过测试的PSP。如果没有，就假设它是无特权的，并使用本章后面讨论的工具来调试特定策略。
- en: Assigning a PSP
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配PSP
- en: 'Once a policy is designed, it needs to be assigned. This is often the hardest
    part of deploying PSPs. The mechanism for determining whether a PSP is applied
    to a pod is the union of two sets of permissions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 设计策略后，需要进行分配。这通常是部署PSP最困难的部分。确定PSP是否应用于Pod的机制是两组权限的并集：
- en: '**The user that submitted the pod**: This can get tricky as users rarely submit
    pods directly. The best practice is to create a **Deployment** or a **StatefulSet**.
    Controllers then create Pods (though not directly). The user that "creates" the
    pod is the correct controller''s service account, not the user that submitted
    the **Deployment** or **StatefulSet**. This can mean that usually only one or
    two service accounts ever actually create pods.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交Pod的用户**：这可能会变得棘手，因为用户很少直接提交Pod。最佳做法是创建一个**Deployment**或**StatefulSet**。控制器然后创建Pod（虽然不是直接创建）。"创建"Pod的用户是正确的控制器服务账户，而不是提交**Deployment**或**StatefulSet**的用户。这意味着通常只有一个或两个服务账户实际上创建Pod。'
- en: '**The service account the pod runs as**: Each pod can define a service account
    that the pod can run as. This service account is scoped at the pod level, not
    on individual containers.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod运行的服务账户**：每个Pod可以定义一个服务账户来运行。这个服务账户的范围是在Pod级别上，而不是在单个容器上。'
- en: By "union," Kubernetes will combine these permissions to determine which capabilities
    are to be allowed. For instance, if the controller's service account that submitted
    the pod has no privileges, but the service account for the pod can run as root,
    then the *best* policy will be chosen to apply to the pod that allows the pod
    to run as root. This process can be confusing and difficult to debug, and can
    often create unexpected results. A policy cannot be directly requested by a pod;
    it has to be assigned. It is important to keep policies constrained to make it
    more likely that the correct policy is applied.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过"并集"，Kubernetes将结合这些权限来确定允许哪些功能。例如，如果提交Pod的控制器服务账户没有特权，但Pod的服务账户可以以root身份运行，那么将选择应用于Pod的*最佳*策略，允许Pod以root身份运行。这个过程可能令人困惑和难以调试，并且经常会产生意想不到的结果。Pod不能直接请求策略；它必须被分配。将策略限制在一定范围内是很重要的，这样更有可能应用正确的策略。
- en: Policies are evaluated and applied using special RBAC objects. Just as with
    the policy objects created to authorize access to APIs, both a **Role**/**ClusterRole**
    and a **RoleBinding**/**ClusterRoleBinding** need to be created. Instead of applying
    to specific APIs, RBAC objects that apply to **PodSecurityPolicy** objects use
    the **apiGroups** of **policy**, the resources of PSPs, and the **use** verb.
    The **use** verb doesn't have any corresponding HTTP action. The binding objects
    are generally the same as when authorizing API usage, but the subjects are generally
    service accounts, not users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用特殊的RBAC对象进行评估和应用的。就像创建用于授权对API的访问的策略对象一样，需要创建**Role**/**ClusterRole**和**RoleBinding**/**ClusterRoleBinding**。RBAC对象不适用于特定的API，而是适用于**PodSecurityPolicy**对象的**apiGroups**、PSPs的资源和**use**动词。**use**动词没有任何对应的HTTP动作。绑定对象通常与授权API使用时相同，但主体通常是服务账户，而不是用户。
- en: 'The first policy created previously is a good generic minimum access policy.
    To apply it across the cluster, first create a **ClusterRole**:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 先前创建的第一个策略是一个很好的通用最低访问策略。要在整个集群中应用它，首先创建一个**ClusterRole**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRole'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRole
- en: 'metadata:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: default-psp'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：default-psp
- en: 'rules:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '- api组：'
- en: '- policy'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '- 策略'
- en: 'resourceNames:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 资源名称：
- en: '- **pod-security-policy-default**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '- **pod-security-policy-default**'
- en: 'resources:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：
- en: '- podsecuritypolicies'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '- podsecuritypolicies'
- en: 'verbs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：
- en: '- use'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '- use'
- en: 'The **resourceNames** section is the only part of the policy that is specific
    to the PSP being referenced. Everything else in the policy is boilerplate. The
    **ClusterRoleBinding** will apply this across the cluster:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**resourceNames**部分是特定于所引用的PSP的策略的唯一部分。策略中的其他所有内容都是样板文件。**ClusterRoleBinding**将在整个集群中应用这一点：'
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRoleBinding'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: default-psp'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：default-psp
- en: 'roleRef:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: roleRef：
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: api组：rbac.authorization.k8s.io
- en: 'kind: ClusterRole'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRole
- en: 'name: default-psp'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：default-psp
- en: 'subjects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 主体：
- en: '- apiGroup: rbac.authorization.k8s.io'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- api组：rbac.authorization.k8s.io'
- en: 'kind: Group'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：组
- en: 'name: system:authenticated'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：system:authenticated
- en: When new pods are created, if no other policy applies, then the restricted policy
    will be used.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新的pod时，如果没有其他策略适用，则将使用受限策略。
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're coming from the OpenShift ecosystem and are used to using SCCs, the
    authorization process is different. SCCs contain information on who is authorized
    directly on the object, whereas **PodSecurityPolicy** objects rely on RBAC.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自OpenShift生态系统并且习惯使用SCCs，则授权过程是不同的。SCCs包含了直接授权对象的信息，而**PodSecurityPolicy**对象依赖于RBAC。
- en: Aren't they going away?
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们不会消失吗？
- en: 'When Kubernetes 1.11 was released in 2018, it was revealed that PSPs will likely
    never go **General Availability** (**GA**). This revelation was based on feedback
    that PSPs were difficult to use and the issues were systemic from their design.
    The discussion that came out of this revelation focused on three potential solutions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年发布Kubernetes 1.11时，人们发现PSPs可能永远不会成为**通用可用性**（**GA**）。这一发现是基于PSPs难以使用以及设计上的系统性问题的反馈。这一发现引发的讨论集中在三个潜在的解决方案上：
- en: '**Fix PSPs/reimplement a new standard**: These two options are bundled together
    because it''s believed "fixing" PSPs will result in a standard that breaks backward-compatibility,
    resulting in a new policy system. Another option that''s been floated is to port
    OpenShift''s SCC implementation upstream.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修复PSPs/重新实施新标准**：这两个选项被捆绑在一起，因为人们认为“修复”PSPs将导致一个打破向后兼容性的标准，从而导致一个新的策略系统。另一个被提出的选项是将OpenShift的SCC实现移植到上游。'
- en: '**Remove PSPs**: An argument has been made that this should be implementation-specific
    and so up to the implementer. Since PSPs are implemented using an admission controller,
    the argument is that this can be left to third parties.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除PSPs**：有人认为这应该是特定于实施的，因此由实施者决定。由于PSP是使用准入控制器实施的，有人认为这可以留给第三方。'
- en: '**Provide a "basic" implementation**: This is a hybrid approach where the upstream
    Kubernetes build supports a subset of PSPs and relies on custom admission controllers
    to support more advanced implementations.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供“基本”实现**：这是一种混合方法，其中上游Kubernetes构建支持PSP的子集，并依赖于自定义准入控制器来支持更高级的实现。'
- en: There have not been any clear favorites as to which direction to go. What has
    been made clear is that PSPs will not be deprecated and removed until well after
    a replacement has become generally available. With Kubernetes 1.19, a new policy
    of not allowing APIs to remain in alpha or beta mode for more than three releases
    has forced the **PodSecurityPolicy** API to be deprecated. The API won't be removed
    until version 1.22, which isn't scheduled for release until January 2023 at the
    earliest (assuming at least 6 months between releases).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有明确的偏爱方向。已经明确的是，直到有替代方案普遍可用之后，PSPs才不会被弃用和移除。随着Kubernetes 1.19的推出，不允许API在alpha或beta模式下超过三个版本的新政策迫使**PodSecurityPolicy**
    API被弃用。该API直到1.22版本才会被移除，而这至少要等到2023年1月发布（假设每次发布之间至少有6个月的时间）。
- en: 'There are multiple approaches for protecting against an eventual deprecation
    of PSPs:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以保护免受PSP最终被弃用的影响：
- en: '**Don''t use them at all**: This isn''t a great approach. It leaves the nodes
    of a cluster open.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全不使用它们**：这不是一个好方法。这会让集群的节点处于开放状态。'
- en: '**Avoid ad hoc policies**: Automating the policy application process will make
    it easier to move to whatever replaces PSPs.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免临时政策**：自动化政策应用过程将使迁移到PSP替代方案更容易。'
- en: '**Use another technology**: There are other options for PSP implementations
    that will be covered in the *Alternatives to PSPs* section.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用其他技术**：有其他PSP实现选项，将在*替代PSPs*部分进行介绍。'
- en: 'Make a decision on PSPs based on your implementation needs. To stay updated
    on the progress of PSPs, watch the issue on GitHub: [https://github.com/kubernetes/enhancements/issues/5](https://github.com/kubernetes/enhancements/issues/5).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的实施需求对PSP做出决定。要了解PSP的进展，请关注GitHub上的问题：[https://github.com/kubernetes/enhancements/issues/5](https://github.com/kubernetes/enhancements/issues/5)。
- en: Enabling PSPs
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用PSPs
- en: 'Enabling PSPs is very simple. Adding **PodSecurityPolicy** to the API server''s
    list of admission controllers will send all newly created Pod objects through
    the **PodSecurityPolicy** admission controller. This controller does two things:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 启用PSPs非常简单。将**PodSecurityPolicy**添加到API服务器的准入控制器列表中，将所有新创建的Pod对象发送到**PodSecurityPolicy**准入控制器。该控制器有两个作用：
- en: '**Identifies the best policy**: The best policy to use is identified by the
    capabilities requested by a pod''s definition. A pod cannot explicitly state which
    policy it wants to enforce, only what capabilities it wants.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定最佳策略**：所请求的功能决定了要使用的最佳策略。一个Pod不能明确说明它想要强制执行哪个策略，只能说明它想要什么功能。'
- en: '**Determines whether the Pod''s policy is authorized**: Once a policy is identified,
    the admission controller needs to determine whether the creator of the pod or
    the **serviceAccount** of the pod is authorized to use that policy.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定Pod的策略是否被授权**：一旦确定了策略，准入控制器需要确定Pod的创建者或Pod的**serviceAccount**是否被授权使用该策略。'
- en: The combination of these two criteria can lead to unexpected results. The creator
    of the pod isn't the user that submits the **Deployment** or **StatefulSet** definition.
    There's a controller that watches for **Deployment** updates and creates a **ReplicaSet**.
    There is a controller that watches for **ReplicaSet** objects and creates (**Pod)**
    objects. So, instead of the user who created the **Deployment** being the one
    that needs to be authorized, the **serviceAccount** for the **ReplicaSet** controller
    is. It's typical for blog posts and many default configurations to assign a privileged
    policy to all of the **ServiceAccount** objects in the **kube-system** namespace.
    This includes the **ServiceAccount** that the **ReplicaSet** controller runs as,
    which means it could create a pod with a privileged PSP without the creator of
    the **Deployment** or the **serviceAccount** of the pod being authorized to do
    so. It's important to press on your vendors to provide certified PSP definitions
    that have been tested.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个标准的结合可能导致意想不到的结果。创建pod的人不是提交**Deployment**或**StatefulSet**定义的用户。有一个控制器监视**Deployment**更新并创建**ReplicaSet**。有一个控制器监视**ReplicaSet**对象并创建（**Pod**）对象。因此，需要授权的不是创建**Deployment**的用户，而是**ReplicaSet**控制器的**serviceAccount**。通常，博客文章和许多默认配置会将特权策略分配给**kube-system**命名空间中的所有**ServiceAccount**对象。这包括**ReplicaSet**控制器运行的**ServiceAccount**，这意味着它可以创建一个具有特权PSP的pod，而不需要**Deployment**的创建者或pod的**serviceAccount**被授权这样做。向您的供应商施压，要求他们提供经过测试的经认证的PSP定义非常重要。
- en: 'Before enabling the admission controller, it''s important to first create initial
    policies. The policy set from [https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter10/podsecuritypolicies.yaml](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter10/podsecuritypolicies.yaml)
    has two policies and associated RBAC bindings. The first policy is the unprivileged
    policy that was described earlier in this chapter. The second policy is a privileged
    policy that is assigned to most of the **ServiceAccount** objects in the **kube-system**
    namespace. The **ReplicaSet** controller''s **ServiceAccount** is not assigned
    access to the privileged policy. If a **Deployment** needs to create a privileged
    pod, the pod''s **serviceAccount** will need to be authorized via RBAC to use
    the privileged policy. The first step is to apply these policies; the policy file
    is in the **chapter10** folder of your cloned repo:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用准入控制器之前，首先创建初始策略非常重要。从[https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter10/podsecuritypolicies.yaml](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter10/podsecuritypolicies.yaml)获取的策略集包括两个策略和相关的RBAC绑定。第一个策略是在本章前面描述的非特权策略。第二个策略是一个特权策略，分配给**kube-system**命名空间中的大多数**ServiceAccount**对象。**ReplicaSet**控制器的**ServiceAccount**没有被分配访问特权策略。如果一个**Deployment**需要创建一个特权pod，pod的**serviceAccount**将需要通过RBAC授权来使用特权策略。第一步是应用这些策略；策略文件位于您克隆的存储库的**chapter10**文件夹中：
- en: 'Go into the **chapter10** folder and create the PSP object using **kubectl**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**chapter10**文件夹，并使用**kubectl**创建PSP对象：
- en: kubectl create -f podsecuritypolicies.yaml
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl create -f podsecuritypolicies.yaml
- en: '**podsecuritypolicy.policy/pod-security-policy-default created**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**podsecuritypolicy.policy/pod-security-policy-default created**'
- en: '**clusterrole.rbac.authorization.k8s.io/default-psp created**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**clusterrole.rbac.authorization.k8s.io/default-psp created**'
- en: '**clusterrolebinding.rbac.authorization.k8s.io/default-psp created**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**clusterrolebinding.rbac.authorization.k8s.io/default-psp created**'
- en: '**podsecuritypolicy.policy/privileged created**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**podsecuritypolicy.policy/privileged created**'
- en: '**clusterrole.rbac.authorization.k8s.io/privileged-psp created**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**clusterrole.rbac.authorization.k8s.io/privileged-psp created**'
- en: '**rolebinding.rbac.authorization.k8s.io/kube-system-psp created**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 **rolebinding.rbac.authorization.k8s.io/kube-system-psp**
- en: Once the policies are created, **docker exec** into the control plain container
    and edit **/etc/kubernetes/manifests/kube-apiserver.yaml**. Look for **- --enable-admission-plugins=NodeRestriction**
    and change it to **- --enable-admission plugins=PodSecurityPolicy,NodeRestriction**.
    Once the API server pod is restarted, all new and updated pod objects will go
    through the **PodSecurityPolicy** admission controller.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦策略被创建，**docker exec** 进入控制平面容器并编辑 **/etc/kubernetes/manifests/kube-apiserver.yaml**。查找
    **- --enable-admission-plugins=NodeRestriction** 并将其更改为 **- --enable-admission
    plugins=PodSecurityPolicy,NodeRestriction**。一旦 API 服务器 pod 重新启动，所有新的和更新的 pod 对象将通过
    **PodSecurityPolicy** 准入控制器。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Managed Kubernetes offerings often pre-configure the **PodSecurityPolicy** admission
    controller. All pods are granted privileged access, so everything just "works."
    Enabling PSPs is a matter of creating the policies and the RBAC rules but not
    explicitly enabling them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 托管的 Kubernetes 提供通常预先配置了 **PodSecurityPolicy** 准入控制器。所有 pod 都被授予特权访问，所以一切都 "正常工作"。启用
    PSPs 只是创建策略和 RBAC 规则，但不显式启用它们。
- en: 'Since policies are enforced through an admission controller, any pods started
    that don''t have access to a privileged policy will continue to run. For instance,
    the NGINX Ingress controller is still running. Checking the annotations of any
    pod using **kubectl describe** will show that there are no annotations for which
    policy is being used. In order to apply policies to all of the running pods, they
    must all be deleted:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于策略是通过准入控制器强制执行的，任何启动的 pod 如果没有访问特权策略，将继续运行。例如，NGINX Ingress 控制器仍在运行。检查任何使用
    **kubectl describe** 的 pod 的注释将显示没有注释指定使用的策略。为了将策略应用到所有正在运行的 pod，它们必须全部被删除：
- en: kubectl delete pods --all-namespaces --all
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl delete pods --all-namespaces --all
- en: '**pod "nginx-ingress-controller-7d6bf88c86-q9f2j" deleted**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "nginx-ingress-controller-7d6bf88c86-q9f2j" pod
- en: '**pod "calico-kube-controllers-5b644bc49c-8lkvs" deleted**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "calico-kube-controllers-5b644bc49c-8lkvs" pod
- en: '**pod "calico-node-r6vwk" deleted**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "calico-node-r6vwk" pod
- en: '**pod "calico-node-r9ck9" deleted**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "calico-node-r9ck9" pod
- en: '**pod "coredns-6955765f44-9vw6t" deleted**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "coredns-6955765f44-9vw6t" pod
- en: '**pod "coredns-6955765f44-qrcss" deleted**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "coredns-6955765f44-qrcss" pod
- en: '**pod "etcd-cluster01-control-plane" deleted**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "etcd-cluster01-control-plane" pod
- en: '**pod "kube-apiserver-cluster01-control-plane" deleted**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kube-apiserver-cluster01-control-plane" pod
- en: '**pod "kube-controller-manager-cluster01-control-plane" deleted**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kube-controller-manager-cluster01-control-plane" pod
- en: '**pod "kube-proxy-n2xf6" deleted**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kube-proxy-n2xf6" pod
- en: '**pod "kube-proxy-tkxh6" deleted**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kube-proxy-tkxh6" pod
- en: '**pod "kube-scheduler-cluster01-control-plane" deleted**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kube-scheduler-cluster01-control-plane" pod
- en: '**pod "dashboard-metrics-scraper-c79c65bb7-vd2k8" deleted**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "dashboard-metrics-scraper-c79c65bb7-vd2k8" pod
- en: '**pod "kubernetes-dashboard-6f89967466-p7rv5" deleted**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "kubernetes-dashboard-6f89967466-p7rv5" pod
- en: '**pod "local-path-provisioner-7745554f7f-lklmf" deleted**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "local-path-provisioner-7745554f7f-lklmf" pod
- en: '**pod "openunison-operator-858d496-zxnmj" deleted**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "openunison-operator-858d496-zxnmj" pod
- en: '**pod "openunison-orchestra-57489869d4-btkvf" deleted**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了 "openunison-orchestra-57489869d4-btkvf" pod
- en: It will take a few minutes to run because the cluster needs to rebuild itself.
    Everything from etcd to the network is rebuilding its pods. After the command
    completes, watch all the pods to make sure they come back.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间来运行，因为集群需要重建自身。从 etcd 到网络，所有都在重建它们的 pod。命令完成后，观察所有的 pod 确保它们恢复。
- en: 'Once all the **Pod** objects are back, take a look at the OpenUnison pod''s
    annotations:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有 **Pod** 对象恢复，查看 OpenUnison pod 的注释：
- en: kubectl describe pod -l application=openunison-orchestra -n openunison
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl describe pod -l application=openunison-orchestra -n openunison
- en: Name:         openunison-orchestra-57489869d4-jmbk2
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：openunison-orchestra-57489869d4-jmbk2
- en: Namespace:    openunison
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：openunison
- en: Priority:     0
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级：0
- en: Node:         cluster01-worker/172.17.0.3
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 节点：cluster01-worker/172.17.0.3
- en: Start Time:   Thu, 11 Jun 2020 22:57:24 -0400
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时间：Thu, 11 Jun 2020 22:57:24 -0400
- en: Labels:       application=openunison-orchestra
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 标签：application=openunison-orchestra
- en: operated-by=openunison-operator
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: operated-by=openunison-operator
- en: pod-template-hash=57489869d4
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: pod-template-hash=57489869d4
- en: 'Annotations:  cni.projectcalico.org/podIP: 10.240.189.169/32'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '注释：cni.projectcalico.org/podIP: 10.240.189.169/32'
- en: 'cni.projectcalico.org/podIPs: 10.240.189.169/32'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'cni.projectcalico.org/podIPs: 10.240.189.169/32'
- en: '**kubernetes.io/psp: pod-security-policy-default**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'kubernetes.io/psp: pod-security-policy-default'
- en: The highlighted annotation shows that OpenUnison is running under the default
    restricted policy.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的注释显示OpenUnison正在使用默认的受限策略运行。
- en: 'While OpenUnison is running, attempts to log in will fail. The NGINX Ingress
    pods aren''t running. As we discussed earlier in the chapter, NGINX needs to be
    able to open ports **443** and **80**, but using the default policy won''t allow
    this to happen. Confirm why NGINX isn''t running by inspecting the events in the
    **ingress-nginx** namespace:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当OpenUnison正在运行时，尝试登录将失败。NGINX Ingress的pod没有运行。正如我们在本章前面讨论的那样，NGINX需要能够打开端口443和80，但使用默认策略不允许这种情况发生。通过检查ingress-nginx命名空间中的事件来确认NGINX为什么没有运行：
- en: '**$ kubectl get events -n ingress-nginx**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl get events -n ingress-nginx
- en: '**2m4s        Warning   FailedCreate       replicaset/nginx-ingress-controller-7d6bf88c86   Error
    creating: pods "nginx-ingress-controller-7d6bf88c86-" is forbidden: unable to
    validate against any pod security policy: [spec.containers[0].securityContext.capabilities.add:
    Invalid value: "NET_BIND_SERVICE": capability may not be added spec.containers[0].hostPort:
    Invalid value: 80: Host port 80 is not allowed to be used. Allowed ports: [] spec.containers[0].hostPort:
    Invalid value: 443: Host port 443 is not allowed to be used. Allowed ports: []]**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '2m4s 警告 FailedCreate replicaset/nginx-ingress-controller-7d6bf88c86 创建错误：pods
    "nginx-ingress-controller-7d6bf88c86-" 被禁止：无法根据任何pod安全策略进行验证：[spec.containers[0].securityContext.capabilities.add:
    Invalid value: "NET_BIND_SERVICE": capability may not be added spec.containers[0].hostPort:
    Invalid value: 80: Host port 80 is not allowed to be used. Allowed ports: [] spec.containers[0].hostPort:
    Invalid value: 443: Host port 443 is not allowed to be used. Allowed ports: []]'
- en: 'Even though the NGINX Ingress project provides polices and RBAC bindings, let''s
    debug this as if it doesn''t. Inspecting the **Deployment** object, the key block
    in the spec is as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使NGINX Ingress项目提供了策略和RBAC绑定，让我们假设没有这些来调试。检查Deployment对象，规范中的关键块如下：
- en: 'ports:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：
- en: '- containerPort: 80'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '- containerPort: 80'
- en: 'hostPort: 80'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 主机端口：80
- en: 'name: http'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：http
- en: 'protocol: TCP'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 协议：TCP
- en: '- containerPort: 443'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '- containerPort: 443'
- en: 'hostPort: 443'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'hostPort: 443'
- en: 'name: https'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：https
- en: 'protocol: TCP'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 协议：TCP
- en: .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: 'securityContext:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'securityContext:'
- en: 'allowPrivilegeEscalation: true'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'allowPrivilegeEscalation: true'
- en: 'capabilities:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 功能：
- en: 'add:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 添加：
- en: '- NET_BIND_SERVICE'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '- NET_BIND_SERVICE'
- en: 'drop:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: drop：
- en: '- ALL'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '- ALL'
- en: 'runAsUser: 101'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'runAsUser: 101'
- en: First, the pod is declaring that it wants to open ports **80** and **443**.
    Next, its **securityContext** declares that it wants a privilege escalation and
    it wants the **NET_BIND_SERVICE** capability to open those ports without being
    root.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，pod声明要打开端口80和443。接下来，它的securityContext声明要进行特权升级，并且要求NET_BIND_SERVICE功能以在不作为root的情况下打开这些端口。
- en: 'Similar to the **audit2rbac** tool used when debugging RBAC policies, Sysdig
    has published a tool that will inspect the pods in a namespace and generate a
    recommended policy and RBAC set. Download the latest version from [https://github.com/sysdiglabs/kube-psp-advisor/releases](https://github.com/sysdiglabs/kube-psp-advisor/releases):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于调试RBAC策略时使用的audit2rbac工具，Sysdig发布了一个工具，将检查命名空间中的pod并生成推荐的策略和RBAC集。从[https://github.com/sysdiglabs/kube-psp-advisor/releases](https://github.com/sysdiglabs/kube-psp-advisor/releases)下载最新版本：
- en: ./kubectl-advise-psp inspect  --namespace=ingress-nginx
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ./kubectl-advise-psp inspect --namespace=ingress-nginx
- en: '**apiVersion: policy/v1beta1**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**apiVersion: policy/v1beta1**'
- en: '**kind: PodSecurityPolicy**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**kind: PodSecurityPolicy**'
- en: '**metadata:**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**metadata:**'
- en: '**  creationTimestamp: null**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '** creationTimestamp: null**'
- en: '**  name: pod-security-policy-ingress-nginx-20200611232031**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '** name: pod-security-policy-ingress-nginx-20200611232031**'
- en: '**spec:**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**spec:**'
- en: '**  defaultAddCapabilities:**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '** defaultAddCapabilities:**'
- en: '**  - NET_BIND_SERVICE**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '** - NET_BIND_SERVICE**'
- en: '**  fsGroup:**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '** fsGroup:**'
- en: '**    rule: RunAsAny**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '** rule: RunAsAny**'
- en: '**  hostPorts:**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '** hostPorts:**'
- en: '**  - max: 80**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '** - max: 80**'
- en: '**    min: 80**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '** min: 80**'
- en: '**  - max: 443**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '** - max: 443**'
- en: '**    min: 443**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '** min: 443**'
- en: '**  requiredDropCapabilities:**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '** requiredDropCapabilities:**'
- en: '**  - ALL**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '** - ALL**'
- en: '**  runAsUser:**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '** runAsUser:**'
- en: '**    ranges:**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '** ranges:**'
- en: '**    - max: 101**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '** - max: 101**'
- en: '**      min: 101**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '** min: 101**'
- en: '**    rule: MustRunAs**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '** rule: MustRunAs**'
- en: '**  seLinux:**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '** seLinux:**'
- en: '**    rule: RunAsAny**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '** rule: RunAsAny**'
- en: '**  supplementalGroups:**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '** supplementalGroups:**'
- en: '**    rule: RunAsAny**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '** rule: RunAsAny**'
- en: '**  volumes:**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '** volumes:**'
- en: '**  - secret**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '** - secret**'
- en: Compare this policy to the one provided by the NGINX Ingress project that was
    examined earlier in the chapter; you'll see that it's more restrictive on the
    ports and user, but less restrictive on the group. The **Deployment** declared
    the user but not the group, so **kube-psp-advisor** didn't know to restrict it.
    Unlike **audit2rbac**, **kube-psp-advisor** isn't scanning a log to see what is
    denied; it is proactively inspecting pod definitions to create policies. If a
    pod doesn't declare that it needs to run as root but just starts a container that
    runs as root, then **kube-psp-advisor** won't generate a proper policy.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将此策略与本章前面检查过的NGINX Ingress项目提供的策略进行比较；您会发现它在端口和用户上更加严格，但在组上不那么严格。**Deployment**声明了用户但没有声明组，因此**kube-psp-advisor**不知道要对其进行限制。与**audit2rbac**不同，**kube-psp-advisor**不是在扫描日志以查看被拒绝的内容；它是积极地检查pod定义以创建策略。如果一个pod没有声明需要以root身份运行，而只是启动一个以root身份运行的容器，那么**kube-psp-advisor**将不会生成适当的策略。
- en: 'Create a policy file from **kube-psp-advisor** called **psp-ingress.yaml**:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**kube-psp-advisor**创建名为**psp-ingress.yaml**的策略文件：
- en: '**$ ./kubectl-advise-psp inspect  --namespace=ingress-nginx > psp-ingress.yaml**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ ./kubectl-advise-psp inspect --namespace=ingress-nginx > psp-ingress.yaml**'
- en: 'Deploy the PSP using **kubectl**:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**kubectl**部署PSP：
- en: '**$ kubectl create -f ./psp-ingress.yaml -n ingress-nginx**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ kubectl create -f ./psp-ingress.yaml -n ingress-nginx**'
- en: 'Next, create RBAC bindings for the **nginx-ingress-serviceaccount ServiceAccount**
    (as referenced in the Deployment) to have access to this policy:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为**nginx-ingress-serviceaccount ServiceAccount**（在部署中引用）创建RBAC绑定，以便访问此策略：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: Role'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Role'
- en: 'metadata:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: nginx-ingress-psp'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: nginx-ingress-psp'
- en: 'namespace: ingress-nginx'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'namespace: ingress-nginx'
- en: 'rules:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'rules:'
- en: '- apiGroups:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups:'
- en: '- policy'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '- policy'
- en: 'resourceNames:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'resourceNames:'
- en: '- pod-security-policy-ingress-nginx-20200611232826'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '- pod-security-policy-ingress-nginx-20200611232826'
- en: 'resources:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'resources:'
- en: '- podsecuritypolicies'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '- podsecuritypolicies'
- en: 'verbs:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 'verbs:'
- en: '- use'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '- use'
- en: '---'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: RoleBinding'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: RoleBinding'
- en: 'metadata:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: nginx-ingress-psp'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: nginx-ingress-psp'
- en: 'namespace: ingress-nginx'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'namespace: ingress-nginx'
- en: 'roleRef:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'roleRef:'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'kind: Role'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Role'
- en: 'name: nginx-ingress-psp'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: nginx-ingress-psp'
- en: 'subjects:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'subjects:'
- en: '- kind: ServiceAccount'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '- kind: ServiceAccount'
- en: 'name: nginx-ingress-serviceaccount'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: nginx-ingress-serviceaccount'
- en: 'namespace: ingress-nginx'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'namespace: ingress-nginx'
- en: 'Once the RBAC objects are created, the Deployment needs to be updated to force
    Kubernetes to attempt to recreate the pods since the API server will stop trying
    after a certain point:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦RBAC对象创建完成，需要更新部署以强制Kubernetes尝试重新创建pod，因为API服务器在一定时间后将停止尝试：
- en: '**$ kubectl scale deployment.v1.apps/nginx-ingress-controller --replicas=0
    -n ingress-nginx**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl scale deployment.v1.apps/nginx-ingress-controller --replicas=0 -n
    ingress-nginx
- en: '**deployment.apps/nginx-ingress-controller scaled**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.apps/nginx-ingress-controller scaled
- en: '**$ kubectl scale deployment.v1.apps/nginx-ingress-controller --replicas=1
    -n ingress-nginx**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl scale deployment.v1.apps/nginx-ingress-controller --replicas=1 -n
    ingress-nginx
- en: '**deployment.apps/nginx-ingress-controller scaled**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.apps/nginx-ingress-controller scaled
- en: '**$ kubectl get pods -n ingress-nginx**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl get pods -n ingress-nginx
- en: '**NAME                                        READY   STATUS    RESTARTS   AGE**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                                      准备就绪    状态      重启次数    年龄
- en: '**nginx-ingress-controller-7d6bf88c86-h4449   0/1     Running   0          21s**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: nginx-ingress-controller-7d6bf88c86-h4449   0/1     Running   0          21s
- en: If you check the annotations on the pod, the **PodSecurityPolicy** annotation
    will be there and OpenUnison is accessible again.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查Pod上的注释，将会有**PodSecurityPolicy**注释，并且OpenUnison将再次可访问。
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A side effect of using RBAC to control PSP authorization is that an admin in
    a namespace is able to create **ServiceAccount** objects that can run privileged
    containers. Stopping this capability while still allowing a namespace admin to
    create RBAC policies in their namespace will be discussed in the next chapter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RBAC来控制PSP授权的一个副作用是，命名空间中的管理员可以创建可以运行特权容器的**ServiceAccount**对象。在允许命名空间管理员在其命名空间中创建RBAC策略的同时停止这种能力将在下一章中讨论。
- en: Congratulations, you have successfully implemented PSPs on your cluster! Try
    running the breakout code we ran earlier in this chapter and you'll see that it
    won't work. The **Pod** won't even start! Seeing that the NGINX Ingress controller
    wouldn't start and debugging it gave you the tools to understand how to work through
    issues after enabling policy enforcement.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已成功在集群上实施了PSPs！尝试运行我们在本章早些时候运行的突破代码，您会发现它不起作用。**Pod**甚至不会启动！看到NGINX Ingress控制器无法启动并对其进行调试，使您能够理解如何在启用策略执行后解决问题。
- en: Alternatives to PSPs
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSP的替代方案
- en: If not PSPs, then what? That really depends on a cluster's use case. There have
    been attempts to implement the full **PodSecurityPolicy** enforcement specification
    in OPA, which will be discussed in more detail in the next chapter. Several other
    projects have attempted to implement PSPs, if not the exact spec as the **PodSecurityPolicy**
    object. Given how fluid the space is, this chapter isn't going to enumerate all
    of the projects that are attempting to do this.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是PSPs，那又是什么呢？这实际上取决于集群的用例。已经有人尝试在OPA中实现完整的**PodSecurityPolicy**执行规范，这将在下一章中更详细地讨论。其他几个项目尝试实现PSPs，即使不是**PodSecurityPolicy**对象的确切规范。鉴于这个领域的变化如此迅速，本章不会列举所有试图做到这一点的项目。
- en: In May 2020, the authentication special interest group (**sig-auth**) published
    the *pod security standards* document to make it easier for different implementations
    of security policies to standardize on vocabulary and nomenclature. The standards
    were published on the Kubernetes website ([https://kubernetes.io/docs/concepts/security/pod-security-standards/](https://kubernetes.io/docs/concepts/security/pod-security-standards/)).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年5月，认证特别兴趣小组（sig-auth）发布了*pod安全标准*文档，以便不同的安全策略实现能够统一词汇和命名。这些标准已经发布在Kubernetes网站上（[https://kubernetes.io/docs/concepts/security/pod-security-standards/](https://kubernetes.io/docs/concepts/security/pod-security-standards/)）。
- en: Be wary of implementing this logic on your own in your own admission controller
    as a validating webhook. Just as with any security implementation, great care
    needs to be taken to not only validate the expected outcome but also to make sure
    that unexpected scenarios are handled in an expected way. For instance, what happens
    if a **Deployment** is used to create a **Pod** versus creating a **Pod** directly?
    What happens when someone tries to inject invalid data into the definition? Or
    if someone tries to create a side car or an **init** container? When choosing
    an approach, it's important to ensure that any implementation has a thorough testing
    environment.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己的准入控制器作为验证webhook中实现这个逻辑时要小心。就像任何安全实现一样，需要非常小心，不仅要验证预期的结果，还要确保意外情况得到预期的处理。例如，如果使用**Deployment**来创建**Pod**与直接创建**Pod**有什么不同？当有人试图向定义中注入无效数据时会发生什么？或者有人试图创建一个side
    car或一个**init**容器时会发生什么？在选择方法时，重要的是要确保任何实现都有一个彻底的测试环境。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began by exploring the importance of protecting nodes, the
    differences between containers and VMs from a security standpoint, and how easy
    it is to exploit a cluster when nodes aren't protected. We also looked at secure
    container design, and finally, we implemented and debugged a PSP implementation.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了保护节点的重要性，从安全角度讨论了容器和VM之间的区别，以及在节点没有受到保护时容易利用集群的情况。我们还研究了安全的容器设计，最后实施和调试了PSP实现。
- en: Locking down the nodes of your cluster provides one less vector for attackers.
    Encapsulating the policy makes it easier to explain to your developers how to
    design their containers and makes it easier to build secure solutions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定集群节点提供了一个更少的攻击向量。封装策略使得更容易向开发人员解释如何设计他们的容器，并更容易构建安全的解决方案。
- en: So far, all of our security has been built on Kubernetes' standard technologies
    and is nearly universal across Kubernetes distributions. In the next chapter,
    we'll work on applying policies that are beyond the scope of Kubernetes using
    dynamic admission controllers and the OPA.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的安全性都是基于Kubernetes的标准技术构建的，几乎在所有Kubernetes发行版中都是通用的。在下一章中，我们将通过动态准入控制器和OPA来应用超出Kubernetes范围的策略。
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: True or false – containers are "lightweight VMs."
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是“轻量级VM”——真还是假？
- en: A. True
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: Can a container access resources from its host?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器能否访问其主机的资源？
- en: A. No, it's isolated.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: A. 不，它是隔离的。
- en: B. If marked as privileged, yes.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: B. 如果标记为特权，是的。
- en: C. Only if explicitly granted by a policy.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: C. 只有在策略明确授予的情况下。
- en: D. Sometimes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: D. 有时候。
- en: How could an attacker gain access to a cluster through a container?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者如何通过容器获得对集群的访问权限？
- en: A. A bug in the container's application can lead to a remote code execution,
    which can be used to break out of a vulnerable container and then used to get
    the kubelet's credentials.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: A. 容器应用程序中的错误可能导致远程代码执行，这可能被用来打破容器的漏洞，然后用来获取kubelet的凭证。
- en: B. Compromised credentials with the ability to create a container in one namespace
    can be used to create a container that mounts the node's filesystem to get the
    kubelet's credentials.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: B. 具有创建一个命名空间中容器的能力的受损凭证可以用来创建一个挂载节点文件系统以获取kubelet凭证的容器。
- en: C. Both of the above.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: C. 以上两者都是。
- en: How does the **PodSecurityPolicy** admission controller determine which policy
    to apply to a pod?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PodSecurityPolicy**准入控制器如何确定要应用于pod的策略？'
- en: A. By reading an annotation on the pod's definition
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: A. 通过读取pod定义中的注释
- en: B. By comparing the pod's requested capabilities and the policies authorized
    via the union of the pod's creator and its own **ServiceAccount**
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: B. 通过比较pod的请求能力和通过pod的创建者和其自己的**ServiceAccount**授权的策略的并集。
- en: C. By comparing the Pod's requested capabilities and the policies authorized
    for its own **ServiceAccount**
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: C. 通过比较Pod请求的功能和为其自己的**ServiceAccount**授权的策略
- en: D. By comparing the pod's requested capabilities and the policies authorized
    for the pod's creator
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: D. 通过比较Pod请求的功能和为Pod创建者授权的策略
- en: What mechanism enforces PSPs?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么机制执行了PSPs？
- en: A. An admission controller that inspects all pods on creation and update
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: A. 一个审批控制器，在创建和更新时检查所有的Pods
- en: B. The **PodSecurityPolicy** API
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: B. **PodSecurityPolicy** API
- en: C. The OPA
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: C. OPA
- en: D. Gatekeeper
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: D. Gatekeeper
- en: True or false – the **PodSecurityPolicy** API will be removed quickly.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - **PodSecurityPolicy** API 将很快被移除。
- en: A. True
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: True or false – containers should generally run as root.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 容器通常应该以root用户身份运行。
- en: A. True
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
