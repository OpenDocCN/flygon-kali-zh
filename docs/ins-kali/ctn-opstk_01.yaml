- en: Working with Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器
- en: 'This chapter covers containers and various topics related to them. In this
    chapter, we will be covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了容器和与之相关的各种主题。在本章中，我们将涵盖以下主题：
- en: The historical context of virtualization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化的历史背景
- en: Introduction to containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的介绍
- en: Container components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器组件
- en: Types of containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的类型
- en: Types of container runtime tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时工具的类型
- en: Installation of Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的安装
- en: Docker hands-on
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker实践
- en: The historical context of virtualization
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化的历史背景
- en: Traditional virtualization appeared on the Linux kernel in the form of hypervisors
    such as Xen and KVM. This allowed users to isolate their runtime environment in
    the form of **virtual machines** (**VMs**). Virtual machines run their own operating
    system kernel. Users attempted to use the resources on host machines as much as
    possible. However, high densities were difficult to achieve with this form of
    virtualization, especially when a deployed application was small in size compared
    to a kernel; most of the host's memory was consumed by multiple copies of kernels
    running on it. Hence, in such high-density workloads, machines were divided using
    technologies such as *chroot jails* which provided imperfect workload isolation
    and carried security implications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统虚拟化出现在Linux内核中，以Xen和KVM等虚拟机监视程序的形式。这允许用户以**虚拟机**（**VM**）的形式隔离其运行时环境。虚拟机运行其自己的操作系统内核。用户尝试尽可能多地使用主机机器上的资源。然而，使用这种形式的虚拟化难以实现高密度，特别是当部署的应用程序与内核相比较小时；主机的大部分内存被运行在其上的多个内核副本所消耗。因此，在这种高密度工作负载中，使用诸如*chroot
    jails*之类的技术来划分机器，提供了不完善的工作负载隔离并带来了安全隐患。
- en: In 2001, an operating system virtualization in the form of Linux vServer was
    introduced as a series of kernel patches.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年，以Linux vServer的形式引入了操作系统虚拟化，作为一系列内核补丁。
- en: This led to an early form of container virtualization. In such forms of virtualization,
    the kernel groups and isolates processes belonging to different tenants, each
    sharing the same kernel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了早期形式的容器虚拟化。在这种形式的虚拟化中，内核对属于不同租户的进程进行分组和隔离，每个租户共享相同的内核。
- en: 'Here is a table that explains the various developments that took place to enable
    operating system virtualization:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张表，解释了各种发展，使操作系统虚拟化成为可能：
- en: '| **Year and Development** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **年份和发展** | **描述** |'
- en: '| 1979: chroot | The concept of containers emerged way back in 1979 with UNIX
    chroot. Later, in 1982, this was incorporated into BSD. With chroot, users can
    change the root directory for any running process and its children, separating
    it from the main OS and directory. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 1979年：chroot | 容器概念早在1979年就出现了，使用UNIX chroot。后来，在1982年，这被纳入了BSD。使用chroot，用户可以更改任何正在运行的进程及其子进程的根目录，将其与主操作系统和目录分离。|'
- en: '| 2000: FreeBSD Jails | FreeBSD Jails was introduced by Derrick T. Woolworth
    at R&D associates in 2000 for FreeBSD. It is an operating system''s system call
    similar to chroot, with additional process sandboxing features for isolating the
    filesystem, users, networking, and so on. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 2000年：FreeBSD Jails | FreeBSD Jails是由Derrick T. Woolworth于2000年在R＆D associates为FreeBSD引入的。它是类似于chroot的操作系统系统调用，具有用于隔离文件系统、用户、网络等的附加进程沙盒功能。|'
- en: '| 2001: Linux vServer | Another jail mechanism that can securely partition
    resources on a computer system (filesystem, CPU time, network addresses, and memory).
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2001年：Linux vServer | 另一种可以在计算机系统上安全分区资源（文件系统、CPU时间、网络地址和内存）的监狱机制。|'
- en: '| 2004: Solaris containers | Solaris containers were introduced for x86 and
    SPARC systems, and first released publicly in February 2004\. They are a combination
    of system resource controls and the boundary separations provided by zones. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: 2004年：Solaris容器 | Solaris容器适用于x86和SPARC系统，并于2004年2月首次公开发布。它们是系统资源控制和区域提供的边界分离的组合。
- en: '| 2005: OpenVZ | OvenVZ is similar to Solaris containers and makes use of a
    patched Linux kernel for providing virtualization, isolation, resource management,
    and checkpointing. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: 2005年：OpenVZ | OpenVZ类似于Solaris容器，并利用经过修补的Linux内核提供虚拟化、隔离、资源管理和检查点。
- en: '| 2006: Process containers | Process containers were implemented at Google
    in 2006 for limiting, accounting, and isolating the resource usage (CPU, memory,
    disk I/O, network, and so on) of a collection of processes. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: 2006年：进程容器 | 谷歌在2006年实施了进程容器，用于限制、记账和隔离一组进程的资源使用（CPU、内存、磁盘I/O、网络等）。
- en: '| 2007: Control groups | Control groups, also known as CGroups, were implemented
    by Google and added to the Linux Kernel in 2007\. CGroups help in the limiting,
    accounting, and isolation of resource usages (memory, CPU, disks, network, and
    so on) for a collection of processes. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: 2007年：控制组 | 控制组，也称为CGroups，是由谷歌实施并于2007年添加到Linux内核中的。CGroups有助于限制、记账和隔离一组进程的资源使用（内存、CPU、磁盘、网络等）。
- en: '| 2008: LXC | LXC stands for Linux containers and was implemented using CGroups
    and Linux namespaces. In comparison to other container technologies, LXC works
    on the vanilla Linux kernel. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: 2008年：LXC | LXC代表Linux容器，使用CGroups和Linux命名空间实施。与其他容器技术相比，LXC在原始Linux内核上运行。
- en: '| 2011: Warden | Warden was implemented by Cloud Foundry in 2011 using LXC
    at the initial stage; later on, it was replaced with their own implementation.
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: 2011年：Warden | Warden是Cloud Foundry在2011年使用LXC初期阶段实施的；后来，它被他们自己的实现所取代。
- en: '| 2013: LMCTFY | **LMCTFY** stands for **Let Me Contain That For You**. It
    is the open source version of Google''s container stack, which provides Linux
    application containers. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: 2013年：LMCTFY | **LMCTFY**代表**让我来为你容纳**。它是谷歌容器堆栈的开源版本，提供Linux应用程序容器。
- en: '| 2013: Docker | Docker was started in the year of 2016\. Today it is the most
    widely used container management tool. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: 2013年：Docker | Docker始于2016年。如今它是最广泛使用的容器管理工具。
- en: '| 2014: Rocket | Rocket is another container runtime tool from CoreOS. It emerged
    to address security vulnerabilities in early versions of Docker. Rocket is another
    possibility or choice to use instead of Docker, with the most resolved security,
    composability, speed, and production requirements. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: 2014年：Rocket | Rocket是来自CoreOS的另一个容器运行时工具。它出现是为了解决早期版本Docker的安全漏洞。Rocket是另一个可以用来替代Docker的选择，具有更好的安全性、可组合性、速度和生产要求。
- en: '| 2016: Windows containers | Microsoft added container support (Windows containers)
    to the Microsoft Windows Server operating system in 2015 for Windows-based applications.
    With the help of this implementation, Docker would be able to run Docker containers
    on Windows natively without having to run a virtual machine to run. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 2016年：Windows容器 | 微软在2015年为基于Windows的应用程序向Microsoft Windows Server操作系统添加了容器支持（Windows容器）。借助这一实施，Docker将能够在Windows上本地运行Docker容器，而无需运行虚拟机。
- en: Introduction to containers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: Linux containers are operating system level virtualization which provides multiple
    isolated environments on a single host. Rather than using dedicated guest OS like
    VMs, they share the host OS kernel and hardware.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器是操作系统级别的虚拟化，可以在单个主机上提供多个隔离的环境。它们不像虚拟机那样使用专用的客户操作系统，而是共享主机操作系统内核和硬件。
- en: Before containers came into the limelight, multitasking and traditional hypervisor-based
    virtualization were used, mainly. Multitasking allows multiple applications to
    run on the same host machine, however, it provides less isolation between different
    applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器成为关注焦点之前，主要使用多任务处理和基于传统虚拟化程序的虚拟化。多任务处理允许多个应用程序在同一台主机上运行，但是它在不同应用程序之间提供了较少的隔离。
- en: Traditional hypervisor-based virtualization allows multiple guest machines to
    run on top of host machines. Each of these guest machines runs their own operating
    system. This approach provides the highest level of isolation as well as the ability
    to run different operating systems simultaneously on the same hardware.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于传统虚拟化程序的虚拟化允许多个客户机在主机机器上运行。每个客户机都运行自己的操作系统。这种方法提供了最高级别的隔离，以及在同一硬件上同时运行不同操作系统的能力。
- en: 'However, it comes with a number of disadvantages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也带来了一些缺点：
- en: Each operating system takes a while to boot
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作系统启动需要一段时间
- en: Each kernel takes up its own memory and CPU, so the overhead of virtualization
    is large
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个内核占用自己的内存和CPU，因此虚拟化的开销很大
- en: The I/O is less efficient as it has to pass through different layers
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O效率较低，因为它必须通过不同的层
- en: Resource allocation is not done on a fine-grained basis, for example, memory
    is allocated to a virtual machine at the time of creation, and memory left idle
    by one virtual machine can't be used by others
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源分配不是基于细粒度的，例如，内存在虚拟机创建时分配，一个虚拟机空闲的内存不能被其他虚拟机使用
- en: The maintenance load of keeping each kernel up to date is large
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持每个内核最新的维护负担很大
- en: 'The following figure explains the concept of virtualization:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解释了虚拟化的概念：
- en: '![](../images/00005.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: Containers provide the best of both words. To provide an isolated and secure
    environment for containers, they use Linux kernel features such as chroot, namespaces,
    CGroups, AppArmor, SELinux profiles, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了最好的两种方式。为了为容器提供隔离和安全的环境，它们使用Linux内核功能，如chroot、命名空间、CGroups、AppArmor、SELinux配置文件等。
- en: The secure access to the host machine kernel from the container is ensured by
    Linux security modules.. Boot is faster as there is no kernel or operating system
    to start up. Resource allocation is fine-grained and handled by the host kernel,
    allowing the effective per container quality of service (QoS). The next figure
    explains container virtualization.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Linux安全模块确保了容器对主机机器内核的安全访问。由于没有内核或操作系统启动，启动速度更快。资源分配是细粒度的，并由主机内核处理，允许有效的每个容器的服务质量（QoS）。下图解释了容器虚拟化。
- en: 'However, there are some disadvantages of containers compared to traditional
    hypervisor-based virtualization: guest operating systems are limited to those
    which can use the same kernel.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与基于传统虚拟化程序的虚拟化相比，容器也有一些缺点：客户操作系统受限于可以使用相同内核的操作系统。
- en: 'Traditional hypervisors provide additional isolation that is not available
    in containers, meaning the noisy neighbor problem is more significant in containers
    than it is with a traditional hypervisor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的虚拟化程序提供了额外的隔离，这在容器中是不可用的，这意味着在容器中嘈杂的邻居问题比在传统的虚拟化程序中更为显著：
- en: '![](../images/00006.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: Container components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器组件
- en: 'Linux containers are typically comprised of five major components:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器通常由五个主要组件组成：
- en: '**Kernel namespaces**: Namespaces are the major building blocks of Linux containers.
    They isolate various types of Linux resources such as the network, processes,
    users, and the filesystem into different groups. This allows different groups
    of processes to have completely independent views of their resources. Other resources
    that can be segregated include the process ID space, the IPC space, and semaphore
    space.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核命名空间**: 命名空间是Linux容器的主要构建模块。它们将各种类型的Linux资源，如网络、进程、用户和文件系统，隔离到不同的组中。这允许不同组的进程完全独立地查看它们的资源。可以分隔的其他资源包括进程ID空间、IPC空间和信号量空间。'
- en: '**Control groups**: Control groups, also known as CGroups, limit and account
    for different types of resource usage such as the CPU, memory, disk I/O, network
    I/O, and so on, across a group of different processes. They help in preventing
    one container from resource starvation or contention caused by another container,
    and thereby maintains QoS.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制组**: 控制组，也称为CGroups，限制和记录不同类型的资源使用，如CPU、内存、磁盘I/O、网络I/O等，跨一组不同的进程。它们有助于防止一个容器由于另一个容器导致的资源饥饿或争用，并因此维护QoS。'
- en: '**Security**: Security in containers is provided via the following components:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**: 容器中的安全性是通过以下组件提供的:'
- en: '**Root capabilities**: This will help in enforcing namespaces in so-called
    privileged containers by reducing the power of root, in some cases to no power
    at all.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根权限**: 这将有助于通过降低根用户的权限来执行特权容器中的命名空间，有时甚至可以完全取消根用户的权限。'
- en: '**Discretionary Access Control (DAC)**: It mediates access to resources based
    on user-applied policies so that individual containers can''t interfere with each
    other and can be run by non-root users securely.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主访问控制(DAC)**: 它基于用户应用的策略来调解对资源的访问，以便个别容器不能相互干扰，并且可以由非根用户安全地运行。'
- en: '**Mandatory Access Controls (MAC)**: Mandatory Access Controls (MAC), such
    as AppArmor and SELinux, are not required for creating containers, but are often
    a key element to their security. MAC ensures that neither the container code itself
    nor the code running in the containers has a greater degree of access than the
    process itself requires. This way, it minimizes the privileges granted to rogue
    or compromised processes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制访问控制(MAC)**: 强制访问控制(MAC)，如AppArmor和SELinux，并不是创建容器所必需的，但通常是其安全性的关键要素。MAC确保容器代码本身以及容器中运行的代码都没有比进程本身需要的更大程度的访问权限。这样，它最小化了授予恶意或被入侵进程的权限。'
- en: '**Toolsets**: Above the host kernel lies the user-space toolsets such as LXD,
    Docker, and other libraries, which help in managing containers:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具集**: 在主机内核之上是用户空间的工具集，如LXD、Docker和其他库，它们帮助管理容器。'
- en: '![](../images/00007.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: Types of containers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的类型
- en: 'The types of containers are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '容器的类型如下:'
- en: Machine containers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器容器
- en: Machine containers are virtual environments that share the kernel of the host
    operating system but provide user space isolation. They look far more similar
    to virtual machines. They have their own init process, and may run a limited number
    of daemons. Programs can be installed, configured, and run just as they would
    be on any guest operating system. Similar to a virtual machine, anything running
    inside a container can only see resources that have been assigned to that container.
    Machine containers are useful when the use case is to run a fleet of identical
    or different flavors of distros.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 机器容器是共享主机操作系统内核但提供用户空间隔离的虚拟环境。它们看起来更像虚拟机。它们有自己的init进程，并且可以运行有限数量的守护程序。程序可以安装、配置和运行，就像在任何客户操作系统上一样。与虚拟机类似，容器内运行的任何内容只能看到分配给该容器的资源。当使用情况是运行一组相同或不同版本的发行版时，机器容器非常有用。
- en: Machine containers having their own operating system does not mean that they
    are running a full-blown copy of their own kernel. Rather, they run a few lightweight
    daemons and have a number of necessary files to provide a separate OS within another
    OS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 机器容器拥有自己的操作系统并不意味着它们正在运行自己内核的完整副本。相反，它们运行一些轻量级的守护程序，并具有一些必要的文件，以在另一个操作系统中提供一个独立的操作系统。
- en: Container technologies such as LXC, OpenVZ, Linux vServer, BSD Jails, and Solaris
    zones are all suitable for creating machine containers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如LXC、OpenVZ、Linux vServer、BSD Jails和Solaris zones之类的容器技术都适用于创建机器容器。
- en: 'The following figure shows the machine container concept:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了机器容器的概念：
- en: '![](../images/00008.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: Application containers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用容器
- en: While machine containers are designed to run multiple processes and applications,
    application containers are designed to package and run a single application. They
    are designed to be very small. They need not contain a shell or `init` process.
    The disk space required for an application container is very small. Container
    technologies such as Docker and Rocket are examples of application containers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然机器容器旨在运行多个进程和应用程序，但应用容器旨在打包和运行单个应用程序。它们被设计得非常小。它们不需要包含shell或`init`进程。应用容器所需的磁盘空间非常小。诸如Docker和Rocket之类的容器技术就是应用容器的例子。
- en: 'The following figure elaborates on application containers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解释了应用容器：
- en: '**![](../images/00009.jpeg)**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](../images/00009.jpeg)**'
- en: Types of container runtime tools
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时工具的类型
- en: Multiple solutions are available today for managing containers. This section
    discusses alternative types of containers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有多种解决方案可用于管理容器。本节讨论了替代类型的容器。
- en: Docker
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: '**Docker** is the world''s leading container platform software. It has been
    available since 2013\. Docker is a container runtime tool designed to make it
    easier to create, deploy, and run applications by using containers. Docker has
    drastically reduced the complexity of managing applications by containerizing
    them. It allows applications to use the same Linux kernel as the host OS, unlike
    VMs, which create a whole new OS with dedicated hardware. Docker containers can
    run both on Linux and Windows workloads. Docker containers have enabled huge efficiencies
    in the development of software, but require runtime tools such as Swarm or Kubernetes.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**是全球领先的容器平台软件。它自2013年以来就可用。Docker是一个容器运行时工具，旨在通过使用容器更轻松地创建、部署和运行应用程序。Docker通过容器化大大降低了管理应用程序的复杂性。它允许应用程序使用与主机操作系统相同的Linux内核，而不像虚拟机那样创建具有专用硬件的全新操作系统。Docker容器可以在Linux和Windows工作负载上运行。Docker容器已经在软件开发中实现了巨大的效率提升，但需要Swarm或Kubernetes等运行时工具。'
- en: Rocket
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rocket
- en: '**Rocket** is another container runtime tool from CoreOS. It emerged to address
    security vulnerabilities in early versions of Docker. Rocket is another possibility
    or choice to Docker, with the most resolved security, composability, speed, and
    production requirements. Rocket has built things differently to Docker in many
    aspects. The main difference is that Docker runs a central daemon with root privileges
    and spins off a new container as its sub process, whereas Rocket never spins a
    container with root privileges. However, Docker always recommends running containers
    within SELinux or AppArmor. Since then, Docker has come up with many solutions
    to tackle the flaws.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rocket**是来自CoreOS的另一个容器运行时工具。它出现是为了解决Docker早期版本中的安全漏洞。Rocket是Docker的另一种可能性或选择，具有最解决的安全性、可组合性、速度和生产要求。Rocket在许多方面与Docker构建了不同的东西。主要区别在于Docker运行具有根权限的中央守护程序，并将一个新的容器作为其子进程，而Rocket从不以根权限旋转容器。然而，Docker始终建议在SELinux或AppArmor中运行容器。自那时起，Docker已经提出了许多解决方案来解决这些缺陷。'
- en: LXD
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LXD
- en: '**LXD** is a container hypervisor for managing LXC by Ubuntu. LXD is a daemon
    which provides a REST API for running containers and managing related resources.
    LXD containers provide the same user experience as traditional VMs, but using
    LXC, which provides similar runtime performance to containers and improved utilization
    over VMs. LXD containers run a full Linux OS so are typically long running, whereas
    Docker application containers are short-lived. This makes LXD a machine management
    tool that is different to Docker and is closer to software distribution.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**LXD**是Ubuntu管理LXC的容器超级监视器。LXD是一个守护程序，提供运行容器和管理相关资源的REST API。LXD容器提供与传统虚拟机相同的用户体验，但使用LXC，这提供了类似于容器的运行性能和比虚拟机更好的利用率。LXD容器运行完整的Linux操作系统，因此通常运行时间较长，而Docker应用程序容器则是短暂的。这使得LXD成为一种与Docker不同的机器管理工具，并且更接近软件分发。'
- en: OpenVZ
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenVZ
- en: '**OpenVZ** is a container-based virtualization for Linux which allows the running
    of multiple secure, isolated Linux containers also known as **virtual environments**
    (**VEs**) and **virtual private server** (**VPS**) on a single physical server.
    OpenVZ enables better server utilization and ensures that applications do not
    conflict. It is similar to LXC. It can only run on a Linux-based OS. Since all
    OpenVZ containers share the same kernel version as hosts, users are not allowed
    to do any kernel modification. However, it also has the advantage of a low memory
    footprint due to the shared host kernel.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenVZ**是Linux的基于容器的虚拟化技术，允许在单个物理服务器上运行多个安全、隔离的Linux容器，也被称为**虚拟环境**（**VEs**）和**虚拟专用服务器**（**VPS**）。OpenVZ可以更好地利用服务器，并确保应用程序不发生冲突。它类似于LXC。它只能在基于Linux的操作系统上运行。由于所有OpenVZ容器与主机共享相同的内核版本，用户不允许进行任何内核修改。然而，由于共享主机内核，它也具有低内存占用的优势。'
- en: Windows Server containers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Server容器
- en: 'Windows Server 2016 introduced Linux containers to Microsoft workloads. Microsoft
    has partnered with Docker to bring the benefits of the Docker container to Microsoft
    Windows Server. They have also re-engineered the core windows OS to enable container
    technology. There are two types of Windows containers: Windows server containers
    and Hyper-V isolation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Server 2016将Linux容器引入了Microsoft工作负载。微软与Docker合作，将Docker容器的优势带到Microsoft
    Windows Server上。他们还重新设计了核心Windows操作系统，以实现容器技术。有两种类型的Windows容器：Windows服务器容器和Hyper-V隔离。
- en: Windows server containers are used for running application containers on Microsoft
    workloads. They use process and namespace isolation technology for ensuring the
    isolation between multiple containers. They also share the same kernel as the
    host OS, as these containers require the same kernel version and configuration
    as the host. These containers do not provide a strict security boundary and should
    not be used to isolate untrusted code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Windows服务器容器用于在Microsoft工作负载上运行应用程序容器。它们使用进程和命名空间隔离技术，以确保多个容器之间的隔离。它们还与主机操作系统共享相同的内核，因为这些容器需要与主机相同的内核版本和配置。这些容器不提供严格的安全边界，不应用于隔离不受信任的代码。
- en: Hyper-V containers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyper-V容器
- en: Hyper-V containers are types of Windows containers which provide higher security
    compared to Windows server containers. Hyper-V hosts Windows server containers
    in lightweight, highly optimized **Hyper-V** virtual machines. Thus, they bring
    a higher degree of resource isolation, but at the cost of efficiency and density
    on the host. They can be used when the trust boundaries of the host OS requires
    additional security. In this configuration, the kernel of the container host is
    not shared with other containers on the same host. Since these containers do not
    share the kernel with the host or other containers on the host, they can run kernels
    with different versions and configurations. Users can choose to run containers
    with or without Hyper-V isolation at runtime.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper-V容器是一种Windows容器，相对于Windows服务器容器提供了更高的安全性。Hyper-V在轻量级、高度优化的Hyper-V虚拟机中托管Windows服务器容器。因此，它们提供了更高程度的资源隔离，但以牺牲主机的效率和密度为代价。当主机操作系统的信任边界需要额外的安全性时，可以使用它们。在这种配置中，容器主机的内核不与同一主机上的其他容器共享。由于这些容器不与主机或主机上的其他容器共享内核，它们可以运行具有不同版本和配置的内核。用户可以选择在运行时使用或不使用Hyper-V隔离来运行容器。
- en: Clear container
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清晰容器
- en: Virtual machines are secure but very expensive and slow to start, whereas containers
    are fast and provide a more efficient alternative, but are less secure. Intel's
    Clear containers are a trade-off solution between hypervisor-based VMs and Linux
    containers that offer agility similar to that of conventional Linux containers,
    while also offering the hardware-enforced workload isolation of hypervisor-based
    VMs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机安全但非常昂贵且启动缓慢，而容器启动快速并提供了更高效的替代方案，但安全性较低。英特尔的清晰容器是基于Hypervisor的虚拟机和Linux容器之间的折衷解决方案，提供了类似于传统Linux容器的灵活性，同时还提供了基于硬件的工作负载隔离。
- en: A Clear container is a container wrapped in its own individual ultra-fast, trimmed
    down VM which offers security and efficiency. The Clear container model uses a
    fast and lightweight QEMU hypervisor that has been optimized to reduce memory
    footprints and improve startup performance. It has also optimized, in the kernel,
    the systemd and core user space for minimal memory consumption. These features
    improve the resource utilization efficiency significantly and offer enhanced security
    and speed compared to traditional VMs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰容器是一个包裹在自己独立的超快、精简的虚拟机中的容器，提供安全性和效率。清晰容器模型使用了经过优化以减少内存占用和提高启动性能的快速轻量级的QEMU
    hypervisor。它还在内核中优化了systemd和核心用户空间，以实现最小内存消耗。这些特性显著提高了资源利用效率，并相对于传统虚拟机提供了增强的安全性和速度。
- en: Intel Clear containers provide a lightweight mechanism to isolate the guest
    environment from the host and also provide hardware-based enforcement for workload
    isolation. Moreover, the OS layer is shared transparently and securely from the
    host into the address space of each Intel Clear container, providing an optimal
    combination of high security with low overhead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔清晰容器提供了一种轻量级机制，用于将客户环境与主机隔离，并为工作负载隔离提供基于硬件的执行。此外，操作系统层从主机透明、安全地共享到每个英特尔清晰容器的地址空间中，提供了高安全性和低开销的最佳组合。
- en: With the security and agility enhancements offered by Clear containers, they
    have seen a high adoption rate. Today, they seamlessly integrate with the Docker
    project with the added protection of Intel VT. Intel and CoreOS have collaborated
    closely to incorporate Clear containers into CoreOS's Rocket (Rkt) container runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于清晰容器提供的安全性和灵活性增强，它们的采用率很高。如今，它们与Docker项目无缝集成，并增加了英特尔VT的保护。英特尔和CoreOS密切合作，将清晰容器整合到CoreOS的Rocket（Rkt）容器运行时中。
- en: Installation of Docker
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的安装
- en: 'Docker is available in two editions, **Community Edition (CE)** and **Enterprise
    Edition (EE)**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有两个版本，**社区版（CE）**和**企业版（EE）**：
- en: '**Docker Community Edition (CE)**: It is ideal for developers and small teams
    looking to get started with Docker and may be experimenting with container-based
    apps'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker社区版（CE）**：它非常适合希望开始使用Docker并可能正在尝试基于容器的应用程序的开发人员和小团队。'
- en: '**Docker Enterprise Edition (EE)**: It is designed for enterprise development
    and IT teams who build, ship, and run business critical applications in production
    at scale'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker企业版（EE）**：它专为企业开发和IT团队设计，他们在生产环境中构建，发布和运行业务关键应用程序'
- en: 'This section will demonstrate the instructions for installing Docker CE on
    Ubuntu 16.04\. The Docker installation package, available in the official Ubuntu
    16.04 repository, may not be the latest version. To get the latest and greatest
    version, install Docker from the official Docker repository. This section shows
    you how to do just that:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示在Ubuntu 16.04上安装Docker CE的说明。在官方Ubuntu 16.04存储库中提供的Docker安装包可能不是最新版本。要获取最新版本，请从官方Docker存储库安装Docker。本节将向您展示如何做到这一点：
- en: 'First, add the GPG key for the official Docker repository to the system:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将官方Docker存储库的GPG密钥添加到系统中：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the Docker repository to APT sources:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker存储库添加到APT源：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, update the package database with the Docker packages from the newly added
    repository:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用新添加的存储库更新Docker软件包的软件包数据库：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make sure you are about to install Docker repository instead of the default
    Ubuntu 16.04 repository:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保要安装Docker存储库而不是默认的Ubuntu 16.04存储库：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see an output similar to the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that `docker-ce` is not installed, but the candidate for installation
    is from the Docker repository for Ubuntu 16.04\. The `docker-ce` version number
    might be different.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`docker-ce`未安装，但安装候选项来自Ubuntu 16.04的Docker存储库。`docker-ce`版本号可能不同。
- en: 'Finally, install Docker:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装Docker：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Docker should now be installed, the daemon started, and the process enabled
    to start on boot. Check that it''s running:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker现在应该已安装，守护程序已启动，并且已启用进程以在启动时启动。检查它是否正在运行：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that Docker CE is installed correctly by running the hello-world image:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行hello-world镜像验证Docker CE是否正确安装：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Docker hands-on
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker实践
- en: This section explains how to use Docker to run any application inside containers.
    The Docker installation explained in the previous section also installs the docker
    command-line utility or the Docker client. Let's explore the `docker` command.
    Using the `docker` command consists of passing it a chain of options and commands
    followed by arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何使用Docker在容器内运行任何应用程序。在上一节中解释的Docker安装也安装了docker命令行实用程序或Docker客户端。让我们探索`docker`命令。使用`docker`命令包括传递一系列选项和命令，后跟参数。
- en: 'The syntax takes this form:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 语法采用以下形式：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To view system wide information about Docker and the Docker version, use the
    following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有关Docker和Docker版本的系统范围信息，请使用以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Docker has many subcommands to manage multiple resources managed by the Docker
    daemon. Here is a list of management commands supported by Docker:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有许多子命令来管理Docker守护程序管理的多个资源。以下是Docker支持的管理命令列表：
- en: '| **Management command** | **Description** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **管理命令** | **描述** |'
- en: '| `Config` | Manages Docker configs |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Config` | 管理Docker配置 |'
- en: '| `container` | Manages containers |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `container` | 管理容器 |'
- en: '| `image` | Manages images |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `image` | 管理镜像 |'
- en: '| `network` | Manages networks |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `network` | 管理网络 |'
- en: '| `Node` | Manages Swarrn nodes |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Node` | 管理Swarrn节点 |'
- en: '| `Plugin` | Manages plugins |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Plugin` | 管理插件 |'
- en: '| `secret` | Manages Docker secrets |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `secret` | 管理Docker秘密 |'
- en: '| `Service` | Manages services |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Service` | 管理服务 |'
- en: '| `Stack` | Manages Docker stacks |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Stack` | 管理Docker堆栈 |'
- en: '| `Swarm` | Manages swarm |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Swarm` | 管理群集 |'
- en: '| `System` | Manages Docker |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `System` | 管理Docker |'
- en: '| `Volume` | Manages volumes |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Volume` | 管理卷 |'
- en: In the next section, we will explore container and image resources.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索容器和镜像资源。
- en: Working with Docker images
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker镜像工作
- en: An image is a lightweight, standalone executable package that includes everything
    needed to run a piece of software, including the code, a runtime, libraries, environment
    variables, and configuration files. Docker images are used to create Docker containers.
    Images are stored in the Docker Hub.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是一个轻量级的、独立的可执行包，包括运行软件所需的一切，包括代码、运行时、库、环境变量和配置文件。Docker镜像用于创建Docker容器。镜像存储在Docker
    Hub中。
- en: Listing images
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出镜像
- en: 'You can list all of the images that are available in the Docker host by running
    the Docker images subcommand. The default Docker images will show all top-level
    images, their repository and tags, and their size:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行Docker images子命令列出Docker主机中所有可用的镜像。默认的Docker镜像将显示所有顶级镜像，它们的存储库和标签，以及它们的大小：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Getting new images
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取新镜像
- en: Docker will automatically download any image that is not present in the Docker
    host system. The `docker pull` subcommand will always download the image that
    has the latest tag in that repository if a tag is not provided. If a tag is provided,
    it pulls the specific image with that tag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将自动下载在Docker主机系统中不存在的任何镜像。如果未提供标签，则`docker pull`子命令将始终下载该存储库中具有最新标签的镜像。如果提供了标签，它将拉取具有该标签的特定镜像。
- en: 'To pull a base image, do the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要拉取基础镜像，请执行以下操作：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Searching Docker images
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索Docker镜像
- en: 'One of the most important features of Docker is that a lot of people have created
    Docker images for a variety of purposes. Many of these have been uploaded to Docker
    Hub. You can easily search for Docker images in the Docker Hub registry by using
    the docker search subcommand:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docker最重要的功能之一是许多人为各种目的创建了Docker镜像。其中许多已经上传到Docker Hub。您可以通过使用docker search子命令在Docker
    Hub注册表中轻松搜索Docker镜像：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Deleting images
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除镜像
- en: 'To delete an image, run the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个镜像，请运行以下命令：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please refer to the Docker documentation for the rest of the commands related
    to Docker images.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关与Docker镜像相关的其余命令，请参考Docker文档。
- en: Working with Docker containers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器工作
- en: A container is a runtime instance of an image. It runs completely isolated from
    the host environment by default, only accessing host files and ports if configured
    to do so.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行时实例。默认情况下，它完全与主机环境隔离，只有在配置为这样做时才能访问主机文件和端口。
- en: Creating containers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建容器
- en: 'Launching a container is simple, as `docker run` passes the image name you
    would like to run and the command to run this within the container. If the image
    doesn''t exist on your local machine, Docker will attempt to fetch it from the
    public image registry:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器很简单，因为`docker run`传递了您想要运行的镜像名称以及在容器内运行此命令。如果镜像不存在于本地机器上，Docker将尝试从公共镜像注册表中获取它：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, the container will start, print hello world, and then
    stop. Containers are designed to stop once the command executed within them has
    exited.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，容器将启动，打印hello world，然后停止。容器被设计为在其中执行的命令退出后停止。
- en: 'As an example, let''s run a container using the latest image in Ubuntu. The
    combination of the `-i` and `-t` switches gives you interactive shell access to
    the container:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用Ubuntu中的最新镜像运行一个容器。`-i`和`-t`开关的组合为您提供了对容器的交互式shell访问：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing containers
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出容器
- en: 'You can list the all containers running on the Docker host using the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令列出在Docker主机上运行的所有容器：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Checking container's logs
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查容器的日志
- en: 'You can also view the information logged by a running container using the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下方法查看正在运行的容器记录的信息：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Starting containers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动容器
- en: 'You can start a stopped container using the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方法启动已停止的容器：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, you can use commands such as stop, pause, unpause, reboot, restart,
    and so on to operate containers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用诸如停止、暂停、取消暂停、重启、重新启动等命令来操作容器。
- en: Deleting containers
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'You can also delete a stopped container using the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下方法删除已停止的容器：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Please refer to the Docker documentation for the rest of the commands related
    to Docker containers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Docker 容器的其他命令，请参考 Docker 文档。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about containers and their types. We have also
    learned about the components in containers. We took a look at the different container
    runtime tools. We took a deep dive into Docker, we installed it, and we did a
    hands-on exercise. We also learned the commands for managing containers and images
    using Docker. In the next chapter, we will read about different COE tools available
    today.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了容器及其类型。我们还了解了容器中的组件。我们看了不同的容器运行时工具。我们深入了解了 Docker，安装了它，并进行了实际操作练习。我们还学习了使用
    Docker 管理容器和镜像的命令。在下一章中，我们将了解当今可用的不同 COE 工具。
