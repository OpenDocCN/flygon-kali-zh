- en: Chapter 3. Decision Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。决策结构
- en: Every application makes some kind of decisions. In Java there are several programming
    constructs that we can use to make these decisions. These include logical expressions,
    the if statement, and the switch statement. The purpose of this chapter is to
    introduce these tools to you and illustrate how they can be used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都会做出某种决定。在Java中，有几种编程构造可以用来做出这些决定。这些包括逻辑表达式、if语句和switch语句。本章的目的是向您介绍这些工具，并说明它们如何使用。
- en: We will begin with a discussion of logical expressions as they are central to
    making decisions. Logical expressions are expressions that return a Boolean value.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从逻辑表达式的讨论开始，因为它们对做决定至关重要。逻辑表达式是返回布尔值的表达式。
- en: Next, we will examine how the logical expressions can be used with the `if`
    statement and the conditional operator. There are numerous variations on how a
    `if` statement can be structured and we will look at their advantages and disadvantages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究逻辑表达式如何与`if`语句和条件运算符一起使用。`if`语句的结构有许多变化，我们将看看它们的优缺点。
- en: This will be followed up with a discussion of the switch statement. Prior to
    Java 7, switch statements were based on integer or enumeration values. In Java
    7, we can now use `String` values. The use of Strings and their potential pitfalls
    are examined.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将讨论`switch`语句。在Java 7之前，`switch`语句基于整数或枚举值。在Java 7中，我们现在可以使用`String`值。我们将研究字符串的使用及其潜在的问题。
- en: The last section addresses general control structure issues along with the impact
    of floating point numbers when making decisions, comparing objects, and a discussion
    of useful ways of organizing code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节讨论了一般的控制结构问题，以及在做决定、比较对象时浮点数的影响，以及组织代码的有用方法的讨论。
- en: 'In this chapter we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Examine the nature of decision constructs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究决策结构的性质
- en: Examine the basics of logical expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究逻辑表达式的基础知识
- en: Learn how to use the `if` statement and look at its variations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`if`语句，并查看其变体
- en: Understand the conditional operator and when it should be used
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解条件运算符以及何时应该使用它
- en: Explore the switch statement and Java 7's use of strings with this statement
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`switch`语句和Java 7在该语句中使用字符串的方式
- en: Determine how floating point number comparisons impact control
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定浮点数比较如何影响控制
- en: Examine the pitfalls associated with comparing objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究与比较对象相关的潜在问题
- en: Flow of control
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: In any application, the flow of control within a program is determined by the
    order in which the statements are executed. It is convenient to consider groups
    of statements as blocks whose execution is controlled by decision statements.
    A block can be considered to be an individual statement or several statements
    contained within a block statement. A block statement in Java is a group of statements
    enclosed in open and close curly braces.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，程序内的控制流由语句执行的顺序决定。方便起见，可以将语句组视为由决策语句控制执行顺序的块。块可以被视为一个单独的语句或包含在块语句中的多个语句。在Java中，块语句是一组用大括号括起来的语句。
- en: Control statement – an overview
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制语句 - 概述
- en: 'Control structures are those parts of the language that determine the order
    in which individual statements are executed. Without control structures, statements
    are executed sequentially, as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构是语言中确定个别语句执行顺序的部分。没有控制结构，语句将按顺序执行，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To vary the order in which the statements are executed, control statements
    are used. In Java, these statements include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变语句的执行顺序，使用控制语句。在Java中，这些语句包括：
- en: 'The `if` statement: This statement is frequently used to decide which of two
    branches to take'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句：这个语句经常用于决定采取哪个分支'
- en: 'Conditional operator: This statement is a simplified and limited form of the
    `if` statement'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件运算符：这个语句是`if`语句的简化和有限形式
- en: 'The `switch` statement: This statement is used to decide which of several branches
    to take'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句：这个语句用于决定采取哪个分支'
- en: The `switch` statement uses either an integer, enumeration, or a string value
    to make a decision. To understand the `if` statement requires an understanding
    of the logical expressions. This is covered in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句使用整数、枚举或字符串值来做出决定。要理解`if`语句需要理解逻辑表达式。这将在下一节中介绍。'
- en: Logical expressions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑表达式
- en: 'As with all expressions, a logical expression consists of operators and operands.
    In Java there are a limited number of logical operators as summarized in the following
    table. It is a subset of the operators listed in [Chapter 2](ch02.html "Chapter 2. Java
    Data Types and Their Usage"), *Java Data Types and Their Usage*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有表达式一样，逻辑表达式由运算符和操作数组成。在Java中，有限数量的逻辑运算符如下表所总结的那样。它是[第2章](ch02.html "第2章。Java数据类型及其用法")中列出的运算符的子集，*Java数据类型及其用法*：
- en: '| Precedence | Operator | Associativity | Meaning |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 优先级 | 运算符 | 结合性 | 意义 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | … |   |   |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1 | … |   |   |'
- en: '| `!` | Right | Logical complement |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 右 | 逻辑补 |'
- en: '| … |   |   |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| … |   |   |'
- en: '| … |   |   |   |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| … |   |   |   |'
- en: '| 5 | `<`, `<=`, `>`, and `>=` | Left | Logical |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `<`, `<=`, `>`, 和 `>=` | 左 | 逻辑 |'
- en: '| `instanceof` | Left | Type comparison |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `instanceof` | 左 | 类型比较 |'
- en: '| 6 | `==` and `!=` | Left | Equality and inequality |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `==` 和 `!=` | 左 | 相等和不相等 |'
- en: '| … |   |   |   |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| … |   |   |   |'
- en: '| 10 | `&&` | Left | Logical AND |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `&&` | 左 | 逻辑与 |'
- en: '| 11 | `&#124;&#124;` | Left | Logical OR |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `||` | 左 | 逻辑或 |'
- en: '| 12 | `?:` | Right | Conditional |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `?:` | 右 | 条件 |'
- en: '| … |   |   |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| … |   |   |   |'
- en: The operands of a logical expression may be of any data type, but a logical
    expression will always evaluate to a `true` or a `false` value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式的操作数可以是任何数据类型，但逻辑表达式总是评估为`true`或`false`值。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse the bitwise operators, `&`, `^`, and `|` with the corresponding
    logical operators `&&` and `||`. The bitwise operators perform similar operations
    as the logical operators, but do it on a bit-by-bit basis.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将按位运算符`&`、`^`和`|`与相应的逻辑运算符`&&`和`||`混淆。按位运算符执行与逻辑运算符类似的操作，但是逐位执行。
- en: Boolean variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔变量
- en: 'The words `true` and `false` are keywords in Java. Their names correspond to
    their values and they can be assigned to Boolean variables. A Boolean variable
    can be declared with the `boolean` keyword followed by the variable name and an
    optional initial value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`和`false`是Java中的关键字。它们的名称对应它们的值，并且可以赋给布尔变量。布尔变量可以用`boolean`关键字声明，后面跟着变量名和可选的初始值：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When a logical expression is evaluated, it will return either a `true` or a
    `false` value. Examples of logical expressions include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当逻辑表达式被评估时，它将返回`true`或`false`值。逻辑表达式的示例包括以下内容：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is a good practice to give a Boolean variable a name that reflects a state
    of `true` or `false`. The `isComplete` variable implies that an operation has
    completed. The variable, `isReady`, if set to true suggests that something is
    ready.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给布尔变量一个反映`true`或`false`状态的名称是一个好习惯。`isComplete`变量意味着一个操作已经完成。如果`isReady`变量设置为true，则表示某物已经准备好。
- en: The equality operator
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等于运算符
- en: The equality operator consists of two equals signs and when evaluated will return
    either a `true` or a `false` value. The assignment operator uses a single equal
    sign and will modify its left operand. To illustrate these operators, consider
    the following example. If a value of a `rate` variable equals `100`, we could
    assume that an error is present. To reflect this error condition we could assign
    a `true` value to the `errorPresent` variable. This can be performed using both
    the assignment and the equality operators.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 等于运算符由两个等号组成，当评估时将返回`true`或`false`值。赋值运算符使用单个等号，并将修改其左操作数。为了说明这些运算符，考虑以下示例。如果`rate`变量的值等于`100`，我们可以假设存在错误。为了反映这种错误条件，我们可以将`true`值赋给`errorPresent`变量。这可以使用赋值和等于运算符来执行。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the preceding code snippet is executed we get the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，我们得到以下输出：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The logical expression, `rate==100`, compares the value stored in `rate` to
    the integer literal `100`. If they are equal, which is the case here, the expression
    returns `true`. The `true` value is then assigned to `errorPresent`. If the value
    stored in `rate` had not been `100`, then the expression will return a value of
    `false`. We will examine the use of the equality operator in more depth in the
    *Comparing floating point numbers* and *Comparing objects* sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式`rate==100`比较存储在`rate`中的值与整数文字`100`。如果它们相等，这里就是这种情况，表达式返回`true`。然后将`true`值赋给`errorPresent`。如果存储在`rate`中的值不是`100`，则表达式将返回`false`值。我们将更深入地研究等于运算符在*比较浮点数*和*比较对象*部分的使用。
- en: Relational operators
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Relational operators are used to determine the relationship, or relative ordering,
    between two operands. These operators frequently use two symbols. For example,
    greater than or equal to is expressed using the `>=` operator. The ordering of
    the symbols is important. Using `=>` is not legal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符用于确定两个操作数之间的关系或相对顺序。这些运算符经常使用两个符号。例如，大于或等于使用`>=`运算符表示。符号的顺序很重要。使用`=>`是不合法的。
- en: 'The relational operators are listed in the following table:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符列在下表中：
- en: '| Operator | Meaning | Simple example |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: 操作符 | 意义 | 简单示例
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '--- | --- | ---'
- en: '| `<` | Less than | `age<35` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: 小于 | `<` | `age<35`
- en: '| `<=` | Less than or equal | `age<=35` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: 小于或等于 | `<=` | `age<=35`
- en: '| `>` | Greater than | `age>35` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: 大于 | `>` | `age>35`
- en: '| `>=` | Greater than or equal | `age>=35` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: 大于或等于 | `>=` | `age>=35`
- en: '| `==` | Equal | `age==35` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: 等于 | `==` | `age==35`
- en: 'If we wish to determine whether an age is greater than 25 and less than 35,
    we will have to use the `age` variable twice and in combination with the `&&`
    operator, shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望确定一个年龄是否大于25且小于35，我们将不得不两次使用`age`变量，并与`&&`运算符结合使用，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the following expression may make sense to us, it is illegal in Java.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下表达式对我们可能有意义，但在Java中是不合法的。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The reason that the variable `age` must be used twice, as in the preceding example,
    is because the relational operators are binary operators. That is, each binary
    operator acts on two operands. In the preceding expression, we compared `25` to
    see if it is less than `age`. The operation will return either a `true` or a `false`
    value. Next, the true or false result will be compared to `35` which does not
    make sense and is illegal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以在前面的示例中变量`age`必须使用两次，是因为关系运算符是二元运算符。也就是说，每个二元运算符作用于两个操作数。在前面的表达式中，我们比较`25`，看它是否小于`age`。操作将返回`true`或`false`值。接下来，将true或false结果与`35`进行比较，这是没有意义的，也是不合法的。
- en: These are the rules of the language. We can't break these rules, therefore it
    is important for us to understand the rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是语言的规则。我们不能违反这些规则，因此重要的是我们理解这些规则。
- en: Logical operators
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: When we think about how we make decisions, we often use logical constructs such
    as AND and OR. We may make a decision if two conditions are both true, or we may
    decide to do something if either of the two conditions are true. The AND operator
    implies that both conditions must be true while OR implies that only one of the
    conditions need to be true.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑如何做决定时，我们经常使用逻辑结构，比如AND和OR。如果两个条件都为真，我们可能会做出决定，或者如果两个条件中的任何一个为真，我们可能会决定做某事。AND运算符意味着两个条件都必须为真，而OR意味着两个条件中只有一个需要为真。
- en: These two operations are the basis for most logical expressions. We will often
    decide to do something if some condition is not true. We may decide not to walk
    the dog if it is raining. The NOT is also an operator used to make decisions.
    When used, it changes a true to a false and a false to a true.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作是大多数逻辑表达式的基础。我们经常会决定在某些条件不成立时做一些事情。如果下雨，我们可能决定不遛狗。NOT也是用于做决定的运算符。使用时，它将true变为false，false变为true。
- en: 'There are three logical operators implementing these logical constructs in
    Java. They are summarized in the following table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中有三个逻辑运算符来实现这些逻辑结构。它们总结如下表：
- en: '| Operator | Meaning | Simple Example |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 | 简单示例 |'
- en: '| --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `&&` | AND | `age > 35 && height < 67` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | AND | `age > 35 && height < 67` |'
- en: '| `&#124;&#124;` | OR | `age > 35 &#124;&#124; height < 67` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | OR | `age > 35 &#124;&#124; height < 67` |'
- en: '| `!` | NOT | `!(age > 35)` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `!` | NOT | `!(age > 35)` |'
- en: 'The AND, OR, and NOT operators are based on the following truth tables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AND、OR和NOT运算符基于以下真值表：
- en: '![Logical operators](img/7324_02_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑运算符](img/7324_02_07.jpg)'
- en: Some decisions can be more complicated and we express these decision evaluations
    using more complex combinations of the operators, `&&`, `||`, or `!`. We may decide
    to go to the movie if it is not raining and if either we have enough money or
    a friend is going to pay our way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些决策可能更加复杂，我们使用`&&`、`||`或`!`运算符的更复杂的组合来表达这些决策评估。如果下雨，我们可能决定去看电影，如果我们有足够的钱或朋友将付我们的路费。
- en: If (it is not raining) AND
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（不下雨）并且
- en: ( (we have enough money) OR (a friend will pay our way)) THEN
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （（我们有足够的钱）或（朋友会付我们的路费））然后
- en: We will go to the movie
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将去看电影
- en: 'Parentheses can be used to control the order of evaluation of logical operators
    in the same way they control the order of evaluation of arithmetic operators.
    In the following code sequence, the existence of errors is determined by the values
    stored in the `rate` and `period` variables. These statements are equivalent,
    but differ in their use of parentheses. The use of the parentheses in the second
    statement is not strictly needed but it does make it clearer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 括号可以用来控制逻辑运算符的评估顺序，就像它们控制算术运算符的评估顺序一样。在下面的代码序列中，错误的存在是由`rate`和`period`变量中存储的值决定的。这些语句是等价的，但在使用括号的方式上有所不同。在第二个语句中使用括号并不是严格需要的，但它确实使其更清晰：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following statement, a set of parentheses is used to force the `||`
    operator to be executed before the `&&` operator. As the `&&` operator has higher
    precedence than the `||` operator, we need to use parentheses to change the order
    of evaluation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的语句中，使用一组括号来强制执行`||`运算符先于`&&`运算符。由于`&&`运算符的优先级高于`||`运算符，我们需要使用括号来改变评估顺序：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Parentheses always take precedence over other operators.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 括号始终优先于其他运算符。
- en: Short circuit evaluation
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路评估
- en: '**Short** **circuiting** is the process of not completely evaluating a logical
    expression once the result becomes obvious. There are two operators in Java that
    short circuit—the logical `&&` and `||` operators.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**短路**是一种在结果变得明显后不完全评估逻辑表达式的过程。在Java中有两个运算符可以进行短路——逻辑`&&`和`||`运算符。'
- en: Using the && operator
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`&&`运算符
- en: 'Let''s consider the logical `&&` operator first. In the following example,
    we are trying to determine if `sum` is greater than `1200` and `amount` is less
    than `500`. For the logical expression to return true, both conditions must be
    met:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑逻辑`&&`运算符。在下面的例子中，我们试图确定`sum`是否大于`1200`且`amount`是否小于`500`。为了逻辑表达式返回true，必须满足两个条件：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, if the first condition is false then there is no reason to evaluate
    the rest of the expression. Regardless of the value of the second condition, the
    `&&` operator will return false. With short circuiting, the second condition is
    not evaluated, saving some processing time especially if the operation is time
    consuming.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果第一个条件为false，则没有理由评估表达式的其余部分。无论第二个条件的值如何，`&&`运算符都将返回false。通过短路，第二个条件不会被评估，尤其是在操作耗时的情况下，可以节省一些处理时间。
- en: 'We can verify this behavior by using the following two functions. They both
    return `false` values and display messages as they execute:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下两个函数来验证这种行为。它们都返回`false`值并在执行时显示消息：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we use them in an `if` statement, shown as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`if`语句中使用它们，如下所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we execute the preceding code sequence, we get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的代码序列时，我们得到以下输出：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `evaluateThis` method executed and returned `false`. As it returned `false`,
    the `evaluateThat` method was not executed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluateThis`方法执行并返回`false`。由于它返回`false`，`evaluateThat`方法没有被执行。'
- en: Using the || operator
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`||`运算符
- en: 'The logical `||` operator works in a similar fashion. If the first condition
    evaluates to `true`, there is no reason to evaluate the second condition. This
    is demonstrated in the following code sequence where the `evaluateThis` method
    has been modified to return `true`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑`||`运算符的工作方式类似。如果第一个条件评估为`true`，就没有理由评估第二个条件。这在下面的代码序列中得到了证明，其中`evaluateThis`方法已被修改为返回`true`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Executing this code sequence results in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码序列将产生以下输出：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Avoiding short circuit evaluation
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免短路评估
- en: 'Normally, short circuiting an expression is an efficient technique. However,
    if we invoked a method as we did in the last example and the program depended
    on the second method executing it can cause unanticipated problems. Suppose we
    had written the `evaluateThat` method as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，短路表达式是一种有效的技术。然而，如果我们像在上一个例子中那样调用一个方法，并且程序依赖于第二个方法的执行，这可能会导致意想不到的问题。假设我们已经编写了`evaluateThat`方法如下：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the logical expression is short circuited, the `state` variable will not
    be changed. If the programmer mistakenly assumed that the `evaluateThat` method
    would always be executed, then this could result in logic error when the value
    assigned to `state` is incorrect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当逻辑表达式被短路时，`state`变量将不会被改变。如果程序员错误地假设`evaluateThat`方法总是会被执行，那么当分配给`state`的值不正确时，这可能导致逻辑错误。
- en: The `evaluateThat` method is said to have a side effect. One can argue whether
    or not it is a good practice to use methods that have side effects. Regardless,
    you may run across code that uses side effects and you need to understand its
    behavior.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 据说`evaluateThat`方法具有副作用。人们可以争论是否使用具有副作用的方法是一种良好的实践。无论如何，您可能会遇到使用副作用的代码，您需要了解其行为。
- en: One alternative to avoid the short circuit of logical expressions is to use
    the bitwise AND (`&`) and OR (`|`) operators. These bitwise operators perform
    the `&&` or `||` operations bit-by-bit for each bit of the operand. As the internal
    representation of the keywords, `true` and `false`, use a single bit, the result
    should be the same as returned by the corresponding logical operators. The difference
    is that the short circuit operation is not performed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 避免逻辑表达式短路的一种替代方法是使用按位与（`&`）和按位或（`|`）运算符。这些按位运算符对操作数的每个位执行`&&`或`||`运算。由于关键字`true`和`false`的内部表示使用单个位，因此结果应该与相应的逻辑运算符返回的结果相同。不同之处在于不执行短路操作。
- en: 'Using the previous example, if we use the `&` operator instead of the `&&`
    operator, as shown in the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的例子，如果我们使用`&`运算符而不是`&&`运算符，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will get the following output, showing that both methods were executed when
    we execute the code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们将得到以下输出，显示两种方法都被执行：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The if statement
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if语句
- en: 'The `if` statement is used to control the flow of execution based on a Boolean
    expression. There are two basic forms that can be used and there are several variations.
    The `if` statement consists of the `if` keyword, followed by a logical expression
    enclosed in parentheses and then by a statement. In the following diagram a graphical
    depiction of a simple `if` statement is presented:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句用于根据布尔表达式控制执行流程。有两种基本形式可以使用，还有几种变体。`if`语句由`if`关键字组成，后面跟着用括号括起来的逻辑表达式，然后是一个语句。在下图中，呈现了一个简单`if`语句的图形描述：'
- en: '![The if statement](img/7324_03_01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![if语句](img/7324_03_01.jpg)'
- en: 'The following illustrates this form of the `if` statement where we compare
    `rate` to `100` and if it is equal to `100` we display a message to that effect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了`if`语句的这种形式，我们比较`rate`和`100`，如果它等于`100`，我们显示相应的消息：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, this is not as readable as the following equivalent example where
    we spilt the `if` statement across two lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不如下面的等效示例易读，我们将`if`语句分成两行：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we will see later, it is better to always use a block statement with `if`
    statements. The following is logically equivalent to the previous `if` statement
    but is more readable and maintainable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面看到，最好总是在`if`语句中使用块语句。以下逻辑上等同于先前的`if`语句，但更易读和易维护：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second form of the `if` statement uses the `else` keyword to designate
    the statement to execute, if the logical expression evaluates to `false`. The
    following diagram graphically illustrates this version of the `if` statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的第二种形式使用`else`关键字来指定逻辑表达式评估为`false`时要执行的语句。以下图表形象地说明了`if`语句的这个版本：'
- en: '![The if statement](img/7324_03_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![if语句](img/7324_03_02.jpg)'
- en: 'The `if` statement is illustrated as follows, using the preceding example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的例子，`if`语句如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the expression evaluates to `true`, the first block is executed and then
    control passes to the end of the `if` statement. If the expression evaluates to
    `false`, the second block is executed. In this example, each block consists of
    a single statement but it doesn't have to be this way. Multiple statements can
    be used within the blocks. The choice of the number of statements depends on what
    we are trying to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式评估为`true`，则执行第一个块，然后控制传递到`if`语句的末尾。如果表达式评估为`false`，则执行第二个块。在这个例子中，每个块都包含一个语句，但不一定非要这样。块内可以使用多个语句。选择使用多少语句取决于我们要做什么。
- en: 'The simpler form of the `if` statement eliminates the `else` clause. Suppose
    we want to display an error message when a certain limit has been exceeded, otherwise
    do nothing. This can be accomplished by not using the `else` clause, as shown
    in the following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的简化形式消除了`else`子句。假设我们想在超过某个限制时显示错误消息，否则什么也不做。这可以通过不使用`else`子句来实现，如下面的代码片段所示：'
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only time that the message is displayed is when the limit has been exceeded.
    Note the use of the block statement. Even though it includes only a single statement
    it is still a good practice to use it. If we ever decide we need to do something
    more than simply displaying the error message, such as change the limit or reset
    the amount, then we will need a block statement. It is best to be prepared:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在超过限制时才显示消息。请注意块语句的使用。即使它只包含一个语句，使用它仍然是一个良好的实践。如果我们决定需要做的事情不仅仅是显示错误消息，比如更改限制或重置金额，那么我们将需要一个块语句。最好做好准备：
- en: Some developers do not like this simpler form and will always use an else clause.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员不喜欢这种简化形式，他们总是使用else子句。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Do nothing` comment serves to document the `else` clause. Should we decide
    to actually do something, such as place an order, then this is where we would
    add the code. With the use of the explicit `else` clause, we at least have to
    think about what could, or should, go there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Do nothing`注释用于记录`else`子句。如果我们决定实际做一些事情，比如下订单，那么这就是我们将添加代码的地方。通过使用显式的`else`子句，我们至少需要考虑可能或应该在那里做什么。'
- en: 'You may also encounter the **empty statement** . This statement consists of
    a single semicolon. When executed, it does nothing. It is commonly used as a place
    holder indicating that nothing is to be done. The previous `if` statement is modified
    in the following code snippet to use the empty statement:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能遇到**空语句**。这个语句由一个分号组成。执行时，它什么也不做。它通常用作占位符，表示不需要做任何事情。在下面的代码片段中，修改了前一个`if`语句，以使用空语句：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This does not add anything to the `if` statement and it is not a problem to
    use it here. In [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping
    Constructs*, we will examine how the careless use of an empty statement can cause
    problems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有给`if`语句增加任何东西，这里使用它也不是问题。在[第5章](ch05.html "第5章。循环结构")中，*循环结构*，我们将研究如何粗心地使用空语句可能会导致问题。
- en: Nested if statements
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套if语句
- en: 'Nesting `if` statements within each other provide another technique for making
    decisions. A `if` statement is nested if it is enclosed within the `then` or `else`
    clause of another `if` statement. In the following example, a `if` statement is
    found within the `then` clause of the first `if` statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在彼此内部嵌套`if`语句提供了另一种决策技术。如果`if`语句被包含在另一个`if`语句的`then`或`else`子句中，则称为嵌套`if`语句。在下面的例子中，一个`if`语句在第一个`if`语句的`then`子句中找到：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is no limit on where the nested `if` can be used. It can be in either
    the `then` or `else` clauses. In addition, there is no limit as to how deeply
    they can be nested. We can place a `if` inside of a `if` inside of a `if` and
    so forth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套`if`的使用没有限制。它可以在`then`或`else`子句中。此外，它们可以嵌套的深度也没有限制。我们可以把`if`放在`if`的内部，依此类推。
- en: The else-if variation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: else-if变体
- en: 'In some programming languages there is a `elseif` keyword that provides a way
    of implementing a multiple-select `if` statement. Graphically, the logic of this
    statement is depicted in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程语言中，有一个`elseif`关键字，提供了一种实现多选择`if`语句的方法。从图形上看，这个语句的逻辑如下图所示：
- en: '![The else-if variation](img/7324_03_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![else-if变体](img/7324_03_03.jpg)'
- en: 'Java does not have the `elseif` keyword but the same effect can be achieved
    using nested if statements. Let''s say we want to compute a shipping cost that
    is dependent on which of four regions of the country we are shipping to—East,
    North Central, South Central or West. We can do this using a series of `if` statements
    where each one is effectively nested inside of the `else` clause of the previous
    `if` statement. The first `if` statement that evaluates to true will have its
    body executed and the other `if` statements will be ignored:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Java没有`elseif`关键字，但可以使用嵌套的if语句来实现相同的效果。假设我们想要计算一个取决于我们要运送到国家的四个地区中的哪一个而定的运费——东部、北部中部、南部中部或西部。我们可以使用一系列`if`语句来实现这一点，其中每个`if`语句实际上都嵌套在前一个`if`语句的`else`子句中。第一个评估为true的`if`语句将执行其主体，其他`if`语句将被忽略：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code sequence is equivalent to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码序列等同于以下内容：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The second example achieves the same result as the first one but requires more
    indention. In the *The switch statement* section, we will demonstrate how to achieve
    the same result using a switch statement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子实现了与第一个相同的结果，但需要更多的缩进。在*switch语句*部分，我们将演示如何使用switch语句实现相同的结果。
- en: The if statement – usage issues
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句-使用问题
- en: 'There are several issues that you should keep in mind when working with `if`
    statements. In this section we will examine the following issues:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`if`语句时，有几个问题需要记住。在本节中，我们将讨论以下问题：
- en: Misusing the equality operator
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滥用等号运算符
- en: Using Boolean variables instead of logical expressions
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔变量而不是逻辑表达式
- en: Using true or false in a logical expression
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在逻辑表达式中使用true或false
- en: The perils of not using a block statement
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用块语句的危险
- en: The dangling else problem
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬空else问题
- en: Misusing the equality operator
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用等号运算符
- en: One nice feature of the Java language is the inability to write code that accidentally
    uses the assignment operator where the equality operator was meant to be. This
    happens frequently in the C programming language where the code compiles cleanly
    but results in logic errors or worse terminates abnormally at run-time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言的一个很好的特性是，无法编写意外使用赋值运算符而意味着等号运算符的代码。这在C编程语言中经常发生，代码可以编译，但会导致逻辑错误，或者更糟糕的是在运行时异常终止。
- en: 'For example, the following code snippet compares `rate` to see if it is equal
    to `100`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的代码片段比较`rate`，看它是否等于`100`：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, if we had used the assignment operator instead, as shown in the following
    code snippet, we will generate a syntax error:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用赋值运算符，如下面的代码片段所示，将会生成语法错误：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A syntax error similar to the following will be generated:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成类似以下的语法错误：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This type of errors is eliminated in Java. The use of the equality operator
    with floating point numbers is covered in the *Comparing floating point numbers*
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误在Java中被消除。使用等号运算符与浮点数的比较在*比较浮点数*部分中有所涉及。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the error message says it found a `int` value. This is because the
    assignment operator returned a **residual value** . The assignment operator will
    modify the operand to its left and return the value that it assigned to that operand.
    This value is the residual value. It is left over from the operation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，错误消息说它找到了一个`int`值。这是因为赋值运算符返回了一个**剩余值**。赋值运算符将修改其左边的操作数，并返回分配给该操作数的值。这个值是剩余值。它是操作的剩余部分。
- en: 'Understanding the concept of residual value explains the error message. It
    also explains why the following expression works:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 理解剩余值的概念解释了错误消息。它还解释了为什么以下表达式有效：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The effect of the expression is to assign `10` to each of the variables. The
    associativity for the assignment is right to left. That is, when there are multiple
    assignment operators in an expression, they are evaluated right to left. The value
    `10` is assigned to `k` and the assignment operator returned a residual value
    of `10`. The residual value is then assigned to `j` and so forth.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的效果是将`10`赋给每个变量。赋值的结合性是从右到左。也就是说，当表达式中有多个赋值运算符时，它们会从右到左进行评估。值`10`被赋给`k`，并且赋值运算符返回了一个剩余值`10`。然后将剩余值赋给`j`，依此类推。
- en: Using inverse operations
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用逆操作
- en: 'When using relational operators, there are frequently more ways than one to
    write the expression. For example, the following code sequence determines whether
    someone is of legal age or not:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关系运算符时，通常有多种编写表达式的方法。例如，以下代码序列确定某人是否达到法定年龄：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, this code sequence could have also been written as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个代码序列也可以这样写：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Which approach is better? In this example, it could be argued that either approach
    will work. However, it is best to use the form which is most natural to the problem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？在这个例子中，可以说任何一种方法都可以。然而，最好使用最符合问题的形式。
- en: 'Note that the operations displayed in the following table are inverse operations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下表中显示的操作是逆操作：
- en: '| Operation | Inverse Operation |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 逆操作 |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<` | `>=` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `>=` |'
- en: '| `>` | `<=` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `<=` |'
- en: Note the use of the constant, `LEGAL_AGE`. It is preferable to use an identifier
    when possible for values such as a legal age. If we did not and the value was
    used in multiple places, then changing the value only has to be done in one place.
    In addition, it avoids the mistake of accidentally using the wrong number in one
    of its occurrences. Also, making the number constant eliminates the possibility
    of accidentally modifying a value that should not be modified while the program
    is running.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意常量`LEGAL_AGE`的使用。尽可能使用标识符来表示诸如法定年龄之类的值是更好的。如果我们没有这样做，并且该值在多个地方使用，那么只需在一个地方更改该值即可。此外，这样做可以避免在其某个出现中意外使用错误的数字。此外，将数字设为常量可以消除在程序运行时意外修改不应修改的值的可能性。
- en: Using Boolean variables instead of logical expressions
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用布尔变量而不是逻辑表达式
- en: 'As we saw in the *Boolean variables* section, we can declare a Boolean variable
    and then use it as part of a logical expression. We can use a Boolean variable
    to hold the result of a logical expression, as shown in the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*布尔变量*部分看到的，我们可以声明一个布尔变量，然后将其用作逻辑表达式的一部分。我们可以使用布尔变量来保存逻辑表达式的结果，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This can be advantageous for two reasons:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个优点：
- en: It allows us to re-use the result later, if we need to
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，它允许我们稍后重复使用结果
- en: It makes the code more readable, if we use a meaningful Boolean variable name
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用一个有意义的布尔变量名，代码会更易读
- en: 'We can also use the negation operator to change the order of the `then` and
    `else` clauses as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用否定运算符来改变`then`和`else`子句的顺序，如下所示：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This example will frequently be more confusing than the previous one. We could
    make it potentially even more confusing by using a poorly worded Boolean variable
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子通常会比前一个更令人困惑。我们可以通过使用一个用词不当的布尔变量来使它变得更加令人困惑：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While this is readable and valid, a general rule is to avoid double negatives
    just as we try to do in the English language.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是可读的和有效的，但一个一般规则是要避免双重否定，就像我们在英语中尝试做的那样。
- en: Using true or false in a logical expression
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在逻辑表达式中使用true或false
- en: 'The `true` and `false` keywords can be used in a logical expression. However,
    they are not necessary, are redundant, and clutter up the code with little value
    added. Note the use of the `true` keyword in the following logical `if` statement:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`和`false`关键字可以用在逻辑表达式中。但它们并不是必需的，是多余的，并且使代码变得混乱，增加了很少的价值。请注意在以下逻辑`if`语句中使用`true`关键字：'
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The explicit use of the sub expression, `== true`, is not necessary. The same
    is true when using the `false` keyword. It is clearer and simpler to use the Boolean
    variable by itself as used in the earlier examples.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 显式使用子表达式`== true`是不必要的。当使用`false`关键字时也是如此。使用布尔变量本身更清晰、更简单，就像前面的例子中使用的那样。
- en: The perils of not using the block statement
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不使用块语句的危险
- en: 'As a block statement is considered to be a statement, this allows multiple
    statements to be included with either part of the `if` statement, as illustrated
    in the following code snippet:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于块语句被视为一个语句，这允许在`if`语句的任一部分中包含多个语句，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Block statements are not actually required when only one statement is needed
    for the `then` or `else` clause, but are encouraged. A similar, but invalid `if`
    statement, would look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当`then`或`else`子句只需要一个语句时，块语句实际上并不是必需的，但是是被鼓励的。类似但无效的`if`语句如下所示：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The block statement was used to group the code together. The indention of the
    print statement does not group code. While it may imply that the first two `println`
    statements are part of the then portion of the `if` statement, the `if` statement
    will, in fact, result in a compile time error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 块语句用于将代码组合在一起。打印语句的缩进不会将代码分组。虽然这可能暗示前两个`println`语句是`if`语句的一部分，但实际上，`if`语句将导致编译时错误。
- en: 'Here, the same code is presented but with different indention. The `if` statement
    has only a `if` clause with a single `println` statement. The second `println`
    statement follows and would be executed regardless of the value of the logical
    expression. This is followed by the else clause which is all by itself. The compiler
    treats this as a syntax error:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现了相同的代码，但缩进不同。`if`语句只有一个`if`子句和一个`println`语句。第二个`println`语句紧随其后，无论逻辑表达式的值如何都会执行。然后是独立的else子句。编译器将此视为语法错误：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The generated syntax error will appear as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的语法错误将如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A general rule of thumb is to always use block statements for the `then` and
    `else` parts of a `if` statement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，对于`if`语句的`then`和`else`部分，始终使用块语句。
- en: 'A more insidious problem can occur if an extra statement is in the `else` clause.
    Consider the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`else`子句中有额外的语句，可能会出现更隐匿的问题。考虑以下示例：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The third `println` statement is not a part of the else clause. Its indention
    is misleading. The equivalent code using proper indention is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`println`语句不是else子句的一部分。它的缩进是误导性的。使用正确缩进的等效代码如下：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is clear that the third `println` statement will always be executed. The
    right way of writing this statement is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，第三个`println`语句将始终被执行。正确的写法如下：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The dangling else problem
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 悬挂else问题
- en: 'Another problem with not using a block statement is the dangling else problem.
    Consider the following series of tests where we need to make a few decisions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用块语句的另一个问题是悬挂else问题。考虑以下一系列测试，我们需要做出一些决定：
- en: If `limit` is greater than `100` and the `stateCode` is equal to `45`, we need
    to increase `limit` by `10`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`limit`大于`100`且`stateCode`等于`45`，我们需要将`limit`增加`10`
- en: If `limit` is not greater than `100`, we need to decrease `limit` by `10`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`limit`不大于`100`，我们需要将`limit`减少`10`
- en: 'This logic is implemented below:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现这个逻辑的方式：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, this example does not properly implement the decision. There are at
    least two problems with this example. First, the indentation of the `else` keyword
    is irrelevant to the evaluation of the statements and is misleading. The `else`
    keyword is always paired with the closest `if` keyword which is, in this case,
    the second one. The compiler does not care how we indent our code. This means
    that the code is equivalent to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子没有正确实现决策。这个例子至少有两个问题。首先，`else`关键字的缩进与语句的评估无关，且具有误导性。`else`关键字总是与最近的`if`关键字配对，这在这种情况下是第二个`if`关键字。编译器不关心我们如何缩进我们的代码。这意味着代码等同于以下内容：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `stateCode` is only tested if the limit exceeds `100` and then `limit`
    is either increased or decreased by `10`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有在限制超过`100`时才测试`stateCode`，然后`limit`要么增加要么减少`10`。
- en: 'Bear in mind that the compiler ignores whitespaces (blanks, tabs, new line,
    and so on) in any statement. The code sequence could be written without whitespace
    but this makes it harder to read:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编译器会忽略任何语句中的空白（空格、制表符、换行等）。代码序列可以不带空白地编写，但这样会使其更难阅读：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second problem in this example is the failure to use block statements.
    Block statements not only provide a way of grouping statements but also provide
    a way of more clearly conveying the logic of an application. The problem can be
    resolved, as shown in the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的第二个问题是没有使用块语句。块语句不仅提供了一种分组语句的方式，还提供了一种更清晰地传达应用程序逻辑的方式。问题可以通过以下代码解决：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is much clearer and accomplishes what was intended. It makes the debugging
    of the program easier and the code is more readable, which makes it more maintainable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更清晰，实现了预期的效果。这样可以更容易地调试程序，代码更易读，更易维护。
- en: Conditional operator
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件运算符
- en: The conditional operator is a condensed, limited form of a `if` statement. It
    is condensed in that the decision is limited to a single expression. It is limited
    because multiple statements cannot be included in the `then` or `else` clauses.
    It is sometimes called the **ternary operator** due to its three components.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符是`if`语句的一种简化、有限形式。它是简化的，因为决策仅限于单个表达式。它是有限的，因为`then`或`else`子句中不能包含多个语句。有时它被称为**三元运算符**，因为它有三个组成部分。
- en: 'The essential form of the operator is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的基本形式如下：
- en: '*LogicalExpression ? ThenExpression : ElseExpression*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*LogicalExpression ? ThenExpression : ElseExpression*'
- en: If the *LogicalExpression* evaluates to true, then the result of the *ThenExpression*
    is returned. Otherwise the result of the *ElseExpression* is returned.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*LogicalExpression*评估为true，则返回*ThenExpression*的结果。否则返回*ElseExpression*的结果。
- en: The following simple example tests to see if a number is less than 10\. If it
    is, 1 is returned, otherwise 2 is returned. The `then` and `else` expressions
    in the example are trivial integer literals.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的例子，用于测试一个数字是否小于10。如果是，返回1，否则返回2。示例中的`then`和`else`表达式是琐碎的整数文字。
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is equivalent to the following `if` statement:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下的`if`语句：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Consider the process for calculating overtime. If the employee works 40 hours
    or less, pay is computed as the number of hours worked times his pay rate. If
    more than 40 hours are worked, then the employee is paid time and a half for those
    hours over 40.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑计算加班的过程。如果员工工作时间不超过40小时，工资按照工作时间乘以他的工资率计算。如果工作时间超过40小时，那么员工将为超过40小时的时间支付加班费。
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This operation can be perfomed using a conditional operator, shown as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作可以使用条件运算符来执行，如下所示：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While this solution is more compact, it is not as readable. In addition, the
    `then` and `else` clauses need to be an expression that returns some value. While
    the value does not have to be a number, it cannot be multiple statements unless
    a method is invoked containing those statements.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种解决方案更加紧凑，但可读性不如前者。此外，`then`和`else`子句需要是返回某个值的表达式。这个值不一定是一个数字，但除非调用包含这些语句的方法，否则不能包含多个语句。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the conditional operator is discouraged, except in trivial cases,
    primarily due to its readability issues. It is usually more important to have
    readable, maintainable code than to save a few lines of code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在琐碎的情况下，不鼓励使用条件运算符，主要是因为它的可读性问题。通常更重要的是拥有可读性强、可维护的代码，而不是节省几行代码。
- en: The switch statement
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: switch语句
- en: 'The purpose of a `switch` statement is to provide a convenient and simple method
    of making multi-branch selections based upon integer, enumeration, or `String`
    expression. The `switch` statement has the following basic form:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的目的是提供一种方便和简单的方法，根据整数、枚举或`String`表达式进行多分支选择。`switch`语句的基本形式如下：'
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There are usually multiple `case` clauses within the statement block. The basic
    form of the `case` clause uses the `case` keyword followed by a colon, zero or
    more statements, and usually a `break` statement. The `break` statement consists
    of a single keyword, `break`, shown as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在语句块中有多个`case`子句。`case`子句的基本形式使用`case`关键字后跟一个冒号，零个或多个语句，通常是一个`break`语句。`break`语句由一个关键字`break`组成，如下所示：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There is also an optional default clause that can be used. This will catch
    any values not caught by a `case` clause. This is demonstrated as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用一个可选的default子句。这将捕获任何未被`case`子句捕获的值。如下所示：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The basic form of the `switch` statement is shown as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的基本形式如下所示：'
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: No two cases within a `switch` statement may have the same value. The `break`
    keyword is used to effectively end the code sequence and exit the `switch` statement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句中的两个情况不能具有相同的值。`break`关键字用于有效地结束代码序列并退出`switch`语句。'
- en: When the expression is evaluated, control is passed to the case expression that
    matches the corresponding constant expression. If no case matches the value of
    the expression, control is passed to the `default` clause, if present. If the
    default prefix is not present, then none of the statements of `switch` will be
    executed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式被评估时，控制将传递给与相应常量表达式匹配的case表达式。如果没有任何case与表达式的值匹配，则控制将传递给`default`子句（如果存在）。如果没有`default`前缀，则`switch`的任何语句都不会被执行。
- en: We will illustrate the use of the `switch` statement for integer, enumeration,
    and `String` expressions. The use of strings in `switch` statements is new to
    Java 7.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将说明`switch`语句用于整数、枚举和`String`表达式。在Java 7中，`switch`语句中使用字符串是新的。
- en: Integer-based switch statements
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于整数的switch语句
- en: 'The `if` statement can be used for choosing between multiple integer values.
    Consider the following example. A series of `if` statements could be used to calculate
    shipping cost based on an integer `zone` value, shown as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可以用于在多个整数值之间进行选择。考虑以下示例。一系列`if`语句可以用于根据整数`zone`值计算运费，如下所示：'
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A `switch` statement could be used for the same purpose, shown as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句可以用于相同的目的，如下所示：'
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget that integer data types include `byte`, `char`, `short`, and `int`.
    Any of these data types can be used with an integer switch statement. The data
    type `long` is not allowed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记整数数据类型包括`byte`、`char`、`short`和`int`。这些数据类型中的任何一个都可以与整数`switch`语句一起使用。不允许使用数据类型`long`。
- en: 'The order of the case and default prefixes is unimportant. The only restriction
    is that the constant-expressions must all be unique. If the `break` statement
    is not the last case clause, then it may need a `break` statement, otherwise control
    will pass to the `case` clause that follows it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: case和default前缀的顺序并不重要。唯一的限制是常量表达式必须是唯一的。如果`break`语句不是最后一个case子句，那么它可能需要一个`break`语句，否则控制将传递给它后面的`case`子句：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For readability purposes a natural order is usually maintained which is normally
    sequential. Using this order makes it easier to find a `case` clause and to make
    sure that cases are not left out accidentally.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可读性的目的，通常会保持自然顺序，这通常是顺序的。使用这个顺序可以更容易地找到`case`子句，并确保不会意外地遗漏情况。
- en: 'The case and default prefixes do not alter the flow of control. Control will
    flow from one case to the next succeeding case unless the break statement is used.
    As zones 5 and 6 use the same formula to calculate the shipping cost, we could
    use back to back case statements without the use of the break statement:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: case和default前缀不会改变控制流。控制将从一个case流向下一个后续case，除非使用了break语句。由于区域5和6使用相同的公式来计算运费，我们可以在不使用break语句的情况下使用连续的case语句：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Break statements are needed to insure that only those statements associated
    with a case are executed. Break is not necessarily needed at the end of the `default`
    clause as control will normally flow out of the `switch` statement. However, it
    is often included for purposes of completeness, and is necessary if the `default`
    clause is not the last case in the `switch` statement.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`break`语句来确保只有与`case`相关的语句被执行。在`default`子句的末尾不一定需要`break`，因为控制通常会流出`switch`语句。然而，出于完整性的目的，通常会包括它，如果`default`子句不是`switch`语句中的最后一个情况，则是必需的。
- en: Enumeration-based switch statements
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于枚举的switch语句
- en: 'Enumerations can also be used with a `switch` statement. This can make it more
    readable and maintainable. The following is duplicated from [Chapter 2](ch02.html
    "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and Their Usage*.
    The variable `direction` is used to control the behavior of the `switch` statement,
    shown as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也可以与`switch`语句一起使用。这可以使代码更易读和易维护。以下内容是从[第2章](ch02.html "第2章。Java数据类型及其用法")中复制的，*Java数据类型及其用法*。变量`direction`用于控制`switch`语句的行为，如下所示：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When this is executed we get the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此操作时，我们得到以下输出：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: String-based switch statements
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于字符串的switch语句
- en: 'To illustrate the use of a string with a `switch` statement, we will demonstrate
    the computation of the shipping cost based on a region as used in *The else-if
    variation* section. That implementation is shown as follows, for your convenience:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在`switch`语句中使用字符串，我们将演示根据区域计算运费的实现，如*else-if variation*部分所示。该实现如下所示，供您参考：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Prior to Java 7, only integer variables could be used with a `switch` statement.
    By permitting the use of strings, programs can incorporate more readable code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，只有整数变量可以与`switch`语句一起使用。通过允许使用字符串，程序可以包含更易读的代码。
- en: 'The following code snippet illustrates how to use a `String` variable with
    a `case` statement. The example provides an alternate implementation of the previous
    nested `if` statement:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何在`case`语句中使用`String`变量。该示例提供了前一个嵌套`if`语句的替代实现：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: String issues with the switch statement
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用switch语句的字符串问题
- en: 'There are two other issues that should be considered when using strings with
    a switch statement:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带有switch语句的字符串时，还应考虑另外两个问题：
- en: When null values are encountered
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到空值时
- en: The case-sensitive nature of strings
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的大小写敏感性
- en: When a null value has been assigned to a string variable used within a switch
    statement, a `java.lang.NullPointerException` exception will be thrown. Of course,
    this will happen whenever a method is executed against a reference variable that
    has been assigned a null value. In Java 7, there is additional support for handling
    null values found in the `java.util.Objects` class.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当在switch语句中使用了一个已分配了空值的字符串变量时，将抛出`java.lang.NullPointerException`异常。当针对已分配了空值的引用变量执行方法时，这将发生。在Java
    7中，对于`java.util.Objects`类中发现的空值，还有额外的支持。
- en: The second thing to remember about strings and the switch statement is that
    the comparison made within a `switch` statement is case-sensitive. In the previous
    example, if a string value of `east` had been used, the `East` case would not
    have been matched and the `defa` `ult` case would have been executed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串和switch语句的第二件事是，在`switch`语句中进行的比较是区分大小写的。在前面的示例中，如果使用了字符串值`east`，则`East`情况将不匹配，并且将执行`defa`
    `ult`情况。
- en: Control structure issues
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构问题
- en: So far, we have identified several types of decision constructs that are available
    in Java. For example, simple decisions are easily handled using a `if` statement.
    Either-or type of decisions can be addressed using a `else if` clause or a `switch`
    statement.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了几种在Java中可用的决策结构。例如，简单的决策可以使用`if`语句轻松处理。要么-要么类型的决策可以使用`else if`子句或`switch`语句来处理。
- en: The proper use of control structures is paramount in developing good code. However,
    there is more to making decisions than simply choosing between different control
    constructs. We also need to test our assumptions and handle unexpected situations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用控制结构在开发良好的代码中至关重要。然而，做决定不仅仅是在不同的控制结构之间进行选择。我们还需要测试我们的假设并处理意外情况。
- en: In this section we will start by addressing a few general issues that you should
    keep in mind when using decision constructs. This will be followed by an examination
    of various floating point issues that can prove troublesome to those unfamiliar
    with floating point number limitations. Next, we will briefly introduce the topic
    of comparing objects and conclude with an overview of three basic coding activities
    that may prove helpful in understanding the nature of programming.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先解决在使用决策结构时应牢记的一些一般问题。然后，我们将检查各种浮点问题，这可能对不熟悉浮点数限制的人造成麻烦。接下来，我们将简要介绍比较对象的主题，并总结三种基本编码活动的概述，这可能有助于理解编程的本质。
- en: General decision constructs issues
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般决策结构问题
- en: 'There are several issues that are important in the use of decision constructs:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用决策结构时有几个重要问题：
- en: The structure of the decision statements
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策语句的结构
- en: Testing your assumptions
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的假设
- en: Planning for failure
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为失败做计划
- en: The overall structure of a decision making process can be well structured or
    it can be an ad hoc sequence of statements that are hard to follow. A well organized
    approach to this structure can improve the readability and maintainability of
    the decision process.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 决策过程的整体结构可以是良好结构化的，也可以是一系列难以遵循的临时语句。对这种结构的良好组织方法可以提高决策过程的可读性和可维护性。
- en: 'A program may be well structured and yet may not work as intended. This is
    often due to invalid assumptions. For example, if the values for an age are assumed
    to be non-negative, then the code that is used may be well formed, and from a
    logical standpoint may be impeccable. However, if the assumption that good values
    for an age are used is wrong, then the results may not be as expected. For example,
    if the age of a person is entered as negative, then the logic may fail. It is
    important to always test your assumptions or at least make sure the underlying
    data has passed some sort of quality control check. Always expect the unexpected.
    Techniques to assist in this process include:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可能结构良好，但可能无法按预期工作。这往往是由于无效的假设。例如，如果假定年龄的值是非负的，那么使用的代码可能形式良好，从逻辑上讲可能是无可挑剔的。然而，如果假设使用的年龄值不正确，那么结果可能不如预期。例如，如果一个人的年龄输入为负数，那么逻辑可能会失败。始终测试你的假设，或者至少确保基础数据已经通过了某种质量控制检查。始终预料意外。帮助这一过程的技术包括：
- en: Always keep a `else` clause
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终保留`else`子句
- en: Test your assumptions
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的假设
- en: Throw exceptions (to be covered in [Chapter 8](ch08.html "Chapter 8. Handling
    Exceptions in an Application"), *Handling Exceptions in an Application*)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常（在[第8章](ch08.html "第8章。在应用程序中处理异常")中介绍，*在应用程序中处理异常*）
- en: Always use block statements
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用块语句
- en: When all else fails, use debugging techniques.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都失败时，请使用调试技术。
- en: Floating point number considerations
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数考虑
- en: Floating point numbers are represented internally using the IEEE 754 Floating
    Point Arithmetic standard ([http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933](http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933)).
    These operations are normally performed in the software, because not all platforms
    provide hardware support for the standard. Performing these operations in the
    software will be slower than those executed directly in the hardware. The advantage
    of performing these operations in the software is that it supports the portability
    of applications.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数在内部使用IEEE 754浮点算术标准([http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933](http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933))来表示。这些操作通常在软件中执行，因为并非所有平台都提供对该标准的硬件支持。在软件中执行这些操作将比直接在硬件中执行慢。在软件中执行这些操作的优势在于它支持应用程序的可移植性。
- en: 'Two floating point types are supported, `float` and `double`, with their precisions
    shown in the following table. In addition, the `Integer` and `Float` classes are
    wrapper classes for these two data types. Wrapper classes are used to encapsulate
    a value, such as an integer or floating point number:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持两种浮点类型，`float`和`double`，它们的精度如下表所示。此外，`Integer`和`Float`类是这两种数据类型的包装类。包装类用于封装值，比如整数或浮点数：
- en: '| Data type | Size (bytes) | Precision |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 大小（字节） | 精度 |'
- en: '| --- | --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `float` | 4 | binary digits |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 4 | 二进制数字 |'
- en: '| `double` | 8 | binary digits |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 8 | 二进制数字 |'
- en: 'Working with floating point numbers can be more complex than working with other
    data types. There are several aspects of floating point numbers that need to be
    considered. These include:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 处理浮点数可能比处理其他数据类型更复杂。需要考虑浮点数的几个方面。这些包括：
- en: Special floating point values
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的浮点值
- en: Comparing floating point numbers
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较浮点数
- en: Rounding errors
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舍入误差
- en: Special floating point values
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊的浮点值
- en: There are several special floating point values as summarized in the following
    table. They exist so that when error conditions occur there will be a representation
    that can be used to identify the error.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 总结在下表中有几个特殊的浮点值。它们存在是为了当发生错误条件时，有一个可以用来识别错误的表示。
- en: 'These values exist so that error conditions such as arithmetic overflow, taking
    the square root of a negative number, and dividing by 0 can yield a result that
    can be represented within the floating point value without throwing an exception
    or otherwise terminating the application:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值存在是为了当发生算术溢出、对负数取平方根和除以0等错误条件时，可以得到一个可以在浮点值内表示的结果，而不会抛出异常或以其他方式终止应用程序：
- en: '| Value | Meaning | May be generated by |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 | 可能由以下产生 |'
- en: '| --- | --- | --- |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Not A Number | **NaN**: Represents the result of an operation that generated
    an undefined value | Division by zeroTaking the square root of a negative number
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 非数字 | **NaN**：表示生成未定义值的操作的结果 | 除以零取平方根 |'
- en: '| Negative infinity | A very small value | A negative number divided by zero
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 负无穷 | 一个非常小的值 | 一个负数除以零 |'
- en: '| Positive infinity | A very large value | A positive number divided by zero
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 正无穷 | 一个非常大的值 | 一个正数除以零 |'
- en: '| Negative zero | Negative zero | A negative number is very close to zero but
    cannot be represented normally |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 负零 | 负零 | 一个负数非常接近零，但不能正常表示 |'
- en: 'NaN can be represented in code by `Float.NaN` and `Double.NaN`, if necessary.
    Performing an arithmetic operation with a NaN value will result in a NaN result.
    Casting a NaN to an integer will return `0` which could result in an application
    error. The use of NaN is illustrated in the following code sequence:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，NaN可以通过`Float.NaN`和`Double.NaN`在代码中表示。对NaN值进行算术运算将得到NaN的结果。将NaN转换为整数将返回`0`，这可能导致应用程序错误。NaN的使用在以下代码序列中进行了说明：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When executed we get the following output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，我们得到以下输出：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Infinity is represented in Java using either of the following fields. As their
    names imply, we can represent either a negative or a positive infinity. Negative
    infinity implies a very small number and positive infinity represents a very large
    number:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，无穷大使用以下字段表示。正如它们的名称所暗示的，我们可以表示负无穷或正无穷。负无穷意味着一个非常小的数，正无穷代表一个非常大的数：
- en: '`Float.NEGATIVE_INFINITY`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float.NEGATIVE_INFINITY`'
- en: '`Double.NEGATIVE_INFINITY`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double.NEGATIVE_INFINITY`'
- en: '`Float.POSITIVE_INFINITY`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float.POSITIVE_INFINITY`'
- en: '`Double.POSITIVE_INFINITY`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double.POSITIVE_INFINITY`'
- en: 'In general, arithmetic operations involving infinite values will result in
    an infinite value. Those involving NaN will result in a NaN result. Division by
    zero will result in positive infinity. The following code snippet illustrates
    some of these operations:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，涉及无限值的算术运算将得到一个无限值。涉及NaN的运算将得到NaN的结果。除以零将得到正无穷。以下代码片段说明了其中一些操作：
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output of this sequence is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A negative zero can be generated by dividing a negative number by positive
    infinity or a positive number divided by negative infinity, as illustrated in
    the following code snippet. The output of both statements will be a negative zero:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将负数除以正无穷或将正数除以负无穷，可以生成负零，如下面的代码片段所示。这两个语句的输出将是负零：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`0` and `-0` are distinct values. However, when compared to each other they
    will be determined to be equal to each other:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`和`-0`是不同的值。然而，当它们相互比较时，它们将被确定为相等：'
- en: '[PRE70]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This generates the following output:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Comparing floating point numbers
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较浮点数
- en: Floating point numbers, as represented in a computer, are not actually real
    numbers. That is, there is an infinite number of floating point numbers in the
    numbering system. However, either 32 or 64 bits are used to represent a floating
    point number. This means that only a finite number of floating point numbers can
    be represented exactly. For example, the fraction 1/3 cannot be represented exactly
    in base 10\. If we try, we get something like 0.333333\. Likewise, there are some
    floating point numbers that cannot be represented exactly in base 2 such as the
    fraction 1/10.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数，在计算机中的表示，实际上并不是真实的数字。也就是说，在数字系统中有无限多个浮点数。然而，只有32位或64位用于表示一个浮点数。这意味着只能精确表示有限数量的浮点数。例如，分数1/3在十进制中无法精确表示。如果我们尝试，会得到类似0.333333的结果。同样，在二进制中，有一些浮点数无法精确表示，比如分数1/10。
- en: 'This implies that comparing floating point numbers can be difficult. Consider
    the following example where we divide two numbers and compare the result to the
    expected quotient of 6:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着比较浮点数可能会很困难。考虑以下例子，我们将两个数字相除，并将结果与期望的商6进行比较：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The result, when executed, gives us an unexpected value, as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时的结果给出了一个意外的值，如下所示：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is because these numbers are not represented exactly using the type `double`.
    To get around this problem, we can examine the result of the operation and see
    how much difference there is between what we expect and what we actually get.
    In the following sequence, a difference, `epsilon`, is defined as the maximum
    difference that is acceptable:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这些数字使用`double`类型并不是精确表示。为了解决这个问题，我们可以检查操作的结果，并查看我们期望的结果与实际结果之间的差异。在以下序列中，定义了一个差异`epsilon`，它是可接受的最大差异：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When this is executed we get the following output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，我们得到以下输出：
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Also, when comparing `Float` or `Double` objects using the `compareTo` method,
    remember that these objects are ordered as follows from low to high:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用`compareTo`方法比较`Float`或`Double`对象时，记住这些对象按从低到高的顺序排列：
- en: Negative infinity
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负无穷
- en: Negative numbers
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数
- en: '-0.0'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-0.0'
- en: '0.0'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0.0'
- en: Positive numbers
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正数
- en: Positive infinity
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正无穷
- en: NaN
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaN
- en: 'For example, the following code will return `-1` indicating that a negative
    number is less than `-0.0`. The output will be `true`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将返回`-1`，表示负数小于`-0.0`。输出将是`true`：
- en: '[PRE76]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Rounding errors
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 舍入误差
- en: 'It is important in some situations to watch out for rounding errors. Consider
    the following code sequence:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，注意舍入误差是很重要的。考虑以下代码序列：
- en: '[PRE77]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When this code is executed, we get the following output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，我们得到以下输出：
- en: '[PRE78]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is the result of the rounding error whose origins derive from the inaccurate
    representation of the fraction 1/10.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于舍入误差导致的，其根源来自于对分数1/10的不准确表示。
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not a good idea to use floating point numbers for exact values. This is
    the case for dollars and cents. Instead, use `BigDecimal` as it provides better
    accuracy and is designed to support this type of operation.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于精确值，使用浮点数并不是一个好主意。这适用于美元和美分。相反，使用`BigDecimal`，因为它提供更好的精度，并且设计用于支持这种类型的操作。
- en: The strictfp keyword
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictfp关键字
- en: The `strictfp` keyword can be applied to a class, an interface, or a method.
    Prior to Java 2, all floating point calculations were performed in compliance
    with the IEEE 754 specifications. After Java 2, intermediate calculations were
    not restricted to the standard and allowed the use of extra bits available on
    some processors to improve precision. This can result in less portable applications
    due to differences in rounding. By using the `strictfp` keyword, all calculations
    will strictly abide by the IEEE standard.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`关键字可以应用于类、接口或方法。在Java 2之前，所有浮点计算都是按照IEEE 754规范执行的。在Java 2之后，中间计算不再受标准限制，允许使用一些处理器上可用的额外位来提高精度。这可能导致应用程序在舍入方面存在差异，从而导致可移植性较差。通过使用`strictfp`关键字，所有计算都将严格遵守IEEE标准。'
- en: Comparing objects
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较对象
- en: 'When comparing objects we need to consider:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较对象时，我们需要考虑：
- en: Comparing object references
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较对象引用
- en: Comparing objects with the `equals` method
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`equals`方法比较对象
- en: When comparing references, we determine whether two reference variables point
    to the same object or not. If we want to determine whether two reference variables
    that point to two different objects are the same, we use the `equals` method.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较引用时，我们确定两个引用变量是否指向相同的对象。如果我们想确定指向两个不同对象的两个引用变量是否相同，我们使用`equals`方法。
- en: 'These two comparisons are illustrated in the following figure. The three references
    variables `r1`, `r2`, and `r3`, are used to reference two objects. The variables
    `r1` and `r2` reference Object 1 while `r3` references Object 2:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种比较如下图所示。三个引用变量`r1`、`r2`和`r3`用于引用两个对象。变量`r1`和`r2`引用对象1，而`r3`引用对象2：
- en: '![Comparing objects](img/7324_03_04.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![比较对象](img/7324_03_04.jpg)'
- en: 'In this example, the following conditions are true:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，以下条件为真：
- en: '`r1 == r2`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1 == r2`'
- en: '`r1 != r3`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1 != r3`'
- en: '`r2 != r3`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r2 != r3`'
- en: '`r1.equals(r2)`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1.equals(r2)`'
- en: However, depending on the implementation of the `equals` method for the objects
    and the objects themselves, Object 1 may or may not be equivalent to Object 2\.
    Comparisons of strings are covered in more detail in the *String comparisons*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*. Overriding the `equals` method is discussed
    in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，根据对象的`equals`方法的实现和对象本身，对象1可能与对象2等价，也可能不等价。字符串的比较在[第2章](ch02.html "第2章.
    Java数据类型及其使用")的*字符串比较*部分中有更详细的介绍，*Java数据类型及其使用*。覆盖`equals`方法在[第6章](ch06.html "第6章.
    类、构造函数和方法")中有讨论，*类、构造函数和方法*。 '
- en: Three basic coding activities
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三种基本编码活动
- en: 'When writing code, it can be difficult to determine how to best organize your
    code. To help keep things in perspective, remember these three general coding
    activities:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，很难确定如何最好地组织代码。为了保持透视，记住这三个一般的编码活动：
- en: What you want to do
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想做什么
- en: How to do it
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何做
- en: When to do it
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时做
- en: 'If a requirement of the application is to calculate the pay for an hourly employee,
    then:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的要求是计算小时工的工资，那么：
- en: The "what" is to calculate pay
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “什么”是计算工资
- en: The "how" determines how to write code to calculate the pay using the hours
    worked and the pay rate
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何”决定如何编写代码来使用工作小时和工资率计算工资
- en: The "when" involves where to place the code, that is, after the hours worked
    and pay rate have been determined
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “when”涉及放置代码的位置，即在确定工作小时和工资率之后
- en: While this may seem simple enough, many beginning programmers will have problems
    with the "when" of programming. This is especially true for event-driven programs
    typified by today's **Graphical User Interface** (**GUI**) based applications.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来很简单，但许多初学者程序员会在编程的“when”方面遇到问题。这对于今天的基于**图形用户界面**（**GUI**）的事件驱动程序尤其如此。
- en: The goto statement
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: goto语句
- en: The `goto` statement is available in older programming languages and provides
    a powerful yet undisciplined way of transferring control within a program. Its
    use has often resulted in poorly organized programs and is discouraged. In Java,
    the use of the `goto` keyword is restricted. It simply cannot be used at all.
    It has been effectively banished from Java programming altogether.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句在旧的编程语言中可用，并提供了程序内部转移控制的强大但不受约束的方式。它的使用经常导致程序组织混乱，并且是不被鼓励的。在Java中，`goto`关键字的使用受到限制。它根本不能被使用。它已经被彻底从Java编程中驱逐出去。'
- en: However, statements with similar functionality to the `goto` statement still
    exist in many languages. For example, the `break` statement causes control to
    immediately be transferred to the end of the switch statement, and as we will
    see later, out of loops. Labels can also be used in conjunction with the break
    statement as we will see in the *Using labels* section in [Chapter 5](ch05.html
    "Chapter 5. Looping Constructs"), *Looping Constructs*. This transfer is immediate
    and unconditional. It is effectively a `goto` statement. However, the `break`
    statement, and in similar fashion the return statement and exception handling,
    are considered to be more structured and safer. Control is not transferred to
    any arbitrary location within the program. It is only transferred to a specific
    location relative to statements at the end of the `switch` statement.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与`goto`语句功能类似的语句仍然存在于许多语言中。例如，`break`语句会导致控制立即转移到switch语句的末尾，并且我们稍后会看到，退出循环。标签也可以与break语句一起使用，正如我们将在[第5章](ch05.html
    "第5章。循环结构")的*使用标签*部分中看到的，*循环结构*。这种转移是即时和无条件的。它实际上是一个`goto`语句。然而，`break`语句，以类似的方式，return语句和异常处理，被认为更加结构化和安全。控制不会转移到程序内的任意位置。它只会转移到`switch`语句末尾附近的特定位置。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Decision making is an important aspect of programming. Most programs' utility
    is based on its ability to make certain decisions. The decision making process
    is based on the use of control constructs such as logical expressions, `if` statements,
    and switch statements.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 决策是编程的重要方面。大多数程序的实用性基于其做出某些决定的能力。决策过程基于控制结构的使用，如逻辑表达式、`if`语句和switch语句。
- en: There are different types of decisions to be made and are supported in Java
    with different control constructs. The primary ones discussed in this chapter
    included the `if` statement and the `switch` statement.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的决策需要做出，并且在Java中使用不同的控制结构进行支持。本章讨论的主要内容包括`if`语句和`switch`语句。
- en: Care must be taken with the use of these statements to avoid the pitfalls possible
    with their use. These include misuse of the comparison operator, not using block
    statements as a matter of habit, and avoiding the dangling else problem. We also
    examined some of the issues that can occur when working with floating point numbers.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些语句时必须小心，以避免可能出现的问题。这些问题包括误用比较运算符，不习惯使用块语句，以及避免悬空else问题。我们还研究了在使用浮点数时可能出现的一些问题。
- en: Decision making in Java can be simple or complex. Simple and complex either-or
    decisions are best handled using the `if then else` statement. For some of the
    simpler decisions, the simple `if` statement or conditional statement can be used.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中做决策可以是简单的或复杂的。简单和复杂的二选一决策最好使用`if then else`语句来处理。对于一些更简单的决策，可以使用简单的`if`语句或条件语句。
- en: Multiple choice decisions can be facilitated using either the `if` statement
    or the `switch` statement, depending on the nature of the decision. More complex
    decisions can be handled by the nesting of `if` statements and `switch` statements.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 多选决策可以使用`if`语句或`switch`语句来实现，具体取决于决策的性质。更复杂的决策可以通过嵌套的`if`语句和`switch`语句来处理。
- en: Now that we've learned about decision constructs, we are ready to examine how
    to use arrays and collections, which is the topic of the next chapter.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了决策结构，我们准备研究如何使用数组和集合，这是下一章的主题。
- en: Certification objectives covered
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'With regards to certification objectives, we will examine:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 关于认证目标，我们将研究：
- en: Using operators and decision constructs
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符和决策结构
- en: Using Java relational and logical operators
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java关系和逻辑运算符
- en: Using parentheses to override operator precedence
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用括号来覆盖运算符优先级
- en: Creating if and if/else constructs
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建if和if/else结构
- en: Using the `switch` statement
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switch`语句
- en: Test your knowledge
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: What is the result of the following operation?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下操作的结果是什么？
- en: '[PRE79]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: a. 0
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: a. 0
- en: b. 1
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: b. 1
- en: c. 2
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: c. 2
- en: d. 3
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: d. 3
- en: Which of the following expressions will evaluate to 7?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个表达式将计算为7？
- en: a. `2 + 4 * 3- 7`
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: a. `2 + 4 * 3- 7`
- en: b. `(2 + 4) * (3 - 7)`
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: b. `(2 + 4) * (3 - 7)`
- en: c. `2 + (4 * 3) - 7`
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: c. `2 + (4 * 3) - 7`
- en: d. `((2 + 4) * 3) - 7)`
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: d. `((2 + 4) * 3) - 7)`
- en: What is the output of the following statement?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句的输出是什么？
- en: '[PRE80]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: a. 1
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: a. 1
- en: b. 2
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: b. 2
- en: c. 4
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: c. 4
- en: d. 8
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: d. 8
- en: Given the following declarations, which of the following if statements will
    compile without errors?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下声明，哪些if语句将在没有错误的情况下编译？
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: a. `if(i > j) {}`
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: a. `if(i > j) {}`
- en: b. `if(i > j > k) {}`
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: b. `if(i > j > k) {}`
- en: c. `if(i > j && i > k) {}`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: c. `if(i > j && i > k) {}`
- en: d. `if(i > j && > k) {}`
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: d. `if(i > j && > k) {}`
- en: What will be printed out when the following code is executed?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行以下代码时，将会打印出什么？
- en: '[PRE82]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: a. one
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个
- en: b. default and two
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: b. 默认和两个
- en: c. one, two, and default
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个，两个和默认
- en: d. Nothing, a compile-time error is generated
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: d. 什么也不会输出，会生成一个编译时错误
