- en: Building a Meme Creator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个Meme Creator
- en: 'As the chapter name suggests, we are going to build a fun application in this
    chapter--a **Meme Creator**. Everyone loves memes! But that''s not the only reason
    we are building a Meme Creator. We are going to explore a few new things that
    are going to change the way you build web applications. Let''s see what''s in
    store:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如章节名称所示，我们将在本章构建一个有趣的应用程序--一个**Meme Creator**。每个人都喜欢表情包！但我们构建Meme Creator的原因不仅仅是因为这个。我们将探索一些新的东西，这些东西将改变您构建Web应用程序的方式。让我们看看有什么：
- en: Introduction to **CSS3 flexbox**. A new way to create responsive layouts on
    the web.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**CSS3 flexbox**。在网络上创建响应式布局的新方法。
- en: Using the **Webpack** module bundler to convert all your dependencies and code
    to static assets.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Webpack**模块打包工具将所有依赖项和代码转换为静态资源。
- en: Using **HTML5 canvas** for drawing graphics on the fly with JavaScript.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**HTML5画布**在JavaScript中实时绘制图形。
- en: Creating a solid production build that is fully optimized, minified, and versioned.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完全优化、缩小和版本化的稳定生产版本。
- en: Previously, you successfully built a ToDo List app while learning the new ES6
    features of JavaScript. At the end of the chapter, you learned how to use Node
    and npm for web development. We have covered only the basics. We are yet to realize
    the full potential of using npm in our project. That's why, in this project, we
    are going to experiment with a powerful module bundler called Webpack. Before
    we begin with our experiment to build a fully automated development environment,
    let's set a few things up.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您成功地构建了一个ToDo List应用程序，同时学习了JavaScript的新ES6特性。在本章结束时，您学会了如何使用Node和npm进行Web开发。我们只涵盖了基础知识。我们还没有意识到在我们的项目中使用npm的全部潜力。这就是为什么在这个项目中，我们将尝试使用一个称为Webpack的强大模块打包工具。在我们开始实验构建一个完全自动化的开发环境之前，让我们先设置一些东西。
- en: Initial project setup
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始项目设置
- en: Create a new folder for our Meme Creator application. Open up the folder in
    VSCode or any other text editor you are using for this project. Navigate to the
    folder in your terminal and run **`npm init`**. Just as we did in the previous
    chapter, fill in all the details asked for in the terminal, then hit *Enter* on
    Windows or *return* on Mac, and you will have your `package.json` file in the
    project root.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的Meme Creator应用创建一个新文件夹。在VSCode或您用于此项目的任何其他文本编辑器中打开该文件夹。在终端中导航到该文件夹并运行**`npm
    init`**。就像我们在上一章中所做的那样，在终端中填写所有要求的细节，然后在Windows上按*Enter*或在Mac上按*return*，您将在项目根目录中得到`package.json`文件。
- en: From the code files you downloaded for this book, open up the starter files
    folder for Chapter 2\. You will see an `index.html` file. Copy and paste it into
    your new project folder. That's all for the starter files provided with this chapter,
    because there is not going to be a default CSS file. We are going to build the
    UI from scratch!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从您为本书下载的代码文件中，打开第2章的起始文件夹。您会看到一个`index.html`文件。将其复制粘贴到您的新项目文件夹中。这就是本章提供的起始文件的全部内容，因为不会有默认的CSS文件。我们将从头开始构建UI！
- en: 'Create the files and folders we are going to use in this chapter. The folder
    structure should be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们将在本章中使用的文件和文件夹。文件夹结构应该如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For now, leave the JS files empty. We are going to work on the `styles.css`
    file. Open up `index.html` in your browser (try using the `http-server` package
    we installed globally in the previous chapter). You should see an awkward looking
    page with some default Bootstrap styles applied using Bootstrap''s classes. We
    are going to turn that page into a Meme Creator app, which looks as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将JS文件保留为空。我们将在`styles.css`文件上进行工作。在浏览器中打开`index.html`（尝试使用我们在上一章全局安装的`http-server`包）。您应该会看到一个奇怪的页面，应用了一些默认的Bootstrap样式。我们将把该页面变成一个Meme
    Creator应用，如下所示：
- en: '![](../images/00009.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: 'This web app is also going to be responsive. So, on your mobile devices, it
    should look as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络应用也将是响应式的。因此，在您的移动设备上，它应该如下所示：
- en: '![](../images/00010.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: That blank box is going to be our canvas, which will preview the memes created
    with this app. Now that you have an idea of how the application will look, we'll
    start working on our `styles.css` file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那个空白框将是我们的画布，它将预览使用该应用程序创建的表情包。现在您已经对应用程序的外观有了一个想法，我们将开始在我们的`styles.css`文件上工作。
- en: Responsive designing with flexbox
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flexbox进行响应式设计
- en: If you look into the `index.html` file of our previous chapter, you will see
    that there are classes, such as `col-md-2`, `col-xs-2`, `col-lg-2`, `col-sm-2`,
    and so on. They are Bootstrap's grid classes. The previous chapter's layout was
    designed using the Bootstrap grid system. The system divides the page into rows
    and 12 columns and allocates a specific number of columns to each `div` in a row
    depending on the screen size.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们上一章的`index.html`文件，您会看到有一些类，比如`col-md-2`、`col-xs-2`、`col-lg-2`、`col-sm-2`等。它们是Bootstrap的网格类。上一章的布局是使用Bootstrap网格系统设计的。该系统将页面分成行和12列，并根据屏幕尺寸为每个`div`分配特定数量的列。
- en: 'There are four different screen sizes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同的屏幕尺寸：
- en: Desktop (md)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面（md）
- en: Tablets (sm)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平板电脑（sm）
- en: Phones (xs)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机（xs）
- en: Large desktops (lg)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型桌面电脑（lg）
- en: However, we are not going to use Bootstrap grids in this chapter. We are going
    to be using a new layout mode introduced in CSS3 called the flexbox. Flexbox or
    flexible box, as it sounds, provides a box model for creating layouts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在本章中我们不会使用Bootstrap网格。我们将使用CSS3中引入的新布局模式，称为flexbox。Flexbox或灵活盒模型提供了一个用于创建布局的盒模型。
- en: Flexbox is a new layout system, which is actively being implemented by the browser
    vendors. Support is almost complete; it's time to adopt this standard in projects.
    A few problems still exist, such as IE 11 only having partial flexbox support
    and older versions of IE do not support flexbox. Visit [https://caniuse.com/](https://caniuse.com/)
    to check details on browser support for flexbox.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox是一个新的布局系统，正在被浏览器供应商积极实施。支持几乎已经完成；是时候在项目中采用这个标准了。仍然存在一些问题，比如IE 11只有部分flexbox支持，较旧版本的IE不支持flexbox。访问[https://caniuse.com/](https://caniuse.com/)查看flexbox的浏览器支持详情。
- en: Flexbox - a quick introduction
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox - 一个快速介绍
- en: 'In the flexbox layout system, you declare a parent `div` with a CSS property
    `display: flex`, which allows you to control how you want to position its children
    elements.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在flexbox布局系统中，您声明一个带有CSS属性`display: flex`的父`div`，这允许您控制如何定位其子元素。'
- en: 'Once you declare `display: flex`, the `div` element becomes a flexbox with
    two axes. The **Main axis** along with the content are placed with the **Cross
    axis**, which is perpendicular to the Main axis. You can use the following CSS
    properties in the parent flexbox to change the position of child elements (*flex
    items*):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦声明了`display: flex`，`div`元素就成为一个具有两个轴的flexbox。**主轴**与内容一起放置在**交叉轴**上，该轴与主轴垂直。您可以在父flexbox中使用以下CSS属性来更改子元素（*flex项目*）的位置：'
- en: '**flex-direction**: Create the Main axis either horizontally (row) or vertically
    (column)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flex-direction**：创建主轴，可以是水平（行）或垂直（列）'
- en: '**justify-content**: Specify how flex items are placed on the Main axis'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**justify-content**：指定如何在主轴上放置flex项目'
- en: '**align-items**: Specify how flex items are placed on the Cross axis'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**align-items**：指定如何在交叉轴上放置flex项目'
- en: '**flex-wrap**: Specify how to handle flex items when there is not enough space
    to display them in a single row'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flex-wrap**：指定当没有足够空间在单行中显示flex项目时如何处理它们'
- en: 'You can also apply some flex properties to flex items, such as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将一些flex属性应用于flex项目，例如：
- en: '**align-self**: Specify how to place the specific flex item on the Cross axis'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**align-self**：指定如何在交叉轴上放置特定的flex项目'
- en: '**flex**: The relative size of the flex item with respect to other flex items
    (if you have two items with `flex: 2` and `flex: 1` respectively, the first one
    will be twice the size of the second one)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flex**：相对于其他flex项目的大小（如果您有两个项目分别为`flex: 2`和`flex: 1`，第一个将是第二个的两倍大小）'
- en: All those should sound confusing, but the easiest way to understand flexbox
    is to use online flexbox playgrounds. Google some flexbox playgrounds available
    online to experience how different properties of flexbox work. One such playground
    can be found at [http://flexboxplayground.catchmyfame.com/](http://flexboxplayground.catchmyfame.com/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来可能令人困惑，但理解flexbox的最简单方法是使用在线flexbox游乐场。搜索一些在线可用的flexbox游乐场，体验flexbox的不同属性如何工作。其中一个游乐场可以在[http://flexboxplayground.catchmyfame.com/](http://flexboxplayground.catchmyfame.com/)找到。
- en: 'To learn flexbox, refer to the following pages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习flexbox，请参考以下页面：
- en: 'Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla开发者网络：[https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)
- en: 'W3Schools: [https://www.w3schools.com/css/css3_flexbox.asp](https://www.w3schools.com/css/css3_flexbox.asp)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3Schools：[https://www.w3schools.com/css/css3_flexbox.asp](https://www.w3schools.com/css/css3_flexbox.asp)
- en: 'Flexbox Froggy (a game for learning flexbox): [https://flexboxfroggy.com/](https://flexboxfroggy.com/)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flexbox Froggy（一个学习flexbox的游戏）：[https://flexboxfroggy.com/](https://flexboxfroggy.com/)
- en: At the time of writing this book, the latest version of Safari browser 10.1
    is having problems with the **flex-wrap** property, which is fixed in nightly
    builds. If you are using the same or an earlier version of the Safari browser,
    I'd recommend using Chrome for this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Safari浏览器的最新版本10.1存在**flex-wrap**属性的问题，这在夜间构建中已经修复。如果您使用相同或更早版本的Safari浏览器，我建议在本章中使用Chrome。
- en: Designing the Meme Creator
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模因创作者
- en: In our `index.html` file, our `<body>` element is divided into a navigation
    bar and `div` containing the contents of the website. The `div.body` element is
    further divided into `div.canvas-area` and `div.input-area`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index.html`文件中，我们的`<body>`元素被分成一个导航栏和包含网站内容的`div`。`div.body`元素进一步分为`div.canvas-area`和`div.input-area`。
- en: Navigation bar
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航栏
- en: The first part of our document's body is the navigation bar `<nav>`. The navigation
    bar usually contains the primary set of links for navigation in a website. Since
    we are building only a single page in this chapter, we can leave the navbar with
    only our page title.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文档正文的第一部分是导航栏`<nav>`。导航栏通常包含网站导航的主要链接集。由于在本章中我们只构建一个单页面，因此我们可以将导航栏仅包含我们的页面标题。
- en: The navigation bar is styled using Bootstrap. The class `.navbar` styles the
    respective element as the primary navigation bar of the page. The `.navbar-inverse`
    class adds a dark color to the navigation bar and the `.navbar-fixed-top` class
    attaches the navigation bar to the top of the screen using a fixed position. The
    contents of the navigation bar are wrapped inside a Bootstrap container (`div.container`).
    The page title is written inside `div.navbar-header` as an anchor tag with the
    class `.navbar-brand`, which instructs Bootstrap that this is the brand name/title
    of the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏使用Bootstrap进行样式设置。类`.navbar`将相应元素样式为页面的主导航栏。`.navbar-inverse`类为导航栏添加了深色，`.navbar-fixed-top`类使用固定位置将导航栏附加到屏幕顶部。导航栏的内容包裹在Bootstrap容器（`div.container`）中。页面标题写在`div.navbar-header`中，作为带有类`.navbar-brand`的锚标签，这告诉Bootstrap这是应用程序的品牌名称/标题。
- en: 'The Bootstrap navigation bar is highly customizable. To learn more about this
    topic, refer to W3Schools'' Bootstrap tutorial: [https://www.w3schools.com/bootstrap/](https://www.w3schools.com/bootstrap/)
    or Bootstrap''s official documentation: [http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap导航栏是高度可定制的。要了解更多关于这个主题的内容，请参考W3Schools的Bootstrap教程：[https://www.w3schools.com/bootstrap/](https://www.w3schools.com/bootstrap/)或Bootstrap的官方文档：[http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/)。
- en: Content area
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容区域
- en: 'The navigation bar occupies a fixed position on top of the screen. Hence, it
    will overlap with the page''s content. Open up `styles.css` and add the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏占据屏幕顶部的固定位置。因此，它将与页面的内容重叠。打开`styles.css`并添加以下代码：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will add padding to the entire body section so that the navbar will not
    overlap with our content. Now, we need to convert our primary content area `div.body`
    to a flexbox:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为整个body部分添加填充，以便导航栏不会与我们的内容重叠。现在，我们需要将我们的主要内容区域`div.body`转换为flexbox：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will convert our `div.body` element into a flexbox that organizes its contents
    as a row (`flex-direction`) and wraps the contents to new rows if space is not
    available for entire rows (`flex-wrap`). Also, the contents will be surrounded
    by equal margin spaces horizontally (`justify-content`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的`div.body`元素转换为一个flexbox，将其内容组织为一行（`flex-direction`），如果没有足够的空间来容纳整行，则将内容换行到新行（`flex-wrap`）。此外，内容将在水平方向被等距间隔包围（`justify-content`）。
- en: Guess what? We are done! Our primary layout is already complete! Switch to Chrome,
    hard-reload, and see that the contents are now aligned horizontally. Open up the
    responsive design mode; for mobile devices you will see that the row is automatically
    wrapped into two rows to display the content. Without flexbox, this would have
    taken thrice the amount of code to achieve the same layout. Flexbox greatly simplifies
    the layout process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？我们完成了！我们的主要布局已经完成了！切换到Chrome，进行硬刷新，看到内容现在水平对齐了。打开响应式设计模式；对于移动设备，你会看到行自动换行成两行来显示内容。没有flexbox，要实现相同的布局需要三倍的代码量。Flexbox大大简化了布局过程。
- en: 'Now that our primary layout is complete, let''s add some styles to individual
    elements, such as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的主要布局已经完成，让我们为各个元素添加一些样式，比如：
- en: Making `.canvas-area` twice the size of the `.input-area`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`.canvas-area`的大小是`.input-area`的两倍
- en: Adding a black border to the canvas element
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给画布元素添加黑色边框
- en: Center-aligning the canvas and the form inputs in their respective areas
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将画布和表单输入在各自的区域居中对齐
- en: Also, we need to add a margin to both `.canvas-area` and `.input-area` so that
    there will be space between them when the row is wrapped
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们需要为`.canvas-area`和`.input-area`添加一些边距，这样当行被换行时它们之间会有空间
- en: 'To achieve these styles, add the following CSS to your `styles.css` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些样式，将以下CSS添加到你的`styles.css`文件中：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The canvas area is still quite small, but we'll handle its size from our JavaScript
    code. So, now, we don't need to worry about the size of the canvas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 画布区域仍然很小，但我们将从JavaScript代码中处理它的大小。所以，现在我们不需要担心画布的大小。
- en: 'We are almost done with our styles, except that the form inputs are now in
    different sizes. This happens because Bootstrap''s `.form-input` styles tell the
    respective `div` to occupy the entire width of its parent `div`. However, when
    we add `align-items: center` in our style, we are telling the parent `div` to
    assign a limited width so that the contents are not overlapped and are then centered
    inside the flexbox. So, the width of each element now differs based on its contents.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的样式几乎完成了，只是表单输入现在大小不同。这是因为Bootstrap的`.form-input`样式告诉相应的`div`占据其父`div`的整个宽度。然而，当我们在样式中添加`align-items:
    center`时，我们告诉父`div`分配有限的宽度，以便内容不重叠，并在flexbox内居中。因此，现在每个元素的宽度根据其内容而异。'
- en: 'To overcome this problem, we simply need to specify a fixed width to the `.form-input`
    class. Also, let''s add some extra top margin to the download button. Add the
    following lines at the end of your `styles.css` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们只需要为`.form-input`类指定一个固定的宽度。此外，让我们为下载按钮添加一些额外的顶部边距。在你的`styles.css`文件的末尾添加以下行：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we are done building the UI for our Meme Creator using flexbox. It's time
    to move on to the most important topic in this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用flexbox构建了我们的Meme Creator的UI。是时候转向本章中最重要的主题了。
- en: Due to its ease of use and a huge amount of features, the flexbox layout system
    is also being adopted in mobile application development. React Native uses flexbox
    to create a UI for Android and iOS apps. Facebook has also released open source
    libraries, such as `yoga` and `litho`, to use flexbox in native Android and iOS
    apps.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易用性和大量功能，flexbox布局系统也被移动应用开发所采用。React Native使用flexbox为Android和iOS应用创建UI。Facebook还发布了开源库，如`yoga`和`litho`，用于在原生Android和iOS应用中使用flexbox。
- en: Webpack module bundler
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack模块打包工具
- en: It's finally time to set up our fully-featured development environment. You'll
    probably be wondering what Webpack is and what's it got to do with a development
    environment. Or perhaps, you are familiar with tools such as gulp or grunt and
    are wondering how Webpack is different from them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 终于是时候建立我们功能齐全的开发环境了。你可能会想知道Webpack是什么，它与开发环境有什么关系。或者，你可能熟悉诸如gulp或grunt之类的工具，想知道Webpack与它们有何不同。
- en: If you have used gulp or grunt before, they are task runners. They execute a
    specific set of tasks to compile, transform, and minify your code. There is also
    a tool called **Browserify**, which lets you use `require()` in browsers. Usually,
    a development environment with gulp/grunt involves executing various commands
    using different sets of tools, such as Babel, Browserify, and so on, in a specific
    order to generate our desired output code. But Webpack is different. Unlike task
    runners, Webpack doesn't run a set of commands to build the code. Instead, it
    acts as a module bundler.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过gulp或grunt，它们是任务运行器。它们执行一组特定的任务来编译、转换和压缩你的代码。还有一个名为**Browserify**的工具，它允许你在浏览器中使用`require()`。通常，使用gulp/grunt的开发环境涉及使用不同的工具集（如Babel、Browserify等）按特定顺序执行各种命令来生成我们期望的输出代码。但Webpack不同。与任务运行器不同，Webpack不运行一组命令来构建代码。相反，它充当模块打包工具。
- en: 'Webpack goes through your JavaScript code and looks for `import`, `require`,
    and so on to find files dependent on it. Then, it loads the files into a dependency
    graph and, in turn, finds those files, dependencies. This process goes on until
    there are no more dependencies. Finally, it bundles the dependency files together
    with the initial file into a single file using the dependency graph it built.
    This functionality is very useful in modern JavaScript development, where everything
    is written as a module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack通过您的JavaScript代码并查找`import`，`require`等来查找依赖于它的文件。然后，它将文件加载到依赖图中，并依次找到这些文件的依赖关系。这个过程会一直持续下去，直到没有更多的依赖关系。最后，它使用构建的依赖图将依赖文件与初始文件捆绑在一起成为一个单一的文件。这个功能在现代JavaScript开发中非常有用，因为所有东西都被写成一个模块：
- en: '![](../images/00011.jpeg)Webpack is being adopted as the bundler of popular
    modern frameworks, such as React, Angular, and Vue. It is also a good skill to
    have on your resume.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00011.jpeg)Webpack正在被广泛采用作为流行的现代框架（如React、Angular和Vue）的捆绑工具。这也是您简历上很好的技能。'
- en: Modules in JavaScript
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模块
- en: Remember the ToDo List app we built in the previous chapter? We used npm to
    install Babel to transform our ES6 code to ES5\. Navigate to the `ToDo List` folder
    and open up the `node_modules` folder. You will find a huge list of folders containing
    various packages! Even though you installed only four packages, npm has traced
    out all the dependencies of the required packages and installed them along with
    the actual packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章中构建的ToDo List应用程序吗？我们使用npm安装Babel将我们的ES6代码转换为ES5。导航到`ToDo List`文件夹并打开`node_modules`文件夹。您会发现一个包含各种包的大型文件夹列表！即使您只安装了四个包，npm也已经跟踪了所需包的所有依赖关系，并将它们与实际包一起安装。
- en: We only used those packages as dev-dependencies to compile our code. So, we
    didn't know how those packages are built. Those packages are built as modules.
    A module is an independent piece of reusable code that returns a value. The value
    can be an object, function, `string`, `int`, and so on. Modules are widely used
    for building large applications. Node.js comes with support for exporting and
    importing JavaScript modules which are currently unavailable in the browser.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用这些包作为开发依赖项来编译我们的代码。因此，我们不知道这些包是如何构建的。这些包被构建为模块。模块是一个独立的可重用代码片段，返回一个值。该值可以是对象、函数、`string`、`int`等。模块被广泛用于构建大型应用程序。Node.js支持导出和导入JavaScript模块，而这在浏览器中目前是不可用的。
- en: 'Let''s see how we can create a simple module in JavaScript:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在JavaScript中创建一个简单的模块：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider the earlier mentioned function that returns a sum of two numbers.
    We are going to convert that function into a module. Create a new file `sum.js`
    and write the function as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面提到的返回两个数字之和的函数。我们将把该函数转换为一个模块。创建一个新文件`sum.js`，并按如下方式编写函数：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s all! You just need to add an `export` keyboard before the variable
    or object you would like to export and it will become a module which can be used
    in a different file. Imagine you have a file called `add.js`, where you need to
    find the sum of two numbers. You can import the `sum` module as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您只需要在您想要导出的变量或对象之前添加一个`export`关键字，它将成为一个可以在不同文件中使用的模块。想象一下，您有一个名为`add.js`的文件，您需要找到两个数字的和。您可以按如下方式导入`sum`模块：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can ignore the extension `.js` if you are importing a JavaScript file and
    use `import { sum } from ''./sum''`. You can also use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在导入一个JavaScript文件，可以忽略扩展名`.js`并使用`import { sum } from './sum'`。您也可以使用以下方式：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, import it, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按如下方式导入它：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`module.exports` and the `require` keyword has been used by Node.js for importing
    and exporting JavaScript modules even since before ES6 was introduced. However,
    ES6 has a new module syntax using the keywords `import` and `export`. Webpack
    supports all types of imports and exports. For our project, we''ll stick with
    ES6 modules.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports`和`require`关键字自Node.js用于导入和导出JavaScript模块，甚至在ES6之前就已经使用了。然而，ES6有一个新的模块语法，使用`import`和`export`关键字。Webpack支持所有类型的导入和导出。对于我们的项目，我们将坚持使用ES6模块。'
- en: 'Consider the following file `sides.js`, which contains the number of sides
    of geometrical figures in more than one module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下文件`sides.js`，其中包含多个几何图形的边数：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To import all of them into our file, you can use the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们全部导入到我们的文件中，您可以使用以下方式：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, all the exported variables/objects from the `sides.js` file will be accessible
    inside the `sides` object. To get the value of `TRIANGLE`, just use `sides.LINE`.
    Also, note that `TRIANGLE` is marked default. A `default` export is useful when
    there are multiple modules in the same file. Type in the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sides.js`文件中导出的所有变量/对象将可以在`sides`对象中访问。要获取`TRIANGLE`的值，只需使用`sides.LINE`。还要注意，`TRIANGLE`被标记为默认。当同一文件中有多个模块时，默认导出是有用的。输入以下内容：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, `side` will contain the value of the default export `TRIANGLE`. So, now
    `side = 3`. To import other modules along with the default module, you can use
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`side`将包含默认导出`TRIANGLE`的值。所以，现在`side = 3`。要导入默认模块以及其他模块，您可以使用以下方式：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if you want to import a module that is present inside the `node_modules`
    folder, you can ignore the relative file path (`./` part) completely and just
    type `import jquery from 'jquery';`. Node.js or Webpack will automatically find
    the nearest `node_modules` folder from the file's parent directories and automatically
    search for the required package. Just make sure you have installed the package
    using `npm install`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想要导入一个存在于`node_modules`文件夹中的模块，您可以完全忽略相对文件路径（`./`部分）并只需输入`import jquery
    from 'jquery';`。Node.js或Webpack将自动从文件的父目录中找到最近的`node_modules`文件夹，并自动搜索所需的包。只需确保您已经使用`npm
    install`安装了该包。
- en: That pretty much covers the basics of using modules in JavaScript. Now it's
    time to learn about the role of Webpack in our project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了在JavaScript中使用模块的基础知识。现在是时候了解Webpack在我们的项目中的作用了。
- en: Bundling modules in Webpack
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Webpack中捆绑模块
- en: 'To start using Webpack, let''s first write some JavaScript code. Open up your
    `memes.js` file and `general.js` file. Write the following code in both files,
    which simply prints the respective filenames in the console:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Webpack，让我们首先编写一些JavaScript代码。打开你的`memes.js`文件和`general.js`文件。在两个文件中写入以下代码，它只是在控制台中打印出相应的文件名：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Usually, while building multiple page web applications that have a large number
    of HTML files, it's common to have a single JavaScript file that has code that
    requires being run on all the HTML files. We are going to use the `general.js`
    file for this purpose. Even though our Meme Creator has a single HTML file, we'll
    use the `general.js` file to include some common code and include the code for
    Meme Creator in the `memes.js` file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建具有大量HTML文件的多页面Web应用程序时，通常会有一个单个的JavaScript文件，其中包含需要在所有HTML文件上运行的代码。我们将使用`general.js`文件来实现这个目的。即使我们的Meme
    Creator只有一个HTML文件，我们也将使用`general.js`文件来包含一些通用代码，并在`memes.js`文件中包含Meme Creator的代码。
- en: 'Why don''t we try importing the `general.js` file inside our `memes.js` file?
    Since `general.js` is not exporting any modules, simply type in the following
    code in your `memes.js` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不尝试在我们的`memes.js`文件中导入`general.js`文件呢？由于`general.js`没有导出任何模块，所以只需在你的`memes.js`文件中输入以下代码：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Include a `script` tag with reference to `memes.js` file at the end of the
    `<body>` element in your `index.html` file and see the result in Chrome. If all
    goes well, you should see an error in Chrome''s console saying: Unexpected token
    import. This means that something didn''t go well for Chrome. Yup! Chrome doesn''t
    know how to use the `import` keyword. To use `import`, we need Webpack to bundle
    both the `general.js` and `meme.js` file together and serve it as a single file
    to Chrome.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`index.html`文件的`<body>`元素末尾包含一个引用`memes.js`文件的`script`标签，并在Chrome中查看结果。如果一切顺利，你应该在Chrome的控制台中看到一个错误，说：Unexpected
    token import。这意味着Chrome出了一些问题。是的！Chrome不知道如何使用`import`关键字。要使用`import`，我们需要Webpack将`general.js`和`meme.js`文件捆绑在一起，并将其作为单个文件提供给Chrome。
- en: 'Let''s install Webpack as a dev dependency for our project. Run the following
    command in the terminal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Webpack作为项目的开发依赖项进行安装。在终端中运行以下命令：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Webpack is now installed as a dev dependency to our project. Webpack is also
    a command-line tool similar to Babel. To run Webpack, we need to use `npm` scripts.
    In your `package.json` file, below the test script, create the following script:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack现在作为我们项目的开发依赖项安装完成。Webpack也是一个类似Babel的命令行工具。要运行Webpack，我们需要使用`npm`脚本。在你的`package.json`文件中，在测试脚本下面，创建以下脚本：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now run the following command in your terminal:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的终端中运行以下命令：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A new `memes.js` file will be created under the `dist/js/` directory. This
    file contains both the `general.js` and `memes.js` files bundled together. Open
    up the new JavaScript code in VSCode; you should see a large amount of code. No
    need to panic at this stage; that is the code used by Webpack to manage the scopes
    and properties of the bundled files. It''s something we don''t have to worry about
    at this point. If you scroll to the end of the file, you will see the `console.log`
    statements that we had written in both of our original files. Edit your script
    tag in `index.html` to include the new file, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将`memes.js`文件创建在`dist/js/`目录下。该文件包含了`general.js`和`memes.js`文件的捆绑在一起。在VSCode中打开新的JavaScript代码；你应该会看到大量的代码。在这个阶段不需要惊慌；这是Webpack用来管理捆绑文件的范围和属性的代码。这是我们目前不必担心的东西。如果你滚动到文件的末尾，你会看到我们在原始文件中写的`console.log`语句。编辑`index.html`中的脚本标签以包含新文件，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, reload the page in Chrome and you should see that the console statements
    from both the files are executed inside the `memes.js` file. We have successfully
    imported a JavaScript file inside our code. In our previous project, we set up
    the development environment so that the code will be compiled and served automatically
    whenever a change is made in the source file. To do ES6 to ES5 compilation and
    other tasks, we need to install a lot of packages and must give a lot of instructions
    to Webpack. For this purpose, create `webpack.config.js` in your project root
    folder and write the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome中重新加载页面，你应该看到来自两个文件的控制台语句都在`memes.js`文件中执行。我们已经成功地在我们的代码中导入了一个JavaScript文件。在我们以前的项目中，我们设置了开发环境，以便在源文件中进行更改时，代码将自动编译和提供服务。要进行ES6到ES5的编译和其他任务，我们需要安装许多包，并且必须给Webpack提供许多指令。为此，在你的项目根目录中创建`webpack.config.js`并编写以下代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remove all the options passed to Webpack in `package.json`. Now, your script
    inside `package.json` should look as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`package.json`中传递给Webpack的所有选项。现在，`package.json`中的脚本应该如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we haven''t passed any arguments to Webpack, it will look for the `webpack.config.js`
    file inside the directory from which it was executed. It will now read the configuration
    from the file we just created. The first line in our config file is to import
    Webpack using `require(''webpack'')`. We are still using Node.js to execute our
    code, so we should use `require` in our Webpack config file. We just need to export
    our configuration in this file as a JSON object. In the `module.exports` object,
    Here''s what each property is used for:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有向Webpack传递任何参数，它将在执行的目录中查找`webpack.config.js`文件。它现在将从我们刚刚创建的文件中读取配置。我们配置文件中的第一行是使用`require('webpack')`导入Webpack。我们仍然使用Node.js来执行我们的代码，所以我们应该在Webpack配置文件中使用`require`。我们只需要将我们的配置作为JSON对象导出到这个文件中。在`module.exports`对象中，每个属性的用途如下：
- en: '`context`: Is used to specify the absolute path from which the path of files
    in the entry section needs to be resolved. Here, `__dirname` is a constant that
    will automatically include the absolute path of the current directory.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：用于指定需要解析入口部分文件路径的绝对路径。在这里，`__dirname`是一个常量，将自动包含当前目录的绝对路径。'
- en: '`entry`: Is used to specify all the files that need to be bundled using Webpack.
    It accepts string, array, and a JSON object. If you need Webpack to bundle a single
    entry file, just specify the file''s path as a string. Otherwise, use array or
    object.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`：用于指定需要使用Webpack捆绑的所有文件。它接受字符串、数组和JSON对象。如果需要Webpack捆绑单个入口文件，只需将文件路径指定为字符串。否则，使用数组或对象。'
- en: 'In our case, we specify input files as objects in the form of `[name]: [path_of_the_file]`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在我们的情况下，我们以`[name]: [path_of_the_file]`的形式指定输入文件为对象。'
- en: This [name] will be used in naming the output bundle of each file.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个[name]将用于命名每个文件的输出捆绑包。
- en: '`output`: In the output, we need to specify the absolute path of the output
    directory, `dist` in our case, and the filename, which is `[name]`, we specified
    in the entry section, followed by the file-extension `[name].js`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：在输出中，我们需要指定输出目录的绝对路径，在我们的情况下是`dist`，以及文件名，即我们在入口部分指定的`[name]`，后跟文件扩展名`[name].js`。'
- en: 'Run `npm run webpack` in the terminal. You should see two new files created
    in the `dist` directory: `general.js` and `memes.js`, which contain the bundled
    code from each of their respective source files. The `memes.js` file will include
    the code from the `general.js` file, so it''s enough to include only the `memes.js`
    file in your HTML.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行`npm run webpack`。您应该会在`dist`目录中看到两个新文件被创建：`general.js`和`memes.js`，它们包含了各自源文件的捆绑代码。`memes.js`文件将包括`general.js`文件中的代码，因此在HTML中只需要包含`memes.js`文件即可。
- en: Now that we have written the configuration for bundling our code, we'll use
    this configuration file to transform the ES6 syntax to ES5\. In Webpack, transformations
    are applied when the file is imported. To apply transformations, we need to use
    loaders.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了捆绑我们代码的配置，我们将使用这个配置文件来将ES6语法转换为ES5。在Webpack中，当文件被导入时，转换会被应用。要应用转换，我们需要使用加载器。
- en: Loaders in Webpack
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack中的加载器
- en: Loaders are used for applying transformations to files before importing and
    bundling them. In Webpack, using different third-party loaders, we can transform
    any file and import it into our code. This goes for files written in other languages,
    such as TypeScript, Dart, and so on. We can even import CSS and images into our
    JS code. First, we'll use loaders to transform ES6 into ES5.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器用于在导入和捆绑文件之前对文件应用转换。在Webpack中，使用不同的第三方加载器，我们可以转换任何文件并将其导入到我们的代码中。这适用于用其他语言编写的文件，如TypeScript、Dart等。我们甚至可以将CSS和图像导入到我们的JS代码中。首先，我们将使用加载器将ES6转换为ES5。
- en: 'In the `memes.js` file, add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`memes.js`文件中，添加以下代码：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a simple class using ES6 that has a `console.log` statement inside
    the constructor. We will use Webpack and `babel-loader` to transform this ES6
    code to ES5 form. To do so, install the following packages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用ES6的简单类，构造函数中有一个`console.log`语句。我们将使用Webpack和`babel-loader`将这个ES6代码转换为ES5形式。为此，安装以下软件包：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In your `webpack.config.js` file, add the following code below the output property:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`webpack.config.js`文件中，在输出属性下面添加以下代码：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is how we should add a loader in Webpack. We need to create an array of
    rules inside the module section. The rule contains an array of configuration objects
    for the loaders. In our configuration, it will test the file to see whether it
    matches the regular expression `.js$`, that is, check whether the file is a JavaScript
    file using its extension. We have excluded the `node_modules` directory so that
    only our code will be evaluated for transformation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Webpack中添加加载器的方法。我们需要在模块部分内创建一组规则的数组。规则包含加载器的配置对象数组。在我们的配置中，它将测试文件，看它是否与正则表达式`.js$`匹配，也就是说，检查文件是否是JavaScript文件，使用它的扩展名。我们已经排除了`node_modules`目录，这样只有我们的代码会被评估进行转换。
- en: If the imported file is a JavaScript file, Webpack will use `babel-loader` with
    the provided options. Here, in `options`, we instruct Babel to use `env` and `es2015`
    presets. The `es2015` preset will transpile the ES6 code into the ES5 format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入的文件是JavaScript文件，Webpack将使用提供的选项使用`babel-loader`。在这里，在`options`中，我们指示Babel使用`env`和`es2015`预设。`es2015`预设将把ES6代码转译成ES5格式。
- en: '`env` preset is more special. It is used for transpiling any ES version of
    javascript to the version supported by a specific environment (such as specific
    versions of Chrome and Firefox). If no configuration is provided, as in our earlier
    mentioned code, then it will make the JavaScript code (even ES8) work in almost
    all environments. More information on this preset can be found at [https://github.com/babel/babel-preset-env](https://github.com/babel/babel-preset-env).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`预设更为特殊。它用于将任何ES版本的JavaScript转译为特定环境支持的版本（如特定版本的Chrome和Firefox）。如果没有提供配置，就像我们之前提到的代码一样，那么它将使JavaScript代码（甚至是ES8）在几乎所有环境中工作。有关此预设的更多信息，请访问[https://github.com/babel/babel-preset-env](https://github.com/babel/babel-preset-env)。'
- en: Since we are only going to use ES6 in this book, the `es2015` preset is enough
    for all the projects. However, if you want to learn ES7 and beyond in the future,
    do learn the working of the `env` preset.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只会在本书中使用ES6，所以`es2015`预设对所有项目来说已经足够了。但是，如果您将来想要学习ES7及更高版本，那么请学习`env`预设的工作。
- en: 'Similarly, let''s bundle our CSS code using Webpack. Bundling CSS code with
    Webpack has many advantages. Some of them are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们使用Webpack捆绑我们的CSS代码。使用Webpack捆绑CSS代码有许多优点。其中一些如下：
- en: Use only the required CSS code for each web page by importing it in respective
    JavaScript files. This will lead to easier and better dependency management and
    reduced file sizes per page.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在各自的JavaScript文件中导入所需的CSS代码，只使用每个网页所需的CSS代码。这将导致更容易和更好的依赖管理，并减少每个页面的文件大小。
- en: Minification of CSS files.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS文件的最小化。
- en: Automatically add vendor-specific prefixes easily using autoprefixer.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用autoprefixer轻松自动添加特定供应商前缀。
- en: Easily compile stylesheets written using Sass, Less, Stylus, and so on to normal
    CSS.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松编译使用Sass、Less、Stylus等编写的样式表为普通的CSS。
- en: 'There are even more advantages as to why you need to bundle your CSS code using
    Webpack. So, let''s start by bundling our `styles.css` file and then Bootstrap''s
    files. Install the following dependencies for implementing our loader for CSS:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Webpack捆绑CSS代码还有更多优势。因此，让我们从捆绑我们的`styles.css`文件开始，然后是Bootstrap的文件。安装以下依赖项来实现我们的CSS加载器：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our Webpack configuration, add the following object to the rules array:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Webpack配置中，将以下对象添加到rules数组中：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are installing two loaders to bundle CSS files:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在安装两个加载器来捆绑CSS文件：
- en: The first one is `css-loader`. It resolves all the imports and `url()` using
    Webpack. It then returns the complete CSS file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个是`css-loader`。它使用Webpack解析所有的导入和`url()`。然后返回完整的CSS文件。
- en: '`style-loader` will add the CSS to the page so that the styles are active on
    the page.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`style-loader`将把CSS添加到页面中，以便样式在页面上生效。'
- en: 'We need to run `css-loader` first, followed by `style-loader`, which uses the
    output returned by `css-loader`. To do that, we have written the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要先运行`css-loader`，然后是`style-loader`，它使用`css-loader`返回的输出。为此，我们编写了以下内容：
- en: 'For a CSS file: `test: /\.css$/`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于CSS文件：`test: /\.css$/`'
- en: 'Use the following loaders: `use: [''style-loader'', ''css-loader'']`. Webpack
    executes the loaders in a last to first order. So, first, `css-loader` will be
    executed and its output will be passed over to `style-loader`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用以下加载器：`use: [''style-loader'', ''css-loader'']`。Webpack按照从后到前的顺序执行加载器。因此，首先执行`css-loader`，然后将其输出传递给`style-loader`。'
- en: 'Open up your `general.js` file and add the following line at the beginning
    of the file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`general.js`文件，并在文件开头添加以下行：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, remove the `<link>` attribute used to include the CSS file in your `index.html`
    page. Here''s the trick: the CSS file will be imported into the `general.js` file,
    which will in turn be imported into the `memes.js` file, which is the only file
    you need to include in `index.html`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还要删除在你的`index.html`页面中用于包含CSS文件的`<link>`属性。这是一个技巧：CSS文件将被导入到`general.js`文件中，然后被导入到`memes.js`文件中，这是你需要在`index.html`中包含的唯一文件。
- en: We are going to create a large `webpack.config.js` file. If you face any problems,
    refer to the final `webpack.config.js` file we are creating at either: [https://goo.gl/Q8P4ta](https://goo.gl/Q8P4ta)
    or the book's code files under the `chapter02\webpack-dev-server` directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个大的`webpack.config.js`文件。如果遇到任何问题，请参考我们在以下位置创建的最终`webpack.config.js`文件：[https://goo.gl/Q8P4ta](https://goo.gl/Q8P4ta)或本书代码文件中的`chapter02\webpack-dev-server`目录。
- en: Now is the time to see our application. Execute `npm run webpack` in your terminal
    and open up the website that only has a single `memes.js` file included in Chrome.
    You should see the exact page with no changes. All the dependencies are bundled
    into a single file--except Bootstrap!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们的应用程序了。在终端中执行`npm run webpack`，然后在Chrome中打开只包含一个`memes.js`文件的网站。你应该看到完全相同的页面，没有任何变化。所有的依赖项都被捆绑到一个单一的文件中——除了Bootstrap！
- en: Bundling Bootstrap in Webpack
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Webpack中捆绑Bootstrap
- en: 'Time to bundle our final dependency into Webpack. Bootstrap consists of three
    parts. The first is Bootstrap''s CSS file, followed by jQuery and Bootstrap''s
    JavaScript file, which is dependent on jQuery. The last two files were ignored
    in this chapter''s `index.html` file, since we weren''t using them. But, since
    we are bundling our dependencies with Webpack, let''s just bring all of them together.
    For the first step, install our dependencies (these are not dev dependencies;
    hence, `-S` is used instead of `-D`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们最终的依赖项捆绑到Webpack中了。Bootstrap由三个部分组成。首先是Bootstrap的CSS文件，然后是jQuery和依赖于jQuery的Bootstrap的JavaScript文件。这两个文件在本章的`index.html`文件中被忽略了，因为我们没有使用它们。但是，由于我们正在使用Webpack捆绑我们的依赖项，让我们把它们都放在一起。首先，安装我们的依赖项（这些不是开发依赖项；因此，使用`-S`而不是`-D`）：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Bootstrap is written using **Less** instead of CSS. **Less** is a CSS pre-processor
    that extends CSS with more features, such as variables, mixins, and functions.
    To import Bootstrap''s less file using Webpack, we need another loader:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是使用**Less**而不是CSS编写的。**Less**是一个CSS预处理器，它通过添加更多功能（如变量、混合和函数）来扩展CSS。为了使用Webpack导入Bootstrap的less文件，我们需要另一个加载器：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will install the less compiler and loader into our `node_modules`. Now,
    in our rules, modify the CSS rules into:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把less编译器和加载器安装到我们的`node_modules`中。现在，在我们的rules中，将CSS规则修改为：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will add `less-loader` as the first option as a loader whenever CSS or
    a less file is detected by Webpack. Now, try `npm run webpack`. This time, you
    will get an error in the terminal saying "*You may need an appropriate loader
    to handle this file type*" for the fonts that are used by Bootstrap. Since Bootstrap
    is dependent on a lot of fonts, we need to create a separate loader to include
    them in our bundle. For this purpose, install the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Webpack检测到CSS或less文件时将`less-loader`作为第一个选项添加为加载器。现在，尝试`npm run webpack`。这次，你将在终端中收到一个错误，指出"*您可能需要一个适当的加载器来处理此文件类型*"，这是由Bootstrap使用的字体引起的。由于Bootstrap依赖于许多字体，我们需要创建一个单独的加载器将它们包含在我们的捆绑文件中。为此目的，安装以下内容：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then include the following object in your rules array:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在你的rules数组中包含以下对象：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will tell Webpack if the file size is smaller than 10 KB. Then, simply
    inline the file into JavaScript as a data URL. Otherwise, move the file into the
    fonts folder and create a reference in JavaScript. This is useful to reduce a
    network overhead if the file is smaller than 10 KB. `url-loader` requires `file-loader`
    to be installed as a dependency. Once again, execute `npm run webpack` and, this
    time, your Bootstrap less file will be bundled successfully and you will be able
    to view your website in the browser.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Webpack，如果文件大小小于10KB，则将文件作为数据URL内联到JavaScript中。否则，将文件移动到字体文件夹并在JavaScript中创建一个引用。如果文件大小小于10KB，则这对于减少网络开销很有用。`url-loader`需要安装`file-loader`作为依赖项。再次执行`npm
    run webpack`，这次你的Bootstrap less文件将成功捆绑，并且你将能够在浏览器中查看你的网站。
- en: This may look like a lot of work for a few CSS and JS files. But, when you are
    working on large-scale applications, these configurations can save hours of development
    work. The biggest advantage of Webpack is that you can write the configuration
    for one project and use it for other projects. So, most of the work we do here
    will be done only once. We'll simply copy and use our `webpack.config.js` file
    in other projects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些CSS和JS文件来说，这可能看起来是很多工作。但是，当您在大型应用程序上工作时，这些配置可以节省数小时的开发工作。Webpack的最大优势是您可以为一个项目编写配置，并将其用于其他项目。因此，我们在这里做的大部分工作只需要做一次。我们只需复制并在其他项目中使用我们的`webpack.config.js`文件。
- en: As I mentioned earlier, we didn't use Bootstrap's JS files in our application.
    However, we might need to use them for our applications in the future. Bootstrap
    requires jQuery to be available in global scope so that it's JavaScript files
    can be executed. However, Webpack does not expose the JavaScript variables it
    has bundled unless it is explicitly specified to expose them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们没有在应用程序中使用Bootstrap的JS文件。但是，我们可能需要在将来的应用程序中使用它们。Bootstrap需要全局范围内可用的jQuery，以便执行其JavaScript文件。但是，Webpack不会暴露它捆绑的JavaScript变量，除非明确指定要暴露它们。
- en: 'To make jQuery available in the global scope throughout our web application,
    we need to use a Webpack plugin. Plugins are different from loaders. We''ll see
    more about plugins in a moment. For now, add the following code after the module
    property of Webpack:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使jQuery在整个Web应用程序中的全局范围内可用，我们需要使用Webpack插件。插件与加载程序不同。我们稍后会详细了解插件。现在，请在Webpack的module属性之后添加以下代码：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our `general.js` file, include the following line to import all the Bootstrap
    JavaScript files into our web app:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`general.js`文件中，包含以下行以将所有Bootstrap JavaScript文件导入到我们的Web应用程序中：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This line will import Bootstrap's JavaScript files from the `node_modules` folder.
    You have now successfully bundled Bootstrap using Webpack. There is just one more
    loader that is commonly used `- img-loader`. There are scenarios when we include
    images in CSS and JavaScript. Using Webpack, we can automatically bundle the images
    while compressing the size of larger images during bundling.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这行将从`node_modules`文件夹中导入Bootstrap的JavaScript文件。您现在已成功使用Webpack捆绑了Bootstrap。还有一个常用的加载程序`-
    img-loader`。有时我们会在CSS和JavaScript中包含图像。使用Webpack，我们可以在捆绑时自动捆绑图像，同时压缩较大图像的大小。
- en: 'To bundle images, we need to use `img-loader` and `url-loader` together. First,
    install `img-loader`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要捆绑图像，我们需要一起使用`img-loader`和`url-loader`。首先，安装`img-loader`：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following object to your rules list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下对象添加到您的规则列表中：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, execute `npm run webpack` and open up the website again. You have all your
    dependencies bundled inside a single JavaScript file `memes.js` and you are ready
    to go.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行`npm run webpack`，然后再次打开网站。您的所有依赖项都已捆绑在一个名为`memes.js`的JavaScript文件中，准备就绪。
- en: Sometimes, the `img-loader` binaries might fail during building depending on
    your operating system. In the latest version of Ubuntu, this is due to a missing
    package that can be downloaded and installed from: [https://packages.debian.org/jessie/amd64/libpng12-0/download](https://packages.debian.org/jessie/amd64/libpng12-0/download).
    In other operating systems, you have to manually find out why the build failed.
    If you cannot resolve the `img-loader` issue, do try to use a different loader
    or simply remove `img-loader` and only use `url-loader` for images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`img-loader`二进制文件在构建过程中可能会因您的操作系统而失败。在Ubuntu的最新版本中，这是由于缺少的软件包，可以从[https://packages.debian.org/jessie/amd64/libpng12-0/download](https://packages.debian.org/jessie/amd64/libpng12-0/download)下载并安装。在其他操作系统中，您必须手动找出构建失败的原因。如果您无法解决`img-loader`问题，请尝试使用不同的加载程序，或者只使用`url-loader`来处理图像。
- en: Plugins in Webpack
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack中的插件
- en: Unlike loaders, plugins are used to customize the Webpack build process. There
    are a lot of plugins that are built into Webpack. They can be accessed by `webpack.[plugin-name]`.
    We can also write our own functions as plugins.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与加载程序不同，插件用于自定义Webpack构建过程。Webpack内置了许多插件。它们可以通过`webpack.[plugin-name]`访问。我们还可以编写自己的函数作为插件。
- en: For more information on webpack's plugin system, refer to [https://webpack.js.org/configuration/plugins/](https://webpack.js.org/configuration/plugins/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有关webpack的插件系统的更多信息，请参阅[https://webpack.js.org/configuration/plugins/](https://webpack.js.org/configuration/plugins/)。
- en: Webpack dev server
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack开发服务器
- en: 'So far, we have created the Webpack configuration to compile our code, but
    it will be easier if we can serve the code as we did using `http-server`. `webpack-dev-server`
    is a small server written using Node.js and Express, which is used to serve the
    Webpack bundle. To use `webpack-dev-server`, we need to install it''s dependencies
    and update our npm scripts:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了Webpack配置来编译我们的代码，但如果我们可以像使用`http-server`一样提供代码，那将更容易。`webpack-dev-server`是一个使用Node.js和Express编写的小型服务器，用于提供Webpack捆绑包。要使用`webpack-dev-server`，我们需要安装它的依赖项并更新我们的npm脚本：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following line to the npm scripts:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到npm脚本中：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the `npm run watch`, we can now serve the files over a server on our
    localhost. `webpack-dev-server` does not write the bundled files to the disk.
    Instead, it will automatically serve them from memory. One great feature of `webpack-dev-server`
    is that it is able to do `HotModuleReplacement`, which will replace a part of
    code that has been changed without even reloading the page. To use `HotModuleReplacement`,
    add the following configurations to your Webpack configuration file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm run watch`，我们现在可以在本地主机上的服务器上提供文件。`webpack-dev-server`不会将捆绑的文件写入磁盘。相反，它将自动从内存中提供它们。`webpack-dev-server`的一个很棒的功能是它能够进行`HotModuleReplacement`，这将替换已更改的代码部分，甚至无需重新加载页面。要使用`HotModuleReplacement`，请将以下配置添加到您的Webpack配置文件中：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Currently, `webpack-dev-server` is serving files from the root. But we need
    files to be served from the `dist` directory. To do that, we need to set `publicPath`
    in our output configuration:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`webpack-dev-server`正在从根目录提供文件。但是我们需要从`dist`目录提供文件。为此，我们需要在输出配置中设置`publicPath`：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Delete your `dist` folder and run the `npm run watch` command. Your web app
    will now print a few extra messages in the console. These are from `webpack-dev-server`,
    which is listening for any file changes. Try changing a few lines in your CSS
    file. Your changes will be immediately, reflected without having to reload the
    page! This is very useful to see style changes immediately as soon as the code
    is saved. `HotModuleReplacement` is widely used in modern JavaScript frameworks,
    such as React, Angular, and so on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 删除你的`dist`文件夹并运行`npm run watch`命令。你的Web应用现在将在控制台中打印一些额外的消息。这些消息来自`webpack-dev-server`，它正在监听任何文件更改。尝试在CSS文件中更改几行。你的更改将立即反映出来，无需重新加载页面！这对于在代码保存后立即查看样式更改非常有用。`HotModuleReplacement`广泛用于现代JavaScript框架，如React、Angular等。
- en: 'We are still missing `source-maps` in our code for debugging. To enable `source-maps`,
    Webpack provides a simple configuration option:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中仍然缺少用于调试的“source-maps”。为了启用“source-maps”，Webpack提供了一个简单的配置选项：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are different types of source-maps that can be generated by Webpack depending
    on the time taken to generate them and the quality. Refer to this page for more
    information: [https://webpack.js.org/configuration/devtool/](https://webpack.js.org/configuration/devtool/).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack可以生成不同类型的源映射，具体取决于生成它们所需的时间和质量。请参考此页面以获取更多信息：[https://webpack.js.org/configuration/devtool/](https://webpack.js.org/configuration/devtool/)。
- en: 'This will only add source maps to the JS files. To add `source-maps` to CSS
    files, which also contains Bootstrap''s less files, change the CSS rules to the
    following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只向JS文件添加源映射。要向包含Bootstrap的less文件的CSS文件添加`source-maps`，请将CSS规则更改为以下内容：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This rule will tell `less-loader` to add `source-maps` to the files compiled
    by it and pass it to `css-loader`, which will also pass the source maps to `style-loader`.
    Now, both your JS and CSS files will have source maps, making it easy to debug
    the application in Chrome.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则将告诉`less-loader`向其编译的文件添加`source-maps`并将其传递给`css-loader`，后者也将源映射传递给`style-loader`。现在，你的JS和CSS文件都将有源映射，这样就可以轻松在Chrome中调试应用程序。
- en: 'If you have been following along, your Webpack configuration file should now
    look like the code in the following URL: [https://goo.gl/Q8P4ta](https://gist.github.com/DaniAkash/811221175c9ef5c292f0fd6f1cec5bc3).
    Your `package.json` file should look like: [https://goo.gl/m4Ib97](https://gist.github.com/DaniAkash/6ec06b68033a5fe46fa68bfe3ce492fd).
    These files are also included in the book''s code inside the `chapter02\webpack-dev-server`
    directory.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟进，你的Webpack配置文件现在应该看起来像以下URL中的代码：[https://goo.gl/Q8P4ta](https://gist.github.com/DaniAkash/811221175c9ef5c292f0fd6f1cec5bc3)。你的`package.json`文件应该是这样的：[https://goo.gl/m4Ib97](https://gist.github.com/DaniAkash/6ec06b68033a5fe46fa68bfe3ce492fd)。这些文件也包含在书中代码的`chapter02\webpack-dev-server`目录中。
- en: We have used a lot of different loaders with Webpack, each of them having their
    own configuration options, many of which we did not discuss here. Do visit those
    packages, npm or GitHub pages to learn more about their configuration and customize
    them as per your requirements.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Webpack中使用了许多不同的加载器，每个加载器都有自己的配置选项，其中许多我们在这里没有讨论。请访问这些包的npm或GitHub页面，了解更多关于它们的配置并根据您的需求进行自定义。
- en: The upcoming section is optional. If you want to build the Meme Creator app,
    you can skip the next section and start with the development. The Webpack configuration
    you have now will be totally fine. However, the next section is important to learn
    more about Webpack and use it in production, so do come back to read about it
    later!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的部分是可选的。如果你想构建Meme Creator应用程序，你可以跳过下一部分并开始开发。你现在拥有的Webpack配置完全没问题。然而，下一部分对于更多了解Webpack并在生产中使用它非常重要，所以请稍后回来阅读！
- en: Optimizing Webpack builds for different environments
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同环境优化Webpack构建
- en: While working on large scale applications, there are usually different types
    of environments created for the application to run, such as development, testing,
    staging, production, and so on. Each environment has different configurations
    for the application and is useful for development and testing by different groups
    of people in the team.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型应用程序时，通常会为应用程序创建不同类型的环境，例如开发、测试、暂存、生产等。每个环境都有不同的应用程序配置，对于团队中的不同人员进行开发和测试非常有用。
- en: For example, imagine you have an API for payments in your app. During development,
    you will have sandbox credentials and, for testing, you have different credentials,
    and finally, for production, you have the actual credentials needed by the payment
    gateway. So, the application needs to use three different credentials for three
    different environments. It is also important not to commit sensitive information
    into your version control system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的应用程序有一个用于支付的API。在开发过程中，你将拥有沙盒凭据，而在测试过程中，你将拥有不同的凭据，最后，在生产环境中，你将拥有支付网关所需的实际凭据。因此，应用程序需要在三种不同的环境中使用三种不同的凭据。同样重要的是不要将敏感信息提交到版本控制系统中。
- en: So, how are we going to pass the credentials to the app without writing them
    in the code? That's where the concept of environment variables come in. The operating
    system will provide the values during compile time so that the build can be generated
    with values from different environment variables in different environments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在不在代码中写入凭据的情况下将凭据传递给应用程序？这就是环境变量的概念发挥作用的地方。操作系统将在编译时提供值，以便可以使用不同环境变量中的值在不同环境中生成构建。
- en: 'The process of creating environment variables is different for each operating
    system and it''s a tedious task to maintain these environment variables for each
    project. So, let''s simplify the process by using an `npm` package to load our
    environment variables from a `.env` file from our project root folder. In Node.js,
    you can access the environment variables in the `process.env` object. Here''s
    how you can read variables from `.env` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境变量的过程对于每个操作系统都是不同的，对于每个项目来说维护这些环境变量是一项繁琐的任务。因此，让我们通过使用`npm`包从项目根目录的`.env`文件中加载我们的环境变量来简化这个过程。在Node.js中，您可以在`process.env`对象中访问环境变量。以下是如何从`.env`文件中读取变量的方法：
- en: 'The first step is to install the following package:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是安装以下包：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once this is done, create a `.env` file in your project root directory with
    the following lines:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，在您的项目根目录中创建一个`.env`文件，并添加以下行：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This `.env` file contains three environment variables and their values. You
    should add the `.env` file to your `.gitignore` file if you are using Git or include
    it in the ignore list of your version control system. It''s also a good practice
    to create the `.env.example` file, which tells other developers what kind of environment
    variables are needed by the application. You can commit the `.env.example` file
    to your version control system. Our `.env.example` file should look as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`.env`文件包含三个环境变量及其值。如果您使用Git，则应将`.env`文件添加到`.gitignore`文件中，或将其包含在您的版本控制系统的忽略列表中。创建`.env.example`文件也是一个好习惯，它告诉其他开发人员应用程序需要哪些环境变量。您可以将`.env.example`文件提交到您的版本控制系统。我们的`.env.example`文件应如下所示：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These environment variables can be read by Node.js, but they can't be read by
    our JavaScript code. So, we need Webpack to read these variables and provide them
    as global variables to the JavaScript code. It is recommended to keep the letters
    of the environment variable names in capital letters so that you can easily identify
    them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境变量可以被Node.js读取，但不能被我们的JavaScript代码读取。因此，我们需要Webpack读取这些变量，并将它们作为全局变量提供给JavaScript代码。建议将环境变量名称的字母保持大写，以便您可以轻松识别它们。
- en: 'We are going to use `NODE_ENV` for detecting the environment type and to tell
    Webpack to generate an appropriate build for that environment, and we need to
    use other two environment variables in our JS code. In your `webpack.config.js`
    file, in the first line, include the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`NODE_ENV`来检测环境类型，并告诉Webpack为该环境生成适当的构建，我们需要在我们的JS代码中使用其他两个环境变量。在您的`webpack.config.js`文件中，第一行包含以下代码：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will use the `dotenv` package we just installed and load the environment
    variables from the `.env` file in our project''s root directory. Now, the environment
    variables are accessible inside the Webpack configuration file in the `process.env`
    object. First, let''s set up a flag to check whether the current environment is
    production. Include the following code after the `require(''webpack'')` line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用我们刚刚安装的`dotenv`包，并从我们项目的根目录中的`.env`文件中加载环境变量。现在，环境变量可以在Webpack配置文件中的`process.env`对象中访问。首先，让我们设置一个标志，检查当前环境是否为production。在`require('webpack')`行之后包含以下代码：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, `isProduction` will be set to true when `NODE_ENV` is set to production.
    To include the other two variables in our JavaScript code, we need to use `DefinePlugin`
    in Webpack. Inside the plugins array, add the following configuration object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`NODE_ENV`设置为production时，`isProduction`将被设置为true。要在我们的JavaScript代码中包含另外两个变量，我们需要在Webpack中使用`DefinePlugin`。在插件数组中，添加以下配置对象：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`DefinePlugin` will define the constants at compile time, so you can change
    your environment variables depending on your environment and it will be reflected
    in the code. Make sure you stringify any value you pass to `DefinePlugin`. More
    information about this plugin can be found at: [https://webpack.js.org/plugins/define-plugin/](https://webpack.js.org/plugins/define-plugin/).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefinePlugin`将在编译时定义常量，因此您可以根据您的环境更改您的环境变量，并且它将反映在代码中。确保您对传递给`DefinePlugin`的任何值进行字符串化。有关此插件的更多信息，请访问：[https://webpack.js.org/plugins/define-plugin/](https://webpack.js.org/plugins/define-plugin/)。'
- en: Now, inside your `memes.js` file's constructor, try `console.log(ENVIRONMENT,
    CONSTANT_VALUE);` and reload Chrome. You should see their values printed out in
    the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的`memes.js`文件的构造函数中，尝试`console.log(ENVIRONMENT, CONSTANT_VALUE);`并重新加载Chrome。您应该在控制台中看到它们的值被打印出来。
- en: Since we set up a flag using the `isProduction` variable, we can use this variable
    to do various optimizations to the build only when the environment is production.
    Some of the common plugins used for optimizations in production builds are as
    follows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`isProduction`变量设置了一个标志，所以只有在环境为production时才能对构建进行各种优化。一些常用于生产构建优化的插件如下。
- en: Creating .env file in Windows
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows中创建.env文件
- en: 'Windows do not allow you to create a `.env` file directly from the windows
    explorer since it will not allow file names starting with a dot. However, you
    will be able to create it from VSCode easily. First, open the project folder in
    VSCode using the menu option File | Open Folder...[Ctrl+K Ctrl+O] as shown in
    the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Windows不允许您直接从Windows资源管理器创建`.env`文件，因为它不允许以点开头的文件名。但是，您可以轻松地从VSCode中创建它。首先，使用菜单选项文件|打开文件夹...[Ctrl+K
    Ctrl+O]打开VSCode中的项目文件夹，如下截图所示：
- en: '![](../images/00012.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: 'Once you have opened the folder, click on the Explorer icon on the top left
    corner of the VSCode (or press *Ctrl*+*Shift*+*E*) to open the explorer panel.
    In the explorer panel, click on the New File button as shown in the following
    screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打开了文件夹，点击VSCode左上角的资源管理器图标（或按*Ctrl*+*Shift*+*E*）打开资源管理器面板。在资源管理器面板中，点击“新建文件”按钮，如下截图所示：
- en: '![](../images/00013.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: 'Then simply type in the new file name `.env` as shown in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如下截图所示，简单地输入新文件名`.env`：
- en: '![](../images/00014.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: Hit *Enter* to create the `.env` file and start editing it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*创建`.env`文件并开始编辑它。
- en: '`.env` files are read only when the Webpack-dev-server starts. So, if you make
    any changes to the `.env` files, you will have to kill the running Webpack-dev-server
    instance in the Terminal and restart it so that it will read the new values in
    `.env` files.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当Webpack-dev-server启动时，`.env`文件是只读的。因此，如果您对`.env`文件进行任何更改，您将需要在终端中终止运行的Webpack-dev-server实例，并重新启动它，以便它将读取`.env`文件中的新值。
- en: UglifyJsPlugin
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UglifyJsPlugin
- en: 'This is a plugin that is used for compressing and minifying JavaScript files.
    This greatly reduces the size of the JavaScript code and increases the loading
    speed for end users. However, using this plugin during development will cause
    Webpack to slow down, since it adds an extra step to the build process (expensive
    task). Hence, `UglifyJsPlugin` is usually used only on production environments.
    To do so, add the following lines at the end of your Webpack configuration:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于压缩和缩小JavaScript文件的插件。这将大大减小JavaScript代码的大小，并增加最终用户的加载速度。但是，在开发过程中使用此插件会导致Webpack变慢，因为它会为构建过程添加额外的步骤（昂贵的任务）。因此，`UglifyJsPlugin`通常仅在生产环境中使用。要这样做，请在Webpack配置的末尾添加以下行：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will push `UglifyJSPlugin` to the plugins array if the environment is set
    to production. More information regarding `UglifyJsPlugin` can be found at: [https://webpack.js.org/plugins/uglifyjs-webpack-plugin/](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境设置为生产环境，这将将`UglifyJSPlugin`推送到插件数组中。有关`UglifyJsPlugin`的更多信息，请访问：[https://webpack.js.org/plugins/uglifyjs-webpack-plugin/](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/)。
- en: PurifyCSSPlugin
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PurifyCSSPlugin
- en: 'When building web applications, there will be a lot of styles that are defined
    in CSS but are never used in HTML. `PurifyCSSPlugin` will go through all the HTML
    files and remove any unnecessary CSS styles that we have defined before bundling
    the code. To use `PurifyCSSPlugin`, we need to install the `purifycss-webpack`
    package:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Web应用程序时，将会有很多在CSS中定义但在HTML中从未使用的样式。`PurifyCSSPlugin`将遍历所有HTML文件，并在捆绑代码之前删除我们之前定义的任何不必要的CSS样式。要使用`PurifyCSSPlugin`，我们需要安装`purifycss-webpack`包：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After that, import the plugin to your Webpack configuration file and use it
    as specified in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将插件导入到您的Webpack配置文件中，并按以下代码中指定的方式使用它：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`glob` is an inbuilt module in Node.js. We specify the paths of HTML using
    `glob.sync`, which resolves the regular expression into all the HTML files inside
    the specified directory. `PurifyCSSPlugin` will now use these HTML files to purify
    our styles. The `minimize` option will minify CSS along with purification. More
    information regarding `PurifyCSSPlugin` can be found at: [https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob`是Node.js中的内置模块。我们使用`glob.sync`指定HTML的路径，它将正则表达式解析为指定目录中的所有HTML文件。`PurifyCSSPlugin`现在将使用这些HTML文件来净化我们的样式。`minimize`选项将与净化一起最小化CSS。有关`PurifyCSSPlugin`的更多信息，请访问：[https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack)。'
- en: '`PurifyCSSplugin` is useful but it might cause problems with Bootstrap animations
    and some other plugins. Make sure you test it well before using it.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`PurifyCSSplugin`很有用，但可能会导致Bootstrap动画和其他一些插件出现问题。在使用之前，请务必进行充分测试。'
- en: ExtractTextPlugin
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExtractTextPlugin
- en: In production, it is recommended to extract all your CSS code into a separate
    file. This is because CSS files need to be included at the beginning of the page
    so that page styles will be applied to HTML while it is loading. However, since
    we are bundling CSS together with JavaScript, we are including it at the end of
    the page. When the page is loading, it will look like a plain document till the
    CSS files are loaded.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，建议将所有CSS代码提取到单独的文件中。这是因为CSS文件需要在页面开头包含，以便在加载HTML时应用页面样式。但是，由于我们将CSS与JavaScript捆绑在一起，因此我们将其包含在页面末尾。当页面加载时，它将看起来像一个普通文档，直到CSS文件加载完成。
- en: '`ExtractTextPlugin` is used to overcome this problem. It will extract all the
    CSS files in JS code into separate files with the same name as the JS file it
    was bundled together with. We can now include that CSS file at the top of our
    HTML file, which makes the styles be loaded first. As usual, the first step is
    to install the package:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractTextPlugin`用于解决这个问题。它将把所有CSS文件从JS代码中提取到与其捆绑在一起的具有相同名称的单独文件中。现在我们可以在HTML文件的顶部包含该CSS文件，这样样式将首先加载。和往常一样，第一步是安装包：'
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After this, we need to create a new instance of `ExtractTextPlugin`, which
    we are going to use with our CSS files. Since we are also using less from Bootstrap,
    our configuration file should look as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要创建一个新的`ExtractTextPlugin`实例，我们将与我们的CSS文件一起使用。由于我们还在使用Bootstrap的less，我们的配置文件应该如下所示：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have created an instance of `ExtractTextPlugin` as `extractLess`. Since we
    are using `PurifyCSSPlugin`, make sure you include the `extractLess` object before
    we create an instance `PurifyCSSPlugin` in the plugins array.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`extractLess`的`ExtractTextPlugin`实例。由于我们使用了`PurifyCSSPlugin`，请确保在我们在插件数组中创建`PurifyCSSPlugin`实例之前包含`extractLess`对象。
- en: More information regarding `PurifyCSSPlugin` can be found at: [https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`PurifyCSSPlugin`的更多信息，请访问：[https://github.com/webpack-contrib/purifycss-webpack](https://github.com/webpack-contrib/purifycss-webpack)。
- en: Once you have added `ExtractTextPlugin`, Webpack will generate two files for
    each JavaScript file if the JavaScript file imports CSS. You will have to include
    the CSS files separately in your HTML. In our case, for `memes.js`, it will generate
    `memes.js` and `memes.css` in the `dist` directory, which needs to be included
    separately in the HTML file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了`ExtractTextPlugin`，Webpack将为每个JavaScript文件生成两个文件，如果JavaScript文件导入CSS，则需要在HTML中单独包含CSS文件。在我们的情况下，对于`memes.js`，它将在`dist`目录中生成`memes.js`和`memes.css`，这需要单独包含在HTML文件中。
- en: '`ExtractTextPlugin` will not work properly with Webpack `HotModuleReplacement`
    for CSS files. Hence, it''s best to include `ExtractTextPlugin` only in production.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractTextPlugin`与Webpack的`HotModuleReplacement`不适用于CSS文件。因此，最好只在生产环境中包含`ExtractTextPlugin`。'
- en: Cache busting
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存破坏
- en: To use caching with the static resources produced by Webpack, it's a good practice
    to append the filenames of the static resources with hashes. **[chunkhash]** will
    generate a content-dependent hash, which should be appended to the filename that
    acts as the cache buster. Whenever the content of the file changes, the hash will
    change, which will lead to new filenames and, hence, regenerating the cache.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Webpack生成的静态资源进行缓存，最好的做法是将静态资源的文件名附加哈希。**[chunkhash]**将生成一个内容相关的哈希，应该附加到充当缓存破坏器的文件名上。每当文件内容发生变化时，哈希值都会改变，这将导致新的文件名，因此重新生成缓存。
- en: 'Only production builds need cache busting logic. Development builds do not
    need these configurations. Hence, we need to generate hashed filenames only at
    production. Also, we must generate a `manifest.json` file that contains the new
    filenames of the generated resources that must be inlined into the HTML file.
    Configurations for cache busting are as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 只有生产构建需要缓存破坏逻辑。开发构建不需要这些配置。因此，我们只需要在生产环境中生成带哈希的文件名。此外，我们必须生成一个包含生成资源的新文件名的`manifest.json`文件，这些资源必须内联到HTML文件中。缓存破坏的配置如下：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will add a hash prefix to the filenames in production. However, `webpack.HotModuleReplacementPlugin()`
    does not work well with **[chunkhash]**, so `HotModuleReplacementPlugin` should
    not be used in our production environment. To generate the `manifest.json` file,
    add the following function as an element to the plugins array:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在生产环境中为文件名添加哈希前缀。但是，`webpack.HotModuleReplacementPlugin()`与**[chunkhash]**不兼容，因此在我们的生产环境中不应使用`HotModuleReplacementPlugin`。要生成`manifest.json`文件，请将以下函数作为元素添加到插件数组中：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Or it's better to add it next to `UglifyJSPlugin`, which gets executed only
    in production. This function will use the `fs` module in Node.js to write the
    generated files as a JSON file. For more information regarding this topic, refer
    to: [https://webpack.js.org/guides/caching/](https://webpack.js.org/guides/caching/).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者最好将其添加到`UglifyJSPlugin`旁边，该插件仅在生产环境中执行。此函数将使用Node.js中的`fs`模块将生成的文件写入JSON文件。有关此主题的更多信息，请参阅：[https://webpack.js.org/guides/caching/](https://webpack.js.org/guides/caching/)。
- en: Clean dist folder before generating a new build
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生成新构建之前清理`dist`文件夹。
- en: 'Since we generate lot of builds with different hashed filenames, it is a good
    practice to delete the `dist` directory before running each build. `clean-webpack-plugin`
    does just that. It cleans the `dist` directory before new files are bundled. To
    use `clean-webpack-plugin`, run the following command inside the project root
    folder to install the plugin: :'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们生成了许多带有不同哈希文件名的构建，最好的做法是在运行每个构建之前删除`dist`目录。`clean-webpack-plugin`就是这样做的。它会在新文件捆绑之前清理`dist`目录。要使用`clean-webpack-plugin`，请在项目根目录内运行以下命令来安装插件：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, add the following variables to your Webpack configuration file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下变量添加到您的Webpack配置文件中：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, add `new CleanWebpackPlugin(pathsToClean, cleanOptions)` to your production
    plugins. Now, every time the production build is generated, the old `dist` folder
    will be deleted and a new folder will be created with the latest bundled files.
    More information regarding this plugin can be found at: [https://github.com/johnagan/clean-webpack-plugin](https://github.com/johnagan/clean-webpack-plugin).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`new CleanWebpackPlugin(pathsToClean, cleanOptions)`添加到您的生产插件中。现在，每次生成生产构建时，旧的`dist`文件夹将被删除，并将创建一个包含最新捆绑文件的新文件夹。有关此插件的更多信息，请参阅：[https://github.com/johnagan/clean-webpack-plugin](https://github.com/johnagan/clean-webpack-plugin)。
- en: Source maps in production
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境中的源映射
- en: 'Source maps provide us with an easy way to debug our compiled code. Browsers
    don''t load source maps until the development tool is opened. Hence, performance-wise
    source maps don''t cause any harm. However, if you need the original source code
    to be protected, then removing source maps is a good idea. You can also use private
    source maps by setting `sourceMappingURL` at the end of each bundled file to a
    restricted URL that can be used only by a trusted source (for example, source
    maps can be accessed only by developers within the company''s domain):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射为我们提供了一种轻松调试编译后的代码的方法。直到打开开发工具之前，浏览器不会加载源映射。因此，就性能而言，源映射不会造成任何伤害。但是，如果需要保护原始源代码，则删除源映射是一个好主意。您还可以通过在每个捆绑文件的末尾设置`sourceMappingURL`来使用私有源映射，以将哈希前缀添加到生产环境中的文件名。这样，源映射只能由受信任的源（例如，源映射只能由公司域内的开发人员访问）使用：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The complete Webpack configuration file with all the earlier mentioned optimizations
    will look as: [https://goo.gl/UDuUBu](https://goo.gl/UDuUBu). The dependencies
    used in this configuration can be found at: [https://goo.gl/PcHpZf](https://goo.gl/PcHpZf).
    These files are also included in this book's code files under the `Chapter02\webpack
    production optimized` directory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了所有前面提到的优化的完整Webpack配置文件如下：[https://goo.gl/UDuUBu](https://goo.gl/UDuUBu)。此配置中使用的依赖项可以在此处找到：[https://goo.gl/PcHpZf](https://goo.gl/PcHpZf)。这些文件也包含在本书的代码文件中，位于`Chapter02\webpack
    production optimized`目录下。
- en: 'We have just tried of lot of community created plugins and loaders for Webpack.
    Remember that there is more than one way to perform these tasks. So, be sure to
    check out a lot of new plugins/loaders created over time. This repository contains
    a curated list of Webpack resources: [https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚尝试了许多由社区创建的Webpack插件和加载器。请记住，执行这些任务的方法不止一种。因此，请务必随时查看许多新的插件/加载器。此存储库包含了Webpack资源的精选列表：[https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack)。
- en: 'Since we are using flexbox in the Meme Creator, some old browsers support flexbox
    with `vendor-prefixes`. Try adding vendor prefixes to your CSS using `postcss/autoprefixer`:
    [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Meme Creator中使用了flexbox，一些旧的浏览器支持带有`vendor-prefixes`的flexbox。尝试使用`postcss/autoprefixer`向您的CSS添加供应商前缀：[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)。
- en: Building the Meme Creator
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Meme Creator
- en: We just built a nice little development environment using Webpack. It's time
    to put it into action. If you have done the production optimizations, make sure
    you have created the `.env` file in the project root folder and your `NODE_ENV`
    environment variable inside that file is not `production`. Simply set the value
    of `NODE_ENV=dev` while we are working on the application. We are going to build
    the Meme Creator now. Make sure you have included the `memes.js` and `memes.css`
    files (if you used `ExtractTextPlugin`) from the `dist` directory in your `index.html`
    file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用Webpack构建了一个不错的开发环境。现在是时候投入使用了。如果您已经进行了生产优化，请确保在项目根文件夹中创建了`.env`文件，并且该文件中的`NODE_ENV`环境变量不是`production`。在我们工作在应用程序时，简单地将`NODE_ENV=dev`的值设置为`NODE_ENV`。我们现在要构建Meme
    Creator。确保您已经在`index.html`文件中包含了`dist`目录中的`memes.js`和`memes.css`文件（如果您使用了`ExtractTextPlugin`）。
- en: Open up the `memes.js` file in your text editor and keep `webpack-dev-server`
    running (`npm run watch`). Our first step is to create a reference to all the
    required DOM elements in variables in our class. We can then use the references
    to modify the elements later, from inside the class. Also, whenever we are creating
    a reference to DOM elements, it is good to have the variable names start with
    `$`. This way, we can easily know which variables contain values and which ones
    contain references to the DOM elements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`memes.js`文件并保持`webpack-dev-server`运行（`npm run watch`）。我们的第一步是在我们的类中创建对所有所需DOM元素的引用变量。然后，我们可以使用这些引用来稍后从类内部修改元素。此外，每当我们创建对DOM元素的引用时，最好将变量名称以`$`开头。这样，我们可以轻松知道哪些变量包含值，哪些包含对DOM元素的引用。
- en: webpack-dev-server will print the URL in the console which you should open using
    Chrome to see your application. The URL will be http://localhost:8080/
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: webpack-dev-server将在控制台中打印URL，您应该使用Chrome打开以查看您的应用程序。URL将是http://localhost:8080/
- en: 'Remember how in the previous chapter, we used `document.getElementById()` to
    search through the DOM elements? JavaScript also has a better alternative that
    makes querying DOM elements simpler: the `document.querySelector()` method. The
    former allowed us to search a document only using `Id`, but `querySelector` allows
    us to query the document using `id`, class, and even the element''s name. For
    example, if you need to select the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在上一章中，我们使用`document.getElementById()`来搜索DOM元素吗？JavaScript还有一个更好的替代方法，使查询DOM元素更简单：`document.querySelector()`方法。前者只允许我们使用`Id`搜索文档，但`querySelector`允许我们使用`id`、类甚至元素名称查询文档。例如，如果您需要选择以下内容：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can use one of the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下之一：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All of these will return the first element matching the query criteria. If
    you want to select multiple elements, you can use `document.querySelectorAll()`,
    which returns an array of references to all the matching DOM elements. In our
    constructor, write the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将返回与查询条件匹配的第一个元素。如果要选择多个元素，可以使用`document.querySelectorAll()`，它将返回对所有匹配的DOM元素的引用数组。在我们的构造函数中，编写以下代码：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we have a reference to all the required DOM elements in our class. Currently,
    our canvas is small; we didn''t specify its size using CSS because we need the
    page to be responsive. If users visits the page from a mobile device, we don''t
    want to show a horizontal scrollbar because the canvas has gone out of the screen
    due to its size. Hence, we will use JavaScript to create the canvas height and
    width depending on the screen size. We need to calculate the device width first.
    Add the following code above the `Memes` class (not inside the class):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的类中有对所有所需DOM元素的引用。目前，我们的画布很小；我们没有使用CSS指定其大小，因为我们需要页面具有响应性。如果用户从移动设备访问页面，我们不希望显示水平滚动条，因为画布由于其大小而超出了屏幕。因此，我们将使用JavaScript根据屏幕大小创建画布高度和宽度。首先需要计算设备宽度。在`Memes`类之前添加以下代码（不要放在类内部）：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will calculate the device''s width and store it in a constant `deviceWidth`.
    Inside the class, create the following function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算设备的宽度并将其存储在常量`deviceWidth`中。在类内部，创建以下函数：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: References to DOM elements contain the entire target element as a JavaScript
    object. It can be used in the same way we handle normal class objects. Modifications
    to references will be reflected in the DOM.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对DOM元素的引用包含整个目标元素作为JavaScript对象。它可以像处理普通类对象一样使用。对引用的修改将反映在DOM中。
- en: This will create a rectanglar canvas with height `480` and width `640` if the
    device's screen is large enough. Otherwise, it will create a square canvas with
    width `deviceWidth-30`. Refer to the image of the Meme Creator you saw earlier.
    The canvas will be rectangular for desktops and will become a square area with
    margin for mobile devices.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备屏幕足够大，这将创建一个高度为`480`，宽度为`640`的矩形画布。否则，它将创建一个宽度为`deviceWidth-30`的正方形画布。参考您之前看到的Meme
    Creator的图像。桌面上的画布将是矩形的，而移动设备上将成为带有边距的正方形区域。
- en: '`Math.min(x, y)` will return the smallest of two numbers `x` and `y`. We reduced
    the width by `30` because we need to have space for the margins. Add `this.createCanvas()`
    inside the constructor and view the page in Chrome (Webpack will have reloaded
    the page for you). Try the responsive design mode to see how the canvas appears
    on mobile devices. Height and width are applied only when the page is loaded for
    the first time; hence, refresh the page when you are checking different devices.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.min(x, y)`将返回两个数字`x`和`y`中较小的那个。我们将宽度减小了`30`，因为我们需要为边距留出空间。在构造函数中添加`this.createCanvas()`，并在Chrome中查看页面（Webpack将为您重新加载页面）。尝试响应式设计模式，查看画布在移动设备上的显示方式。高度和宽度仅在首次加载页面时应用；因此，在检查不同设备时，请刷新页面。'
- en: Our canvas area is ready; let's look at a few things about the new `<canvas>`
    element in HTML. Canvas is a container for graphics. We can use JavaScript to
    write graphics on the canvas element. Canvas has several methods for drawing,
    such as paths, shapes, text, and images. Also, rendering graphics in canvas is
    faster than using DOM elements. One more advantage of canvas is that we can convert
    the canvas content into an image. In real-world applications, where you have server-side
    APIs, you can use the server to render the images and text for the memes. But,
    since we are not going to use server-side in this chapter, canvas is our best
    option.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的画布区域已经准备好了；让我们来看看HTML中新的`<canvas>`元素的一些内容。Canvas是一个图形容器。我们可以使用JavaScript在canvas元素上绘制图形。Canvas有几种绘图方法，如路径、形状、文本和图像。此外，在canvas中渲染图形比使用DOM元素更快。Canvas的另一个优势是我们可以将画布内容转换为图像。在现实世界的应用程序中，当你有服务器端API时，你可以使用服务器来渲染表情包的图像和文本。但是，由于本章节中我们不打算使用服务器端，canvas是我们最好的选择。
- en: 'Visit the **Mozilla Developer Network** (**MDN**) page: [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial)
    for more information regarding the canvas element.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 访问**Mozilla开发者网络**（**MDN**）页面：[https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial)
    以获取有关canvas元素的更多信息。
- en: 'Here is the strategy for the Meme Creator:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是表情包创建器的策略：
- en: The canvas element just renders the graphics to its bitmap when instructed.
    We cannot detect any graphics that were previously drawn on it. This leaves us
    no option but to clear the canvas every time a new text or image is entered into
    the Meme Creator and render the whole canvas again.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布元素只在被指示时将图形渲染到其位图上。我们无法检测到先前在其上绘制的任何图形。这使我们别无选择，只能在每次输入新文本或图像到表情包创建器时清除画布，并再次渲染整个画布。
- en: We need event listeners to add text to the meme whenever the user is typing
    in the Top Text or Bottom Text input boxes.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要事件监听器在用户在顶部文本框或底部文本框中输入文本时向表情包添加文本。
- en: Bottom Text is a compulsory field. The user cannot download the meme unless
    it is filled.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部文本是一个必填字段。用户只有在填写了底部文本后才能下载表情包。
- en: The user can select images of any size. If he selects a huge image, it shouldn't
    break our page layout.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择任意大小的图像。如果他选择了一个巨大的图像，它不应该破坏我们的页面布局。
- en: The Download Button should work like a download button!
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载按钮应该像一个下载按钮一样工作！
- en: Event handling
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: 'We now have an idea for building the Meme Creator. Our first step is to create
    a function that renders the meme to the canvas. Inside the `Memes` class, create
    a function `createMeme()` that is going to contain our primary canvas renderer.
    For now, leave the function with a simple console statement:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个构建表情包创建器的想法。我们的第一步是创建一个将表情包渲染到画布上的函数。在`Memes`类中，创建一个名为`createMeme()`的函数，它将包含我们的主要画布渲染器。现在，让函数保持一个简单的控制台语句：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Remember, we need to render the entire canvas every time a change happens. So,
    we need to attach event listeners to all the input elements. You can also use
    HTML event attributes such as `onchange` we used in the previous ToDo List app.
    But event listeners let us handle more than one event for an element. Hence, they
    are widely preferred. Also, since we are using Webpack to bundle the code, we
    cannot access the JavaScript variables or objects inside our HTML directly! This
    requires a little Webpack configuration change and it might not be needed at all.
    We will discuss this topic in detail in the next chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次发生变化时我们需要渲染整个画布。因此，我们需要为所有输入元素附加事件监听器。你也可以使用HTML事件属性，比如我们在之前的ToDo List应用程序中使用的`onchange`。但是事件监听器让我们可以处理一个元素的多个事件。因此，它们被广泛地使用。此外，由于我们使用Webpack来捆绑代码，我们无法直接在HTML中访问JavaScript变量或对象！这需要一些Webpack配置更改，而且可能根本不需要。我们将在下一章节中详细讨论这个话题。
- en: 'First, we need to call `createMeme` whenever a text is entered into the `TopTextInput` and
    `BottomTextInput` areas. So, we need to attach an event listener that listens
    to the `keyup` event on these input boxes. Create the event listener function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`TopTextInput`和`BottomTextInput`区域输入文本时调用`createMeme`。因此，我们需要在这些输入框上附加一个监听`keyup`事件的事件监听器。创建事件监听器函数：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open Chrome and try typing in the text boxes while keeping the console open.
    You should see rendered being printed in the console every time you type a word.
    There is actually a better way to attach event listeners if you want to attach
    the same event listener to multiple elements. Simply use the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Chrome并尝试在保持控制台打开的情况下在文本框中输入。每次输入一个单词时，你应该在控制台中看到`rendered`被打印出来。实际上，如果你想将相同的事件监听器附加到多个元素，有一个更好的方法来附加事件监听器。只需使用以下方法：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This code does the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下几件事：
- en: It creates an array of reference objects to all the target input elements (`inputNodes`)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个对所有目标输入元素（`inputNodes`）的引用对象数组
- en: Use the `forEach()` method to loop through each element in the array and attach
    an event listener to it
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`forEach()`方法循环遍历数组中的每个元素，并为其附加一个事件监听器
- en: By using the ES6 fat arrows, we achieved it in a single line without having
    to worry about binding the `this` object to the callback function
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用ES6的箭头函数，我们在一行代码中实现了它，而不必担心将`this`对象绑定到回调函数。
- en: 'We have also added `$imageInput` in `inputNodes`. This element is not going
    to be affected much with the `keyup` event, but we need this to be monitored when
    a user uploads a new image. Also, if the user copies and pastes text into the
    text inputs without pressing any keyboard buttons, we need to handle the change.
    Both of these scenarios can be handled using the `change` event. Add the following
    line to the `addEventListeners()` function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`inputNodes`中添加了`$imageInput`。这个元素不会受到`keyup`事件的影响，但是当用户上传新图片时，我们需要监控它。此外，如果用户在不按键盘按钮的情况下复制和粘贴文本到文本输入框中，我们需要处理这种变化。这两种情况都可以使用`change`事件来处理。在`addEventListeners()`函数中添加以下行：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Whenever the user types in some text or uploads a new image, the `this.createMeme()`
    method will be automatically called.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户输入一些文本或上传新图像时，`this.createMeme()`方法将自动调用。
- en: Rendering an image in the canvas
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中渲染图像
- en: 'The first step to render something to the canvas is to use the `CanvasRenderingContext2D`
    interface to get the 2D rendering context for the target `<canvas>` element. Inside
    our `createMeme()` function, create a context to the canvas element:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 向画布渲染一些东西的第一步是使用`CanvasRenderingContext2D`接口获取目标`<canvas>`元素的2D渲染上下文。在我们的`createMeme()`函数内部，为画布元素创建一个上下文：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `context` variable will now hold the object of the `CanvasRenderingContext2D`
    interface. To make rendering a little more efficient, we''ll add a condition to
    render only when a user has selected an image. We can do this by checking whether
    the reference to the image input has any files in it. We should start the rendering
    process only when there is a file selected in the input. To do so, check whether
    the input element contains any file objects:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`变量现在将保存`CanvasRenderingContext2D`接口的对象。为了使渲染更加高效，我们将添加一个条件，仅在用户选择了图像时才进行渲染。我们可以通过检查图像输入的引用是否包含任何文件来实现这一点。只有在输入中选择了文件时，我们才应该开始渲染过程。为此，检查输入元素是否包含任何文件对象：'
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, try typing some text into the input field. You should get an error in
    the console saying: Cannot read property ''getContext'' of undefined.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在输入字段中输入一些文本。您应该在控制台中收到一个错误，说：无法读取未定义的属性'getContext'。
- en: '![](../images/00015.jpeg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: 'At this moment, you should be asking the following questions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该问以下问题：
- en: Didn't we define `this.$canvas` to hold reference to our canvas element in our
    constructor?
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是在构造函数中定义`this.$canvas`来保存对画布元素的引用吗？
- en: We are getting the context object from our canvas reference `this.$canvas`.
    But how could `this.$canvas` be undefined?
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从画布引用`this.$canvas`获取上下文对象。但是`this.$canvas`怎么会是未定义的呢？
- en: Aren't we doing everything right?
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们难道没有做对吗？
- en: 'To find the answers, we need to use the Chrome DevTools to figure out what
    went wrong in our code. Add the `debugger;` keyword right before the line causing
    the error (the line we define our context variable). Now, reload Chrome and start
    typing. Chrome''s debugger will have now paused the page execution and the sources
    tab will highlight the line in which the Chrome debugger has paused the execution:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到答案，我们需要使用Chrome DevTools来找出代码中出了什么问题。在引起错误的行之前（我们定义上下文变量的行）添加`debugger;`关键字。现在，重新加载Chrome并开始输入。Chrome的调试器现在已经暂停了页面执行，并且源选项卡将突出显示Chrome调试器暂停执行的行：
- en: '![](../images/00016.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: 'The execution of the code is now paused. This means all the variables will
    now contain their values during execution. Hover your cursor over the `this` keyword
    in the line next to `debugger;`. Surprisingly, placing the cursor over this object
    will highlight the top Input text field in your website! Also, the information
    popup will also show this object containing reference to `input#topText.form-control`.
    Here is the problem: the `this` object no longer has reference to the class but
    has reference to a DOM element. We defined the `$canvas` variable inside the class;
    hence, `this.$canvas` is now undefined. We faced a similar problem with binding
    the `this` object in the previous project. Can you guess where we went wrong?'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码的执行已经暂停。这意味着在执行期间，所有变量现在都将包含它们的值。将光标悬停在`debugger;`旁边的行上的`this`关键字上。令人惊讶的是，将光标放在此对象上将突出显示您网站中顶部输入文本字段！此外，信息弹出窗口还将显示包含对`input#topText.form-control`的引用的此对象。问题在这里：`this`对象不再具有对类的引用，而是具有对DOM元素的引用。我们在类内部定义了`$canvas`变量；因此，`this.$canvas`现在未定义。我们在上一个项目中遇到了类似的绑定`this`对象的问题。您能猜到我们哪里出错了吗？
- en: 'It''s the line where we attached event listeners to our input elements in our
    `addEventListeners()` function. Since we are using ES6 fat arrows here, you might
    be wondering why `this` didn''t automatically inherit its value from the parent.
    It''s because, this time, we are sending `this.createMeme` as a parameter to the
    `addEventListener()` method of the target element. Hence, that input element becomes
    the new parent for inheriting the `this` object. To overcome this problem, change
    `this.createMeme` to `this.createMeme.bind(this)`, or for a cleaner syntax, add
    the following code as the first line of our `addEventListeners()` function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`addEventListeners()`函数中附加事件侦听器到输入元素的行。由于我们在这里使用了ES6的箭头函数，您可能会想知道为什么`this`没有自动从父级继承其值。这是因为，这一次，我们将`this.createMeme`作为参数发送到目标元素的`addEventListener()`方法。因此，该输入元素成为继承`this`对象的新父级。为了解决这个问题，在`addEventListeners()`函数的第一行添加以下代码：
- en: '[PRE70]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, `this.createMeme` can be used normally anywhere inside our `addEventListeners()`
    function. Try typing some text into the input boxes. This time, there shouldn't
    be any errors. Now, select an image from the source image input. Try typing some
    text. This time, you should see *rendering* text printed in the console. We are
    going to write the rendering code inside this `if` condition so that the meme
    renders only when an image is selected.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`this.createMeme`可以在`addEventListeners()`函数的任何地方正常使用。尝试在输入框中输入一些文本。这次不应该有任何错误。现在，从源图像输入中选择一个图像。尝试输入一些文本。这次，您应该在控制台中看到*rendering*文本。我们将在此`if`条件中编写渲染代码，以便当选择图像时才渲染表情。
- en: 'One more thing! If you click the image input, it shows all the files in the
    disk. We only need the user to select the image files. In this case, add the `accept`
    attribute to the input element in `index.html` with the extensions that are allowed
    for the user to select. The new input element should be the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事！如果您点击图像输入，它会显示磁盘中的所有文件。我们只需要用户选择图像文件。在这种情况下，在`index.html`中的输入元素中添加`accept`属性，以允许用户选择的扩展名。新的输入元素应该是以下内容：
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Reading a file using JavaScript
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript读取文件
- en: To read the selected image, we are going to use `FileReader`, which allows JavaScript
    to *asynchronously* read the contents of a file (either from a file or raw data).
    Note the term asynchronously; it means JavaScript will not wait for the `FileReader`
    code to complete execution. JavaScript will start the execution of the next line
    while `FileReader` is still reading the file. This is because JavaScript is a
    single-threaded language. It means all the operations, event listeners, functions,
    and so on, are executing in a single thread. If JS has to wait for the completion
    of `FileReader`, then the entire JavaScript code will be paused (just like how
    debugger pauses the execution of the script), since everything is running in a
    single thread.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取所选的图像，我们将使用`FileReader`，它允许JavaScript*异步*读取文件的内容（无论是来自文件还是原始数据）。请注意术语异步；这意味着JavaScript不会等待`FileReader`代码完成执行。JavaScript将在`FileReader`仍在读取文件时开始执行下一行。这是因为JavaScript是单线程语言。这意味着所有操作、事件监听器、函数等都在单个线程中执行。如果JS必须等待`FileReader`的完成，那么整个JavaScript代码将被暂停（就像调试器暂停脚本的执行一样），因为一切都在单个线程中运行。
- en: To avoid this from happening, JavaScript does not simply wait for the event
    to complete, but runs the event simultaneously while executing the next lines
    of code. There are different ways in which we can handle asynchronous events.
    Generally, an asynchronous event is given a callback function (some lines of code
    that needs to be executed after the event is completed) or the asynchronous code
    will fire an event when the execution is complete and we can write a function
    to execute when that event is triggered. ES6 has a new way of dealing with asynchronous
    events, called Promises.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况发生，JavaScript不仅仅等待事件完成，而是在执行下一行代码的同时运行事件。我们可以处理异步事件的不同方式。通常，异步事件会给定一个回调函数（需要在事件完成后执行的一些代码行）或者异步代码在执行完成时会触发一个事件，我们可以编写一个函数在触发该事件时执行。ES6有一种新的处理异步事件的方式，称为Promises。
- en: 'We will see more about using Promises in the next chapter. `FileReader` will
    fire a `load` event when it''s finished reading the file. `FileReader` also comes
    with the `onload` event handler to handle the `load` event. Inside the `if` statement,
    create a new `FileReader` object and assign it to variable reader using the `FileReader()`
    constructor. Here''s how we are going to handle the asynchronous `FileReader`
    logic: write the following code inside the `if` statement (remove the previous
    `console.log` statement):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中了解更多关于使用Promises的内容。`FileReader`在完成读取文件时会触发`load`事件。`FileReader`还带有`onload`事件处理程序来处理`load`事件。在`if`语句内部，创建一个新的`FileReader`对象，并使用`FileReader()`构造函数将其分配给变量reader。这就是我们将如何处理异步`FileReader`逻辑的方式：将以下代码写入`if`语句中（删除之前的`console.log`语句）：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, try selecting an image in Chrome. You should see two statements printed
    in the console. This is what we have done in the previous code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome中尝试选择一张图片。你应该在控制台中看到两个语句打印出来。这是我们在之前的代码中所做的事情：
- en: We created a new instance of `FileReader` in the reader variable
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在reader变量中创建了一个`FileReader`的新实例。
- en: We then specified what the reader should do in the `onload` event handler
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在`onload`事件处理程序中指定了读取器应该做什么
- en: Then, we passed the file object of the selected image to the reader object
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将所选图像的文件对象传递给了读取器对象
- en: As you might have guessed, JavaScript will execute `reader.readAsDataURL` first
    and find that it is an asynchronous event. So, while the `FileReader` is running,
    it will execute the next `console.log()` statement.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，JavaScript将首先执行`reader.readAsDataURL`，并发现它是一个异步事件。因此，在`FileReader`运行时，它将执行下一个`console.log()`语句。
- en: Once the `FileReader` has completed reading the file, it will fire the `load`
    event, which will call the corresponding `reader.onload` event handler. Now, the
    `console.log()` statement inside the `reader.onload` method will be executed.
    `reader.result` will now contain the image data.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`FileReader`完成读取文件，它将触发`load`事件，这将调用相应的`reader.onload`事件处理程序。现在，`reader.onload`方法内的`console.log()`语句将被执行。`reader.result`现在将包含图像数据。
- en: 'We need to create an `Image` object using the result from `FileReader`. Create
    a new instance of the image using the `Image()` constructor (we should now write
    the code inside the `reader.onload` method):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`FileReader`的结果创建一个`Image`对象。使用`Image()`构造函数创建一个新的图像实例（现在我们应该在`reader.onload`方法内编写代码）：
- en: '[PRE73]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, dynamically loading an image source is also an asynchronous
    event and we need to use the `onload` event handler provided by the `Image` object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，动态加载图像源也是一个异步事件，我们需要使用`Image`对象提供的`onload`事件处理程序。
- en: 'Once we have the image loaded, we need to resize the canvas to the image''s
    size. To do that, write the following code inside the `image.onload` method:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像加载完成，我们需要将画布调整为图像的大小。为此，请在`image.onload`方法中写入以下代码：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will now resize the canvas to the size of the image. Once we have the
    canvas resized, our first step is to erase the canvas. The canvas object has the
    `clearRect()` method, which can be used to clear a rectangular area in the canvas.
    In our case, the rectangular area is the entire canvas. To clear the entire canvas,
    we need to use `clearRect()` with our canvas''s context object, which is the `context`
    variable we created earlier. After that, we need to load the image into the canvas.
    Write the following code inside the `image.onload` method right after assigning
    the canvas dimensions:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将画布调整为图像的大小。一旦我们调整了画布的大小，我们的第一步是擦除画布。画布对象有`clearRect()`方法，可以用来清除画布中的矩形区域。在我们的情况下，矩形区域是整个画布。要清除整个画布，我们需要使用`clearRect()`和我们画布的上下文对象，也就是我们之前创建的`context`变量。之后，我们需要将图像加载到画布中。在分配了画布尺寸后，将以下代码写入`image.onload`方法中：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, try selecting an image. The image should be displayed in the canvas. This
    is what the previous code does:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试选择一张图片。图片应该显示在画布上。这是之前的代码所做的事情：
- en: Clear a rectangular area in the canvas starting from the top-left coordinates
    `(0,0)`, that is, the *first two parameters* of the `clearRect()` method and then
    create a rectangle with its height and width equal to that of the canvas, that
    is, the last two parameters of the `clearRect()` method. This effectively clears
    the entire canvas.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除从左上坐标`(0,0)`开始的画布上的矩形区域，即`clearRect()`方法的*前两个参数*，然后创建一个高度和宽度等于画布的矩形，即`clearRect()`方法的*最后两个参数*。这将有效地清除整个画布。
- en: Draw an image onto the canvas using the image stored in the `image` object starting
    from the coordinates `(0,0)`. Since the canvas has the same dimensions as the
    image, the image will cover the entire canvas.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储在`image`对象中的图像在画布上绘制图像，从坐标`(0,0)`开始。由于画布的尺寸与图像相同，图像将覆盖整个画布。
- en: Rendering text on the canvas
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上呈现文本
- en: 'We have an image now, but we are still missing the top text and bottom text.
    Here are a few things we need as the text property:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一张图片，但是我们还缺少顶部文本和底部文本。以下是我们作为文本属性需要的一些东西：
- en: The font size should be responsive to the size of the image
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小应该根据图像的大小进行响应
- en: The text should be center-aligned
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本应该是居中对齐的
- en: The text should have margin space at the top and bottom of the image
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本应该在图像的顶部和底部有边距空间
- en: The text should have a black stroke so that it can be seen clearly over the
    image
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本应该有黑色描边，以便清晰地显示在图像上
- en: For our first step, we need the font size to be responsive. If the user selects
    either a large image or a small one, we need to have a relative font size. Since
    we have the canvas height and width, we can use that to get a font size that is
    `4`% of the average of the image height and width. We can center align the text
    using the `textAlign` property.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一步，我们需要字体大小是响应式的。如果用户选择了大图像或小图像，我们需要有一个相对的字体大小。由于我们有画布的高度和宽度，我们可以使用它来获得一个字体大小，即图像高度和宽度的平均值的`4`%。我们可以使用`textAlign`属性使文本居中对齐。
- en: 'Also, we need to specify a baseline using the `textBaseline` property. It is
    used to position the text at the specified location. First, the canvas creates
    a baseline at the location we specify for the text. Then, it will write the text
    above, below, or over the baseline based on the value supplied to `textBaseline`.
    Write the following code inside the `image.onload` method:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要使用`textBaseline`属性指定基线。它用于将文本定位到指定位置。首先，画布在我们为文本指定的位置创建一个基线。然后，根据`textBaseline`提供的值，它将在基线的上方、下方或上方写入文本。在`image.onload`方法中写入以下代码：
- en: '[PRE76]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We have specified the font to be `4`% of the average of the canvas height and
    width and set the font style to `sans-serif`. Also, by setting `textBaseline`
    to `top`, the baseline will be on top of the text, that is, the text will be rendered
    below the baseline.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了字体为画布高度和宽度的平均值的`4`%，并将字体样式设置为`sans-serif`。此外，通过将`textBaseline`设置为`top`，基线将位于文本顶部，也就是说，文本将在基线下方呈现。
- en: Canvas does not have an option to apply stroke to the text. Hence, to create
    a white text with black stroke, we need to create two different texts, a black
    stroke text and a white fill text, with the line width of the stroke text being
    slightly bigger than the fill text, and place them one over another. This might
    sound like a complex task to do, but it's actually simple.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 画布没有选项来对文本应用描边。因此，为了创建带有黑色描边的白色文本，我们需要创建两种不同的文本，一个是黑色描边文本，一个是白色填充文本，描边文本的线宽略大于填充文本，并将它们放在一起。这听起来可能是一个复杂的任务，但实际上很简单。
- en: 'This is how a stroke text looks:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是描边文本的样子：
- en: '![](../images/00017.gif)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.gif)'
- en: 'This is how a fill text looks (in a gray background):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是填充文本的样子（在灰色背景下）：
- en: '![](../images/00018.gif)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.gif)'
- en: 'Create styles for the stroke text and fill text:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为描边文本和填充文本创建样式：
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Get the value for the top text and bottom text from the input fields:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入字段获取顶部文本和底部文本的值：
- en: '[PRE78]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will get the value from the input fields and automatically convert the
    text to uppercase letters. Finally, to render the text at the top and bottom of
    the canvas, we need to do the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从输入字段获取值，并自动将文本转换为大写字母。最后，要在画布的顶部和底部呈现文本，我们需要做以下操作：
- en: '[PRE79]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Consider `context.strokeText()`. This is how the text gets rendered:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`context.strokeText()`。这就是文本的呈现方式：
- en: The first parameter of the `strokeText` method, `topText` contains the text
    to be rendered.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strokeText`方法的第一个参数`topText`包含要呈现的文本。'
- en: The second and third parameters contain the location where the text should start
    rendering. Along the *x *axis, the text should start rendering from the middle
    of the canvas (`this.$canvas.width/2`). The text will be center aligned and along
    the *y* axis from a height that is `5`% from the top of the canvas (`this.$canvas.height*(5/100)`).
    The text will be rendered.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个和第三个参数包含文本应该开始呈现的位置。沿着*x*轴，文本应该从画布的中间开始呈现（`this.$canvas.width/2`）。文本将居中对齐，沿着*y*轴从距离画布顶部`5`%的高度开始（`this.$canvas.height*(5/100)`）。文本将被呈现。
- en: 'This is exactly where we need the top text of the meme. For the bottom text,
    increase the height to `90`% from the top. The stroke text with black stroke will
    be below the fill text. Sometimes, ''M'' will have additional strokes over the
    text. This is because the place where two lines meet is not properly rounded.
    To do so, add the following line after the line specifying `fillStyle`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要Meme的顶部文本的地方。对于底部文本，将高度增加到距离顶部`90`%的高度。带有黑色描边的文本将位于填充文本下方。有时，“M”会在文本上有额外的笔画。这是因为两条线相交的地方没有正确圆角。为此，在指定`fillStyle`之后添加以下行：
- en: '[PRE80]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, quickly switch to Chrome, select an image, and type some text! You have
    your very own Meme Creator! For reference, it should work like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，快速切换到Chrome，选择一张图片，然后输入一些文本！你就有了自己的Meme创作者！作为参考，它应该像这样工作：
- en: '![](../images/00019.jpeg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: 'Now, to download the meme, we need to convert the canvas into an image and
    attach the image as the attribute to the download button. Create a new function
    `downloadMeme()` inside the `Memes` class. In the `addEventListeners()` function,
    add the following line:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要下载meme，我们需要将画布转换为图像，并将图像作为属性附加到下载按钮。在`Memes`类中创建一个新的函数`downloadMeme()`。在`addEventListeners()`函数中，添加以下行：
- en: '[PRE81]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, inside the `downloadMeme()` function, add the following code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`downloadMeme()`函数中，添加以下代码：
- en: '[PRE82]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, clicking the download button will convert the canvas into an image and
    let the browser download it. This is how the previous code works:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单击下载按钮将会将画布转换为图像，并让浏览器下载它。这就是先前的代码的工作原理：
- en: First, the canvas is converted into a 64-bit encoded png URL using the `toDataURL('image/png')`
    method and is stored in the `imageSource` constant.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用`toDataURL('image/png')`方法将画布转换为64位编码的png URL，并存储在`imageSource`常量中。
- en: Create another constant `att` that contains an HTML `'href'` attribute object.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建另一个包含HTML `'href'`属性对象的常量`att`。
- en: Now, change the value of the `att` object to the image URL stored in `imageSource`
    while changing the mime type from `data:image` to `data:application/octet-stream`.
    This step is necessary because most browsers display images directly instead of
    downloading them. By changing the mime type to `octet-stream` (used for binary
    files), we can trick the browser into thinking the file is not an image and, hence,
    download the file instead of viewing it.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，将`att`对象的值更改为存储在`imageSource`中的图像URL，同时将mime类型从`data:image`更改为`data:application/octet-stream`。这一步是必要的，因为大多数浏览器会直接显示图像而不是下载它们。通过将mime类型更改为`octet-stream`（用于二进制文件），我们可以欺骗浏览器，使其认为文件不是图像，因此下载文件而不是查看文件。
- en: Finally, assign the `att` object as an attribute of `$downloadButton`, which
    is an anchor tag with the `download` attribute. The value of the `download` attribute
    will be the default name of the downloaded image.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将`att`对象分配为`$downloadButton`的属性，它是一个带有`download`属性的锚标签。`download`属性的值将是下载图像的默认名称。
- en: 'In the `imageSource.replace()` method, a regular expression is used for changing
    the mime type of the image. We will discuss more on using regular expressions
    in the next chapter. To know more about regular expressions, visit the following
    MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`imageSource.replace()`方法中，使用正则表达式来更改图像的mime类型。我们将在下一章中更多地讨论使用正则表达式。要了解更多关于正则表达式的信息，请访问以下MDN页面：[https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions)。
- en: 'Before downloading the meme from the Meme Creator, we need to validate the
    form so that there must be an image selected and, at least, the bottom text box
    is filled in order to download the meme. We need to add the form validation code
    in the `downloadMeme()` function above the code to download the file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在从Meme Creator下载meme之前，我们需要验证表单，以便必须选择图像，并且至少底部文本框已填写才能下载meme。我们需要在上面的代码中添加`downloadMeme()`函数中的表单验证代码：
- en: '[PRE83]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The previous code will check for an image and text in the bottom text input
    box and stop `downloadMeme()` from continuing execution using the `return` keyword.
    Once an empty field has been found, it will add the `.has-error` class to the
    input's parent `div`, which, according to Bootstrap, highlights the input in a
    red border (we used it previously in the ToDo list app).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码将检查底部文本输入框中的图像和文本，并使用`return`关键字停止`downloadMeme()`的执行。一旦发现空字段，它将向输入的父`div`添加`.has-error`类，根据Bootstrap的定义，这将突出显示红色边框的输入（我们之前在ToDo列表应用程序中使用过它）。
- en: 'You might not get the highlight, because we are using `PurifyCSSPlugin` with
    Webpack, which filters out all the unwanted styles by referring `index.html`.
    Since the `.has-error` class is not present in `index.html` initially, its style
    definition is also removed from the bundled CSS. To overcome this problem, add
    all the classes you would like to add dynamically to a hidden `div` element in
    the page. Add the following line to our `index.html` file just above the `<script>`
    tag:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能无法获得突出显示，因为我们正在使用`PurifyCSSPlugin`与Webpack，它通过引用`index.html`过滤掉所有不需要的样式。由于`.has-error`类最初不在`index.html`中，因此其样式定义也从捆绑的CSS中删除。为了解决这个问题，将您想要动态添加的所有类添加到页面中的隐藏`div`元素中。在我们的`index.html`文件中，在`<script>`标签的上面添加以下行：
- en: '[PRE84]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, the style definitions for `.has-error` will be included in the bundle and
    form validation will add a red border to the empty fields.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`.has-error`的样式定义将包含在bundle中，并且表单验证将向空字段添加红色边框。
- en: Making a canvas responsive to show large images
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使画布响应以显示大图像
- en: 'If the user selects a large image (for example, an image the size of the screen),
    it will cause the layout to break. To prevent this from happening, we need to
    zoom out our canvas when large images are selected. We can zoom in or zoom out
    our canvas element by controlling its height and width in CSS. In the `Memes`
    class, create the following function:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择了大图像（例如，屏幕大小的图像），它将导致布局破坏。为了防止这种情况发生，当选择大图像时，我们需要缩小画布。我们可以通过控制CSS中的高度和宽度来放大或缩小画布元素。在`Memes`类中，创建以下函数：
- en: '[PRE85]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is how `resizeCanvas()` works:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`resizeCanvas()`的工作原理：
- en: This function will initially apply the height and width of the canvas in CSS
    to its actual height and width (so that the zoom level of the previous image is
    not remembered).
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数最初将CSS中画布的高度和宽度应用于其实际高度和宽度（以便不记住先前图像的缩放级别）。
- en: Then, it will check whether the height and width are either greater than the
    minimum of 1000px or `deviceWidth-30` (we already defined the `deviceWidth` constant).
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将检查高度和宽度是否大于最小值1000px或`deviceWidth-30`（我们已经定义了`deviceWidth`常量）。
- en: If the canvas size is greater than the given condition, we reduce the height
    and width by half and then assign the new values to the canvas's CSS (this will
    zoom out the canvas).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果画布大小大于给定条件，我们将高度和宽度减半，然后将新值分配给画布的CSS（这将缩小画布）。
- en: Since it is a while loop, the operation is repeated until the canvas size goes
    below the condition, thus, effectively zooming out the canvas and preserving the
    page layout.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是一个while循环，操作会重复进行，直到画布大小小于条件，从而有效地缩小画布并保持页面布局。
- en: Simply call `this.resizeCanvas(this.$canvas.height, this.$canvas.width)` inside
    the `image.onload` method after the code to render text in the canvas.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在`image.onload`方法中，在渲染画布中的文本代码之后，简单地调用`this.resizeCanvas(this.$canvas.height,
    this.$canvas.width)`。
- en: '`height /= 2` is a shorthand used for `height = height / 2`. This is applicable
    for other arithmetic operators, such as `+`, `-`, `*`, and `%`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`height /= 2`是`height = height / 2`的简写。这适用于其他算术运算符，如`+`、`-`、`*`和`%`。'
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Good work! You have built a Meme Creator that will now convert your images
    into memes. More importantly, you have a great development environment that will
    make app development with JavaScript even easier. Let''s review the things you
    have learned in this chapter:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已经建立了一个模因创作者，现在可以将您的图像转换成模因。更重要的是，您拥有一个很棒的开发环境，将使JavaScript应用程序开发变得更加容易。让我们回顾一下您在本章学到的东西：
- en: A short introduction to the flexbox layout system in CSS
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS中flexbox布局系统的简介
- en: An introduction to JavaScript modules
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript模块介绍
- en: Module bundling with Webpack
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack进行模块捆绑
- en: Production optimizations to improve performance for users
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化生产以提高用户性能
- en: Using HTML5 canvas with JavaScript to draw graphics on a website
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5画布和JavaScript在网站上绘制图形
- en: We learned quite a lot in this chapter. Especially about Webpack. It might seem
    a little overwhelming, but it is very useful in the long run. In the next chapter,
    we are going to see how to write modular code and reuse it across the application,
    which is now possible due to Webpack.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章学到了很多东西。特别是关于Webpack。这可能看起来有点令人不知所措，但从长远来看非常有用。在下一章中，我们将看到如何编写模块化的代码并在整个应用程序中重用它，这现在由于Webpack是可能的。
