- en: Chapter 2. Basic Thread Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。基本线程同步
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Synchronizing a method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步一个方法
- en: Arranging independent attributes in synchronized classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同步类中排列独立属性
- en: Using conditions in synchronized code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同步代码中使用条件
- en: Synchronizing a block of code with a Lock
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁同步代码块
- en: Synchronizing data access with read/write locks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读/写锁同步数据访问
- en: Modifying Lock fairness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改锁的公平性
- en: Using multiple conditions in a Lock
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锁中使用多个条件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the most common situations in concurrent programming occurs when more
    than one execution thread shares a resource. In a concurrent application, it is
    normal that multiple threads read or write the same data or have access to the
    same file or database connection. These shared resources can provoke error situations
    or data inconsistency and we have to implement mechanisms to avoid these errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中最常见的情况之一是多个执行线程共享资源。在并发应用程序中，多个线程读取或写入相同的数据，或者访问相同的文件或数据库连接是正常的。这些共享资源可能引发错误情况或数据不一致，我们必须实现机制来避免这些错误。
- en: The solution for these problems comes with the concept of **critical section**
    . A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的解决方案是通过**关键部分**的概念得到的。关键部分是指访问共享资源的代码块，不能同时由多个线程执行。
- en: To help programmers to implement critical sections, Java (and almost all programming
    languages) offers **synchronization** mechanisms. When a thread wants access to
    a critical section, it uses one of those synchronization mechanisms to find out
    if there is any other thread executing the critical section. If not, the thread
    enters the critical section. Otherwise, the thread is suspended by the synchronization
    mechanism until the thread that is executing the critical section ends it. When
    more than one thread is waiting for a thread to finish the execution of a critical
    section, the JVM chooses one of them, and the rest wait for their turn.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助程序员实现关键部分，Java（以及几乎所有编程语言）提供了**同步**机制。当一个线程想要访问关键部分时，它使用这些同步机制之一来查找是否有其他线程正在执行关键部分。如果没有，线程就进入关键部分。否则，线程被同步机制挂起，直到正在执行关键部分的线程结束。当多个线程等待一个线程完成关键部分的执行时，JVM会选择其中一个，其余的等待他们的轮到。
- en: 'This chapter presents a number of recipes that teaches how to use the two basic
    synchronization mechanisms offered by the Java language:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些教授如何使用Java语言提供的两种基本同步机制的方法：
- en: The keyword `synchronized`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`synchronized`
- en: The `Lock` interface and its implementations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口及其实现'
- en: Synchronizing a method
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步一个方法
- en: In this recipe, we will learn how to use one of the most basic methods for synchronization
    in Java, that is, the use of the `synchronized` keyword to control the concurrent
    access to a method. Only one execution thread will access one of the methods of
    an object declared with the `synchronized` keyword. If another thread tries to
    access any method declared with the `synchronized` keyword of the same object,
    it will be suspended until the first thread finishes the execution of the method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用Java中最基本的同步方法之一，即使用`Synchronized`关键字来控制对方法的并发访问。只有一个执行线程将访问使用`Synchronized`关键字声明的对象的方法。如果另一个线程尝试访问同一对象的任何使用`Synchronized`关键字声明的方法，它将被挂起，直到第一个线程完成方法的执行。
- en: In other words, every method declared with the `synchronized` keyword is a critical
    section and Java only allows the execution of one of the critical sections of
    an object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用`Synchronized`关键字声明的每个方法都是一个关键部分，Java只允许执行对象的一个关键部分。
- en: Static methods have a different behavior. Only one execution thread will access
    one of the static methods declared with the `synchronized` keyword, but another
    thread can access other non-static methods of an object of that class. You have
    to be very careful with this point, because two threads can access two different
    `synchronized` methods if one is static and the other one is not. If both methods
    change the same data, you can have data inconsistency errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法有不同的行为。只有一个执行线程将访问使用`Synchronized`关键字声明的静态方法之一，但另一个线程可以访问该类对象的其他非静态方法。在这一点上你必须非常小心，因为如果一个是静态的，另一个不是，两个线程可以访问两个不同的`Synchronized`方法。如果这两个方法都改变了相同的数据，就可能出现数据不一致的错误。
- en: To learn this concept, we will implement an example with two threads accessing
    a common object. We will have a bank account and two threads; one that transfers
    money to the account and another one that withdraws money from the account. Without
    synchronization methods, we could have incorrect results. Synchronization mechanisms
    ensures that the final balance of the account will be correct.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习这个概念，我们将实现一个示例，其中有两个线程访问一个共同的对象。我们将有一个银行账户和两个线程；一个向账户转账，另一个从账户取款。没有同步方法，我们可能会得到不正确的结果。同步机制确保账户的最终余额是正确的。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经在Eclipse IDE中实现。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `Account` that will model our bank account. It has only
    one `double` attribute, named `balance`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Account`的类来模拟我们的银行账户。它只有一个名为`balance`的`double`属性。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implement the `setBalance()` and `getBalance()` methods to write and read the
    value of the attribute.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setBalance()`和`getBalance()`方法来写入和读取属性的值。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement a method called `addAmount()` that increments the value of the balance
    in a certain amount that is passed to the method. Only one thread should change
    the value of the balance, so use the `synchronized` keyword to convert this method
    into a critical section.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`addAmount()`的方法，该方法增加传递给方法的特定金额的余额值。只有一个线程应该更改余额的值，因此使用`synchronized`关键字将此方法转换为临界区。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement a method called `subtractAmount()`that decrements the value of the
    balance in a certain amount that is passed to the method. Only one thread should
    change the value of the balance, so use the `synchronized` keyword to convert
    this method into a critical section.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`subtractAmount()`的方法，该方法减少传递给方法的特定金额的余额值。只有一个线程应该更改余额的值，因此使用`synchronized`关键字将此方法转换为临界区。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Implement a class that simulates an ATM. It will use the `subtractAmount()`
    method to decrement the balance of an account. This class must implement the `Runnable`
    interface to be executed as a thread.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个模拟ATM的类。它将使用`subtractAmount()`方法来减少账户的余额。这个类必须实现`Runnable`接口以作为线程执行。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add an `Account` object to this class. Implement the constructor of the class
    that initializes that `Account` object.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Account`对象添加到这个类中。实现初始化该`Account`对象的类的构造函数。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implement the `run()` method. It makes `100` calls to the `subtractAmount()`
    method of an account to reduce the balance.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它对一个账户进行`100`次`subtractAmount()`方法的调用以减少余额。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implement a class that simulates a company and uses the `addAmount()` method
    of the `Account` class to increment the balance of the account. This class must
    implement the `Runnable` interface to be executed as a thread.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个模拟公司的类，并使用`Account`类的`addAmount()`方法来增加账户的余额。这个类必须实现`Runnable`接口以作为线程执行。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add an `Account` object to this class. Implement the constructor of the class
    that initializes that account object.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Account`对象添加到这个类中。实现初始化该账户对象的类的构造函数。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implement the `run()` method . It makes `100` calls to the `addAmount()` method
    of an account to increment the balance.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它对一个账户进行`100`次`addAmount()`方法的调用以增加余额。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the main class of the application by creating a class named `Main`
    that contains the `main()` method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含`main()`方法来实现应用程序的主类。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create an `Account` object and initialize its balance to `1000`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Account`对象并将其余额初始化为`1000`。
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a `Company` object and `Thread` to run it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Company`对象和一个`Thread`来运行它。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a `Bank` object and `Thread` to run it.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Bank`对象和一个`Thread`来运行它。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Write the initial balance to the console.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将初始余额写入控制台。
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait for the finalization of the two threads using the `join()` method and print
    in the console the final balance of the account.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待两个线程的完成，并在控制台中打印出账户的最终余额。
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you have developed an application that increments and decrements
    the balance of a class that simulates a bank account. The program makes `100`
    calls to the `addAmount()` method that increments the balance by `1000` in each
    call and `100` calls to the `subtractAmount()` method that decrements the balance
    by `1000` in each call. You should expect the final and initial balances to be
    equal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您已经开发了一个应用程序，该应用程序增加和减少了模拟银行账户余额的类的余额。该程序对`addAmount()`方法进行了`100`次调用，每次调用都会将余额增加`1000`，并对`subtractAmount()`方法进行了`100`次调用，每次调用都会将余额减少`1000`。您应该期望最终余额和初始余额相等。
- en: You have tried to force an error situation using a variable named `tmp` to store
    the value of the account's balance, so you read the account's balance, you increment
    the value of the temporal variable, and then you establish the value of the account's
    balance again. Additionally, you have introduced a little delay using the `sleep()`
    method of the `Thread` class to put the thread that is executing the method to
    sleep for 10 milliseconds, so if another thread executes that method, it can modify
    the account's balance provoking an error. It's the `synchronized` keyword mechanism
    that avoids those errors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经尝试使用一个名为`tmp`的变量来存储账户余额的值，因此您读取了账户余额，增加了临时变量的值，然后再次设置了账户余额的值。此外，您还使用了`Thread`类的`sleep()`方法引入了一点延迟，以便执行该方法的线程休眠10毫秒，因此如果另一个线程执行该方法，它可能会修改账户余额，从而引发错误。正是`synchronized`关键字机制避免了这些错误。
- en: If you want to see the problems of concurrent access to shared data, delete
    the `synchronized` keyword of the `addAmount()` and `subtractAmount()` methods
    and run the program. Without the `synchronized` keyword, while a thread is sleeping
    after reading the value of the account's balance, another method will read the
    account's balance, so both the methods will modify the same balance and one of
    the operations won't be reflected in the final result.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到共享数据并发访问的问题，请删除`addAmount()`和`subtractAmount()`方法的`synchronized`关键字并运行程序。没有`synchronized`关键字，当一个线程在读取账户余额的值后休眠时，另一个方法将读取账户余额，因此两个方法都将修改相同的余额，其中一个操作不会反映在最终结果中。
- en: 'As you can see in the following screenshot, you can obtain inconsistent results:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下面的屏幕截图中所看到的，您可能会得到不一致的结果：
- en: '![How it works...](img/7881_02_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_01.jpg)'
- en: If you run the program often, you will obtain different results. The order of
    execution of the threads is not guaranteed by the JVM. So every time you execute
    them, the threads will read and modify the account's balance in a different order,
    so the final result will be different.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常运行程序，您将获得不同的结果。线程的执行顺序不受JVM保证。因此，每次执行它们时，线程都将以不同的顺序读取和修改账户的余额，因此最终结果将不同。
- en: 'Now, add the `synchronize` keyword as you learned before and run the program
    again. As you can see in the following screenshot, now you obtain the expected
    result. If you run the program often, you will obtain the same result. Refer to
    the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照之前学到的方法添加`synchronize`关键字，并再次运行程序。如下截图所示，现在您可以获得预期的结果。如果经常运行程序，您将获得相同的结果。请参考以下截图：
- en: '![How it works...](img/7881_02_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_02_02.jpg)'
- en: Using the `synchronized` keyword, we guarantee correct access to shared data
    in concurrent applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`synchronized`关键字，我们可以保证并发应用程序中对共享数据的正确访问。
- en: As we mentioned in the introduction of this recipe, only a thread can access
    the methods of an object that use the `synchronized` keyword in their declaration.
    If a thread (A) is executing a `synchronized` method and another thread (B) wants
    to execute other `synchronized` methods of the same object, it will be blocked
    until the thread (A) ends. But if threadB has access to different objects of the
    same class, none of them will be blocked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节介绍中提到的，只有一个线程可以访问使用`synchronized`关键字声明的对象的方法。如果一个线程（A）正在执行一个`synchronized`方法，另一个线程（B）想要执行同一对象的其他`synchronized`方法，它将被阻塞，直到线程（A）结束。但是如果threadB可以访问同一类的不同对象，则它们都不会被阻塞。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `synchronized` keyword penalizes the performance of the application, so
    you must only use it on methods that modify shared data in a concurrent environment.
    If you have multiple threads calling a `synchronized` method, only one will execute
    them at a time while the others will be waiting. If the operation doesn't use
    the `synchronized` keyword, all the threads can execute the operation at the same
    time, reducing the total execution time. If you know that a method will not be
    called by more than one thread, don't use the `synchronized` keyword.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字会降低应用程序的性能，因此您只能在并发环境中修改共享数据的方法上使用它。如果有多个线程调用`synchronized`方法，只有一个线程会一次执行它们，而其他线程将等待。如果操作不使用`synchronized`关键字，则所有线程可以同时执行操作，从而减少总执行时间。如果您知道某个方法不会被多个线程调用，请不要使用`synchronized`关键字。'
- en: You can use recursive calls with `synchronized` methods. As the thread has access
    to the `synchronized` methods of an object, you can call other `synchronized`
    methods of that object, including the method that is executing. It won't have
    to get access to the `synchronized` methods again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用带有`synchronized`方法的递归调用。由于线程可以访问对象的`synchronized`方法，因此可以调用该对象的其他`synchronized`方法，包括正在执行的方法。它不必再次访问`synchronized`方法。
- en: We can use the `synchronized` keyword to protect the access to a block of code
    instead of an entire method. We should use the `synchronized` keyword in this
    way to protect the access to the shared data, leaving the rest of operations out
    of this block, obtaining a better performance of the application. The objective
    is to have the critical section (the block of code that can be accessed only by
    one thread at a time) be as short as possible. We have used the `synchronized`
    keyword to protect the access to the instruction that updates the number of persons
    in the building, leaving out the long operations of this block that don't use
    the shared data. When you use the `synchronized` keyword in this way, you must
    pass an object reference as a parameter. Only one thread can access the `synchronized`
    code (blocks or methods) of that object. Normally, we will use the `this` keyword
    to reference the object that is executing the method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`synchronized`关键字来保护对一段代码的访问，而不是整个方法。我们应该以这种方式使用`synchronized`关键字来保护对共享数据的访问，将其余操作排除在此块之外，从而获得更好的应用性能。目标是使关键部分（一次只能由一个线程访问的代码块）尽可能短。我们已经使用`synchronized`关键字来保护对更新建筑物中人数的指令的访问，排除了不使用共享数据的此块的长操作。当您以这种方式使用`synchronized`关键字时，必须将对象引用作为参数传递。只有一个线程可以访问该对象的`synchronized`代码（块或方法）。通常，我们会使用`this`关键字来引用执行方法的对象。
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Arranging independent attributes in synchronized classes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排同步类中的独立属性
- en: When you use the `synchronized` keyword to protect a block of code, you must
    pass an object reference as a parameter. Normally, you will use the `this` keyword
    to reference the object that executes the method, but you can use other object
    references. Normally, these objects will be created exclusively with this purpose.
    For example, if you have two independent attributes in a class shared by multiple
    threads, you must synchronize the access to each variable, but there is no problem
    if there is one thread accessing one of the attributes and another thread accessing
    the other at the same time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`synchronized`关键字来保护一段代码时，您必须将一个对象引用作为参数传递。通常，您会使用`this`关键字来引用执行方法的对象，但您也可以使用其他对象引用。通常，这些对象将专门为此目的创建。例如，如果一个类中有两个独立的属性被多个线程共享，您必须同步对每个变量的访问，但如果一个线程同时访问其中一个属性，另一个线程访问另一个属性，则不会有问题。
- en: In this recipe, you will learn how to resolve this situation's programming with
    an example that simulates a cinema with two screens and two ticket offices. When
    a ticket office sells tickets, they are for one of the two cinemas, but not for
    both, so the numbers of free seats in each cinema are independent attributes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何通过一个示例来解决这种情况的编程，该示例模拟了一个具有两个屏幕和两个售票处的电影院。当售票处出售票时，它们是为两个电影院中的一个而不是两个，因此每个电影院中的空座位数是独立的属性。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `Cinema` and add to it two `long` attributes named `vacanciesCinema1`
    and `vacanciesCinema2`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Cinema`的类，并向其添加两个名为`vacanciesCinema1`和`vacanciesCinema2`的`long`属性。
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Add to the `Cinema` class two additional `Object` attributes named `controlCinema1`
    and `controlCinema2`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cinema`类中添加两个额外的`Object`属性，命名为`controlCinema1`和`controlCinema2`。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implement the constructor of the `Cinema` class that initializes all the attributes
    of the class.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Cinema`类的构造函数，初始化类的所有属性。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement the `sellTickets1()` method that is called when some tickets for the
    first cinema are sold. It uses the `controlCinema1` object to control the access
    to the `synchronized` block of code.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`sellTickets1()`方法，当第一个电影院的一些票被售出时调用。它使用`controlCinema1`对象来控制对`同步`代码块的访问。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implement the `sellTickets2()` method that is called when some tickets for the
    second cinema are sold. It uses the `controlCinema2` object to control the access
    to the `synchronized` block of code.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`sellTickets2()`方法，当第二个电影院的一些票被售出时调用。它使用`controlCinema2`对象来控制对`同步`代码块的访问。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implement the `returnTickets1()` method that is called when some tickets for
    the first cinema are returned. It uses the `controlCinema1` object to control
    the access to the `synchronized` block of code.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`returnTickets1()`方法，当第一个电影院的一些票被退回时调用。它使用`controlCinema1`对象来控制对`同步`代码块的访问。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implement the `returnTickets2()` method that is called when some tickets for
    the second cinema are returned. It uses the `controlCinema2` object to control
    the access to the `synchronized` block of code.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`returnTickets2()`方法，当第二个电影院的一些票被退回时调用。它使用`controlCinema2`对象来控制对`同步`代码块的访问。
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implement another two methods that return the number of vacancies in each cinema.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现另外两个方法，返回每个电影院的空位数。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implement the class `TicketOffice1` and specify that it implements the `Runnable`
    interface.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`TicketOffice1`类，并指定它实现`Runnable`接口。
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Declare a `Cinema` object and implement the constructor of the class that initializes
    that object.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Cinema`对象，并实现该类的构造函数来初始化该对象。
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implement the `run()` method that simulates some operations over the two cinemas.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法，模拟对两个电影院的一些操作。
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Implement the class `TicketOffice2` and specify that it implements the `Runnable`
    interface.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`TicketOffice2`类，并指定它实现`Runnable`接口。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Declare a `Cinema` object and implement the constructor of the class that initializes
    that object.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Cinema`对象，并实现该类的构造函数来初始化该对象。
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implement the `run()` method that simulates some operations over the two cinemas.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法，模拟对两个电影院的一些操作。
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implement the main class of the example by creating a class called `Main` and
    add to it the `main()` method.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Declare and create a `Cinema` object.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建一个`Cinema`对象。
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a `TicketOffice1` object and `Thread` to execute it.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TicketOffice1`对象和`Thread`来执行它。
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create a `TicketOffice2` object and `Thread` to execute it.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TicketOffice2`对象和`Thread`来执行它。
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Start both threads.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个线程。
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Wait for the completion of the threads.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待线程完成。
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Write to the console the vacancies of the two cinemas.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个电影院的空位数写入控制台。
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you use the `synchronized` keyword to protect a block of code, you use
    an object as a parameter. JVM guarantees that only one thread can have access
    to all the blocks of code protected with that object (note that we always talk
    about objects, not about classes).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`同步`关键字保护一段代码时，使用一个对象作为参数。JVM保证只有一个线程可以访问使用该对象保护的所有代码块（请注意，我们总是谈论对象，而不是类）。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we have an object that controls access to the `vacanciesCinema1`
    attribute, so only one thread can modify this attribute each time, and another
    object controls access to the `vacanciesCinema2` attribute, so only one thread
    can modify this attribute each time. But there may be two threads running simultaneously,
    one modifying the `vacancesCinema1` attribute and the other one modifying the
    `vacanciesCinema2` attribute.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个对象来控制对`vacanciesCinema1`属性的访问，因此每次只有一个线程可以修改这个属性，另一个对象控制对`vacanciesCinema2`属性的访问，因此每次只有一个线程可以修改这个属性。但可能会有两个线程同时运行，一个修改`vacancesCinema1`属性，另一个修改`vacanciesCinema2`属性。
- en: 'When you run this example, you can see how the final result is always the expected
    number of vacancies for each cinema. In the following screenshot, you can see
    the results of an execution of the application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，您可以看到最终结果始终是每个电影院预期的空位数。在下面的屏幕截图中，您可以看到应用程序执行的结果：
- en: '![How it works...](img/7881_02_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_03.jpg)'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are other important uses of the `synchronize` keyword. See the *See also*
    section for other recipes that explain the use of this keyword.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`同步`关键字还有其他重要的用途。请参阅*另请参阅*部分，了解其他解释此关键字用法的示例。'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using conditions in synchronized code* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 基本线程同步")的*基本线程同步*中的*在同步代码中使用条件*示例中
- en: Using conditions in synchronized code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同步代码中使用条件
- en: A classic problem in concurrent programming is the **producer-consumer** problem.
    We have a data buffer, one or more producers of data that save it in the buffer
    and one or more consumers of data that take it from the buffer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中的一个经典问题是**生产者-消费者**问题。我们有一个数据缓冲区，一个或多个生产者将数据保存在缓冲区中，一个或多个消费者从缓冲区中取数据。
- en: As the buffer is a shared data structure, we have to control the access to it
    using a synchronization mechanism such as the `synchronized` keyword, but we have
    more limitations. A producer can't save data in the buffer if it's full and the
    consumer can't take data from the buffer if it's empty.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区是共享数据结构，我们必须使用同步机制来控制对它的访问，比如`同步`关键字，但我们有更多的限制。如果缓冲区已满，生产者就不能将数据保存在缓冲区中，如果缓冲区为空，消费者就不能从缓冲区中取数据。
- en: For these types of situations, Java provides the `wait()`, `notify()` , and
    `notifyAll()` methods implemented in the `Object` class. A thread can call the
    `wait()` method inside a `synchronized` block of code. If it calls the `wait()`
    method outside a `synchronized` block of code, the JVM throws an `IllegalMonitorStateException`
    exception. When the thread calls the `wait()` method, the JVM puts the thread
    to sleep and releases the object that controls the `synchronized` block of code
    that it's executing and allows the other threads to execute other blocks of `synchronized`
    code protected by that object. To wake up the thread, you must call the `notify()`
    or `notifyAll()` method inside a block of code protected by the same object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，Java提供了在`Object`类中实现的`wait()`、`notify()`和`notifyAll()`方法。线程可以在`同步`代码块中调用`wait()`方法。如果它在`同步`代码块之外调用`wait()`方法，JVM会抛出`IllegalMonitorStateException`异常。当线程调用`wait()`方法时，JVM会让线程进入睡眠状态，并释放控制`同步`代码块的对象，允许其他线程执行由该对象保护的其他`同步`代码块。要唤醒线程，必须在由相同对象保护的代码块中调用`notify()`或`notifyAll()`方法。
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using the `synchronized` keyword and the `wait()`, `notify()`, and `notifyAll()`
    methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`同步`关键字和`wait()`、`notify()`和`notifyAll()`方法来实现生产者-消费者问题。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的实现使用了Eclipse IDE。如果您使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `EventStorage`. It has two attributes: an `int` attribute
    called `maxSize` and a `LinkedList<Date>` attribute called `storage`.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EventStorage`的类。它有两个属性：一个名为`maxSize`的`int`属性和一个名为`storage`的`LinkedList<Date>`属性。
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Implement the constructor of the class that initializes the attributes of the
    class.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化类属性的类构造函数。
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implement the `synchronized` method `set()` to store an event in the storage.
    First, check if the storage is full or not. If it's full, it calls the `wait()`
    method until the storage has empty space. At the end of the method, we call the
    `notifyAll()` method to wake up all the threads that are sleeping in the `wait()`
    method.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`同步`方法`set()`以将事件存储在存储中。首先，检查存储是否已满。如果满了，调用`wait()`方法直到存储有空余空间。在方法结束时，调用`notifyAll()`方法唤醒所有在`wait()`方法中睡眠的线程。
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implement the `synchronized` method `get()` to get an event for the storage.
    First, check if the storage has events or not. If it has no events, it calls the
    `wait()` method until the storage has some events. At the end of the method, we
    call the `notifyAll()` method to wake up all the threads that are sleeping in
    the `wait()` method.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`同步`方法`get()`以获取存储的事件。首先，检查存储是否有事件。如果没有事件，调用`wait()`方法，直到存储有事件为止。在方法结束时，调用`notifyAll()`方法唤醒所有在`wait()`方法中睡眠的线程。
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a class named `Producer` and specify that it implements the `Runnable`
    interface. It will implement the producer of the example.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Producer`的类，并指定它实现`Runnable`接口。它将实现示例的生产者。
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Declare an `EventStore` object and implement the constructor of the class that
    initializes that object.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`EventStore`对象并实现初始化该对象的类构造函数。
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Implement the `run()` method that calls `100` times the `set()` method of the
    `EventStorage` object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现调用`EventStorage`对象的`set()`方法`100`次的`run()`方法。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create a class named `Consumer` and specify that it implements the `Runnable`
    interface. It will implement the consumer for the example.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Consumer`的类，并指定它实现`Runnable`接口。它将实现示例的消费者。
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Declare an `EventStorage` object and implement the constructor of the class
    that initializes that object.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`EventStorage`对象并实现初始化该对象的类构造函数。
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Implement the `run()` method. It calls `100` times the `get()` method of the
    `EventStorage` object.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它调用`EventStorage`对象的`get()`方法`100`次。
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create the main class of the example by implementing a class named `Main` and
    add to it the `main()` method.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个名为`Main`的类并添加`main()`方法来创建示例的主类。
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create an `EventStorage` object.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`EventStorage`对象。
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a `Producer` object and `Thread` to run it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Producer`对象和一个`Thread`来运行它。
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Create a `Consumer` object and `Thread` to run it.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Consumer`对象和一个`Thread`来运行它。
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Start both threads.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个线程。
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to this example is the `set()` and `get()` methods of the `EventStorage`
    class. First of all, the `set()` method checks if there is free space in the storage
    attribute. If it's full, it calls the `wait()` method to wait for free space.
    When the other thread calls the `notifyAll()` method, the thread wakes up and
    checks the condition again. The `notifyAll()` method doesn't guarantee that the
    thread will wake up. This process is repeated until there is free space in the
    storage and it can generate a new event and store it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键是`EventStorage`类的`set()`和`get()`方法。首先，`set()`方法检查存储属性中是否有空闲空间。如果满了，调用`wait()`方法等待空闲空间。当其他线程调用`notifyAll()`方法时，线程会被唤醒并再次检查条件。`notifyAll()`方法不能保证线程会被唤醒。这个过程会重复，直到存储中有空闲空间并且可以生成新的事件并存储它。
- en: The behavior of the `get()` method is similar. First, it checks if there are
    events on the storage. If the `EventStorage` class is empty, it calls the `wait()`
    method to wait for events. Where the other thread calls the `notifyAll()` method,
    the thread wakes up and checks the condition again until there are some events
    in the storage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法的行为类似。首先，它检查存储中是否有事件。如果`EventStorage`类为空，调用`wait()`方法等待事件。当其他线程调用`notifyAll()`方法时，线程会被唤醒并再次检查条件，直到存储中有事件为止。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You have to keep checking the conditions and calling the `wait()` method in
    a `while` loop. You can't continue until the condition is `true.`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须不断检查条件，并在`while`循环中调用`wait()`方法。直到条件为`true`为止，您才能继续。
- en: If you run this example, you will see how producer and consumer are setting
    and getting the events, but the storage never has more than 10 events.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例，您将看到生产者和消费者如何设置和获取事件，但存储中从未有超过10个事件。
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are other important uses of the `synchronized` keyword. See the *See also*
    section for other recipes that explain the use of this keyword.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字还有其他重要的用途。请参阅*另请参阅*部分，了解解释此关键字用法的其他配方。'
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Arranging independent attributes in synchronized classes* recipe in [Chapter
    2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章.基本线程同步")中的*在同步类中排列独立属性*配方，*基本线程同步*'
- en: Synchronizing a block of code with a Lock
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁同步代码块
- en: 'Java provides another mechanism for the synchronization of blocks of code.
    It''s a more powerful and flexible mechanism than the `synchronized` keyword.
    It''s based on the `Lock` interface and classes that implement it (as `ReentrantLock`).
    This mechanism presents some advantages, which are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了另一种用于同步代码块的机制。这是一种比`synchronized`关键字更强大和灵活的机制。它基于`Lock`接口和实现它的类（如`ReentrantLock`）。这种机制具有一些优势，如下所示：
- en: It allows the structuring of synchronized blocks in a more flexible way. With
    the `synchronized` keyword, you have to get and free the control over a synchronized
    block of code in a structured way. The `Lock` interfaces allow you to get more
    complex structures to implement your critical section.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许以更灵活的方式构造同步块。使用`synchronized`关键字，您必须以结构化的方式获取和释放同步代码块的控制权。`Lock`接口允许您获得更复杂的结构来实现您的临界区。
- en: The `Lock` interfaces provide additional functionalities over the `synchronized`
    keyword. One of the new functionalities is implemented by the `tryLock()` method.
    This method tries to get the control of the lock and if it can't, because it's
    used by other thread, it returns the lock. With the `synchronized` keyword, when
    a thread (A) tries to execute a synchronized block of code, if there is another
    thread (B) executing it, the thread (A) is suspended until the thread (B) finishes
    the execution of the synchronized block. With locks, you can execute the `tryLock()`
    method. This method returns a `Boolean` value indicating if there is another thread
    running the code protected by this lock.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口提供了比`synchronized`关键字更多的功能。其中一个新功能是`tryLock()`方法。此方法尝试获取锁的控制权，如果无法获取（因为它被其他线程使用），则返回该锁。使用`synchronized`关键字时，当线程（A）尝试执行同步代码块时，如果有另一个线程（B）正在执行它，线程（A）将被挂起，直到线程（B）完成同步块的执行。使用锁，您可以执行`tryLock()`方法。此方法返回一个`Boolean`值，指示是否有另一个线程运行由此锁保护的代码。'
- en: The `Lock` interfaces allow a separation of read and write operations having
    multiple readers and only one modifier.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口允许对读和写操作进行分离，具有多个读取者和仅一个修改者。'
- en: The `Lock` interfaces offer better performance than the `synchronized` keyword.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口的性能比`synchronized`关键字更好。'
- en: In this recipe, you will learn how to use locks to synchronize a block of code
    and create a critical section using the `Lock` interface and the `ReentrantLock`
    class that implements it, implementing a program that simulates a print queue.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何使用锁来同步代码块，并使用`Lock`接口和实现它的`ReentrantLock`类创建临界区，实现一个模拟打印队列的程序。
- en: Getting Ready...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `PrintQueue` that will implement the print queue.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrintQueue`的类，它将实现打印队列。
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Declare a `Lock` object and initialize it with a new object of the `ReentrantLock`
    class.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Lock`对象，并使用`ReentrantLock`类的新对象对其进行初始化。
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Implement the `printJob()` method. It will receive `Object` as a parameter and
    it will not return any value.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`printJob()`方法。它将接收`Object`作为参数，并不会返回任何值。
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Inside the `printJob()` method, get the control of the `Lock` object calling
    the `lock()` method.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`printJob()`方法内部，通过调用`lock()`方法获取`Lock`对象的控制权。
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, include the following code to simulate the printing of a document:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，包括以下代码来模拟打印文档：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, free the control of the `Lock` object with the `unlock()` method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`unlock()`方法释放`Lock`对象的控制权。
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create a class named `Job` and specify that it implements the `Runnable` interface.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Job`的类，并指定它实现`Runnable`接口。
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Declare an object of the `PrintQueue` class and implement the constructor of
    the class that initializes that object.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`PrintQueue`类的对象，并实现初始化该对象的类的构造函数。
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Implement the `run()` method. It uses the `PrintQueue` object to send a job
    to print.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它使用`PrintQueue`对象发送打印作业。
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Create the main class of the application by implementing a class named `Main`
    and add the `main()` method to it.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个名为`Main`的类并向其中添加`main()`方法，创建应用程序的主类。
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Create a shared `PrintQueue` object.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个共享的`PrintQueue`对象。
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Create 10 `Job` objects and 10 threads to run them.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个`Job`对象和10个线程来运行它们。
- en: '[PRE64]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Start the 10 threads.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动10个线程。
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see a part of the output of one execution,
    of this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到一个执行的部分输出，例如：
- en: '![How it works...](img/7881_02_04.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_04.jpg)'
- en: The key to the example is in the `printJob()` method of the `PrintQueue` class.
    When we want to implement a critical section using locks and guarantee that only
    one execution thread runs a block of code, we have to create a `ReentrantLock`
    object. At the beginning of the critical section, we have to get the control of
    the lock using the `lock()` method. When a thread (A) calls this method, if no
    other thread has the control of the lock, the method gives the thread (A) the
    control of the lock and returns immediately to permit the execution of the critical
    section to this thread. Otherwise, if there is another thread (B) executing the
    critical section controlled by this lock, the `lock()` method puts the thread
    (A) to sleep until the thread (B) finishes the execution of the critical section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的关键在于`PrintQueue`类的`printJob()`方法。当我们想要使用锁实现临界区并确保只有一个执行线程运行代码块时，我们必须创建一个`ReentrantLock`对象。在临界区的开始，我们必须使用`lock()`方法获取锁的控制权。当一个线程（A）调用此方法时，如果没有其他线程控制着锁，该方法将给予线程（A）锁的控制权，并立即返回以允许该线程执行临界区。否则，如果有另一个线程（B）执行由此锁控制的临界区，`lock()`方法将使线程（A）进入休眠状态，直到线程（B）完成临界区的执行。
- en: At the end of the critical section, we have to use the `unlock()` method to
    free the control of the lock and allow the other threads to run this critical
    section. If you don't call the `unlock()` method at the end of the critical section,
    the other threads that are waiting for that block will be waiting forever, causing
    a deadlock situation. If you use try-catch blocks in your critical section, don't
    forget to put the sentence containing the `unlock()` method inside the `finally`
    section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在临界区的结束，我们必须使用`unlock()`方法释放锁的控制权，并允许其他线程运行此临界区。如果在临界区结束时不调用`unlock()`方法，那些正在等待该块的其他线程将永远等待，导致死锁情况。如果在临界区中使用try-catch块，请不要忘记将包含`unlock()`方法的语句放在`finally`部分中。
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Lock` interface (and the `ReentrantLock` class) includes another method
    to get the control of the lock. It's the `tryLock()` method. The biggest difference
    with the `lock()` method is that this method, if the thread that uses it can't
    get the control of the `Lock` interface, returns immediately and doesn't put the
    thread to sleep. This method returns a `boolean` value, `true` if the thread gets
    the control of the lock, and `false` if not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口（以及`ReentrantLock`类）包括另一个方法来获取锁的控制权。这就是`tryLock()`方法。与`lock()`方法最大的区别在于，如果使用它的线程无法获得`Lock`接口的控制权，该方法将立即返回，而不会使线程进入休眠状态。该方法返回一个`boolean`值，如果线程获得了锁的控制权，则返回`true`，否则返回`false`。'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take into consideration that it is the responsibility of the programmer to take
    into account the result of this method and act accordingly. If the method returns
    the `false` value, it's expected that your program doesn't execute the critical
    section. If it does, you probably will have wrong results in your application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序员有责任考虑此方法的结果并相应地采取行动。如果该方法返回`false`值，则预期您的程序不会执行临界区。如果执行了，您的应用程序可能会产生错误的结果。
- en: The `ReentrantLock` class also allows the use of recursive calls. When a thread
    has the control of a lock and makes a recursive call, it continues with the control
    of the lock, so the calling to the `lock()` method will return immediately and
    the thread will continue with the execution of the recursive call. Moreover, we
    can also call other methods.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock`类还允许使用递归调用。当一个线程控制着一个锁并进行递归调用时，它将继续控制着锁，因此调用`lock()`方法将立即返回，线程将继续执行递归调用。此外，我们还可以调用其他方法。'
- en: More Info
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息
- en: You have to be very careful with the use of `Locks` to avoid **deadlocks** .
    This situation occurs when two or more threads are blocked waiting for locks that
    never will be unlocked. For example, a thread (A) locks a Lock (X) and a thread
    (B) locks a Lock (Y). If now, the thread (A) tries to lock the Lock (Y) and the
    thread (B) simultaneously tries to lock the Lock (X), both threads will be blocked
    indefinitely, because they are waiting for locks that will never be liberated.
    Note that the problem occurs, because both threads try to get the locks in the
    opposite order. The Appendix , *Concurrent programming design*, explains some
    good tips to design concurrent applications adequately and avoid these deadlocks
    problems.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须非常小心地使用`Locks`以避免**死锁**。当两个或更多线程被阻塞等待永远不会被解锁的锁时，就会发生这种情况。例如，一个线程（A）锁定了一个锁（X），而另一个线程（B）锁定了一个锁（Y）。如果现在，线程（A）尝试锁定锁（Y），而线程（B）同时尝试锁定锁（X），那么两个线程将无限期地被阻塞，因为它们正在等待永远不会被释放的锁。请注意，问题出现在于两个线程尝试以相反的顺序获取锁。附录*并发编程设计*解释了一些设计并发应用程序并避免这些死锁问题的好建议。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a method* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 基本线程同步")的*基本线程同步*中的*同步方法*配方
- en: The *Using multiple conditions in a Lock* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 基本线程同步")的*基本线程同步*中的*在锁中使用多个条件*配方中
- en: The *Monitoring a Lock* interface recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章 测试并发应用")的*测试并发应用*中的*监视锁*接口配方
- en: Synchronizing data access with read/write locks
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用读/写锁同步数据访问
- en: One of the most significant improvements offered by locks is the `ReadWriteLock`
    interface and the `ReentrantReadWriteLock` class, the unique one that implements
    it. This class has two locks, one for read operations and one for write operations.
    There can be more than one thread using read operations simultaneously, but only
    one thread can be using write operations. When a thread is doing a write operation,
    there can't be any thread doing read operations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 锁提供的最重要的改进之一是`ReadWriteLock`接口和`ReentrantReadWriteLock`类，它是唯一实现它的类。这个类有两个锁，一个用于读操作，一个用于写操作。可以有多个线程同时使用读操作，但只能有一个线程使用写操作。当一个线程执行写操作时，不能有任何线程执行读操作。
- en: In this recipe, you will learn how to use a `ReadWriteLock` interface implementing
    a program that uses it to control the access to an object that stores the prices
    of two products.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何使用`ReadWriteLock`接口来实现一个程序，该程序使用它来控制对存储两种产品价格的对象的访问。
- en: Getting Ready...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: You should read the *Synchronizing a block of code with a Lock* recipe for a
    better understanding of this recipe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读*Synchronizing a block of code with a Lock*一节，以更好地理解本节。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `PricesInfo` that stores information about the prices of
    two products.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PricesInfo`的类，用于存储两种产品的价格信息。
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Declare two `double` attributes named `price1` and `price2`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`price1`和`price2`的`double`属性。
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Declare a `ReadWriteLock` object called `lock`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`lock`的`ReadWriteLock`对象。
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the constructor of the class that initializes the three attributes.
    For the `lock` attribute, we create a new `ReentrantReadWriteLock` object.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化三个属性的类的构造函数。对于`lock`属性，我们创建一个新的`ReentrantReadWriteLock`对象。
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Implement the `getPrice1()` method that returns the value of the `price1` attribute.
    It uses the read lock to control the access to the value of this attribute.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getPrice1()`方法，该方法返回`price1`属性的值。它使用读锁来控制对该属性值的访问。
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implement the `getPrice2()` method that returns the value of the `price2` attribute.
    It uses the read lock to control the access to the value of this attribute.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getPrice2()`方法，该方法返回`price2`属性的值。它使用读锁来控制对该属性值的访问。
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Implement the `setPrices()` method that establishes the values of the two attributes.
    It uses the write lock to control access to them.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setPrices()`方法，用于设置两个属性的值。它使用写锁来控制对它们的访问。
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Create a class named `Reader` and specify that it implements the `Runnable`
    interface. This class implements a reader of the values of the `PricesInfo` class
    attributes.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Reader`的类，并指定它实现`Runnable`接口。该类实现了`PricesInfo`类属性值的读取器。
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Declare a `PricesInfo` object and implement the constructor of the class that
    initializes that object.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`PricesInfo`的对象，并实现初始化该对象的类的构造函数。
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Implement the `run()` method for this class. It reads 10 times the value of
    the two prices.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类实现`run()`方法。它读取两个价格的值10次。
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Create a class named `Writer` and specify that it implements the `Runnable`
    interface. This class implements a modifier of the values of the `PricesInfo`
    class attributes.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Writer`的类，并指定它实现`Runnable`接口。该类实现了`PricesInfo`类属性值的修改器。
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Declare a `PricesInfo` object and implement the constructor of the class that
    initializes that object.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`PricesInfo`的对象，并实现初始化该对象的类的构造函数。
- en: '[PRE77]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Implement the `run()` method. It modifies three times the value of the two prices
    that are sleeping for two seconds between modifications.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它在修改两个价格的值之间休眠两秒，共修改三次。
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Create a `PricesInfo` object.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PricesInfo`对象。
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Create five `Reader` objects and five `Threads` to execute them.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Reader`对象和五个`Thread`来执行它们。
- en: '[PRE81]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Create a `Writer` object and `Thread` to execute it.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Writer`对象和一个`Thread`来执行它。
- en: '[PRE82]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Start the threads.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程。
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到此示例的一个执行输出的一部分：
- en: '![How it works...](img/7881_02_05.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_05.jpg)'
- en: As we mentioned previously, the `ReentrantReadWriteLock` class has two locks,
    one for read operations and one for write operations. The lock used in read operations
    is obtained with the `readLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. The lock used in write operations
    is obtained with the `writeLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. It is the responsibility of the
    programmer to ensure the correct use of these locks, using them with the same
    purposes for which they were designed.When you get the read lock of a `Lock` interface,
    you can't modify the value of the variable. Otherwise, you probably will have
    inconsistency data errors.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`ReentrantReadWriteLock`类有两个锁，一个用于读操作，一个用于写操作。在读操作中使用的锁是通过`ReadWriteLock`接口中声明的`readLock()`方法获得的。这个锁是一个实现了`Lock`接口的对象，所以我们可以使用`lock()`、`unlock()`和`tryLock()`方法。在写操作中使用的锁是通过`ReadWriteLock`接口中声明的`writeLock()`方法获得的。这个锁是一个实现了`Lock`接口的对象，所以我们可以使用`lock()`、`unlock()`和`tryLock()`方法。程序员有责任确保正确使用这些锁，使用它们的目的与它们设计的目的相同。当您获得`Lock`接口的读锁时，您不能修改变量的值。否则，您可能会遇到数据不一致的错误。
- en: See also
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章.基本线程同步")的*Synchronizing a block of code with a Lock*一节中，*基本线程同步*
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing concurrent Applications*
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。测试并发应用程序")的*监视锁接口*食谱中，*测试并发应用程序*
- en: Modifying Lock fairness
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改锁的公平性
- en: The constructor of the `ReentrantLock` and `ReentrantReadWriteLock` classes
    admits a `boolean` parameter named `fair` that allows you to control the behavior
    of both classes. The `false` value is the default value and it's called the **non-fair
    mode** . In this mode, when there are some threads waiting for a lock (`ReentrantLock`
    or `ReentrantReadWriteLock`) and the lock has to select one of them to get the
    access to the critical section, it selects one without any criteria. The `true`
    value is called the **fair mode**. In this mode, when there are some threads waiting
    for a lock (`ReentrantLock` or `ReentrantReadWriteLock`) and the lock has to select
    one to get access to a critical section, it selects the thread that has been waiting
    for the most time. Take into account that the behavior explained previously is
    only used with the `lock()` and `unlock()` methods. As the `tryLock()` method
    doesn't put the thread to sleep if the `Lock` interface is used, the fair attribute
    doesn't affect its functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock`和`ReentrantReadWriteLock`类的构造函数接受一个名为`fair`的`boolean`参数，允许您控制这两个类的行为。`false`值是默认值，称为**非公平模式**。在此模式下，当有一些线程等待锁（`ReentrantLock`或`ReentrantReadWriteLock`）并且锁必须选择其中一个来访问临界区时，它会选择一个而没有任何标准。`true`值称为**公平模式**。在此模式下，当有一些线程等待锁（`ReentrantLock`或`ReentrantReadWriteLock`）并且锁必须选择一个来访问临界区时，它会选择等待时间最长的线程。请注意，前面解释的行为仅用于`lock()`和`unlock()`方法。由于`tryLock()`方法在使用`Lock`接口时不会使线程进入睡眠状态，因此公平属性不会影响其功能。'
- en: In this recipe, we will modify the example implemented in the *Synchronizing
    a block of code with a Lock* recipe to use this attribute and see the difference
    between the fair and non-fair modes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将修改在*使用锁同步代码块*食谱中实现的示例，以使用此属性并查看公平和非公平模式之间的区别。
- en: Getting Ready...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备...
- en: We are going to modify the example implemented in the *Synchronizing a block
    of code with a Lock* recipe, so read that recipe to implement this example.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改在*使用锁同步代码块*食谱中实现的示例，因此请阅读该食谱以实现此示例。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Implement the example explained in the *Synchronizing a block of code with a
    Lock* recipe.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现在*使用锁同步代码块*食谱中解释的示例。
- en: 'In the `PrintQueue` class, modify the construction of the `Lock` object. The
    new instruction is given as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PrintQueue`类中，修改`Lock`对象的构造。新的指令如下所示：
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Modify the `printJob()` method. Separate the simulation of printing in two blocks
    of code, freeing the lock between them.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`printJob()`方法。将打印模拟分为两个代码块，在它们之间释放锁。
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Modify in the `Main` class the block of code that starts the threads. The new
    block of code is given as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`类中修改启动线程的代码块。新的代码块如下所示：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot you can see a part of the output of one execution
    of this example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到此示例的一次执行输出的一部分：
- en: '![How it works...](img/7881_02_06.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_06.jpg)'
- en: All threads are created with a difference of 0.1 seconds. The first thread that
    requests the control of the lock is **Thread 0**, then **Thread 1**, and so on.
    While **Thread 0** is running the first block of code protected by the lock, we
    have nine threads waiting to execute that block of code. When **Thread 0** releases
    the lock, immediately, it requests the lock again, so we have 10 threads trying
    to get the lock. As the fair mode is enabled, the `Lock` interface will choose
    **Thread 1**, so it's the thread that has been waiting for more time for the lock.
    Then, it chooses **Thread 2**, then, **Thread 3**, and so on. Until all the threads
    have passed the first block protected by the lock, none of them will execute the
    second block protected by the lock.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程的创建间隔为0.1秒。请求控制锁的第一个线程是**线程0**，然后是**线程1**，依此类推。当**线程0**运行由锁保护的第一个代码块时，我们有九个线程等待执行该代码块。当**线程0**释放锁时，立即再次请求锁，因此我们有10个线程尝试获取锁。由于启用了公平模式，`Lock`接口将选择**线程1**，因此它是等待时间最长的线程。然后选择**线程2**，然后是**线程3**，依此类推。直到所有线程都通过了由锁保护的第一个代码块，它们才会执行由锁保护的第二个代码块。
- en: Once all the threads have executed the first block of code protected by the
    lock, it's the turn of **Thread 0** again. Then, it's the turn of **Thread 1**,
    and so on.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有线程执行了由锁保护的第一个代码块，再次轮到**线程0**。然后是**线程1**，依此类推。
- en: 'To see the difference with the non-fair mode, change the parameter passed to
    the lock constructor and put the `false` value. In the following screenshot, you
    can see the result of one execution of the modified example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与非公平模式的区别，请更改传递给锁构造函数的参数并将其设置为`false`值。在下面的屏幕截图中，您可以看到修改后示例的执行结果：
- en: '![How it works...](img/7881_02_07.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_02_07.jpg)'
- en: In this case, the threads are executed in the order that have been created but
    each thread executes the two protected blocks of code. However, this behavior
    is not guaranteed because, as explained earlier, the lock could choose any thread
    to give it access to the protected code. The JVM does not guarantee, in this case,
    the order of execution of the threads.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，线程按照它们被创建的顺序执行，但每个线程都执行两个受保护的代码块。但是，这种行为不能保证，因为如前所述，锁可以选择任何线程来让其访问受保护的代码。在这种情况下，JVM不能保证线程的执行顺序。
- en: There's more...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Read/write locks also have the fair parameter in their constructor. The behaviour
    of this parameter in this kind of lock is the same as we explained in the introduction
    of this recipe.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 读/写锁在其构造函数中也有公平参数。此参数在这种类型的锁中的行为与我们在本食谱介绍中解释的相同。
- en: See also
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本线程同步")中的*使用锁同步代码块*示例中，*基本线程同步*
- en: The *Synchronizing data access with read/write locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本线程同步")中的*使用读/写锁同步数据访问*示例中，*基本线程同步*
- en: The *Implementing a custom Lock class* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。自定义并发类")中的*实现自定义锁类*示例中，*自定义并发类*
- en: Using multiple conditions in a Lock
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在锁中使用多个条件
- en: A lock may be associated with one or more conditions. These conditions are declared
    in the `Condition` interface. The purpose of these conditions is to allow threads
    to have control of a lock and check whether a condition is `true` or not and,
    if it's `false`, be suspended until another thread wakes them up. The `Condition`
    interface provides the mechanisms to suspend a thread and to wake up a suspended
    thread.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个锁可以与一个或多个条件关联。这些条件在`Condition`接口中声明。这些条件的目的是允许线程控制锁，并检查条件是否为`true`，如果为`false`，则暂停，直到另一个线程唤醒它们。`Condition`接口提供了挂起线程和唤醒挂起线程的机制。
- en: A classic problem in concurrent programming is the **producer-consumer** problem.
    We have a data buffer, one or more **producers** of data that save it in the buffer,
    and one or more **consumers** of data that take it from the buffer as explained
    earlier in this chapter
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中的一个经典问题是**生产者-消费者**问题。我们有一个数据缓冲区，一个或多个将数据保存在缓冲区中的**生产者**，以及一个或多个从缓冲区中取出数据的**消费者**，正如本章前面所述
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using locks and conditions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用锁和条件来实现生产者-消费者问题。
- en: Getting Ready...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: You should read the *Synchronizing a block of code with a Lock* recipe for a
    better understanding of this recipe.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读*使用锁同步代码块*示例，以更好地理解这个示例。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, let''s implement a class that will simulate a text file. Create a class
    named `FileMock` with two attributes: a `String` array named `content` and `int`
    named `index`. They will store the content of the file and the line of the simulated
    file that will be retrieved.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现一个类，模拟文本文件。创建一个名为`FileMock`的类，具有两个属性：一个名为`content`的`String`数组和一个名为`index`的`int`。它们将存储文件的内容和将被检索的模拟文件的行。
- en: '[PRE87]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Implement the constructor of the class that initializes the content of the file
    with random characters.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化文件内容为随机字符。
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Implement the method `hasMoreLines()` that returns `true` if the file has more
    lines to process or `false` if we have achieved the end of the simulated file.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`hasMoreLines()`方法，如果文件有更多行要处理，则返回`true`，如果已经到达模拟文件的末尾，则返回`false`。
- en: '[PRE89]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Implement the method `getLine()`that returns the line determined by the index
    attribute and increases its value.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getLine()`方法，返回由索引属性确定的行并增加其值。
- en: '[PRE90]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now, implement a class named `Buffer` that will implement the buffer shared
    by producers and consumers.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个名为`Buffer`的类，它将实现生产者和消费者共享的缓冲区。
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This class has six attributes:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类有六个属性：
- en: A `LinkedList<String>` attribute named `buffer` that will store the shared data
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`buffer`的`LinkedList<String>`属性，用于存储共享数据
- en: An `int` type named `maxSize` that stores the length of the buffer
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为`maxSize`的`int`类型，用于存储缓冲区的长度
- en: A `ReentrantLock` object called `lock` that controls the access to the blocks
    of code that modify the buffer
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`lock`的`ReentrantLock`对象，用于控制修改缓冲区的代码块的访问
- en: Two `Condition` attributes named `lines` and `space`
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个名为`lines`和`space`的`Condition`属性
- en: A `boolean` type called `pendingLines` that will indicate if there are lines
    in the buffer
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`pendingLines`的`boolean`类型，它将指示缓冲区中是否有行
- en: '[PRE92]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Implement the constructor of the class. It initializes all the attributes described
    previously.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化先前描述的所有属性。
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Implement the `insert()` method. It receives `String` as a parameter and tries
    to store it in the buffer. First, it gets the control of the lock. When it has
    it, it then checks if there is empty space in the buffer. If the buffer is full,
    it calls the `await()` method in the `space` condition to wait for free space.
    The thread will be woken up when another thread calls the`signal()` or `signalAll()`
    method in the space `Condition`. When that happens, the thread stores the line
    in the buffer and calls the `signallAll()` method over the `lines` condition.
    As we'll see in a moment, this condition will wake up all the threads that were
    waiting for lines in the buffer.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`insert()`方法。它接收`String`作为参数，并尝试将其存储在缓冲区中。首先，它获取锁的控制权。当它拥有它时，它会检查缓冲区是否有空间。如果缓冲区已满，它会调用`space`条件中的`await()`方法等待空闲空间。当另一个线程调用`space`条件中的`signal()`或`signalAll()`方法时，线程将被唤醒。发生这种情况时，线程将行存储在缓冲区中，并调用`lines`条件上的`signallAll()`方法。正如我们将在下一刻看到的，这个条件将唤醒所有等待缓冲区中行的线程。
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Implement the `get()` method. It returns the first string stored in the buffer.
    First, it gets the control of the lock. When it has it, it checks if there are
    lines in the buffer. If the buffer is empty, it calls the `await()` method in
    the `lines` condition to wait for lines in the buffer. This thread will be woken
    up when another thread calls the `signal()` or `signalAll()` method in the lines
    condition. When it happens, the method gets the first line in the buffer, calls
    the `signalAll()` method over the space condition and returns `String`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`get()`方法。它返回缓冲区中存储的第一个字符串。首先，它获取锁的控制权。当它拥有它时，它会检查缓冲区中是否有行。如果缓冲区为空，它会调用`lines`条件中的`await()`方法等待缓冲区中的行。当另一个线程调用`lines`条件中的`signal()`或`signalAll()`方法时，该线程将被唤醒。当发生这种情况时，该方法获取缓冲区中的第一行，调用`space`条件上的`signalAll()`方法，并返回`String`。
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Implement the `setPendingLines()` method that establishes the value of the attribute
    `pendingLines`. It will be called by the producer when it has no more lines to
    produce.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setPendingLines()`方法，建立`pendingLines`属性的值。当生产者没有更多行要生产时，将调用它。
- en: '[PRE96]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Implement the `hasPendingLines()` method. It returns `true` if there are more
    lines to be processed, or `false` otherwise.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`hasPendingLines()`方法。如果有更多行要处理，则返回`true`，否则返回`false`。
- en: '[PRE97]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It's now the turn of the producer. Implement a class named `Producer` and specify
    that it implements the `Runnable` interface.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在轮到生产者了。实现一个名为`Producer`的类，并指定它实现`Runnable`接口。
- en: '[PRE98]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Declare two attributes: one object of the `FileMock` class and another object
    of the `Buffer` class.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个属性：`FileMock`类的一个对象和`Buffer`类的另一个对象。
- en: '[PRE99]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Implement the constructor of the class that initializes both attributes.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化两个属性的类的构造函数。
- en: '[PRE100]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Implement the `run()` method that reads all the lines created in the `FileMock`
    object and uses the `insert()` method to store them in the buffer. Once it finishes,
    use the `setPendingLines()` method to alert the buffer that it's not going to
    generate more lines.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法，读取`FileMock`对象中创建的所有行，并使用`insert()`方法将它们存储在缓冲区中。完成后，使用`setPendingLines()`方法通知缓冲区不会再生成更多行。
- en: '[PRE101]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Next is the consumer's turn. Implement a class named `Consumer` and specify
    that it implements the `Runnable` interface.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是消费者的轮次。实现一个名为`Consumer`的类，并指定它实现`Runnable`接口。
- en: '[PRE102]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Declare a `Buffer` object and implement the constructor of the class that initializes
    it.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Buffer`对象并实现初始化它的类的构造函数。
- en: '[PRE103]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Implement the `run()` method. While the buffer has pending lines, it tries to
    get one and process it.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。在缓冲区有待处理的行时，它尝试获取并处理其中的一行。
- en: '[PRE104]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Implement the auxiliary method `processLine()`. It only sleeps for 10 milliseconds
    to simulate some kind of processing with the line.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`processLine()`。它只休眠10毫秒，模拟对行进行某种处理。
- en: '[PRE105]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE106]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Create a `FileMock` object.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FileMock`对象。
- en: '[PRE107]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Create a `Buffer` object.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Buffer`对象。
- en: '[PRE108]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Create a `Producer` object and `Thread` to run it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Producer`对象和一个`Thread`来运行它。
- en: '[PRE109]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create three `Consumer` objects and three threads to run it.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个`Consumer`对象和三个线程来运行它。
- en: '[PRE110]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Start the producer and the three consumers.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动生产者和三个消费者。
- en: '[PRE111]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How it works...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the `Condition` objects are associated with a lock and are created using
    the `newCondition()` method declared in the `Lock` interface. Before we can do
    any operation with a condition, you have to have the control of the lock associated
    with the condition, so the operations with conditions must be in a block of code
    that begins with a call to a `lock()` method of a `Lock` object and ends with
    an `unlock()` method of the same `Lock` object.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Condition`对象都与一个锁相关联，并且是使用`Lock`接口中声明的`newCondition()`方法创建的。在我们可以对条件进行任何操作之前，必须控制与条件相关联的锁，因此条件的操作必须在以`Lock`对象的`lock()`方法调用开始的代码块中，并以相同`Lock`对象的`unlock()`方法结束。
- en: When a thread calls the `await()` method of a condition, it automatically frees
    the control of the lock, so that another thread can get it and begin the execution
    of the same, or another critical section protected by that lock.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程调用条件的`await()`方法时，它会自动释放锁的控制权，以便另一个线程可以获取它并开始执行相同的临界区或由该锁保护的另一个临界区。
- en: Note
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a thread calls the `signal()` or `signallAll()` methods of a condition,
    one or all of the threads that were waiting for that condition are woken up, but
    this doesn't guarantee that the condition that made them sleep is now `true`,
    so you must put the `await()` calls inside a `while` loop. You can't leave that
    loop until the condition is `true`. While the condition is `false`, you must call
    `await()` again.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程调用条件的`signal()`或`signallAll()`方法时，等待该条件的一个或所有线程被唤醒，但这并不保证使它们休眠的条件现在是`true`，因此必须将`await()`调用放在`while`循环中。在条件为`true`之前，不能离开该循环。条件为`false`时，必须再次调用`await()`。
- en: You must be careful with the use of `await()` and `signal()`. If you call the
    `await()` method in a condition and never call the `signal()` method in this condition,
    the thread will be sleeping forever.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`await()`和`signal()`时必须小心。如果在条件中调用`await()`方法，但从未在该条件中调用`signal()`方法，线程将永远休眠。
- en: A thread can be interrupted while it is sleeping, after a call to the `await()`
    method, so you have to process the `InterruptedException` exception.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在休眠时，线程可能会被中断，在调用`await()`方法后，因此必须处理`InterruptedException`异常。
- en: There's more...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Condition` interface has other versions of the `await()` method, which
    are as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Condition`接口有`await()`方法的其他版本，如下所示：'
- en: '`await(long time, TimeUnit unit)`: The thread will be sleeping until:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await(long time, TimeUnit unit)`: 线程将休眠直到：'
- en: It's interrupted
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被中断了
- en: Another thread calls the `singal()` or `signalAll()` methods in the condition
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个线程在条件中调用`signal()`或`signalAll()`方法
- en: The specified time passes
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的时间已经过去
- en: 'The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`'
- en: '`awaitUninterruptibly()`: The thread will be sleeping until another thread
    calls the `signal()` or `signalAll()` methods, which can''t be interrupted'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitUninterruptibly()`: 线程将休眠直到另一个线程调用`signal()`或`signalAll()`方法，这是不可中断的'
- en: '`awaitUntil(Date date)`: The thread will be sleeping until:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitUntil(Date date)`: 线程将休眠直到：'
- en: It's interrupted
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被中断了
- en: Another thread calls the `singal()` or `signalAll()` methods in the condition
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个线程在条件中调用`signal()`或`signalAll()`方法
- en: The specified date arrives
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的日期到达
- en: You can use conditions with the `ReadLock` and `WriteLock` locks of a read/write
    lock.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用条件与读/写锁的`ReadLock`和`WriteLock`锁。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《第2章》（ch02.html“第2章基本线程同步”）的*使用锁同步代码块*配方中
- en: The *Synchronizing data access with read/write locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《第2章》（ch02.html“第2章基本线程同步”）的*使用读/写锁同步数据访问*配方
