- en: Chapter 2. Java Data Types and Their Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. Java数据类型及其使用
- en: In this chapter we will learn more about how Java organizes and manipulates
    data, especially primitive data types and strings. In addition to this, we will
    explore various related concepts such as scoping and the lifetime of a variable.
    While strings are not a primitive data type in Java, they are a critical part
    of many applications and we will examine what Java has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更多地了解Java如何组织和操作数据，特别是基本数据类型和字符串。除此之外，我们还将探讨各种相关概念，如作用域和变量的生命周期。虽然字符串在Java中不是基本数据类型，但它们是许多应用程序的重要组成部分，我们将探讨Java提供了什么。
- en: 'In this chapter we will focus on:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注：
- en: The declaration and use of primitive data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型的声明和使用
- en: Using the `String` and `StringBuilder` classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`String`和`StringBuilder`类
- en: How the program stack and heap relate to each other
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序堆栈和堆如何相互关联
- en: The differences between a class and an object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象之间的区别
- en: Constants and literals in Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的常量和文字
- en: The scope and lifetime of a variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域和生命周期
- en: Operators, operands, and expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符、操作数和表达式
- en: Understanding how Java handles data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java如何处理数据
- en: The core of programming is code that manipulates data. As programmers we are
    interested in the organization of data and code. The organization of data is referred
    to as **data** **structures** . These structures can be static or dynamic in nature.
    For example, the ages of a population can be stored in consecutive locations in
    a data structure known as an **array** . While the array data structure has a
    fixed size, the contents may or may not change. Arrays are discussed in detail
    in [Chapter 4](ch04.html "Chapter 4. Using Arrays and Collections"), *Using Arrays
    and Collections*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的核心是操作数据的代码。作为程序员，我们对数据和代码的组织感兴趣。数据的组织被称为**数据结构**。这些结构可以是静态的或动态的。例如，人口的年龄可以存储在数据结构中连续的位置，这种数据结构称为**数组**。虽然数组数据结构具有固定的大小，但内容可能会改变或不改变。数组在[第4章](ch04.html
    "第4章. 使用数组和集合")中有详细讨论，*使用数组和集合*。
- en: 'In this section, we will examine several different aspects of variables including:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究变量的几个不同方面，包括：
- en: How they are declared
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是如何声明的
- en: Primitive data types versus objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型与对象
- en: Where they reside in memory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在内存中的位置
- en: How they are initialized
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是如何初始化的
- en: Their scope and lifetime
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的作用域和生命周期
- en: Java identifiers, objects, and memory
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java标识符、对象和内存
- en: Variables are defined to be of a specific type and are allocated memory. When
    an object is created, instance variables that make up the object are allocated
    on the heap. The static variables of an object are allocated to a special area
    of memory. When a variable is declared as part of a method, the memory for the
    variable is allocated on the program stack.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被定义为特定类型，并分配内存。当创建对象时，构成对象的实例变量被分配在堆上。对象的静态变量被分配到内存的特殊区域。当变量被声明为方法的一部分时，变量的内存被分配在程序堆栈上。
- en: Stack and heap
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈和堆
- en: A thorough understanding of the stack/heap and other issues is critical for
    understanding how a program works, and in turn how well a developer can use a
    language such as Java to do his job. These concepts provide a framework for understanding
    how an application works and are the basis for the implementation of the runtime
    system used by Java, not to mention almost every other programming language in
    existence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对堆栈/堆和其他问题的彻底理解对于理解程序如何工作以及开发人员如何使用Java等语言来完成工作至关重要。这些概念为理解应用程序的工作方式提供了一个框架，并且是Java使用的运行时系统的实现的基础，更不用说几乎所有其他编程语言的实现了。
- en: With this said, the concept of a stack and heap is fairly simple. The **stack**
    is an area where the parameters of a method and its local variables are stored
    each time a method is invoked. The **heap** is an area of memory where objects
    are allocated when the `new` keyword is invoked. The parameters and local variables
    of a method make up an **activation** **record** , also called a **stack** **frame**
    . Activation records are pushed onto a stack when the method is invoked and popped
    off the stack when the method returns. The temporary existence of these variables
    determines the lifetime of the variables.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，堆栈和堆的概念相当简单。**堆栈** 是每次调用方法时存储方法的参数和局部变量的区域。**堆** 是在调用`new`关键字时分配对象的内存区域。方法的参数和局部变量构成一个**激活记录**，也称为**堆栈帧**。激活记录在方法调用时被推送到堆栈上，并在方法返回时从堆栈上弹出。这些变量的临时存在决定了变量的生命周期。
- en: '![Stack and heap](img/7324_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![堆栈和堆](img/7324_02_01.jpg)'
- en: The stack grows toward the heap when a method is invoked and shrinks when the
    method returns. The heap does not grow in a predictable order and can become fragmented.
    As they share the same memory space, if the heap and stack collide then the program
    will terminate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用方法时，堆栈向堆增长，并在方法返回时收缩。堆不会按可预测的顺序增长，并且可能变得分散。由于它们共享相同的内存空间，如果堆和堆栈发生碰撞，程序将终止。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Understanding the concept of stack and heap is important because:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解堆栈和堆的概念很重要，因为：
- en: It provides a foundation used to understand how data is organized in an application
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个基础，用于理解应用程序中数据的组织方式
- en: It helps explain the concept of the scope and lifetime of a variable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于解释变量的作用域和生命周期
- en: It helps explain how recursion works
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于解释递归的工作原理
- en: 'We will re-use the program illustrated in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Java"), *Getting Started with Java*, to demonstrate the use of stack
    and heap. The program has been duplicated here for your convenience:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复使用[第1章](ch01.html "第1章. Java入门")中演示的程序，*Java入门*，以演示堆栈和堆的使用。该程序已经在此处复制以方便您使用：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the `main` method is executed, an activation record is pushed onto the
    program stack. As shown in the following diagram, its activation record consists
    of only the single `args` parameter and the `customer` reference variable. When
    the instance of the `Customer` class is created, an object is created and allocated
    on the heap. The state of the stack and heap reflected in this example occurs
    after the `Customer` constructor executes. The `args` reference variable points
    to an array. Each element of the array references a string representing the applications''
    command line arguments. In the example shown in the following diagram, we assume
    there are two command line arguments, Argument 1 and Argument 2:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`main`方法时，激活记录被推送到程序堆栈上。如下图所示，它的激活记录仅包括单个`args`参数和`customer`引用变量。当创建`Customer`类的实例时，将在堆上创建并分配一个对象。在此示例中反映的堆栈和堆的状态是在`Customer`构造函数执行后发生的。`args`引用变量指向一个数组。数组的每个元素引用表示应用程序命令行参数的字符串。在下图所示的示例中，我们假设有两个命令行参数，参数1和参数2：
- en: '![Stack and heap](img/7324_02_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![堆栈和堆](img/7324_02_02.jpg)'
- en: When the `setBalance` method is executed, its activation record is pushed onto
    the program stack as illustrated below. The `setBalance` method has a single parameter,
    `balance`, which is assigned to the `balance` instance variable. But first, it
    is used as an argument to the `BigDecimal` constructor. The `this` keyword references
    the current object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`setBalance`方法时，它的激活记录被推送到程序堆栈上，如下所示。`setBalance`方法有一个参数`balance`，它被分配给`balance`实例变量。但首先，它被用作`BigDecimal`构造函数的参数。`this`关键字引用当前对象。
- en: Heap is the memory that is dynamically allocated for objects. A heap manager
    controls how this memory is organized. When an object is no longer needed, a garbage
    collection routine will execute to free up the memory so it can be re-used. Before
    an object is disposed of, the object's `finalize` method is executed. However,
    there is no guarantee that the method will execute as the program may terminate
    without the need for the garbage collection routine to run. The original `BigDecimal`
    object will be eventually destroyed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是为对象动态分配的内存。堆管理器控制这些内存的组织方式。当对象不再需要时，将执行垃圾收集例程以释放内存以便重新使用。在对象被处理之前，将执行对象的`finalize`方法。但是，不能保证该方法将执行，因为程序可能在不需要运行垃圾收集例程的情况下终止。原始的`BigDecimal`对象最终将被销毁。
- en: '![Stack and heap](img/7324_02_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![堆栈和堆](img/7324_02_03.jpg)'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In C++, when an object is about to be destroyed its destructor will be executed.
    The closest thing Java has to this is the `finalize` method, which will execute
    when the object is processed by the garbage collector. However, the garbage collector
    may not run and, thus, the `finalize` method may never execute. This paradigm
    shift results in an important difference in how we manage resources. The try-with-resources
    block introduced in [Chapter 8](ch08.html "Chapter 8. Handling Exceptions in an
    Application"), *Handling Exceptions in an Application*, offers a technique for
    dealing with this situation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当对象即将被销毁时，其析构函数将被执行。Java最接近的是`finalize`方法，当对象被垃圾收集器处理时将执行。但是，垃圾收集器可能不会运行，因此`finalize`方法可能永远不会执行。这种范式转变导致了我们在资源管理方面的重要差异。[第8章](ch08.html
    "第8章。应用程序中的异常处理")中介绍的“try-with-resources”块，*应用程序中的异常处理*，提供了一种处理这种情况的技术。
- en: Declaring a variable
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: A variable is also called an identifier. The term "variable" implies that its
    value can be changed. This is usually the case. However, if the identifier is
    declared as a constant, as discussed in the *Constants* section, then it is not
    really a variable. Regardless of this, the terms variable and identifier are normally
    considered to be synonymous.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也称为标识符。术语“变量”意味着它的值可以更改。这通常是这样的。但是，如果标识符被声明为常量，如*常量*部分所讨论的那样，那么它实际上不是一个变量。尽管如此，变量和标识符这两个术语通常被认为是同义词。
- en: The declaration of a variable begins with the data type and is followed by the
    variable name and then a semicolon. The data type may be a primitive data type
    or a class. When the data type is a class, the variable is an object reference
    variable. That is, it is a reference to an object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的声明以数据类型开头，然后是变量名，然后是分号。数据类型可以是原始数据类型或类。当数据类型是类时，变量是对象引用变量。也就是说，它是对对象的引用。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A reference variable is effectively a disguised C pointer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量实际上是一个伪装的C指针。
- en: 'Variables can be classified into the following three categories:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以分为以下三类：
- en: Instance variables
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量
- en: Static variables
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量
- en: Local variables
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量
- en: Instance variables are used to reflect the state of the object. Static variables
    are variables that are common to all instances. Local variables are declared within
    a method and are visible only within the block in which they are declared.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量用于反映对象的状态。静态变量是所有实例共有的变量。局部变量在方法内声明，只在声明它们的块中可见。
- en: 'Identifiers are case-sensitive and can only be composed of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符区分大小写，只能由以下内容组成：
- en: Letters, numbers, the underscore (_) and the dollar sign ($)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母、数字、下划线（_）和美元符号（$）
- en: Identifiers may only begin with a letter, the underscore or a dollar sign
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符只能以字母、下划线或美元符号开头
- en: 'Examples of valid variable names include:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的变量名示例包括：
- en: '`numberWheels`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numberWheels`'
- en: '`ownerName`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ownerName`'
- en: '`mileage`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mileage`'
- en: '`_byline`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_byline`'
- en: '`numberCylinders`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numberCylinders`'
- en: '`$newValue`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$newValue`'
- en: '`_engineOn`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_engineOn`'
- en: 'By convention, identifiers and methods start with the first word in lower case
    and subsequent words capitalized as discussed in the *Java naming conventions*
    section of [Chapter 1](ch01.html "Chapter 1. Getting Started with Java"), *Getting
    Started with Java*. Examples of conventional declarations include the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，标识符和方法以小写字母开头，后续单词大写，如[第1章](ch01.html "第1章. Java入门")中的*Java命名约定*部分所讨论的那样。常规声明的示例包括以下内容：
- en: '`int numberWheels;`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int numberWheels;`'
- en: '`int numberCylinders;`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int numberCylinders;`'
- en: '`float mileage;`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float mileage;`'
- en: '`boolean engineOn;`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean engineOn;`'
- en: '`int $newValue;`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int $newValue;`'
- en: '`String ownerName;`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String ownerName;`'
- en: '`String _byline;`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String _byline;`'
- en: 'In the preceding examples, each variable, except the last two, is declared
    as a primitive data type. The last one is declared as a reference to a `String`
    object. The reference variable can reference a `String` object but, in this example,
    is assigned a `null` value meaning that it is does not currently reference a string.
    Strings are covered in more detail in the *The String class* section. The following
    code snippet declares three variables of type integer:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，除了最后两个变量外，每个变量都声明为原始数据类型。最后一个声明为对`String`对象的引用。引用变量可以引用`String`对象，但在这个示例中，它被赋予了一个`null`值，这意味着它当前没有引用字符串。字符串在*String类*部分中有更详细的介绍。以下代码片段声明了三个整数类型的变量：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is also possible to declare all three variables on a single line, shown
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在一行上声明所有三个变量，如下所示：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Primitive data types
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: 'There are eight primitive data types defined in Java, as listed in the following
    table. In Java, the size of each of the data types is the same for all machines:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java中定义了八种原始数据类型，如下表所示。在Java中，每种数据类型的大小对所有机器来说都是相同的：
- en: '| Data type | Size in bytes | Internal representation | Range |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 字节大小 | 内部表示 | 范围 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `boolean` | -- | Not precisely defined | `true` or `false` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | -- | 没有精确定义 | `true` 或 `false` |'
- en: '| `byte` | 1 | 8-bit two''s complement | `−128` to `+127` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 1 | 8位二进制补码 | `-128` 到 `+127` |'
- en: '| `char` | 2 | Unicode | `\u0000` to `\uffff` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 2 | Unicode | `\u0000` 到 `\uffff` |'
- en: '| `short` | 2 | 16-bit two''s complement | `–32768` to `32767` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 2 | 16位二进制补码 | `-32768` 到 `32767` |'
- en: '| `int` | 4 | 32-bit two''s complement | `−2,147,483,648` to `2,147,483,647`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 4 | 32位二进制补码 | `-2,147,483,648` 到 `2,147,483,647` |'
- en: '| `long` | 8 | 64-bit two''s complement | `-9,223,372,036,854,775,808` to`9,223,372,036,854,775,807`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 8 | 64位二进制补码 | `-9,223,372,036,854,775,808` 到 `9,223,372,036,854,775,807`
    |'
- en: '| `float` | 4 | 32-bit IEEE 754 floating point | `3.4e +/- 38` (7 digits) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 4 | 32位IEEE 754浮点数 | `3.4e +/- 38`（7位数字） |'
- en: '| `double` | 8 | 64-bit IEEE 754 floating point | `1.7e +/- 308` (15 digits)
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 8 | 64位IEEE 754浮点数 | `1.7e +/- 308`（15位数字） |'
- en: The `String` data type is also a part of Java. While it is not a primitive data
    type, it is a class and is discussed in detail in the *The String class* section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`数据类型也是Java的一部分。虽然它不是原始数据类型，但它是一个类，并且在*String类*部分中有详细讨论。'
- en: Another common data type is currency. There are several ways of representing
    money in Java as detailed in the following table. However, the recommended approach
    is to use the `BigDecimal` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的数据类型是货币。在Java中，有几种表示货币的方式，如下表所述。然而，推荐的方法是使用`BigDecimal`类。
- en: '| Data type | Advantages | Disadvantages |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 优点 | 缺点 |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Integer | Good for simple currency units, such as a penny. | It does not
    use a decimal point, such as that used in dollars and cents. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 适用于简单的货币单位，如一分钱。 | 它不使用小数点，如美元和美分中使用的那样。 |'
- en: '| Floating point | It uses a decimal point. | Rounding errors are very common.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | 使用小数点 | 舍入误差非常常见。 |'
- en: '| `BigDecimal` class |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `BigDecimal`类 |'
- en: Handles large numbers.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大数字。
- en: Uses decimal points.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小数点。
- en: Has built-in rounding modes.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有内置的舍入模式。
- en: '| More difficult to use. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 更难使用。 |'
- en: 'When using `BigDecimal`, it is important to note the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`BigDecimal`时，重要的是要注意以下几点：
- en: Use the constructor with the `String` argument as it does a better job at placing
    the decimal point
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有`String`参数的构造函数，因为它在放置小数点时做得更好
- en: '`BigDecimal` is immutable'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigDecimal`是不可变的'
- en: The `ROUND_HALF_EVEN` rounding mode introduces the least bias
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROUND_HALF_EVEN`舍入模式引入了最小偏差'
- en: The `Currency` class is used to control the formatting of currency.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Currency`类用于控制货币的格式。'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Another recommendation regarding currency representation is based on the number
    of digits used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于货币表示的另一个建议是基于使用的数字位数。
- en: '**Number of digits** **Recommended data type**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字位数** **推荐的数据类型**'
- en: Less than 10 Integer or `BigDecimal`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 小于10的整数或`BigDecimal`
- en: Less than 19 Long or `BigDecimal`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 小于19的长整型或`BigDecimal`
- en: Greater than 19 `BigDecimal`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大于19 `BigDecimal`
- en: 'Floating point numbers can be a significant source of problems in most languages.
    Consider the following snippets where we add `0.1` in an attempt to get the value
    `1.0`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，浮点数可能是问题的重要来源。考虑以下片段，我们在尝试获得值`1.0`时添加`0.1`：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It reflects the fact that the decimal value `0.1` cannot be accurately represented
    in base two. This means we must always be vigilant when working with floating
    point numbers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它反映了十进制值`0.1`无法在二进制中准确表示的事实。这意味着我们在使用浮点数时必须时刻保持警惕。
- en: Wrapper classes and autoboxing
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装类和自动装箱
- en: 'Wrapper classes are used to enclose primitive data type values inside an object.
    Prior to the availability of boxing, there were often situations where it was
    necessary to explicitly use wrapper classes such as the `Integer` and `Float`
    classes. This was required to be able to add primitive data types to collections
    often found in the `java.util` package, including the `ArrayList` class, because
    methods of these data classes used objects as arguments. Wrapper classes include
    the following data types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类用于将原始数据类型值封装在对象中。在装箱可用之前，通常需要显式使用包装类，如`Integer`和`Float`类。这是为了能够将原始数据类型添加到`java.util`包中经常出现的集合中，包括`ArrayList`类，因为这些数据类的方法使用对象作为参数。包装类包括以下数据类型：
- en: Boolean
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Byte
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节
- en: Character
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符
- en: Short
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短
- en: Integer
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Long
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长
- en: Float
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点
- en: Double
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双
- en: Objects of these wrapper classes are immutable. That is, their values cannot
    be changed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装类的对象是不可变的。也就是说，它们的值不能被改变。
- en: '**Autoboxing** is the automatic conversion of primitive data types into their
    corresponding wrapper classes. This is performed as needed so as to eliminate
    the need to perform trivial, explicit conversion between primitive data types
    and their corresponding wrapper classes. **Unboxing** refers to the automatic
    conversion of a wrapper object to its equivalent primitive data type. In effect,
    primitive data types are treated as if they are objects in most situations.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动装箱**是将原始数据类型自动转换为其对应的包装类的过程。这是根据需要执行的，以消除在原始数据类型和其对应的包装类之间执行琐碎的显式转换的需要。**取消装箱**是指将包装对象自动转换为其等效的原始数据类型。实际上，在大多数情况下，原始数据类型被视为对象。'
- en: 'There are a few things to remember when working with primitives and objects.
    First, objects can be `null`, whereas primitives cannot be assigned a `null` value.
    This can present problems from time to time. For example, unboxing a null object
    will result in a `NullPointerException`. Also, be careful when comparing primitives
    and objects when boxing does not occur as illustrated in the following table:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理原始值和对象时有一些需要记住的事情。首先，对象可以是`null`，而原始值不能被赋予`null`值。这有时可能会带来问题。例如，取消装箱一个空对象将导致`NullPointerException`。此外，在比较原始值和对象时要小心，当装箱不发生时，如下表所示：
- en: '| Comparison | Two primitives | Two objects | One of each |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 两个原始值 | 两个对象 | 一个原始值和一个对象 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `a == b` | Simple comparison | Compares reference values | Treated as two
    primitives |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `a == b` | 简单比较 | 比较引用值 | 被视为两个原始值 |'
- en: '| `a.equals(b)` | Will not compile | Compares for equality of values | Will
    not compile if a is a primitive, otherwise their values are compared |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `a.equals(b)` | 不会编译 | 比较值的相等性 | 如果a是原始值，否则它们的值将被比较 |'
- en: Initializing identifiers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化标识符
- en: 'The initialization of Java variables is actually a complex process. Java supports
    four ways of initializing variables:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Java变量的初始化实际上是一个复杂的过程。Java支持四种初始化变量的方式：
- en: Default initial values
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认初始值
- en: Instance variable initializers
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量初始化程序
- en: Instance initializers
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例初始化程序
- en: Constructors
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: In this chapter we will examine the first two approaches. The latter two techniques
    are covered in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"),
    *Classes, Constructors, and Methods*, where the whole initialization process is
    put together.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究前两种方法。后两种技术在[第6章](ch06.html "第6章。类，构造函数和方法")中进行了介绍，*类，构造函数和方法*，在那里整个初始化过程被整合在一起。
- en: 'When explicit values are not provided, initial default values are used as the
    object is created. In general, when a field of an object is allocated it is initialized
    to a zero value as detailed in the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当未提供显式值时，对象创建时使用初始默认值。一般来说，当对象的字段被分配时，它会被初始化为零值，如下表所述：
- en: '| Data type | Default value (for fields) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 默认值（对于字段） |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` | `false` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `false` |'
- en: '| `byte` | `0` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `0` |'
- en: '| `char` | `''`\`u0000''` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `''`\`u0000''` |'
- en: '| `short` | `0` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `0` |'
- en: '| `int` | `0` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `0` |'
- en: '| `long` | `0L` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `0L` |'
- en: '| `float` | `0.0f` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `0.0f` |'
- en: '| `double` | `0.0d` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `0.0d` |'
- en: '| `String` (or any object) | `null` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `String`（或任何对象） | `null` |'
- en: 'For example, in the following class, `name` is assigned `null` and `age` has
    a value of `0`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下类中，`name`被赋予`null`，`age`的值为`0`：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The instance variable initializers'' operator can be used to explicitly assign
    a value to a variable. Consider the following variation of the `Person` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量初始化程序的运算符可以用来显式地为变量分配一个值。考虑`Person`类的以下变化：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When an object of type `Person` is created, the `name` and `age` fields are
    assigned the values `John Doe` and `23` respectively.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`Person`类型的对象时，`name`和`age`字段分别被赋予值`John Doe`和`23`。
- en: However, when a local variable is declared, it is not initialized. It is, therefore,
    important to either use the initialization operator when declaring the variable
    or to not use the variable until a value has been assigned to it. Otherwise, a
    syntax error will result.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当声明一个局部变量时，它不会被初始化。因此，重要的是要在声明变量时使用初始化运算符，或者在为其分配值之前不使用该变量。否则，将导致语法错误。
- en: Java constants, literals, and enumerations
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java常量，字面量和枚举
- en: Constants and literals are similar in that they cannot be changed. A variable
    can be declared using the `final` keyword as a primitive data type that cannot
    change and is, thus, referred to as a constant. A literal is a token such as `35`
    or `'C'` which represents a value. Obviously, it cannot be modified either. Related
    to this concept are immutable objects—objects which cannot be modified. While
    the object cannot be modified, the reference variable pointing to the object can
    be changed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和字面量在不能被更改方面是相似的。变量可以使用`final`关键字声明为不能更改的原始数据类型，因此被称为常量。字面量是表示值的标记，例如`35`或`'C'`。显然，它也不能被修改。与此概念相关的是不可变对象——不能被修改的对象。虽然对象不能被修改，但指向对象的引用变量可以被更改。
- en: Enumerations are also effectively constant in nature. They are used to provide
    a convenient way of dealing with sets of values as a list. For example, an enumeration
    can be created to represent the suits of a card deck.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在本质上也是常量。它们用于提供一种方便的方式来处理值的集合作为列表。例如，可以创建一个枚举来表示一副牌的花色。
- en: Literals
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面量
- en: 'Literal constants are simple numbers, characters, and strings that represent
    a quantity. There are three basic types:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 字面常量是表示数量的简单数字、字符和字符串。有三种基本类型：
- en: Numeric
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Character
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符
- en: Strings
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Numeric literals
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字字面量
- en: Numeric constants consist of a series of digits with an optional sign and an
    optional decimal point. Numeric literals that contain a decimal point are by default
    `double` constants. Numeric constants can also be prefixed with a `0x` to indicate
    the number is a hexadecimal number (base 16). Numbers that begin with a `0` are
    octal numbers (base 8). A suffix of `f` or `F` can be used to declare a floating
    point literal as of type `float`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数字常量由一系列数字组成，可选的符号和可选的小数点。包含小数点的数字字面量默认为`double`常量。数字常量也可以以`0x`为前缀表示为十六进制数（基数16）。以`0`开头的数字是八进制数（基数8）。后缀`f`或`F`可以用来声明浮点字面量的类型为`float`。
- en: '| Numeric literal | Base | Data type | Decimal equivalent |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 数字字面量 | 基数 | 数据类型 | 十进制等价 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `25` | 10 | `int` | `25` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `25` | 10 | `int` | `25` |'
- en: '| `-235` | 10 | `int` | `-235` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `-235` | 10 | `int` | `-235` |'
- en: '| `073` | 8 | `int` | `59` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `073` | 8 | `int` | `59` |'
- en: '| `0x3F` | 16 | `int` | `63` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `0x3F` | 16 | `int` | `63` |'
- en: '| `23.5` | 10 | `double` | `23.5` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `23.5` | 10 | `double` | `23.5` |'
- en: '| `23.5f` | 10 | `float` | `23.5` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `23.5f` | 10 | `float` | `23.5` |'
- en: '| `23.5F` | 10 | `float` | `23.5` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `23.5F` | 10 | `float` | `23.5` |'
- en: '| `35.05E13` | 10 | `double` | `350500000000.00` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `35.05E13` | 10 | `double` | `350500000000.00` |'
- en: 'Integer literals are common. Normally they are expressed in base 10, but octal
    and hexadecimal literals can be created using the appropriate prefix. Integer
    literals are of type `int` by default. A literal can be specified as type `long`
    by appending an L to the end of the literal. The following table illustrates literals
    and their corresponding data types:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量很常见。通常它们以十进制表示，但可以使用适当的前缀创建八进制和十六进制字面量。整数字面量默认为`int`类型。可以通过在字面量的末尾添加L来指定字面量的类型为`long`。下表说明了字面量及其对应的数据类型：
- en: '| Literal | Type |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 字面量 | 类型 |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `45` | `int` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `45` | `int` |'
- en: '| `012` | An integer expressed as an octal number. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `012` | 以八进制数表示的整数。 |'
- en: '| `0x2FFC` | An integer expressed as a hexadecimal number. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `0x2FFC` | 以十六进制数表示的整数。 |'
- en: '| `10L` | `long` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `10L` | `long` |'
- en: '| `0x10L` | A long expressed as a hexadecimal number. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `0x10L` | 以十六进制数表示的长整型。 |'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Either a lowercase or uppercase L can be used to designate an integer as type
    long. However, it is better to use an uppercase L to avoid confusing the letter
    with the numeric digit "1" (one). In the following example, an unwary reader might
    see the literal as one hundred and one versus the integer 10:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用小写或大写的L来指定整数的长整型类型。但最好使用大写的L，以避免将字母与数字1混淆。在下面的例子中，一个不小心的读者可能会将字面量看作是一百零一，而不是整数10：
- en: '`10l` versus `10L`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`10l`与`10L`'
- en: Floating point literals are numbers that contain a decimal point or those that
    are written using scientific notation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点字面量是包含小数点的数字，或者使用科学计数法写成的数字。
- en: '| Literal | Type |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 字面量 | 类型 |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `3.14` | `double` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `3.14` | `double` |'
- en: '| `10e6` | `double` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `10e6` | `double` |'
- en: '| `0.042F` | `float` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `0.042F` | `float` |'
- en: Java 7 added the ability to uses underscore characters (`_`) in numeric literals.
    This enhances the readability of code by adding a visual spacing between significant
    parts of a literal. Underscores can be added almost anywhere with a numeric literal.
    It can be used with floating point numbers and with any integer base (binary,
    octal, hexadecimal, or decimal). In addition, base 2 literal are also supported.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7增加了在数字字面量中使用下划线字符（`_`）的能力。这通过在字面量的重要部分之间添加可视间距来增强代码的可读性。下划线可以几乎添加到数字字面量的任何位置。它可以与浮点数和任何整数基数（二进制、八进制、十六进制或十进制）一起使用。此外，还支持基数2字面量。
- en: 'The following table illustrates the use of underscores with a variety of numeric
    literals:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下表说明了在各种数字字面量中使用下划线的情况：
- en: '| Example | Usage |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 用法 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `111_22_3333` | Social security number |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `111_22_3333` | 社会安全号码 |'
- en: '| `1234_5678_9012_3456` | Credit card number |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `1234_5678_9012_3456` | 信用卡号码 |'
- en: '| `0b0110_00_1` | Binary literal representing a byte |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0b0110_00_1` | 代表一个字节的二进制字面量 |'
- en: '| `3._14_15F` | PI |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `3._14_15F` | 圆周率 |'
- en: '| `0xE_44C5_BC_5` | Hexadecimal literal for a 32-bit quantity |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0xE_44C5_BC_5` | 32位数量的十六进制字面量 |'
- en: '| `0450_123_12` | 24-bit octal literal |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `0450_123_12` | 24位八进制字面量 |'
- en: 'The use of literals in code has no effect on the internal representation of
    the number or how it is displayed. For example, if we use a long literal to represent
    a social security number, the number is stored internally in two''s complement
    notation and will be displayed as an integer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用字面量对数字的内部表示或显示方式没有影响。例如，如果我们使用长整型字面量表示社会安全号码，该数字在内部以二进制补码表示，并显示为整数：
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If it is necessary to display the number formatted as a social security number,
    this needs to be done in code. The following is one of the approaches to this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要以社会安全号码的格式显示数字，需要在代码中进行。以下是其中一种方法：
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When executed, we get the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The use of the underscore is to make the code more readable to the developer
    but it is ignored by the compiler.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的使用是为了使代码对开发人员更易读，但编译器会忽略它。
- en: 'There are a couple of other things to consider when using underscores in literals.
    First, consecutive underscores are treated as one and also ignored by the compiler.
    Also, underscores cannot be placed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文字中的下划线时，还有一些其他要考虑的事情。首先，连续的下划线被视为一个，并且也被编译器忽略。此外，下划线不能放置在：
- en: At the beginning or end of a number
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字的开头或结尾
- en: Adjacent to a decimal point
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧邻小数点
- en: Prior to the `D`, `F`, or `L` suffix
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`D`、`F`或`L`后缀之前
- en: 'The following table illustrates invalid usage of the underscores. These will
    generate the syntax error: `illegal underscore`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格说明了下划线的无效用法。这些将生成语法错误：`非法下划线`：
- en: '| Example | Problem |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 例子 | 问题 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `_123_6776_54321L` | Cannot begin with an underscore |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `_123_6776_54321L` | 不能以下划线开头 |'
- en: '| `0b0011_1100_` | Cannot end with an underscore |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `0b0011_1100_` | 不能以下划线结尾 |'
- en: '| `3._14_15F` | Cannot be adjacent to a decimal point |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `3._14_15F` | 不能紧邻小数点 |'
- en: '| `987_654_321_L` | Cannot be adjacent to an `L` suffix |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `987_654_321_L` | 不能紧邻`L`后缀 |'
- en: 'Some applications need to manipulate the bits of a value. The following example
    will perform a bitwise AND operation against a value using a mask. A mask is a
    sequence of bits that are used to isolate part of another value. In this example,
    `value` represents a bit sequence whose last four bits we wish to isolate. The
    binary literal represents the mask:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序需要操作值的位。以下示例将对一个值使用掩码执行位AND操作。掩码是一系列用于隔离另一个值的一部分的位。在这个例子中，`value`代表一个希望隔离最后四位的位序列。二进制文字代表掩码：
- en: '[PRE11]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The AND operation will return zeroes when ANDed with a mask containing zeroes.
    In the preceding example, the first four bits of result of the expression will
    be zeroes. The last four bits are ANDed with ones which result in the last four
    bits of the result being the same as the last four bits of value. Thus, the last
    four bits have been isolated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当与包含零的掩码进行AND操作时，AND操作将返回零。在前面的例子中，表达式的前四位将是零。最后四位与一进行AND操作，结果是结果的最后四位与值的最后四位相同。因此，最后四位已被隔离。
- en: 'This is illustrated by executing the following code sequence:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下代码序列来说明：
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When executed we get the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following diagram illustrates this AND operation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这个AND操作：
- en: '![Numeric literals](img/7324_02_04.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![数字文字](img/7324_02_04.jpg)'
- en: Character literals
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符文字
- en: Character literals are single characters enclosed in single quotes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 字符文字是用单引号括起来的单个字符。
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, one or more symbols can be used to represent a character. The backslash
    character is used to "escape" or give special meaning to a letter. For example,
    `''\n''` represents the carriage return line feed character. These special escape
    sequences represent certain special values. These escape sequences can also be
    used within a string literal. Escape sequence characters are listed in the following
    table:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个或多个符号可以用来表示一个字符。反斜杠字符用于“转义”或赋予字母特殊含义。例如，`'\n'`代表回车换行字符。这些特殊的转义序列代表特定的特殊值。这些转义序列也可以在字符串文字中使用。转义序列字符列在下表中：
- en: '| Escape Sequence Character | Meaning |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列字符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\a` | alert (bell) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | 警报（响铃） |'
- en: '| `\b` | backspace |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格 |'
- en: '| `\f` | form feed |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页 |'
- en: '| `\n` | new line |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行 |'
- en: '| `\r` | carriage return |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车 |'
- en: '| `\t` | horizontal tab |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 |'
- en: '| `\v` | vertical tab |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `\v` | 垂直制表符 |'
- en: '| `\\` | backslash |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\?` | question mark |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `\?` | 问号 |'
- en: '| `\''` | single quote |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 |'
- en: '| `\"` | double quote |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\ooo` | octal number |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `\ooo` | 八进制数 |'
- en: '| `\xhh` | hexadecimal number |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `\xhh` | 十六进制数 |'
- en: String literals
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串文字
- en: 'String literals are a sequence of characters that are enclosed in a set of
    double quotes. String literals cannot be split across two lines:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字是一系列用双引号括起来的字符。字符串文字不能跨两行分割：
- en: '[PRE15]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Constants
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: Constants are identifiers whose values cannot change. They are used in situations
    where, instead of using a literal, a more readable name should be used instead.
    In Java, constants are declared by prefixing the variable declaration with the
    `final` keyword.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是其值不能改变的标识符。它们用于情况，其中应该使用更易读的名称而不是使用文字。在Java中，常量是通过在变量声明前加上`final`关键字来声明的。
- en: 'In the following example, three constants are declared—`PI`, `NUMSHIPS`, and
    `RATEOFRETURN`. Each of these is capitalized as per the standard *Java naming
    conventions* section of [Chapter 1](ch01.html "Chapter 1. Getting Started with
    Java"), *Getting Started with Java*, and is given a value. These values cannot
    be changed:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，声明了三个常量——`PI`、`NUMSHIPS`和`RATEOFRETURN`。根据标准*Java命名约定*第[第1章](ch01.html
    "第1章. 开始使用Java")的*开始使用Java*部分，每个常量都是大写的，并赋予一个值。这些值不能被改变：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following statement, an attempt is made to change the value of PI:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的语句中，试图改变PI的值：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Depending on the compiler, an error message similar to the following will be
    generated:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编译器的不同，将生成类似以下的错误消息：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means you cannot change the value of the constant variable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您不能改变常量变量的值。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Constants provide other benefits apart from always having the same value. A
    constant number or object can be handled more efficiently and optimized. This
    makes the application that uses them more efficient and easier to understand.
    Instead of using 3.14159 every place it is needed, we can simply use `PI`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 常量除了始终具有相同的值之外，还提供其他好处。常量数字或对象可以更有效地处理和优化。这使得使用它们的应用程序更有效和更易于理解。我们可以简单地使用“PI”而不是在需要的每个地方使用3.14159。
- en: The final keyword
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: final关键字
- en: 'While the `final` keyword is used to declare a constant, it has other uses
    as detailed in the following table. We will cover its use with methods and classes
    in later chapters:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“final”关键字用于声明常量，但它还有其他用途，如下表所述。我们将在后面的章节中介绍它在方法和类中的用法：
- en: '| Applied to | Meaning |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 应用于 | 意义 |'
- en: '| --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Primitive data declaration | The value assigned to the variable cannot be
    changed. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据声明 | 分配给变量的值无法更改。 |'
- en: '| Reference variable | You cannot change the variable to reference a different
    variable. However, it may be possible to change the object the variable is referencing
    to. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 引用变量 | 无法更改变量以引用不同的变量。但是，可能可以更改变量引用的对象。 |'
- en: '| Method | The method cannot be overridden. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 该方法无法被覆盖。 |'
- en: '| Class | The class cannot be extended. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 该类无法被扩展。 |'
- en: Enumerations
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations are actually subclasses of the `java.lang.Enum` class. In this
    section, we will look at the creation of a simple enumeration. A more complete
    treatment of this topic is found in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举实际上是`java.lang.Enum`类的子类。在本节中，我们将看一下简单枚举的创建。有关此主题的更完整处理，请参阅[第6章](ch06.html
    "第6章。类，构造函数和方法")中的*类，构造函数和方法*。
- en: The following example declares an enumeration called `Directions`. This enumeration
    represents the four cardinal points.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了一个名为“Directions”的枚举。此枚举表示四个基本点。
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can declare a variable of this type and then assign values to it. The following
    code sequence illustrates this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明此类型的变量，然后为其分配值。以下代码序列说明了这一点：
- en: '[PRE20]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of this sequence is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列的输出如下：
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `enum` call also can be used as part of a switch statement illustrated as
    follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`调用也可以作为switch语句的一部分，如下所示：'
- en: '[PRE22]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When executed with the previous code we get the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在与前面的代码一起执行时，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Immutable objects
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变对象
- en: Immutable objects are objects whose fields cannot be modified. There are several
    classes whose objects are immutable in the Java core SDK including the `String`
    class. Perhaps surprisingly, the `final` keyword is not used for this purpose.
    These are discussed in more detail in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是其字段无法修改的对象。在Java核心SDK中有几个类的对象是不可变的，包括“String”类。也许令人惊讶的是，“final”关键字并未用于此目的。这些将在[第6章](ch06.html
    "第6章。类，构造函数和方法")中详细讨论，*类，构造函数和方法*。
- en: Instance versus static data
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例与静态数据
- en: 'There are two different types of variables (data) within a class: instance
    and static. When an object is instantiated (using the `new` keyword with a class
    name), each object is composed of the instance variables that make up that class.
    However, there is only one copy of static variables allocated for each class.
    While each class has its own copy of instance variables, all of the classes share
    a single copy of the static variables. These static variables are allocated to
    a separate area of memory and exist for the lifetime of the class.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 类中有两种不同类型的变量（数据）：实例和静态。当实例化对象（使用类名的“new”关键字）时，每个对象由组成该类的实例变量组成。但是，为每个类分配了静态变量的唯一副本。虽然每个类都有其自己的实例变量副本，但所有类共享静态变量的单个副本。这些静态变量分配到内存的一个单独区域，并且存在于类的生命周期内。
- en: 'Consider the addition of a common discount percentage that may be applied selectively
    to some, but not all, customers. Regardless of whether or not it is applied, the
    percentage is always the same. Based on these assumptions, we can add a static
    variable to a class as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑添加一个可以选择性地应用于某些客户的常见折扣百分比，但不是所有客户。无论是否应用，百分比始终相同。基于这些假设，我们可以将静态变量添加到类中，如下所示：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Static methods and fields are covered in more detail in [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和字段在[第6章](ch06.html "第6章。类，构造函数和方法")中有更详细的介绍，*类，构造函数和方法*。
- en: Scope and lifetime
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和生命周期
- en: Scope refers to where in a program a specific variable can be used. In general,
    a variable is visible within the block statement in which it is declared but not
    outside it. A block statement is a sequence of code encapsulated by curly braces.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 范围指的是程序中特定变量可以使用的位置。一般来说，变量在其声明的块语句内可见，但在其外部不可见。块语句是由花括号封装的代码序列。
- en: If a variable is in scope, then it is visible to the code and can be accessed.
    If it is not in scope, then the variable cannot be accessed and any attempts to
    do so will result in a compile-time error.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量在范围内，则对代码可见并且可以访问。如果不在范围内，则无法访问变量，并且任何尝试这样做都将导致编译时错误。
- en: The lifetime of a variable refers to the time period in which it has been allocated
    memory. When a variable is declared as a local variable of a method, the memory
    allocated to the variable is in the activation record. As long as the method has
    not returned, the activation record exists and memory is allocated for the variable.
    As soon as the method returns, the activation record is removed from the stack
    and the variable is no longer in existence and cannot be used.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的生命周期是指其分配了内存的时间段。当变量声明为方法的局部变量时，分配给变量的内存位于激活记录中。只要方法尚未返回，激活记录就存在，并且为变量分配内存。一旦方法返回，激活记录就从堆栈中移除，变量就不再存在，也无法使用。
- en: The lifetime of an object allocated from the heap begins when the memory is
    allocated and ends when the memory is de-allocated. In Java, memory is allocated
    for an object using the `new` keyword. An object and its memory are marked for
    de-allocation when it is no longer referenced. In reality, it is de-allocated
    at some indeterminate point in the future when a garbage collection routine runs,
    if at all. If an object has no references to it, it can be used or accessed even
    if the garbage collector has not reclaimed it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中分配的对象的生命周期始于分配内存时，终止于释放内存时。在Java中，使用`new`关键字为对象分配内存。当对象不再被引用时，对象及其内存被标记为释放。实际上，如果对象没有被回收，它将在未来的某个不确定的时间点被释放，如果有的话。如果一个对象没有引用，即使垃圾收集器尚未回收它，它也可以被使用或访问。
- en: Scoping rules
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域规则
- en: Scoping rules are critical to understanding how block structure languages, such
    as Java, work. These rules explain when a variable can be used and which one of
    the several will be used when a naming conflict occurs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域规则对于理解诸如Java之类的块结构语言的工作方式至关重要。这些规则解释了变量何时可以使用，以及在命名冲突发生时将使用哪一个。
- en: 'Scoping rules revolve around the concept of a block. A block is delineated
    by an opening and closing curly brace. These blocks are used to group code together
    and to define the scope of a variable. The following diagram shows the scope of
    three variables, `i`, `j`, and `k`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域规则围绕着块的概念。块由开放和闭合的大括号界定。这些块用于将代码分组在一起，并定义变量的范围。以下图表显示了三个变量`i`，`j`和`k`的范围：
- en: '![Scoping rules](img/7324_02_05.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![作用域规则](img/7324_02_05.jpg)'
- en: Access modifiers
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: 'Access modifiers can be used as prefixes when declaring instance and static
    variables and methods. Modifiers are applied in various combinations to provide
    specific behaviors. The modifier order is not always important, but consistent
    style leads to more readable code. All modifiers are optional though there are
    some default modifiers. Access modifiers include:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明实例和静态变量和方法时，可以使用访问修饰符作为前缀。修饰符以各种组合应用以提供特定的行为。修饰符的顺序并不总是重要的，但一致的风格会导致更可读的代码。所有修饰符都是可选的，尽管有一些默认修饰符。访问修饰符包括：
- en: '`public`: A public object is visible to all methods inside and outside its
    own class.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：公共对象对其自身类内外的所有方法可见。'
- en: '`protected`: This allows protection between the current class and subclasses.
    A protected object is invisible outside *-the class, fully visible to subclasses.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：这允许在当前类和子类之间进行保护。受保护的对象在类外是不可见的，对子类完全可见。'
- en: '`private`: A private variable cannot be seen by any class other than the one
    in which it is defined (including subclasses).'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：私有变量只能被定义它的类（包括子类）看到。'
- en: '**package**: This visibility is the default protection. Only classes within
    the package have the access (public within the package).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：这种可见性是默认保护。只有包内的类才有访问权限（包内公共）。'
- en: 'To explain the scope of variables, consider the package/class organization
    shown in the following diagram, where the arrows indicate inheritance:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释变量的作用域，请考虑以下图表中显示的包/类组织，箭头表示继承：
- en: '![Access modifiers](img/7324_02_05a.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![访问修饰符](img/7324_02_05a.jpg)'
- en: 'Assume that the A class is defined as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设A类定义如下：
- en: '[PRE25]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All of the variables are of type `int`. The `publicInt` variable is a public
    variable. It can be seen by all methods inside and outside of this class. The
    `privateInt` variable is only visible within this class. The `protectedInt` variable
    is visible only to those classes within this package. The `protectedInt` variable
    is visible to this class, its subclasses, and other classes in the same package.
    It is not visible elsewhere. The following table shows the visibility of each
    of the declaration types to each of the classes:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都是`int`类型。`publicInt`变量是公共变量。它可以被这个类内外的所有方法看到。`privateInt`变量只在这个类内可见。`protectedInt`变量只对这个包内的类可见。`protectedInt`变量对这个类、它的子类和同一个包内的其他类可见。在其他地方是不可见的。以下表格显示了每种声明类型对每个类的可见性：
- en: '|   | A | B | C | D | E |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|   | A | B | C | D | E |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `publicInt` | Visible | Visible | Visible | Visible | Visible |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `publicInt` | 可见 | 可见 | 可见 | 可见 | 可见 |'
- en: '| `privateInt` | Visible | Invisible | Invisible | Invisible | Invisible |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `privateInt` | 可见 | 不可见 | 不可见 | 不可见 | 不可见 |'
- en: '| `protectedInt` | Visible | Visible | Visible | Invisible | Visible |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `protectedInt` | 可见 | 可见 | 可见 | 不可见 | 可见 |'
- en: '| `defaultInt` | Visible | Visible | Visible | Invisible | Invisible |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `defaultInt` | 可见 | 可见 | 可见 | 不可见 | 不可见 |'
- en: Data summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据摘要
- en: 'The following table summarizes the types of variables and their relationship
    to Java compile-time and run-time elements:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了变量类型及其与Java编译时和运行时元素的关系：
- en: '| Program element | Variable type | Part of | Allocated to |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 程序元素 | 变量类型 | 的一部分 | 分配给 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Class | Instance | Object | Heap |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 实例 | 对象 | 堆 |'
- en: '| Static | Class | Special region of memory |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 静态 | 类 | 内存的特殊区域 |'
- en: '| Method | Parameter | Activation record | Activation record of the stack |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 激活记录 | 栈的激活记录 |'
- en: '| Local |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 本地 |'
- en: Building expressions using operands and operators
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作数和运算符构建表达式
- en: 'An expression consists of operands and operators. Operands are normally variable
    names or literals while operators act on operands. The following are examples
    of expressions:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式由操作数和运算符组成。操作数通常是变量名或文字，而运算符作用于操作数。以下是表达式的示例：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are several ways of classifying operators:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种分类运算符的方法：
- en: Arithmetic
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术
- en: Assignment
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值
- en: Relational
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系
- en: Logical complement
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑补码
- en: Logical
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑
- en: Conditional
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件
- en: Bitwise
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位
- en: Expressions can be thought of as the building blocks of a program. They are
    used to express the logic of the program.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以被认为是程序的构建块。它们用于表达程序的逻辑。
- en: Precedence and associativity
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级和结合性
- en: 'Java operators are summarized in the following precedence and associativity
    table. Most of these operators are straightforward:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Java运算符总结如下优先级和结合性表。这些运算符中的大多数都很简单：
- en: '| Precedence | Operator | Associativity | Operator |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 优先级 | 运算符 | 结合性 | 运算符 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | `++` | Right | Pre/post increment |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `++` | 右 | 前/后增量 |'
- en: '| `--` | Right | Pre/post decrement |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 右 | 前/后减量 |'
- en: '| `+,-` | Right | Unary plus or minus |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `+,-` | 右 | 一元加或减 |'
- en: '| `~` | Right | Bitwise complement |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 右 | 位补 |'
- en: '| `!` | Right | Logical complement |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 右 | 逻辑补 |'
- en: '| (cast) | Right | Cast |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| (cast) | 右 | 强制转换 |'
- en: '| 2 | `*`, `/`, and `%` | Left | Multiplication, division, and modulus |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `*`, `/`, 和 `%` | 左 | 乘法、除法和取模 |'
- en: '| 3 | `+` and `-` | Left | Addition and subtraction |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `+` 和 `-` | 左 | 加法和减法 |'
- en: '| `+` | Left | String concatenation |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 左 | 字符串连接 |'
- en: '| 4 | `<<` | Left | Left shift |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `<<` | 左 | 左移 |'
- en: '| `>>` | Left | Right shift and sign fill |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 左 | 右移和符号填充 |'
- en: '| `>>>` | Left | Right shift and zero fill |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 左 | 右移和零填充 |'
- en: '| 5 | `<`, `<=`, `>`, `>=` | Left | Logical |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `<`, `<=`, `>`, `>=` | 左 | 逻辑 |'
- en: '| `Instanceof` | Left | Type comparison |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `Instanceof` | 左 | 类型比较 |'
- en: '| 6 | `==` and `!=` | Left | Equality and inequaltity |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `==` 和 `!=` | 左 | 相等和不相等 |'
- en: '| 7 | `&` | Left | Bitwise and Boolean AND |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `&` | 左 | 位和布尔与 |'
- en: '| 8 | `^` | Left | Bitwise and Boolean XOR |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `^` | 左 | 位和布尔异或 |'
- en: '| 9 | `&#124;` | Left | Bitwise and Boolean OR |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `|` | 左 | 位和布尔或 |'
- en: '| 10 | `&&` | Left | Boolean AND |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `&&` | 左 | 布尔与 |'
- en: '| 11 | `&#124;&#124;` | Left | Boolean OR |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `||` | 左 | 布尔或 |'
- en: '| 12 | `?:` | Right | Conditional |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `?:` | 右 | 条件 |'
- en: '| 13 | `=` | Right | Assignment |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `=` | 右 | 赋值 |'
- en: '| `+=`, `-=`, `*=`, `/=`, and `%=` | Right | Compound |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `+=`, `-=`, `*=`, `/=`, 和 `%=` | 右 | 复合 |'
- en: 'While the use of most of these operators is straightforward, more detailed
    examples for their usage are provided in later chapters. However, bear in mind
    that there are no other variations and no other operators available in Java. For
    example, `+=` is a valid operator while `=+` is not. However, it can be used with
    possibly unintended consequences. Consider the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数这些运算符的使用是直接的，但它们的更详细的用法示例将在后面的章节中提供。但请记住，在Java中没有其他变体和其他可用的运算符。例如，`+=`是一个有效的运算符，而`=+`不是。但是，它可能会带来意想不到的后果。考虑以下情况：
- en: '[PRE27]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last statement appears to be using a =+ operator. In reality, it is the
    assignment operator followed by the unary plus operator. A `+2` is assigned to
    `total`. Remember, Java ignores white space except within string literals.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句似乎使用了一个=+运算符。实际上，它是赋值运算符后面跟着的一元加运算符。一个`+2`被赋给`total`。请记住，Java会忽略除了字符串文字之外的空格。
- en: Casting
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制转换
- en: When one type of data is assigned to a different type of data, it is possible
    to lose information. If the data is being assigned from a more precise data type
    to a less precise data type, it is referred to as **narrowing** . For example,
    if the floating point number `45.607` is assigned to an integer, the fractional
    part, `.607`, is lost.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种类型的数据被分配给另一种类型的数据时，可能会丢失信息。如果数据从更精确的数据类型分配到不太精确的数据类型，就可能会发生**缩小**。例如，如果浮点数`45.607`被分配给整数，小数部分`.607`就会丢失。
- en: 'When making assignments of this type, the cast operator should be used. The
    cast operator is simply the data type that you are casting to, enclosed in parentheses.
    The following shows several explicit casting operations:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此类分配时，应使用强制转换运算符。强制转换运算符只是您要转换为的数据类型，括在括号中。以下显示了几个显式转换操作：
- en: '[PRE28]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Without the use of the cast operator in such situations, the compiler will issue
    a warning. The warning is there to suggest that you look more closely at the assignments.
    The loss of precision may or may not be a problem, depending upon the use of the
    data within the application. Without a cast operator, an implicit cast is made
    when the code is executed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有使用强制转换运算符，编译器将发出警告。警告是为了建议您更仔细地查看分配情况。精度的丢失可能是一个问题，也可能不是，这取决于应用程序中数据的使用。没有强制转换运算符，当代码执行时会进行隐式转换。
- en: Working with characters and strings
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符和字符串
- en: The primary classes include the `String`, `StringBuffer`, `StringBuilder`, and
    `Character` classes. There are several other classes and interfaces related to
    string and character manipulation, listed as follows, that you should be aware
    of. However, not all of the following classes will be detailed here.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 主要类包括`String`、`StringBuffer`、`StringBuilder`和`Character`类。还有几个与字符串和字符操作相关的其他类和接口，列举如下，您应该知道。但并非所有这些类都将在此处详细说明。
- en: '`Character`: This deals with the manipulation of character data'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character`：这涉及到字符数据的操作'
- en: '`Charset`: This defines a mapping between Unicode characters and a sequence
    of bytes'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charset`：这定义了Unicode字符和字节序列之间的映射'
- en: '`CharSequence`: In this, an interface is implemented by the `String`, `StringBuffer`
    and `StringBuilder` classes defining common methods'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharSequence`：在这里，一个接口由`String`、`StringBuffer`和`StringBuilder`类实现，定义了公共方法'
- en: '`StringTokenizer`: This is used for tokenizing text'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringTokenizer`：这用于对文本进行标记化'
- en: '`StreamTokenizer`: This is used for tokenizing text'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamTokenizer`：这用于对文本进行标记化'
- en: '`Collator`: This is used to support operations on locale specific strings'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collator`：这用于支持特定区域设置字符串的操作'
- en: The String, StringBuffer, and StringBuilder classes
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String、StringBuffer和StringBuilder类
- en: There are several string-related classes available to the Java programmer. In
    this section, we will examine the classes and techniques available in Java for
    manipulating this type of data.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java程序员，有几个与字符串相关的类可用。在本节中，我们将研究Java中用于操作此类数据的类和技术。
- en: The three primary classes for string manipulation found in the JDK are the `String`,
    `StringBuffer`, and `StringBuilder`. The `String` class is the most widely used
    of these classes. The `StringBuffer` and `StringBuilder` classes were introduced
    in Java 5 to address efficiency issues of the `String` class. The `String` class
    is immutable and an application that requires frequent changes to a string will
    be burdened by the overhead of having to create new immutable objects. The `StringBuffer`
    and `StringBuilder` classes are mutable objects and can be used more efficiently
    when strings need to be modified frequently. `StringBuffer` differs from `StringBuilder`
    in that its methods are synchronized.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK中用于字符串操作的三个主要类是`String`、`StringBuffer`和`StringBuilder`。`String`类是这些类中最广泛使用的。`StringBuffer`和`StringBuilder`类是在Java
    5中引入的，以解决`String`类的效率问题。`String`类是不可变的，需要频繁更改字符串的应用程序将承受创建新的不可变对象的开销。`StringBuffer`和`StringBuilder`类是可变对象，当字符串需要频繁修改时可以更有效地使用。`StringBuffer`与`StringBuilder`的区别在于它的方法是同步的。
- en: In terms of methods supported by the classes, the methods of `StringBuffer`
    and `StringBuilder` are identical. They only differ in whether the methods are
    synchronized or not.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在类支持的方法方面，`StringBuffer`和`StringBuilder`的方法是相同的。它们只在方法是否同步上有所不同。
- en: '| Class | Mutable | Synchronized |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 可变 | 同步 |'
- en: '| --- | --- | --- |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `String` | No | No |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 否 | 否 |'
- en: '| `StringBuffer` | Yes | Yes |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `StringBuffer` | 是 | 是 |'
- en: '| `StringBuilder` | Yes | No |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `StringBuilder` | 是 | 否 |'
- en: A synchronized method is useful when dealing with applications that use multiple
    threads. A **thread** is a code sequence that executes on its own. It will run
    at the same time as other threads within the same application. Concurrent threads
    do not pose a problem unless they are sharing data. When this happens it is possible
    for that data to become corrupted. The use of synchronized methods addresses this
    problem and prevents the data from being corrupted due to the interaction of the
    threads.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理使用多个线程的应用程序时，同步方法是有用的。**线程**是一个独立执行的代码序列。它将与同一应用程序中的其他线程同时运行。并发线程不会造成问题，除非它们共享数据。当这种情况发生时，数据可能会变得损坏。同步方法的使用解决了这个问题，并防止数据由于线程的交互而变得损坏。
- en: The use of synchronized methods includes some overhead. Thus, if the string
    is not being shared by multiple threads then the overhead introduced by the `StringBuffer`
    class is not needed. When synchronization is not needed, in most cases the `StringBuilder`
    class should be used.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 同步方法的使用包括一些开销。因此，如果字符串不被多个线程共享，则不需要`StringBuffer`类引入的开销。当不需要同步时，大多数情况下应该使用`StringBuilder`类。
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Criteria for using string classes**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用字符串类的标准**'
- en: 'If the string is not going to change, use the `String` class:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串不会改变，请使用`String`类：
- en: As it is immutable it is safe for sharing between multiple threads
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是不可变的，因此可以安全地在多个线程之间共享
- en: The threads will only read them, which is normally a thread safe operation.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程只会读取它们，这通常是一个线程安全的操作。
- en: 'If the string is going to change and it will be shared between threads, then
    use the `StringBuffer` class:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串将要改变并且将在线程之间共享，则使用`StringBuffer`类：
- en: This class is designed for just this situation
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是专门为这种情况设计的
- en: Using this class in this situation will insure that the string is updated correctly
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下使用这个类将确保字符串被正确更新
- en: The chief drawback is that the methods may execute slower
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要缺点是方法可能执行得更慢
- en: 'If the string is to change but will not be shared between the threads, use
    the `StringBuilder` class:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串要改变但不会在线程之间共享，请使用`StringBuilder`类：
- en: It allows modification of the strings but does not incur the overhead of synchronization
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许修改字符串，但不会产生同步的开销
- en: The methods of this class will execute as fast as, or faster, than those of
    the `StringBuffer` class
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类的方法将执行得和`StringBuffer`类一样快，甚至更快
- en: Unicode characters
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode字符
- en: Java uses the Unicode standard to define a character. However, this standard
    has evolved and changed, and Java has accommodated its changes. Originally the
    Unicode standard defined a character as a 2 byte 16-bit value which could be represented
    using printable characters or `U+0000` through `U+FFFF`. Hexadecimal digits can
    be use to encode the Unicode characters whether they were printable or not.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用Unicode标准来定义字符。然而，这个标准已经发展和改变，而Java已经适应了它的变化。最初，Unicode标准将字符定义为一个2字节16位值，可以使用可打印字符或`U+0000`到`U+FFFF`来表示。无论可打印与否，十六进制数字都可以用来编码Unicode字符。
- en: However, the 2-byte encoding was not sufficient for all languages. So, version
    4 of the Unicode standard introduced new characters above `U+FFFF` called **UTF-16**
    (**16-bit Unicode Transformation Format**). Java, in support of the new standard,
    uses the concept of **surrogate** **pairs** —pairs of 16-bit chars. These pairs
    are used to represent values from `U+10000` through `U+10FFFF`. The leading or
    high value of the surrogate pair ranges from `U+D800` through `U+DBFF`. The trailing
    or low value of the pair ranges from `U+DC00` through `U+DFFF`. Characters in
    this latter range are called **supplementary** **characters** . These two special
    ranges are used to map any Unicode character into a surrogate pair. As of JDK
    5.0, a character is represented using UTF-16.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，2字节编码对于所有语言来说都不够。因此，Unicode标准的第4版引入了新的字符，位于`U+FFFF`以上，称为**UTF-16**（**16位Unicode转换格式**）。为了支持新标准，Java使用了**代理对**的概念——16位字符对。这些对用于表示从`U+10000`到`U+10FFFF`的值。代理对的前导或高值范围从`U+D800`到`U+DBFF`。对的尾部或低值范围从`U+DC00`到`U+DFFF`。这些范围内的字符称为**补充字符**。这两个特殊范围用于将任何Unicode字符映射到代理对。从JDK
    5.0开始，一个字符使用UTF-16表示。
- en: The Character class
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: The `Character` class is a wrapper class for the `char` primitive data type.
    This data type supports the Unicode standard version 4.0\. Characters are defined
    as fixed-width, 16-bit quantities.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`类是`char`原始数据类型的包装类。该数据类型支持Unicode标准版本4.0。字符被定义为固定宽度的16位数量。'
- en: The Character class – methods
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类-方法
- en: 'The `Character` class possesses a number of methods for dealing with characters.
    Many of the `Character` methods are overloaded and can take either a char or a
    Unicode code point parameter. A code point is an abstraction used for a character
    and for our purposes is a Unicode character. The following table lists several
    `Character` methods that you are likely to encounter:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类
- en: '| Methods | Description |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: 方法
- en: '| --- | --- |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '`String`类是Java中用于表示字符串的常见类。它是不可变的，这使得它是线程安全的。也就是说，多个线程可以访问同一个字符串，而不用担心破坏字符串。不可变还意味着它是固定大小的。'
- en: '| `isDigit` | Returns `true` if the character is a digit |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: 如果字符是数字，则返回true
- en: '| `isLetter` | Returns `true` if the character is a letter |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: 如果字符是字母，则返回true
- en: '| `isLetterOrDigit` | Returns `true` if the character is a letter or a digit
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: 如果字符是字母或数字，则返回true
- en: '| `isLowerCase` | Returns `true` if the character is a lower case letter |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: 如果字符是小写字母，则返回true
- en: '| `isSpace` | Returns `true` if the character is a space |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: 如果字符是空格，则返回true
- en: '| `isUpperCase` | Returns `true` if the character is an upper case letter |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: 如果字符是大写字母，则返回true
- en: '| `toLowerCase` | Returns the lower case equivalent of the character |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: 返回字符的小写等价物
- en: '| `toUpperCase` | Returns the upper case equivalent of the character |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: 描述
- en: The String class
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回字符的大写等价物
- en: The `String` class is a common class used to represent strings in Java. It is
    immutable which makes it thread safe. That is, multiple threads can access the
    same string and not worry about corrupting the string. Being immutable also means
    that it is of a fixed size.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`类具有处理字符的多种方法。许多`Character`方法都是重载的，可以接受`char`或Unicode代码点参数。代码点是用于字符的抽象，对于我们的目的是Unicode字符。以下表列出了您可能会遇到的几种`Character`方法：'
- en: One of the reasons the `String` class was made immutable was for security reasons.
    If a string is used to identify a resource that is protected, once permission
    has been granted for that resource, it may be possible to modify the string and
    then obtain access to another resource for which the user does not have permission.
    By making it immutable, this vulnerability is avoided.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类被设计为不可变的一个原因是出于安全考虑。如果一个字符串用于标识受保护的资源，一旦为该资源授予权限，可能会修改字符串然后获取对用户没有权限的另一个资源的访问权限。通过使其不可变，可以避免这种漏洞。'
- en: 'While the `String` class is immutable, it may still appear to be mutable. Consider
    the following example:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`String`类是不可变的，但它可能看起来是可变的。考虑以下示例：
- en: '[PRE29]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of this sequence is the string "Constant and unchangeable". As `s`
    is defined as a `String` type, the object referenced by the `s` identifier cannot
    change. When the second assignment statement is made, a new object is created
    that combines `Constant` and `and unchangeable` together to produce a new string
    `Constant and unchangeable`. Three `String` objects are created in the process:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 输出这个序列的结果是字符串"Constant and unchangeable"。由于`s`被定义为`String`类型，因此由`s`标识符引用的对象不能改变。当进行第二个赋值语句时，将创建一个新对象，将`Constant`和`and
    unchangeable`组合在一起，生成一个新的字符串`Constant and unchangeable`。在这个过程中创建了三个`String`对象：
- en: '`Constant`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: '`and unchangeable`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可改变
- en: '`Constant and unchangeable`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可改变
- en: The identifier, `s`, now references the new string `Constant and unchangeable`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符`s`现在引用新的字符串`Constant and unchangeable`。
- en: While we have access to these objects, we were not able to change them. We can
    access and read them but we cannot modify them.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以访问这些对象，但我们无法更改它们。我们可以访问和读取它们，但不能修改它们。
- en: 'We could have used the `String` class'' `concat` method but this is not as
    straightforward:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`String`类的`concat`方法，但这并不那么直接：
- en: '[PRE30]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following code illustrates several techniques for creating a `String` object.
    The first constructor will only produce an empty string. This is not of immediate
    value unless an empty immutable string located on the heap is needed in the application.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了创建`String`对象的几种技术。第一个构造函数只会产生一个空字符串。除非应用程序需要在堆上找到一个空的不可变字符串，否则这对于立即价值不大。
- en: '[PRE31]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In addition, there are two constructors that use the `StringBuffer` and `StringBuilder`
    classes. New `String` objects are created from these objects, as shown in the
    following code sequence:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个使用`StringBuffer`和`StringBuilder`类的构造函数。从这些对象创建了新的`String`对象，如下代码序列所示：
- en: '[PRE32]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, a string of the `String` class is represented as an array of `char`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`String`类的字符串表示为`char`数组。
- en: String comparisons
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'String comparisons are not as straightforward as they might initially appear.
    If we wanted to compare two integers, we might use a statement such as the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串比较并不像最初看起来那么直接。如果我们想要比较两个整数，我们可能会使用如下语句：
- en: '[PRE33]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, for the comparisons of two strings, such as `s1` and `s2`, the following
    will often evaluate as `false`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于两个字符串的比较，比如`s1`和`s2`，以下通常会评估为`false`：
- en: '[PRE34]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The problem is that the variables `s1` and `s2` may be referencing different
    objects in memory. The if statement is comparing string reference variables and
    not the actual strings. As they are referencing different objects, the comparison
    returns `false`. It all depends on how the compiler and run-time system handles
    the strings internally.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于变量`s1`和`s2`可能引用内存中的不同对象。if语句比较字符串引用变量而不是实际的字符串。由于它们引用不同的对象，比较返回`false`。这完全取决于编译器和运行时系统如何在内部处理字符串。
- en: When the `new` keyword is used, memory is allocated from the heap and assigned
    to the new object. In the case of a string literal however, this memory does not
    come from the heap but instead from a literal pool, or more specifically, the
    string intern pool. In Java, interned strings are placed into the permanent generation
    area of the JVM. This area also stores Java class declarations and class static
    variables, among other things.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`new`关键字时，内存是从堆中分配并分配给新对象。但是，在字符串文字的情况下，这个内存不是来自堆，而是来自文字池，更具体地说，是字符串内部池。在Java中，内部化的字符串被放置在JVM的永久代区域中。该区域还存储Java类声明和类静态变量等内容。
- en: String interning stores only one copy of each distinct string. This is to improve
    the execution of certain string methods and reduce the amount of space used to
    represent identical strings. The strings in this area are subject to garbage collection.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 内部化字符串仅存储每个不同字符串的一个副本。这是为了改善某些字符串方法的执行并减少用于表示相同字符串的空间量。此区域中的字符串会受到垃圾回收的影响。
- en: 'For example, if we create two string literals and a `String` object using the
    `new` keyword:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建两个字符串文字和一个使用`new`关键字的`String`对象：
- en: '[PRE35]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `String` class' `intern` method can be used to intern a string. Interning
    is performed automatically for all constant strings. When comparing interned strings,
    the equality operator can be used instead of having to use the `equals` method.
    This can save time for string intensive applications. It is easy to forget to
    intern a string, so be careful using the equality operator. In addition to this,
    the `intern` method can be an expensive method to use.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类的`intern`方法可用于对字符串进行内部化。对于所有常量字符串，内部化是自动执行的。在比较内部化的字符串时，可以使用等号运算符，而不必使用`equals`方法。这可以节省对字符串密集型应用程序的时间。很容易忘记对字符串进行内部化，因此在使用等号运算符时要小心。除此之外，`intern`方法可能是一个昂贵的方法。'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other objects besides the `String` type are interned by Java. These include
    wrapper objects and small integer values. Wrapper objects can result when a string
    concatenation operator is used with a primitive type. For more details visit [http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf](http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf)
    and refer to sections 5.1.7 and 12.5.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Java还会对`String`类型之外的其他对象进行内部化。这些包括包装对象和小整数值。当使用原始类型的字符串连接运算符时，可能会产生包装对象。有关更多详细信息，请访问[http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf](http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf)，并参考5.1.7和12.5节。
- en: 'To perform `String` comparisons, there is a number of `String` methods you
    can use including, but not necessarily limited to, the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`String`比较，可以使用一系列`String`方法，包括但不限于以下内容：
- en: '| Method | Purpose |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 目的 |'
- en: '| --- | --- |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `equals` | Compares two strings and returns `true` if they are equivalent
    |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `equals` | 比较两个字符串，如果它们等效，则返回`true` |'
- en: '| `equalsIgnoreCase` | Compares two strings while ignoring the case of the
    letters and returns `true` if they are equivalent |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `equalsIgnoreCase` | 忽略字母大小写比较两个字符串，如果它们等效，则返回`true` |'
- en: '| `startsWith` | Returns `tru` `e` if the string starts with the specified
    character sequence |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `startsWith` | 如果字符串以指定的字符序列开头，则返回`true` |'
- en: '| `endsWith` | Returns `true` if the string ends with the specified character
    sequence |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `endsWith` | 如果字符串以指定的字符序列结尾，则返回`true` |'
- en: '| `compareTo` | Returns `-1` if the first string precedes the second, `0` if
    they are equal to each other, or `1` if the first string follows the second string
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `compareTo` | 如果第一个字符串在第二个字符串之前，则返回`-1`，如果它们相等，则返回`0`，如果第一个字符串在第二个字符串之后，则返回`1`
    |'
- en: Note
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that strings start with an index `0`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 记住字符串从索引`0`开始。
- en: 'The following illustrates the use of various string comparisons:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用各种字符串比较的示例：
- en: '[PRE37]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is shown as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE38]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are several things to consider when using this method. First, uppercase
    letters come before lowercase letters. This is the result of their ordering in
    Unicode. The same ordering applies to ASCII.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此方法时有几件事情需要考虑。首先，大写字母在小写字母之前。这是它们在Unicode中的排序结果。ASCII也适用相同的排序。
- en: A string can have multiple internal representations. Many languages use the
    accent to differentiate or emphasize a character. For example, the French name,
    Irène, uses an accent and can be represented either as `I` `r` `è` `n` `e` or
    as the sequence `I` `r` `e` [PRE39] to form the character `è`. If these two different
    internal representations were compared using the `equals` method, the method would
    return `false`. In this example, `\u0300` combines the grave accent with the letter
    `e`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串可以有多个内部表示。许多语言使用重音来区分或强调字符。例如，法国名字Irène使用重音，可以表示为`I` `r` `è` `n` `e`或序列`I`
    `r` `e` [PRE39]以形成字符`è`。如果使用`equals`方法比较这两种不同的内部表示，该方法将返回`false`。在这个例子中，`\u0300`将重音与字母`e`组合在一起。
- en: String firstIrene = "Irène";
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: String firstIrene = "Irène";
- en: '[PRE40]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this code sequence is as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码序列的输出如下：
- en: '[PRE41]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Collator` class can be used to manipulate strings in a locale-specific
    manner removing the problems of different internal string representations.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collator`类可用于以特定于区域设置的方式操作字符串，消除了不同内部字符串表示的问题。'
- en: Basic string methods
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本字符串方法
- en: 'There are several `String` methods you may encounter. These are illustrated
    in the following table:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到几种`String`方法。这些在下表中有所说明：
- en: '| Method | Purpose |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 目的 |'
- en: '| --- | --- |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `length` | Returns the length of the string. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `length` | 返回字符串的长度。 |'
- en: '| `charAt` | Returns the position of a character given an index in the string.
    |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `charAt` | 返回字符串中给定索引的字符的位置。 |'
- en: '| `substring` | This method is overloaded and returns parts of the string.
    |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| `substring` | 此方法是重载的，返回字符串的部分。 |'
- en: '| `indexOf` | Returns the position of the first occurrence of a char or string.
    |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf` | 返回字符或字符串的第一次出现的位置。 |'
- en: '| `lastIndexOf` | Returns the position of the last occurrence of a char or
    string. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| `lastIndexOf` | 返回字符或字符串的最后一次出现的位置。 |'
- en: 'The following examples illustrate the use of these methods:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这些方法的使用：
- en: '[PRE42]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When this code is executed, we get the following output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码时，我们得到以下输出：
- en: '[PRE43]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Searching a string for a character or sequence of characters is a common requirement
    of many applications. The `indexOf` and `lastIndex` methods perform this type
    of operation:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，搜索字符串以查找字符或字符序列是常见的需求。`indexOf`和`lastIndex`方法执行此类操作：
- en: '[PRE44]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results of these statements are as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句的结果如下：
- en: '[PRE45]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can think of the position in a string as a position immediately before
    a character. These positions or indexes start at `0`, as illustrated in the following
    diagram:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将字符串中的位置视为字符之前的位置。这些位置或索引从`0`开始，如下图所示：
- en: '![Basic string methods](img/7324_02_06.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![基本字符串方法](img/7324_02_06.jpg)'
- en: String length
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串长度
- en: The calculation of the length of a string can be a bit more complicated than
    suggested by the simple use of the `length` method. It depends upon what is being
    counted and how the string is represented internally.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串长度的计算可能比简单使用`length`方法所建议的要复杂一些。它取决于正在计数的内容以及字符串在内部的表示方式。
- en: 'Methods that can be used to determine the length of a string include:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定字符串长度的方法包括：
- en: '`length`: The standard method used'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：标准方法'
- en: '`codePointCount`: This is used in conjunction with supplementary characters'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codePointCount`：与补充字符一起使用'
- en: 'The `length` method of an array of bytes: This is used to determine the actual
    number of bytes used to hold the string'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节数组的`length`方法：用于确定用于保存字符串的实际字节数
- en: The actual length of the string in bytes can be important when storing a string.
    The amount of space allocated in a table of a database may need to be longer than
    simply the number of characters in the string.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储字符串时，字符串的实际长度（以字节为单位）可能很重要。数据库表中分配的空间量可能需要比字符串中的字符数更长。
- en: Number/string conversions
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字/字符串转换
- en: 'The process of converting a number to a string is important. There are two
    approaches we can use. The first approach uses a static method, as shown in the
    following code sequence. The `valueOf` method will convert a number to a string:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为字符串的过程很重要。我们可以使用两种方法。第一种方法使用静态方法，如下代码序列所示。`valueOf`方法将数字转换为字符串：
- en: '[PRE46]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `intValue` and `doubleValue` methods take the object returned by the `valueOf`
    static method and return an integer or double number respectively:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`intValue`和`doubleValue`方法接受`valueOf`静态方法返回的对象，并分别返回整数或双精度数：'
- en: '[PRE47]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second approach is to use the `parseInt` and `parseDouble` methods of their
    respective wrapper classes. Their use is illustrated as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用各自的包装类的`parseInt`和`parseDouble`方法。它们的使用如下所示：
- en: '[PRE48]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Miscellaneous String methods
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项字符串方法
- en: 'There are several miscellaneous methods that can be useful:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种杂项方法可能会有用：
- en: '`replace`: This replaces a part of a string with another string'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`：这将字符串的一部分替换为另一个字符串'
- en: '`toLowerCase`: This converts all characters to lower case in a string'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLowerCase`：将字符串中的所有字符转换为小写'
- en: '`toUpperCase`: This converts all characters to upper case in a string'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUpperCase`：将字符串中的所有字符转换为大写'
- en: '`trim`: This removes leading and trailing blanks'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim`：删除前导和尾随空格'
- en: 'The use of these methods is illustrated below:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些方法的使用示例：
- en: '[PRE49]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The results are shown as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE50]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The StringBuffer and StringBuilder classes
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StringBuffer和StringBuilder类
- en: The `StringBuffer` and `StringBuilder` classes provide an alternative to the
    `String` class. Unlike the `String` class, they are mutable. This is sometimes
    helpful in making a program more efficiently. There are several commonly used
    methods that are available to manipulate a `StringBuffer` or a `StringBuilder`
    object. Several of these are illustrated in the example that follows. While the
    examples use the `StringBuffer` class, the `StringBuilder` method works the same
    way.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuffer`和`StringBuilder`类提供了`String`类的替代方法。与`String`类不同，它们是可变的。这在使程序更有效时有时是有帮助的。有几种常用的方法可用于操作`StringBuffer`或`StringBuilder`对象。以下示例中演示了其中几种。虽然示例使用`StringBuffer`类，但`StringBuilder`方法的工作方式相同。'
- en: 'It is frequently necessary to append one string to another. This can be accomplished
    using the `append` method:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要将一个字符串附加到另一个字符串。可以使用`append`方法来实现这一点：
- en: '[PRE51]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following illustrates inserting a string into a buffer:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将字符串插入缓冲区的示例：
- en: '[PRE52]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A more detailed example:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的示例：
- en: '[PRE53]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE54]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have examined how Java deals with the data. The use of the
    stack and heap are important programming concepts that go a long way in explaining
    concepts such as the scope and lifetime of a variable. The difference between
    objects and primitive data types was introduced along with the initialization
    of variables. The initialization process will be covered in more detail in [Chapter
    6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors,
    and Methods*. The operators available in Java were listed along with the rules
    of precedence and associativity. In addition, the manipulation of character and
    string data was presented.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了Java如何处理数据。堆栈和堆的使用是重要的编程概念，可以很好地解释变量的作用域和生命周期等概念。介绍了对象和原始数据类型之间的区别以及变量的初始化。初始化过程将在[第6章](ch06.html
    "第6章。类，构造函数和方法")*类，构造函数和方法*中更详细地介绍。列出了Java中可用的运算符以及优先级和结合性规则。此外，还介绍了字符和字符串数据的操作。
- en: In the next chapter we will explore the decision constructs available in Java
    and how they can be used effectively. This will build upon the data types presented
    here.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Java中可用的决策结构以及它们如何有效地使用。这将建立在此处介绍的数据类型之上。
- en: Certification objectives covered
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'In this chapter we covered the following:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下内容：
- en: Understanding how Java handles data
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Java如何处理数据
- en: Investigating the relationships between identifiers, the Java class, and memory
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查标识符、Java类和内存之间的关系
- en: Defining the scope of the variables
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量的范围
- en: Initializing identifiers
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化标识符
- en: Building expressions using operators and operands
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符和操作数构建表达式
- en: Working with strings
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Understanding the difference between objects and primitive data types
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象和原始数据类型之间的区别
- en: Test your knowledge
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: What will happen when you compile and run the following code?
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编译和运行以下代码时会发生什么？
- en: '[PRE55]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: a. 35 will be printed out
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: a. 35将被打印出来
- en: b. 45 will be printed out
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: b. 45将被打印出来
- en: c. A compile time error will be generated
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将生成编译时错误
- en: d. An exception will be thrown
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将抛出异常
- en: Which of the following lines will compile without warning or error?
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行将会编译而不会产生警告或错误？
- en: a. `char d="d";`
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: a. `char d="d";`
- en: b. `float f=3.1415;`
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: b. `float f=3.1415;`
- en: c. `int i=34;`
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: c. `int i=34;`
- en: d. `byte b=257;`
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: d. `byte b=257;`
- en: e. `boolean isPresent=true;`
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: e. `boolean isPresent=true;`
- en: 'Given the following declaration:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下声明：
- en: '[PRE56]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Which of the following statements are correct if they replace the comment line?
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们替换注释行，以下哪些陈述是正确的？
- en: a. `System.out.println(i);`
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: a. `System.out.println(i);`
- en: b. `System.out.println(sc.i);`
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: b. `System.out.println(sc.i);`
- en: c. `System.out.println(SomeClass.i);`
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: c. `System.out.println(SomeClass.i);`
- en: d. `System.out.println((new SomeClass()).i);`
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: d. `System.out.println((new SomeClass()).i);`
- en: 'Given the following declaration:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下声明：
- en: '[PRE57]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Which of the following are valid uses of the `sb` variable?
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是`sb`变量的有效用法？
- en: a. `sb.append(34.5);`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: a. `sb.append(34.5);`
- en: b. `sb.deleteCharAt(34.5);`
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: b. `sb.deleteCharAt(34.5);`
- en: c. `sb.toInteger` `(3);`
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: c. `sb.toInteger` `(3);`
- en: d. `sb.toString();`
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: d. `sb.toString();`
- en: Which of the following will return the position of the first letter `a` where
    the string s contains "banana"?
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个将返回字符串s中包含“banana”的第一个字母`a`的位置？
- en: a. `lastIndexOf(2,s);`
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: a. `lastIndexOf(2,s);`
- en: b. `s.indexOf('a');`
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: b. `s.indexOf('a');`
- en: c. `s.charAt(` `2);`
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: c. `s.charAt(` `2);`
- en: d. `indexOf(s,'v');`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: d. `indexOf(s,'v');`
- en: Given the following code, which expression displays the word "Equal"?
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下代码，哪个表达式显示单词“Equal”？
- en: '[PRE58]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: a. `s1==s2`
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: a. `s1==s2`
- en: b. `s1.matchCase(s2)`
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: b. `s1.matchCase(s2)`
- en: c. `s1.equalsIgnoreCase(s2)`
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: c. `s1.equalsIgnoreCase(s2)`
- en: d. `s1.equals(s2)`
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: d. `s1.equals(s2)`
