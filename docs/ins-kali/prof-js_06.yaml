- en: '*Chapter 6*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*'
- en: Code Quality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Identify the best practices for writing clean JavaScript code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定编写清晰JavaScript代码的最佳实践
- en: Perform linting and add a lint command to your node project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码检查并在你的node项目中添加一个检查命令
- en: Use unit, integration, and end-to-end testing methods on your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码上使用单元测试、集成测试和端到端测试方法
- en: Automate linting and tests using Git hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git钩子自动化代码检查和测试
- en: In this chapter, we will focus on improving code quality, setting up tests,
    and automating tests to run before a Git commit. These techniques can be used
    to ensure that mistakes or errors are found early on and never make it to production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于提高代码质量，设置测试，并在Git提交之前自动运行测试。这些技术可以确保错误或问题能够及早被发现，从而不会进入生产环境。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we explored the concepts of modular design, ES6 modules,
    and their use with Node.js. We took our compiled ES6 JavaScript and converted
    it into a compatible script using Babel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了模块化设计、ES6模块以及它们在Node.js中的使用。我们将我们编译的ES6 JavaScript转换为兼容的脚本使用Babel。
- en: In this chapter, we'll discuss code quality, which is one of the key qualities
    of professional JavaScript development. When we start writing code, we tend to
    focus on solving simple problems and evaluating the outcome. When it comes to
    the small pet projects that most developers start with, there is little need to
    communicate with others or work as part of a large team.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论代码质量，这是专业JavaScript开发的关键品质之一。当我们开始编写代码时，我们往往会专注于解决简单的问题和评估结果。对于大多数开发人员开始的小型项目，很少需要与他人沟通或作为大团队的一部分工作。
- en: As the projects, you work on becoming larger in scope, the importance of code
    quality increases. In addition to ensuring that the code works, we have to consider
    other developers who will use the components we create or update the code we write.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你参与的项目范围变得更大，代码质量的重要性也增加。除了确保代码能够正常工作，我们还必须考虑其他开发人员将使用我们创建的组件或更新我们编写的代码。
- en: There are several aspects of quality code. The first and most obvious is that
    it does what it is intended to do. This is often easier said than done. Often,
    it can be difficult to meet the requirements of a large project. To make matters
    more complex, often adding a new feature can cause an error in some existing part
    of the application. We can reduce these mistakes through good design but, even
    so, these types of breakages are bound to happen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量有几个方面。最明显的是它能够实现预期的功能。这通常说起来容易做起来难。很难满足大型项目的要求。更复杂的是，通常添加新功能可能会导致应用程序的某些现有部分出现错误。通过良好的设计可以减少这些错误，但即便如此，这些类型的故障还是会发生。
- en: As agile development becomes more popular, the speed at which code changes have
    also increased. As a result, tests are more important than ever. We'll demonstrate
    how you can use unit tests to confirm the proper functioning of functions and
    classes. In addition to unit tests, we'll look at integration testing, which ensures
    that all aspects of the program function together correctly as expected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着敏捷开发变得越来越流行，代码变更的速度也在增加。因此，测试比以往任何时候都更加重要。我们将演示如何使用单元测试来确认函数和类的正确功能。除了单元测试，我们还将研究集成测试，以确保程序的所有方面都能正确地一起运行。
- en: The second component of code quality is performance. The algorithms in our code
    may produce the desired result, but do they do so efficiently? We'll look at how
    you can test functions for performance to ensure that algorithms can return results
    in an acceptable amount of time when processing a large input. As an example,
    you may have a sorting algorithm that works great with 10 rows of data but takes
    several minutes once you try processing 100.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量的第二个组成部分是性能。我们代码中的算法可能会产生期望的结果，但它们是否能够高效地实现？我们将看看如何测试函数的性能，以确保算法在处理大量输入时能够在合理的时间内返回结果。例如，你可能有一个排序算法在处理10行数据时效果很好，但一旦尝试处理100行数据，就需要几分钟的时间。
- en: The third aspect of code quality we'll talk about in this chapter is readability.
    Readability is a measure of how easy it is for a human to read and understand
    your code. Have you ever looked at code written with vague functions and variable
    names or variable names that are misleading? When writing code, consider that
    others may have to read or modify it. Following some basic guidelines can help
    to improve your readability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论代码质量的第三个方面，即可读性。可读性是衡量人类阅读和理解代码的难易程度。你是否曾经看过使用模糊函数和变量名称或者误导性变量名称编写的代码？在编写代码时，要考虑其他人可能需要阅读或修改它。遵循一些基本准则可以帮助提高可读性。
- en: Clear Naming
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰命名
- en: One of the easiest ways to make code more readable is **clear naming**. Make
    using variables and functions as obvious as possible. Even on a one-man project,
    it's easy to come back to your own code after 6 months and have trouble remembering
    what every function does. When you're reading someone else's code, this is doubly
    true.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码更易读的最简单方法之一是**清晰命名**。尽可能使变量和函数的使用明显。即使是一个人的项目，也很容易在6个月后回到自己的代码时，难以记住每个函数的作用。当你阅读别人的代码时，这一点更加明显。
- en: 'Make sure your names are clear and pronounceable. Consider the following example,
    where a developer has created a function that returns the date in `yymm` format:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的名称清晰且可读。考虑以下示例，开发人员创建了一个以`yymm`格式返回日期的函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we're given the context and explanation of what this function does, it's
    obvious. But for an outside developer skimming over the code for the first time,
    `yymm` can easily cause some confusion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们了解了这个函数的上下文和解释时，它是明显的。但对于第一次浏览代码的外部开发人员来说，`yymm`很容易引起一些困惑。
- en: 'Vague functions should be renamed in a way that makes their use obvious:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将模糊函数重命名为使用明显的方式：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the correct naming of functions and variables is used, it becomes easy
    to compose code that is easily readable. Consider another example, in which we
    want to turn on a light if it''s nighttime:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用正确的函数和变量命名时，编写易读的代码变得容易。再举一个例子，我们想在夜间打开灯：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s not at all clear what''s going on in the preceding code. What exactly
    is meant by `1600` and `600`, and what does it mean if the light''s state is `true`?
    Now consider the same function rewritten as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中并不清楚发生了什么。`1600`和`600`到底是什么意思，如果灯的状态是`true`又代表什么？现在考虑将相同的函数重写如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code makes the same process clear. Instead of asking whether the
    time is between 600 and 1600, we simply ask whether it is night, and, if so, we
    turn the light on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使相同的过程变得清晰。我们不再询问时间是否在600和1600之间，而是简单地询问是否是夜晚，如果是，我们就打开灯。
- en: In addition to being more readable, we have also put the definition of when
    it is nighttime into a central location, `isNight`. If we want to make night end
    at 5:00 instead of 6:00, we only have to change a single line within `isNight`
    instead of finding all instances of `time<600` in our code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更易读外，我们还将夜间的定义放在了一个中心位置，`isNight`。如果我们想在5:00而不是6:00结束夜晚，我们只需要在`isNight`中更改一行，而不是在代码中找到所有`time<600`的实例。
- en: Convention
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范
- en: 'When it comes to the **convention** of how to format or write code, there are
    two categories: industry- or language-wide convention and company/organization-wide
    convention. The industry- or language-specific conventions are generally accepted
    by most programmers using a language. For example, in JavaScript, an industry-wide
    convention is the use of camel case for variable names.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化或编写代码的**规范**方面，有两类：行业或语言范例和公司/组织范例。行业或语言特定的规范通常被大多数使用该语言的程序员所接受。例如，在JavaScript中，行业范例是使用驼峰命名法来命名变量。
- en: Good sources for industry-wide conventions include W3 JavaScript Style Guide
    and Mozilla MDN Web Docs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 行业范例的良好来源包括W3 JavaScript样式指南和Mozilla MDN Web文档。
- en: In addition to industry-wide conventions, software development teams or projects
    will often have a further set of conventions. Sometimes, these conventions are
    compiled into a style guide document; in other cases, these conventions are undocumented.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了行业范例外，软件开发团队或项目通常会有一套更进一步的规范。有时，这些规范被编制成样式指南文件；在其他情况下，这些规范是未记录的。
- en: If you're part of a team that has a relatively large code base, documenting
    the specific style choices can be useful. This will help you to consider what
    aspects you'd like to keep and enforce new updates, and which aspects you may
    want to change. It also helps onboarding new employees who may be familiar with
    JavaScript but not familiar with the specifics of the company.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个有着相对庞大代码库的团队的一部分，记录特定的样式选择可能是有用的。这将帮助你考虑你想要保留和强制执行新更新的哪些方面，以及你可能想要更改的哪些方面。它还有助于培训可能熟悉JavaScript但不熟悉公司具体规范的新员工。
- en: 'A good example of a company-specific style guide is Google JavaScript Style
    Guide ([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html)).
    It contains some information that is useful in general. For example, *Section
    2.3.3* discusses the use of non-ASCII in code. It suggests the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公司特定的样式指南的很好的例子是Google JavaScript样式指南([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html))。它包含一些一般有用的信息。例如，*第2.3.3节*讨论了在代码中使用非ASCII的问题。它建议如下：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Is preferable to using something like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用类似于：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `\u03bcs` without the comment would be even worse. The more obvious the
    meaning of your code, the better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有注释使用`\u03bcs`会更糟。你的代码的意思越明显，越好。
- en: Companies often have a set of libraries they favor for doing things such as
    logging, working with time values (for example, the Moment.js library), and testing.
    This can be useful for compatibility and the reuse of code. Having multiple dependencies
    that do similar things, used by different developers, increases the size of the
    compiled project, for example, if a project is already using Bunyan for logging,
    and someone else decides to install an alternative library such as Morgan.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常有一套他们偏爱的库，用于记录日志、处理时间值（例如Moment.js库）和测试等。这对于兼容性和代码重用非常有用。例如，如果一个项目已经使用Bunyan记录日志，而其他人决定安装Morgan等替代库，那么使用不同开发人员使用的执行类似功能的多个依赖项会增加编译项目的大小。
- en: 'Note: Style Guides'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：样式指南
- en: 'It''s worth taking the time to read over some of the more popular style guides
    for JavaScript. Don''t feel obligated to follow every single rule or suggestion,
    but get accustomed to the thinking behind why rules are created and enforced.
    Some popular guides worth checking out include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花时间阅读一些更受欢迎的JavaScript样式指南。不要觉得自己必须遵循每一个规则或建议，但要习惯于规则背后的思维方式。一些值得查看的热门指南包括以下内容：
- en: 'MSDN Style Guide: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN样式指南：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
- en: Opinionated versus Non-Opinionated
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主观与非主观
- en: 'When it comes to convention, the term "opinionated" is one you will likely
    come across. When exploring existing libraries and frameworks, you will often
    see phrases such as "an opinionated framework." In this context, "opinionated"
    is a measure of how strictly a convention is enforced:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范方面，"主观"这个术语是你可能会遇到的。在探索现有的库和框架时，你经常会看到诸如"一个主观的框架"之类的短语。在这种情况下，"主观"是规范执行的严格程度的衡量标准：
- en: 'Opinionated: Strictly enforces its chosen conventions and methods of doing
    things'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 主观的：严格执行其选择的规范和方法
- en: 'Non-opinionated: Does not enforce convention, that is, as long as the code
    is valid, it can be used'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 非主观：不强制执行规范，也就是说，只要代码有效，就可以使用
- en: Linting
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linting
- en: '**Linting** is an automated process where code is examined and validated against
    a standard of style guidelines. For example, a project that has linting set up
    to ensure two spaces instead of tabs will detect instances of tabs and prompt
    the developer to make the change.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linting**是一个自动化的过程，其中代码被检查并根据一套样式指南的标准进行验证。例如，一个设置了linting以确保使用两个空格而不是制表符的项目将检测到制表符的实例，并提示开发人员进行更改。'
- en: It's important to be aware of linting, but it's not a strict requirement for
    your projects. When I'm working on a project, the main points I consider when
    deciding whether linting is needed are the size of the project and the size of
    the team working on the project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 了解linting很重要，但它并不是项目的严格要求。当我在一个项目上工作时，我考虑的主要因素是项目的规模和项目团队的规模。
- en: Linting really comes in handy on long-term projects with medium- to large-sized
    teams. Often, new people join the project with experience of using some other
    styling convention. This means that you start getting mixed styles between files
    or even within the same file. This leads to the project becoming less organized
    and harder to read.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在中长期项目和中大型团队中，Linting确实非常有用。通常，新人加入项目时会有使用其他样式约定的经验。这意味着你会在文件之间甚至在同一个文件中得到混合的样式。这导致项目变得不太有组织且难以阅读。
- en: If you're writing a prototype for a hackathon, on the other hand, I would suggest
    that you skip the linting. It adds overhead to a project, that is unless you're
    using a boilerplate project as your starting point, which comes with your preferred
    linting installed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在为一个黑客马拉松编写原型，我建议你跳过linting。它会给项目增加额外的开销，除非你使用一个带有你喜欢的linting的样板项目作为起点。
- en: There is also the risk of linting systems that are too restrictive and end up
    slowing down development.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种风险是linting系统过于严格，最终导致开发速度变慢。
- en: Good linting should consider the project and find a balance between enforcing
    a common style and not being too restrictive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Linting应该考虑项目，并在强制执行通用样式和不太严格之间找到平衡。
- en: 'Exercise 29: Setting up ESLint and Prettier to Monitor Errors in Code'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：设置ESLint和Prettier来监视代码中的错误
- en: In this exercise, we will install and set up ESLint and Prettier to monitor
    our code for styling and syntax errors. We will use a popular ESLint convention
    that was developed by Airbnb and has become somewhat of a standard.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将安装并设置ESLint和Prettier来监视我们的代码的样式和语法错误。我们将使用由Airbnb开发的流行的ESLint约定，这已经成为了一种标准。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise29/result](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise29/result).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise29/result](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise29/result)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create a new folder and initialize an `npm` project:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并初始化一个`npm`项目：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're installing several developer dependencies here. In addition to `eslint`
    and `prettier`, we're also installing a starting config made by Airbnb, a config
    to work with Prettier, and an extension that adds style exceptions for our Jest-based
    test files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里安装了几个开发者依赖项。除了`eslint`和`prettier`之外，我们还安装了由Airbnb制作的起始配置，一个与Prettier一起工作的配置，以及一个为基于Jest的测试文件添加样式异常的扩展。
- en: 'Create a `.eslintrc` file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`.eslintrc`文件：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `.prettierignore` file (similar to the `.gitignore` file, this just
    lists the files that should be ignored by Prettier). Your `.prettierignore` file
    should contain the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`.prettierignore`文件（类似于`.gitignore`文件，这只是列出应该被Prettier忽略的文件）。你的`.prettierignore`文件应包含以下内容：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `src` folder and, inside it, create a file called `square.js` that
    contains the following code. Make sure that you include the out-of-place tab:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`src`文件夹，并在其中创建一个名为`square.js`的文件，其中包含以下代码。确保你包含了不合适的制表符：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `lint` script in your npm `package.json` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的npm `package.json`文件中创建一个`lint`脚本：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will test and demonstrate `prettier --write` by running our new script
    from the command line:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过从命令行运行新脚本来测试和演示`prettier --write`：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open `src/square.js` in a text editor; you can see that the out-of-place tab
    was removed:![Figure 6.1: The out-of-place tab was removed'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`src/square.js`，你会看到不合适的制表符已被移除：![图6.1：不合适的制表符已被移除
- en: '](Images/C14587_06_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_01.jpg)'
- en: 'Figure 6.1: The out-of-place tab was removed'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：不合适的制表符已被移除
- en: 'Next, go back to `package.json` and extend our lint script to run `eslint`
    after `prettier` is complete:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回到`package.json`，扩展我们的lint脚本，在`prettier`完成后运行`eslint`：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the command line, run `npm run lint` again. You will encounter a linting
    error due to the code format in `square.js`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中再次运行`npm run lint`。你将因`square.js`中的代码格式而遇到一个linting错误：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding script produces one error and one warning. The error is due to
    the use of `var` when `let` or `const` could be used. Although, in this particular
    case, `const` should be used, as the value of `square` is not reassigned. The
    warning is in regard to our use of `console.log`, which generally shouldn't be
    shipped in production code, as it will make it hard to debug the console output
    when an error occurs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本产生了一个错误和一个警告。错误是由于在可以使用`let`或`const`的情况下使用`var`。尽管在这种特殊情况下应该使用`const`，因为`square`的值没有被重新赋值。警告是关于我们使用`console.log`，通常不应该在生产代码中使用，因为这会使在发生错误时难以调试控制台输出。
- en: 'Open `src/example.js` and change `var` to `const` on line 1, as shown in the
    following figure:![Figure 6.2: The var statement replaced to const'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/example.js`，并按照下图所示，在第1行将`var`更改为`const`：![图6.2：将var语句替换为const
- en: '](Images/C14587_06_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_02.jpg)'
- en: 'Figure 6.2: The var statement replaced to const'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：将var语句替换为const
- en: 'Now run `npm run lint` again. You should now only get back the warning:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行`npm run lint`。现在你应该只会收到警告：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this exercise, we installed and set up Prettier for automatic code formatting,
    and ESLint to check our code for common bad practices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们安装并设置了Prettier以进行自动代码格式化，并使用ESLint检查我们的代码是否存在常见的不良实践。
- en: Unit Tests
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: A **unit test** is an automated software test that checks whether a single aspect
    or function in some software is working as expected. For example, a calculator
    application might be split up into functions that deal with the Graphical User
    Interface (GUI) of the application and another set of functions responsible for
    each type of mathematical calculation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种自动化软件测试，用于检查某个软件中的单个方面或功能是否按预期工作。例如，计算器应用程序可能被分成处理应用程序的图形用户界面（GUI）的函数和负责每种类型的数学计算的另一组函数。'
- en: 'In such a calculator, unit tests might be set up to ensure that each mathematical
    function works as expected. This setup allows us to quickly find any inconsistent
    results or broken functions caused by any changes. As an example, such a calculator''s
    test file might include the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的计算器中，可以设置单元测试来确保每个数学函数按预期工作。这种设置使我们能够快速发现任何由于任何更改而导致的不一致结果或损坏函数。例如，这样一个计算器的测试文件可能包括以下内容：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding tests would run every time the code base was changed and be checked
    into version control. Often, errors will arise unexpectedly when a function that
    is used in multiple places is updated and causes a chain reaction, breaking some
    other function. If such a change happens and one of the preceding statements becomes
    false (for example, 5 multiplied by 3 returns 16 instead of 15), we will immediately
    be able to associate our new code change with the break.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试将在每次更改代码库时运行，并被检入版本控制。通常，当更新用于多个地方的函数并引发连锁反应导致某些其他函数损坏时，错误会意外地出现。如果发生这样的更改，并且前面的某个语句变为假（例如，5乘以3返回16而不是15），我们将立即能够将新的代码更改与损坏联系起来。
- en: This is a very powerful technique that can be taken for granted in environments
    where tests are already set up. In work environments without such a system, it's
    possible that changes from developers or updates in software dependencies that
    unexpectedly break an existing function are committed to source control. Later,
    the bug is found, and it becomes difficult to make the association between the
    broken function and the code change that caused it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大的技术，在已经设置好测试的环境中可能被认为是理所当然的。在没有这样一个系统的工作环境中，开发人员的更改或软件依赖项的更新可能会意外地破坏现有的函数并提交到源代码控制中。后来，发现了错误，并且很难将损坏的函数与导致它的代码更改联系起来。
- en: It's also important to remember that unit tests ensure the functionality of
    some sub-unit of work, but not the functionality of a project as a whole (where
    multiple functions work together to produce a result). This is where integration
    testing comes into play. We will explore integration tests later on within this
    chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，单元测试确保某个子单元的功能，但不确保整个项目的功能（其中多个函数一起工作以产生结果）。这就是集成测试发挥作用的地方。我们将在本章后面探讨集成测试。
- en: 'Exercise 30: Setting up Jest Tests to Test a Calculator Application'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：设置Jest测试以测试计算器应用程序
- en: In this exercise, we will demonstrate setting up a unit test using Jest, the
    most popular testing framework in the JavaScript ecosystem. We will continue with
    our example of a calculator application and set up automated testing for a function
    that takes a number and outputs its square.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将演示如何使用Jest设置单元测试，Jest是JavaScript生态系统中最流行的测试框架。我们将继续使用计算器应用程序的示例，并为一个接受一个数字并输出其平方的函数设置自动化测试。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise30](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise30).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise30](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson06/Exercise30)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: On the command line, navigate to the `Exercise30/start` exercise folder. This
    folder includes a `src` folder that contains the code we will be running our tests
    on.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise30/start`练习文件夹。该文件夹包括一个包含我们将运行测试的代码的`src`文件夹。
- en: 'Initialize a `npm` project by entering the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令来初始化一个`npm`项目：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install Jest using the `--save-dev` flag (this indicates that the dependency
    is required for development but not production) by entering the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装Jest，使用`--save-dev`标志（表示该依赖项对开发而非生产是必需的）：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a folder called `__tests__`. This is the default location where Jest
    looks for tests:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__`的文件夹。这是Jest查找测试的默认位置：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we''re going to create our first test in `__tests__/math.test.js`. It should
    import `src/math.js` and ensure that running the `math.square(5)` returns `25`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`__tests__/math.test.js`中创建我们的第一个测试。它应该导入`src/math.js`并确保运行`math.square(5)`返回`25`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open `package.json` and modify the test script so that it runs `jest`. Notice
    the `scripts` section in the following screenshot:![Figure 6.3: The test script
    modified so that it runs Jest'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`package.json`并修改测试脚本，使其运行`jest`。注意以下截图中的`scripts`部分：![图6.3：修改后的测试脚本，使其运行Jest
- en: '](Images/C14587_06_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_03.jpg)'
- en: 'Figure 6.3: The test script modified so that it runs Jest'
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：修改后的测试脚本，使其运行Jest
- en: 'On the command line, enter the `npm run test`. This should return a message
    that tells us the wrong value was found, as shown in the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入`npm run test`。这应该返回一条消息，告诉我们找到了错误的值，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This error triggers because the start code has purposely included an error in
    the `square` function. Instead of multiplying the number by itself, we have instead
    doubled the value. Notice that the number of received answers was `10`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为起始代码故意在`square`函数中包含了一个错误。我们没有将数字乘以自身，而是将值加倍。请注意，接收到的答案数量是`10`。
- en: 'Fix the error by opening up the file and fixing the `square` function. It should
    multiply `x`, as shown in the following code, instead of doubling it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开文件并修复`square`函数来修复错误。它应该像下面的代码一样将`x`相乘，而不是将其加倍：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With our code fixed, let''s test again with `npm run test`. You should get
    a success message, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复了我们的代码后，让我们再次用`npm run test`进行测试。你应该会得到一个成功的消息，如下所示：
- en: '![Figure 6.4: Success message shown after testing with npm run test'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：使用npm run test进行测试后显示的成功消息'
- en: '](Images/C14587_06_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_04.jpg)'
- en: 'Figure 6.4: Success message shown after testing with npm run test'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：使用npm run test进行测试后显示的成功消息
- en: In this exercise, we set up a Jest test to ensure that running our `square`
    function with an input of 5 returns 25\. We also looked at what to expect when
    the wrong value is returned by running our test with a mistake in the code that
    returned 10 instead of 25.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们设置了一个Jest测试，以确保用输入5运行我们的`square`函数返回25。我们还看了一下当代码中返回错误值时会发生什么，比如返回10而不是25。
- en: Integration Tests
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: So, we have discussed unit tests, which are extremely useful for finding the
    cause of errors when a project's code changes. However, it's also possible that
    the project passes all unit tests yet does not work as expected. This is because
    the whole of the project contains additional logic that glues our functions together,
    as well as static components such as HTML, data, and other artifacts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了单元测试，当项目的代码发生变化时，它们非常有用，可以帮助找到错误的原因。然而，也有可能项目通过了所有的单元测试，但并不像预期的那样工作。这是因为整个项目包含了将我们的函数粘合在一起的额外逻辑，以及静态组件，如HTML、数据和其他工件。
- en: '**Integration tests** can be used to ensure a project works from a higher level.
    For example, while our unit tests directly call functions such as `math.square`,
    an integration test will test multiple pieces of functionality working together
    for a particular result.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**可以用来确保项目在更高层次上工作。例如，虽然我们的单元测试直接调用`math.square`等函数，但集成测试将测试多个功能一起工作以获得特定结果。'
- en: Often, this means bringing together multiple modules or interacting with a database
    or other external components or APIs. Of course, integrating more parts means
    integration tests take longer, so they should be used more sparingly than unit
    tests. Another downside of the integration test is that when one fails, there
    are multiple possibilities as to the cause. In contrast, a failed unit test is
    generally easy to fix as the code being tested is in a specified location.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这意味着将多个模块组合在一起，或者与数据库或其他外部组件或API进行交互。当然，集成更多部分意味着集成测试需要更长的时间，因此它们应该比单元测试更少地使用。集成测试的另一个缺点是，当一个测试失败时，可能有多种可能性作为原因。相比之下，失败的单元测试通常很容易修复，因为被测试的代码位于指定的位置。
- en: 'Exercise 31: Integration Testing with Jest'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习31：使用Jest进行集成测试
- en: 'In this exercise, we''ll continue where we left off in our last Jest exercise,
    where we tested that the `square` function was returning 25 in response to 5\.
    In this exercise, we''ll continue by adding some new tests that use our functions
    in conjunction with each other:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续上次Jest练习的内容，上次我们测试了`square`函数对5的响应是否返回25。在这个练习中，我们将继续添加一些新的测试，使用我们的函数相互结合：
- en: 'On the command line, navigate to the `Exercise31/start` exercise folder, and
    install the dependencies with `npm`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise31/start`练习文件夹，并使用`npm`安装依赖项：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a folder called `__tests__`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__`的文件夹：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `__tests__/math.test.js`. Then, at the top, import the
    `math` library:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__/math.test.js`的文件。然后，在顶部导入`math`库：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly to the last exercise, we''ll add a test. The main difference here,
    however, is that we''re combining multiple functions:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个练习类似，我们将添加一个测试。然而，这里的主要区别是我们将多个函数组合在一起：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a timer to measure performance to the preceding test:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的测试中添加一个计时器来测量性能：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, test to make sure everything works by running `npm test`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行`npm test`来测试一切是否正常运行：
- en: '![Figure 6.5: Running npm test to make sure everything is working fine'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：运行npm test以确保一切正常'
- en: '](Images/C14587_06_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_05.jpg)'
- en: 'Figure 6.5: Running npm test to make sure everything is working fine'
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：运行npm test以确保一切正常
- en: You should see an output similar to the preceding figure, with each test passing
    with an expected result.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到与前面图中类似的输出，每个测试都通过了预期的结果。
- en: It should be noted that these integration tests are somewhat simplistic. In
    a real-world scenario, integration tests combine functions, as we demonstrated
    previously, but from different sources. For example, when you have multiple components
    created by different teams, integration testing is there to ensure that everything
    works together. Often, bugs can be caused by simple things, such as updating an
    external library.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，这些集成测试有点简单。在实际情况下，集成测试结合了我们之前演示的不同来源的函数。例如，当你有多个由不同团队创建的组件时，集成测试可以确保一切都能一起工作。通常，错误可能是由简单的事情引起的，比如更新外部库。
- en: The idea is that multiple parts of your application are integrated, giving you
    a greater chance of finding where something breaks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是你的应用程序的多个部分被集成在一起，这样你就有更大的机会找到哪里出了问题。
- en: Code Performance Fibonacci Example
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码性能斐波那契示例
- en: Often, a problem has more than one solution. While all solutions might return
    the same result, they likely don't have the same performance. Take, for example,
    the problem of getting the nth number of the Fibonacci sequence. Fibonacci is
    a mathematical pattern where the next number in the sequence is the sum of the
    last two numbers (1, 1, 2, 3, 5, 8, 13, …).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个问题有不止一种解决方案。虽然所有的解决方案可能会返回相同的结果，但它们的性能可能不同。例如，考虑获取斐波那契数列的第n个数字的问题。斐波那契是一个数学模式，其中序列中的下一个数字是前两个数字的和（1,
    1, 2, 3, 5, 8, 13, …）。
- en: 'Consider the following solution, where Fibonacci calls itself recursively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下解决方案，其中斐波那契递归调用自身：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding example states that if we want to get the nth number of the Fibonacci
    sequence recursively, then get the Fibonacci of `n` minus one plus the Fibonacci
    of `n` minus two, unless `n` is 1, in which case, return 1\. It works and will
    return the correct answer for any given number. However, as the value of `n` increases,
    the execution time increases exponentially.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子说明，如果我们想要递归地得到斐波那契数列的第n个数字，那么就得到`n`减一的斐波那契加上`n`减二的斐波那契，除非`n`为1，此时返回1。它可以返回任何给定数字的正确答案。然而，随着`n`的增加，执行时间呈指数增长。
- en: 'To see how slow this performs, add the `fib` function to a new file and use
    the function by console logging the result as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个算法的执行速度有多慢，将`fib`函数添加到一个新文件中，并使用以下方式通过控制台记录结果：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, on the command line, run the following command (`time` should be available
    in most Unix- and Mac-based environments):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在命令行中运行以下命令（`time`应该在大多数Unix和基于Mac的环境中可用）：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On a particular laptop, I got back the following, which indicates the 37th
    digit of Fibonacci is `24157817` and the execution time took 0.441 seconds:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的笔记本电脑上，我得到了以下结果，表明斐波那契的第37位数字是`24157817`，执行时间为0.441秒：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now open up that same file and change `37` to `44`. Then, run the same `time
    node test` command again. In my case, an increase of only 7 caused the execution
    time to increase up to 20 times:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开同一个文件，并将`37`改为`44`。然后再次运行相同的`time node test`命令。在我的情况下，仅增加了7，执行时间就增加了20倍：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can rewrite the same algorithm in a more efficient way to increase speed
    for larger numbers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以更高效的方式重写相同的算法，以增加大数字的速度：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even though it appears to be more complex, this method of generating a Fibonacci
    number is superior due to the speed of execution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来更复杂，但由于执行速度快，这种生成斐波那契数的方法更优越。
- en: One of the downsides of tests with Jest is that, given the preceding scenario,
    both the slow and fast versions of Fibonacci will pass. Yet, the slow version
    would clearly be unacceptable in a real-world application where quick processing
    has to be done.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Jest测试的一个缺点是，鉴于前面的情景，斐波那契的慢速和快速版本都会通过。然而，在现实世界的应用程序中，慢速版本显然是不可接受的，因为需要快速处理。
- en: 'To guard against this, you may want to add some performance-based tests that
    ensure functions are completed within a certain time period. The following is
    an example of creating a custom timer to ensure that a function finishes within
    5 seconds:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防范这种情况，您可能希望添加一些基于性能的测试，以确保函数在一定时间内完成。以下是一个示例，创建一个自定义计时器，以确保函数在5秒内完成：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note: Future versions of Jest'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：Jest的未来版本
- en: It can be somewhat cumbersome to manually add timers to all your functions.
    For this reason, there is discussion within the Jest project to create an easier
    syntax for accomplishing what has been done previously.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 手动为所有函数添加计时器可能有些麻烦。因此，在Jest项目中有讨论，以创建更简单的语法来实现之前所做的事情。
- en: 'To see the discussion related to this syntax and whether it''s been resolved,
    check issue #6947 for Jest on GitHub at [https://github.com/facebook/jest/issues/6947](https://github.com/facebook/jest/issues/6947).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与此语法相关的讨论以及是否已解决，请在GitHub上的Jest的问题＃6947中查看[https://github.com/facebook/jest/issues/6947](https://github.com/facebook/jest/issues/6947)。
- en: 'Exercise 32: Ensuring Performance with Jest'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习32：使用Jest确保性能
- en: 'In this exercise, we''ll use the technique described previously to test the
    performance of two algorithms for getting Fibonacci:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用之前描述的技术来测试获取斐波那契的两种算法的性能：
- en: 'On the command line, navigate to the `Exercise32/start` exercise folder and
    install dependencies with `npm`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise32/start`练习文件夹，并使用`npm`安装依赖项：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a folder called `__tests__`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__`的文件夹：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a file called `__tests__/fib.test.js`. At the top, import the fast and
    slow Fibonacci functions (these are already created in the `start` folder):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__/fib.test.js`的文件。在顶部，导入快速和慢速的斐波那契函数（这些已经在`start`文件夹中创建）：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a test for fast Fibonacci that creates a timer and ensures that the timer
    hasn''t run for longer than 5 seconds:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为快速斐波那契添加一个测试，创建一个计时器，并确保计时器运行时间不超过5秒：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, add a test for slow Fibonacci, which also checks the run time is less
    than 5 seconds:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为慢速斐波那契添加一个测试，同时检查运行时间是否少于5秒：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'From the command line, run the tests using the `npm test` command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行中，使用`npm test`命令运行测试：
- en: '![Figure 6.6: Result from the Fibonacci tests'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：斐波那契测试的结果'
- en: '](Images/C14587_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_06.jpg)'
- en: 'Figure 6.6: Result from the Fibonacci tests'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：斐波那契测试的结果
- en: Notice the preceding error response for the part that mentions the timer. The
    expected result for the function's running time was under 5,000 milliseconds but,
    in my case, I actually received 10,961\. You'll likely get a different result
    based on the speed of your computer. If you didn't receive the error, it may be
    that your computer is so fast that it completed in less than 5,000 milliseconds.
    If that's the case, try lowering the expected maximum time to trigger the error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面提到的关于计时器的错误响应。函数运行时间的预期结果应该在5,000毫秒以下，但在我的情况下，我实际收到了10,961。根据您的计算机速度，您可能会得到不同的结果。如果您没有收到错误，可能是因为您的计算机速度太快，完成时间少于5,000毫秒。如果是这种情况，请尝试降低预期的最大时间以触发错误。
- en: End-to-End Testing
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: While integration testing combines multiple units or functions of a software
    project, **end-to-end testing** goes one step further by simulating the actual
    use of the software.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然集成测试结合了软件项目的多个单元或功能，**端到端测试**更进一步，模拟了软件的实际使用。
- en: For example, while our unit tests directly called functions such as `math.square`,
    an end-to-end test would load the graphical interface of the calculator and simulate
    pressing a number, say 5, followed by the square button. After a few seconds,
    the end-to-end test would look at the resulting answer in the graphical interface
    and ensure it equals 25 as expected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，虽然我们的单元测试直接调用了`math.square`等函数，端到端测试将加载计算器的图形界面，并模拟按下一个数字，比如5，然后是平方按钮。几秒钟后，端到端测试将查看图形界面中的结果，并确保它等于预期的25。
- en: 'End-to-end testing should be used more sparingly due to the overhead, but it
    is a great final step in a testing process to ensure that everything is working
    as expected. In contrast, unit tests are relatively quick to run and, therefore,
    can be run more often without slowing down development. The following figure shows
    a recommended distribution of tests:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开销较大，端到端测试应该更加节制地使用，但它是测试过程中的一个很好的最后一步，以确保一切都按预期工作。相比之下，单元测试运行起来相对快速，因此可以更频繁地运行而不会拖慢开发速度。下图显示了测试的推荐分布：
- en: '![Figure 6.7: Recommended distribution of tests'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：测试的推荐分布'
- en: '](Images/C14587_06_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_07.jpg)'
- en: 'Figure 6.7: Recommended distribution of tests'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：测试的推荐分布
- en: 'Note: Integration Testing versus End-to-End Testing'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：集成测试与端到端测试
- en: It should be noted that there can be some overlap between what is considered
    an integration test and what is considered an end-to-end test. The interpretation
    of what constitutes a test type may vary between one company and another.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，什么被认为是集成测试和端到端测试之间可能存在一些重叠。对于测试类型的解释可能会在不同公司之间有所不同。
- en: Traditionally, tests have been classified as either a unit test or an integration
    test. Over time, other classifications have become popular, such as system, acceptance,
    and end-to-end. Due to this, there can be an overlap as to what type a particular
    test is.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，测试被分类为单元测试或集成测试。随着时间的推移，其他分类变得流行，如系统测试、验收测试和端到端测试。因此，特定测试的类型可能会有重叠。
- en: Puppeteer
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppeteer
- en: In 2018, Google released the **Puppeteer** JavaScript library, which has drastically
    increased the ease with which end-to-end testing can be set up on a JavaScript-based
    project. Puppeteer is a headless version of the Chrome web browser, meaning that
    it has no GUI component. This is crucial, as it means we're testing our applications
    with a full Chrome browser, rather than a simulation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，谷歌发布了**Puppeteer** JavaScript库，大大提高了在基于JavaScript的项目上设置端到端测试的便利性。Puppeteer是Chrome浏览器的无头版本，意味着它没有GUI组件。这是至关重要的，因为这意味着我们使用完整的Chrome浏览器来测试我们的应用，而不是模拟。
- en: 'Puppeteer can be controlled through jQuery-like syntax, where elements on an
    HTML page are selected by ID or class and interacted with. For example, the following
    code opens Google News, finds a `.rdp59b` class, clicks on it, waits 3 seconds,
    and finally takes a screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer可以通过类似于jQuery的语法进行控制，其中可以通过ID或类选择HTML页面上的元素并与之交互。例如，以下代码打开Google News，找到一个`.rdp59b`类，点击它，等待3秒，最后截取屏幕：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Bear in mind that, in the preceding example, we're selecting a `.rdp59b` class
    that looks like it was automatically generated; therefore, it is likely that this
    class will change in the future. In the case that the class name changes, the
    script will no longer work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在上面的示例中，我们选择了一个看起来是自动生成的`.rdp59b`类；因此，很可能这个类将来会发生变化。如果类名发生变化，脚本将不再起作用。
- en: 'If upon reading this, you find the preceding script does not work, I challenge
    you to update it. One of the best tools when working with Puppeteer is the Chrome
    DevTools. My usual workflow is to go to the website I''m writing a script for
    and right-click on the element that I''ll be targeting, as shown in the following
    figure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读本文时，您发现前面的脚本不起作用，我挑战您更新它。在使用Puppeteer时，其中一个最好的工具是Chrome DevTools。我的常规工作流程是转到我为其编写脚本的网站，并右键单击我将要定位的元素，如下图所示：
- en: '![Figure 6.8: Right-click to inspect in Chrome'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：在Chrome中右键单击进行检查'
- en: '](Images/C14587_06_08.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_08.jpg)'
- en: 'Figure 6.8: Right-click to inspect in Chrome'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：在Chrome中右键单击进行检查
- en: 'Once you click on **Inspect**, the DOM explorer will pop up and you''ll be
    able to see any classes or IDs associated with the element:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单击**检查**，DOM资源管理器将弹出，您将能够看到与元素相关的任何类或ID：
- en: '![Figure 6.9: DOM explorer in Chrome DevTools'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：Chrome DevTools中的DOM资源管理器'
- en: '](Images/C14587_06_09.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_09.jpg)'
- en: 'Figure 6.9: DOM explorer in Chrome DevTools'
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：Chrome DevTools中的DOM资源管理器
- en: 'Note: Puppeteer for Web Scraping and Automation'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：Puppeteer用于Web抓取和自动化
- en: In addition to being useful for writing end-to-end tests, Puppeteer can also
    be used for web scraping and automation. Almost anything that can be done in a
    normal browser can be automated (given the right code).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于编写端到端测试，Puppeteer还可以用于Web抓取和自动化。几乎可以在普通浏览器中完成的任何事情都可以自动化（只要有正确的代码）。
- en: In addition to being able to select elements on a page via selectors, as we
    previously looked at, Puppeteer has full access to keyboard and mouse simulation.
    Thus, more complex things such as automating web-based games and daily tasks are
    possible. Some have even managed to bypass things such as captchas using it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够通过选择器在页面上选择元素之外，正如我们之前所看到的，Puppeteer还可以完全访问键盘和鼠标模拟。因此，诸如自动化基于Web的游戏和日常任务等更复杂的事情是可能的。一些人甚至成功地使用它绕过了验证码等东西。
- en: 'Exercise 33: End-to-End Testing with Puppeteer'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习33：使用Puppeteer进行端到端测试
- en: In this exercise, we're going to use Puppeteer to manually open an HTML/JavaScript-based
    calculator and use it as an end user would. I didn't want to target a live website
    as its content often changes or goes offline. So, instead, I have included an
    HTML calculator in `Exercise33/start` of the project files.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Puppeteer手动打开一个基于HTML/JavaScript的计算器，并像最终用户一样使用它。我不想针对一个实时网站，因为它的内容经常会发生变化或下线。因此，我在项目文件的`Exercise33/start`中包含了一个HTML计算器。
- en: 'You can view it by installing dependencies with npm, running `npm start`, and
    then going to `localhost:8080` in your browser:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用npm安装依赖项，运行`npm start`，然后在浏览器中转到`localhost:8080`来查看它：
- en: '![Figure 6.10: Site showing the demonstration of a calculator created using
    Puppeteer'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：显示使用Puppeteer创建的计算器演示的网站'
- en: '](Images/C14587_06_10.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_10.jpg)'
- en: 'Figure 6.10: Site showing the demonstration of a calculator created using Puppeteer'
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：显示使用Puppeteer创建的计算器演示的网站
- en: In this exercise, we'll be creating a script that opens the site, presses the
    buttons, and then checks the site for the correct results. Instead of just checking
    the output of a function, we're listing actions to take on the site and specifying
    the HTML selector to use as the value to run our tests against.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个脚本，打开网站，按下按钮，然后检查网站的正确结果。我们不仅仅是检查函数的输出，而是列出在网站上执行的操作，并指定要用作我们测试对象的值的HTML选择器。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Open the `Exercise33/start` folder and install the existing dependencies:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise33/start`文件夹并安装现有的依赖项：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Install the required `jest`, `puppeteer`, and `jest-puppeteer` packages:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的`jest`，`puppeteer`和`jest-puppeteer`包：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open `package.json` and configure Jest to use the `jest-puppeteer` presets,
    which will automatically set up Jest to work with Puppeteer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`package.json`并配置Jest使用`jest-puppeteer`预设，这将自动设置Jest以与Puppeteer一起工作：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file called `jest-puppeteer.config.js` and add the following to it:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`jest-puppeteer.config.js`的文件，并添加以下内容：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding configuration will make sure the `npm start` command is run before
    the testing phase. It also tells Puppeteer to look for our web application on
    `port: 8080`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的配置将确保在测试阶段之前运行`npm start`命令。它还告诉Puppeteer在`port: 8080`上查找我们的Web应用程序。'
- en: 'Make a new folder called `__tests__`, as we did in our previous examples:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__tests__`的新文件夹，就像我们在之前的示例中所做的那样：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inside the `__tests__` folder, create a file called `test.test.js` that contains
    the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__tests__`文件夹中创建一个名为`test.test.js`的文件，其中包含以下内容：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code is a complete end-to-end test for multiplying 5 by 5 and
    confirming that the answer returned within the interface is 25\. Here, we're opening
    the local website, pressing five, pressing multiply, pressing five, pressing equals,
    and then checking the value of the `div` with the ID of `screen`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个完整的端到端测试，用于将5乘以5并确认界面返回的答案为25。在这里，我们打开本地网站，按下五，按下乘，按下五，按下等于，然后检查具有ID为`screen`的`div`的值。
- en: 'Run the tests using `npm`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`运行测试：
- en: '![Figure 6.11: Output after running the calculator script'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：运行计算器脚本后的输出'
- en: '](Images/C14587_06_11.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_11.jpg)'
- en: 'Figure 6.11: Output after running the calculator script'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：运行计算器脚本后的输出
- en: You should see a result, as shown in the preceding figure, with the output of
    25.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个结果，如前图所示，输出为25。
- en: Git Hooks
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git钩子
- en: The tests and linting commands discussed here can be incredibly useful for maintaining
    and improving your code quality and functionality. However, in the heat of actual
    development, where our focus is on specific problems and deadlines, it can be
    easy to forget to run the linting and test commands.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的测试和linting命令对于维护和改进代码质量和功能非常有用。然而，在实际开发的热情中，我们的重点是特定问题和截止日期，很容易忘记运行linting和测试命令。
- en: One popular solution to this problem is the use of Git hooks. A Git hook is
    a feature of the Git version control system. A **Git hook** specifies a terminal
    command to be run at some specific point in the Git process. A Git hook can be
    run before a commit; after, when a user updates by pulling; and at many other
    specific points. A full list of possible Git hooks can be found at [https://git-scm.com/docs/githooks](https://git-scm.com/docs/githooks).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个流行方法是使用Git钩子。Git钩子是Git版本控制系统的一个特性。**Git钩子**指定要在Git过程的某个特定点运行的终端命令。Git钩子可以在提交之前运行；在用户通过拉取更新时运行；以及在许多其他特定点运行。可以在[https://git-scm.com/docs/githooks](https://git-scm.com/docs/githooks)找到可能的Git钩子的完整列表。
- en: For our purposes, we'll focus only be using the pre-commit hook. This will allow
    us to find any formatting issues before we commit our code to the source.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将只关注使用预提交钩子。这将允许我们在提交代码到源代码之前找到任何格式问题。
- en: 'Note: Exploring Git'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：探索Git
- en: Another interesting way of exploring the possible Git hooks and how they're
    used in general is to open any Git version control project and look in the `hooks`
    folder.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 探索可能的Git钩子以及它们通常如何使用的另一个有趣的方法是打开任何Git版本控制项目并查看`hooks`文件夹。
- en: 'By default, any new `.git` project will contain a large list of samples in
    the `.git/hooks` folder. Explore their contents and have them trigger by renaming
    them with the following pattern:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何新的`.git`项目都将在`.git/hooks`文件夹中包含大量的示例。探索它们的内容，并通过使用以下模式重命名它们来触发它们：
- en: '`<hook-name>.sample to <hook-name>`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`<hook-name>.sample to <hook-name>`'
- en: 'Exercise 34: Setting up a Local Git Hook'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习34：设置本地Git钩子
- en: 'In this exercise, we''ll set up a local Git hook that runs the `lint` command
    before we''re allowed to commit using Git:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将设置一个本地Git钩子，在我们允许使用Git提交之前运行`lint`命令：
- en: 'On the command line, navigate to the `Exercise34/start` exercise folder and
    install the dependencies:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise34/start`练习文件夹并安装依赖项：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initialize the folder as a Git project:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件夹初始化为Git项目：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `.git/hooks/pre-commit` file, which contains the following:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`.git/hooks/pre-commit`文件，其中包含以下内容：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If on an OS X- or Linux-based system, make the file executable by running the
    following (this is not required on Windows):'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在基于OS X或Linux的系统上，通过运行以下命令使文件可执行（在Windows上不需要）：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll now test the hook by making a commit:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将通过进行提交来测试钩子：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the output of the preceding code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 6.12: Git hook being run before committing to Git'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：提交到Git之前运行的Git钩子'
- en: '](Images/C14587_06_12.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_12.jpg)'
- en: 'Figure 6.12: Git hook being run before committing to Git'
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：提交到Git之前运行Git钩子
- en: You should see the `lint` command being run before your code is committed to
    the source, as shown in the preceding screenshot.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码提交到源代码之前，您应该看到`lint`命令正在运行，如前面的屏幕截图所示。
- en: 'Next, let''s test failure by adding some code that will generate a linting
    error. Modify your `src/js.js` file by adding the following line:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加一些代码来测试失败，这些代码将生成linting错误。通过在您的`src/js.js`文件中添加以下行来修改：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Make sure that you keep the unnecessary tab in the preceding line, as this will
    be what triggers a lint error.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在上一行中保留不必要的制表符，因为这将触发lint错误。
- en: 'Repeat the process of adding the file and committing it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复添加文件并提交的过程：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is the output of the preceding code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 6.13: A failed linting before committing the code to git'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13：提交代码到git之前的失败linting'
- en: '](Images/C14587_06_13.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_13.jpg)'
- en: 'Figure 6.13: A failed linting before committing the code to git'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：提交代码到git之前的失败linting
- en: You should see the `lint` command running as before; however, after it runs,
    the code is not committed like the last time, due to the Git hook returning an
    error.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`lint`命令像以前一样运行；但是，在运行后，由于Git钩子返回错误，代码不会像上次那样被提交。
- en: Sharing Git Hooks with Husky
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Husky共享Git钩子
- en: An important factor to be aware of with Git hooks is that, because these hooks
    are within the `.git` folder itself, they are not considered part of the project.
    Therefore, they will not be shared to your central Git repository for collaborators
    to use.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的一个重要因素是，由于这些钩子位于`.git`文件夹本身内部，它们不被视为项目的一部分。因此，它们不会被共享到您的中央Git存储库供协作者使用。
- en: However, Git hooks are most useful in collaborative projects where new developers
    may not be fully aware of a project's conventions. It's a very convenient process
    when a new developer clones a project, makes some changes, tries to commit, and
    immediately gets feedback based on linting and tests.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Git钩子在协作项目中最有用，新开发人员可能不完全了解项目的约定。当新开发人员克隆项目，进行一些更改，尝试提交，并立即根据linting和测试获得反馈时，这是一个非常方便的过程。
- en: The `husky` node library was created with this in mind. It allows you to keep
    track of your Git hooks within the source code using a single config file called
    `.huskyrc`. When a project is installed by a new developer, the hooks will be
    active without the developer having to do anything.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`husky`节点库是基于这个想法创建的。它允许您使用一个名为`.huskyrc`的单个配置文件在源代码中跟踪您的Git钩子。当新开发人员安装项目时，钩子将处于活动状态，开发人员无需做任何操作。'
- en: 'Exercise 35: Setting up a Commit Hook with Husky'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习35：使用Husky设置提交钩子
- en: 'In this exercise, we''re going to set up a Git hook that does the same thing
    as the one in *Exercise 34, Setting up a Local Git Hook,* but has the advantage
    of being shareable across a team. By using the `husky` library instead of `git`
    directly, we''ll ensure that anyone who clones the project also has the hook that
    runs `lint` before committing any changes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将设置一个Git钩子，它与*练习34，设置本地Git钩子*中的钩子做相同的事情，但具有可以在团队中共享的优势。通过使用`husky`库而不是直接使用`git`，我们将确保任何克隆项目的人也有在提交任何更改之前运行`lint`的钩子：
- en: 'On the command line, navigate to the `Exercise35/start` exercise folder and
    install the dependencies:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise35/start`练习文件夹并安装依赖项：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a file called `.huskyrc` that contains the following:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`.huskyrc`的文件，其中包含以下内容：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding file is the most important part of this exercise as it defines
    exactly what command will be run at what point in the Git process. In our case,
    we're running the `lint` command before any code is committed to the source.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件是这个练习的最重要部分，因为它确切地定义了在Git过程的哪个时刻运行什么命令。在我们的情况下，在将任何代码提交到源代码之前，我们运行`lint`命令。
- en: 'Initialize the folder as a Git project by running `git init`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`git init`将文件夹初始化为Git项目：
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Install Husky using `npm`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`安装Husky：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Make a change to `src/js.js` that will be used for our test commit. As an example,
    I''ll add a comment as follows:![Figure 6.14: The test commit comment'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`src/js.js`进行更改，以便用于我们的测试提交。例如，我将添加以下注释：![图6.14：测试提交注释
- en: '](Images/C14587_06_14.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_14.jpg)'
- en: 'Figure 6.14: The test commit comment'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：测试提交注释
- en: 'Now, we''ll run a test ensuring it works like in the previous example:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将运行一个测试，确保它像之前的示例一样工作：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is the output of the preceding code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 6.15: Output after committing the test husky hook'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：提交测试husky钩子后的输出'
- en: '](Images/C14587_06_15.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_15.jpg)'
- en: 'Figure 6.15: Output after committing the test husky hook'
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：提交测试husky钩子后的输出
- en: We're getting a warning about our use of `console.log`, but you can ignore this
    for our purposes. The main point is that we have set up our Git hook using Husky,
    so anyone else who installs the project will also have the hooks set up, as opposed
    to if we set them up directly in Git.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到关于我们使用`console.log`的警告，但是出于我们的目的，您可以忽略这一点。主要问题是我们已经使用Husky设置了我们的Git钩子，因此安装项目的任何其他人也将设置好钩子，而不是我们直接在Git中设置它们。
- en: 'Note: Initializing Husky'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：初始化Husky
- en: Take note of the fact that `npm install --save-dev husky` was run after our
    Git repository was created. When you install Husky, it runs the required commands
    to set up your Git hooks. However, if the project isn't a Git repository, it won't
    be able to.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm install --save-dev husky`是在创建Git存储库后运行的。当您安装Husky时，它会运行必需的命令来设置您的Git钩子。但是，如果项目不是Git存储库，则无法运行。
- en: If you have any problems related to this, try re-running `npm install --save-dev
    husky` once you have initialized a Git repository.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到与此相关的任何问题，请在初始化Git存储库后尝试重新运行`npm install --save-dev husky`。
- en: 'Exercise 36: Getting Elements by Text with Puppeteer'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：使用Puppeteer按文本获取元素
- en: 'In this exercise, we''re going to write a Puppeteer test that verifies a small
    quiz app is working. If you go into the exercise folders and find the starting
    point for *Exercise 36*, you can run `npm start` to see the quiz we''ll be testing:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个Puppeteer测试，验证一个小测验应用程序是否正常工作。如果你进入练习文件夹并找到*练习36*的起点，你可以运行`npm
    start`来查看我们将要测试的测验：
- en: '![Figure 6.16: Puppeteer showing a small quiz app'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16：Puppeteer显示一个小测验应用程序'
- en: '](Images/C14587_06_16.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_16.jpg)'
- en: 'Figure 6.16: Puppeteer showing a small quiz app'
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：Puppeteer显示一个小测验应用程序
- en: 'In this application, clicking on the correct answer of a question makes the
    question disappear and the score increment by one:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，点击问题的正确答案会使问题消失，分数增加一：
- en: 'On the command line, navigate to the `Exercise36/start` exercise folder and
    install the dependencies:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到`Exercise36/start`练习文件夹并安装依赖项：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a test script to `package.json` by modifying the `scripts` section so that
    it looks like the following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`scripts`部分，向`package.json`文件添加一个`test`脚本，使其看起来像下面这样：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add a Jest section to `package.json` that tells Jest to use Puppeteer presets:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加一个Jest部分，告诉Jest使用Puppeteer预设：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a file called `jest-puppeteer.config.js` where we will tell Jest to
    turn our quiz app on before running any tests:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`jest-puppeteer.config.js`的文件，在其中告诉Jest在运行任何测试之前打开我们的测验应用程序：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a folder called `__test__` where we will put our Jest tests:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`__test__`的文件夹，我们将把我们的Jest测试放在其中：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a test in the folder called `quiz.test.js`. It should contain the following
    to initialize our test:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`quiz.test.js`的文件夹中创建一个测试。它应该包含以下内容来初始化我们的测试：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, replace the comment in the preceding code with a test for the first question
    in our quiz:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用我们测验中的第一个问题的测试替换前面代码中的注释：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice our use of `q1.$x("//button[contains(text(), '10')]")`. Instead of using
    an ID, we're searching the answers for a button that contains the text `10`. This
    can be very useful when parsing a website that doesn't use IDs on the elements
    you need to interact with.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的`q1.$x("//button[contains(text(), '10')]")`。我们不是使用ID，而是在答案中搜索包含文本`10`的按钮。当解析一个网站时，这可能非常有用，该网站没有在您需要交互的元素上使用ID。
- en: 'The following test is added to the last step. We''ll add three new tests, one
    for each question:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步添加了以下测试。我们将添加三个新测试，每个问题一个：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice how the line at the bottom of each test has an expected result, one higher
    than the last; this is us tracking the score on the page. If everything is working
    properly, the fourth test will find a score of 4.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个测试的底部都有一个预期结果，比上一个高一个；这是我们在页面上跟踪分数。如果一切正常，第四个测试将找到一个分数为4。
- en: 'Finally, return to the command line so that we can confirm the correct results.
    Run the `test` command as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回到命令行，以便我们可以确认正确的结果。运行以下`test`命令：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is the output of the preceding code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 6.17: Command line confirming the correct results'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：命令行确认正确的结果'
- en: '](Images/C14587_06_17.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_17.jpg)'
- en: 'Figure 6.17: Command line confirming the correct results'
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：命令行确认正确的结果
- en: If you have done everything correctly, you should see four passing tests as
    a response to running `npm test`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，运行`npm test`应该看到四个通过的测试作为响应。
- en: 'Activity 7: Putting It All Together'
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动7：将所有内容组合在一起
- en: 'In this activity, we''ll combine several aspects of the chapter. Starting with
    a pre-built calculator using HTML/JavaScript, your task is the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将结合本章的几个方面。从使用HTML/JavaScript构建的预先构建的计算器开始，你的任务是：
- en: Create a `lint` command that checks the project against `prettier` and `eslint`
    using the `eslint-config-airbnb-base` package, as was done in a previous exercise.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`lint`命令，使用`eslint-config-airbnb-base`包检查项目是否符合`prettier`和`eslint`，就像在之前的练习中所做的那样。
- en: Install `puppeteer` with `jest` and create a `test` command in `package.json`
    that runs `jest`.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jest`安装`puppeteer`并在`package.json`中创建一个运行`jest`的`test`命令。
- en: Create a Puppeteer test that uses the calculator to calculate 777 multiplied
    by 777, and ensure the answer returned is 603,729.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Puppeteer测试，使用计算器计算777乘以777，并确保返回的答案是603,729。
- en: Create another Puppeteer test to calculate 3.14 divided by 2, and ensure the
    answer returned is 1.57.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建另一个Puppeteer测试来计算3.14除以2，并确保返回的答案是1.57。
- en: Install and set up Husky to run both the linting and testing commands before
    a commit is made using Git.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并设置Husky，在使用Git提交之前运行linting和测试命令。
- en: 'Perform the following steps to complete the activity (high-level steps):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成活动（高级步骤）：
- en: Install the developer dependencies listed in the linting exercise (`eslint`,
    `prettier`, `eslint-config-airbnb-base`, `eslint-config-prettier`, `eslint-plugin-jest`,
    and `eslint-plugin-import`).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装在linting练习中列出的开发人员依赖项（`eslint`，`prettier`，`eslint-config-airbnb-base`，`eslint-config-prettier`，`eslint-plugin-jest`和`eslint-plugin-import`）。
- en: Add an `eslint` configuration file, `.eslintrc`.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`eslint`配置文件`.eslintrc`。
- en: Add a .`prettierignore` file.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`.prettierignore`文件。
- en: Add a `lint` command to your `package.json` file.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`文件中添加一个`lint`命令。
- en: Open the `assignment` folder and install the developer dependencies for using
    Puppeteer with Jest.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`assignment`文件夹，并安装使用Puppeteer和Jest的开发人员依赖项。
- en: Modify your `package.json` file by adding an option telling Jest to use the
    `jest-puppeteer` preset.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`package.json`文件，添加一个选项告诉Jest使用`jest-puppeteer`预设。
- en: Add a `test` script to `package.json` that runs `jest`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加一个`test`脚本来运行`jest`。
- en: Create a `jest-puppeteer.config.js` to configure Puppeteer.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`jest-puppeteer.config.js`来配置Puppeteer。
- en: Create a test file at `__tests__/calculator.js`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__tests__/calculator.js`创建一个测试文件。
- en: Create a Husky file at `.huskyrc`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`.huskyrc`文件。
- en: Install `husky` as a developer dependency by running `npm install --save-dev
    husky`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`npm install --save-dev husky`安装`husky`作为开发人员依赖项。
- en: '**Expected Output**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**'
- en: '![Figure 6.18: The final output showing calc.test passed](Images/C14587_06_18.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18：最终输出显示calc.test通过](Images/C14587_06_18.jpg)'
- en: 'Figure 6.18: The final output showing calc.test passed'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：最终输出显示calc.test通过
- en: After completing the assignment, you should be able to run the `npm run` `lint`
    command and the `npm test` command and get tests passing like in the preceding
    screenshot.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 完成任务后，您应该能够运行`npm run` `lint`命令和`npm test`命令，并像前面的截图中一样通过测试。
- en: Note
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 602.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在602页找到。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at aspects of code quality with an emphasis on automated
    testing. We started with the basics of clear naming and getting familiar with
    the industry-wide conventions of the language. By following these conventions
    and writing clearly, we're able to make our code more readable and reusable.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们着重介绍了自动化测试的代码质量方面。我们从清晰命名和熟悉语言的行业惯例的基础知识开始。通过遵循这些惯例并清晰地书写，我们能够使我们的代码更易读和可重用。
- en: Building from there, we looked at how linting and testing commands can be created
    with Node.js using a handful of popular tools, including Prettier, ESLint, Jest,
    Puppeteer, and Husky.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，我们看了一下如何使用一些流行的工具（包括Prettier、ESLint、Jest、Puppeteer和Husky）在Node.js中创建linting和测试命令。
- en: In addition to setting up tests, we talked about the categories of tests and
    their use cases. We went through unit tests that ensure that individual functions
    are working as expected, and integration tests that combine multiple functions
    or aspects of a program to ensure things are working together. Then, we performed
    end-to-end tests, which open the application's interface and interact with it
    as an end-user would.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '除了设置测试之外，我们还讨论了测试的类别和它们的用例。我们进行了单元测试，确保单个函数按预期工作，并进行了集成测试，将多个函数或程序的方面结合在一起，以确保它们一起工作。然后，我们进行了端到端测试，打开应用程序的界面并与其进行交互，就像最终用户一样。 '
- en: Finally, we looked at how we can tie it all together by having our linting and
    testing scripts automatically run with Git hooks.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了如何通过Git钩子自动运行我们的linting和测试脚本。
- en: In the next chapter, we'll look at constructors, promises, and async/await.
    We'll be using some of these techniques to refactor JavaScript in a modern way
    that takes advantage of the new features available in ES6.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究构造函数、promises和async/await。我们将使用其中一些技术以一种现代化的方式重构JavaScript，利用ES6中提供的新功能。
