- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Diving into Variables, Types, and Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入变量、类型和方法
- en: The initial steps into any programming language are plagued with a fundamental
    issue—you can understand the words being typed out, but not the meaning behind
    them. Normally, this would be cause for a paradox, but programming is a special
    case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进入任何编程语言的初始步骤都会受到一个基本问题的困扰——你可以理解打出的字，但不知道它们背后的含义。通常情况下，这会导致悖论，但编程是一个特殊情况。
- en: C# is not its own language; it's written in English. The discrepancy between
    the words you use every day and the code in Visual Studio comes from missing context,
    which is something that has to be learned all over again. You know how to say
    and spell the words used in C#, but what you don't know is where, when, why, and,
    most importantly, how they make up the syntax of the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C#并不是一种独立的语言；它是用英语编写的。你每天使用的词语和在Visual Studio中的代码之间的差异来自于缺少上下文，这是需要重新学习的东西。你知道如何说和拼写C#中使用的词语，但你不知道的是它们在语言的语法中是如何组成的，以及最重要的是如何组成的。
- en: 'This chapter marks our departure from programming theory and the beginning
    of our journey into actual coding. We''ll talk about accepted formatting, debugging
    techniques, and putting together more complex examples of variables and methods.
    There''s a lot of ground to cover, but by the time you reach the last quiz, you''ll
    be comfortable with the following high-level topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章标志着我们离开了编程理论，开始了我们进入实际编码的旅程。我们将讨论接受的格式化、调试技术，并组合更复杂的变量和方法示例。有很多内容要涵盖，但当你达到最后的测验时，你将对以下高级主题感到舒适：
- en: Writing proper C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写正确的C#
- en: Debugging your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: Understanding variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量
- en: Introducing operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入运算符
- en: Defining methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义方法
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Writing proper C#
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写正确的C#
- en: Lines of code function like sentences, meaning they need to have some sort of
    separating or ending character. Every line of C#, called a statement, *must* end
    with a semicolon to separate them for the code compiler to process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行就像句子一样，意味着它们需要有某种分隔或结束字符。每一行C#代码，称为语句，*必须*以分号结尾，以便编译器对其进行处理。
- en: 'However, there''s a catch that you need to be aware of. Unlike the written
    word we''re all familiar with, a C# statement doesn''t technically have to be
    on a single line; whitespace and newlines are ignored by the code compiler. For
    example, a simple variable could be written like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要注意一个问题。与我们熟悉的书面语言不同，C#语句在技术上不一定要在一行上；空格和换行符会被代码编译器忽略。例如，一个简单的变量可以这样写：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, it could also be written as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以这样写：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two code snippets are both perfectly acceptable to Visual Studio, but
    the second option is highly discouraged in the software community as it makes
    code extremely hard to read. The idea is to write your programs as efficiently
    and clearly as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段对Visual Studio来说都是完全可以接受的，但第二个选项在软件社区中是极为不鼓励的，因为它使得代码极其难以阅读。理念是尽可能高效和清晰地编写你的程序。
- en: There will be times when a statement will be too long to reasonably fit on a
    single line, but those are few and far between. Just make sure that it's formatted
    in a way someone else could understand, and don't forget the semicolon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一条语句会太长，无法合理地放在一行上，但这种情况很少。只要确保它的格式能让别人理解，并且不要忘记分号。
- en: 'The second formatting rule you need to drill into your coding muscle memory
    is the use of curly brackets or braces: `{}`. Methods, classes, and interfaces
    all need a set of curly brackets after their declaration. We''ll talk about each
    of these in-depth later on, but it''s important to get the standard formatting
    in your head early on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要牢记的第二个格式化规则是使用花括号：`{}`。方法、类和接口在声明后都需要一对花括号。我们稍后会详细讨论这些内容，但是早点把标准格式化记在脑海中是很重要的。
- en: 'The traditional practice in C# is to include each bracket on a new line, as
    shown in the following method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C#的传统做法是将每个括号放在新的一行，就像下面的方法所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, you might see the first curly bracket located on the same line as
    the declaration out in the wild. It''s all down to personal preference:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会看到第一个花括号与声明在同一行的情况。这完全取决于个人偏好：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this isn't something to tear your hair out over, the important thing is
    to be consistent. In this book, we'll stick with "pure" C# code, which will always
    put each bracket on a new line, while C# examples that have to do with Unity and
    game development will often follow the second example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是什么让你抓狂的事情，但重要的是要保持一致。在本书中，我们将坚持使用“纯粹”的C#代码，它总是将每个括号放在新的一行，而与Unity和游戏开发有关的C#示例通常会遵循第二个例子。
- en: Good, consistent formatting style is paramount when starting in programming,
    but so is being able to see the fruits of your work. In the next section, we'll
    talk about how to print out variables and information straight to the Unity console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 良好、一致的格式化风格在编程初学者中至关重要，但能够看到你的工作成果也同样重要。在下一节中，我们将讨论如何将变量和信息直接打印到Unity控制台。
- en: Debugging your code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: While we're working through practical examples, we'll need a way to print out
    information and feedback to the **Console** window in the Unity editor. The programmatic
    term for this is debugging, and both C# and Unity provide helper methods to make
    this process easier for developers. You already debugged your code from the last
    chapter, but we didn't go into much detail about how it actually works. Let's
    fix that.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过实际示例进行工作时，我们需要一种方法将信息和反馈打印到Unity编辑器中的**控制台**窗口。这个程序术语称为调试，C#和Unity都提供了辅助方法，使开发人员更容易进行这个过程。你已经从上一章调试了你的代码，但我们并没有详细讨论它是如何工作的。让我们来解决这个问题。
- en: 'Whenever I ask you to debug or print something out, use one of the following
    methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我要求你调试或打印出某些东西时，使用以下方法之一：
- en: 'For simple text or individual variables, use the standard `Debug.Log()` method.
    The text needs to be inside a set of parentheses, and variables can be used directly
    with no added characters; for example:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的文本或单个变量，使用标准的`Debug.Log()`方法。文本需要放在一对括号内，变量可以直接使用，不需要添加其他字符；例如：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_01.png)'
- en: 'Figure 3.1: Observing Debug.Log output'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：观察Debug.Log输出
- en: 'For more complex debugging, use `Debug.LogFormat()`. This will let you place
    variables inside the printed text by using placeholders. These are marked with
    a pair of curly brackets, each containing an index. An index is a regular number,
    starting at 0 and increasing sequentially by 1\. In the following example, the
    `{0}` placeholder is replaced with the `CurrentAge` value, `{1}` with `FirstName`,
    and so on:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更复杂的调试，使用`Debug.LogFormat()`。这将允许您在打印的文本中使用占位符来放置变量。这些占位符用一对花括号标记，每个花括号包含一个索引。索引是一个常规数字，从0开始，依次递增1。在下面的示例中，`{0}`占位符被`CurrentAge`的值替换，`{1}`被`FirstName`替换，依此类推：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_02.png)'
- en: 'Figure 3.2: Observing Debug.LogFormat output'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：观察Debug.LogFormat输出
- en: You might have noticed that we're using **dot notation** in our debugging techniques,
    and you'd be right! Debug is the class we're using, and `Log()` and `LogFormat()`
    are different methods that we can use from that class. More on this at the end
    of this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在调试技术中使用了**点符号**，没错！Debug是我们使用的类，`Log()`和`LogFormat()`是我们可以从该类中使用的不同方法。本章末尾将详细介绍这一点。
- en: With the power of debugging under our belts, we can safely move on and do a
    deeper dive into how variables are declared, as well as the different ways that
    syntax can play out.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了调试的能力，我们可以安全地继续深入了解变量声明的方式，以及语法可以如何发挥作用。
- en: Understanding variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量
- en: In the previous chapter, we saw how variables are written and touched on the
    high-level functionality that they provide. However, we're still missing the syntax
    that makes all of that possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了变量的写法，并简要介绍了它们提供的高级功能。然而，我们仍然缺少使所有这些成为可能的语法。
- en: Declaring variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'Variables don''t just appear at the top of a C# script; they have to be declared
    according to certain rules and requirements. At its most basic level, a variable
    statement needs to satisfy the following requirements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不会只是出现在C#脚本的顶部；它们必须根据特定的规则和要求进行声明。在最基本的层面上，变量声明需要满足以下要求：
- en: The type of data the variable will store needs to be specified
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要指定变量将存储的数据类型
- en: The variable has to have a unique name
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须有一个唯一的名称
- en: If there is an assigned value, it must match the specified type
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个赋值，它必须与指定的类型匹配
- en: The variable declaration needs to end with a semicolon
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明需要以分号结束
- en: 'The result of adhering to these rules is the following syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守这些规则的结果是以下语法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables need unique names to avoid conflicts with words that have already
    been taken by C#, which are called keywords. You can find the full list of protected
    keywords at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 变量需要唯一的名称，以避免与C#已经使用的关键字发生冲突。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index)找到受保护关键字的完整列表。
- en: This is simple, neat, and efficient. However, a programming language wouldn't
    be useful in the long run if there was only one way of creating something as pervasive
    as variables. Complex applications and games have different use cases and scenarios,
    all of which have unique C# syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，整洁，高效。然而，如果只有一种方式创建如此普遍的变量，那么编程语言在长期内将毫无用处。复杂的应用程序和游戏有不同的用例和场景，所有这些都有独特的C#语法。
- en: Type and value declarations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型和值的声明
- en: 'The most common scenario for creating variables is one that has all of the
    required information available when the declaration is made. For instance, if
    we knew a player''s age, storing it would be as easy as doing the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建变量最常见的情况是在声明时已经有了所有必需的信息。例如，如果我们知道玩家的年龄，存储它就像这样简单：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, all of the basic requirements have been met:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有基本要求都得到了满足：
- en: A data type is specified, which is `int` (short for integer)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了数据类型，即`int`（整数的缩写）
- en: A unique name is used, which is `CurrentAge`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了一个唯一的名称，即`CurrentAge`
- en: '`32` is an integer, which matches the specified data type'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32`是一个整数，与指定的数据类型匹配'
- en: The statement ends with a semicolon
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语句以分号结束
- en: However, there will be scenarios where you'll want to declare a variable without
    knowing its value right away. We'll talk about this topic in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你会想要声明一个变量，但并不知道它的值。我们将在接下来的部分讨论这个话题。
- en: Type-only declarations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅类型声明
- en: 'Consider another scenario—you know the type of data you want a variable to
    store and its name, but not its value. The value will be computed and assigned
    somewhere else, but you still need to declare the variable at the top of the script.
    This situation is perfect for a type-only declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种情况——你知道你想要一个变量存储的数据类型和它的名称，但不知道它的值。值将在其他地方计算和赋值，但你仍然需要在脚本的顶部声明变量。这种情况非常适合仅类型声明：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only the type (`int`) and unique name (`CurrentAge`) are defined, but the statement
    is still valid because we''ve followed the rules. With no assigned value, default
    values will be assigned according to the variable''s type. In this case, `CurrentAge`
    will be set to `0`, which matches the `int` type. As soon as the actual value
    of the variable becomes available, it can easily be set in a separate statement
    by referencing the variable name and assigning it a value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只有类型（`int`）和唯一名称（`CurrentAge`）被定义，但语句仍然有效，因为我们遵循了规则。没有分配的值，将根据变量的类型分配默认值。在这种情况下，`CurrentAge`将被设置为`0`，这与`int`类型匹配。一旦变量的实际值变得可用，就可以通过引用变量名并为其分配一个值来轻松地在单独的语句中设置它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find a complete list of all C# types and their default values at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values)找到所有C#类型及其默认值的完整列表。
- en: At this point, you might be asking why, so far, our variables haven't included
    the `public` keyword, called an *access modifier*, which we saw in earlier scripting
    examples. The answer is that we didn't have the necessary foundation to talk about
    them with any clarity. Now that we have that foundation, it's time to revisit
    them in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会问为什么到目前为止，我们的变量还没有包括`public`关键字，即*访问修饰符*，这是我们在早期脚本示例中看到的。答案是我们没有必要的基础来清楚地谈论它们。现在我们有了这个基础，是时候详细讨论它们了。
- en: Using access modifiers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符
- en: Now that the basic syntax is no longer a mystery, let's get into the finer details
    of variable statements. Since we read code from left to right, it makes sense
    to begin our variable deep dive with the keyword that traditionally comes first—an
    access modifier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本语法不再是一个谜，让我们深入了解变量语句的细节。由于我们从左到右阅读代码，因此从传统上来说，从关键字开始进行变量深入研究是有意义的。
- en: 'Take a quick look back at the variables we used in the preceding chapter in
    `LearningCurve` and you''ll see they had an extra keyword at the front of their
    statements: `public`. This is the variable''s access modifier. Think of it as
    a security setting, determining who and what can access the variable''s information.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下我们在前一章中在`LearningCurve`中使用的变量，您会发现它们在语句的开头有一个额外的关键字：`public`。这就是变量的访问修饰符。将其视为安全设置，确定谁和什么可以访问变量的信息。
- en: Any variable that isn't marked `public` is defaulted to `private` and won't
    show up in the Unity Inspector panel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何没有标记为`public`的变量都默认为`private`，并且不会显示在Unity Inspector面板中。
- en: 'If you include a modifier, the updated syntax recipe we put together at the
    beginning of this chapter will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包括一个修饰符，我们在本章开头组合的更新语法配方将如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While explicit access modifiers aren't necessary when declaring a variable,
    it's a good habit to get into as a new programmer. That extra word goes a long
    way toward readability and professionalism in your code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，明确的访问修饰符并不是必需的，但作为新程序员，养成这样的习惯是很好的。这个额外的词在代码的可读性和专业性方面有很大帮助。
- en: 'There are four main access modifiers available in C#, but the two you''ll be
    working with most often as a beginner are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有四种主要的访问修饰符，但作为初学者，您最常使用的两种是以下两种：
- en: '**Public**: This is available to any script without restriction.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：对任何脚本都是可用的，没有限制。'
- en: '**Private**: This is only available in the class they''re created in (which
    is called the containing class). Any variable without an access modifier defaults
    to private.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**：仅在创建它们的类中可用（称为包含类）。任何没有访问修饰符的变量默认为私有。'
- en: 'The two advanced modifiers have the following characteristics:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个高级修饰符具有以下特点：
- en: '**Protected**: Accessible from their containing class or types derived from
    it'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protected**：可从包含类或从中派生的类型访问'
- en: '**Internal**: Only available in the current assembly'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internal**：仅在当前程序集中可用'
- en: There are specific use cases for each of these modifiers, but until we get to
    the advanced chapters, don't worry about **protected** and **internal**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个修饰符都有特定的用例，但在我们进入高级章节之前，不要担心**protected**和**internal**。
- en: Two combined modifiers also exist, but we won't be using them in this book.
    You can find more information about them at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两种组合修饰符也存在，但在本书中我们不会使用它们。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)找到更多关于它们的信息。
- en: Let's try out some access modifiers of our own! Just like information in real
    life, some data needs to be protected or shared with specific people. If there's
    no need for a variable to be changed in the **Inspector** window or accessed from
    other scripts, it's a good candidate for a private access modifier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些自己的访问修饰符！就像现实生活中的信息一样，有些数据需要受到保护或与特定人分享。如果变量在**Inspector**窗口中不需要更改或从其他脚本中访问，那么它就是私有访问修饰符的一个很好的选择。
- en: 'Perform the following steps to update `LearningCurve`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来更新`LearningCurve`：
- en: Change the access modifier in front of `CurrentAge` from `public` to `private`
    and save the file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentAge`前面的访问修饰符从`public`更改为`private`并保存文件。
- en: Go back into Unity, select the Main Camera, and take a look at what changed
    in the `LearningCurve`section:![](img/B17573_03_03.png)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，选择主摄像机，并查看`LearningCurve`部分中的更改！[](img/B17573_03_03.png)
- en: 'Figure 3.3: LearningCurve script component attached to the Main Camera'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：附加到主摄像机的LearningCurve脚本组件
- en: Since `CurrentAge` is now private, it's no longer visible in the **Inspector**
    window and can only be accessed within the `LearningCurve` script in code. If
    we click play, the script will still work exactly as it did before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAge`现在是私有的，它不再在**检视器**窗口中可见，只能在`LearningCurve`脚本中的代码中访问。如果我们点击播放，脚本仍然会像以前一样正常工作。
- en: This is a good start on our journey into variables, but we still need to know
    more about what kinds of data they can store. This is where data types come in,
    which we'll look at in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们进入变量的旅程的一个良好开端，但我们仍然需要了解它们可以存储什么类型的数据。这就是数据类型的作用，我们将在下一节中进行讨论。
- en: Working with types
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型
- en: Assigning a specific type to a variable is an important choice, one that trickles
    down into every interaction a variable has over its entire lifespan. Since C#
    is what's called a *strongly-typed* or *type-safe* language, every variable has
    to have a data type without exception. This means that there are specific rules
    when it comes to performing operations with certain types, and regulations when
    converting a given variable type into another.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将特定类型分配给变量是一个重要的选择，它会影响变量在整个生命周期中的每次交互。由于C#是所谓的*强类型*或*类型安全*语言，每个变量都必须有一个数据类型，没有例外。这意味着在执行特定类型的操作时有特定的规则，并且在将给定变量类型转换为另一个类型时有规定。
- en: Common built-in types
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的内置类型
- en: 'All data types in C# trickle down (or *derive*, in programmatic terms) from
    a common ancestor: `System.Object`. This hierarchy, called the **Common Type System**
    (**CTS**), means that different types have a lot of shared functionality. The
    following table lays out some of the most common data type options and the values
    they store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的所有数据类型都从一个共同的祖先`System.Object`（在编程术语中称为*派生*）派生下来。这个层次结构称为**公共类型系统**（**CTS**），意味着不同类型有很多共享功能。下表列出了一些最常见的数据类型选项以及它们存储的值：
- en: '![](img/B17573_03_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_04.png)'
- en: 'Figure 3.4: Common data types for variables'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：变量的常见数据类型
- en: 'In addition to specifying the kind of value a variable can store, types contain
    added information about themselves, including the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定变量可以存储的值的类型之外，类型还包含有关自身的其他信息，包括以下内容：
- en: Required storage space
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的存储空间
- en: Minimum and maximum values
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小和最大值
- en: Allowed operations
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的操作
- en: Location in memory
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的位置
- en: Accessible methods
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问的方法
- en: Base (derived) type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本（派生）类型
- en: If this seems overwhelming, take a deep breath. Working with all of the types
    C# offers is a perfect example of using documentation over memorization. Pretty
    soon, using even the most complex custom types will feel like second nature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来令人不知所措，请深呼吸。使用C#提供的所有类型是使用文档而不是记忆的完美示例。很快，即使是最复杂的自定义类型的使用也会变得轻而易举。
- en: You can find a complete list of all of the C# built-in types and their specifications
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index)找到所有C#内置类型及其规格的完整列表。
- en: Before the list of types becomes a sticking point, it's best to experiment with
    them. After all, the best way to learn something new is to use it, break it, and
    then learn to fix it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型列表成为难点之前，最好先尝试它们。毕竟，学习新东西的最佳方式是使用它，打破它，然后学会修复它。
- en: 'Go ahead and open up `LearningCurve`and add a new variable for each type in
    the preceding chart from the *Common built-in types* section. The names and values
    you use are up to you; just make sure they''re marked as public so we can see
    them in the Inspector window. If you need inspiration, take a look at my code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`并根据前面图表中*常见内置类型*部分的每种类型添加一个新变量。您使用的名称和值由您决定；只需确保它们标记为公共，以便我们可以在检视器窗口中看到它们。如果需要灵感，可以看看我的代码：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When dealing with string types, the actual text value needs to be inside a pair
    of double quotes, while float values need to end with a lowercase `f`, as you
    can see with `FirstName` and `Pi`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串类型时，实际文本值需要放在一对双引号中，而浮点值需要以小写`f`结尾，就像`FirstName`和`Pi`一样。
- en: All our different variable types are now visible. Take note of the `bool` variable
    that Unity displays as a checkbox (true is checked and false is unchecked).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的不同变量类型现在都是可见的。请注意Unity显示为复选框的`bool`变量（选中为true，未选中为false）。
- en: '![](img/B17573_03_05.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_05.png)'
- en: 'Figure 3.5: LearningCurve script component with common variable types'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：带有常见变量类型的LearningCurve脚本组件
- en: Remember, any variables you declare as private won't show up in the Inspector
    window. Before we move on to conversions, we need to touch on a common and powerful
    application of the string data type; namely, the creation of strings that have
    variables interspersed at will.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您声明为私有的任何变量都不会显示在检视器窗口中。在我们继续进行转换之前，我们需要提及字符串数据类型的一个常见且强大的应用，即创建随意插入变量的字符串。
- en: While number types behave as you'd expect from grade school math, strings are
    a different story. It's possible to insert variables and literal values directly
    into text by starting with a `$` character, which is called string interpolation.
    You've already used an interpolated string in your `LogFormat()` debugging; adding
    the `$` character lets you use them anywhere!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数字类型的行为与小学数学中的预期相同，但字符串则是另一回事。可以通过以`$`字符开头直接在文本中插入变量和文字值，这称为字符串插值。您已经在`LogFormat()`调试中使用了插值字符串；添加`$`字符可以让您随时使用它们！
- en: 'Let''s create a simple interpolated string of our own inside `LearningCurve`
    to see this in action. Print out the interpolated string inside the `Start()`
    method directly after `ComputeAge()` is called:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`LearningCurve`中创建一个简单的插值字符串，以便看到它的效果。在`ComputeAge()`之后直接在`Start()`方法中打印插值字符串：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to the `$` character and curly brackets, the value of `FirstName` is
    treated as a value and is printed out inside the interpolated string. Without
    this special formatting, the string would just include `FirstName` as text instead
    of the variable value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`$`字符和花括号，`FirstName`的值被视为一个值，并在插值字符串中打印出来。如果没有这种特殊格式，字符串将只包括`FirstName`作为文本，而不是变量值。
- en: '![](img/B17573_03_06.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_06.png)'
- en: 'Figure 3.6: Console showing debug log output'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：控制台显示调试日志输出
- en: It's also possible to create interpolated strings using the `+` operator, which
    we'll talk about in the *Introducing operators* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`+`运算符创建插值字符串，我们将在*介绍运算符*部分讨论。
- en: Type conversions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'We''ve already seen that variables can only hold values of their declared types,
    but there will be situations where you''ll need to combine variables of different
    types. In programming terminology, these are called conversions, and they come
    in two main flavors:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到变量只能保存其声明类型的值，但会有情况需要组合不同类型的变量。在编程术语中，这些称为转换，有两种主要类型：
- en: '**Implicit** conversions take place automatically, usually when a smaller value
    will fit into another variable type without any rounding. For example, any integer
    can be implicitly converted into a `double` or `float` value without additional
    code:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式**转换通常在较小的值适合到另一个变量类型中时自动进行，通常不需要四舍五入。例如，任何整数都可以隐式转换为`double`或`float`值而无需额外的代码：'
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output in the **Console** pane can be seen in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台**窗格中的输出可以在以下截图中看到：'
- en: '![](img/B17573_03_07.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_07.png)'
- en: 'Figure 3.7: Implicit type conversion debug log output'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：隐式类型转换调试日志输出
- en: '**Explicit** conversions are needed when there is a risk of losing a variable''s
    information during the conversion. For example, if we wanted to convert a `double`
    value into an `int` value, we would have to explicitly cast (convert) it by adding
    the destination type in parentheses before the value we want to convert.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式**转换是在转换过程中存在丢失变量信息风险时需要的。例如，如果我们想要将`double`值转换为`int`值，我们必须通过在要转换的值之前加上目标类型的括号来显式地进行转换。'
- en: 'This tells the compiler that we are aware that data (or precision) might be
    lost:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这告诉编译器，我们知道数据（或精度）可能会丢失：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this explicit conversion, `3.14` would be rounded down to `3`, losing the
    decimal values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个显式转换中，`3.14`将被四舍五入为`3`，丢失小数值：
- en: '![](img/B17573_03_08.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_08.png)'
- en: 'Figure 3.8: Explicit type conversion debug log output'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：显式类型转换调试日志输出
- en: C# provides built-in methods for explicitly converting values to common types.
    For example, any type can be converted into a string value with the `ToString()`
    method, while the `Convert` class can handle more complicated conversions. You
    can find more info about these features under the *Methods* section at [https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了用于显式转换值为常见类型的内置方法。例如，任何类型都可以使用`ToString()`方法转换为字符串值，而`Convert`类可以处理更复杂的转换。您可以在[https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2)的*方法*部分找到有关这些功能的更多信息。
- en: So far, we've learned that types have rules regarding their interactions, operations,
    and conversion, but how do we handle a situation where we need to store a variable
    of an unknown type? This might sound crazy, but think about a data-download scenario—you
    know the information is coming into your game, but you're not sure what form it
    will take. We'll discuss how to handle this in the following section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到类型在交互、操作和转换方面有规则，但是当我们需要存储未知类型的变量时，我们该如何处理呢？这听起来很疯狂，但想想数据下载的情景——你知道信息正在进入你的游戏，但不确定它将采取什么形式。我们将在接下来的部分讨论如何处理这种情况。
- en: Inferred declarations
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断声明
- en: 'Luckily, C# can *infer* a variable''s type from its assigned value. For example,
    the `var` keyword can let the program know that the type of the data, `CurrentAge`,
    needs to be determined by its value of `32`, which is an integer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#可以从分配的值中*推断*出变量的类型。例如，`var`关键字可以让程序知道数据`CurrentAge`的类型需要根据其值`32`来确定，这是一个整数：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this is handy in certain situations, don't be suckered into the lazy programming
    habit of using inferred variable declarations for everything. This adds a lot
    of guesswork to your code, where it should be crystal clear.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下这很方便，但不要被懒惰的编程习惯所迷惑，使用推断变量声明来处理所有事情。这会给你的代码增加很多猜测，而应该是清晰明了的。
- en: Before we wrap up our discussion on data types and conversion, we do need to
    briefly touch on the idea of creating custom types, which we'll do next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于数据类型和转换的讨论之前，我们确实需要简要涉及创建自定义类型的想法，我们将在下一步中进行。
- en: Custom types
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义类型
- en: When we're talking about data types, it's important to understand early on that
    numbers and words (referred to as *literal values*) are not the only kinds of
    values a variable can store. For instance, a class, struct, or enumeration can
    be stored as variables. We will introduce these topics in *Chapter 5*, *Working
    with Classes, Structs, and OOP*, and explore them in greater detail in *Chapter
    10*, *Revisiting Types, Methods, and Classes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据类型时，早期理解数字和单词（称为*文字值*）不是变量可以存储的唯一种类的值是很重要的。例如，类、结构或枚举可以存储为变量。我们将在*第5章*，*使用类、结构和面向对象编程*中介绍这些主题，并在*第10章*，*重新审视类型、方法和类*中更详细地探讨它们。
- en: 'Types are complicated, and the only way to get comfortable with them is by
    using them. However, here are some important things to keep in mind:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型很复杂，唯一熟悉它们的方法是使用它们。然而，这里有一些重要的事情需要记住：
- en: All variables need to have a specified type (be it explicit or inferred)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量都需要指定类型（无论是显式还是推断）
- en: Variables can only hold values of their assigned type (a `string` value can't
    be assigned an `int` variable)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只能保存其分配类型的值（`string`值不能分配给`int`变量）
- en: If a variable needs to be assigned or combined with a variable of a different
    type, a conversion needs to take place (either implicit or explicit)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将变量分配或与不同类型的变量组合，需要进行转换（隐式或显式）
- en: The C# compiler can infer a variable's type from its value using the `var` keyword,
    but should only be used when the type isn't known when it's created
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#编译器可以使用`var`关键字从其值推断变量的类型，但应该仅在创建时类型未知时使用
- en: That's a lot of nitty-gritty detail we've just jammed into a few sections, but
    we're not done yet. We still need to understand how naming conventions work in
    C#, as well as where the variables live in our scripts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在几个部分中塞入了很多细节，但我们还没有完成。我们还需要了解C#中命名约定的工作方式，以及变量在我们的脚本中的位置。
- en: Naming variables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量命名
- en: Picking names for your variables might seem like an afterthought in light of
    everything we've learned about access modifiers and types, but it shouldn't be
    a straightforward choice. Clear and consistent naming conventions in your code
    will not only make it more readable but will also ensure that other developers
    on your team understand your intentions without having to ask.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为变量选择名称可能看起来像是在考虑访问修饰符和类型之后的事情，但它不应该是一个简单的选择。在代码中清晰一致的命名约定不仅会使其更易读，而且还会确保团队中的其他开发人员了解您的意图，而无需询问。
- en: 'The first rule when it comes to naming a variable is that the name you give
    it should be meaningful; the second rule is that you use Pascal case. Let''s take
    a common example from games and declare a variable to store a player''s health:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量时的第一个规则是，您给出的名称应该是有意义的；第二个规则是使用帕斯卡命名法。让我们以游戏中常见的一个例子来看，声明一个变量来存储玩家的健康：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you find yourself declaring a variable like this, alarm bells should be going
    off in your head. Whose health? Is it storing the maximum or minimum value? What
    other code will be affected when this value changes? These are all questions that
    should be easily answered by a meaningful variable name; you don't want to find
    yourself confused by your code in a week or a month.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现自己声明变量像这样，你的脑中应该响起警报。谁的健康？它是存储最大值还是最小值？当此值更改时，将受到影响的其他代码是什么？这些都是有意义的变量名称应该很容易回答的问题；你不希望在一周或一个月后被自己的代码搞糊涂。
- en: 'With that said, let''s try to make this a bit better using a Pascal case name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，让我们尝试使用帕斯卡命名法使其更好一些：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, Pascal case starts each word in the variable name with an uppercase
    letter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，帕斯卡命名法将变量名称中的每个单词的首字母大写。
- en: That's much better. With a little thought, we've updated the variable name with
    meaning and context. Since there is no technical limit in terms of how long a
    variable name can be, you might find yourself going overboard and writing out
    ridiculously descriptive names, which will give you problems just as much as a
    short, non-descriptive name would.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样好多了。经过一点思考，我们已经更新了变量名称并赋予了意义和上下文。由于在变量名称的长度方面没有技术限制，您可能会发现自己过度并写出过于描述性的名称，这将给您带来问题，就像短的、不描述性的名称一样。
- en: As a general rule, make a variable name as descriptive as it needs to be—no
    more, no less. Find your style and stick to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，将变量名称描述得尽可能清楚——不多也不少。找到您的风格并坚持下去。
- en: Understanding variable scope
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量范围
- en: 'We''re getting to the end of our dive into variables, but there''s still one
    more important topic we need to cover: scope. Similar to access modifiers, which
    determine which outside classes can grab a variable''s information, the variable
    scope is the term used to describe where a given variable exists and its access
    point within its containing class.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入了解了变量，但还有一个重要的主题需要讨论：范围。类似于访问修饰符，确定外部类可以获取变量信息的方式，变量范围是用来描述给定变量存在的位置及其在其包含类中的访问点的术语。
- en: 'There are three main levels of variable scope in C#:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有三个主要的变量范围级别：
- en: '**Global** scope refers to a variable that can be accessed by an entire program;
    in this case, a game. C# doesn''t directly support global variables, but the concept
    is useful in certain cases, which we''ll cover in *Chapter 10*, *Revisiting Types,
    Methods, and Classes.*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**范围指的是整个程序（在本例中是游戏）都可以访问的变量。C#不直接支持全局变量，但这个概念在某些情况下是有用的，我们将在*第10章*“重新审视类型、方法和类”中介绍。'
- en: '**Class** or **member** scope refers to a variable that is accessible anywhere
    in its containing class.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**或**成员**范围指的是可以在其包含类中的任何地方访问的变量。'
- en: '**Local** scope refers to a variable that is only accessible inside the specific
    block of code it''s created in.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部**范围指的是只能在其创建的特定代码块内部访问的变量。'
- en: 'Take a look at the following screenshot. You don''t need to put this into `LearningCurve`
    if you don''t want to; it''s only for visualization purposes at this point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的屏幕截图。如果你不想把它放到`LearningCurve`中，你不需要；目前它只是用于可视化目的：
- en: '![](img/B17573_03_09.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_09.png)'
- en: 'Figure 3.9: Diagram of different scopes in the LearningCurve script'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：LearningCurve脚本中不同范围的图表
- en: When we talk about code blocks, we're referring to the area inside any set of
    curly brackets. These brackets serve as a kind of visual hierarchy in programming;
    the farther right-indented they are, the deeper they are nested in the class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码块时，我们指的是任何一组花括号内部的区域。这些括号在编程中充当一种视觉层次结构；它们向右缩进得越多，它们在类中嵌套得越深。
- en: 'Let''s break down the class and local scope variables in the preceding screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下前面屏幕截图中的类和局部范围变量：
- en: '`CharacterClass` is declared at the very top of the class, which means we can
    reference it by name anywhere inside `LearningCurve`. You might hear this concept
    referred to as variable visibility, which is a good way of thinking about it.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterClass`在类的顶部声明，这意味着我们可以在`LearningCurve`的任何地方通过名称引用它。您可能会听到这个概念被称为变量可见性，这是一个很好的思考方式。'
- en: '`CharacterHealth` is declared inside the `Start()` method, which means it is
    only visible inside that block of code. We can still access `CharacterClass` from
    `Start()` with no issue, but if we attempted to access `CharacterHealth` from
    anywhere but `Start()`, we would get an error.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterHealth`在`Start()`方法中声明，这意味着它只能在该代码块内部可见。我们仍然可以毫无问题地从`Start()`中访问`CharacterClass`，但如果我们试图从`Start()`之外的任何地方访问`CharacterHealth`，我们将会收到一个错误。'
- en: '`CharacterName` is in the same boat as `CharacterHealth`; it can only be accessed
    from the `CreateCharacter()` method. This was just to illustrate that there can
    be multiple, even nested, local scopes in a single class.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterName`和`CharacterHealth`处于相同的境地；它们只能从`CreateCharacter()`方法中访问。这只是为了说明在单个类中可以有多个，甚至是嵌套的本地作用域。'
- en: 'If you spend enough time around programmers, you''ll hear discussions (or arguments,
    depending on the time of day) about the best place to declare a variable. The
    answer is simpler than you might think: variables should be declared with their
    use in mind. If you have a variable that needs to be accessed throughout a class,
    make it a class variable. If you only need a variable in a specific section of
    code, declare it as a local variable.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序员周围花足够的时间，你会听到关于声明变量的最佳位置的讨论（或争论，取决于一天中的时间）。答案比你想象的要简单：变量应该根据它们的使用情况进行声明。如果你有一个需要在整个类中访问的变量，那就把它作为类变量。如果你只需要一个变量在特定的代码段中，那就声明它为局部变量。
- en: Note that only class variables can be viewed in the Inspector window, which
    isn't an option for local or global variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有类变量可以在检查器窗口中查看，这对于局部或全局变量来说不是一个选项。
- en: With naming and scope in our toolbox, let's transport ourselves back to middle
    school math class and relearn how arithmetic operations work all over again!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了命名和作用域的工具，让我们把自己带回到中学数学课堂，重新学习算术运算是如何工作的！
- en: Introducing operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍操作符
- en: Operator symbols in programming languages represent the *arithmetic*, *assignment*,
    *relational*, and *logical* functionality that types can perform. Arithmetic operators
    represent basic math functions, while assignment operators perform math and assignment
    functions together on a given value. Relational and logical operators evaluate
    conditions between multiple values, such as *greater than*, *less than*, and *equal
    to*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的操作符符号代表类型可以执行的*算术*、*赋值*、*关系*和*逻辑*功能。算术运算符代表基本的数学函数，而赋值运算符在给定值上执行数学和赋值功能。关系和逻辑运算符评估多个值之间的条件，例如*大于*、*小于*和*等于*。
- en: C# also offers bitwise and miscellaneous operators, but these won't come into
    play for you until you're well on your way to creating more complex applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C#还提供了位和杂项运算符，但这些对你来说只有在你开始创建更复杂的应用程序时才会发挥作用。
- en: At this point, it only makes sense to cover arithmetic and assignment operators,
    but we'll get to relational and logical functionality when it becomes relevant
    in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，只有涵盖算术和赋值运算符才有意义，但当它在下一章变得相关时，我们将介绍关系和逻辑功能。
- en: Arithmetic and assignments
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术和赋值
- en: 'You''re already familiar with the arithmetic operator symbols from school:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了学校中的算术运算符符号：
- en: '`+` for addition'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`表示加法'
- en: '`-` for subtraction'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`表示减法'
- en: '`/` for division'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`表示除法'
- en: '`*` for multiplication'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`表示乘法'
- en: 'C# operators follow the conventional order of operations, that is, evaluating
    parentheses first, then exponents, then multiplication, then division, then addition,
    and finally subtraction. For instance, the following equations will provide different
    results, even though they contain the same values and operators:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: C#操作符遵循常规的运算顺序，即首先计算括号，然后是指数，然后是乘法，然后是除法，然后是加法，最后是减法。例如，以下方程将提供不同的结果，即使它们包含相同的值和运算符：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Operators work the same when applied to variables as they do with literal values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于变量时，操作符的工作方式与应用于文字值时相同。
- en: 'Assignment operators can be used as a shorthand replacement for any math operation
    by using any arithmetic and equals symbol together. For example, if we wanted
    to multiply a variable, you could use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符可以作为任何数学运算的简写替代，方法是将任何算术和等号符号结合在一起。例如，如果我们想要对一个变量进行乘法运算，可以使用以下代码：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second, alternative, way to do this is shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种替代方法如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The equals symbol is also considered an assignment operator in C#. The other
    assignment symbols follow the same syntax pattern as our preceding multiplication
    example: `+=`, `-=`, and `/=` for add and assign, subtract and assign, and divide
    and assign, respectively.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 等号符号在C#中也被认为是一个赋值运算符。其他赋值符号遵循与我们之前的乘法示例相同的语法模式：`+=`，`-=`和`/=`分别用于加和赋值，减和赋值，以及除和赋值。
- en: 'Strings are a special case when it comes to operators as they can use the addition
    symbol to create patchwork text, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作符方面，字符串是一个特殊情况，因为它们可以使用加号来创建拼接文本，如下所示：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will produce the following when logged in to the **Console** panel:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当登录到**控制台**面板时，将产生以下结果：
- en: '![](img/B17573_03_10.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_10.png)'
- en: 'Figure 3.10: Using operators on strings'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：在字符串上使用操作符
- en: This approach tends to produce clunky code, making string interpolation the
    preferred method for putting together different bits of text in most cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法往往会产生笨拙的代码，使得字符串插值成为大多数情况下拼接不同文本的首选方法。
- en: Take note that arithmetic operators don't work on all data types. For example,
    the `*` and `/` operators don't work on string values, and none of these operators
    work on Booleans. Having learned that types have rules that govern what kind of
    operations and interactions they can have, let's give it a shot in practice in
    the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，算术运算符不适用于所有数据类型。例如，`*`和`/`运算符不适用于字符串值，而这些运算符都不适用于布尔值。在了解了类型有规则来规定它们可以进行的操作和交互之后，让我们在下一节的实践中试一试。
- en: 'Let''s do a little experiment: we''ll try to multiply our `string` and `float`
    variables together, as we did earlier with our numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个小实验：我们将尝试将我们的`string`和`float`变量相乘，就像我们之前对数字做的那样：
- en: '![](img/B17573_03_11.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_11.png)'
- en: 'Figure 3.11: Visual Studio incorrect type operation error message'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：Visual Studio不正确的类型操作错误消息
- en: Look at Visual Studio and you'll see we've got an error message letting us know
    that a `string` type and a `float` type can't be multiplied. This error will also
    show up in the Unity **Console**, and won't let the project build.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 Visual Studio，您会看到我们收到了一个错误消息，告诉我们`string`类型和`float`类型不能相乘。这个错误也会显示在 Unity
    **控制台**中，并且不会让项目构建。
- en: '![](img/B17573_03_12.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_12.png)'
- en: 'Figure 3.12: Console showing operator errors on incompatible data types'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：控制台显示不兼容数据类型的运算符错误
- en: Whenever you see this type of error, go back and inspect your variable types
    for incompatibilities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您看到这种类型的错误时，回去检查变量类型是否不兼容。
- en: We must clean up this example, as the compiler won't allow us to run our game
    at this point. Choose between a pair of backslashes (`//`) at the beginning of
    the line `Debug.Log(FirstName*Pi)`, or delete it altogether.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须清理这个示例，因为编译器现在不允许我们运行游戏。在`Debug.Log(FirstName*Pi)`行的开头选择一对反斜杠(`//`)，或者将其完全删除。
- en: That's as far as we need to go in terms of variables and types for the moment.
    Be sure to test yourself on this chapter's quiz before moving on!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在变量和类型方面需要了解的全部内容。在继续之前，请务必在本章的测验中进行测试！
- en: Defining methods
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义方法
- en: In the previous chapter, we briefly touched on the role methods play in our
    programs; namely, that they store and execute instructions, just like variables
    store values. Now, we need to understand the syntax of method declarations and
    how they drive action and behavior in our classes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了方法在我们的程序中扮演的角色；即，它们存储和执行指令，就像变量存储值一样。现在，我们需要理解方法声明的语法以及它们如何在我们的类中驱动行为和动作。
- en: 'As with variables, method declarations have their basic requirements, which
    are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法声明具有其基本要求，如下所示：
- en: The type of data that will be returned by the method
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法将返回的数据类型
- en: A unique name, starting with a capital letter
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以大写字母开头的唯一名称
- en: A pair of parentheses following the method name
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名后面跟着一对括号
- en: A pair of curly brackets marking the method body (where instructions are stored)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对花括号标记方法体（其中存储指令）
- en: 'Putting all of these rules together, we get a simple method blueprint:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些规则放在一起，我们得到一个简单的方法蓝图：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the default `Start()` method in `LearningCurve` as a practical
    example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解`LearningCurve`中的默认`Start()`方法作为一个实际示例：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding output, we can see the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到以下内容：
- en: The method starts with the `void` keyword, which is used as the method's return
    type if it doesn't return any data.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法以`void`关键字开头，如果它不返回任何数据，则用作方法的返回类型。
- en: The method has a unique name within the class. You can use the same name in
    different classes, but you should aim to always make your names unique no matter
    what.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在类中具有唯一的名称。您可以在不同的类中使用相同的名称，但无论如何，您都应该始终使您的名称唯一。
- en: The method has a pair of parentheses after its name to hold any potential parameters.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在其名称后面有一对括号，用于保存任何潜在的参数。
- en: The method body is defined by a set of curly brackets.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法体由一组花括号定义。
- en: In general, if you have a method that has an empty method body, it's good practice
    to delete it from the class. You always want to be pruning your scripts of unused
    code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果一个方法有一个空的方法体，最好将其从类中删除。您总是希望修剪您的脚本中未使用的代码。
- en: Like variables, methods can also have security levels. However, they can also
    have input parameters, both of which we'll be discussing next!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法也可以具有安全级别。但是，它们也可以有输入参数，我们将在下一节讨论这两个方面！
- en: Declaring methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明方法
- en: Methods can also have the same four access modifiers that are available to variables,
    as well as input parameters. Parameters are variable placeholders that can be
    passed into methods and accessed inside them. The number of input parameters you
    can use isn't limited, but each one needs to be separated by a comma, show its
    data type, and have a unique name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有与变量相同的四个访问修饰符，以及输入参数。参数是可以传递到方法中并在其中访问的变量占位符。您可以使用的输入参数数量没有限制，但每个参数都需要用逗号分隔，显示其数据类型，并具有唯一的名称。
- en: Think of method parameters as variable placeholders whose values can be used
    inside the method body.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法参数视为变量占位符，其值可以在方法体内使用。
- en: 'If we apply these options, our updated blueprint will look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用这些选项，我们的更新后的蓝图将如下所示：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is no explicit access modifier, the method defaults to private. A private
    method, like a private variable, cannot be called from other scripts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显式的访问修饰符，方法默认为私有。私有方法，就像私有变量一样，不能从其他脚本中调用。
- en: 'To call a method (meaning to run or execute its instructions), we simply use
    its name, followed by a pair of parentheses, with or without parameters, and cap
    it off with a semicolon:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用方法（即运行或执行其指令），我们只需使用其名称，后面跟一对括号，带有或不带有参数，并以分号结束：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like variables, every method has a fingerprint that describes its access level,
    return type, and parameters. This is called its method signature. Essentially,
    a method's signature marks it as unique to the compiler so Visual Studio knows
    what to do with it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，每个方法都有一个指纹，描述其访问级别、返回类型和参数。这称为方法签名。基本上，方法的签名将其标记为编译器的唯一标识，因此 Visual Studio
    知道如何处理它。
- en: Now that we understand how methods are structured, let's create one of our own.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了方法的结构，让我们创建一个自己的方法。
- en: 'The *Methods are placeholders too* section in the previous chapter had you
    blindly copy a method called `ComputeAge()` into `LearningCurve` without you knowing
    what you were getting into. This time, let''s purposefully create a method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的*方法也是占位符*部分让你盲目地将一个名为`ComputeAge()`的方法复制到`LearningCurve`中，而你并不知道你在做什么。这一次，让我们有意识地创建一个方法：
- en: Declare a `public` method with a void return type called `GenerateCharacter():`
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个带有void返回类型的`public`方法，名为`GenerateCharacter()`：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a simple `Debug.Log()` inside the new method and print out a character
    name from your favorite game or movie:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新方法中添加一个简单的`Debug.Log()`，并打印出你最喜欢的游戏或电影中的角色名：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call `GenerateCharacter()` inside the `Start()` method and hit play:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法中调用`GenerateCharacter()`并点击播放：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the game starts up, Unity automatically calls `Start()`, which, in turn,
    calls our `GenerateCharacter()` method and prints the result to the Console window.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏启动时，Unity会自动调用`Start()`，然后调用我们的`GenerateCharacter()`方法，并将结果打印到控制台窗口。
- en: If you have read enough documentation, you'll see different terminology related
    to methods. Throughout the rest of this book, when a method is created or declared,
    I'll refer to this as **defining** a method. Similarly, I'll refer to running
    or executing a method as **calling** that method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了足够的文档，你会看到与方法相关的不同术语。在本书的其余部分中，当一个方法被创建或声明时，我会称之为**定义**一个方法。同样，我会称运行或执行一个方法为**调用**该方法。
- en: The power of naming is integral to the entirety of the programming landscape,
    so it shouldn't be a surprise that we're going to revisit naming conventions for
    methods before moving on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的力量对整个编程领域至关重要，所以在继续之前，我们将重新审视方法的命名约定。
- en: Naming conventions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: Like variables, methods need unique, meaningful names to distinguish them in
    code. Methods drive actions, so it's a good practice to name them with that in
    mind. For example, `GenerateCharacter()` sounds like a command, which reads well
    when you call it in a script, whereas a name such as `Summary()` is bland and
    doesn't paint a very clear picture of what the method will accomplish. Like variables,
    method names are written in Pascal case.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 像变量一样，方法需要独特而有意义的名称，以在代码中加以区分。方法驱动操作，因此最好的做法是以此为考量来命名它们。例如，`GenerateCharacter()`听起来像一个命令，在脚本中调用时读起来很好，而`Summary()`这样的名称很平淡，不太清楚方法将实现什么。像变量一样，方法名称采用帕斯卡命名法。
- en: Methods as logic detours
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法作为逻辑的绕道
- en: We've seen that lines of code execute sequentially in the order they're written,
    but bringing methods into the picture introduces a unique situation. Calling a
    method tells the program to take a detour into the method instructions, run them
    one by one, and then resume sequential execution where the method was called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到代码行按照它们编写的顺序依次执行，但是引入方法会引入一种独特的情况。调用一个方法告诉程序进入方法指令，逐个运行它们，然后在调用方法的地方恢复顺序执行。
- en: 'Take a look at the following screenshot and see whether you can figure out
    in what order the debug logs will be printed out to the console:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的截图，看看你能否弄清楚调试日志将以什么顺序打印到控制台：
- en: '![](img/B17573_03_13.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_13.png)'
- en: 'Figure 3.13: Considering the order of debug logs'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：考虑调试日志的顺序
- en: 'These are the steps that occur:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发生的步骤：
- en: '`Choose a character` prints out first because it''s the first line of code.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`选择一个角色`首先打印出来，因为它是代码的第一行。'
- en: 'When `GenerateCharacter()` is called, the program jumps to line 23, prints
    out `Character: Spike`, and then resumes execution at line 17.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当调用`GenerateCharacter()`时，程序跳转到第23行，打印出`Character: Spike`，然后在第17行恢复执行。'
- en: '`A fine choice` prints out last, after all the lines in `GenerateCharacter()`
    have finished running.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A fine choice`在`GenerateCharacter()`中的所有行都运行完毕后打印出来。'
- en: '![](img/B17573_03_14.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_14.png)'
- en: 'Figure 3.14: Console showing the output of character building code'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：控制台显示角色构建代码的输出
- en: Now, methods in themselves wouldn't be very useful beyond simple examples like
    these if we couldn't add parameter values to them, which is what we'll do next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能给方法添加参数值，那么方法本身就不会比这些简单的示例更有用。
- en: Specifying parameters
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定参数
- en: 'Chances are your methods aren''t always going to be as simple as `GenerateCharacter()`.
    To pass in additional information, we''ll need to define parameters that our method
    can accept and work with. Every method parameter is an instruction and needs to
    have two things:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你的方法可能并不总是像`GenerateCharacter()`这样简单。为了传入额外的信息，我们需要定义方法可以接受和处理的参数。每个方法参数都是一条指令，需要具备两个要素：
- en: An explicit type
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个明确的类型
- en: A unique name
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独特的名称
- en: Does this sound familiar? Method parameters are essentially stripped-down variable
    declarations and perform the same function. Each parameter acts like a local variable,
    only accessible inside their specific method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很熟悉吗？方法参数本质上是简化的变量声明，具有相同的功能。每个参数都像一个局部变量，只能在其特定方法内部访问。
- en: You can have as many parameters as you need. Whether you're writing custom methods
    or using built-in ones, the parameters that are defined are what the method requires
    to perform its specified task.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有任意数量的参数。无论你是编写自定义方法还是使用内置方法，定义的参数是方法执行其指定任务所需的。
- en: 'If parameters are the blueprint for the types of values a method can accept,
    then arguments are the values themselves. To break this down further, consider
    the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是方法可以接受的值类型的蓝图，那么参数就是这些值本身。为了进一步解释这一点，考虑以下内容：
- en: The argument that's passed into a method needs to match the parameter type,
    just like a variable type and its value
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传入方法的参数需要与参数类型匹配，就像变量类型和它的值一样
- en: Arguments can be literal values (for instance, the number 2) or variables declared
    elsewhere in the class
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数可以是字面值（例如数字2）或在类中其他地方声明的变量
- en: Argument names and parameter names don't need to match to compile.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名和参数名不需要匹配就能编译。
- en: Now, let's move on and add some method parameters to make `GenerateCharacter()`
    a bit more interesting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并添加一些方法参数，使`GenerateCharacter()`变得更有趣一些。
- en: 'Let''s update `GenerateCharacter()` so that it can take in two parameters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`GenerateCharacter()`，使其可以接受两个参数：
- en: 'Add two method parameters: one for a character''s name of the `string` type,
    and another for a character''s level of the `int` type:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个方法参数：一个是`string`类型的角色名称，另一个是`int`类型的角色等级：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update `Debug.Log()` so that it uses these new parameters:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Debug.Log()`，使其使用这些新参数：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the `GenerateCharacter()` method call in `Start()` with your arguments,
    which can be either literal values or declared variables:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`中更新`GenerateCharacter()`方法调用，使用你的参数，可以是文字值或已声明的变量：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Your code should look like the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该如下所示：
- en: '![](img/B17573_03_15.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_15.png)'
- en: 'Figure 3.15: Updating the GenerateCharacter() method'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：更新GenerateCharacter()方法
- en: Here, we defined two parameters, `name` (string) and `level` (int), and used
    them inside the `GenerateCharacter()` method, just like local variables. When
    we called the method inside `Start()`, we added argument values for each parameter
    with corresponding types. In the preceding screenshot, you can see that using
    the literal string value in quotations produced the same result as using `characterLevel`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个参数，`name`（字符串）和`level`（整数），并在`GenerateCharacter()`方法中使用它们，就像本地变量一样。当我们在`Start()`中调用方法时，我们为每个参数添加了相应类型的参数值。在前面的截图中，你可以看到使用引号中的文字字符串值产生了与使用`characterLevel`相同的结果。
- en: '![](img/B17573_03_16.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_16.png)'
- en: 'Figure 3.16: Console showing the output from method parameters'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：控制台显示方法参数输出
- en: Going even further with methods, you might be wondering how we can pass values
    from inside the method and back out again. This brings us to our next section
    on return values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中传递值并再次传递出来，你可能会想知道我们如何做到这一点。这将引出我们下一节关于返回值的内容。
- en: Specifying return values
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定返回值
- en: Aside from accepting parameters, methods can return values of any C# type. All
    of our previous examples have used the `void` type, which doesn't return anything,
    but being able to write instructions and pass back computed results is where methods
    shine.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受参数，方法可以返回任何C#类型的值。我们之前的所有示例都使用了`void`类型，它不返回任何东西，但能够编写指令并传回计算结果是方法的亮点所在。
- en: According to our blueprints, method return types are specified after the access
    modifier. In addition to the type, the method needs to contain the `return` keyword,
    followed by the return value. A return value can be a variable, a literal value,
    or even an expression, as long as it matches the declared return type.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的蓝图，方法返回类型在访问修饰符之后指定。除了类型之外，方法需要包含`return`关键字，后面跟着返回值。返回值可以是变量、文字值，甚至是表达式，只要它与声明的返回类型匹配即可。
- en: Methods that have a return type of `void` can still use the return keyword with
    no value or expression assigned. Once the line with the return keyword is reached,
    the method will stop executing. This is useful in cases where you want to avoid
    certain behaviors or guard against program crashes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 具有返回类型为`void`的方法仍然可以使用没有值或表达式分配的return关键字。一旦到达带有return关键字的行，方法将停止执行。这在你想要避免某些行为或防止程序崩溃的情况下非常有用。
- en: 'Next, add a return type to `GenerateCharacter()` and learn how to capture it
    in a variable. Let''s update the `GenerateCharacter()` method so that it returns
    an integer:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给`GenerateCharacter()`添加一个返回类型，并学习如何将其捕获到一个变量中。让我们更新`GenerateCharacter()`方法，使其返回一个整数：
- en: 'Change the return type in the method declaration from `void` to `int`, and
    set the return value to `level += 5` using the `return` keyword:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法声明中的返回类型从`void`更改为`int`，并使用`return`关键字将返回值设置为`level += 5`：
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`GenerateCharacter()` will now return an integer. This is computed by adding
    `5` to the level argument. We haven''t specified how, or if, we want to use this
    return value, which means that right now, the script won''t do anything new.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateCharacter()`现在将返回一个整数。这是通过将`5`添加到level参数来计算的。我们还没有指定如何或是否要使用这个返回值，这意味着现在脚本不会做任何新的事情。'
- en: 'Now, the question becomes: how do we capture and use the newly added return
    value? Well, we''ll discuss that very topic in the following section.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是：我们如何捕获和使用新添加的返回值？嗯，我们将在下一节中讨论这个话题。
- en: Using return values
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用返回值
- en: 'When it comes to using return values, there are two approaches available:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用返回值时，有两种可用的方法：
- en: Create a local variable to capture (store) the returned value.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个本地变量来捕获（存储）返回的值。
- en: Use the calling method itself as a stand-in for the returned value, using it
    just like a variable. The calling method is the actual line of code that fires
    the instructions, which, in our example, would be `GenerateCharacter("Spike",
    CharacterLevel)`. You can even pass a calling method into another method as an
    argument if need be.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调用方法本身作为返回值的替代，就像使用变量一样。调用方法是实际触发指令的代码行，在我们的示例中，就是`GenerateCharacter("Spike",
    CharacterLevel)`。如果需要，甚至可以将调用方法作为参数传递给另一个方法。
- en: The first option is preferred in most programming circles for its readability.
    Throwing around method calls as variables can get messy fast, especially when
    we use them as arguments in other methods.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程圈子更喜欢第一种选项，因为它更易读。随意使用方法调用作为变量可能会很快变得混乱，特别是当我们将它们用作其他方法的参数时。
- en: Let's give this a try in our code by capturing and debugging the return value
    that `GenerateCharacter()` returns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中尝试一下，捕获和调试`GenerateCharacter()`返回的返回值。
- en: 'We''re going to use both ways of capturing and using return variables with
    two simple debug logs:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种捕获和使用返回变量的方法来进行简单的调试日志：
- en: 'Create a new local variable in the `Start` method of the `int` type, called
    `NextSkillLevel`, and assign it to the return value of the `GenerateCharacter()`
    method call we already have in place:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中创建一个新的本地变量，类型为`int`，名为`NextSkillLevel`，并将其分配给我们已经放置的`GenerateCharacter()`方法调用的返回值：
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add two debug logs, with the first printing out `NextSkillLevel` and the second
    printing out a new calling method with argument values of your choice:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个调试日志，第一个打印出`NextSkillLevel`，第二个打印出一个新的调用方法，参数值由你选择：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Comment out the debug log inside `GenerateCharacter()` with two forward slashes
    (`//`) to make the console output less cluttered. Your code should look like the
    following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用两个斜杠(`//`)注释掉`GenerateCharacter()`内部的调试日志，以减少控制台输出的混乱。你的代码应该如下所示：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the file and hit play in Unity. To the compiler, the `NextSkillLevel` variable
    and the `GenerateCharacter()` method caller represent the same information, namely
    an integer, which is why both logs show the number `37`:![](img/B17573_03_17.png)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在Unity中点击播放。对于编译器来说，`NextSkillLevel`变量和`GenerateCharacter()`方法调用者代表相同的信息，即一个整数，这就是为什么两个日志都显示数字`37`的原因：![](img/B17573_03_17.png)
- en: 'Figure 3.17: Console output from the character generation code'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17：角色生成代码的控制台输出
- en: That was a lot to take in, especially given the exponential possibilities of
    methods with parameters and return values. However, we'll ease off the throttle
    here for a minute and consider some of Unity's most common methods to catch a
    little breathing room.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容，特别是考虑到带有参数和返回值的方法的指数可能性。然而，我们将在这里放慢节奏一分钟，考虑一下Unity最常用的一些方法，给自己喘口气。
- en: But first, see if you can handle a challenge in the next *Hero's trial*!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，看看你是否能在下一个*英雄的试炼*中应对一个挑战！
- en: Hero's trial – methods as arguments
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的试炼-方法作为参数
- en: If you're feeling brave, why not try creating a new method that takes in an
    `int` parameter and simply prints it out to the console? No return type is necessary.
    When you've got that, call the method in `Start`, pass in a `GenerateCharacter`
    method call as its argument, and take a look at the output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到勇敢，为什么不尝试创建一个接受`int`参数并简单打印到控制台的新方法？不需要返回类型。当你做到这一点时，在`Start`中调用该方法，将`GenerateCharacter`方法调用作为其参数传入，并查看输出。
- en: Dissecting common Unity methods
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解剖常见的Unity方法
- en: 'We''re now at a point where we can realistically discuss the most common default
    methods that come with any new Unity C# script: `Start()` and `Update()`. Unlike
    the methods we define ourselves, methods belonging to the `MonoBehaviour` class
    are called automatically by the Unity engine according to their respective rules.
    In most cases, it''s important to have at least one `MonoBehaviour` method in
    a script to kick off your code.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了一个可以真实讨论任何新的Unity C#脚本都带有的最常见默认方法的地步：`Start()`和`Update()`。与我们自己定义的方法不同，属于`MonoBehaviour`类的方法根据其各自的规则由Unity引擎自动调用。在大多数情况下，至少需要在脚本中有一个`MonoBehaviour`方法来启动你的代码。
- en: You can find a complete list of all available MonoBehaviour methods and their
    descriptions at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    You can also find the order in which each method is executed at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)找到所有可用的MonoBehaviour方法及其描述的完整列表。你还可以在[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)找到每个方法执行的顺序。
- en: Just like stories, it's always a good idea to start at the beginning. So, naturally,
    we should take a look at every Unity script's first default method—`Start()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就像故事一样，从头开始总是一个好主意。因此，自然而然地，我们应该看一下每个Unity脚本的第一个默认方法——`Start()`。
- en: The Start method
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始方法
- en: Unity calls the `Start()` method on the first frame where a script is enabled
    for the first time. Since `MonoBehaviour` scripts are almost always attached to
    *GameObjects* in a scene, their attached scripts are enabled at the same time
    they are loaded when you hit play. In our project, `LearningCurve`is attached
    to the **Main Camera** *GameObject*, which means that its `Start()` method runs
    when the main camera is loaded into the scene. `Start()` is primarily used to
    set up variables or perform logic that needs to happen before `Update()` runs
    for the first time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在脚本第一次启用时的第一帧调用`Start()`方法。由于`MonoBehaviour`脚本几乎总是附加到场景中的*GameObjects*上，它们的附加脚本在加载时同时启用。在我们的项目中，`LearningCurve`附加到**Main
    Camera** *GameObject*上，这意味着它的`Start()`方法在主摄像机加载到场景时运行。`Start()`主要用于设置变量或执行需要在`Update()`第一次运行之前发生的逻辑。
- en: The examples we've worked on so far have all used `Start()`, even though they
    weren't performing setup actions, which isn't normally the way it would be used.
    However, it only fires once, making it an excellent tool to use for displaying
    one-time-only information on the console.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的示例都使用了`Start()`，即使它们并没有执行设置操作，这并不是通常的使用方式。然而，它只会执行一次，使其成为在控制台上显示一次性信息的绝佳工具。
- en: 'Other than `Start()`, there''s one other major Unity method that you''ll run
    into by default: `Update()`. Let''s familiarize ourselves with how it works in
    the following section before we finish off this chapter.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Start()`，默认情况下你会遇到另一个重要的Unity方法：`Update()`。在我们完成本章之前，让我们在下一节中熟悉一下它的工作原理。
- en: The Update method
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新方法
- en: If you spend enough time looking at the sample code in the Unity Scripting Reference
    ([https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)),
    you'll notice that a vast majority of the code is executed using the `Update()`
    method. As your game runs, the Scene window is displayed many times per second,
    which is called the frame rate or **frames per second** (**FPS**).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花足够的时间查看Unity脚本参考中的示例代码（[https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)），你会注意到绝大多数代码都是使用`Update()`方法执行的。当你的游戏运行时，场景窗口会以每秒多次的频率显示，这被称为帧率或**每秒帧数**（**FPS**）。
- en: After each frame is displayed, the `Update()` method is called by Unity, making
    it one of the most executed methods in your game. This makes it ideal for detecting
    mouse and keyboard input or running gameplay logic.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧显示后，Unity都会调用`Update()`方法，使其成为游戏中执行次数最多的方法之一。这使其非常适合检测鼠标和键盘输入或运行游戏逻辑。
- en: 'If you''re curious about the FPS rating on your machine, hit play in Unity
    and click the **Stats** tab in the upper-right corner of the **Game** view:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对你的机器的FPS评级感到好奇，那就在Unity中点击**Stats**选项卡，并在**Game**视图的右上角点击播放：
- en: '![](img/B17573_03_18.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_18.jpg)'
- en: 'Figure 3.18: Unity editor showing the Stats panel with graphics FPS count'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18：Unity编辑器显示带有图形FPS计数的Stats面板
- en: You'll be using the `Start()` and `Update()` methods in the lion's share of
    your initial C# scripts, so get acquainted with them. That being said, you've
    reached the end of this chapter with a pocketful of the most fundamental building
    blocks programming with C# has to offer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在你最初的C#脚本中，你将会大量使用`Start()`和`Update()`方法，所以要熟悉它们。话虽如此，你已经掌握了本章提供的C#编程中最基本的构建模块。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a fast descent from the basic theory of programming and
    its building blocks into the strata of real code and C# syntax. We've seen good
    and bad forms of code formatting, learned how to debug information in the Unity
    console, and created our first variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章从编程的基本理论和构建模块迅速下降到了真实代码和C#语法的层面。我们看到了代码格式的好坏形式，学会了如何在Unity控制台中调试信息，并创建了我们的第一个变量。
- en: C# types, access modifiers, and variable scope weren't far behind, as we worked
    with member variables in the Inspector window and started venturing into the realm
    of methods and actions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: C#类型、访问修饰符和变量作用域紧随其后，当我们在检视器窗口中使用成员变量并开始涉足方法和操作领域时。
- en: Methods helped us to understand written instructions in code, but more importantly,
    how to properly harness their power into useful behaviors. Input parameters, return
    types, and method signatures are all important topics, but the real gift they
    offer is the potential for new kinds of actions to be performed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 方法帮助我们理解代码中的书面指令，但更重要的是，如何正确地利用它们的力量来实现有用的行为。输入参数、返回类型和方法签名都是重要的主题，但它们真正提供的是执行新类型行为的潜力。
- en: You're now armed with the two fundamental building blocks of programming; almost
    everything you'll do from now on will be an extension or application of these
    two concepts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在掌握了编程的两个基本构建模块；从现在开始，你所做的几乎都是这两个概念的延伸或应用。
- en: In the next chapter, we'll take a look at a special subset of C# types called
    collections, which can store groups of related data, and learn how to write decision-based
    code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下C#类型的一个特殊子集，称为集合，它可以存储相关数据组，并学习如何编写基于决策的代码。
- en: Pop quiz – variables and methods
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验-变量和方法
- en: What is the proper way to write a variable name in C#?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中正确书写变量名的方法是什么？
- en: How do you make a variable appear in Unity's Inspector window?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使一个变量出现在Unity的检视器窗口中？
- en: What are the four access modifiers available in C#?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中有哪四种访问修饰符？
- en: When are explicit conversions needed between types?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型之间何时需要显式转换？
- en: What are the minimum requirements for defining a method?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义方法的最低要求是什么？
- en: What is the purpose of the parentheses at the end of the method name?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法名后面的括号的目的是什么？
- en: What does a return type of `void` mean in a method definition?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法定义中`void`的返回类型意味着什么？
- en: How often is the `Update()` method called by Unity?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity中`Update()`方法被调用的频率是多少？
- en: JOIN us on Discord!
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户一起阅读本书，与Unity/C#专家和Harrison Ferrone一起阅读。提问，为其他读者提供解决方案，通过*Ask Me Anything
    sessions*与作者交流等等。
- en: Join Now!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
