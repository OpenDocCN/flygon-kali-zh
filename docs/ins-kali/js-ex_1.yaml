- en: Building a ToDo List
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建待办事项清单
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are going to be building some really interesting applications with JavaScript
    in this book. JavaScript has evolved from being a simple scripting language that
    is used for form validation in browsers to a powerful programming language that
    is used practically everywhere. Check out these use cases:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用JavaScript构建一些非常有趣的应用程序。JavaScript已经从在浏览器中用于表单验证的简单脚本语言发展为一种强大的编程语言，几乎在任何地方都有应用。请查看以下用例：
- en: Want to set up a server to handle millions of requests with a lot of I/O operations?
    You have Node.js with its single threaded non-blocking I/O model that can handle
    the heavy load with ease. Write JavaScript on the server with Node.js frameworks,
    such as **Express** or **Sails**.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要设置一个服务器来处理数百万请求和大量I/O操作？您可以使用Node.js的单线程非阻塞I/O模型轻松处理重负载。使用Node.js框架（如**Express**或**Sails**）在服务器上编写JavaScript。
- en: Want to build a large scale web application? This is an exciting time to be
    a frontend developer, since lots of new JavaScript frameworks, such as **React**,
    **Angular 2**, **Vue.js**, and so on, are available to speed up your development
    process and build large scale applications easily.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要构建大规模的Web应用程序？现在是成为前端开发人员的激动人心的时刻，因为有很多新的JavaScript框架，如**React**、**Angular
    2**、**Vue.js**等，可用于加快开发流程并轻松构建大规模应用程序。
- en: Want to build a mobile app? Pick up **React Native** or **NativeScript** and
    you can build truly native mobile applications that work across both iOS and Android
    with a single codebase written in JavaScript. Not enough? Use **PhoneGap** or
    **Ionic** to simply create a mobile application with HTML, CSS, and JavaScript.
    Just like a web app!
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要构建移动应用程序？选择**React Native**或**NativeScript**，您可以使用JavaScript编写的单个代码库构建跨iOS和Android的真正本地移动应用程序。还不够？使用**PhoneGap**或**Ionic**简单地使用HTML、CSS和JavaScript创建移动应用程序。就像Web应用程序一样！
- en: Want to build a desktop app? Use **Electron** to build a cross-platform native
    desktop application using HTML, CSS, and of course, JavaScript.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要构建桌面应用程序？使用**Electron**使用HTML、CSS和JavaScript构建跨平台本地桌面应用程序。
- en: JavaScript is also playing an important role in building **Virtual Reality**
    (**VR**) and **Augmented Reality** (**AR**) applications. Check out **React VR**,
    **A-Frame** for building WebVR experiences and **Argon.js**, **AR.js** for adding
    AR to your web applications.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript在构建**虚拟现实**（**VR**）和**增强现实**（**AR**）应用程序中也扮演着重要角色。查看**React VR**、**A-Frame**用于构建WebVR体验以及**Argon.js**、**AR.js**用于向Web应用程序添加AR。
- en: JavaScript is also evolving rapidly. With the introduction of **ECMAScript 2015 **(**ES6**),
    a lot of new additions came into the language that simplify a lot of work for
    developers, providing them with features that were previously only possible using
    TypeScript and CoffeeScript. Even more, features are being added to JavaScript
    in its new specifications (ES7 and beyond). This is an exciting time to be a JavaScript
    developer and this book aims at building a solid foundation so that you can adapt
    to any of the earlier mentioned JavaScript platforms/frameworks in the future.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript也在迅速发展。随着**ECMAScript 2015**（**ES6**）的引入，语言中引入了许多新的功能，简化了开发人员的许多工作，为他们提供了以前只能使用TypeScript和CoffeeScript实现的功能。甚至在JavaScript的新规范（ES7及更高版本）中还添加了更多功能。现在是成为JavaScript开发人员的激动人心的时刻，本书旨在建立坚实的基础，以便您将来可以适应前面提到的任何JavaScript平台/框架。
- en: 'This chapter is targeted at readers who know the basic concepts of HTML, CSS,
    and JavaScript, but are yet to learn new topics, such as ES6, Node, and so on.
    In this chapter, the following topics will be covered:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面向那些了解HTML、CSS和JavaScript基本概念，但尚未学习新主题（如ES6、Node等）的读者。本章将涵盖以下主题：
- en: '**Document Object Model** (**DOM**) manipulation and event listeners'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）操作和事件监听器'
- en: Introduction to and the practical usage of the ES6 implementation of JavaScript
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍ES6 JavaScript的实际用法
- en: Using Node and npm for frontend development
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node和npm进行前端开发
- en: Using Babel to transpile ES6 to ES5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel将ES6转译为ES5
- en: Setting up an automated development server with npm scripts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm脚本设置自动化开发服务器
- en: If you feel you are comfortable with these topics, you can jump over to the
    next chapter, where we will be dealing with some advanced tools and concepts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得对这些主题感到舒适，可以跳到下一章，我们将在那里处理一些高级工具和概念。
- en: System requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统要求
- en: JavaScript is the language of the web. So, you can build web applications from
    any system with a web browser and a text editor. But we do need some tools for
    building modern complex web applications. For better development experience, it's
    recommended to use a Linux or Windows machine with minimum 4 GB RAM or a Mac machine.
    Before we start, you might want to set up some of the following applications in
    your system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是网络的语言。因此，您可以使用带有网络浏览器和文本编辑器的任何系统构建Web应用程序。但是，我们确实需要一些工具来构建现代复杂的Web应用程序。为了获得更好的开发体验，建议使用具有至少4GB
    RAM的Linux或Windows机器或Mac机器。在开始之前，您可能希望在系统中设置以下一些应用程序。
- en: Text editor
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: 'First of all, you need a JavaScript-friendly text editor. Text editors are
    important when it comes to writing code. Depending on the features they provide,
    you can save hours of development time. There are some really good text editors
    out there with excellent languages support. We are going to be using JavaScript
    in this book, so I''d recommend getting one of these open source JavaScript-friendly
    text editors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个友好的JavaScript文本编辑器。文本编辑器在编写代码时非常重要。根据它们提供的功能，您可以节省大量的开发时间。有一些非常好的文本编辑器支持多种语言。在本书中，我们将使用JavaScript，因此我建议获取其中一个开源的JavaScript友好的文本编辑器：
- en: 'Atom: [http://atom.io](http://atom.io)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom：[http://atom.io](http://atom.io)
- en: Visual Studio Code: [http://code.visualstudio.com](https://code.visualstudio.com/)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code：[http://code.visualstudio.com](https://code.visualstudio.com/)
- en: Brackets: [http://brackets.io/](http://brackets.io/)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brackets：[http://brackets.io/](http://brackets.io/)
- en: 'You can also try Sublime Text: [https://www.sublimetext.com/](https://www.sublimetext.com/),
    which is a great text editor, but unlike the previously mentioned ones, Sublime
    Text is commercial and you need to pay for continued usage. There is also another
    commercial product WebStorm: [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/),
    which is a full-fledged **Integrated Development Environment** (**IDE**) for JavaScript.
    It comes with various tools for debugging and integration with JavaScript frameworks.
    You might want to give it a try sometime.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试Sublime Text：[https://www.sublimetext.com/](https://www.sublimetext.com/)，这是一个很棒的文本编辑器，但与前面提到的不同，Sublime
    Text是商业软件，您需要付费才能继续使用。还有另一个商业产品WebStorm：[https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)，它是一个专门为JavaScript打造的全功能**集成开发环境**（**IDE**）。它配备了各种用于调试和与JavaScript框架集成的工具。您可能想试试看。
- en: I would recommend using **Visual Studio Code** (**VSCode**) for the projects
    in this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在本书的项目中使用**Visual Studio Code**（**VSCode**）。
- en: Node.js
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: Here's another important tool that we will be using throughout this book, Node.js.
    Node.js is a JavaScript runtime built on Chrome's V8 engine. It lets you run JavaScript
    outside your browser. Node.js has become really popular because it lets you run
    JavaScript on the server and is really fast thanks to its non-blocking I/O methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中我们将一直使用的另一个重要工具，Node.js。Node.js是建立在Chrome的V8引擎上的JavaScript运行时。它让您可以在浏览器之外运行JavaScript。Node.js变得非常流行，因为它让您可以在服务器上运行JavaScript，并且由于其非阻塞I/O方法，它非常快速。
- en: One other excellent advantage of Node.js is that it helps create command-line
    tools, which can be used for various purposes, such as automation, code scaffolding,
    and more, many of which we will be using in this book. At the time of writing
    this book, the latest **Long Term Support** (**LTS**) version of Node.js is 6.10.2\.
    I'll be using this version throughout this book. You can install the latest LTS version
    available at the time you are reading this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的另一个优点是它有助于创建命令行工具，可用于各种用途，如自动化、代码脚手架等，本书中我们将使用其中许多。在撰写本书时，Node.js的最新**长期支持**（**LTS**）版本是6.10.2。我将在本书中一直使用这个版本。您可以在阅读本书时安装最新的LTS版本。
- en: For Windows users
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Windows用户
- en: Installation on Windows is straightforward; just download and install the latest
    LTS version available at: [https://nodejs.org/en/](https://nodejs.org/en/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装非常简单；只需下载并安装最新的LTS版本：[https://nodejs.org/en/](https://nodejs.org/en/)。
- en: For Linux users
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Linux用户
- en: The easiest way is to install the latest LTS version through your package manager
    by following the instructions provided at [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是通过遵循提供的说明，通过软件包管理器安装最新的LTS版本：[https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)。
- en: For Mac users
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Mac用户
- en: 'Install Node.js using Homebrew:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Homebrew安装Node.js：
- en: Install Homebrew from: [https://brew.sh/](https://brew.sh/)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从以下网址安装Homebrew：[https://brew.sh/](https://brew.sh/)
- en: Run the following command in terminal: `brew install node`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：`brew install node`
- en: Once you have installed Node.js, run `node -v` in your Terminal (command prompt
    for Windows users) to check whether it is properly installed. This should print
    the current version of the node you have installed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Node.js之后，在终端（Windows用户的命令提示符）中运行`node -v`，以检查是否已正确安装。这应该会打印出您已安装的当前版本。
- en: Google Chrome
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌浏览器
- en: Finally, install the latest version of Google Chrome: [https://www.google.com/chrome/](https://www.google.com/chrome/)
    in your system. You can use Firefox or other browsers, but I will be using Chrome,
    so it will be easier for you to follow if you use Chrome.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您的系统中安装最新版本的谷歌浏览器：[https://www.google.com/chrome/](https://www.google.com/chrome/)。您可以使用Firefox或其他浏览器，但我将使用Chrome，所以如果您使用Chrome，跟随起来会更容易。
- en: Now that we have all the necessary tools installed in our system, let's get
    started with building our first application!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的系统中已经安装了所有必要的工具，让我们开始构建我们的第一个应用程序！
- en: ToDo List app
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项应用
- en: 'Let''s take a look at the application we are about to build:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们即将构建的应用程序：
- en: '![](../images/00005.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: We are going to build this simple ToDo List app, which allows us to create a
    list of tasks, mark them as completed, and delete tasks from the list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建这个简单的待办事项应用，它允许我们创建任务列表，标记已完成的任务，并从列表中删除任务。
- en: 'Let''s get started by using the starter code of Chapter 1 in the book''s code
    files. The starter code will contain three files: `index.html`, `scripts.js`,
    and `styles.css`. Open the `index.html` file in a web browser to see the basic
    design of the ToDo List app, as shown in the preceding screenshot.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本书的代码文件中使用第1章的起始代码开始。起始代码将包含三个文件：`index.html`、`scripts.js`和`styles.css`。在Web浏览器中打开`index.html`文件，以查看待办事项应用的基本设计，如前面的屏幕截图所示。
- en: 'The JavaScript file will be empty, in which we are going to write scripts to
    create the application. Let''s take a look at the HTML file. In the `<head>` section,
    a reference to the `styles.css` file and BootstrapCDN are included, and at the
    end of the `<body>` tag, jQuery and Bootstrap''s JS files are included along with
    our `scripts.js` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript文件将是空的，我们将在其中编写脚本来创建应用程序。让我们来看看HTML文件。在`<head>`部分中，包含了对`styles.css`文件和BootstrapCDN的引用，在`<body>`标签的末尾，包括了jQuery和Bootstrap的JS文件以及我们的`scripts.js`文件：
- en: Bootstrap is a UI development framework that helps us to build responsive HTML
    designs faster. Bootstrap comes with set of JavaScript codes that requires jQuery
    to run.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap是一个UI开发框架，可以帮助我们更快地构建响应式HTML设计。Bootstrap带有一组需要jQuery运行的JavaScript代码。
- en: jQuery is a JavaScript library that simplifies JavaScript functions for DOM
    traversal, DOM manipulation, event handling, and so on.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery是一个简化DOM遍历、DOM操作、事件处理等JavaScript函数的JavaScript库。
- en: 'Bootstrap and jQuery are widely used together for building web applications.
    In this book, we will be focusing more on using JavaScript. Hence, both of them
    will not be covered in detail. However, you can take a look at w3school''s website
    for learning Bootstrap: [https://www.w3schools.com/bootstrap/default.asp](https://www.w3schools.com/bootstrap/default.asp)
    and jQuery: [https://www.w3schools.com/jquery/default.asp](https://www.w3schools.com/jquery/default.asp)
    in detail.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap和jQuery通常一起用于构建Web应用程序。在本书中，我们将更多地专注于使用JavaScript。因此，它们两者都不会被详细介绍。但是，你可以在w3school的网站上详细学习Bootstrap：[https://www.w3schools.com/bootstrap/default.asp](https://www.w3schools.com/bootstrap/default.asp)
    和jQuery：[https://www.w3schools.com/jquery/default.asp](https://www.w3schools.com/jquery/default.asp)。
- en: 'In our HTML file, the styles in the CSS file included last will overwrite the
    styles in the previous file. Hence, it''s a good practice to include our own CSS
    files after the default framework''s CSS files (Bootstrap in our case) if we plan
    to rewrite any of the framework''s default CSS properties. We don''t have to worry
    about CSS in this chapter, since we are not going to edit default styles of Bootstrap
    in this chapter. We only need to concentrate on our JS files. JavaScript files
    must be included in the given order as in the starter code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML文件中，最后包含的CSS文件中的样式将覆盖之前文件中的样式。因此，如果我们打算重写框架的默认CSS属性，最好的做法是在默认框架的CSS文件（在我们的情况下是Bootstrap）之后包含我们自己的CSS文件。在本章中我们不需要担心CSS，因为我们不打算编辑Bootstrap的默认样式。我们只需要专注于我们的JS文件。JavaScript文件必须按照起始代码中给定的顺序包含：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are including the jQuery code first after which Bootstrap JS files are included.
    This is because Bootstrap''s JS files require jQuery to run. If we include Bootstrap
    JS first, it will print an error in the console, saying Bootstrap requires jQuery
    to run. Try moving the Bootstrap code above the jQuery code and open up your browser''s
    console. For Google Chrome, it''s *Ctrl*+*Shift*+*J* on Windows or Linux and *command*+*option*+*J*
    on Mac. You will receive an error similar to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含jQuery代码，然后包含Bootstrap JS文件。这是因为Bootstrap的JS文件需要jQuery来运行。如果我们先包含Bootstrap
    JS，它将在控制台中打印一个错误，说Bootstrap需要jQuery来运行。尝试将Bootstrap代码移动到jQuery代码上方，并打开浏览器的控制台。对于谷歌浏览器，在Windows或Linux上是*Ctrl*+*Shift*+*J*，在Mac上是*command*+*option*+*J*。你将收到类似于这样的错误：
- en: '![](../images/00006.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: Hence, we are currently managing dependencies by including the JS files in the
    right order. However, in larger projects, this could be really difficult. We'll
    look at a better way to manage our JS files in the next chapter. For now, let's
    continue on to build our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们目前通过按正确的顺序包含JS文件来管理依赖关系。然而，在更大的项目中，这可能会非常困难。在下一章中，我们将看一种更好的方式来管理我们的JS文件。现在，让我们继续构建我们的应用程序。
- en: 'The body of our HTML file is divided into two sections:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML文件的body部分分为两个部分：
- en: Navigation bar
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏
- en: Container
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: We usually use the navigation bar to add links to the different sections of
    our web app. Since we are only dealing with a single page in this app, we will
    only include the page title in the navigation bar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用导航栏来为我们的Web应用程序的不同部分添加链接。由于在这个应用程序中我们只处理单个页面，所以我们只会在导航栏中包含页面标题。
- en: I have included many classes to the HTML elements, such as `navbar`, `navbar-inverse`,
    `navbar-fixed-top`, `container`, `col-md-2`, `col-xs-2`, and so on. They are used
    for styling the elements using Bootstrap. We'll discuss them in later chapters.
    For now, let's focus only on the functionality part.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在HTML元素中包含了许多类，比如`navbar`、`navbar-inverse`、`navbar-fixed-top`、`container`、`col-md-2`、`col-xs-2`等等。它们用于使用Bootstrap对元素进行样式设置。我们将在后面的章节中讨论它们。现在，让我们只专注于功能部分。
- en: Chrome DevTools
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chrome DevTools
- en: In the body section, we have an input field with a button to add a new task
    and an unordered list to list out the tasks. The unordered list will have a checkbox
    to mark the task as completed and a delete icon to remove the task from the list.
    You might notice that the first item in the list is marked completed using a strike-through
    line. If you inspect the element using Chrome DevTools, you will notice that it
    has an additional class `complete`, which adds a strike-through line on the text
    using CSS, which is defined in our `styles.css` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在body部分，我们有一个输入字段和一个按钮来添加新任务，以及一个无序列表来列出任务。无序列表将有一个复选框来标记任务已完成，以及一个删除图标来从列表中删除任务。你可能会注意到列表中的第一项使用删除线标记为已完成。如果你使用Chrome
    DevTools检查元素，你会注意到它有一个额外的类`complete`，它使用CSS在文本上添加了删除线，这在我们的`styles.css`文件中定义。
- en: 'To inspect an element using Chrome DevTools, right-click over that element
    and select inspect. You can also click *Ctrl*+*Shift*+*C* on Windows or Linux,
    or *command*+*shift*+*C* on Mac, and then, hover the cursor over the element to
    see its details. You can also directly edit the element''s HTML or CSS to see
    the changes reflected on the page. Delete the complete class from the `div` of
    the first item in the list. You''ll see that the strike-through line has gone.
    The changes made directly in the DevTools are temporary and will be cleaned when
    the page is refreshed. Take a look at the following image for a list of tools
    available to inspect an element in Chrome:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome DevTools检查元素，右键单击该元素并选择检查。你也可以在Windows或Linux上点击*Ctrl*+*Shift*+*C*，或者在Mac上点击*command*+*shift*+*C*，然后将鼠标悬停在元素上以查看其详细信息。你也可以直接编辑元素的HTML或CSS以查看页面上的变化。从列表中的第一项的`div`中删除`complete`类。你会发现删除线已经消失了。在DevTools中直接进行的更改是临时的，在刷新页面时会被清除。查看以下图片，了解在Chrome中检查元素的工具列表：
- en: '![](../images/00007.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: '**A**: Inspect element from right-click'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：右键单击检查元素'
- en: '**B**: Click the cursor icon and select a different element by hovering the
    cursor over the element'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**：点击光标图标，通过将鼠标悬停在元素上选择不同的元素'
- en: '**C**: Directly edit the HTML of the page'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：直接编辑页面的HTML'
- en: '**D**: Directly edit the CSS associated with an element'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：直接编辑与元素相关的CSS'
- en: One other nice feature of Chrome DevTools is that you can write `debugger` anywhere
    in your JavaScript code and Google Chrome will pause the execution of the script
    at the point in which `debugger` was called. Once the execution is paused, you
    can hover your cursor over the source code in sources tab and it will show the
    value contained in the variable in a popup. You can also type in the variable's
    name in the console tab to see its value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome DevTools的另一个不错的功能是，你可以在你的JavaScript代码中的任何地方写入`debugger`，Google Chrome会在调用`debugger`的地方暂停脚本的执行。一旦执行暂停，你可以将光标悬停在源代码中的变量上，它会显示弹出窗口中包含的变量的值。你也可以在控制台选项卡中输入变量的名称来查看其值。
- en: 'This is the screenshot of Google Chrome debugger in action:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Google Chrome调试器的截图：
- en: '![](../images/00008.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: Feel free to explore the different sections of the Chrome Developer Tools to
    understand more about the tools it provides for the developers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索Chrome开发者工具的不同部分，以更多地了解它为开发人员提供的工具。
- en: Getting started with ES6
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用ES6
- en: Now that you have a good idea about the developer tools, let's start the coding
    part. You should already be familiar with the JavaScript ES5 syntax. So, let's
    explore JavaScript with the ES6 syntax in this chapter. ES6 (ECMAScript 2015)
    is the sixth major release of ECMAScript language specification. JavaScript is
    an implementation of ECMAScript language specification.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对开发者工具有了一个很好的了解，让我们开始编码部分。你应该已经熟悉了JavaScript ES5语法。因此，在本章中，让我们探索JavaScript的ES6语法。ES6（ECMAScript
    2015）是ECMAScript语言规范的第六个主要版本。JavaScript是ECMAScript语言规范的一种实现。
- en: At the time of writing this book, ES8 is the latest release of JavaScript language.
    However, for simplicity and ease of understanding, this book only focuses on ES6\.
    You can always learn about the latest features introduced in ES7 and beyond on
    the Internet easily once you grasp the knowledge of ES6.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，ES8是JavaScript语言的最新版本。然而，为了简单和易于理解，本书仅关注ES6。一旦掌握了ES6的知识，你可以轻松地在互联网上了解ES7及更高版本引入的最新功能。
- en: At the time of writing this book, all the modern browsers support most of the
    ES6 features. However, older browsers don't know about the new JavaScript syntax
    and, hence, they will throw errors. To resolve such backward compatibility issues,
    we will have to transpile our ES6 code to ES5 before deploying the app. Let's
    look into that at the end of the chapter. The latest version of Chrome supports
    ES6; so, for now, we'll directly create our ToDo List with the ES6 syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，所有现代浏览器都支持大部分ES6功能。然而，旧版浏览器不了解新的JavaScript语法，因此它们会抛出错误。为了解决这种向后兼容性问题，我们需要在部署应用程序之前将ES6代码转译为ES5。让我们在本章末尾详细了解这一点。最新版本的Chrome支持ES6；因此，现在我们将直接使用ES6语法创建我们的ToDo
    List。
- en: 'I''ll explain in detail about the new ES6 syntax. If you find difficulties
    understanding normal JavaScript syntax and data types, do refer to the respective
    section in the following w3schools page: [https://www.w3schools.com/js/default.asp.](https://www.w3schools.com/js/default.asp)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细解释新的ES6语法。如果你在理解普通JavaScript语法和数据类型方面遇到困难，请参考以下w3schools页面中的相应部分：[https://www.w3schools.com/js/default.asp.](https://www.w3schools.com/js/default.asp)
- en: 'Open up the `scripts.js` file in your text editor. First of all, we will create
    a class that contains the methods of our ToDo List app, and yeah! Classes are
    a new addition to JavaScript in ES6\. It''s simple to create objects using classes
    in JavaScript. It lets us organize our code as modules. Create a class named `ToDoClass`
    with the following code in the scripts file and refresh the browser:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`scripts.js`文件。首先，我们将创建一个包含我们的ToDo List应用程序方法的类，是的！在ES6中，类是JavaScript的一个新添加。使用类在JavaScript中创建对象很简单。它让我们将代码组织为模块。在脚本文件中创建一个名为`ToDoClass`的类，并刷新浏览器：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your browser will now throw an alert saying "Hello World!". So here''s what
    the code is doing. First, `window.addEventListener` will attach an event listener
    to the window and wait for the window to finish loading all the needed resources.
    Once it is loaded, the `load` event is fired, which calls the callback function
    of our event listener that initializes `ToDoClass` and assigns it to a variable
    `toDo`. While `ToDoClass` is initialized, it automatically calls the constructor,
    which creates an alert saying "Hello World!". We can further modify our code to
    take advantage of ES6\. In the `window.addEventListener` part, you can rewrite
    it as:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器现在会弹出一个警报，显示“Hello World!”。这是代码的作用。首先，`window.addEventListener`将在窗口上附加一个事件监听器，并等待窗口完成加载所有所需的资源。一旦加载完成，将触发`load`事件，调用我们事件监听器的回调函数，初始化`ToDoClass`并将其赋值给变量`toDo`。在初始化`ToDoClass`时，它会自动调用构造函数，创建一个显示“Hello
    World!”的警报。我们可以进一步修改我们的代码以利用ES6。在`window.addEventListener`部分，你可以将其重写为：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we replace the anonymous callback function `function () {}` with the
    new arrow function `() => {}`. Second, we define the variable with `let` instead
    of `var`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们用新的箭头函数`() => {}`替换匿名回调函数`function () {}`。其次，我们用`let`而不是`var`定义变量。
- en: Arrow functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are a cleaner and shorter way to define functions in JavaScript and
    they simply inherit the `this` object of its parent instead of binding its own.
    We''ll see more about the `this` binding soon. Let''s just look into using the
    new syntax. Consider the following functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是在JavaScript中定义函数的更清晰和更简洁的方式，它们简单地继承其父级的`this`对象，而不是绑定自己的。我们很快会看到更多关于`this`绑定的内容。让我们先看看使用新语法。考虑以下函数：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The equivalent arrow functions can be written as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的箭头函数可以写成：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that `()` are optional, when we have to pass the only single argument
    to the function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当我们必须将唯一的单个参数传递给函数时，`()`是可选的。
- en: 'Sometimes, we just return a value in a single line in our functions, such as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在函数中只需在一行中返回一个值，例如：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to directly return a value in our arrow function in a single line,
    we can directly ignore the `return` keyword and `{}` curly braces and write it
    as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在箭头函数中直接在一行中返回一个值，我们可以直接忽略`return`关键字和`{}`花括号，并将其写为：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's it! It will automatically return the sum of `x` and `y`. However, this
    can be used only when you want to return the value immediately in a single line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！它将自动返回`x`和`y`的和。但是，这只能在您想要立即在一行中返回值时使用。
- en: let, var, and const
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let、var和const
- en: 'Next, we have the `let` keyword. ES6 has two new keywords for declaring variables,
    `let` and `const`. `let` and `var` differ by the scope of the variables declared
    using them. The scope of variables declared using `var` is within the function
    it is defined and global if it is not defined inside any function, while the scope
    of `let` is restricted to within the enclosing block it was declared in and global
    if it is not defined inside any enclosing block. Look at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`let`关键字。ES6有两个用于声明变量的新关键字，`let`和`const`。使用它们声明的变量的作用域有所不同。使用`var`声明的变量的作用域在定义它的函数内部，并且如果没有在任何函数内部定义，则为全局，而`let`的作用域仅限于声明它的封闭块内，并且如果没有在任何封闭块内定义，则为全局。看看以下代码：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to accidentally re-declare `toDo` somewhere along the code, as
    follows, your class object gets overwritten:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在代码中的其他地方意外重新声明`toDo`，如下所示，您的类对象将被覆盖：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This behavior is confusing and quite difficult to maintain variables for large
    applications. Hence, `let` was introduced in ES6\. It restricts the scope of variables
    only within the enclosing in which it was declared. In ES6, it is encouraged to
    use `let` instead of `var` for declaring variables. Look at the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于大型应用程序来说很令人困惑，也很难维护变量。因此，在ES6中引入了`let`。它只限制了变量的作用域在声明它的封闭块内。在ES6中，鼓励使用`let`而不是`var`来声明变量。看看以下代码：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, even if you accidentally re-declare `toDo` somewhere else in the code,
    JavaScript will throw an error, saving you from a runtime exception. An enclosing
    block is a block of code between two curly braces `{}` and the curly braces may
    or may not belong to a function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使您在代码的其他地方意外重新声明`toDo`，JavaScript也会抛出错误，使您免受运行时异常。封闭块是两个花括号`{}`之间的代码块，花括号可能属于函数，也可能不属于函数。
- en: We need a `toDo` variable to be accessible throughout the application. So, we
    declare `toDo` above the event listener and assign it to the class object inside
    the callback function. This way, the `toDo` variable will be accessible throughout
    the page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`toDo`变量在整个应用程序中都可以访问。因此，我们在事件侦听器上方声明`toDo`，并在回调函数内将其分配给类对象。这样，`toDo`变量将在整个页面中都可以访问。
- en: '`let` is very useful for defining variables in `for` loops. You can create
    a `for` loop such that `for(let i=0; i<3; i++) {}` and the scope of the variable
    `i` will only be within the `for` loop. You can easily use the same variable name
    in other places of your code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`非常有用于定义`for`循环中的变量。您可以创建一个`for`循环，例如`for(let i=0; i<3; i++) {}`，并且变量`i`的作用域将仅在`for`循环内。您可以轻松地在代码的其他地方使用相同的变量名。'
- en: 'Let''s take a look at the other keyword `const`. The working of `const` is
    the same as that of `let`, except that variables declared using `const` cannot
    be changed (reassigned). Hence, `const` is used for constants. However, an entire
    constant cannot be reassigned but their properties can be changed. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一个关键字`const`。`const`的工作方式与`let`相同，只是使用`const`声明的变量不能更改（重新分配）。因此，`const`用于常量。但是，整个常量不能被重新分配，但它们的属性可以被更改。例如：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While writing code in ES6, always use `const` to declare your variables. Use
    `let` only when you need to perform any changes (reassignments) to the variable
    and completely avoid using `var`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中编写代码时，始终使用`const`来声明变量。只有在需要对变量进行任何更改（重新分配）时才使用`let`，完全避免使用`var`。
- en: The `toDo` object contains the class variables and functions as properties and
    methods of the object. If you need a clear picture of how the object is structured
    in JavaScript, see: [https://www.w3schools.com/js/js_objects.asp](https://www.w3schools.com/js/js_objects.asp).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`toDo`对象包含类变量和函数作为对象的属性和方法。如果您需要了解JavaScript中对象的结构，请参阅：[https://www.w3schools.com/js/js_objects.asp](https://www.w3schools.com/js/js_objects.asp)。'
- en: Loading the tasks from data
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据加载任务
- en: 'The first thing we want to do in our application is to load the tasks dynamically
    from a set of data. Let''s declare a class variable that contains the data for
    tasks along with methods needed to pre-populate the tasks. ES6 does not provide
    a direct way to declare class variables. We need to declare variables using the
    constructor. We also need a function to load tasks into the HTML elements. So,
    we''ll create a `loadTasks()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中要做的第一件事是从一组数据动态加载任务。让我们声明一个包含任务数据以及预填充任务所需方法的类变量。ES6没有直接提供声明类变量的方法。我们需要使用构造函数声明变量。我们还需要一个函数将任务加载到HTML元素中。因此，我们将创建一个`loadTasks()`方法：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The tasks variable is declared inside the constructor as `this.tasks`, which
    means the tasks variable belongs to `this` (`ToDoClass`). The variable is an array
    of objects that contain the task details and its completion status. The second
    task is set to be completed. Now, we need to generate an HTML code for the data.
    We''ll reuse the code of the `<li>` element from the HTML to generate a task dynamically:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasks`变量在构造函数内部声明为`this.tasks`，这意味着tasks变量属于`this`（`ToDoClass`）。该变量是一个包含任务详情和完成状态的对象数组。第二个任务被设置为已完成。现在，我们需要为数据生成HTML代码。我们将重用HTML中`<li>`元素的代码来动态生成任务：'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In JavaScript, an instance of a class is called the class object or simply object.
    The class objects are structured similarly to JSON objects in key-value pairs.
    The functions associated with a class object are called its methods and the variables/values
    associated with a class object are called its properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，类的实例被称为类对象或简单对象。类对象的结构类似于JSON对象中的键值对。与类对象关联的函数称为其方法，与类对象关联的变量/值称为其属性。
- en: Template literals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板文字
- en: 'Traditionally, in JavaScript, we concatenate strings using the `+` operator.
    However, if we want to concatenate multi-line strings, then we have to use the
    escape code `\` to escape new lines, such as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在JavaScript中，我们使用`+`运算符来连接字符串。然而，如果我们想要连接多行字符串，那么我们必须使用转义码`\`来转义换行，例如：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can be very confusing when we have to write a string that contains a large
    amount of HTML. In this case, we can use ES6 template strings. Template strings
    are strings surrounded by backticks `` `` instead of single quotation marks `''
    ''`. By using this, we can create multi-line strings in an easier way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须编写包含大量HTML的字符串时，这可能会非常令人困惑。在这种情况下，我们可以使用ES6模板字符串。模板字符串是用反引号`` ``而不是单引号`'
    '`括起来的字符串。通过使用这种方式，我们可以更轻松地创建多行字符串：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we can create DOM elements in a similar way; we type them in
    HTML without worrying about spaces or multi-lines. Because whatever formatting,
    such as tabs or new lines, present inside the template strings is directly recorded
    in the variable. And we can declare variables inside the strings using `${}`.
    So, in our case, we need to generate a list of items for each task. First, we
    will create a function to loop through the array and generate the HTML. In our
    `loadTasks()` method, write the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以以类似的方式创建DOM元素；我们在HTML中输入它们，而不用担心空格或多行。因为模板字符串中存在的任何格式，例如制表符或换行符，都直接记录在变量中。我们可以使用`${}`在字符串中声明变量。因此，在我们的情况下，我们需要为每个任务生成一个项目列表。首先，我们将创建一个函数来循环遍历数组并生成HTML。在我们的`loadTasks()`方法中，编写以下代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, create a `generateTaskHtml()` function inside `ToDoClass`, with
    the code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`ToDoClass`内部创建一个`generateTaskHtml()`函数，代码如下：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, refresh the page, and wow! Our application is loaded with tasks from our
    `tasks` variable. That should look like a lot of code at first, but let's look
    into it line by line.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新页面，哇！我们的应用程序已经加载了来自`tasks`变量的任务。一开始可能看起来像是很多代码，但让我们逐行来看。
- en: In case the changes aren't reflected when you refresh the page, it's because
    Chrome has cached the JavaScript files and is not retrieving the latest one. To
    make it retrieve the latest code, you will have to do a hard reload by pressing
    *Ctrl*+*Shift*+*R* on Windows or Linux and *command*+*Shift*+*R* on Mac.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新页面时更改没有反映出来，那是因为Chrome已经缓存了JavaScript文件，并且没有检索到最新的文件。要使其检索最新的代码，您需要通过在Windows或Linux上按下*Ctrl*+*Shift*+*R*，或在Mac上按下*command*+*Shift*+*R*来进行强制重新加载。
- en: 'In the `loadTasks()` function, we declare a variable `tasksHtml` with a value
    that is returned by the callback function of the array `reduce()` method of the
    `tasks` variable. Each array object in JavaScript has some methods associated
    with it. `reduce` is one such method of JS array that applies a function to each
    element of the array from left to right and applies the values to an accumulator
    so that the array gets reduced to a single value and then it returns that final
    value. The `reduce` method accepts two parameters; first is the callback function,
    which is applied to each element of the array, and the second one is the initial
    value of the accumulator. Let''s look at our function in normal ES5 syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadTasks()`函数中，我们声明一个名为`tasksHtml`的变量，其值是由`tasks`变量的数组`reduce()`方法的回调函数返回的。JavaScript中的每个数组对象都有一些与之关联的方法。`reduce`是JS数组的一种方法，它将一个函数应用于数组的每个元素，从左到右应用值到累加器，以便将数组减少为单个值，然后返回该最终值。`reduce`方法接受两个参数；第一个是应用于数组每个元素的回调函数，第二个是累加器的初始值。让我们看看我们的函数在普通的ES5语法中是什么样子的：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter is the callback function, whose four parameters are `html`,
    which is our accumulator, `task`, which is an element from the tasks array, index,
    which gives the current index of the array element in the iteration, and `tasks`,
    which contains the entire array on which the reduce method is applied on (we don't
    need the entire array inside the callback function for our use case, so the fourth
    parameter is ignored in our code).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是回调函数，它的四个参数是`html`，这是我们的累加器，`task`，这是任务数组中的一个元素，索引，它给出了迭代中数组元素的当前索引，以及`tasks`，它包含了reduce方法应用的整个数组（对于我们的用例，我们不需要在回调函数中使用整个数组，所以忽略了第四个参数）。
- en: The second parameter is optional, which contains the initial value of the accumulator.
    In our case, the initial HTML string is an empty string `''`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，包含累加器的初始值。在我们的情况下，初始HTML字符串是一个空字符串`''`。
- en: Also, note that we have to `bind` the callback function with `this` (which is
    our class) object so that the methods of `ToDoClass` and the variables are accessible
    within the callback function. This is because, otherwise, every function will
    define its own `this` object and the parent's `this` object will be inaccessible
    within that function.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，请注意我们必须使用`bind`将回调函数与`this`（即我们的类）对象绑定在一起，以便在回调函数中可以访问`ToDoClass`的方法和变量。这是因为，否则，每个函数都将定义自己的`this`对象，并且父级的`this`对象将无法在该函数内部访问。
- en: What the callback function does is it takes the empty `html` string (accumulator)
    first and concatenates it with the value returned by the `generateTaskHtml()`
    method of `ToDoClass`, whose parameters are the first element of the array and
    its index. The returned value, of course, should be a string, otherwise, it will
    throw an error. Then, it repeats the operation for each element of the array with
    an updated value of the accumulator, which is finally returned at the end of the
    iteration. The final reduced value contains the entire HTML code for populating
    our tasks as a string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的作用是首先取空的`html`字符串（累加器），然后将其与`ToDoClass`的`generateTaskHtml()`方法返回的值连接起来，该方法的参数是数组的第一个元素及其索引。返回的值当然应该是一个字符串，否则会抛出错误。然后，它对数组的每个元素重复执行操作，累加器的更新值最终在迭代结束时返回。最终的减少值包含作为字符串填充任务的整个HTML代码。
- en: 'By applying ES6 arrow functions, the entire operation can be achieved in a
    single line as:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用ES6箭头函数，整个操作可以在一行中完成：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Isn't that simple! Since we are just returning the value in a single line, we
    can ignore both the `{}` curly braces and `return` keyword. Also, arrow functions
    do not define their own `this` object; they simply inherit the `this` object of
    their parents. So we can also ignore the `.bind(this)` method. Now, we have made
    our code cleaner and much simpler to understand using arrow functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很简单吗！由于我们只是在一行中返回值，我们可以忽略`{}`大括号和`return`关键字。此外，箭头函数不定义自己的`this`对象；它们只是继承其父级的`this`对象。因此，我们也可以忽略`.bind(this)`方法。现在，我们使用箭头函数使我们的代码更清晰，更容易理解。
- en: 'Before we move on to the next line of the `loadTasks()` method, let''s look
    at the working of the `generateTaskHtml()` method. This function takes two arguments--an
    array element task in the tasks data and its index and returns a string that contains
    the HTML code for populating our tasks. Note that we have included variables in
    the code for the checkbox:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续`loadTasks()`方法的下一行之前，让我们看一下`generateTaskHtml()`方法的工作原理。这个函数接受两个参数--任务数据中的数组元素任务和它的索引，并返回一个包含用于填充任务的HTML代码的字符串。请注意，我们在代码中包含了复选框的变量：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It says that "on change of checkbox's status", call `toggleTaskStatus()` method
    of the `toDo` object with the index of the task that was changed. We haven't defined
    the `toggleTaskStatus()` method yet, so when you click the checkbox on the website
    now, it will throw an error in Chrome's console and nothing special happens in
    the browser window. Also, we have added a conditional operator `()?:` to return
    a checked attribute for the input tag if the task status is complete. This is
    useful to render the list with a prechecked check box if the task is already complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它说“在复选框状态改变时”，调用`toDo`对象的`toggleTaskStatus()`方法，参数是被改变的任务的索引。我们还没有定义`toggleTaskStatus()`方法，所以当您现在在网站上点击复选框时，它会在Chrome的控制台中抛出错误，并且在浏览器窗口中没有任何特殊的情况发生。此外，我们添加了一个条件运算符`()?:`，如果任务状态已完成，则返回输入标签的已选属性。如果任务已经完成，这对于渲染带有预选复选框的列表非常有用。
- en: Similarly, we have included `${task.isComplete?'complete':''}` in the `div`
    that contains the task text so that an additional class gets added to the task
    if the task is complete, and CSS has been written in the `styles.css` file for
    that class to render a strike-through line over the text.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们在包含任务文本的`div`中包含了`${task.isComplete?'complete':''}`，这样如果任务已完成，任务就会添加一个额外的类，而且在`styles.css`文件中为该类编写了CSS，以在文本上渲染删除线。
- en: Finally, in the anchor tag, we have included `onClick="toDo.deleteTask(event,
    ${index})"` to call the `deleteTask()` method of the `toDo` object with parameters--the
    click event itself and the index of the task. We haven't defined the `deleteTask()`
    method yet, so clicking on the delete icon is going to take you to the root of
    your file system!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在锚点标签中，我们包含了`onClick="toDo.deleteTask(event, ${index})"`来调用`toDo`对象的`deleteTask()`方法，参数是点击事件本身和任务的索引。我们还没有定义`deleteTask()`方法，所以点击删除图标会将您带到文件系统的根目录！
- en: '`onclick` and `onchange` are some of HTML attributes that are used to call
    JavaScript functions when the specified event occurs on the parent element on
    which the attributes are defined. Since these attributes belong to HTML, they
    are case insensitive.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`onclick`和`onchange`是一些HTML属性，用于在父元素上发生指定事件时调用JavaScript函数。由于这些属性属于HTML，它们不区分大小写。'
- en: 'Now, let''s look at the second line of the `loadTasks()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`loadTasks()`方法的第二行：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We just replaced the HTML code of the DOM element with the ID `taskList` with
    our newly generated string `tasksHTML`. Now, the ToDo List is populated. Time
    to define the two new methods of the `toDo` object, which we included in our generated
    HTML code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用新生成的字符串`tasksHTML`替换了具有ID`taskList`的DOM元素的HTML代码。现在，待办事项列表已经填充。是时候定义`toDo`对象的两个新方法了，这些方法包含在我们生成的HTML代码中。
- en: Managing task status
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理任务状态
- en: 'Inside `ToDoClass`, include the two new methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ToDoClass`中，包括两个新方法：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first method, `toggleTaskStatus()`, is used to mark a task as completed
    or incomplete. It is called when a checkbox is clicked (`onChange`) with the index
    of the task, which was clicked as the parameter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`toggleTaskStatus()`用于标记任务为已完成或未完成。当复选框被点击（`onChange`）时，会调用该方法，并将被点击的任务的索引作为参数：
- en: Using the task's index, we assign the task's `isComplete` status as the negation
    of its current status not using the `(!)` operator. Hence, the completion status
    of the tasks can be toggled in this function.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务的索引，我们将任务的`isComplete`状态分配为其当前状态的否定，而不使用`(!)`运算符。因此，可以在此函数中切换任务的完成状态。
- en: Once the `tasks` variable is updated with new data, `this.loadTasks()` is called
    to re-render all the tasks with the updated value.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦`tasks`变量使用新数据更新，就会调用`this.loadTasks()`来重新渲染所有任务的更新值。
- en: 'The second method, `deleteTask()`, is used to delete a task from the list.
    Currently, clicking the delete icon will take you to the root of the file system.
    However, before navigating you to the root of the file system, a call to `toDo.deleteTask()` is
    made with the click `event` and task''s `index` as the parameters:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法`deleteTask()`用于从列表中删除任务。当前，单击删除图标将带您转到文件系统的根目录。但是，在将您导航到文件系统的根目录之前，将使用单击`event`和任务的`index`作为参数调用`toDo.deleteTask()`：
- en: The first parameter `event` contains the entire event object that contains various
    properties and methods about the click event that just happened (try `console.log(event)`
    inside the `deleteTask()` function to see all the details in Chrome's console).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数`event`包含关于刚刚发生的点击事件的各种属性和方法的整个事件对象（在`deleteTask()`函数内尝试`console.log(event)`以查看Chrome控制台中包含的所有详细信息）。
- en: To prevent any default action (opening a URL) from happening once, we click
    the delete icon (the `<a>` tag). Initially, we need to specify `event.preventDefault()`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止任何默认操作（打开URL）在单击删除图标（`<a>`标签）后发生，我们需要指定`event.preventDefault()`。
- en: Then, we need to remove the task element of the array that was deleted from
    the `tasks` variable. For that, we use the `splice()` method, which deletes a
    specified number of elements from an array from a specified index. In our case,
    from the index of the task, which needs to be deleted, delete only a single element.
    This removes the task to be deleted from the `tasks` variable.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们需要从`tasks`变量中删除已删除的数组的任务元素。为此，我们使用`splice()`方法，该方法从指定的索引处删除数组中指定数量的元素。在我们的情况下，从需要删除的任务的索引处仅删除一个元素。这将从`tasks`变量中删除要删除的任务。
- en: '`this.loadTasks()` is called to re-render all the tasks with the updated value.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`this.loadTasks()`以重新呈现所有具有更新值的任务。
- en: Refresh the page (*hard reload* if needed) to see how our current application
    works with the new code. You can now mark a task as completed and can delete a
    task from the list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面（*如果需要，进行硬刷新*）以查看我们的当前应用程序如何使用新代码。您现在可以将任务标记为已完成，并且可以从列表中删除任务。
- en: Adding new tasks to the list
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向列表添加新任务
- en: 'We now have the options to toggle a task status and to delete a task. But we
    need to add more tasks to the list. For that, we need to use the text box provided
    in the HTML file to allow users to type in new tasks. The first step will be adding
    the `onclick` attribute to the add task `<button>`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了切换任务状态和删除任务的选项。但是我们需要向列表中添加更多任务。为此，我们需要使用HTML文件中提供的文本框，以允许用户输入新任务。第一步将是向添加任务的`<button>`添加`onclick`属性：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, every button click will call the `addTaskClick()` method of the `toDo`
    object, which is not yet defined. So, let''s define it inside our `ToDoClass`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次单击按钮都将调用`toDo`对象的`addTaskClick()`方法，该对象尚未定义。因此，让我们在`ToDoClass`内定义它：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reload Chrome and try adding a new task by clicking the Add button. If everything's
    fine, you should see a new task get appended to the list. Also, when you click
    the Add button without typing anything in the input field, then it will highlight
    the input field with a red border, indicating the user should input text in the
    input field.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载Chrome并尝试通过单击“添加”按钮添加新任务。如果一切正常，您应该看到新任务被追加到列表中。此外，当您单击“添加”按钮而不在输入字段中键入任何内容时，它将使用红色边框突出显示输入字段，指示用户应在输入字段中输入文本。
- en: See how I have divided our add task operation across two functions? I did a
    similar thing for the `loadTask()` function. In programming, it is a best practice
    to organize all the tasks into smaller, more generic functions, which will allow
    you to reuse those functions in the future.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我是如何将我们的添加任务操作分成两个函数的？我对`loadTask()`函数也做了类似的事情。在编程中，最佳实践是将所有任务组织成更小、更通用的函数，这将允许您在将来重用这些函数。
- en: 'Let''s see how the `addTaskClick()` method works:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`addTaskClick()`方法是如何工作的：
- en: '`addTaskClick()` function doesn''t have any request parameters. First, to read
    the new task''s text, we get the `<input>` element with the ID `addTask`, which
    contains the text needed for the task. using `document.getElementById(''addTask'')`,
    and assign it to `target` variable. Now, the `target` variable contains all the
    properties and methods of the `<input>` element, which can be read and modified
    (try `console.log(target)` to see all the details contained in the variable).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addTaskClick()`函数没有任何请求参数。首先，为了读取新任务的文本，我们获取ID为`addTask`的`<input>`元素，其中包含任务所需的文本。使用`document.getElementById(''addTask'')`，并将其分配给`target`变量。现在，`target`变量包含`<input>`元素的所有属性和方法，可以读取和修改（尝试`console.log(target)`以查看变量中包含的所有详细信息）。'
- en: The `value` property contains the required text. So, we pass `target.value` to the
    `addTask()` function, which handles adding a new task to the list.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`属性包含所需的文本。因此，我们将`target.value`传递给`addTask()`函数，该函数负责将新任务添加到列表中。'
- en: Finally, we reset the input field to an empty state by setting `target.value`
    to an empty string `''`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们通过将`target.value`设置为空字符串`''`来将输入字段重置为空状态。
- en: 'That''s the event handling part for the click event. Let''s see how the task
    gets appended to the list in the `addTask()` method. The `task` variable contains
    the text for the new task:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击事件的事件处理部分。让我们看看任务如何在`addTask()`方法中追加到列表中。`task`变量包含新任务的文本：
- en: 'Ideally, the first step in this function is to construct the JSON data that
    defines our task:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，此函数的第一步是构造定义我们任务的JSON数据：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s another ES6 feature object literal property value shorthand; instead
    of writing `{task: task}` in our JSON object, we can simply write `{task}`. The
    variable name will become the key and the value stored in the variable becomes
    the value. This will throw an error if the variable is undefined.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '这里是另一个ES6特性对象文字属性值简写；在我们的JSON对象中，我们可以简单地写`{task}`而不是`{task: task}`。变量名将成为键，存储在变量中的值将成为值。如果变量未定义，这将引发错误。'
- en: We also need to create another variable `parentDiv` to store the object of the
    parent `<div>` element of our target `<input>` element. It's useful because, when
    the task is an empty string, we can add the `has-error` class to the parent element `parentDiv.classList.add('has-error')`,
    which by Bootstrap's CSS, renders a red border to our `<input>` element. This
    is how we can indicate to the user that they need to enter a text before clicking
    the Add button.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要创建另一个变量`parentDiv`来存储目标`<input>`元素的父`<div>`元素的对象。这很有用，因为当任务为空字符串时，我们可以向父元素`parentDiv.classList.add('has-error')`添加`has-error`类，这样通过Bootstrap的CSS，就会在我们的`<input>`元素上呈现红色边框。这就是我们如何告诉用户他们需要在单击添加按钮之前输入文本的方式。
- en: However, if the input text is not empty, we should remove the `has-error` class
    from our parent element to ensure the red border is not shown to the user and
    then simply push our `newTask` variable to the `tasks` variable of our class.
    Also, we need to call `loadTasks()` again so that the new task gets rendered.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果输入文本不为空，我们应该从父元素中删除`has-error`类，以确保红色边框不会显示给用户，然后简单地将我们的`newTask`变量推送到我们类的`tasks`变量中。此外，我们需要再次调用`loadTasks()`，以便新任务得到渲染。
- en: Adding tasks by hitting Enter button
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过按Enter键添加任务
- en: Well, this is one way of adding tasks, but some users prefer adding tasks directly
    by hitting the *Enter* button. For that, let's use event listeners to detect the
    *Enter* key press in the `<input>` element. We can also use the `onchange` attribute
    of our `<input>` element, but let's give event listeners a try. The best way to
    add event listeners to a class is to call them in the constructor so that the
    event listeners are set up when the class is initialized.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种添加任务的方式，但是一些用户更喜欢直接按下*Enter*按钮来添加任务。为此，让我们使用事件监听器来检测`<input>`元素中的*Enter*键按下。我们也可以使用我们的`<input>`元素的`onchange`属性，但让我们尝试一下事件监听器。向类添加事件监听器的最佳方式是在构造函数中调用它们，以便在初始化类时设置事件监听器。
- en: 'So, in our class, create a new function `addEventListeners()` and call it in
    our constructor. We are going to add event listeners inside this function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的类中，创建一个新的函数`addEventListeners()`并在我们的构造函数中调用它。我们将在此函数内添加事件监听器：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And that''s it! Reload Chrome, type in the text, and hit *Enter*. This should
    add tasks to our list just like how the add button works. Let''s go through our
    new event listener:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！重新加载Chrome，输入文本，然后按*Enter*。这应该像添加按钮一样将任务添加到我们的列表中。让我们来看看我们的新事件监听器：
- en: For every keypress happening in the `<input>` element with the ID `addTask`,
    we run the callback function with the `event` object as the parameter.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于发生在具有ID`addTask`的`<input>`元素中的每个按键按下，我们运行回调函数，参数为`event`对象。
- en: This event object contains the keycode of the key that was pressed. For the *Enter*
    key, the keycode is 13\. If the key code is equal to 13, we simply call the `this.addTask()`
    function with the task's text `event.target.value` as its parameter.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此事件对象包含按下的键的键码。对于*Enter*键，键码为13。如果键码等于13，我们只需调用`this.addTask()`函数，参数为任务的文本`event.target.value`。
- en: Now, the `addTask()` function handles adding the task to the list. We can simply
    reset `<input>` back to an empty string. This is a great advantage of organizing
    every operation into functions. We can simply reuse the functions wherever they're
    needed.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，`addTask()`函数处理将任务添加到列表中。我们可以简单地将`<input>`重置为空字符串。这是将每个操作组织成函数的一个很大的优势。我们可以在需要的地方简单地重用这些函数。
- en: Persisting data in the browser
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中持久保存数据
- en: 'Now, functionality-wise, our ToDo List is ready. However, on refreshing the
    page, the data will be gone. Let''s see how to persist data in the browser. Usually,
    web apps connect with APIs from the server-side to load data dynamically. Here,
    we are not looking into server-side implementation. So, we need to look for an
    alternate way to store data in the browser. There are three ways to store data
    in the browser. They are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就功能而言，我们的待办事项列表已经准备好了。但是，刷新页面后，数据将会丢失。让我们看看如何在浏览器中持久保存数据。通常，Web应用程序会与服务器端的API连接，以动态加载数据。在这里，我们不会研究服务器端的实现。因此，我们需要寻找一种在浏览器中存储数据的替代方式。在浏览器中有三种存储数据的方式。它们如下：
- en: '`cookie`: A `cookie` is a small information that is stored on the client-side
    (browser) by the server with an expiry date. It is useful for reading information
    from the client, such as login tokens, user preferences, and so on. Cookies are
    primarily used on the server-side and the amount of data that can be stored in
    the cookie is limited to 4093 bytes. In JavaScript, cookies can be managed using
    the `document.cookie` object.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`：`cookie`是由服务器存储在客户端（浏览器）上的小信息，带有到期日期。它对于从客户端读取信息非常有用，例如登录令牌、用户偏好等。Cookie主要用于服务器端，可以存储在cookie中的数据量限制为4093字节。在JavaScript中，可以使用`document.cookie`对象来管理cookie。'
- en: '`localStorage`: HTML5''s `localStorage` stores information with no expiry date
    and the data will persist even after closing and opening the web page. It provides
    a storage space of 5 MB per domain.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`：HTML5的`localStorage`存储信息没有到期日期，数据将在关闭和打开网页后仍然存在。它为每个域提供5MB的存储空间。'
- en: '`sessionStorage`: `sessionStorage` is equivalent to that of `localStorage`,
    except that the data is only valid per session (the current tab that the user
    is working on). The data expires when the website is closed.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionStorage`：`sessionStorage`与`localStorage`相当，只是数据仅在会话期间有效（用户正在使用的当前选项卡）。当网站关闭时，数据将过期。'
- en: 'For our use case, `localStorage` is the best choice for persisting task data.
    `localStorage` stores data as key-value pairs, while the value needs to be a string.
    Let''s look at the implementation part. Inside the constructor, instead of assigning
    the value to `this.tasks` directly, change it to the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，`localStorage`是持久化任务数据的最佳选择。`localStorage`将数据存储为键值对，而值需要是一个字符串。让我们来看看实现部分。在构造函数中，不要直接将值分配给`this.tasks`，而是更改为以下内容：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are going to save our tasks in `localStorage` as a string with `''TASKS''`
    as its key. So when the user opens the website for the first time, we need to
    check whether any data is present in `localStorage` with the key `''TASKS''`.
    If no data is present, it will return `null`, which means this is the first time
    a user is visiting the website. We need to use `JSON.parse()` to convert the data
    retrieved from `localStorage` from a string to an object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把任务保存在`localStorage`中，以字符串形式存储，其键为`'TASKS'`。因此，当用户第一次打开网站时，我们需要检查`localStorage`中是否存在以`'TASKS'`为键的数据。如果没有数据，它将返回`null`，这意味着这是用户第一次访问网站。我们需要使用`JSON.parse()`将从`localStorage`中检索到的数据从字符串转换为对象：
- en: 'If no data is present in `localStorage` (user visiting the site for the first
    time), we shall prepopulate some data for them using the `tasks` variable. The
    best place to add the code to persist task data in our application will be the
    `loadTasks()` function because it is called every time a change in `tasks` is
    made. In the `loadTasks()` function, add an additional line:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`localStorage`中没有数据（用户第一次访问网站），我们将使用`tasks`变量为他们预填一些数据。将代码添加到我们应用程序中持久保存任务数据的最佳位置将是`loadTasks()`函数，因为每次对`tasks`进行更改时都会调用它。在`loadTasks()`函数中，添加一行额外的代码：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will convert our `tasks` variable to string and store it in `localStorage`.
    Now, you can add tasks and refresh the page, and the data will be persisted in
    your browser.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将把我们的`tasks`变量转换为字符串并存储在`localStorage`中。现在，您可以添加任务并刷新页面，数据将在您的浏览器中持久保存。
- en: If you want to empty `localStorage` for development purposes, you can use `localStorage.removeItem('TASKS')` to
    delete the key or you can use `localStorage.clear()` to completely remove all
    the data stored in `localStorage`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想出于开发目的清空`localStorage`，可以使用`localStorage.removeItem('TASKS')`来删除键，或者可以使用`localStorage.clear()`来完全删除`localStorage`中存储的所有数据。
- en: Everything in JavaScript has an inherent Boolean value, which can be called
    truthy or falsy. The following values are always falsy - `null`, `""` (empty string),
    `false`, `0` (zero), `NaN` (not a number), and `undefined`. Other values are considered
    truthy. Hence, they can be directly used in conditional statements like how we
    used `if(!this.tasks) {}` in our code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有内容都有固有的布尔值，可以称为真值或假值。以下值始终为假值-`null`、`""`（空字符串）、`false`、`0`（零）、`NaN`（不是数字）和`undefined`。其他值被视为真值。因此，它们可以直接用于条件语句，就像我们在代码中使用`if(!this.tasks)
    {}`一样。
- en: 'Now that our application is complete, you can remove the contents of the `<ul>`
    element in the `index.html` file. The contents will now be directly populated
    from our JavaScript code. Otherwise, you will see the default HTML code flash
    in the page when the page is loaded or refreshed. This is because our JavaScript
    code executes only after all the resources are finished loading due to the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已经完成，您可以删除`index.html`文件中`<ul>`元素的内容。内容现在将直接从我们的JavaScript代码中填充。否则，当页面加载或刷新时，您将看到默认的HTML代码在页面中闪烁。这是因为我们的JavaScript代码只有在所有资源加载完成后才会执行，这是由以下代码造成的：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If everything works fine, then congratulations! You have successfully built
    your first JavaScript application and you have learned about the new ES6 features
    of JavaScript. Oh wait! Looks like we forgot something important!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，那么恭喜您！您已成功构建了您的第一个JavaScript应用程序，并了解了JavaScript的新ES6功能。哦等等！看起来我们忘记了一些重要的东西！
- en: All the storage options discussed here are unencrypted and, hence, should not
    be used for storing sensitive information, such as password, API keys, authentication
    tokens, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在这里讨论的存储选项都是未加密的，因此不应该用于存储敏感信息，比如密码、API密钥、认证令牌等。
- en: Compatibility with older browsers
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与旧浏览器的兼容性
- en: While ES6 works with almost all modern browsers, there are still many users
    who use older versions of Internet Explorer or Firefox. So, how are we going to
    make our application work for them? Well, the good thing about ES6 is that all
    it's new features can be implemented using the ES5 specification. This means that
    we can easily transpile our code to ES5, which will work on all modern browsers.
    For this purpose, we are going to use Babel: [https://babeljs.io/](https://babeljs.io/), as the
    compiler for converting ES6 to ES5.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ES6可以在几乎所有现代浏览器中使用，但仍然有许多用户使用较旧版本的Internet Explorer或Firefox。那么，我们要如何让我们的应用程序对他们起作用呢？ES6的好处在于，它的所有新功能都可以使用ES5规范来实现。这意味着我们可以轻松地将我们的代码转译为ES5，在所有现代浏览器上都可以运行。为此，我们将使用Babel：[https://babeljs.io/](https://babeljs.io/)，作为将ES6转换为ES5的编译器。
- en: Remember how, in the beginning of our chapter, we installed Node.js in our system?
    Well, it's finally time to use it. Before we start compiling our code to ES5,
    we need to learn about Node and the npm.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本章的开头在系统中安装Node.js吗？现在终于可以使用它了。在我们开始将代码编译为ES5之前，我们需要了解Node和npm。
- en: Node.js and npm
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js和npm
- en: Node.js is a JavaScript runtime built on Chrome's V8 engine. It lets developers
    run JavaScript outside of the browser. Due to the non-blocking I/O model of Node.js,
    it is widely used for building data-intensive, real-time applications. You can
    use it to build backend for your web application in JavaScript, just like PHP,
    Ruby, or other server-side languages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是建立在Chrome的V8引擎上的JavaScript运行时。它允许开发人员在浏览器之外运行JavaScript。由于Node.js的非阻塞I/O模型，它被广泛用于构建数据密集型的实时应用程序。您可以使用它来构建JavaScript的Web应用程序后端，就像PHP、Ruby或其他服务器端语言一样。
- en: 'One great advantage of Node.js is that it lets you organize your code into
    modules. A module is a set of code used to perform a specific function. So far,
    we have included the JavaScript code one after another inside the `<script>` tag
    in the browser. But in Node.js, we can simply call the dependency inside the code
    by creating the reference to the module. For example, if we need to jQuery, we
    can simply write the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的一个很大的优势是它允许你将代码组织成模块。模块是用于执行特定功能的一组代码。到目前为止，我们在浏览器的`<script>`标签中一个接一个地包含JavaScript代码。但是在Node.js中，我们可以通过创建对模块的引用来在代码中简单地调用依赖项。例如，如果我们需要jQuery，我们可以简单地写如下代码：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or, we can write the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写如下内容：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The jQuery module will be included in our code. All the properties and methods
    of jQuery will be accessible inside the `$` object. The scope of `$` will be only
    within the file it is called. So, in each file, we can specify the dependencies
    individually and all of them will be bundled together during compilation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery模块将被包含在我们的代码中。jQuery的所有属性和方法将在`$`对象内部可访问。`$`的范围将仅限于调用它的文件。因此，在每个文件中，我们可以单独指定依赖项，并且在编译期间它们将被捆绑在一起。
- en: 'But wait! For including `jquery`, we need to download the `jquery` package
    that contains the required module and save it in a folder. Then, we need to assign
    `$` the reference of the file in the folder containing the module. And as the
    project grows, we will be adding a lot of packages and refer ring the modules
    in our code. So, how are we going to manage all the packages. Well, we have a
    nice little tool that gets installed along with Node.js called the **Node Package
    Manager** (**npm**):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！为了包含`jquery`，我们需要下载包含所需模块的`jquery`包并将其保存在一个文件夹中。然后，我们需要将`$`分配给包含模块的文件夹中的文件的引用。随着项目的增长，我们将添加许多软件包并在我们的代码中引用这些模块。那么，我们将如何管理所有这些软件包。好吧，我们有一个随Node.js一起安装的小工具，叫做**Node
    Package Manager**（**npm**）：
- en: 'For Linux and Mac users, npm is similar to one of these: `apt-get`, `yum`,
    `dnf`, and `Homebrew`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Linux和Mac用户，npm类似于这些之一：`apt-get`、`yum`、`dnf`和`Homebrew`。
- en: For Windows users, you might not be familiar with the concept of package management
    yet. So, let's say you need jQuery. But you don't know what dependencies are needed
    for jQuery to run. That's where package managers come into play. You can simply
    run a command to install a package (`npm install jquery`). The package manager
    will read all the dependencies of the target package and install the target along
    with its dependencies. It also manages a file to keep track of installed packages.
    This is used for easily uninstalling the package in the future.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows用户，您可能还不熟悉软件包管理的概念。所以，假设您需要jQuery。但是您不知道jQuery运行所需的依赖关系。这就是软件包管理器发挥作用的地方。您可以简单地运行一个命令来安装一个包（`npm
    install jquery`）。软件包管理器将读取目标软件包的所有依赖项，并安装目标及其依赖项。它还管理一个文件以跟踪已安装的软件包。这用于将来轻松卸载软件包。
- en: Even though Node.js allows require/import of modules directly into the code,
    browsers do not support require or import functionality to directly import a module.
    But there are many tools available that can easily mimic this functionality so
    that we can use import/require inside our browsers. We'll use them for our project
    in the next chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node.js允许直接将模块导入/导入到代码中，但浏览器不支持直接导入模块的require或import功能。但是有许多可用的工具可以轻松模仿这种功能，以便我们可以在浏览器中使用import/require。我们将在下一章中为我们的项目使用它们。
- en: npm maintains a `package.json` file to store information regarding a package,
    such as its name, scripts, dependencies, dev dependencies, repository, author,
    license, and so on. A package is a folder containing one or more folder or files
    with a `package.json` file in its root folder. There are thousands of open source
    packages available in npm. Visit [https://www.npmjs.com/](https://www.npmjs.com/)
    to explore the available packages. The packages can be modules that are used on
    the server-side or browser-side and command-line tools that are useful for performing
    various operations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: npm维护一个`package.json`文件，用于存储有关软件包的信息，例如其名称、脚本、依赖项、开发依赖项、存储库、作者、许可证等。软件包是一个包含一个或多个文件夹或文件的文件夹，其根文件夹中有一个`package.json`文件。npm中有成千上万的开源软件包可用。访问[https://www.npmjs.com/](https://www.npmjs.com/)来探索可用的软件包。这些软件包可以是用于服务器端或浏览器端的模块，也可以是用于执行各种操作的命令行工具。
- en: 'npm packages can be installed locally (per project) or globally (entire system).
    We can specify how we want to install it using different flags, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: npm软件包可以在本地（每个项目）或全局（整个系统）安装。我们可以使用不同的标志来指定我们想要如何安装它，如下所示：
- en: If we want to install a package globally, we should use the `--global` or `-g` flag.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要全局安装一个包，我们应该使用`--global`或`-g`标志。
- en: If the package should be installed locally for a specific project, use the `--save`
    or `-S` flag.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果软件包应该在本地为特定项目安装，请使用`--save`或`-S`标志。
- en: If the package should be installed locally and it is only used for development
    purposes, use the `--save-dev` or `-D` flag.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果软件包应该在本地安装，并且仅用于开发目的，请使用`--save-dev`或`-D`标志。
- en: If you run `npm install <package-name>` without any flags, it will install the
    package locally but will not update the `package.json` file. It is not recommended
    to install packages without the `-S` or `-D` flags.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行`npm install <package-name>`而没有任何标志，它将在本地安装软件包，但不会更新`package.json`文件。不建议在没有`-S`或`-D`标志的情况下安装软件包。
- en: Let's install a command-line tool using npm called `http-server`:[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server).
    It is a simple tool that can be used to serve static files over an `http-server`
    just like how files are served in Apache or Nginx. This is useful for testing
    and developing our web applications, since we can see how our application behaves
    when it's served through a web server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用npm安装一个命令行工具叫做`http-server`：[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)。这是一个简单的工具，可以用来像Apache或Nginx一样通过`http-server`提供静态文件。这对于测试和开发我们的Web应用程序非常有用，因为我们可以看到我们的应用程序在通过Web服务器提供时的行为。
- en: 'Command-line tools are mostly recommended to install globally if they are going
    to be used only by ourselves and not by any other developer. In our case, we are
    only going to be using the `http-server` package. So, let''s install it globally.
    Open your Terminal/command prompt and run the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行工具只会被我们自己使用，而不会被任何其他开发人员使用，那么通常建议全局安装。在我们的情况下，我们只会使用`http-server`包。所以，让我们全局安装它。打开你的终端/命令提示符并运行以下命令：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you are using Linux, some times you might face errors such as permission
    denied or unable to access file, and so on. Try running the same command as administrator
    (prefixed with `sudo`) for installing the package globally.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Linux，有时可能会遇到权限被拒绝或无法访问文件等错误。尝试以管理员身份运行相同的命令（前面加上`sudo`）以全局安装该软件包。
- en: 'Once the installation is complete, navigate to the root folder of our ToDo
    List app in your terminal and run the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，就在终端中导航到我们的待办事项列表应用程序的根文件夹，并运行以下命令：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will receive two URLs and the server will start running, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到两个URL，并且服务器将开始运行，如下所示：
- en: To view the ToDo List app on your local device, open the URL starting with `127`
    in your browser
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在本地设备上查看待办事项列表应用程序，请在浏览器中打开以`127`开头的URL
- en: To view the ToDo List app on a different device connected to your local network,
    open the URL starting with `192` on the device's browser
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在连接到您本地网络的其他设备上查看待办事项列表应用程序，请在设备的浏览器中打开以`192`开头的URL
- en: Every time you open the application, `http-server` will print the served files
    in the terminal. There are various options available with `http-server`, such
    as `-p` flag, which can be used to change the default port number `8080` (try
    `http-server -p 8085`). Visit the http-server:[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server),npm
    page for documentation on all available options. Now that we have a general idea
    of the `npm` packages, let's install Babel to transpile our ES6 code to ES5.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每次打开应用程序时，`http-server`都会在终端中打印已提供的文件。`http-server`有各种选项可用，例如`-p`标志，可用于更改默认端口号`8080`（尝试`http-server
    -p 8085`）。访问http-server:[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)，npm页面以获取所有可用选项的文档。现在我们对`npm`包有了一个大致的了解，让我们安装Babel将我们的ES6代码转译为ES5。
- en: We will be using Terminals a lot in our upcoming chapters. If you are using
    VSCode, it has an inbuilt terminal, which can be opened by pressing *Ctrl*+*`*
    on Mac, Linux, and Windows. It also supports opening multiple terminal sessions
    at the same time. This can save you lot time on switching between windows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中经常使用终端。如果您使用的是VSCode，它有一个内置的终端，可以通过在Mac、Linux和Windows上按*Ctrl*+*`*来打开。它还支持同时打开多个终端会话。这可以节省您在窗口之间切换的时间。
- en: Setting up our development environment with Node and Babel
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node和Babel设置我们的开发环境
- en: Babel is a JavaScript compiler, which is used to transpile JavaScript code from
    ES6+ to normal ES5 specification. Let's set up Babel in our project so that it
    automatically compiles our code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是一个JavaScript编译器，用于将JavaScript代码从ES6+转译为普通的ES5规范。让我们在项目中设置Babel，以便它自动编译我们的代码。
- en: 'There will be two different JS files in our project after setting up Babel.
    One is ES6, which we use to develop our app, and another will be the compiled
    ES5 code, which is going to be used by the browser. So, we need to create two
    different folders in our project root directory, namely, `src` and `dist`. Move
    the `scripts.js` file into the `src` directory. We are going to use Babel to compile
    the scripts from the `src` directory and store the result in the `dist` directory.
    So, in `index.html`, change the reference of `scripts.js` into `<script src="dist/scripts.js"></script>` so
    that the browser will always read the compiled code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置Babel后，我们的项目中将有两个不同的JS文件。一个是ES6，我们用来开发我们的应用程序，另一个是编译后的ES5代码，将被浏览器使用。因此，我们需要在项目的根目录中创建两个不同的文件夹，即`src`和`dist`。将`scripts.js`文件移动到`src`目录中。我们将使用Babel来编译`src`目录中的脚本，并将结果存储在`dist`目录中。因此，在`index.html`中，将`scripts.js`的引用更改为`<script
    src="dist/scripts.js"></script>`，以便浏览器始终读取编译后的代码：
- en: 'To use npm, we need to create `package.json` in our project''s root directory.
    Navigate to the project root directory in your terminal and type:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用npm，我们需要在项目的根目录中创建`package.json`。在终端中导航到项目的根目录，并键入：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, it will ask your project's name, type in a name. For other questions,
    either type in some values or just hit *Enter* to accept default values. These
    values will be populated in the `package.json` file, which can be changed later.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它会询问您的项目名称，请输入名称。对于其他问题，要么输入一些值，要么只需按*Enter*接受默认值。这些值将填充到`package.json`文件中，稍后可以更改。
- en: 'Let''s install our development dependencies by running the following command
    in the terminal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令来安装我们的开发依赖项：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command will create a `node_modules` folder and install the packages inside
    it. Now, your `package.json` file will have the preceding packages in its `devDependencies`
    parameter and your current folder structure should be:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将创建一个`node_modules`文件夹，并在其中安装包。现在，您的`package.json`文件将在其`devDependencies`参数中具有前述包，并且您当前的文件夹结构应如下所示：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you are using git or any other version control system in your project, add
    `node_modules` and the `dist` folder to `.gitignore` or a similar file. These
    folders need not be committed to version control and must be generated when needed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目中使用git或任何其他版本控制系统，请将`node_modules`和`dist`文件夹添加到`.gitignore`或类似的文件中。这些文件夹不需要提交到版本控制，并且在需要时必须生成。
- en: 'Time to write scripts to compile our code. Inside the `package.json` file,
    there will be a parameter called `scripts`. By default, it will be the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写脚本来编译我们的代码了。在`package.json`文件中，将有一个名为`scripts`的参数。默认情况下，它将是以下内容：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`test` is one of the default commands for npm. When you run `npm test` in the
    terminal, it will automatically execute the script inside the test key''s value
    in the terminal. As the name suggests, `test` is used for executing automated
    test cases. Some other default commands are `start`, `stop`, `restart`, `shrinkwrap`,
    and so on. These commands are very useful to run scripts when developing server-side
    applications with Node.js.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`是npm的默认命令之一。当您在终端中运行`npm test`时，它将自动在终端中执行test键值内的脚本。顾名思义，`test`用于执行自动化测试用例。其他一些默认命令包括`start`、`stop`、`restart`、`shrinkwrap`等。这些命令在使用Node.js开发服务器端应用程序时非常有用。'
- en: However, during frontend development, we may need more commands like the default commands.
    `npm` also allows us to create our commands to execute arbitrary scripts. However,
    unlike default commands (such as `npm start`), we cannot execute our own commands
    by running `npm <command-name>`; we have to execute `npm run <command-name>` in
    the terminal.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前端开发过程中，我们可能需要更多的命令，像默认的命令一样。`npm`也允许我们创建自己的命令来执行任意脚本。但是，与默认命令（如`npm start`）不同，我们不能通过运行`npm
    <command-name>`来执行我们自己的命令；我们必须在终端中执行`npm run <command-name>`。
- en: We are going to set up npm scripts so that running `npm run build` will generate
    a working build for our application with the compiled ES5 code and running `npm
    run watch` will spin up a development server, which we are going to use for development.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置npm脚本，这样运行`npm run build`将会生成一个包含编译后的ES5代码的应用程序工作构建，运行`npm run watch`将会启动一个开发服务器，我们将用于开发。
- en: 'Change the contents of scripts section into the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本部分的内容更改为以下内容：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Well, that looks like a lot of scripts! Let's go through them one by one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看起来有很多脚本！让我们逐个查看它们。
- en: 'First, let''s check out the `watch` script:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看`watch`脚本：
- en: The function of this script is to start `babel` in the watch mode so that every
    time we make any change in our ES6 code inside `src` directory, it will automatically
    be transpiled into ES5 code inside the `dist` directory along with source maps,
    which is useful for debugging the compiled code. The watch mode will keep on continuing
    the process in the terminal until the execution is terminated (hitting *Ctrl*+*C*).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个脚本的功能是启动`babel`进入监视模式，这样每当我们在`src`目录中的ES6代码中进行任何更改时，它都会自动转译为`dist`目录中的ES5代码，同时生成源映射，这对于调试编译后的代码非常有用。监视模式将在终端中持续进行，直到执行被终止（按下*Ctrl*+*C*）。
- en: Execute `npm run watch` in the terminal from your project's root directory.
    You can see that Babel has started compiling the code and a new `scripts.js` file
    will be created inside the `dist` folder.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中从项目的根目录执行`npm run watch`。你会看到Babel已经开始编译代码，并且一个新的`scripts.js`文件将被创建在`dist`文件夹中。
- en: The `scripts.js` file will contain our code in the ES5 format. Open up `index.html`
    in Chrome and you should see our application running normally.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts.js`文件将包含我们的代码以ES5格式。在Chrome中打开`index.html`，你应该能看到我们的应用程序正常运行。'
- en: Here's how it works. Try running `babel src -d dist --presets=es2015 -ws` directly
    in the terminal. It will throw an error saying `babel` is not installed (the error
    message may vary depending on your operating system). This is because we haven't
    installed Babel globally. We only installed it within our project. So, when we
    run `npm run watch`, npm will look for the binaries for Babel inside the project's
    `node_modules` folder and execute the command using those binaries.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的。尝试直接在终端中运行`babel src -d dist --presets=es2015 -ws`。它会抛出一个错误，说`babel`未安装（错误消息可能因操作系统而异）。这是因为我们还没有全局安装Babel。我们只在项目中安装了它。所以，当我们运行`npm
    run watch`时，npm将在项目的`node_modules`文件夹中查找Babel的二进制文件，并使用这些二进制文件执行命令。
- en: 'Delete the `dist` directory, and create a new script inside `package.json`--`"babel":
    "babel src -d dist"`. We are going to use this script for learning how Babel works:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '删除`dist`目录，并在`package.json`中创建一个新的脚本--`"babel": "babel src -d dist"`。我们将使用这个脚本来学习Babel的工作原理。'
- en: This script tells Babel *compile all the JS files inside the* `src` *directory
    and save the resulting files inside* `dist` *directory*. The `dist` directory
    will be created if it is not present. Here, the `-d` flag is used to tell Babel
    that it needs to compile files inside the entire directory.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个脚本告诉Babel*编译`src`目录中的所有JS文件，并将生成的文件保存在*`dist`*目录中*。如果`dist`目录不存在，它将被创建。这里，使用`-d`标志告诉Babel需要编译整个目录中的文件。
- en: Run `npm run babel` in the terminal and open up our new `scripts.js` file inside
    the `dist` directory. Well, the file is compiled, but unfortunately, the result
    is also in ES6 syntax, so the new `scripts.js` file is an exact copy of our original
    file!
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中运行`npm run babel`，并打开`dist`目录中的新`scripts.js`文件。好吧，文件已经编译了，但不幸的是，结果也是ES6语法，所以新的`scripts.js`文件是我们原始文件的精确副本！
- en: Our goal is to compile our code to ES5\. For that, we need to instruct Babel
    to use some presets during compilation. Look at our `npm install` command, we
    have installed a package called `babel-preset-es2015` for this purpose.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的目标是将我们的代码编译为ES5。为此，我们需要在编译过程中指示Babel使用一些预设。看看我们的`npm install`命令，我们已经安装了一个名为`babel-preset-es2015`的包来实现这个目的。
- en: In our Babel script, add the option `--presets=es2015` and execute `npm run
    babel` again. This time the code will be compiled to ES5 syntax.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Babel脚本中，添加选项`--presets=es2015`，然后再次执行`npm run babel`。这次代码将被编译为ES5语法。
- en: Open up our application in the browser, add `debugger` inside our constructor,
    and reload. We have a new problem; the sources will now contain the code in ES5
    syntax, which makes it harder to debug our original code.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中打开我们的应用程序，在构造函数中添加`debugger`，然后重新加载。我们有一个新问题；源代码现在将包含ES5语法的代码，这使得调试我们的原始代码变得更加困难。
- en: For this, we need to enable source maps using the `-s` flag that creates a `.map`
    file, which is used to map the compiled code back to the original source. Also,
    use the `-w` flag to put Babel in the watch mode.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为此，我们需要使用`-s`标志启用源映射，它会创建一个`.map`文件，用于将编译后的代码映射回原始源代码。还要使用`-w`标志将Babel置于监视模式。
- en: And now our script will be the same as the one used in the `watch` command.
    Reload the application with the debugger and you can see that the sources will
    contain our original code even though it is using the compiled source.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的脚本将与`watch`命令中使用的脚本相同。使用调试器重新加载应用程序，你会看到源代码将包含我们的原始代码，即使它使用的是编译后的源代码。
- en: Wouldn't it be nice if running a single command would also start up our development
    server using `http-server`. We cannot use `&&` to concatenate two commands that
    run simultaneously. Since `&&` will execute the second command, only after the
    first one completes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行单个命令也可以启动我们的开发服务器，那不是很好吗？我们不能使用`&&`来连接两个同时运行的命令。因为`&&`将在第一个命令完成后才执行第二个命令。
- en: 'We have installed another package called `concurrently` for this purpose. It
    is used for executing multiple commands together. Syntax for using `concurrently`
    is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此安装了另一个名为`concurrently`的包。它用于同时执行多个命令。使用`concurrently`的语法如下：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we execute `npm run watch`, we need to run both the current `watch` script
    and the `serve` script. Change the `watch` script into the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`npm run watch`时，我们需要同时运行当前的`watch`脚本和`serve`脚本。将`watch`脚本更改为以下内容：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Try running `npm run watch` again. Now, you have a fully functional development
    environment, which will automatically serve the files as well as compile the code
    as you make changes to your JS code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次运行`npm run watch`。现在，您拥有一个完全功能的开发环境，它将在您对JS代码进行更改时自动提供文件并编译代码。
- en: Shipping the code
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布代码
- en: Once development is done, for shipping the code if you use version control,
    add the `node_modules` and `dist` folder to the ignore list. Otherwise, send your
    code without the `node_modules` or `dist` folder. Other developers can simply
    run `npm install` to install dependencies and read the scripts inside the `package.json` file
    to build the project when needed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 开发完成后，如果您使用版本控制来发布代码，请将`node_modules`和`dist`文件夹添加到忽略列表中。否则，发送您的代码时不包括`node_modules`或`dist`文件夹。其他开发人员可以简单地运行`npm
    install`来安装依赖项，并在需要时读取`package.json`文件中的脚本来构建项目。
- en: Our `npm run build` command will remove the `dist` folder present inside the
    project folder and create a new `dist` folder with the latest build of JS code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`npm run build`命令将删除项目文件夹中的`dist`文件夹，并使用最新的JS代码构建一个新的`dist`文件夹。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Congratulations! You have built your first JavaScript application with the
    new ES6 syntax. You have learned the following concepts in this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经用新的ES6语法构建了您的第一个JavaScript应用程序。在本章中，您学到了以下概念：
- en: DOM manipulation and event listeners in JavaScript
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的DOM操作和事件监听器
- en: ECMAScript 2015 (ES6) syntax of JavaScript
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的ECMAScript 2015（ES6）语法
- en: Chrome Developer Tools
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome开发者工具
- en: The workings of Node and npm
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node和npm的工作原理
- en: Using Babel to transpile the ES6 code to ES5 code
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel将ES6代码转译为ES5代码
- en: In our current npm setup, we have simply created a compile script to transform
    our code into ES5\. There are lots of other tools available to automate more tasks,
    such as minification, linting, image compression, and so on. We will use one such
    tool called Webpack in our next chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的npm设置中，我们只是创建了一个编译脚本来将我们的代码转换为ES5。还有许多其他可用于自动化更多任务的工具，例如缩小、linting、图像压缩等。我们将在下一章中使用一个名为Webpack的工具。
