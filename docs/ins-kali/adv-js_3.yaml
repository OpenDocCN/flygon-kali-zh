- en: '*Chapter 3*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*'
- en: DOM Manipulation and Event Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM操作和事件处理
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下几点：
- en: Explain DOM traversal and manipulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释DOM遍历和操作
- en: Create the event object and browser events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事件对象和浏览器事件
- en: Organize event propagation and bubbling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织事件传播和冒泡
- en: Delegate events efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地委托事件
- en: Utilize JQuery to handle events and DOM manipulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用jQuery处理事件和DOM操作
- en: This chapter will cover working with document nodes, event objects, and the
    process of chaining, navigation, and handling events.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖处理文档节点、事件对象以及链式、导航和处理事件的过程。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the first chapter, we covered many of the new and powerful features that
    were released in ES6\. We discussed the evolution of JavaScript and highlighted
    the key additions in ES6\. We discussed scope rules, variable declaration, arrow
    functions, template literals, enhanced object properties, destructuring assignment,
    classes and modules, transpiling, and iterators and generators.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们涵盖了ES6中发布的许多新的强大功能。我们讨论了JavaScript的发展，并突出了ES6中的关键新增功能。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强对象属性、解构赋值、类和模块、转译以及迭代器和生成器。
- en: In the second chapter, we covered JavaScript's asynchronous programming paradigms.
    We discussed the JavaScript event loop, callbacks, promises, and the async/await
    syntax. This chapter prepared us to apply the material from *Chapter 1, Introducing
    ECMAScript 6* and write powerful asynchronous programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们涵盖了JavaScript的异步编程范式。我们讨论了JavaScript事件循环、回调、承诺和async/await语法。本章使我们能够应用*第1章，介绍ECMAScript
    6*中的材料，并编写强大的异步程序。
- en: In this chapter, we will learn about the **Document** **Object Model (DOM)**
    and the **JavaScript Event object**. In the first topic, we will define the Document
    Object Model and explain DOM chaining, navigation, and manipulation. Then, we
    will explain the JavaScript event object and show how to interact with and handle
    DOM events. In this chapter, we will cover jQuery and use it to traverse the DOM
    and handle events.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**文档对象模型（DOM）**和**JavaScript事件对象**。在第一个主题中，我们将定义文档对象模型并解释DOM链式、导航和操作。然后，我们将解释JavaScript事件对象，并展示如何与处理DOM事件进行交互。在本章中，我们将涵盖jQuery，并使用它来遍历DOM和处理事件。
- en: DOM Chaining, Navigation, and Manipulation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM链式、导航和操作
- en: The **Document Object Model (DOM)** is an interface for HTML documents. The
    DOM represents a web page in such a way that programs can change the document
    structure, style, and content. The DOM is the object-oriented representation of
    a web page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型（DOM）**是HTML文档的接口。DOM以一种程序可以更改文档结构、样式和内容的方式来表示网页。DOM是网页的面向对象表示。'
- en: 'There are two standards for the DOM: the **World Wide Web Consortium (W3C)**
    standard and the **Web Hypertext Application Technology Working Group (WHATWG)**
    standard. WHATWG was developed in response to the slow development of the W3C
    standard. Both standards define HTML elements as objects that can be accessed
    by JavaScript code, and properties, accessor methods, and events for all HTML
    elements. DOM object methods are actions you can perform on HTML elements and
    DOM object properties are values you can get or set. The DOM standard provides
    a way for JavaScript to add, get, change, or delete HTML elements programmatically.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DOM有两个标准：**万维网联盟（W3C）**标准和**Web超文本应用技术工作组（WHATWG）**标准。WHATWG是为了应对W3C标准的缓慢发展而开发的。这两个标准都将HTML元素定义为可以被JavaScript代码访问的对象，并为所有HTML元素定义了属性、访问器方法和事件。DOM对象方法是您可以在HTML元素上执行的操作，DOM对象属性是您可以获取或设置的值。DOM标准提供了一种让JavaScript以编程方式添加、获取、更改或删除HTML元素的方法。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The W3C DOM standard and WHATWG DOM standard are implemented by most modern
    browsers (Chrome, Firefox, and Edge), and many browsers extend the standard. When
    interfacing with the DOM, we must make sure that all of the functions we use are
    compatible with the browsers our users may have.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: W3C DOM标准和WHATWG DOM标准由大多数现代浏览器（Chrome、Firefox和Edge）实现，并且许多浏览器扩展了这些标准。在与DOM进行交互时，我们必须确保我们使用的所有函数与我们的用户可能使用的浏览器兼容。
- en: The DOM for a web page is constructed as a tree of objects, called **nodes**.
    The object at the head of the tree is a **document node**. The **document** is
    the interface that serves as an entry point for the web page's content, the DOM
    tree. HTML elements in the page are added to the DOM tree under the document.
    They are called **element nodes**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的DOM构造为对象树，称为**节点**。树的顶部对象是**文档节点**。**文档**是作为网页内容、DOM树的入口点的接口。页面中的HTML元素被添加到文档下的DOM树中。它们被称为**元素节点**。
- en: 'Elements in the DOM tree can have three types of relationships with the elements
    around them: **parent**, **sibling**, and **child**. An element''s parent element
    is the element that it is contained by. An element''s sibling nodes are elements
    that are also contained by the element''s parent. An element''s child nodes are
    the elements that it contains. An example DOM tree is shown in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: DOM树中的元素与其周围元素有三种类型的关系：**父级**、**同级**和**子级**。元素的父元素是包含它的元素。元素的同级节点是同样包含在父元素中的元素。元素的子节点是它包含的元素。以下是一个示例DOM树的图示：
- en: '![Figure 3.1: DOM tree structure ](image/Figure_3.1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：DOM树结构](image/Figure_3.1.jpg)'
- en: 'Figure 3.1: DOM tree structure'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：DOM树结构
- en: In the preceding diagram, we can see that the global parent is the **document
    object**. The document object has one child node, the `<html>` element. The `<html>`
    element's parent node is the document and it has two child nodes, the `<head>`
    and `<body>` elements. The `<head>` and `<body>` elements are sibling nodes to
    each other because they both have the same parent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到全局父级是**文档对象**。文档对象有一个子节点，即`<html>`元素。`<html>`元素的父节点是文档，它有两个子节点，即`<head>`和`<body>`元素。`<head>`和`<body>`元素是彼此的兄弟节点，因为它们都有相同的父节点。
- en: 'Exercise 20: Building the HTML Document from a DOM Tree Structure'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习20：从DOM树结构构建HTML文档
- en: The aim here is to create a web page, "My title", which displays the header
    "My header" and the link "My link". Reference the preceding diagram for the DOM
    tree structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是创建一个名为"My title"的网页，显示标题"My header"和链接"My link"。参考前面的图表以获取DOM树结构。
- en: 'To build an HTML document from a DOM tree structure, perform the following
    steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从DOM树结构构建HTML文档，请执行以下步骤：
- en: Create an HTML file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件。
- en: Add an `<html>` tag to the file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加一个`<html>`标签。
- en: Add a `<head>` tag inside the `<html>` tag.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<html>`标签内添加一个`<head>`标签。
- en: Add a `<title>` tag after the `<head>` tag.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`标签后添加一个`<title>`标签。
- en: Add the text **My title** in the `<title>` tag.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<title>`标签中添加文本**My title**。
- en: Add a `<body>` tag below the `<head>` tag.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`标签下方添加一个`<body>`标签。
- en: Add the elements `<a>` and `<h1>` under the `<body>` tag.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<body>`标签下添加`<a>`和`<h1>`元素。
- en: Add the `href` attribute to the `<a>` tag and set its internal text to **My
    link**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`<a>`标签添加`href`属性，并将其内部文本设置为**My link**。
- en: Add the text **My header** inside the `<h1>` tag.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<h1>`标签中添加文本**My header**。
- en: Close the `body` and `html` tags and fetch the output.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`body`和`html`标签并获取输出。
- en: '**Code**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: https://bit.ly/2FiLgcE
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2FiLgcE
- en: 'Snippet 3.1: Simple site to demonstrate a DOM tree'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.1：演示DOM树的简单网站
- en: '**Outcome**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '![Figure 3.2: My header link output ](image/Figure_3.2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：我的标题链接输出](image/Figure_3.2.jpg)'
- en: 'Figure 3.2: My header link output'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：我的标题链接输出
- en: You have successfully built an HTML document from a DOM tree structure.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功从DOM树结构构建了HTML文档。
- en: DOM Navigation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM导航
- en: 'Now that we understand the basic structure of the DOM, we are ready to start
    interfacing with it in our applications. Before we can begin to modify the DOM
    with JavaScript, we have to navigate the DOM tree to find the specific element
    nodes that we want to modify. We can find a specific node in one of two ways:
    **finding it by identifier** or **navigating the DOM tree**. The fastest look
    up method is looking up an element by identifier. DOM elements can be looked up
    in one of four ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了DOM的基本结构，我们准备在我们的应用程序中开始与它进行接口。在我们可以用JavaScript修改DOM之前，我们必须导航DOM树以找到我们想要修改的特定元素节点。我们可以通过两种方式之一找到特定节点：**通过标识符找到**或**导航DOM树**。最快的查找方法是通过标识符查找元素。DOM元素可以通过以下四种方式之一查找：
- en: ID
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID
- en: Tag name
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签名
- en: Class
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: CSS query selector
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS查询选择器
- en: Finding a DOM Node
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找DOM节点
- en: 'Getting an element by ID is done with the `document.getElementById( id )` method.
    This method takes in a parameter id, which represents the id of the element to
    look up, and returns an element object. The object that''s returned will be the
    element object that describes the DOM node of the specified id. If no element
    matches the id provided, the function will return null. An example of the `getElementById`
    function is shown in the following snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`document.getElementById( id )`方法可以通过ID获取元素。该方法接受一个表示要查找的元素ID的参数id，并返回一个元素对象。返回的对象将是描述指定ID的DOM节点的元素对象。如果没有匹配提供的ID的元素，则该函数将返回null。以下是`getElementById`函数的示例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 3.2: Getting an element by its id'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.2：通过ID获取元素
- en: 'Getting an element by tag name is done with the `document.getElementsByTagName(
    name )` method. The function takes in a single argument that represents the HTML
    tag name to search for. `getElementsByTagName` returns a live `HTMLCollection`
    of elements that match the given tag name. The returned list is live, which means
    that it updates itself with the DOM tree automatically. There is no need to call
    the function several times with the same element and arguments. An example of
    `getElementsByTagName` is shown in the following snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`document.getElementsByTagName( name )`方法可以通过标签名获取元素。该函数接受一个表示要搜索的HTML标签名的参数。`getElementsByTagName`返回一个匹配给定标签名的元素的实时`HTMLCollection`。返回的列表是实时的，这意味着它会自动更新与DOM树。不需要多次使用相同的元素和参数调用该函数。以下是`getElementsByTagName`的示例：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 3.3: Getting elements by tag name'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.3：按标签名获取元素
- en: Note
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An `HTMLCollection` is an interface that represents a collection (array-like
    object) of element nodes. It can be iterated over and offers methods and properties
    for selecting from the list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTMLCollection`是表示元素节点集合（类似数组的对象）的接口。它可以被迭代，并提供用于从列表中选择的方法和属性。'
- en: 'To get an element by class name, we use the `document.getElementsByClassName(
    name )` method. The function takes in a single argument that represents the HTML
    class name to search for and returns a live `HTMLCollection` of elements that
    match the given `classname`. An example of `getElementsByClassName` is shown in
    the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过类名获取元素，我们使用`document.getElementsByClassName( name )`方法。该函数接受一个表示要搜索的HTML类名的参数，并返回一个匹配给定类名的元素的实时`HTMLCollection`。以下是`getElementsByClassName`的示例：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 3.4: Getting elements by class name'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.4：按类名获取元素
- en: 'The two functions, `querySelector()` and `querySelectorAll()`, are used to
    get HTML elements by CSS query selector. They both take in a single string parameter
    that represents a CSS selector string. `querySelector` will return a single element.
    `querySelectorAll` will return a static (non-live) `NodeList` of the elements
    that match the query. Multiple query selectors can be passed into the function
    by creating a comma-separated string that contains each selector. If multiple
    selectors are passed into the query selector functions, the function will match
    and return elements that meet any of the selector''s requirements. The functionality
    for `querySelector` and `querySelectorAll` is shown in the following snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelector()`和`querySelectorAll()`这两个函数用于通过CSS查询选择器获取HTML元素。它们都接受一个表示CSS选择器字符串的单个字符串参数。`querySelector`将返回一个单个元素。`querySelectorAll`将返回与查询匹配的元素的静态（非实时）`NodeList`。可以通过创建包含每个选择器的逗号分隔字符串将多个查询选择器传递给函数。如果将多个选择器传递给查询选择器函数，函数将匹配并返回满足任何选择器要求的元素。`querySelector`和`querySelectorAll`的功能如下片段所示：'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 3.5: Getting elements by using the CSS selector'
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.5：使用CSS选择器获取元素
- en: Note
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A `NodeList` is similar to an `HTMLCollection`. It is an array-like collection
    of HTML nodes that can be iterated over.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeList`类似于`HTMLCollection`。它是一个类似数组的HTML节点集合，可以进行迭代。'
- en: 'Each of the methods covered previously and their function syntax are shown
    in the following table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前介绍的每个方法及其函数语法如下表所示：
- en: '![Figure 3.3: Methods and syntax'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3：方法和语法'
- en: '](image/Figure_3.3.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.3.jpg)'
- en: 'Figure 3.3: Methods and syntax'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：方法和语法
- en: The `getElementsByTagName`, `getElementsByClassName`, `querySelector`, and `querySelectorAll`
    functions are not limited to only the document object; they can also be called
    on element nodes. If they are called on an element node, the resulting elements
    collection returned by the function will be limited to only the children of the
    element, which the function was called on. This is shown in the following example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByTagName`、`getElementsByClassName`、`querySelector`和`querySelectorAll`函数不仅限于文档对象；它们也可以在元素节点上调用。如果它们在元素节点上调用，函数返回的结果元素集合将仅限于函数调用的元素的子节点。以下示例显示了这一点。'
- en: '**Example**: We get the element object for the div with the id `div1` and save
    it in the `elem` variable. We then use `getElementsByTagName` to get other div
    elements. The function is called on the element object saved in `elem`, so the
    search space is limited to child nodes of `div1`. `getElementsByTagName` will
    return an `HTMLCollection` with the divs `div2` and `div3` because they are descendants
    of `div1`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：我们获取具有id`div1`的div元素对象，并将其保存在`elem`变量中。然后我们使用`getElementsByTagName`来获取其他div元素。该函数在保存在`elem`中的元素对象上调用，因此搜索范围仅限于`div1`的子节点。`getElementsByTagName`将返回一个包含divs`div2`和`div3`的`HTMLCollection`，因为它们是`div1`的后代：'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 3.6: Returning an HTMLCollection'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.6：返回HTMLCollection
- en: The second way to find DOM elements is by navigating the DOM tree through the
    element relationships. Once we have found a DOM element to work with, we can use
    several properties to get that element's child, parent, and sibling nodes. We
    can traverse the DOM tree by going from node to node with the properties `parentNode`,
    `childNodes`, `firstChild`, `lastChild`, `previousSibling`, and `nextSibling`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查找DOM元素的第二种方法是通过导航DOM树来查找元素关系。一旦找到要处理的DOM元素，我们可以使用多个属性来获取该元素的子节点、父节点和兄弟节点。我们可以通过使用`parentNode`、`childNodes`、`firstChild`、`lastChild`、`previousSibling`和`nextSibling`属性从一个节点到另一个节点遍历DOM树。
- en: 'The `parentNode` property returns a node''s parent node. The parent node is
    a node in the DOM tree that the node is a descendent of. The parent node will
    always exist unless `parentNode` is called on the document node. Since the document
    node is at the top of the DOM tree, it has no parent, and the call to `parentNode`
    will return null. The DOM tree can be climbed with the `parentNode` property.
    An example of `parentNode` is shown in the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`parentNode`属性返回节点的父节点。父节点是DOM树中的一个节点，该节点是其后代。父节点始终存在，除非在文档节点上调用`parentNode`。由于文档节点位于DOM树的顶部，它没有父节点，调用`parentNode`将返回null。可以使用`parentNode`属性遍历DOM树。以下示例显示了`parentNode`的用法：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 3.7: Parent node'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.7：父节点
- en: 'The `nextSibling` and `previousSibling` properties are to get a node''s siblings
    in the DOM tree. `previousSibling` will return the previous sibling in the DOM
    tree (the sibling added to the parent node before the current node) and `nextSibling`
    will return the next sibling in the DOM tree (the sibling node added to the parent
    node after the current node). When DOM trees are drawn, the node''s previous sibling
    is usually shown to the left and the next sibling is usually shown on the right.
    The DOM tree can be traversed laterally with the `nextSibling` and `previousSibling`
    functions. These properties are shown in the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextSibling`和`previousSibling`属性用于获取DOM树中节点的兄弟节点。`previousSibling`将返回DOM树中的前一个兄弟节点（添加到当前节点之前的父节点的兄弟节点），`nextSibling`将返回DOM树中的下一个兄弟节点（添加到当前节点之后的父节点的兄弟节点）。在绘制DOM树时，通常将节点的前一个兄弟节点显示在左侧，下一个兄弟节点显示在右侧。可以使用`nextSibling`和`previousSibling`函数横向遍历DOM树。以下示例显示了这些属性：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 3.8: Traversing sibling nodes'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.8：遍历兄弟节点
- en: 'The three last properties are for navigating to a node''s child node; they
    are `childNodes`, `firstChild`, and `lastChild`. The `childNodes` property returns
    a live `NodeList` of the child nodes of an element. The `firstChild` and `lastChild`
    properties return the first or last node from the child `NodeList` respectively.
    The use of these properties is shown in the following snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个属性用于导航到节点的子节点；它们是`childNodes`，`firstChild`和`lastChild`。`childNodes`属性返回元素的子节点的实时`NodeList`。`firstChild`和`lastChild`属性分别返回子`NodeList`中的第一个或最后一个节点。以下片段显示了这些属性的使用：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 3.9: Traversing sibling nodes'
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.9：遍历兄弟节点
- en: Traversing the DOM
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历DOM
- en: 'The DOM tree navigation properties are summarized in the following table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: DOM树导航属性总结如下表：
- en: '![Figure 3.4: DOM tree navigation properties](image/Figure_3.4.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：DOM树导航属性](image/Figure_3.4.jpg)'
- en: 'Figure 3.4: DOM tree navigation properties'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：DOM树导航属性
- en: DOM Manipulation
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM操作
- en: When you write an app or web page, one of the most powerful tools you have is
    manipulating the document structure in some way. This is done through DOM manipulation
    functions, for controlling the HTML and styling the app or page. Being able to
    manipulate the HTML document while the user uses an app or website allows us to
    dynamically change parts of the page without fully reloading the content. For
    example, when you use a messaging app on your cell phone, the app's code is manipulating
    the document you're looking at. Every time you send a message, it updates the
    document to append the elements and styling that makes up the message. There are
    three basic ways we can manipulate the DOM. We can add elements or nodes, remove
    elements or nodes, and update elements or nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写应用程序或网页时，您拥有的最强大的工具之一是以某种方式操纵文档结构。这是通过DOM操作函数来完成的，用于控制HTML并为应用程序或页面设置样式。能够在用户使用应用程序或网站时操纵HTML文档，使我们能够动态更改页面的部分而无需完全重新加载内容。例如，当您在手机上使用消息应用时，应用的代码正在操纵您正在查看的文档。每次发送消息时，它都会更新文档以附加构成消息的元素和样式。我们可以操纵DOM的三种基本方式。我们可以添加元素或节点，删除元素或节点，以及更新元素或节点。
- en: Adding new elements to the DOM tree is a must-have for interactive applications.
    There are many examples in most of the web applications you use. Both Google's
    Gmail and Microsoft's Skype actively add elements to the DOM as you use the application.
    There are two steps to adding a new element to the DOM. First, we must create
    a node for the element we want to add, and then we must add the new node to the
    DOM tree.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 向DOM树添加新元素是交互应用程序的必备功能。在您使用的大多数Web应用程序中都有许多示例。谷歌的Gmail和微软的Skype在您使用应用程序时都会主动向DOM添加元素。向DOM添加新元素有两个步骤。首先，我们必须为要添加的元素创建一个节点，然后我们必须将新节点添加到DOM树中。
- en: 'To create a new element or node, we can use the `document.createElement(),`
    `Node.cloneNode()`, and `document.createTextNode()` functions. `CreateElement`
    is called on the global document object and takes in two arguments. The first
    is `tagName`. **tagName** is a string that specifies the type of element to be
    created. If we want to create a new div element, we would pass the `div` string
    in through `tagName`. The second argument is an optional argument called options.
    Options is an `ElementCreationObject` that contains a single property, named ''is''.
    This property allows us to specify if the element being added is a custom element.
    We will not be using this property, but it is important to know what it is used
    for. `CreateElement` returns a newly created Element object. The syntax and usage
    of `document.createElement()` are shown in the following snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新元素或节点，我们可以使用`document.createElement()`、`Node.cloneNode()`和`document.createTextNode()`函数。`CreateElement`是在全局文档对象上调用的，并接受两个参数。第一个是`tagName`。**tagName**是一个字符串，指定要创建的元素类型。如果我们想要创建一个新的div元素，我们将通过`tagName`传递`div`字符串。第二个参数是一个可选参数，称为options。Options是一个包含单个属性的`ElementCreationObject`，名为'is'。此属性允许我们指定要添加的元素是否是自定义元素。我们将不使用此属性，但知道它的用途很重要。`CreateElement`返回一个新创建的Element对象。`document.createElement()`的语法和用法如下片段所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 3.10: Using document.createElement'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.10：使用document.createElement
- en: A new element node can also be created with the `cloneNode` function. `cloneNode`
    is called on a DOM node object and duplicates the node that it is called on. It
    takes in one argument, a Boolean called `deep`, and returns a copy of the node
    to clone. If `deep` is set to `false`, `cloneNode` will do a shallow clone and
    only clone the node that it was called on. If `deep` is set to `true`, `cloneNode`
    will do a deep copy and copy the node and all of its child nodes (the node's full
    DOM tree). Cloning a node copies all of its attributes and their values. This
    includes event listeners that are added inline in the HTML, but not listeners
    added through JavaScript with `addEventListener`, or those assigned with element
    properties.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 新的元素节点也可以使用`cloneNode`函数创建。`cloneNode`是在DOM节点对象上调用的，并复制调用它的节点。它接受一个名为`deep`的布尔值作为参数，并返回要克隆的节点的副本。如果`deep`设置为`false`，`cloneNode`将进行浅克隆，只克隆调用它的节点。如果`deep`设置为`true`，`cloneNode`将进行深度复制，并复制节点及其所有子节点（节点的完整DOM树）。克隆节点会复制其所有属性及其值。这包括在HTML中内联添加的事件监听器，但不包括通过`addEventListener`用JavaScript添加的监听器，或者通过元素属性分配的监听器。
- en: 'The following is an example of `cloneNode`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`cloneNode`的示例：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 3.11: Cloning a node'
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.11：克隆节点
- en: In the preceding example, we created a document with two divs, `div1` and `div2`.
    `div2` is nested inside of `div1`. In the preceding code, we selected `div1` by
    its id and cloned it into `div1Clone` by doing a shallow `nodeClone`. We then
    did a deep `nodeClone` and cloned `div1` and its nested child, `div2`, into `div1Div2Clone`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个包含两个div的文档，`div1`和`div2`。`div2`嵌套在`div1`中。在前面的代码中，我们通过id选择了`div1`，并通过浅`nodeClone`将其克隆到`div1Clone`中。然后我们进行了深度`nodeClone`，并将`div1`及其嵌套的子元素`div2`克隆到`div1Div2Clone`中。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`cloneNode` may lead to duplicate element ids in a document. If you copy a
    node with an id, you should update that node''s id property to something unique.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloneNode`可能会导致文档中出现重复的元素id。如果复制具有id的节点，则应更新该节点的id属性为唯一值。'
- en: The spec for DOM has been updated recently. In the DOM4 specification, deep
    was an optional parameter for `cloneNode`. If omitted, the method would default
    the value to true, using deep cloning as the default behavior. To create a shallow
    clone, deep must be set to false. In the latest DOM spec, this behavior has been
    changed. Deep is still an optional parameter; however, it defaults to false. We
    recommend always providing the deep parameter for backward and forward compatibility.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 的规范最近已经更新。在 DOM4 规范中，`cloneNode` 的 `deep` 是一个可选参数。如果省略，该方法将默认将值设置为 true，使用深克隆作为默认行为。要创建浅克隆，必须将
    `deep` 设置为 false。在最新的 DOM 规范中，此行为已更改。`deep` 仍然是一个可选参数；但是，默认值为 false。我们建议始终提供 `deep`
    参数以实现向后和向前兼容性。
- en: '`CreateTextNode` is used to create text-only nodes. Text-only DOM nodes are
    used when filling the page with text. We use `createTextNode` to place new text
    in an element like a div. `CreateTextNode` takes in one argument, a string called
    `data`, and returns a text node. An example of `createTextNode` is shown in the
    following snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateTextNode` 用于创建仅包含文本的节点。当用文本填充页面时，会使用仅包含文本的 DOM 节点。我们使用 `createTextNode`
    将新文本放入像 div 这样的元素中。`CreateTextNode` 接受一个参数，一个名为 `data` 的字符串，并返回一个文本节点。`createTextNode`
    的示例如下所示：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Snippet 3.12: Creating a text node'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段 3.12：创建文本节点
- en: 'Now that we know how to create new DOM nodes, we must add the new nodes to
    the DOM tree to see changes in our application. We can add new nodes with two
    functions: `Node.appendChild()` and `Node.insertBefore()`. Both functions are
    called on a DOM node object.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建新的 DOM 节点，我们必须将新节点添加到 DOM 树中，以便在应用程序中看到更改。我们可以使用两个函数添加新节点：`Node.appendChild()`
    和 `Node.insertBefore()`。这两个函数都是在 DOM 节点对象上调用的。
- en: '`Node.appendChild` adds a node to the end of the child list of the node it
    is called on. `Node.appendChild` takes in one argument, `aChild`, and returns
    the appended child. The `aChild` argument is the node that we want to append to
    the parent node''s child list. If `appendChild` is passed in a node that already
    exists in the DOM tree, the node is moved from its current position to the new
    position in the DOM, as a child of the specified parent node. If `appendChild`
    is passed a `DocumentFragment`, the entire content of the `DocumentFragment` is
    moved into the child list of the parent node, and an empty Document Fragment is
    returned. The syntax and use of `appendChild` are shown in the following snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.appendChild` 将节点添加到其调用的节点的子节点列表的末尾。`Node.appendChild` 接受一个参数 `aChild`，并返回附加的子节点。`aChild`
    参数是我们要附加到父节点的子节点列表的节点。如果 `appendChild` 传入的是已经存在于 DOM 树中的节点，该节点将从当前位置移动到 DOM 中的新位置，作为指定父节点的子节点。如果
    `appendChild` 传入的是 `DocumentFragment`，则 `DocumentFragment` 的整个内容将移动到父节点的子节点列表中，并返回一个空的
    Document Fragment。`appendChild` 的语法和用法如下所示：'
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Snippet 3.13: Inserting a node with appendChild'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段 3.13：使用 appendChild 插入节点
- en: Note
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A `DocumentFragment` is simply a DOM tree that does not have a parent.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentFragment` 只是一个没有父节点的 DOM 树。'
- en: In the preceding example, we created an HTML document with a div, `div1`. We
    then created a new div, `div2`, and then appended it to the `div1` child list
    with the `appendChild` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个带有 div `div1` 的 HTML 文档。然后我们创建了一个新的 div `div2`，然后使用 `appendChild`
    函数将其附加到 `div1` 的子列表中。
- en: A node can also be inserted into the DOM with the `Node.insertBefore()` function.
    The `insertBefore` function inserts a node into the child list of the node it
    is called on, in front of a specified reference node. The `insertBefore` function
    takes in two parameters, `newNode` and `referenceNode`, and returns the inserted
    node. The `newNode` parameter represents the node that we are inserting. The `referenceNode`
    parameter is a node from the parent's child node list or the value `null`. If
    `referenceNode` is a node from the parent's child list, `newNode` will be inserted
    in front of that node, but if `referenceNode` is the value `null`, `newNode` will
    be inserted at the end of the parent's child node list. Much like `Node.appendChild()`,
    if the function is given a node to insert that is already in the DOM tree, the
    node will be removed from its old position in the DOM tree and placed in its new
    position as a child of the parent node. `InsertBefore` can also insert an entire
    `DocumentFragment`. If `newNode` is a `DocumentFragment`, the function will return
    an empty `DocumentFragment`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 节点还可以使用 `Node.insertBefore()` 函数插入到 DOM 中。`insertBefore` 函数将节点插入到其调用的节点的子节点列表中，位于指定的参考节点之前。`insertBefore`
    函数接受两个参数，`newNode` 和 `referenceNode`，并返回插入的节点。`newNode` 参数表示我们要插入的节点。`referenceNode`
    参数是父节点的子节点列表中的一个节点或值 `null`。如果 `referenceNode` 是父节点子列表中的一个节点，`newNode` 将插入到该节点之前，但如果
    `referenceNode` 是值 `null`，`newNode` 将插入到父节点的子节点列表的末尾。与 `Node.appendChild()` 类似，如果函数给定要插入的节点已经在
    DOM 树中，该节点将从其在 DOM 树中的旧位置中移除，并作为父节点的子节点放置在新位置。`InsertBefore` 还可以插入整个 `DocumentFragment`。如果
    `newNode` 是 `DocumentFragment`，函数将返回一个空的 `DocumentFragment`。
- en: 'An example of `appendChild` is shown in the following snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendChild` 的示例如下所示：'
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Snippet 3.14: Inserting a node with insertBefore'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段 3.14：使用 insertBefore 插入节点
- en: In the preceding example, we created a div, `div1`, with a nested child div,
    `div2`. In the script, we got `div1` and `div2` by element id. We then created
    two new divs, `div3` and `div4`. We inserted `div3` into div1's child list. We
    passed `div2` as the reference node, so `div3` is inserted in front of `div2`
    in div1's child list. We then inserted `div4` into the `div1` child list. We passed
    in null as the reference node. This causes `div4` to be appended to the end of
    the div1 child list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个带有嵌套子 div `div2` 的 div `div1`。在脚本中，我们通过元素 id 获取了 `div1` 和 `div2`。然后我们创建了两个新的
    div，`div3` 和 `div4`。我们将 `div3` 插入到 `div1` 的子列表中。我们将 `div2` 作为参考节点传递，因此 `div3`
    被插入到 `div1` 的子列表中 `div2` 的前面。然后我们将 `div4` 插入到 `div1` 的子列表中。我们将 null 作为参考节点传递。这会导致
    `div4` 被追加到 `div1` 的子列表的末尾。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `referenceNode` parameter is not an optional parameter. You must explicitly
    pass in a node or the value null. Different browsers and browser versions interpret
    invalid values differently and app functionality may be compromised.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`referenceNode`参数不是可选参数。你必须明确传入一个节点或值null。不同的浏览器和浏览器版本对无效值的解释不同，应用功能可能会受到影响。'
- en: Another key functionality of manipulating the DOM is the ability to remove DOM
    nodes from the DOM tree. This functionality can be seen in Gmail and Facebook.
    When you delete an email in Gmail or remove a Facebook post, the DOM element associated
    with that email or post is being removed from the DOM tree. DOM node removal is
    done with the `Node.removeChild()` function. `RemoveChild` removes the specified
    child from the parent node it is called from. It takes in one argument, child,
    and returns the child DOM node removed. The child argument must be a child in
    the parent node's child list. If the child element is not a child of the parent
    node, an exception will be thrown.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 操作DOM的另一个关键功能是能够从DOM树中删除DOM节点。这个功能可以在Gmail和Facebook中看到。当你在Gmail中删除一封邮件或删除Facebook的帖子时，与该邮件或帖子相关的DOM元素将从DOM树中删除。DOM节点的移除是通过`Node.removeChild()`函数完成的。`RemoveChild`从其被调用的父节点中移除指定的子节点。它接受一个参数child，并返回被移除的子DOM节点。child参数必须是父节点的子节点列表中的一个子节点。如果子元素不是父节点的子节点，将抛出异常。
- en: 'An example of the `removeChild` functionality is shown in the following snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段展示了`removeChild`功能的示例：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Snippet 3.15: Removing a node from the DOM'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.15：从DOM中删除节点
- en: In the preceding example, we created a div, `div1`, with a nested child div,
    `div2`. In the script, we get both divs by element id, then remove `div2` from
    the `div1` child list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个div，`div1`，带有一个嵌套的子div，`div2`。在脚本中，我们通过元素id获取了两个div，然后从`div1`的子节点列表中移除了`div2`。
- en: 'Now that we can add and remove nodes from the DOM, it would be very useful
    to be able to modify nodes that already exist. Nodes can be updated in the following
    ways:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向DOM添加和删除节点，修改已经存在的节点将非常有用。节点可以通过以下方式进行更新：
- en: Replacing the node
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换节点
- en: Changing the inner HTML
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改内部HTML
- en: Changing attributes
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改属性
- en: Changing the class
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改类
- en: Changing the style
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改样式
- en: Updating Nodes in the DOM
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新DOM中的节点
- en: The first way to modify a DOM node is by replacing it entirely with a new DOM
    node. A DOM node can have any of its children replaced with the `Node.replaceChild()`
    function. `ReplaceChild` replaces one child of the parent node and it is called
    on with a new specified node. It takes in two arguments, `newChild` and `oldChild`,
    and returns the replaced node (`oldChild`). The `oldChild` parameter is the node
    in the parent's child list that will be replaced and the `newChild` parameter
    is the node that will replace `oldChild`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 修改DOM节点的第一种方法是完全用新的DOM节点替换它。DOM节点可以使用`Node.replaceChild()`函数替换任何一个子节点。`ReplaceChild`替换父节点的一个子节点，并用一个新指定的节点调用它。它接受两个参数，`newChild`和`oldChild`，并返回被替换的节点（`oldChild`）。`oldChild`参数是将被替换的父节点子节点列表中的节点，`newChild`参数是将替换`oldChild`的节点。
- en: 'An example of this is shown in the following snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段展示了这个示例：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Snippet 3.16: Replacing nodes in the DOM'
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.16：替换DOM中的节点
- en: In the preceding example, we created two divs, `div1` and `div2`. `Div1` is
    created with a nested child div, `div2`. In the script, we get each div by its
    element id. We then replace the `div1` child, `div2`, with `div3`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了两个div，`div1`和`div2`。`Div1`创建了一个嵌套的子div，`div2`。在脚本中，我们通过元素id获取每个div。然后我们用`div3`替换了`div1`的子元素`div2`。
- en: 'The second way to manipulate a DOM node is by changing the node''s inner HTML.
    The node''s `innerHTML` property can be used to get or set the HTML or XML markup
    contained in the element. The property can be used to change the current HTML
    code of the element''s children. It can be used to update or overwrite anything
    below the element in the DOM tree. To insert HTML into the node, set the `innerHTML`
    parameter equal to a string containing the HTML, elements you want to add. The
    string passed into the parameter is parsed as HTML and new DOM nodes are created;
    they''re then added as children to the parent node the property was referenced
    from. An example of the `innerHTML` property is shown in the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作DOM节点的第二种方法是通过更改节点的内部HTML。节点的`innerHTML`属性可用于获取或设置元素中包含的HTML或XML标记。该属性可用于更改元素子元素中的当前HTML代码。它可以用于更新或覆盖DOM树中元素下方的任何内容。要将HTML插入节点，将`innerHTML`参数设置为包含要添加的HTML元素的字符串。传递到参数中的字符串将被解析为HTML，并创建新的DOM节点；然后将它们作为子节点添加到引用该属性的父节点中。下面的片段展示了`innerHTML`属性的示例：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Snippet 3.17: Replacing the innerHTML of a node'
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.17：替换节点的innerHTML
- en: Note
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the value of `innerHTML` completely overwrites the old value. DOM nodes
    will be removed and replaced with the new nodes that have been parsed from the
    HTML string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`innerHTML`的值会完全覆盖旧值。DOM节点将被移除，并用从HTML字符串解析出的新节点替换。
- en: For security reasons, `innerHTML` will not parse and execute script contained
    in `<script>` tags inside of the HTML string. There are, however, other ways to
    execute JavaScript through the `innerHTML` property. You should never use `innerHTML`
    to append string data you have no control over.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，`innerHTML`不会解析和执行HTML字符串中`<script>`标签内包含的脚本。然而，还有其他方法可以通过`innerHTML`属性执行JavaScript。你永远不应该使用`innerHTML`来追加你无法控制的字符串数据。
- en: 'The third way to manipulate an element node is by changing the node''s attributes.
    Element node attributes can be interacted with through three functions: `Element.getAttribute()`,
    `Element.setAttribute()`, and `Element.removeAttribute()`. All three of these
    functions must be called on an element node.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 操作元素节点的第三种方法是通过更改节点的属性。元素节点属性可以通过三个函数进行交互：`Element.getAttribute()`、`Element.setAttribute()`和`Element.removeAttribute()`。这三个函数都必须在元素节点上调用。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some attributes applied to element nodes have special meanings. Be careful
    when adding or removing attributes. A list of HTML attributes is shown here: [https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于元素节点的一些属性具有特殊的含义。在添加或移除属性时要小心。HTML属性列表如下所示：[https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)。
- en: The `getAttribute` function takes in one parameter, the name of the attribute,
    and returns the value of the specified attribute. If the attribute does not exist,
    the function will return null or the empty string (""). Modern DOM specifications
    state that the function should return the value null and most browsers follow
    this specification, but some browsers still follow the old DOM3 specification,
    which states that the correct return value should be the empty string. It is important
    to handle both cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAttribute`函数接受一个参数，即属性的名称，并返回指定属性的值。如果属性不存在，函数将返回null或空字符串("")。现代DOM规范规定该函数应返回null的值，大多数浏览器遵循这一规范，但一些浏览器仍遵循旧的DOM3规范，该规范规定正确的返回值应为空字符串。重要的是要处理这两种情况。'
- en: The `setAttribute` function is used to set or update the value of the specified
    attribute. It takes in two parameters, **name** and **value**, and does not return
    any value. The `name` parameter is the name of the attribute that will be set.
    The `value` parameter is the string value that the attribute will be set to. If
    the value passed in is not a string, it will be converted in to a string before
    being set. Since the value is converted in to a string, setting an attribute to
    an object or null will not have the expected value. The attribute will get set
    to the stringified version of the value that's passed in.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAttribute`函数用于设置或更新指定属性的值。它接受两个参数，**name**和**value**，并不返回任何值。`name`参数是要设置的属性的名称。`value`参数是要设置的属性的字符串值。如果传入的值不是字符串，它将在设置之前转换为字符串。由于值被转换为字符串，将属性设置为对象或null将不会得到预期的值。属性将被设置为传入值的字符串化版本。'
- en: 'The `removeAttribute` function removes the specified attribute from the node.
    It takes in a single parameter, `attrName`, and returns no value. The `attrName`
    parameter is the name of the attribute to be removed. You can use `removeAttribute`
    instead of attempting to set an attribute''s value to null with `setAttribute`.
    An example of `getAttribute`, `setAttribute`, and `removeAttribute` is shown in
    the following snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAttribute`函数从节点中移除指定的属性。它接受一个参数`attrName`，并不返回任何值。`attrName`参数是要移除的属性的名称。您可以使用`removeAttribute`来代替尝试使用`setAttribute`将属性的值设置为null。下面的片段中展示了`getAttribute`、`setAttribute`和`removeAttribute`的示例：'
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Snippet 3.18: Getting, setting, and removing attributes'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.18：获取、设置和移除属性
- en: In the preceding example, we create a div called `div1`. We then get that div
    by its id, add the `testName` attribute, and set its value to `testValue`. We
    then get the value of `testName` and remove it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个名为`div1`的div。然后我们通过其id获取该div，添加`testName`属性，并将其值设置为`testValue`。然后我们获取`testName`的值并将其移除。
- en: The fourth way to manipulate a node is by changing its class information. Element
    class information is used to associate similar HTML elements for styling and grouping
    purposes. An element's class can be accessed in two ways, the `className` property
    or the `classList` property. The `className` property returns a string containing
    all of the element's class information. This property can be used to get or set
    the class value. The `classList` property returns a live `DOMTokenList` object.
    This object is simply a live list of the current class information with special
    methods for getting and updating class information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 操作节点的第四种方式是通过更改其类信息。元素类信息用于关联类似的HTML元素以进行样式和分组。可以通过两种方式访问元素的类，即`className`属性或`classList`属性。`className`属性返回一个包含所有元素类信息的字符串。该属性可用于获取或设置类值。`classList`属性返回一个实时的`DOMTokenList`对象。这个对象只是当前类信息的实时列表，具有特殊的方法用于获取和更新类信息。
- en: Updating Nodes in the DOM
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新DOM中的节点
- en: 'The `classList` object has six helper functions. They are detailed in the following
    table:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`classList`对象有六个辅助函数。它们在下表中详细说明：'
- en: '![Figure 3.5: Helper functions'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：辅助函数'
- en: '](image/Figure_3.5.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.5.jpg)'
- en: 'Figure 3.5: Helper functions'
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：辅助函数
- en: 'These helper functions are used in the following snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些辅助函数在下面的片段中使用：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Snippet 3.19: Using the classList object'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.19：使用classList对象
- en: 'The fifth and final way we typically modify a node is through the style object.
    The style object reflects the node''s CSS styling, and every element node has
    a style object. The style object can be obtained through `Element.style`. The
    style object contains properties for each CSS style that can be assigned to the
    object. This object is meant to be read-only, so element style should not be set
    directly by overwriting the style object. Instead, we should change the individual
    properties of the style object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常修改节点的第五种和最后一种方式是通过样式对象。样式对象反映了节点的CSS样式，每个元素节点都有一个样式对象。样式对象可以通过`Element.style`获得。样式对象包含了可以分配给对象的每个CSS样式的属性。这个对象是只读的，所以不应该直接通过覆盖样式对象来设置元素样式。相反，我们应该改变样式对象的各个属性：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Snippet 3.20: Using the classList object'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.20：使用classList对象
- en: Note
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A list of all of the available style properties can be found online at [https://www.w3schools.com/jsref/dom_obj_style.asp](https://www.w3schools.com/jsref/dom_obj_style.asp).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.w3schools.com/jsref/dom_obj_style.asp](https://www.w3schools.com/jsref/dom_obj_style.asp)上找到所有可用样式属性的列表。
- en: DOM manipulation is one of the most important parts of a web page. The DOM can
    be manipulated by finding, adding, removing, and updating the nodes in the tree.
    We can find a DOM node in several ways—by unique id, by class, or by CSS query
    selector. Once we have found a DOM node, we can traverse the DOM tree by stepping
    to that element's child, sibling, or parent nodes. To add new elements to the
    DOM tree, we must first create a new element node, then append that element somewhere
    in the DOM. To remove an element, we simply get the node for the element we want
    to remove and then call the node remove function. To update a node, we can change
    any of its properties, attributes, or flat out replace the node. DOM manipulation
    allows us to build dynamic web pages and it is important to master it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DOM操作是网页的最重要部分之一。DOM可以通过查找、添加、删除和更新树中的节点来进行操作。我们可以通过唯一的id、类或CSS查询选择器等多种方式找到DOM节点。一旦找到了DOM节点，我们可以通过移动到该元素的子节点、同级节点或父节点来遍历DOM树。要向DOM树中添加新元素，我们必须首先创建一个新的元素节点，然后将该元素附加到DOM中的某个位置。要删除一个元素，我们只需获取要删除的元素的节点，然后调用节点的删除函数。要更新一个节点，我们可以更改其属性、属性或直接替换节点。DOM操作允许我们构建动态网页，这一点非常重要。
- en: '**Conclusion**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Web documents built from HTML code are represented by the Document Object Model,
    or DOM. The DOM is a tree-like structure built from nodes. Each node corresponds
    to an element in the HTML source. As programmers, we can interact with the DOM
    to dynamically updated web pages. We can interact with the DOM by finding, creating,
    removing, and updating element nodes. Combining all of these concepts allows us
    to create dynamic web pages that can update the view based on user interaction.
    This kind of functionality can be seen on nearly every website, including Amazon,
    Facebook, and Google.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTML代码构建的Web文档由文档对象模型（DOM）表示。DOM是从节点构建的类似树的结构。每个节点对应HTML源代码中的一个元素。作为程序员，我们可以与DOM交互，动态更新网页。我们可以通过查找、创建、删除和更新元素节点与DOM进行交互。结合所有这些概念，我们可以创建可以根据用户交互更新视图的动态网页。几乎每个网站都可以看到这种功能，包括亚马逊、Facebook和Google。
- en: 'Exercise 21: DOM Manipulation'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：DOM操作
- en: Your team is building an email website. The site needs to load the user's email
    data from a JSON file and dynamically populate a table with the email data that's
    loaded. The emails are provided in the example code file. The email table should
    show the **From**, **To**, and **Subject** fields and have a row for each email.
    Use the emails object to build the email table in the DOM through the DOM manipulation
    you learned about in this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队正在构建一个电子邮件网站。该网站需要从JSON文件中加载用户的电子邮件数据，并动态填充加载的电子邮件数据的表格。电子邮件在示例代码文件中提供。电子邮件表应显示**发件人**、**收件人**和**主题**字段，并为每封电子邮件创建一行。使用电子邮件对象通过本章学习的DOM操作来构建DOM中的电子邮件表。
- en: 'To build an email list with JavaScript using DOM manipulation techniques, perform
    the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DOM操作技术构建JavaScript的电子邮件列表，执行以下步骤：
- en: Open the file called **exercise** from **/exercises/exercise21/exercise.html.**
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开名为**exercise**的文件，路径为**/exercises/exercise21/exercise.html**。
- en: In the `script` tag, at the bottom of the file, write the JavaScript code (under
    *Code*, at the end of this exercise).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部的`script`标签中，编写JavaScript代码（在*Code*下，本练习的末尾）。
- en: Make a new table element (`<table>`) and save it into a variable called `table`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的表元素(`<table>`)并将其保存到一个名为`table`的变量中。
- en: Create a new scope block with curly braces (`{}`).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大括号(`{}`)创建一个新的作用域块。
- en: Create an array to hold the header types **To**, **From**, and **Subject**.
    Save the array into the variable headers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个数组来保存表头类型**To**、**From**和**Subject**。将数组保存到变量`headers`中。
- en: Create a table row element (`<tr>`) and save it into the variable row. Loop
    through the headers array with a `forEach` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表行元素(`<tr>`)并将其保存在变量`row`中。使用`forEach`函数循环遍历`headers`数组。
- en: 'Inside the callback of `forEach`, do the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`forEach`的回调函数中，执行以下操作：
- en: Create the table header element (`<th>`) and save it into the `header` variable.
    Using `appendChild()`, append a new text node to `header`. The text node should
    contain the `header` name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表头元素(`<th>`)并将其保存到`header`变量中。使用`appendChild()`，将一个新的文本节点附加到`header`。文本节点应包含`header`名称。
- en: Append the header element stored in `header` as a child to the table row stored
    in `row`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在`header`中的表头元素作为子元素附加到存储在`row`中的表行中。
- en: 'Append the table row stored in `row` as a child to the table stored in `table`.
    The output is shown in the following figure:![Figure 3.6: Step 4 output](image/Figure_3.6.jpg)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储在`row`中的表行作为子元素附加到存储在`table`中的表中。输出如下图所示：![图3.6：步骤4输出](image/Figure_3.6.jpg)
- en: 'Figure 3.6: Step 4 output'
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：步骤4输出
- en: Create a new scope block with curly braces (`{}`).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大括号(`{}`)创建一个新的作用域块。
- en: 'Loop over the data array, `data`, with a `forEach` loop and do the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`循环遍历数据数组`data`，并执行以下操作：
- en: Create a new table row element (`<tr>`) and save it in the `row` variable. Create
    another new table data element (`<td>`) and save it in the `to` variable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的表行元素(`<tr>`)并将其保存在`row`变量中。创建另一个新的表数据元素(`<td>`)并将其保存在`to`变量中。
- en: Next, create two more table data elements (`<td>` and `<td>`) and save them
    as variables (`subject` and `from)`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另外两个表数据元素(`<td>`和`<td>`)，并将它们保存为变量（`subject`和`from）。
- en: Append a text node to the table data element stored in `to` that contains the
    `forEach` loop's data object's `to` value. Append another text node to the table
    data element stored in `from` that contains the `forEach` loop's data object's
    `from` value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个文本节点附加到存储在`to`中的表数据元素，该文本节点包含`forEach`循环的数据对象的`to`值。将另一个文本节点附加到存储在`from`中的表数据元素，该文本节点包含`forEach`循环的数据对象的`from`值。
- en: Append a text node to the table data element stored in `subject` that contains
    the `forEach` loop's data object's `subject` value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个文本节点附加到存储在`subject`中的表数据元素，该文本节点包含`forEach`循环的数据对象的`subject`值。
- en: Append the element stored in `to` to the table row stored in `row`. Append the
    element stored in `from` to the table row stored in `row`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在`to`中的元素附加到存储在`row`中的表行。将存储在`from`中的元素附加到存储在`row`中的表行。
- en: Append the element stored in `subject` to the table row stored in `row`. Append
    the row stored in `row` to the table stored in `table`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在`subject`中的元素附加到存储在`row`中的表行。将存储在`row`中的行附加到存储在`table`中的表。
- en: Get the `emailTableHolder` DOM node and append the table stored in the `table`
    variable as a child node.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`emailTableHolder` DOM节点，并将存储在`table`变量中的表作为子节点附加。
- en: 'Load the HTML file in a web browser to view the results:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中加载HTML文件以查看结果。
- en: '![Figure 3.7: Final output'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7：最终输出'
- en: '](image/Figure_3.7.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.7.jpg)'
- en: 'Figure 3.7: Final output'
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：最终输出
- en: '**Code**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: solution.html
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: solution.html
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Snippet 3.21: DOM manipulation to create an email list'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 'Snippet 3.21: 使用DOM操作创建电子邮件列表'
- en: https://bit.ly/2FmvdK1
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2FmvdK1
- en: '**Outcome**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: You have successfully analyzed DOM manipulation techniques.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功分析了DOM操作技术。
- en: DOM Events and Event Objects
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件和事件对象
- en: DOM events are the backbone of functional and responsive web applications. Events
    are used in any website that has any form of user interaction. Websites such as
    Facebook, Google, and Skype all heavily make use of events. An event is a signal
    that tells the programmer that something has happened to a DOM node. An event
    can be fired for nearly any reason. We can use JavaScript to listen for events
    and run functions when an event occurs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: DOM事件是功能性和响应式Web应用程序的基础。事件在任何具有任何形式用户交互的网站中使用。Facebook、Google和Skype等网站都大量使用事件。事件是告诉程序员有关DOM节点发生了某事的信号。几乎可以出于任何原因触发事件。我们可以使用JavaScript来监听事件，并在事件发生时运行函数。
- en: DOM Event
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM事件
- en: A **DOM event** is a notification sent by a DOM node to let the programmer know
    that something has happened to the DOM node. This can be anything from a user
    clicking on an element or pressing a key on the keyboard to video playback ending.
    There are a lot of events that can be fired. Every event that can be fired can
    have an event listener attached to it. An event listener is an interface that
    waits for an event to fire and then calls an event handler. An event handler is
    code that is run in response to an event. Event handlers are JavaScript functions
    that we, as programmers, assign to an event. This is called registering an event
    handler.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM事件**是由DOM节点发送的通知，以通知程序员DOM节点发生了某事。这可以是用户单击元素、在键盘上按键或视频播放结束等任何事情。可以触发许多事件。可以为触发的每个事件附加事件侦听器。事件侦听器是等待事件触发然后调用事件处理程序的接口。事件处理程序是响应事件运行的代码。事件处理程序是我们作为程序员分配给事件的JavaScript函数。这称为注册事件处理程序。'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete list of events can be found here: [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处找到完整的事件列表：[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)。
- en: The best way to add an event handler is with the `addEventListener` function.
    The `addEventListener` function sets up the specified event handler to be called
    when an event of the specified type fires. The function takes in three parameters,
    **type**, **listener**, and either **options** or **useCapture**. The first argument,
    type, is the case-sensitive event type to listen for. The second argument, listener,
    is the object that can receive a notification, usually a JavaScript function.
    The options and **useCapture** parameters are optional and you may only provide
    one of them. The options argument specifies an options objects with the **capture**,
    **once**, and **passive** properties. In the options argument, the property named
    'capture' is a Boolean indicating that events will be dispatched to the event
    handler before they are pushed to the DOM tree. The property named 'once' is a
    Boolean that indicates whether the event handler should be removed after it has
    been called once. The property named 'passive' is a Boolean that indicates that
    event handler will never call the `preventDefault` function (discussed in the
    handling events subtopic). The useCapture parameter functions the same way as
    the `options.capture` property.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加事件处理程序的最佳方法是使用`addEventListener`函数。`addEventListener`函数设置指定的事件处理程序在指定类型的事件触发时被调用。该函数接受三个参数，**type**，**listener**，以及**options**或**useCapture**。第一个参数type是要监听的区分大小写的事件类型。第二个参数listener是可以接收通知的对象，通常是JavaScript函数。选项和**useCapture**参数是可选的，您只能提供其中之一。选项参数指定具有**capture**、**once**和**passive**属性的选项对象。在选项参数中，名为'capture'的属性是一个布尔值，指示事件将在推送到DOM树之前分派给事件处理程序。名为'once'的属性是一个布尔值，指示事件处理程序在调用一次后是否应该被移除。名为'passive'的属性是一个布尔值，指示事件处理程序永远不会调用`preventDefault`函数（在处理事件子主题中讨论）。useCapture参数的功能与`options.capture`属性相同。
- en: Event Listeners
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件侦听器
- en: '**Event listeners** can be attached to any DOM node. To attach an event listener,
    we must select the node that needs to listen to the event, and then we can call
    the `addEventListener` function on that node. This is shown in the following snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件侦听器**可以附加到任何DOM节点。要附加事件侦听器，我们必须选择需要监听事件的节点，然后我们可以在该节点上调用`addEventListener`函数。如下面的代码片段所示：'
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Snippet 3.22: Getting, setting, and removing attributes'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 'Snippet 3.22: 获取、设置和移除属性'
- en: In the preceding example, we created a button with the id `button1`. In the
    script, we selected that button and added an event listener. The event listener
    listens for click events. When a click event happens, it calls the handler function,
    which logs to the console.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个ID为`button1`的按钮。在脚本中，我们选择了该按钮并添加了一个事件侦听器。事件侦听器监听点击事件。当发生点击事件时，它调用处理程序函数，该函数记录到控制台。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You may see inline event handlers in HTML code, for example, `<button onclick="alert(
    'Hello! ')">Press me</button>`. You should not do this. It is best practice to
    keep JavaScript and HTML separate. When you mix HTML and JavaScript, the code
    can quickly become unmanageable, inefficient, and harder to parse and interpret.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在HTML代码中看到内联事件处理程序，例如，`<button onclick="alert('Hello!')">Press me</button>`。您不应该这样做。最佳做法是保持JavaScript和HTML分开。当您混合HTML和JavaScript时，代码很快就会变得难以管理、低效，并且更难解析和解释。
- en: 'At a later time, if we decide we no longer want an event listener, we can remove
    it with the `removeEventListener` function. The `removeEventListener` function
    removes the specified handler function from the specified event type. It takes
    the same parameters as `addEventListener`. To properly remove an event listener,
    `removeEventListener` must match it with a listener that''s been added. `RemoveEventListener`
    looks for a listener that has the same type, listener function, and capture option.
    If a match is found, then the event listener is removed. An example of `removeEventListener`
    is shown in the following snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的时间，如果我们决定不再需要事件监听器，我们可以使用`removeEventListener`函数将其移除。`removeEventListener`函数从指定的事件类型中移除指定的处理程序函数。它接受与`addEventListener`相同的参数。要正确地移除事件监听器，`removeEventListener`必须与添加的监听器匹配。`removeEventListener`会查找具有相同类型、监听器函数和捕获选项的监听器。如果找到匹配项，则移除事件监听器。以下是`removeEventListener`的示例：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Snippet 3.23: Getting, setting, and removing attributes'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.23：获取、设置和删除属性
- en: In the preceding example, we created a button with the id `button1`. In the
    script, we get that button by its id by adding add an event listener for the click
    event. We then remove that same listener, providing the exact same parameters
    we provided to the `addEventListener` function, so that `removeEventListener`
    can properly match the listener that we want to remove.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个带有id `button1`的按钮。在脚本中，我们通过添加单击事件的事件监听器来获取该按钮。然后，我们移除相同的监听器，提供与`addEventListener`函数提供的完全相同的参数，以便`removeEventListener`可以正确匹配我们要移除的监听器。
- en: Event Objects and Handling Events
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件对象和处理事件
- en: 'Every event handler function takes in a single parameter. This is the event
    object. You will often see this parameter defined as `event`, `evt`, or simply
    `e`. It is automatically passed to the event handler to provide information about
    the event. The event handler can leverage the information in the event object
    to manipulate the DOM and allow the user to interact with the page:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件处理程序函数都接受一个参数。这是事件对象。您经常会看到此参数被定义为`event`、`evt`或简单地`e`。它会自动传递给事件处理程序，以提供有关事件的信息。事件处理程序可以利用事件对象中的信息来操作DOM，并允许用户与页面交互：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Snippet 3.24: Using an event handler to manipulate the DOM'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.24：使用事件处理程序操作DOM
- en: 'A new instance of an event object can be created by calling a new instance
    of the event class (`new Event()`). The constructor takes in two arguments: **type**
    and **options**. Type is the type of the event and options is an optional object
    containing the following fields: **bubbles**, **cancelable**, and **composed**.
    All three of these fields are also optional. The bubbles property indicates whether
    the event should bubble. The `cancelable` property indicates whether the event
    can be canceled. The composed property indicates whether the event should trigger
    listeners outside of a shadow root. All three default to false.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用事件类的新实例（`new Event()`）来创建事件对象的新实例。构造函数接受两个参数：**type**和**options**。类型是事件的类型，选项是一个可选对象，包含以下字段：**bubbles**、**cancelable**和**composed**。这三个字段也都是可选的。bubbles属性指示事件是否应该冒泡。`cancelable`属性指示事件是否可以被取消。composed属性指示事件是否应该触发阴影根之外的监听器。这三个默认值都为false。
- en: The event object has many useful properties and functions. These properties
    can be leveraged to gain additional information about the event. For example,
    we can use the `Event.target` property to obtain the DOM node that the event was
    originally fired from, or we can use `Event.type` to see the name of the event.
    `Event.target` is very useful when you want to use the same handler for multiple
    elements. Instead of having a new handler function for each event, we can reuse
    a handler and simply use `Event.target` to check which element fired the event.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象具有许多有用的属性和函数。这些属性可以被利用来获取有关事件的附加信息。例如，我们可以使用`Event.target`属性来获取最初触发事件的DOM节点，或者我们可以使用`Event.type`来查看事件的名称。当您希望为多个元素使用相同的处理程序时，`Event.target`非常有用。我们可以重用处理程序，只需使用`Event.target`来检查哪个元素触发了事件，而不是为每个事件创建一个新的处理程序函数。
- en: When an event is fired from a DOM element, it notifies the event listeners attached
    to the DOM node. The event then propagates, or bubbles, up the DOM tree to each
    parent node, until it reaches the top of the tree. This effect is called event
    propagation or event bubbling. It allows us make our code more efficient by reducing
    the number of event listeners required in the page. If we have an element with
    many child elements that all require the same user interaction, we could add a
    single event listener to the parent element and catch any event that bubbles up
    from the child nodes. This is called event delegation. Instead of attaching a
    listener to each child node, we delegate the event handing to the parent node.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当从DOM元素触发事件时，它会通知附加到DOM节点的事件监听器。然后，事件会传播或冒泡，直到达到树的顶部为止。这种效果称为事件传播或事件冒泡。它允许我们通过减少页面中所需的事件监听器数量来使我们的代码更加高效。如果我们有一个具有许多子元素的元素，它们都需要相同的用户交互，我们可以将单个事件监听器添加到父元素，并捕获从子节点冒泡上来的任何事件。这称为事件委托。我们委托事件处理给父节点，而不是将监听器附加到每个子节点。
- en: Event Propagation
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件传播
- en: Event propagation can be controlled with the `stopPropagation` function. This
    function is one of the many functions in the event object. `StopPropagation` takes
    in no arguments. When it is called, it prevents further propagation of the current
    event. This means that it fully captures the event and prevents it from bubbling
    upwards to any other parent nodes. Stopping an event's propagation can be very
    useful if we are using delegation, or if we have event listeners on child and
    parent nodes that listen to the same event but do different tasks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 事件传播可以通过`stopPropagation`函数进行控制。这个函数是事件对象中的许多函数之一。`StopPropagation`不带任何参数。当调用它时，它会阻止当前事件的进一步传播。这意味着它完全捕获了事件，并阻止它向上冒泡到任何其他父节点。停止事件传播在使用委派时或者在子节点和父节点上有监听同一事件但执行不同任务时非常有用。
- en: Firing Events
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发事件
- en: Standard DOM events are fired automatically by the browser. JavaScript gives
    us two very powerful tools that allow us to have even more control over how events
    in our page are fired. The first tool is firing events through JavaScript. The
    second is custom events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 标准DOM事件由浏览器自动触发。JavaScript为我们提供了两个非常强大的工具，允许我们更多地控制页面中事件的触发。第一个工具是通过JavaScript触发事件。第二个是自定义事件。
- en: 'We learned earlier in this chapter that we can create new instances of the
    event object. A lone event is not very useful if we cannot fire the event and
    have the DOM tree be notified that something happened. DOM nodes have a member
    function, `dispatchEvent()`, that allows us to fire, or dispatch, instances of
    the event object. `DispatchEvent()` should be called on the DOM node that you
    want the event node to be fired from. It takes in a single argument and returns
    a Boolean value. This argument is the event object that will be fired on the target
    DOM node. The `DispatchEvent()` boolean return value will be false if the event
    is cancelable and one of the event handlers that handled the event was called
    `Event.preventDefault()`. Otherwise, `dispatchEvent()` will return true. An example
    of `dispatchEvent()` is shown in the following snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们学到可以创建事件对象的新实例。如果我们不能触发事件并使DOM树知道发生了什么，单独的事件就不是很有用。DOM节点有一个成员函数`dispatchEvent()`，允许我们触发或分发事件对象的实例。`DispatchEvent()`应该在您希望从事件节点触发的DOM节点上调用。它接受一个参数并返回一个布尔值。这个参数是将在目标DOM节点上触发的事件对象。如果事件是可取消的并且处理事件的一个事件处理程序被调用`Event.preventDefault()`，`DispatchEvent()`的布尔返回值将为false。否则，`dispatchEvent()`将返回true。以下是`dispatchEvent()`的示例：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Snippet 3.26: Firing an event'
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.26：触发事件
- en: The `dispatchEvent` method will throw an `UNSPECIFIED_EVENT_TYPE_ERR` error
    if the event's type is not specified properly. This means that if an event's type
    is null or an empty string, or the event was not initialized before `dispatchEvent()`
    is called, a runtime error will be thrown.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件的类型没有正确指定，`dispatchEvent`方法将抛出`UNSPECIFIED_EVENT_TYPE_ERR`错误。这意味着如果事件的类型为null或空字符串，或者在调用`dispatchEvent()`之前未初始化事件，则会抛出运行时错误。
- en: It is important to note that events fired with `dispatchEvent()` do not get
    called asynchronously via the event loop. Normal events that are fired by DOM
    nodes call the event handlers asynchronously via the event loop. When `dispatchEvent()`
    is used, the event handlers get invoked synchronously. All applicable event handlers
    are executed and return before the code continues with the code after the `dispatchEvent`
    call. Other events could be blocked if there are many event handlers for that
    event, or if one of the event handlers does a lot of synchronous work.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用`dispatchEvent()`触发的事件不会通过事件循环异步调用。由DOM节点触发的正常事件会通过事件循环异步调用事件处理程序。当使用`dispatchEvent()`时，事件处理程序会同步调用。所有适用的事件处理程序都会在代码继续执行`dispatchEvent`调用后执行并返回。如果有许多事件处理程序或者其中一个事件处理程序做了大量同步工作，其他事件可能会被阻塞。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Some browsers implement the `fireEvent()` function for firing events on DOM
    nodes. This function is a non-standard function that will not work on most browsers.
    Do not use this method in production code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器实现了`fireEvent()`函数，用于在DOM节点上触发事件。这个函数是一个非标准函数，在大多数浏览器上不起作用。不要在生产代码中使用这种方法。
- en: 'Exercise 22: Handling Your First Event'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习22：处理您的第一个事件
- en: 'To set up an event listener and catch an event fired, perform the following
    steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置事件侦听器并捕获触发的事件，请执行以下步骤：
- en: Create an HTML file with a `body` tag.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`body`标签的HTML文件。
- en: Inside the `body` tag, create a button with the text `Click Me!` in it and the
    id `button1`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`标签内，创建一个文本为“点击我！”的按钮，并将其id设置为`button1`。
- en: Add a `script` tag after the button.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮后添加一个`script`标签。
- en: In the `script` tag, select the button by id and save it into the `button1`
    variable.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script`标签中，通过id选择按钮并将其保存到`button1`变量中。
- en: Add an event listener for the `click` event to the element stored in `button1`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为存储在`button1`中的元素添加`click`事件的事件侦听器。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The callback should call the alert function and alert the browser with the `clicked!`
    string.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 回调应调用警报函数并用“点击！”字符串警报浏览器。
- en: '**Code**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.html
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.html
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snippet 3.25: DOM event handling'
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.25：DOM事件处理
- en: https://bit.ly/2M0Bcp5
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2M0Bcp5
- en: '**Outcome**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 3.8: Step 2 Click me! button'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图3.8：步骤2点击我！按钮'
- en: '](image/Figure_3.8.png)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.8.png)'
- en: 'Figure 3.8: Step 2 Click me! button'
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.8：步骤2点击我！按钮
- en: '![Figure 3.9: Output view'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：输出视图'
- en: '](image/Figure_3.9.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.9.jpg)'
- en: 'Figure 3.9: Output view'
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.9：输出视图
- en: You have successfully set up an event listener and caught an event that fired.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功设置了事件侦听器并捕获了触发的事件。
- en: Custom Events
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'JavaScript also allows for the creation of custom events. Custom events are
    a way to fire events and listen for events with a custom type. The type of the
    event can be any non-empty string. The most basic way to create a custom event
    is by initializing a new instance of the event object with the event type as the
    custom event name. This is done with the following syntax: `const event = new
    Event( ''myCustomEvent'' )`. Creating an event like this does not allow you to
    add any custom information or properties to the event. To create a custom event
    with additional information, we can use the `CustomEvent` class. The `CustomEvent`
    class constructor takes in two arguments. The first argument is a string that
    represents the type name of the custom event we want to create. The second argument
    is an object that represents the custom event initialization options. It accepts
    the same fields as the options passed into the event class initializer, with the
    addition of a field called `detail`. The detail field defaults to null and is
    an event-dependent value associated with the event. Any information we want passed
    in to our custom event can be passed in through the detail parameter. The data
    in this parameter is also passed to all of the handlers that listen for the custom
    event.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还允许创建自定义事件。自定义事件是一种触发事件和监听具有自定义类型的事件的方式。事件的类型可以是任何非空字符串。创建自定义事件的最基本方式是使用事件类型作为自定义事件名称初始化事件对象的新实例。这是通过以下语法完成的：`const
    event = new Event( 'myCustomEvent' )`。像这样创建事件不允许向事件添加任何自定义信息或属性。要创建带有附加信息的自定义事件，我们可以使用`CustomEvent`类。`CustomEvent`类构造函数接受两个参数。第一个参数是表示我们要创建的自定义事件的类型名称的字符串。第二个参数是表示自定义事件初始化选项的对象。它接受与传递给事件类初始化器的选项相同的字段，另外还有一个名为`detail`的字段。详细字段默认为null，是与事件相关的与事件关联的值。我们想要传递给自定义事件的任何信息都可以通过详细参数传递。此参数中的数据也传递给所有监听自定义事件的处理程序。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The event constructor works will all modern browsers except for Internet Explorer.
    For full compatibility with IE, you must use the `createEvent()` and `initEvent()`
    methods discussed later, or use a `polyfill` to simulate the `CustomEvent` class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 事件构造函数适用于所有现代浏览器，除了Internet Explorer。为了与IE完全兼容，必须使用稍后讨论的`createEvent()`和`initEvent()`方法，或者使用`polyfill`来模拟`CustomEvent`类。
- en: To maximize code browser compatibility, we must also discuss the `initEvent()`
    and `createEvent()` methods for creating custom events. These methods are deprecated
    and have been removed from the web standard. Some browsers, however, still support
    these functions. To create a custom event in an older browser, you must first
    create the event with `var event = document.createEvent( 'Event' )` (we must use
    `var` instead of `const` in old browsers) and then initialize the new event with
    `event.initEvent()`. `CreateEvent()` takes in a single argument, type. This is
    the type of event object that will be created. This type must be one of the standard
    JavaScript event types, such as `Event`, `MouseEvent`, and so on. `InitEvent()`
    takes in three arguments. The first argument is a string that represents the type
    name of the event. For example, a click event's type is **click**. The second
    argument is a Boolean that represents the event's bubble behavior. The third argument
    is a Boolean that represents the event's cancelable behavior. These two behaviors
    were discussed in the *Event Objects and Handling Events* section of this topic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高代码浏览器兼容性，我们还必须讨论用于创建自定义事件的`initEvent()`和`createEvent()`方法。这些方法已被弃用并从Web标准中删除。但是，一些浏览器仍然支持这些功能。要在旧版浏览器中创建自定义事件，必须首先使用`var
    event = document.createEvent( 'Event' )`创建事件（在旧版浏览器中必须使用`var`而不是`const`），然后使用`event.initEvent()`初始化新事件。`CreateEvent()`接受一个参数，类型。这是将要创建的事件对象的类型。此类型必须是标准JavaScript事件类型之一，例如`Event`、`MouseEvent`等。`InitEvent()`接受三个参数。第一个参数是表示事件类型名称的字符串。例如，点击事件的类型是**click**。第二个参数是表示事件冒泡行为的布尔值。第三个参数是表示事件可取消行为的布尔值。这两种行为在本主题的*事件对象和处理事件*部分中进行了讨论。
- en: To catch and handle custom events, we can use the standard event listener behaviors.
    All we need to do is attach an event listener with `addEventListener()` that listens
    for the custom event type that's been added. For example, if we create a `CustomEvent`
    with the event type `myEvent`, all we need to do to listen for that event is add
    an event listener on that type with `addEventListener( 'myEvent', e => {} )`.
    Whenever an event with the type `myEvent` is fired, the added event listener callback
    will be called.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获和处理自定义事件，我们可以使用标准的事件监听器行为。我们所需要做的就是使用`addEventListener()`附加一个监听自定义事件类型的事件监听器。例如，如果我们创建了一个事件类型为`myEvent`的`CustomEvent`，我们只需要添加一个事件监听器来监听这个类型，使用`addEventListener(
    'myEvent', e => {} )`。每当类型为`myEvent`的事件被触发时，添加的事件监听器回调函数将被调用。
- en: 'When the event listener callback is called, the event parameter in the callback
    will have an additional field, `detail`. This field will contain the information
    passed in to the custom event through the `detail` field of the custom event options
    object. Any information that''s relevant to the custom event should be passed
    through the `detail` object. An example of the detail object is shown in the following
    snippet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用事件监听器回调时，回调中的事件参数将具有一个额外的字段`detail`。此字段将包含通过自定义事件选项对象的`detail`字段传递给自定义事件的信息。与自定义事件相关的任何信息都应通过`detail`对象传递。详细对象的示例如下所示：
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Snippet 3.27: Firing a custom event with data in the detail'
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.27：在详细信息中触发自定义事件
- en: 'Exercise 23: Handling and Delegating Events'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习23：处理和委托事件
- en: You are building a shopping list page to help busy shoppers manage shopping
    lists without pencil and paper. Our shopping list application will be a page with
    a table, a text input, and an add row button. The add row button will add a new
    row to the shopping list table. The rows that are added have the shopping list
    item (text from the text input) and a remove button. The remove button will remove
    that row from the shopping list table.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在构建一个购物清单页面，以帮助忙碌的购物者管理购物清单，而无需纸和笔。我们的购物清单应用程序将是一个带有表、文本输入和添加行按钮的页面。添加行按钮将在购物清单表中添加新行。添加的行包含购物清单项目（来自文本输入的文本）和一个删除按钮。删除按钮将从购物清单表中删除该行。
- en: 'The following steps will build the app:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将构建应用程序：
- en: Open the starter file at **exercises/exercise23/exercise.html**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**exercises/exercise23/exercise.html**中打开起始文件。
- en: In the HTML `body`, in the `userInteractionHolder` `div`, add a text input and
    a button.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML `body`中的`userInteractionHolder` `div`中，添加一个文本输入和一个按钮。
- en: Give the button the id `addButton`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 给按钮添加id`addButton`。
- en: Add a table element with the id `shoppingList` to the `div` with the id `shoppingListHolder`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 向具有id`shoppingList`的`div`添加一个表元素。
- en: Add a row to the table created in the previous step (`id = "shoppingList"`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 向在上一步创建的表（`id="shoppingList"`）中添加一行。
- en: Add two header items to the table, one with the text `Item` and one with the
    text `Remove`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 向表添加两个标题项，一个带有文本`Item`，另一个带有文本`Remove`。
- en: '![Figure 3.10: Output After stpe 2](image/Figure_3.10.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10：第2步后的输出](image/Figure_3.10.jpg)'
- en: 'Figure 3.10: Output After step 2'
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.10：第2步后的输出
- en: 'In the `script` tag, select the button by its id and add a click listener that
    calls the `_addRow` function. Create the `_addRow` function with the following
    functionality:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script`标签中，通过其id选择按钮，并添加一个点击监听器，调用`_addRow`函数。创建`_addRow`函数，具有以下功能：
- en: Take in one parameter, `e`, which is the event object. Get the text input with
    DOM traversal using the `previousSibling` property on the event target. Save the
    text input element node to a variable, `inputBox`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个参数`e`，即事件对象。使用DOM遍历，使用事件目标上的`previousSibling`属性获取文本输入。将文本输入元素节点保存到变量`inputBox`中。
- en: Save the value of the text in the `inputBox` to the `value` variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本框中的值保存到`value`变量中。
- en: Clear the value of the text area by setting it to the empty string (`""`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其设置为空字符串（""）来清除文本区域的值。
- en: Create a table row element and save it in the `row` variable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表行元素，并将其保存在`row`变量中。
- en: Use DOM manipulation and chaining to append a table data element to the table
    row. Append a text node to the table data element.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DOM操作和链接将表数据元素附加到表行。将文本节点附加到表数据元素。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The text node should contain the value that's stored in `value`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 文本节点应包含存储在`value`中的值。
- en: Use DOM manipulation and chaining to append table data to the table row.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用DOM操作和链接将表数据附加到表行。
- en: Append a button to the table data element.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮附加到表数据元素。
- en: Append the text `remove` to the button.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本`remove`附加到按钮上。
- en: Navigate back up to the button element.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到按钮元素。
- en: Add a listener to the button and have it call the `_removeRow` function.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加监听器，并让它调用`_removeRow`函数。
- en: Select the `shopingList` table and append the row to it.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`shopingList`表，并将行附加到其中。
- en: 'Create the `_removeRow`  function with the following functionality:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`_removeRow`函数，具有以下功能：
- en: Take in an argument, `e` that will contain the event object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个参数`e`，其中将包含事件对象。
- en: Get the row element, that the button click occurred in with DOM traversal, and
    the `parentNode` property. Log the row element.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DOM遍历，获取发生按钮点击的行元素，并使用`parentNode`属性。记录行元素。
- en: 'Using DOM traversal and chaining, get the table that contains the row, and
    then remove the row from the table:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DOM遍历和链接，获取包含行的表，然后从表中删除行：
- en: '![Figure 3.11: Final output](image/Figure_3.11.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：最终输出](image/Figure_3.11.jpg)'
- en: 'Figure 3.11: Final output'
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.11：最终输出
- en: '**Code**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: solution.html
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: solution.html
- en: '[PRE27]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Snippet 3.28: DOM manipulation and event handling to build a shopping list
    app'
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.28：使用DOM操作和事件处理构建购物清单应用程序
- en: https://bit.ly/2D1c3rC
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2D1c3rC
- en: '**Outcome**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: You have successfully applied event handling concepts to build a useful web
    app.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功应用事件处理概念来构建一个有用的Web应用程序。
- en: JQuery
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: '**jQuery** is a lightweight JavaScript library that''s designed to simplify
    DOM interaction. It is one of the most popular libraries used in web development.
    jQuery is designed to simplify calls to the DOM and to make code more streamlined.
    In this topic, we will outline what jQuery is, how to install jQuery in a project,
    jQuery basics, using jQuery for DOM manipulation, and handling events with jQuery.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个轻量级的JavaScript库，旨在简化DOM交互。它是在Web开发中使用最广泛的库之一。jQuery旨在简化对DOM的调用，并使代码更加流畅。在这个主题中，我们将概述jQuery是什么，如何在项目中安装jQuery，jQuery基础知识，使用jQuery进行DOM操作以及使用jQuery处理事件。
- en: jQuery is a library that's designed to make DOM traversal, manipulation, event
    handling, animation, and AJAX requests simpler to use and to make code that uses
    those elements more streamlined. jQuery is an extensive JavaScript library. A
    strong grasp of JavaScript is essential for harnessing all of the power of jQuery.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个旨在使DOM遍历、操作、事件处理、动画和AJAX请求更简单使用，并使使用这些元素的代码更加流畅的库。jQuery是一个广泛的JavaScript库。对JavaScript的深入理解对于发挥jQuery的所有功能至关重要。
- en: jQuery provides an easy to use API that has extensive cross browser compatibility.
    jQuery implements what they call "current " browser support. This simply means
    that JQuery will run and is supported on a browser's current release version and
    previous release (v23.x and 22.x, but not v21.x). Code may run successfully on
    older browser versions, but bug fixes to jQuery will not be pushed for any bugs
    that appear with older browser versions. jQuery browser compatibility also extends
    to stock mobile browsers on Android and IOS devices.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一个易于使用的API，具有广泛的跨浏览器兼容性。jQuery实现了他们所谓的“当前”浏览器支持。这只是意味着JQuery将在浏览器的当前发布版本和上一个发布版本（v23.x和22.x，但不是v21.x）上运行并得到支持。代码可能会在旧的浏览器版本上成功运行，但对于出现在旧的浏览器版本中的任何错误，JQuery的错误修复将不会被推送。jQuery浏览器兼容性还延伸到Android和IOS设备上的原生移动浏览器。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The full documentation can be found on the official JQuery web page: [https:// jquery.com/](https://jquery.com/).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文档可以在官方JQuery网页上找到：[https:// jquery.com/](https://jquery.com/)。
- en: The first way to install jQuery is to download the source JavaScript files directly.
    The files can be found at [http://code.jquery.com](http://code.jquery.com). The
    JavaScript files can be added directly to a project's file structure. You should
    use the minified version in production code due to the smaller file size.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 安装jQuery的第一种方法是直接下载源JavaScript文件。这些文件可以在[http://code.jquery.com](http://code.jquery.com)找到。JavaScript文件可以直接添加到项目的文件结构中。由于文件大小较小，应在生产代码中使用缩小版本。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Code minification** is the process of removing unnecessary characters from
    source code without changing its functionality. Minification is done to reduce
    the size of the code file. This is important for JavaScript, HTML, and CSS files
    as it reduces the resources required to send and load web pages.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码缩小**是从源代码中删除不必要字符而不改变其功能的过程。缩小是为了减小代码文件的大小。这对JavaScript、HTML和CSS文件很重要，因为它减少了发送和加载网页所需的资源。'
- en: 'The second way to install JQuery is by using a package manager. The most popular
    command-line package managers for this are NPM, Yarn, and Bower. NPM will be discussed
    in more detail in the final chapter of this book. To install jQuery with one of
    these CLI (Command-Line Interface) package managers, first install and configure
    the relevant package manager. To install with NPM, run the following line: `npm
    install jquery`. This will place the jQuery files in the `node_modules` folder
    under `node_modules/jquery/dist/`. To install with Yarn, use the following command:
    `yarn add jquery`. To install with Bower, use the following command: `bower install
    jquery`. Installing with Bower will place the files in the `bower_components`
    folder under `bower_components/jquery/dist/`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 安装JQuery的第二种方法是使用包管理器。用于此目的的最流行的命令行包管理器是NPM、Yarn和Bower。本书的最后一章将更详细地讨论NPM。要使用这些CLI（命令行界面）包管理器之一安装jQuery，首先安装和配置相关的包管理器。要使用NPM安装，运行以下命令：`npm
    install jquery`。这将把jQuery文件放在`node_modules/jquery/dist/`文件夹下的`node_modules`文件夹中。要使用Yarn安装，使用以下命令：`yarn
    add jquery`。要使用Bower安装，使用以下命令：`bower install jquery`。使用Bower安装将把文件放在`bower_components/jquery/dist/`文件夹下的`bower_components`文件夹中。
- en: Once JQuery has been installed, we are ready to start load jQuery into our project.
    This is as simple as adding a script tag to the HTML file. In the main HTML file,
    simply add a script tag with the source being the jQuery library file `(<script
    src="path/to/jquey.js"></script>`). JQuery is now installed and ready to be used
    in the project!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了JQuery，我们就可以开始将jQuery加载到我们的项目中。这只需要在HTML文件中添加一个脚本标签即可。在主HTML文件中，只需添加一个带有jQuery库文件路径的脚本标签（<script
    src="path/to/jquey.js"></script>）。JQuery现在已安装并准备好在项目中使用！
- en: jQuery Basics
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery基础
- en: JQuery is a library built around selecting and working with DOM nodes. All of
    the JQuery operations, by default, are available under both the library name `jQuery`
    and the shortcut variable `$`. We will call all JQuery functions by referencing
    the shortcut variable.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery是围绕选择和处理DOM节点构建的库。默认情况下，所有JQuery操作都可以在库名称`jQuery`和快捷变量`$`下使用。我们将通过引用快捷变量来调用所有JQuery函数。
- en: When creating or selecting DOM nodes, jQuery always returns an instance of the
    JQuery object. The JQuery object is an array-like collection that contains a zero
    indexed sequence of DOM elements, some familiar array functions and properties,
    and all the built-in JQuery methods. It is important to note two things about
    the JQuery object. First, JQuery objects are not live objects. The contents of
    the JQuery object will not update as the DOM tree changes. If the DOM has changed,
    the JQuery object can be updated by rerunning the same JQuery selector. Second,
    JQuery objects are also not equal. An equality comparison between two JQuery objects
    that are built with the same query will not be truthy. To compare JQuery objects,
    you must inspect the elements contained inside the collection.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建或选择DOM节点时，jQuery始终返回一个JQuery对象的实例。JQuery对象是一个类似数组的集合，其中包含零索引序列的DOM元素、一些熟悉的数组函数和属性，以及所有内置的JQuery方法。关于JQuery对象有两点很重要。首先，JQuery对象不是活动对象。JQuery对象的内容不会随着DOM树的更改而更新。如果DOM已更改，可以通过重新运行相同的JQuery选择器来更新JQuery对象。其次，JQuery对象也不相等。使用相同查询构建的两个JQuery对象之间的相等比较将不会是真值。要比较JQuery对象，必须检查集合中包含的元素。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Zero indexed means that the object has numeric properties that can be used to
    reference the items from the items sequence (0, 1, 2, …, n).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 零索引意味着对象具有可以用来引用项目序列中的项目的数字属性（0、1、2、…、n）。
- en: The JQuery object is not an array. Built-in array properties and functions may
    not exist on the JQuery object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery对象不是数组。JQuery对象上可能不存在内置数组属性和函数。
- en: jQuery Selector
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery选择器
- en: 'The core functionality of JQuery revolves around selecting and manipulating
    DOM elements. This is done with the jQuery core selector. To select DOM elements,
    we call the jQuery selector function `jQuery( selector )`, or `$( selector )`
    for short. The selector passed in to the jQuery function can take nearly any valid
    CSS selector, a callback function, or an HTML string. If a CSS selector is passed
    in to the JQuery selector, a collection of matched elements will be returned in
    a JQuery object. If the selector passed in is a HTML string, a collection of nodes
    will be created from the provided HTML string. If a callback function is passed
    in to the selector function, the callback will be run when the DOM has finished
    loading. jQuery can also accept a DOM node and create a JQuery object from that.
    If a DOM node is passed into the jQuery selector function, that node will be automatically
    selected and returned in a JQuery collection. An example of the JQuery selector
    function is shown in the following snippet:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery的核心功能围绕选择和操作DOM元素展开。这是通过jQuery核心选择器来实现的。要选择DOM元素，我们调用jQuery选择器函数`jQuery(
    selector )`，或者简写为`$( selector )`。传递给jQuery函数的选择器几乎可以是任何有效的CSS选择器、回调函数或HTML字符串。如果传递给JQuery选择器的是CSS选择器，将返回一个匹配元素的集合，这些元素将在一个JQuery对象中返回。如果传递给选择器的是HTML字符串，将从提供的HTML字符串创建一个节点集合。如果传递给选择器函数的是回调函数，当DOM加载完成时将运行回调。jQuery还可以接受一个DOM节点，并从中创建一个JQuery对象。如果将DOM节点传递给jQuery选择器函数，该节点将自动被选择并返回到一个JQuery集合中。下面的片段展示了JQuery选择器函数的一个示例：
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Snippet 3.29: Selecting DOM nodes'
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.29：选择DOM节点
- en: Most jQuery functions operate on a selection of DOM nodes (`$()`); however,
    JQuery also offers a set of functions that do not. These are referenced directly
    through the $ variable. The distinction between the two can be confusing for new
    jQuery users. The easiest way to remember this difference is to note that functions
    in the `$` namespace are generally utility methods and do not work with selections.
    There are cases where the selector methods and the core utility methods have the
    same name, for example, `$.each()` and `$().each()`. When reading the jQuery documentation
    and learning new functions, be sure that you are exploring the correct function.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数jQuery函数都是在一组DOM节点（`$()`）上操作的；然而，jQuery也提供了一组不是这样的函数。这些函数直接通过$变量引用。这两者之间的区别对于新的jQuery用户来说可能会令人困惑。记住这个区别最简单的方法是注意到`$`命名空间中的函数通常是实用方法，不适用于选择。有些情况下，选择器方法和核心实用方法具有相同的名称，例如`$.each()`和`$().each()`。在阅读jQuery文档和学习新函数时，一定要确保你正在探索正确的函数。
- en: An HTML page's DOM cannot be safely manipulated until the base DOM structure
    has been created. JQuery offers a way to safely wait until the DOM is ready before
    running any code. This is done with the `ready()` JQuery object function. This
    function should be called on a jQuery object containing the HTML document ( `$(
    document ).ready()` ). The `ready()` function take in a single argument, a callback
    function. This function is run once the DOM is ready. Code that manipulates the
    DOM should be put in this callback function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基本DOM结构之前，HTML页面的DOM不能安全地进行操作。JQuery提供了一种安全等待DOM准备就绪的方法。这是通过`ready()` JQuery对象函数来实现的。这个函数应该在包含HTML文档的jQuery对象上调用（`$(
    document ).ready()`）。`ready()`函数接受一个参数，一个回调函数。一旦DOM准备就绪，这个函数就会运行。操作DOM的代码应该放在这个回调函数中。
- en: 'When working with multiple libraries in JavaScript, namespace conflicts can
    always be a concern. jQuery and all of its plugins and functionality are contained
    within the `jQuery` namespace. Because of this, there should not be a conflict
    between jQuery and any other library. There is one caveat, however, jQuery, by
    default, uses the `$` as a shortcut for the jQuery namespace. If you are using
    another library that uses the `$` variable, there could be conflicts with jQuery.
    To avoid this, you can put JQuery in no-conflict mode. To do this, call the `noConflict()`
    function on the jQuery namespace (`jQuery.noConflict()`). This will turn on no-conflict
    mode and allow you to assign the jQuery library a new shortcut variable name.
    The variable name can be anything you like, from `$` to `mySuperAwesomeJQuery`.
    A full example of enabling no-conflict mode and changing the jQuery shortcut variable
    name is shown in the following snippet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中使用多个库时，命名空间冲突总是一个问题。jQuery及其所有插件和功能都包含在`jQuery`命名空间中。因此，jQuery和任何其他库之间不应该有冲突。然而，有一个例外，jQuery默认使用`$`作为jQuery命名空间的快捷方式。如果你使用另一个使用`$`变量的库，可能会与jQuery发生冲突。为了避免这种情况，你可以将jQuery置于无冲突模式。要做到这一点，调用jQuery命名空间上的`noConflict()`函数（`jQuery.noConflict()`）。这将打开无冲突模式，并允许你为jQuery库分配一个新的快捷变量名。变量名可以是任何你喜欢的，从`$`到`mySuperAwesomeJQuery`。启用无冲突模式并更改jQuery快捷变量名的完整示例如下片段所示：
- en: '[PRE29]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Snippet 3.30: Enabling no-conflict mode'
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.30：启用无冲突模式
- en: jQuery DOM Manipulation
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery DOM操作
- en: JQuery is built around DOM manipulation. Here, we will cover the very basics
    of JQuery DOM manipulation. We will start by selecting elements, then move on
    to traversing and manipulating the DOM, and we will end with chaining.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery是围绕DOM操作构建的。在这里，我们将介绍JQuery DOM操作的基础知识。我们将从选择元素开始，然后转向遍历和操作DOM，最后以链式操作结束。
- en: Selecting Elements
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择元素
- en: 'The first step in DOM manipulation is always selecting the DOM nodes you''re
    going to work with. JQuery''s most basic concept is "select some elements and
    do something with them." jQuery makes selecting elements very easy with the selector
    function`: $()`. selector. jQuery supports most CSS3 selectors for selecting nodes.
    The simplest ways to select elements are by id, by class name, by attribute, and
    by CSS.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: DOM操作的第一步始终是选择要处理的DOM节点。JQuery最基本的概念是“选择一些元素并对其进行操作”。jQuery通过选择器函数`$()`非常容易地选择元素。jQuery支持大多数CSS3选择器来选择节点。选择元素的最简单方法是通过id、类名、属性和CSS来选择元素。
- en: 'Selecting an element by id is done by passing the CSS element id selector into
    the jQuery selector function: `$( ''#elementId'' )`. This will return a JQuery
    object that contains an element matching that id. Selecting by class name is done
    just like selecting by id. Pass the CSS class name selector into the jQuery selector
    function: `$( ''.className'' )`. This will return a jQuery object that contains
    all of the elements that match that class name. Selecting elements by attribute
    is done by passing the attribute CSS selector into the jQuery selector function:
    `$( "div[attribute-name=''example'']" )`. This will return a JQuery object that
    contains all of the elements that match the specified element type and attribute
    name/value. jQuery also supports more complicated selectors. You can pass in compound
    CSS selectors, comma-separated lists of selectors, and pseudo-selectors such as
    `:visible`. These selectors all return JQuery objects that contain the elements
    that match.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将CSS元素id选择器传递给jQuery选择器函数来选择元素：`$( '#elementId' )`。这将返回一个包含匹配该id的元素的JQuery对象。通过类名选择与通过id选择的方式相同。将CSS类名选择器传递给jQuery选择器函数：`$(
    '.className' )`。这将返回一个包含所有匹配该类名的元素的jQuery对象。通过属性选择元素是通过将属性CSS选择器传递给jQuery选择器函数来完成的：`$(
    "div[attribute-name='example']" )`。这将返回一个包含所有匹配指定元素类型和属性名称/值的元素的JQuery对象。jQuery还支持更复杂的选择器。您可以传递复合CSS选择器、逗号分隔的选择器列表和伪选择器，如`:visible`。这些选择器都返回包含匹配元素的JQuery对象。
- en: Note
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If a jQuery selector does not match any nodes, it still returns a JQuery object.
    The JQuery object will have no nodes in the collection and the length property
    of the object will be equal to zero. If you are checking to see if a selector
    found nodes, you must check on the length property, not on the truthiness of the
    JQuery object.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果jQuery选择器没有匹配任何节点，它仍然会返回一个JQuery对象。JQuery对象的集合中将没有节点，并且对象的长度属性将等于零。如果要检查选择器是否找到节点，必须检查长度属性，而不是JQuery对象的真实性。
- en: Once you have gotten a selection of nodes, JQuery object functions can be used
    to filter and refine the selection. Some of the simple functions that are very
    useful are `has()`, `not()`, `filter()`, `first()`, and `eq()`. All of these functions
    take in a selector and return a JQuery object with a filtered set of nodes. The
    `has()` function filters the list to contain elements whose descendants match
    the CSS selector that's provided to `has()`. The `not()` function filters the
    JQuery object's nodes to only contain nodes that do not match the provided CSS
    selector. The `filter()` function filters the nodes to only show nodes that match
    the provided CSS selector. `First()` returns the first node in the JQuery object's
    internal node list. The `eq()` function returns a JQuery object containing the
    node at that index. Complete, in-depth documentation on these methods and other
    filtering methods can be found on the JQuery website.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了一些节点，就可以使用JQuery对象函数来过滤和细化选择。一些非常有用的简单函数包括`has()`、`not()`、`filter()`、`first()`和`eq()`。所有这些函数都接受一个选择器，并返回一个带有过滤节点集的JQuery对象。`has()`函数将列表过滤为包含其后代与提供给`has()`的CSS选择器匹配的元素。`not()`函数将JQuery对象的节点过滤为仅包含不匹配提供的CSS选择器的节点。`filter()`函数将节点过滤为仅显示与提供的CSS选择器匹配的节点。`first()`返回JQuery对象内部节点列表中的第一个节点。`eq()`函数返回一个包含该索引处节点的JQuery对象。这些方法的完整深入文档以及其他过滤方法可以在JQuery网站上找到。
- en: Traversing the DOM
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历DOM
- en: 'Once nodes have been selected with jQuery selectors, we can traverse the DOM
    to find more elements. DOM nodes can be traversed in three directions: to the
    parent nodes, to the child nodes, and to the sibling nodes.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用jQuery选择器选择了节点，我们可以遍历DOM以查找更多元素。DOM节点可以沿着三个方向遍历：到父节点、到子节点和到兄弟节点。
- en: Traversing parent nodes can be done in many ways, but the simplest ways are
    by calling one of four functions on the JQuery object. The first is a way to traverse
    parent nodes is by calling the `parent()` function. This function simply returns
    a JQuery object that contains the original node's parent node. The second function
    is the `parents()` function. This function takes in a CSS selector and returns
    a JQuery object containing the matching nodes. `parents()` traverses up the DOM
    tree, selecting any parent node, up to the head of the tree, that matches the
    provided query criteria. If no criteria is given, it selects all of the parent
    nodes. The third parent traversing function is the `parentsUntil()` function.
    It also takes in a CSS selector and returns a JQuery object. This function traverses
    up the parent tree, selecting elements until it reaches an element that matches
    the provided selector. The node that matches the provided selector is not included
    in the new JQuery object. The final method is the `closest()` method. This function
    takes in a CSS selector and returns a JQuery object containing the first parent
    node to match the provided selector.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历父节点有很多种方式，但最简单的方式之一是在JQuery对象上调用四个函数中的一个。第一种遍历父节点的方式是调用`parent()`函数。这个函数简单地返回一个包含原始节点的父节点的JQuery对象。第二个函数是`parents()`函数。这个函数接受一个CSS选择器，并返回一个包含匹配节点的JQuery对象。`parents()`遍历DOM树，选择与提供的查询条件匹配的任何父节点，直到树的顶部。如果没有给出条件，它将选择所有父节点。第三个父遍历函数是`parentsUntil()`函数。它也接受一个CSS选择器，并返回一个JQuery对象。这个函数遍历父树，选择元素，直到它达到与提供的选择器匹配的元素。与提供的选择器匹配的节点不包括在新的JQuery对象中。最后一个方法是`closest()`方法。这个函数接受一个CSS选择器，并返回一个包含与提供的选择器匹配的第一个父节点的JQuery对象。
- en: Note
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Closest()` always starts searching at the node contained in the JQuery object
    it is called on. If the selector passed in to `closest()` matches that node, it
    will always return itself.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`closest()`总是从包含它被调用的JQuery对象中的节点开始搜索。如果传递给`closest()`的选择器与该节点匹配，它将始终返回自身。'
- en: 'Traversing child nodes can be done easily in two ways: `children()` and `find()`.
    The `children()` function takes in a CSS selector and returns a JQuery object
    of nodes are direct descendants, and match the selector, of the node it was called
    on. The `find()` function takes in a CSS selector and returns a JQuery object
    of any descendent node in the DOM tree, including nested children, that match
    the provided CSS selector.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历子节点可以通过两种简单的方式轻松完成：`children()`和`find()`。`children()`函数接受一个CSS选择器，并返回一个JQuery对象，该对象是调用它的节点的直接后代，并且匹配选择器。`find()`函数接受一个CSS选择器，并返回DOM树中任何匹配提供的CSS选择器的后代节点的JQuery对象，包括嵌套的子节点。
- en: 'Traversing sibling nodes can be done in the simplest way with the `next()`,
    `prev()`, and `siblings()` functions. `next()` gets the next sibling and `prev()`
    gets the previous sibling. Both functions return the new node in the JQuery object.
    `Siblings()` takes in a CSS selector and selects an element''s siblings in both
    directions (previous and next) that match the provided selector. `Prev()` and
    `next()` also have similar functions: `prevAll()`, `prevUntil()`, `nextAll()`,
    and `nextUntil()`. As you might expect, the `All` functions select all previous
    or next nodes. The `Until` functions select nodes, until but not including the
    node that matches the provided CSS selector.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历兄弟节点可以通过`next()`、`prev()`和`siblings()`函数以最简单的方式完成。`next()`获取下一个兄弟节点，`prev()`获取上一个兄弟节点。这两个函数都返回JQuery对象中的新节点。`siblings()`接受一个CSS选择器，并选择匹配提供的选择器的元素的兄弟节点（前一个和后一个）。`prev()`和`next()`也有类似的函数：`prevAll()`、`prevUntil()`、`nextAll()`和`nextUntil()`。正如你所期望的那样，`All`函数选择所有之前或之后的节点。`Until`函数选择节点，直到但不包括与提供的CSS选择器匹配的节点。
- en: Modifying the DOM
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改DOM
- en: 'Now that we can select DOM nodes, we need to learn how to modify and create
    them. To create a node, we can simply pass an HTML string into the selector function.
    JQuery will parse the HTML string and create the nodes in the string. This is
    done like so: `$( ''<div>'' )`. The HTML string will be parsed for the div element
    and a JQuery object will be returned containing that element.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以选择DOM节点了，我们需要学习如何修改和创建它们。要创建一个节点，我们可以简单地将HTML字符串传递给选择器函数。JQuery将解析HTML字符串并创建字符串中的节点。这样做的方式是：`$('<div>')`。HTML字符串将被解析为div元素，并返回一个包含该元素的JQuery对象。
- en: To add elements to the DOM, we can use the `append()`, `before()`, and `after()`
    functions. The append function takes in a JQuery object and appends it to the
    children of the JQuery object that append was called from. It then returns a JQuery
    object containing the node the `append()` function was called on. `Before()` and
    `after()` function in a similar way. They both take in a JQuery object and insert
    it before or after the nodes contained in the JQuery object they are called on.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要向DOM添加元素，我们可以使用`append()`、`before()`和`after()`函数。`append()`函数接受一个JQuery对象，并将其附加到调用`append()`函数的JQuery对象的子节点中。然后返回一个包含调用`append()`函数的节点的JQuery对象。`before()`和`after()`函数以类似的方式工作。它们都接受一个JQuery对象，并在调用它们的JQuery对象中的节点之前或之后插入它。
- en: To remove DOM nodes, we can use the `remove()` and `detach()` function. Remove
    permanently removes the nodes that match the CSS selector passed in to the function.
    `Remove()` returns a JQuery object containing the removed nodes. All event listeners
    and associated data are removed from the nodes. If they are returned to the DOM,
    the listeners and data will have to be reset. `Detach()` removes nodes but persists
    events and data. Like `remove()`, it returns the detached nodes in a JQuery object.
    `Detach()` should be used if you plan on returning nodes to the page eventually.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除DOM节点，我们可以使用`remove()`和`detach()`函数。`remove()`永久删除与函数传入的CSS选择器匹配的节点。`remove()`返回一个包含已删除节点的JQuery对象。所有事件监听器和相关数据都将从节点中删除。如果它们返回到DOM中，监听器和数据将需要重新设置。`detach()`删除节点但保留事件和数据。与`remove()`一样，它返回一个包含已分离节点的JQuery对象。如果打算最终将节点返回到页面上，则应使用`detach()`。
- en: Modifying nodes with JQuery is very simple. Once we have selected nodes, traversed
    the tree, then filtered the selection to a single node, we can call JQuery object
    functions to modify things like attributes and CSS. To modify attributes, we can
    use the `attr()` function. `Attr()` takes in two values. The first is the name
    of the attribute to be modified. The second value sets what the attribute equals
    to. To modify an element's CSS, we can use the `css()` function. This function
    takes in two parameters. The first parameter is the CSS property to be modified.
    The second parameter value sets what the CSS property equals to. Both of these
    functions can also be used as `get` functions. If a second value is omitted, the
    `attr()` and `css()` functions will return the value of the attribute or CSS property
    instead of setting it.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JQuery修改节点非常简单。一旦我们选择了节点，遍历了树，然后将选择过滤到单个节点，我们就可以调用JQuery对象函数来修改属性和CSS等内容。要修改属性，我们可以使用`attr()`函数。`attr()`接受两个值。第一个是要修改的属性的名称。第二个值设置属性等于什么。要修改元素的CSS，我们可以使用`css()`函数。此函数接受两个参数。第一个参数是要修改的CSS属性。第二个参数值设置CSS属性等于什么。这两个函数也可以用作`get`函数。如果省略第二个值，`attr()`和`css()`函数将返回属性或CSS属性的值，而不是设置它。
- en: Chaining
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接
- en: 'Most jQuery object functions return jQuery objects. This allows us to chain
    calls together and not separate each function call with a semicolon and newline.
    When chaining jQuery functions, jQuery tracks changes to the selector and nodes
    in the jQuery object. We can use the `end()` function to restore the current selection
    to its original selection. An example of this is shown in the following snippet:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数jQuery对象函数返回jQuery对象。这使我们能够链接调用，并且不需要用分号和换行符分隔每个函数调用。在链接jQuery函数时，jQuery会跟踪对选择器和JQuery对象中的节点的更改。我们可以使用`end()`函数将当前选择恢复到其原始选择。以下是一个示例：
- en: '[PRE30]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Snippet 3.31: Chaining and .end()'
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段3.31：链接和.end()
- en: jQuery Events
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery事件
- en: As discussed previously in the *DOM Events* section, any responsive and functional
    web page must rely on events. jQuery also provides a simple interface for adding
    event handlers and handling events.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面在*DOM事件*部分讨论的那样，任何响应灵敏和功能的网页都必须依赖事件。jQuery还提供了一个简单的接口来添加事件处理程序和处理事件。
- en: '**Registering Handlers**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册处理程序**'
- en: Registering events with jQuery is very simple. The jQuery object provides many
    ways to register events. The simplest way to register an event is with the `on()`
    function. `On()` can be called with two different sets of data.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery注册事件非常简单。jQuery对象提供了许多注册事件的方法。注册事件的最简单方法是使用`on()`函数。`On()`可以使用两组不同的数据进行调用。
- en: 'The first way to set up an event listener is by calling `on()` with four arguments:
    **events**, **selector**, **data**, and **handler**. Events is a space separated
    string of event types and optional namespaces (`click hover scroll.myPlugin`).
    A listener will be created for each event that''s provided. The second argument
    is selector. It is optional. If a CSS selector string is provided, the event listeners
    will also be added to all descendants of the selected elements that match the
    selector. The third argument is data. This can be anything and is optional. If
    data is provided, then it will be passed to the event object in the data field
    when the event is triggered. The final argument is the handler function. This
    is the function that will be called when the event triggers.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 设置事件监听器的第一种方法是使用`on()`调用四个参数：**events**，**selector**，**data**和**handler**。Events是一个以空格分隔的事件类型和可选的命名空间字符串（`click
    hover scroll.myPlugin`）。将为提供的每个事件创建一个监听器。第二个参数是选择器。这是可选的。如果提供了CSS选择器字符串，则事件监听器也将添加到与选择器匹配的所选元素的所有后代元素。第三个参数是数据。这可以是任何内容，也是可选的。如果提供了数据，那么在触发事件时它将被传递到事件对象的数据字段中。最后一个参数是处理程序函数。这是在事件触发时将被调用的函数。
- en: 'The second way to set up an event listener is by calling `on()` with three
    arguments: **events**, **selector**, and **data**. Much like the first method,
    events specifies the events that listeners will be created for. However, in this
    case, events is an object. The key is that the event name, which a listener will
    be set up for and the value is the function that will be called when the event
    fires. Like the first method, the selector and data arguments are optional. They
    both function the same way as the first method.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 设置事件监听器的第二种方法是使用三个参数调用`on()`：**events**，**selector**和**data**。与第一种方法类似，事件指定将创建监听器的事件。但是，在这种情况下，事件是一个对象。键是事件名称，将为其设置监听器的值，而值是事件触发时将被调用的函数。与第一种方法一样，选择器和数据参数是可选的。它们的功能与第一种方法相同。
- en: To remove an event listener, we can use the `off()` method. The simplest way
    to remove event listeners with off is by providing the name of the event we want
    to remove listeners for. Like `on()`, we can provide the event types in a space-separated
    string or through an object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除事件监听器，我们可以使用`off()`方法。使用off删除事件监听器的最简单方法是提供要删除监听器的事件的名称。与`on()`一样，我们可以通过空格分隔的字符串或对象提供事件类型。
- en: Firing Events
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'jQuery provides an easy way to fire events from JavaScript: the `trigger()`
    function. The `trigger()` function should be used to fire an event and takes in
    the event type and an unlimited number of extra parameters. The event type is
    the type of event that will be triggered. The extra parameters are passed to the
    event handler function and are passed in as arguments after the event object.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一种从JavaScript中触发事件的简单方法：`trigger()`函数。`trigger()`函数应该用于触发事件，并接受事件类型和无限数量的额外参数。事件类型是将被触发的事件类型。额外的参数将传递给事件处理程序函数，并在事件对象之后作为参数传递。
- en: Custom Events
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义事件
- en: Custom events in jQuery are very simple. Unlike custom events with Vanilla JavaScript,
    in jQuery, to set up an event handler for a custom event, all we need to do is
    create a listener with the `on()` function, with the event type as the custom
    event. To fire the event, we simply need to fire it with `trigger()`, with the
    event type as the custom event.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的自定义事件非常简单。与Vanilla JavaScript中的自定义事件不同，在jQuery中，要为自定义事件设置事件处理程序，我们只需要使用`on()`函数创建一个监听器，事件类型为自定义事件。要触发事件，我们只需要使用`trigger()`来触发它，事件类型为自定义事件。
- en: 'Activity 3: Implementing jQuery'
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：实现jQuery
- en: You want to make a web app that controls your home's smart LED lighting system.
    You have three LEDs that can be individually turned on or off, or all toggled
    together. You must build a simple HTML and jQuery interface that shows the on
    state of the lights and has buttons to control the lights.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您想制作一个控制家庭智能LED照明系统的网络应用程序。您有三个LED，可以单独打开或关闭，或者全部一起切换。您必须构建一个简单的HTML和jQuery界面，显示灯的开启状态，并具有控制灯的按钮。
- en: 'To build a functioning application with JQuery, perform the following steps:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JQuery构建一个功能应用程序，请执行以下步骤：
- en: Set up a Node.js project with `npm run init` on the command line and install jQuery.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行上的`npm run init`设置一个Node.js项目并安装jQuery。
- en: Create an HTML file that loads the jQuery scripts.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个加载jQuery脚本的HTML文件。
- en: In the HTML file, add three divs that start as white.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文件中，添加三个起始为白色的div。
- en: Add a toggle button above the divs and a button after each div.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在div上方添加一个切换按钮，并在每个div后面添加一个按钮。
- en: Set up event listeners for click events for each button.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个按钮设置点击事件的事件监听器。
- en: The toggle button should change the color of all divs. Other buttons should
    change the color of the associated `div`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换按钮应更改所有div的颜色。其他按钮应更改相关`div`的颜色。
- en: On a color change, swap the color between black and white
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色变化时，将颜色在黑色和白色之间切换
- en: '**Code**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**Outcome**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 3.12: After step 4 output](image/Figure_3.12.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12：步骤4输出后](image/Figure_3.12.jpg)'
- en: 'Figure 3.12: After step 4 output'
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.12：步骤4输出后
- en: '![Figure 3.13: After step 6 output'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：步骤6输出后](image/Figure_3.13.jpg)'
- en: '](image/Figure_3.13.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.13.jpg)'
- en: 'Figure 3.13: After step 6 output'
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.13：步骤6输出后
- en: You have successfully utilized jQuery to build a functioning application.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功利用jQuery构建了一个功能应用程序。
- en: Note
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 285\.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第285页找到。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Web development revolves around the Document Object Model and the Event object.
    JavaScript is built to quickly and efficiently interact with the DOM and DOM events
    to provide us with powerful and interactive web pages. In the first topic of this
    chapter, we covered the DOM tree and discussed the ways to navigate and manipulate
    the DOM. In the second topic of this chapter, we discussed the JavaScript Event
    object, showed how to interact with DOM events, and demonstrated how to set up
    handlers to catch events. In the final topic of this chapter, we discussed the
    jQuery module. We discussed the jQuery object and jQuery selector, and showed
    how to use jQuery for DOM manipulation and event handling. With the topics learned
    in this chapter, you should be prepared to begin writing your own powerful and
    interactive web pages.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发围绕着文档对象模型和事件对象展开。JavaScript被设计成能够快速高效地与DOM和DOM事件进行交互，为我们提供强大而丰富的互动网页。在本章的第一个主题中，我们讨论了DOM树，并讨论了导航和操作DOM的方法。在本章的第二个主题中，我们讨论了JavaScript事件对象，展示了如何与DOM事件交互，并演示了如何设置处理程序来捕获事件。在本章的最后一个主题中，我们讨论了jQuery模块。我们讨论了jQuery对象和jQuery选择器，并展示了如何使用jQuery进行DOM操作和事件处理。通过学习本章的内容，您应该已经准备好开始编写自己的强大而丰富的互动网页。
- en: In the next chapter, you will analyze the benefit of tests and build code testing
    environments.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将分析测试的好处，并建立代码测试环境。
