- en: 7\. Monitoring the AKS cluster and the application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 监视AKS集群和应用程序
- en: Now that you know how to deploy applications on an AKS cluster, let's focus
    on how you can ensure your cluster and applications remain available. In this
    chapter, you will learn how to monitor your cluster and the applications running
    on it. You'll explore how Kubernetes makes sure that your applications are running
    reliably using readiness and liveness probes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何在AKS集群上部署应用程序，让我们专注于如何确保您的集群和应用程序保持可用。在本章中，您将学习如何监视您的集群以及运行在其中的应用程序。您将探索Kubernetes如何通过就绪和存活探针确保您的应用程序可靠运行。
- en: You will also learn how **Azure Monitor** is used, and how it is integrated
    within the Azure portal, as well as how to set up alerts for critical events on
    your AKS cluster. You will see how you can use Azure Monitor to monitor the status
    of the cluster itself, the Pods on the cluster and get access to the logs of the
    Pods at scale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习如何使用**Azure Monitor**，以及它如何在Azure门户中集成，以及如何为AKS集群上的关键事件设置警报。您将了解如何使用Azure
    Monitor监视集群本身的状态，集群上的Pod以及以规模访问Pod的日志。
- en: 'In brief, the following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: Monitoring and debugging applications using `kubectl`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl`监视和调试应用程序
- en: Reviewing metrics reported by Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查Kubernetes报告的指标
- en: Reviewing metrics from Azure Monitor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查来自Azure Monitor的指标
- en: Let's start the chapter by reviewing some of the commands in `kubectl` that
    you can use to monitor your applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾一些`kubectl`中的命令开始，您可以使用这些命令来监视您的应用程序。
- en: Commands for monitoring applications
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于监视应用程序的命令
- en: 'Monitoring the health of applications deployed on Kubernetes as well as the
    Kubernetes infrastructure itself is essential to provide a reliable service to
    your customers. There are two primary use cases for monitoring:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 监控部署在Kubernetes上的应用程序的健康状况以及Kubernetes基础架构本身对于向客户提供可靠的服务至关重要。监控有两个主要用例：
- en: Ongoing monitoring to get alerts if something is not behaving as expected
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续监控以获取警报，如果某些情况表现不如预期
- en: Troubleshooting and debugging applications errors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除和调试应用程序错误
- en: 'When monitoring an application running on top of a Kubernetes cluster, you''ll
    need to examine multiple things in parallel, including containers, Pods, Services,
    and the nodes in the cluster. For ongoing monitoring, you''ll need a monitoring
    system such as Azure Monitor or Prometheus. For troubleshooting, you''ll need
    to interact with the live cluster. The most common commands used for troubleshooting
    are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视运行在Kubernetes集群之上的应用程序时，您需要同时检查多个内容，包括容器、Pod、服务以及集群中的节点。对于持续监控，您将需要像Azure
    Monitor或Prometheus这样的监控系统。对于故障排除，您将需要与实时集群进行交互。用于故障排除的最常用命令如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll describe each of these commands in detail in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中详细描述每个命令。
- en: 'Before we begin, we are going to have a clean start with our guestbook example.
    Recreate the guestbook example again using the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们将使用我们的guestbook示例进行清洁启动。再次使用以下命令重新创建guestbook示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the `create` command is running, we will watch its progress in the following
    sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create`命令运行时，我们将在以下章节中观察其进展。
- en: The kubectl get command
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kubectl get命令
- en: 'To see the overall picture of deployed applications, `kubectl` provides the
    `get` command. The `get` command lists the resources that you specify. Resources
    can be Pods, ReplicaSets, Ingresses, nodes, Deployments, Secrets, and so on. We
    have already run this command in the previous chapters to verify that our application
    was ready to be used. Perform the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看部署应用程序的整体情况，`kubectl`提供了`get`命令。`get`命令列出您指定的资源。资源可以是Pods、ReplicaSets、Ingresses、节点、部署、Secrets等等。我们已经在前几章中运行了这个命令，以验证我们的应用程序已经准备好使用。执行以下步骤：
- en: 'Run the following `get` command, which will get us the resources and their
    statuses:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下`get`命令，这将获取我们资源及其状态：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will show you all the Deployments, ReplicaSets, Pods, and Services in
    your namespace:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示您的命名空间中的所有部署、ReplicaSets、Pods和服务：
- en: '![Output of the kubectl get all command showing the resources and their statuses,
    along with the Deployments, ReplicaSets, Pods, and Services in the namespace.](image/Figure_7.1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get all命令的输出显示资源及其状态，以及命名空间中的部署、ReplicaSets、Pods和服务。](image/Figure_7.1.jpg)'
- en: 'Figure 7.1: All the resources running in the default namespace'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.1：默认命名空间中运行的所有资源
- en: 'Let''s focus our attention on the Pods in our Deployment. We can get the status
    of the Pods with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把注意力集中在我们部署中的Pods上。我们可以使用以下命令获取Pods的状态：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see that, now, only the Pods are shown, as seen in *Figure 7.2*. Let''s
    investigate this in detail:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到，现在只显示了Pods，就像*图7.2*中所示。让我们详细调查一下：
- en: '![Retrieving the status of the pods in our deployment using the kubectl get
    pods command.](image/Figure_7.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get pods命令检索我们部署中的Pod的状态。](image/Figure_7.2.jpg)'
- en: 'Figure 7.2: All the Pods in your namespace'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.2：您的命名空间中的所有Pods
- en: The first column indicates the Pod name, for example, `frontend-57d8c9fb45-c6qtm`.
    The second column indicates how many containers in the Pod are ready against the
    total number of containers in the Pod. Readiness is defined via a readiness probe
    in Kubernetes. We have a dedicated section called *Readiness and liveness probes*
    later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列表示Pod名称，例如`frontend-57d8c9fb45-c6qtm`。第二列表示Pod中准备好的容器数量与Pod中的总容器数量。通过Kubernetes中的就绪探针来定义就绪状态。我们在本章的后面有一个专门的部分叫做*就绪和存活探针*。
- en: The third column indicates the status, for example, `Pending`, or `ContainerCreating`,
    or `Running`, and so on. The fourth column indicates the number of restarts, while
    the fifth column indicates the age when the Pod was asked to be created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列表示状态，例如`Pending`或`ContainerCreating`或`Running`等等。第四列表示重启次数，而第五列表示Pod被要求创建的时间。
- en: 'If you need more information about your Pod, you can add extra columns to the
    output of a `get` command by adding `-o wide` to the command like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于您的Pod的信息，您可以通过在命令中添加`-o wide`来添加额外的列到`get`命令的输出中，就像这样：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will show you additional information as shown in *Figure 7.3*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示额外的信息，就像*图7.3*中所示：
- en: '![Getting additional information about the Pod with the kubectl get pods -o
    wide command.](image/Figure_7.3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get pods -o wide命令获取有关Pod的其他信息。](image/Figure_7.3.jpg)'
- en: 'Figure 7.3: Adding -o wide shows more details on the Pods'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.3：添加-o wide显示了Pod的更多细节
- en: The extra columns include the IP address of the Pod, the node it is running
    on, the nominated node, and readiness gates. A nominated node is only set when
    a higher-priority Pod preempts a lower-priority Pod. The nominated node is the
    node where that higher-priority Pod will start once the lower-priority Pods gracefully
    terminate. A readiness gate is a way to introduce external system components as
    the readiness for a Pod.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的列包括Pod的IP地址、它所在的节点、被提名的节点和就绪门。只有当高优先级的Pod抢占低优先级的Pod时，才会设置被提名的节点。被提名的节点是高优先级Pod在低优先级Pod优雅终止后将启动的节点。就绪门是引入外部系统组件作为Pod就绪的一种方式。
- en: 'Executing a `get pods` command only shows the state of the current Pod. To
    see the events for all resources in the system, run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`get pods`命令只显示当前Pod的状态。要查看系统中所有资源的事件，请运行以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Kubernetes maintains events for only 1 hour by default. All the commands work
    only if the event was fired within the past hour.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes默认只保留1小时的事件。所有命令只在事件在过去一小时内触发时有效。
- en: 'If everything goes well, you should have an output similar to *Figure 7.4*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会得到类似于*图7.4*的输出：
- en: '![Output of the kubectl get events command displaying a truncated list of the
    events from the past hour.](image/Figure_7.4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![显示过去一小时事件的kubectl get events命令的输出的缩略列表。](image/Figure_7.4.jpg)'
- en: 'Figure 7.4: Getting the events shows all events from the past hour'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：获取事件显示过去一小时的所有事件
- en: As you can see in the output, the general states for a Pod are `Scheduled` |
    `Pulling` | `Pulled` | `Created` | `Started`. As we will see next, things can
    fail at any of the states, and we need to use the `kubectl describe` command to
    dig deeper.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中所见，Pod的一般状态为`Scheduled` | `Pulling` | `Pulled` | `Created` | `Started`。接下来我们将看到，任何状态都可能失败，我们需要使用`kubectl
    describe`命令进行深入挖掘。
- en: The kubectl describe command
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kubectl describe命令
- en: 'The `kubectl get events` command lists all the events for the entire namespace.
    If you are interested in just Pods, you can use the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl get events`命令列出整个命名空间的所有事件。如果您只对Pod感兴趣，可以使用以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding command lists all the information pertaining to all Pods. This
    is typically too much information to contain in a typical shell.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令列出了所有与所有Pod相关的信息。这通常是典型shell无法包含的太多信息。
- en: 'If you want information on a particular Pod, you can type the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要特定Pod的信息，可以输入以下内容：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can either use a *slash* or a *space* in between `pod` and `podname`. The
    following two commands will have the same output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`pod`和`podname`之间使用*斜杠*或*空格*。以下两个命令将产生相同的输出：
- en: '`kubectl describe pod/<pod-name>`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe pod/<pod-name>`'
- en: '`kubectl describe pod <pod-name>`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe pod <pod-name>`'
- en: 'You will get an output similar to *Figure 7.5*, which will be explained in
    detail later:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到类似于*图7.5*的输出，稍后将对其进行详细解释。
- en: '![Output of the kubectl describe pod/<pod-name> command displaying all the
    details of the specified pod.](image/Figure_7.5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![显示指定pod的所有细节的kubectl describe pod/<pod-name>命令的输出。](image/Figure_7.5.jpg)'
- en: 'Figure 7.5: Describing an object shows the detailed output of that object'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：描述对象显示该对象的详细输出
- en: From the description, you can get the node on which the Pod is running, how
    long it has been running, its internal IP address, the Docker image name, the
    ports exposed, the `env` variables, and the events (from within the past hour).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述，您可以获得Pod所在的节点、它运行了多长时间、它的内部IP地址、Docker镜像名称、暴露的端口、`env`变量和事件（在过去一小时内）。
- en: 'In the preceding example, the Pod name is `frontend-57d8c9fb45-c6qtm`. As mentioned
    in *Chapter 1, Introduction to Docker and Kubernetes*, it has the `<ReplicaSet
    name>-<random 5 chars>` format. The `replicaset` name itself is randomly generated
    from the Deployment name front end: `<deployment name>-<random 5 chars>`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，Pod的名称是“frontend-57d8c9fb45-c6qtm”。如*第1章《Docker和Kubernetes简介》*中所述，它采用了“<ReplicaSet名称>-<随机5个字符>”的格式。`replicaset`名称本身是从部署名称`frontend`随机生成的：`<deployment名称>-<随机5个字符>`。
- en: '*Figure 7.6* shows the relationship between a Deployment, a ReplicaSet, and
    Pods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6*显示了部署、副本集和Pod之间的关系：'
- en: '![Graphical representation of the relationship between a Deployment, a ReplicaSet,
    and Pods.](image/Figure_7.6.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图形化表示部署、副本集和Pod之间的关系。](image/Figure_7.6.jpg)'
- en: 'Figure 7.6: Relationship between a Deployment, a ReplicaSet, and Pods'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.6：部署、副本集和Pod之间的关系
- en: The namespace under which the Pod runs is `default`. So far, we have just been
    using the `default` namespace, appropriately named `default`. In the next chapters,
    we will see how namespaces help us to isolate Pods.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Pod运行的命名空间是“default”。到目前为止，我们一直在使用名为“default”的“default”命名空间。在接下来的章节中，我们将看到命名空间如何帮助我们隔离Pod。
- en: 'Another section that is important from the preceding output is the node section:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出中重要的另一部分是节点部分：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The node section lets us know which physical node/VM the Pod is running on.
    If the Pod is repeatedly restarting or having issues running and everything else
    seems OK, there might be an issue with the node. Having this information is essential
    to perform advanced debugging.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 节点部分让我们知道Pod正在哪个物理节点/虚拟机上运行。如果Pod反复重启或出现运行问题，而其他一切似乎正常，可能是节点出现了问题。拥有这些信息对于进行高级调试至关重要。
- en: 'The following is the time the Pod was initially scheduled:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Pod最初被调度的时间：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This doesn't mean that the Pod has been running since that time, so the time
    can be misleading in that sense. If a health event occurs (for example, a container
    crashes), a Pod will be restarted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着Pod从那时起一直在运行，因此时间在这方面可能会误导。如果发生健康事件（例如，容器崩溃），Pod将被重新启动。
- en: 'Connections between resources are made using `Labels`, as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 资源之间的连接是使用“标签”进行的，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is how connections such as `Service` | `Deployment` | `ReplicaSet` | `Pod`
    are made. If you see that traffic is not being routed to a Pod from a Service,
    this is the first thing you should check. If the labels don't match, the resources
    won't attach.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何建立`Service` | `Deployment` | `ReplicaSet` | `Pod`等连接的。如果发现流量没有从Service路由到Pod，这是您应该检查的第一件事。如果标签不匹配，资源将无法连接。
- en: 'The following shows the internal IP of the Pod and its status:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了Pod的内部IP和其状态：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned in previous chapters, when building out your application, the Pods
    can be moved to different nodes and get a different IP. However, when debugging
    application issues, having a direct IP for a Pod can help in troubleshooting.
    Instead of connecting to your application through a Service object, you can connect
    directly from one Pod to another to test connectivity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，构建应用程序时，Pod可以移动到不同的节点并获得不同的IP。然而，在调试应用程序问题时，直接获得Pod的IP可以帮助进行故障排除。您可以直接从一个Pod连接到另一个Pod以测试连接性，而不是通过Service对象连接到应用程序。
- en: 'The containers running in the Pod and the ports that are exposed are listed
    in the following block:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod中运行的容器和暴露的端口列在以下区块中：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, we are getting the `gb-frontend` container with the `v4` tag from
    the `gcr.io` container registry, and the repository name is `google-samples`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们从`gcr.io`容器注册表中获取带有`v4`标签的`gb-frontend`容器，仓库名称为`google-samples`。
- en: Port `80` is exposed to outside traffic. Since each Pod has its own IP, the
    same port can be exposed for multiple instances of the same Pod even when running
    on the same host. For instance, if you were to have two Pods running a web server
    on the same node, those could both use port `80`, since each Pod has its own IP
    address. This is a huge management advantage as you don't have to worry about
    port collisions. The port that needs to be configured is also fixed so that scripts
    can be written simply without the logic of figuring out which port actually got
    allocated for the Pod.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 端口`80`对外部流量开放。由于每个Pod都有自己的IP，即使在同一主机上运行时，相同的端口也可以为同一Pod的多个实例开放。例如，如果您在同一节点上运行两个运行Web服务器的Pod，这两个Pod都可以使用端口`80`，因为每个Pod都有自己的IP地址。这是一个巨大的管理优势，因为您不必担心端口冲突。需要配置的端口也是固定的，因此可以简单地编写脚本，而无需考虑为Pod分配了哪个端口的逻辑。
- en: 'Any events that occurred in the previous hour show up here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处显示了上一个小时发生的任何事件：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using `kubectl describe` is very useful to get more context about the resources
    you are running. In the next section, we'll focus on debugging applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl describe`非常有用，可以获取有关正在运行的资源的更多上下文。在下一节中，我们将专注于调试应用程序。
- en: Debugging applications
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Now that we have a basic understanding of how to monitor Deployments, we can
    start seeing how we can debug issues with Deployments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何监视部署有了基本的了解，我们可以开始看看如何调试部署中的问题。
- en: In this section, we will introduce common errors and determine how to debug
    and fix them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍常见错误并确定如何调试和修复它们。
- en: 'If you have not implemented the guestbook application already, run the following
    command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未实现guestbook应用程序，请运行以下命令：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After a period of time, the Services should be up and running.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，服务应该已经启动并运行。
- en: '**Image pull errors**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像拉取错误**'
- en: In this section, we are going to introduce image pull errors by setting the
    image tag value to a non-existent one. An image pull error occurs when Kubernetes
    cannot download the image for the container it needs to run.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将图像标记值设置为不存在的值来介绍图像拉取错误。当Kubernetes无法下载容器所需的图像时，就会发生图像拉取错误。
- en: 'Run the following command on Azure Cloud Shell:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Cloud Shell上运行以下命令：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, change the image tag from `v4` to `v_non_existent` by executing the following
    steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过执行以下步骤将图像标记从`v4`更改为`v_non_existent`：
- en: Type `/gb-frontend` and hit the *Enter* button to have your cursor brought to
    the image definition.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`/gb-frontend`并按*Enter*按钮，将光标移到图像定义处。
- en: Hit the *I* key to go into insert mode. Delete `v4` and type `v_non_existent`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*I*键进入插入模式。删除`v4`并输入`v_non_existent`。
- en: Now, close the editor by first hitting the *Esc* key, then type `:wq!` and hit
    *Enter*.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，首先按下*Esc*键关闭编辑器，然后输入`:wq!`并按*Enter*键。
- en: 'Running the following command lists all the Pods in the current namespace:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令列出当前命名空间中的所有Pod：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command should indicate errors, as shown in *Figure 7.7*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该指示错误，如*图7.7*所示：
- en: '![The output of the kubectl get pods command showing that three pods are running,
    while one.Pod throws an Image pull back off error.](image/Figure_7.7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get pods命令的输出显示有三个Pod正在运行，而一个Pod出现了Image pull back off错误。](image/Figure_7.7.jpg)'
- en: 'Figure 7.7: One of the Pods has the status of ImagePullBackOff'
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：一个Pod的状态为ImagePullBackOff
- en: 'Run the following command to get the full error details:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以获取完整的错误详细信息：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A sample error output is shown in *Figure7.8*. The key error line is highlighted
    in red:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.8*显示了一个示例错误输出。关键错误行用红色突出显示：'
- en: '![Using the kubectl describe pods/<failed pod name> command to showing the
    error details for the pod that failed to pull the image. The image has two highlights,
    "Failed to pull image" and "v_non_existent not found".ils on the error'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用kubectl describe pods/<failed pod name>命令显示无法拉取图像的错误详细信息。图像有两个亮点，“无法拉取图像”和“v_non_existent未找到”。ils
    on the error'
- en: '](image/Figure_7.8.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.8.jpg)'
- en: 'Figure 7.8: Using describe shows more details on the error'
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：使用describe显示错误的更多详细信息
- en: So, the events clearly show that the image does not exist. Errors such as passing
    invalid credentials to private Docker repositories will also show up here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，事件清楚地显示图像不存在。将无效凭据传递给私有Docker存储库也会在此处显示。
- en: 'Let''s fix the error by setting the image tag back to `v4`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将图像标签设置回`v4`来修复错误：
- en: 'First, type the following command in Cloud Shell to edit the Deployment:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Cloud Shell中键入以下命令以编辑部署：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Type `/gb-frontend` and hit `<enter>` to have your cursor brought to the image
    definition.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`/gb-frontend`并按`<enter>`将光标移到图像定义处。
- en: Hit the *I* button to go into insert mode. Delete `v_non_existent`, and type
    `v4`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*I*键进入插入模式。删除`v_non_existent`，然后输入`v4`。
- en: Now, close the editor by first hitting the *Esc* key, then type `:wq!` and hit
    *Enter*.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，首先按下*Esc*键关闭编辑器，然后输入`:wq!`并按*Enter*键。
- en: The Deployment should get automatically fixed. You can verify it by getting
    the events for the Pods again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应该会自动修复。您可以通过再次获取Pod的事件来验证它。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Because Kubernetes did a rolling update, the frontend was continuously available
    with zero downtime. Kubernetes recognized a problem with the new specification
    and stopped rolling out additional changes automatically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes进行了滚动更新，前端一直可用，没有任何停机时间。Kubernetes识别出新规范存在问题，并停止自动滚动出额外的更改。
- en: Image pull errors can occur when images aren't available. In the next section,
    we'll explore an error within the application itself.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图像拉取错误可能发生在图像不可用时。在下一节中，我们将探索应用程序本身的错误。
- en: '**Application errors**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序错误**'
- en: We will now see how to debug an application error. The errors in this section
    will be self- induced, similar to in the last section. The method for debugging
    the issue is the same as the one we used to debug errors on running applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何调试应用程序错误。本节中的错误将是自我引起的，类似于上一节。调试问题的方法与我们用于调试运行应用程序的方法相同。
- en: 'In order to test our failure, we''ll have to make the `frontend` Service publicly
    accessible:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的失败，我们将使`frontend`服务可以公开访问：
- en: 'To start, we''ll edit the `frontend` Service:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编辑`frontend`服务：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Type `/ClusterIP` and hit *Enter* to bring your cursor to the type field (line
    27).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`/ClusterIP`并按*Enter*将光标移到类型字段（第27行）。
- en: Hit the *I* button to go into insert mode. Delete the `ClusterIP` and type `LoadBalancer`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*I*键进入插入模式。删除`ClusterIP`，然后输入`LoadBalancer`。
- en: Now, close the editor by first hitting the *Esc* key, then type `:wq!` and hit
    *Enter*. This will create a public IP for our frontend Service.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，首先按下*Esc*键关闭编辑器，然后输入`:wq!`并按*Enter*。这将为我们的前端服务创建一个公共IP。
- en: 'We can get this IP using the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令获取此IP：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's connect to the Service, by pasting its public IP in a browser. Create
    a couple of entries:![The guestbook application with a couple of entries added.](image/Figure_7.9.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在浏览器中粘贴其公共IP来连接到服务。创建一些条目：![添加了一些条目的留言板应用程序。](image/Figure_7.9.jpg)
- en: 'Figure 7.9: Make a couple of entries in the guestbook application'
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：在留言板应用程序中进行一些条目
- en: Note
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Most errors come from misconfiguration, where they can be fixed by editing the
    specification. Errors in the application code itself require a new image to be
    built and used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误来自错误配置，可以通过编辑规范来修复。应用程序代码本身的错误需要构建和使用新的映像。
- en: You now have an instance of the guestbook application running. To improve the
    experience with the example, we will scale down the frontend so there is only
    a single replica running.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个运行中的guestbook应用程序实例。为了改善示例的体验，我们将缩减前端，以便只有一个副本在运行。
- en: '**Scaling down the frontend**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩减前端**'
- en: In *Chapter 3*, *Application deployment on AKS*, you learned how the deployment
    of the frontend has a configuration of `replicas=3`. This means that the requests
    the application receives can be handled by any of the Pods. To introduce the application
    error and note the errors, we would need to make changes in all three of them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*在AKS上部署应用程序*中，您学习了前端部署的配置为`replicas=3`。这意味着应用程序接收的请求可以由任何一个Pod处理。要引入应用程序错误并注意错误，我们需要对所有三个Pod进行更改。
- en: 'To make this example easier, scale the `replicas` to `1` so that you have to
    make changes to only one Pod:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例更容易，将`replicas`缩减到`1`，这样您只需要对一个Pod进行更改：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having only one replica running will make introducing the error easier. Let's
    now introduce this error.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只运行一个副本将使引入错误变得更容易。现在让我们引入这个错误。
- en: '**Introducing an app error**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**引入应用程序错误**'
- en: In this case, we are going to make the **Submit** button fail to work. We need
    to modify the application code for this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使**提交**按钮无法工作。我们需要修改应用程序代码。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is not advised to make production changes to your application by using `kubectl
    exec` to execute commands in your Pods. If you need to make changes to your application,
    the preferable way is to create a new container image and update your Deployment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用`kubectl exec`对Pod执行命令来对应用程序进行生产更改。如果需要对应用程序进行更改，最好的方法是创建新的容器映像并更新部署。
- en: 'We will use the `kubectl exec` command. This command lets you run commands
    on the command line of that Pod. With the `-it` option, it attaches an interactive
    terminal to the Pod and gives us a shell that we can run our commands on. The
    following command launches a Bash terminal on the Pod:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`kubectl exec`命令。此命令允许您在该Pod的命令行上运行命令。使用`-it`选项，它会将交互式终端附加到Pod，并为我们提供一个可以运行命令的shell。以下命令在Pod上启动Bash终端：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you are in the container shell, run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入容器shell，运行以下命令：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code installs the vim editor so that we can edit the file to
    introduce an error. Now, use `vim` to open the `guestbook.php` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码安装了vim编辑器，以便我们可以编辑文件引入错误。现在，使用`vim`打开`guestbook.php`文件：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following line after line 18\. Remember, to insert a line in vim, you
    hit the *I* key. After you are done editing, you can exit by hitting *Esc*, and
    then type `:wq!` and then press *Enter*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第18行后添加以下行。记住，在vim中插入一行，您按*I*键。编辑完成后，您可以通过按*Esc*退出，然后输入`:wq!`，然后按*Enter*：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The file will look like *Figure 7.10*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将看起来像*图7.10*：
- en: '![The guestbook.php file in the vim editor with the updated code.](image/Figure_7.10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![在vim编辑器中具有更新代码的guestbook.php文件。](image/Figure_7.10.jpg)'
- en: 'Figure 7.10: The updated code that introduced an error and additional logging'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：引入错误和额外日志的更新代码
- en: We are introducing an error where reading messages would work, but not writing
    them. We do this by asking the frontend to connect to the Redis master at the
    non-existent localhost server. The writes should fail. At the same time, to make
    this demo more visual, we added some additional logging to this section of the
    code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个错误，即读取消息可以工作，但写入消息却不行。我们通过要求前端连接到不存在的本地主机的Redis主服务器来实现这一点。写入应该失败。与此同时，为了使这个演示更加直观，我们在代码的这一部分添加了一些额外的日志记录。
- en: 'Open your guestbook application by browsing to its public IP, and you should
    see the entries from earlier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览其公共IP打开您的留言板应用程序，您应该可以看到之前的条目：
- en: '![The guest book application re-opened that displays that the entries from
    earlier are still present.](image/Figure_7.11.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![重新打开的留言板应用程序显示之前的条目仍然存在。](image/Figure_7.11.jpg)'
- en: 'Figure 7.11: The entries from earlier are still present'
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：之前的条目仍然存在
- en: 'Now, create a new message by typing a message and hitting the **Submit** button:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过输入一条消息并点击**提交**按钮来创建一条新消息：
- en: '![Add a "New message" entry to the guestbook application.](image/Figure_7.12.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![向留言板应用程序添加一个“新消息”条目。](image/Figure_7.12.jpg)'
- en: 'Figure 7.12: A new message was created'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：创建了一条新消息
- en: Submitting a new message makes it appear in our application. If we did not know
    any better, we would have thought the entry was written safely. However, if you
    refresh your browser, you will see that the message is no longer there.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提交新消息会使其出现在我们的应用程序中。如果我们不知道更好的方法，我们可能会认为该条目已经安全地被写入。然而，如果您刷新浏览器，您会发现消息不再存在。
- en: If you have network debugging tools turned on in your browser, you can catch
    the error response from the server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开了网络调试工具，您可以捕获服务器的错误响应。
- en: 'To verify that the message has not been written to the database, hit the **Refresh**
    button in your browser; you will see just the initial entries, and the new entry
    has disappeared:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证消息没有被写入数据库，点击浏览器中的**刷新**按钮；您将只看到最初的条目，新条目已经消失：
- en: '![The guestbook application showing just the initial entries after the refresh
    button is hit. The new message waslost.](image/Figure_7.13.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![点击刷新按钮后，留言板应用程序只显示最初的条目。新消息丢失了。](image/Figure_7.13.jpg)'
- en: 'Figure 7.13: The new message has disappeared'
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：新消息已经消失了
- en: 'As an app developer or operator, you''ll probably get a ticket like this: *After
    the new deployment, new entries are not persisted. Fix it.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发人员或操作员，您可能会收到这样的工单：*在新部署后，新条目没有被持久化。修复它。*
- en: Logs
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志
- en: 'The first step is to get the logs. Let''s exit out of our front-end Pod for
    now and get the logs for this Pod:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取日志。现在让我们暂时退出前端Pod并获取该Pod的日志：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see entries such as those seen in *Figure 7.14*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到诸如*图7.14*中所见的条目：
- en: '![Output of the kubectl logs <frontend-pod-name> command displaying the logs
    for the pod. The image contains three highlighted areas: "hostname at the beginning
    of ''set'' command localhost," "cmd=set," and "new%20message".](image/Figure_7.14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl logs <frontend-pod-name>命令的输出显示了该Pod的日志。图中包含三个突出显示的区域：“在''设置''命令localhost之前的主机名”，“cmd=set”，和“new%20message”。](image/Figure_7.14.jpg)'
- en: 'Figure 7.14: The new message shows up as part of the application logs'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：新消息显示在应用程序日志中
- en: Hence, you know that the error is somewhere when writing to the database in
    the `set` section of the code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您知道错误出现在代码的`set`部分写入数据库时。
- en: 'You will see this entry:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到这个条目：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So we know that the error is between this line and the start of the client,
    so the setting of `$host = 'localhost'` must be the offending error. This error
    is not as uncommon as you would think and, as we just saw, could have easily gone
    through QA unless there had been a specific instruction to refresh the browser.
    It could have worked perfectly well for the developer, as they could have a running
    Redis server on the local machine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道错误发生在这一行和客户端开始之间，所以`$host = 'localhost'`的设置必须是错误的原因。这种错误并不像你想象的那样罕见，正如我们刚才看到的，除非有特定的指示刷新浏览器，否则它很容易通过QA。对于开发人员来说，它可能完全正常工作，因为他们可能在本地机器上运行着一个Redis服务器。
- en: 'There are two options to fix this bug we introduced now: we can either navigate
    into the Pod and make the code changes, or we can ask Kubernetes to give us a
    healthy new Pod. It is not recommended to make manual changes to Pods, so we will
    use the second approach. Let''s fix this bug by deleting our faulty Pod:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两种选项来修复这个错误：我们可以进入Pod并进行代码更改，或者我们可以要求Kubernetes为我们提供一个健康的新Pod。不建议对Pod进行手动更改，所以我们将使用第二种方法。让我们通过删除有问题的Pod来修复这个错误：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we have a ReplicaSet that controls our Pods, we should immediately get a
    new Pod that has started from the correct image. Try to connect to the guestbook
    again and verify that messages are persisted across browser refreshes again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个控制我们的Pod的ReplicaSet，我们应该立即获得一个已经从正确的镜像启动的新Pod。尝试再次连接到guestbook并验证消息是否再次在浏览器刷新时保留。
- en: 'The following points summarize some of the common errors and methods to fix
    these errors:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点总结了一些常见的错误和修复这些错误的方法：
- en: Errors can come in many shapes and forms.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误可以呈现多种形式。
- en: Most of the errors encountered by the deployment team are configuration issues.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署团队遇到的大多数错误都是配置问题。
- en: Logs are your friends.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志是你的朋友。
- en: Using `kubectl exec` on a container is a useful debugging tool.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器上使用`kubectl exec`是一个有用的调试工具。
- en: Note that broadly allowing `kubectl exec` is a serious security risk, as it
    pretty much lets the Kubernetes operator do what they want in the Pods they have
    access to.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，广泛允许`kubectl exec`是一个严重的安全风险，因为它几乎让Kubernetes操作员在他们可以访问的Pod中做任何他们想做的事情。
- en: Anything printed to `stdout` and `stderr` shows up in the logs (independent
    of the application/language/logging framework).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何打印到`stdout`和`stderr`的内容都会显示在日志中（与应用程序/语言/日志框架无关）。
- en: We introduced an application error to the guestbook application and were able
    to leverage Kubernetes logs to pinpoint the issue in the code. In the next section,
    we will look into a powerful mechanism in Kubernetes called *Readiness and liveness
    probes*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在guestbook应用程序中引入了一个应用程序错误，并且能够利用Kubernetes日志来准确定位代码中的问题。在下一节中，我们将探讨Kubernetes中一个强大的机制，称为*就绪和活跃探针*。
- en: Readiness and liveness probes
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就绪和活跃探针
- en: We touched upon readiness probes briefly in the previous section. In this section,
    we'll explore them in more depth.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中简要提到了就绪探针。在本节中，我们将更深入地探讨它们。
- en: 'Kubernetes uses liveness and readiness probes to monitor the availability of
    your applications. Each probe serves a different purpose:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用活跃探针和就绪探针来监视应用程序的可用性。每个探针都有不同的目的：
- en: A **liveness probe** monitors the availability of an application while it is
    running. If a liveness probe fails, Kubernetes will restart your Pod. This could
    be useful to catch deadlocks, infinite loops, or just a "stuck" application.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃探针**在应用程序运行时监视可用性。如果活跃探针失败，Kubernetes将重新启动您的Pod。这对于捕获死锁、无限循环或者只是“卡住”的应用程序可能非常有用。'
- en: A **readiness probe** monitors when your application becomes available. If a
    readiness probe fails, Kubernetes will not send any traffic to unready Pods. This
    is useful if your application has to go through some configuration before it becomes
    available, or if your application could become overloaded but recover from the
    additional load.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**就绪探针**监视应用程序何时变得可用。如果就绪探针失败，Kubernetes将不会向未准备好的Pod发送任何流量。如果您的应用程序在变得可用之前必须经过一些配置，或者如果您的应用程序可能会过载但可以从额外的负载中恢复，这将非常有用。
- en: Liveness and readiness probes don't need to be served from the same endpoint
    in your application. If you have a smart application, that application could take
    itself out of rotation (meaning no more traffic is sent to the application) while
    still being healthy. To achieve this, it would have the readiness probe fail,
    but have the liveness probe remain active.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃和就绪探针不需要从应用程序的同一端点提供服务。如果您有一个智能应用程序，该应用程序可以在仍然健康的情况下将自身从轮换中移出（意味着不再向应用程序发送流量）。为了实现这一点，就绪探针将失败，但活跃探针仍然保持活动状态。
- en: Let's build this out in an example. We will create two nginx Deployments, each
    with an index page and a health page. The index page will serve as the liveness
    probe.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来构建这个部署。我们将创建两个nginx部署，每个部署都有一个索引页面和一个健康页面。索引页面将作为活跃探针。
- en: Building two web containers
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建两个web容器
- en: 'For this example, we''ll use a couple of web pages that we''ll use to connect
    to our readiness and liveness probes. Let''s first create `index1.html`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一对网页来连接到我们的就绪和活跃探针。让我们首先创建`index1.html`：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, create `index2.html`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建`index2.html`：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s also create a health page, `healthy.html`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个健康页面，`healthy.html`：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the next step, we''ll mount these files to our Kubernetes Deployments. We''ll
    turn each of these into a `configmap` that we connect to our Pods. Use the following
    commands to create the configmap:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将把这些文件挂载到我们的Kubernetes部署中。我们将把每个文件都转换成一个`configmap`，然后连接到我们的Pods。使用以下命令创建configmap：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With that out of the way, we can go ahead and create our two web Deployments.
    Both will be very similar, with just the `configmap` changing. The first Deployment
    file (`webdeploy1.yaml`) looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了这些，我们可以继续创建我们的两个web部署。两者将非常相似，只是`configmap`不同。第一个部署文件（`webdeploy1.yaml`）如下所示：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are a few things to highlight in this Deployment:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部署中有一些要强调的事项：
- en: '**Lines 23-28**:This is the liveness probe. The liveness probe points to the
    health page. Remember, if the health page fails, the container will be restarted.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第23-28行：这是活跃探针。活跃探针指向健康页面。请记住，如果健康页面失败，容器将被重新启动。
- en: '**Lines 29-32**: This is the readiness probe. The readiness probe in our case
    points to the index page. If this page fails, the Pod will temporarily not be
    sent any traffic but will remain running.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第29-32行：这是就绪探针。在我们的情况下，就绪探针指向索引页面。如果此页面失败，Pod将暂时不会收到任何流量，但将继续运行。
- en: '**Lines 44-45**: These two lines contain a couple of commands that get executed
    when our container starts. Instead of simply running the nginx server, we copy
    the index and ready files in the right location, then start nginx, and then use
    a sleep command (so our container keeps running).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第44-45行：这两行包含一对在容器启动时执行的命令。我们不仅仅运行nginx服务器，而是将索引和就绪文件复制到正确的位置，然后启动nginx，然后使用一个睡眠命令（这样我们的容器就会继续运行）。
- en: 'You can create this Deployment using the following command. You can also deploy
    the second version for server 2, which is similar to server 1:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令创建此部署。您还可以部署类似于服务器1的第二个版本，用于服务器2：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we will also create a Service that routes traffic to both Deployments
    (`webservice.yaml`):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将创建一个服务，将流量路由到两个部署（`webservice.yaml`）：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can create that Service using the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建该服务：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now have our application up and running. In the next section, we'll introduce
    some failures to verify the behavior of liveness and readiness probes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的应用程序已经启动运行。在接下来的部分，我们将引入一些故障来验证活跃性和就绪探针的行为。
- en: Experimenting with liveness and readiness probes
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试活跃性和就绪探针
- en: In the previous section, we explained the functionality of the liveness and
    readiness probes and created a sample application. In this section, we will introduce
    errors in our application and verify the behavior of the liveness and readiness
    probes. We will see how a failure of the readiness probe will cause the Pod to
    remain running but no longer accept traffic. After that, we will see how a failure
    of the liveness probe will cause the Pod to be restarted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们解释了活跃性和就绪探针的功能，并创建了一个示例应用程序。在本节中，我们将在应用程序中引入错误，并验证活跃性和就绪探针的行为。我们将看到就绪探针的失败将导致Pod保持运行，但不再接受流量。之后，我们将看到活跃性探针的失败将导致Pod被重新启动。
- en: Let's start by failing the readiness probe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试使就绪探针失败。
- en: '**Failing the readiness probe causes traffic to temporarily stop**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**使就绪探针失败会导致流量暂时停止**'
- en: 'Now that we have a simple application up and running, we can experiment with
    the behavior of the liveness and readiness probes. To start, let''s get our Service''s
    external IP to connect to our web server using the browser:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的应用程序正在运行，我们可以尝试活跃性和就绪探针的行为。首先，让我们获取服务的外部IP以便使用浏览器连接到我们的Web服务器：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you hit the external IP in the browser, you should see a single line that
    either says **Server 1** or **Server 2**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中输入外部IP，您应该看到一个单行，上面要么写着**服务器1**，要么写着**服务器2**：
- en: '![The browser showing the external IP and that the application is returning
    traffic from server 2.](image/Figure_7.15.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器显示外部IP和应用程序正在从服务器2返回流量。](image/Figure_7.15.jpg)'
- en: 'Figure 7.15: Our application is returning traffic from server 2'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：我们的应用程序正在从服务器2返回流量
- en: 'During our tests, we''ll use a small script called `testWeb.sh` to connect
    to our web page 50 times, so we can monitor a good distribution of results between
    server 1 and 2\. We''ll first need to make that script executable, and then we
    can run that script while our Deployment is fully healthy:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将使用一个名为`testWeb.sh`的小脚本连接到我们的网页50次，这样我们就可以监视服务器1和2之间结果的良好分布。我们首先需要使该脚本可执行，然后我们可以在我们的部署完全健康的情况下运行该脚本：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'During healthy operations, we can see that server 1 and server 2 are hit almost
    equally, with `24` hits for server 1, and `26` for server 2:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在健康运行期间，我们可以看到服务器1和服务器2几乎被同等命中，服务器1有24次命中，服务器2有26次命中：
- en: '![The output showing the hit instances for server 1 and server 2 as 24, 48,
    216 and 26, 52, 234 respectively.](image/Figure_7.16.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示服务器1和服务器2的命中实例分别为24、48、216和26、52、234。](image/Figure_7.16.jpg)'
- en: 'Figure 7.16: While the application is healthy, traffic is load-balanced between
    server 1 and server 2'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：当应用程序健康时，流量在服务器1和服务器2之间进行负载平衡
- en: 'Let''s now move ahead and fail the readiness probe in server 1\. To do this,
    we will `exec` into the container and move the index file to a different location:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续并使服务器1的就绪探针失败。为此，我们将`exec`进入容器并将索引文件移动到另一个位置：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once this is executed, we can view the change in the Pod status with the following
    command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了这个，我们可以用以下命令查看Pod状态的变化：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the readiness state of the server 1 Pod change to `0/1`, as
    shown in *Figure 7.17*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到服务器1 Pod的就绪状态更改为`0/1`，如*图7.17*所示：
- en: '![Output of the kubectl get pods -w command showing the readiness state of
    the server 1 Pod changing to 0/1.](image/Figure_7.17.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get pods -w命令的输出显示服务器1的就绪状态变为0/1。](image/Figure_7.17.jpg)'
- en: 'Figure 7.17: The failing readiness probes causes server 1 to not have any READY
    containers'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.17：失败的就绪探针导致服务器1没有任何READY容器
- en: 'This should direct no more traffic to the server 1 Pod. Let''s verify:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该不再将流量定向到服务器1的Pod。让我们验证一下：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our case, traffic is indeed redirected to server 2:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，流量确实被重定向到了服务器2：
- en: '![Output showing that all the traffic is directed to server 2 and the traffic
    for server 1 is zero.](image/Figure_7.18.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示所有流量都被定向到服务器2，服务器1的流量为零。](image/Figure_7.18.jpg)'
- en: 'Figure 7.18: All traffic is now served by server 2'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.18：现在所有流量都由服务器2提供
- en: 'We can now restore the state of server 1 by moving the file back to its rightful
    place:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将文件移回到其正确位置来恢复服务器1的状态：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will return our Pod to a healthy state, and should again split traffic
    equally:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的Pod恢复到健康状态，并应该再次平均分配流量：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will show an output similar to *Figure 7.19*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似于*图7.19*的输出：
- en: '![Output showing the readiness probe causing traffic to be load-balanced again
    between server 1 and server 2.](image/Figure_7.19.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示就绪探针导致流量再次在服务器1和服务器2之间进行负载均衡。](image/Figure_7.19.jpg)'
- en: 'Figure 7.19: Restoring the readiness probe causes traffic to be load-balanced
    again'
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.19：恢复就绪探针会导致流量再次进行负载均衡
- en: A failing readiness probe will cause Kubernetes to no longer send traffic to
    the failing Pod. We have verified this by causing a readiness probe in our example
    application to fail. In the next section, we'll explore the impact of a failing
    liveness probe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的就绪探针将导致Kubernetes不再向失败的Pod发送流量。我们通过使示例应用程序中的就绪探针失败来验证了这一点。在下一节中，我们将探讨失败的活跃探针的影响。
- en: '**A failing liveness probe causes container restart**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**失败的活跃探针导致容器重新启动**'
- en: 'We can repeat the previous process as well with the liveness probe. When the
    liveness probe fails, we are expecting Kubernetes to go ahead and restart our
    Pod. Let''s try this  by deleting the health file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用活跃探针重复之前的过程。当活跃探针失败时，我们期望Kubernetes会继续重启我们的Pod。让我们尝试通过删除健康文件来实现这一点：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s see what this does with our Pod:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这对我们的Pod有什么影响：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We should see that the Pod restarts within a couple of seconds:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到Pod在几秒钟内重新启动：
- en: '![Using kubectl get pods -w to track the status of the pods. The image shows
    that server1 is restarted by incrementing the restarts counter from 0 to 1.](image/Figure_7.20.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get pods -w跟踪Pod状态的图像。图像显示服务器1通过将重启计数器从0增加到1来重新启动。](image/Figure_7.20.jpg)'
- en: 'Figure 7.20: A failing liveness probe will cause the Pod to be restarted'
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.20：失败的活跃探针将导致Pod重新启动
- en: 'As you can see in *Figure 7.20*, the Pod was successfully restarted, with limited
    impact. We can inspect what was going on in the Pod by running a `describe` command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*图7.20*中所看到的，Pod已成功重新启动，影响有限。我们可以通过运行`describe`命令来检查Pod中发生了什么：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding command will give you an output similar to *Figure 7.21*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将给出类似于*图7.21*的输出：
- en: '![Output of the kubectl describe pod command provides additional details on
    the Pod and showing how the liveness probe failed.](image/Figure_7.21.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl describe pod命令的输出提供了有关Pod的额外细节，并显示了活跃探针的失败情况。](image/Figure_7.21.jpg)'
- en: 'Figure 7.21: More details on the Pod showing how the liveness probe failed'
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.21：有关Pod的更多详细信息，显示了活跃探针的失败情况
- en: In the `describe` command, we can clearly see that the Pod failed the liveness
    probe. After four failures, the container was killed and restarted.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`describe`命令中，我们可以清楚地看到Pod未通过活跃探针。在四次失败后，容器被终止并重新启动。
- en: 'This concludes our experiment with liveness and readiness probes. Remember
    that both are useful for your application: a readiness probe can be used to temporarily
    stop traffic to your Pod, so it has to suffer less load. A liveness probe is used
    to restart your Pod if there is an actual failure in your Pod.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对活跃性和就绪性探针的实验。请记住，这两者对您的应用程序都很有用：就绪性探针可用于暂时停止流量到您的Pod，以便它承受更少的负载。活跃性探针用于在Pod出现实际故障时重新启动Pod。
- en: 'Let''s also make sure to clean up the Deployments we just created:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也确保清理我们刚刚创建的部署：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Liveness and readiness probes are useful to ensure only healthy Pods will receive
    traffic in your cluster. In the next section, we will explore different metrics
    reported by Kubernetes that you can use to verify the state of your application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃性和就绪性探针对确保只有健康的Pod会在您的集群中接收流量很有用。在下一节中，我们将探索Kubernetes报告的不同指标，您可以使用这些指标来验证应用程序的状态。
- en: Metrics reported by Kubernetes
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes报告的指标
- en: Kubernetes reports multiple metrics. In this section, we'll first use a number
    of kubectl commands to get these metrics. Afterward, we'll look into Azure Monitor
    for containers to see how Azure helps with container monitoring.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes报告多个指标。在本节中，我们首先将使用一些kubectl命令来获取这些指标。之后，我们将研究Azure容器监视器，看看Azure如何帮助容器监视。
- en: Node status and consumption
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点状态和消耗
- en: The nodes in your Kubernetes are the servers running your application. Kubernetes
    will schedule Pods to different nodes in the cluster. You need to monitor the
    status of your nodes to ensure that the nodes themselves are healthy and that
    the nodes have enough resources to run new applications.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Kubernetes中的节点是运行应用程序的服务器。Kubernetes将Pod调度到集群中的不同节点。您需要监视节点的状态，以确保节点本身健康，并且节点有足够的资源来运行新应用程序。
- en: 'Run the following command to get information about the nodes on the cluster:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以获取有关集群上节点的信息：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding command lists their name, status, and age:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令列出它们的名称、状态和年龄：
- en: '![Output for the kubectl get nodes command listing the name, status, and age
    of the nodes.](image/Figure_7.22.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get nodes命令的输出，列出节点的名称、状态和年龄。](image/Figure_7.22.jpg)'
- en: 'Figure 7.22: There are two nodes in this cluster'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.22：此集群中有两个节点
- en: 'You can get more information by passing the `-o` wide option:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递`-o` wide选项来获取更多信息：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output lists the underlying `OS-IMAGE` and `INTERNAL-IP`, and other useful
    information, which can be viewed in *Figure 7.23*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了底层的`OS-IMAGE`和`INTERNAL-IP`，以及其他有用的信息，可以在*图7.23*中查看。
- en: '![Output of the kubectl get -o wide nodes command displaying additional information
    about the nodes such asinternal IP, external IP, Kernel version, and container
    runtime.](image/Figure_7.23.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get -o wide nodes命令的输出，显示节点的额外信息，如内部IP、外部IP、内核版本和容器运行时。](image/Figure_7.23.jpg)'
- en: 'Figure 7.23: Using -o wide adds more details about our nodes'
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.23：使用-o wide可以添加关于我们节点的更多细节
- en: 'You can find out which nodes are consuming the most resources by using the
    following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令找出哪些节点消耗了最多的资源：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It shows the CPU and memory usage of the nodes:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了节点的CPU和内存使用情况：
- en: '![Output of the kubectl top nodes command displaying the CPU and memory utilization
    of the nodes.](image/Figure_7.24.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl top nodes命令的输出，显示节点的CPU和内存利用率。](image/Figure_7.24.jpg)'
- en: 'Figure 7.24: CPU and memory utilization of the nodes'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.24：节点的CPU和内存利用率
- en: 'Note that this is the actual consumption at that point in time, not the number
    of requests a certain node has. To get the requests, you can execute:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是那一时刻的实际消耗，而不是某个节点的请求数。要获取请求数，您可以执行：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will show you the requests and limits per Pod, as well as the cumulative
    amount for the whole node:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您显示每个Pod的请求和限制，以及整个节点的累积量：
- en: '![Output showing the number of requests and limits a specific node has assigned
    to it.](image/Figure_7.25.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![显示特定节点分配的请求和限制数量的输出。](image/Figure_7.25.jpg)'
- en: 'Figure 7.25: Describing the nodes shows details on requests and limits'
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.25：描述节点显示有关请求和限制的详细信息
- en: You now know where you can find information about the utilization of your nodes.
    In the next section, we will look into how you can get the same metrics for individual
    Pods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道在哪里可以找到有关节点利用率的信息。在下一节中，我们将探讨如何获取单个Pod的相同指标。
- en: Pod consumption
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod消耗
- en: Pods consume CPU and memory resources from an AKS cluster. Requests and limits
    are used to configure how much CPU and memory a Pod can consume. Requests are
    used to reserve a minimum amount of CPU and memory, while limits are used to set
    a maximum amount of CPU and memory per Pod.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Pods从AKS集群中消耗CPU和内存资源。请求和限制用于配置Pod可以消耗多少CPU和内存。请求用于保留最小数量的CPU和内存，而限制用于设置每个Pod的最大CPU和内存量。
- en: In this section, we will explore how we can use `kubectl` to get information
    about the CPU and memory utilization of Pods.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用`kubectl`获取有关Pod的CPU和内存利用率的信息。
- en: 'Let''s start by exploring how we can see the requests and limits for a Pod
    that we currently have running:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探索如何查看当前正在运行的Pod的请求和限制：
- en: 'For this example, we will use the Pods running in the `kube-system` namespace.
    Get all the Pods in this namespace:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用在`kube-system`命名空间中运行的Pods。获取此命名空间中的所有Pods：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should show something similar to *Figure 7.26*:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示类似于*图7.26*的内容：
- en: '![Using kubectl get pods -n kube-system to list of all the pods in the in the
    kube-system namespace with their name, status, number of restarts, and age.](image/Figure_7.26.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get pods -n kube-system列出kube-system命名空间中所有Pod的名称、状态、重启次数和年龄。](image/Figure_7.26.jpg)'
- en: 'Figure 7.26: The Pods running in the kube-system namespace'
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.26：在kube-system命名空间中运行的Pods
- en: 'Let''s get the requests and limits for one of the `coredns` Pods. This can
    be done using the `describe` command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取`coredns` Pods之一的请求和限制。可以使用`describe`命令来完成：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `describe` command, there should be a section similar to *Figure 7.27*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`describe`命令中，应该有一个类似于*图7.27*的部分：
- en: '![The describe command showing the limits and requests for the CoreDNS Pod.](image/Figure_7.27.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![显示CoreDNS Pod的限制和请求的describe命令。](image/Figure_7.27.jpg)'
- en: 'Figure 7.27: Limits and requests for the CoreDNS Pod'
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.27：CoreDNS Pod的限制和请求
- en: This shows us that this Pod has a memory limit of `170Mi`, no CPU limit, and
    has a request for 100m CPU (which means 0.1 CPU) and `70Mi` of memory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们显示，此Pod的内存限制为`170Mi`，没有CPU限制，并且请求了100m CPU（即0.1 CPU）和`70Mi`内存。
- en: 'Requests and limits are used to perform capacity management in a cluster. We
    can also get the actual CPU and memory consumption of a Pod by running the following
    command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和限制用于在集群中执行容量管理。我们还可以通过运行以下命令获取Pod的实际CPU和内存消耗：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This should show you the output similar to *Figure 7.28*:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向您显示类似于*图7.28*的输出：
- en: '![Output of the kubectl top pods -n kube-system command showing the CPU and
    memory consumption of Pods.](image/Figure_7.28.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![显示Pod的CPU和内存消耗的kubectl top pods -n kube-system命令的输出。](image/Figure_7.28.jpg)'
- en: 'Figure 7.28: Seeing the CPU and memory consumption of Pods'
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.28：查看Pod的CPU和内存消耗
- en: Using the `kubectl top` command shows the CPU and memory consumption at the
    point in time when the command was run. In this case, we can see that the `coredns`
    Pods are using `2m` and `3m` CPU and are using `21Mi` and `17Mi` of memory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl top命令显示了命令运行时的CPU和内存消耗。在这种情况下，我们可以看到coredns Pods正在使用2m和3m的CPU，并且正在使用21Mi和17Mi的内存。
- en: In this section, we have been using the `kubectl` command to get an insight
    into the resource utilization of the nodes and Pods in our cluster. This is useful
    information, but it is limited to that specific point in time. In the next section,
    we'll use Azure Monitor to get more detailed information on the cluster and the
    applications on top of the cluster.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们一直在使用kubectl命令来了解集群中节点和Pods的资源利用情况。这是有用的信息，但仅限于特定时间点。在下一节中，我们将使用Azure
    Monitor来获取有关集群和集群上应用程序的更详细信息。
- en: Metrics reported from Azure Monitor
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自Azure Monitor的报告指标
- en: The Azure portal shows many of the metrics that you would like to see combined
    with authorization, as only personnel with access to the portal can see these
    metrics.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Azure门户显示了许多指标，您希望将其与授权结合在一起，因为只有具有门户访问权限的人员才能查看这些指标。
- en: AKS Insights
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AKS Insights
- en: The **Insights** section of the AKS blade provides most of the metrics you need
    to know about your cluster. It also has the ability to drill down to the container
    level. You can also see the logs of the container.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: AKS刀片的Insights部分提供了您需要了解有关集群的大多数指标。它还具有深入到容器级别的能力。您还可以查看容器的日志。
- en: Kubernetes makes metrics available but doesn't store them. Azure Monitor can
    be used to store these metrics and make them available to query over time. To
    collect the relevant metrics and logs into Insights, Azure connects to the Kubernetes
    API to collect the metrics and then stores them in Azure Monitor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了可用的指标，但不会存储它们。Azure Monitor可用于存储这些指标，并使它们随时间可用于查询。为了将相关指标和日志收集到Insights中，Azure连接到Kubernetes
    API来收集指标，然后将其存储在Azure Monitor中。
- en: Note
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Logs of a container could contain sensitive information. Therefore, the rights
    to review logs should be controlled and audited.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的日志可能包含敏感信息。因此，应控制和审计查看日志的权限。
- en: Let's explore the **Insights** tab of the AKS blade. We'll start with the cluster
    metrics.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索AKS刀片的Insights选项卡。我们将从集群指标开始。
- en: '**Cluster metrics**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 集群指标
- en: '**Insights** shows the cluster metrics. *Figure 7.29* shows the CPU utilization
    and the memory utilization of all the nodes in the cluster:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Insights显示集群指标。图7.29显示了集群中所有节点的CPU利用率和内存利用率：
- en: '![The Cluster tab in the Insights blade shows the cluster metrics. It displays
    two graphs: the CPU utilization and the memory utilization of all the nodes in
    the cluster.](image/Figure_7.29.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![Insights选项卡中的Cluster选项卡显示了集群指标。它显示了两个图表：集群中所有节点的CPU利用率和内存利用率。](image/Figure_7.29.jpg)'
- en: 'Figure 7.29: The Cluster tab shows CPU and memory utilization for the cluster'
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.29：Cluster选项卡显示了集群的CPU和内存利用率
- en: 'The cluster metrics also show the node count and the number of active Pods.
    The node count is very important, as you can track whether you have any nodes
    that are in a **Not Ready** state:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 集群指标还显示了节点计数和活动Pods的数量。节点计数非常重要，因为您可以跟踪是否有节点处于Not Ready状态：
- en: '![The Cluster tab displaying two additional graphs: the node count and the
    number of active Pods.](image/Figure_7.30.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![Cluster选项卡显示两个额外的图表：节点计数和活动Pods的数量。](image/Figure_7.30.jpg)'
- en: 'Figure 7.30: The Cluster tab shows the node count and the number of active
    Pods'
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.30：Cluster选项卡显示了节点计数和活动Pods的数量
- en: The **Cluster** tab can be used to monitor the status of the nodes in the cluster.
    Next, we'll explore the **Health** tab.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Cluster选项卡可用于监视集群中节点的状态。接下来，我们将探索Health选项卡。
- en: '**Using the Health tab**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用健康选项卡**'
- en: 'The **Health** tab was in preview at the time of writing this book. This tab
    shows you a view of your cluster health. To show you this status, Azure monitors
    and checks the required infrastructure components as well as node health:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，“健康”选项卡处于预览状态。该选项卡显示了集群健康状况的视图。为了向您显示这一状态，Azure监视并检查所需的基础设施组件以及节点健康状况：
- en: '![A view of the Health tab showing the overall health of the cluster. All the
    health metrics are marked green for this cluster.](image/Figure_7.31.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![健康选项卡的视图显示了集群的整体健康状况。该集群的所有健康指标都标记为绿色。](image/Figure_7.31.jpg)'
- en: 'Figure 7.31: The Health tab shows the overall health of the cluster'
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.31：健康选项卡显示了集群的整体健康状况
- en: The **Health** tab is useful for tracking the overall health of your cluster.
    The next tab we'll explore is the **Nodes** tab..
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: “健康”选项卡对于跟踪集群的整体健康状况非常有用。我们将要探索的下一个选项卡是“节点”选项卡。
- en: '**Nodes**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点**'
- en: 'The **Nodes** view shows you detailed metrics for your nodes. It also shows
    you which Pods are running on each node, as we can see in *Figure 7.32*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: “节点”视图向您显示了节点的详细指标。它还向您显示了每个节点上运行的Pods，正如我们在*图7.32*中所看到的：
- en: '![The Nodes view pane showing the detailed metrics for the pods running on
    each of the nodes.](image/Figure_7.32.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![节点视图窗格显示了每个节点上运行的Pod的详细指标。](image/Figure_7.32.jpg)'
- en: 'Figure 7.32: Detailed metrics of the nodes in the Nodes view pane'
  id: totrans-341
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.32：节点视图窗格中节点的详细指标
- en: 'If you want even more details, you can click through and get Kubernetes event
    logs from your nodes as well:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更多细节，您还可以单击并从节点获取Kubernetes事件日志：
- en: '![The View Kubernetes event logs option in the right-hand pane allowing to
    get the logs from a cluster.](image/Figure_7.33.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![右侧窗格中的查看Kubernetes事件日志选项允许从集群获取日志。](image/Figure_7.33.jpg)'
- en: 'Figure 7.33: Click on View Kubernetes event logs to get the logs from a cluster'
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.33：单击“查看Kubernetes事件日志”以从集群获取日志
- en: 'This will open Azure Log Analytics and will have pre-created a query for you
    that shows the logs for your node. In our case, we can see that our nodes have
    been rebooted a couple of times:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开Azure Log Analytics，并为您预先创建一个查询，显示节点的日志。在我们的情况下，我们可以看到我们的节点已经重新启动了几次：
- en: '![The Log Analytics showing the logs for the nodes.](image/Figure_7.34.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![Log Analytics显示了节点的日志。](image/Figure_7.34.jpg)'
- en: 'Figure 7.34: Log Analytics showing the logs for the nodes'
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.34：Log Analytics显示了节点的日志
- en: '**Controllers**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**'
- en: 'The **Controllers** view shows you details on all the controllers (that is,
    ReplicaSet, DaemonSet, and so on) on your cluster and the Pods running in them.
    This shows you a controller-centric view of running containers. For instance,
    you can find the frontend ReplicaSet and see all the Pods and containers running
    in it, as shown in *Figure 7.35*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: “控制器”视图向您显示了集群中所有控制器（即ReplicaSet、DaemonSet等）的详细信息以及其中运行的Pods。这向您展示了一个以控制器为中心的运行容器的视图。例如，您可以找到前端ReplicaSet并查看其中运行的所有Pods和容器，如*图7.35*所示：
- en: '![All the containers running in a ReplicaSet with their name and status, displayed
    in the Controller tab.](image/Figure_7.35.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![在控制器选项卡中显示的具有名称和状态的ReplicaSet中运行的所有容器。](image/Figure_7.35.jpg)'
- en: 'Figure 7.35: The Controller tab shows us all the containers running in a ReplicaSet'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.35：控制器选项卡向我们显示了ReplicaSet中运行的所有容器
- en: The next tab is the **Containers** tab, which will show us the metrics, logs,
    and environment variables for a container.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的选项卡是“容器”选项卡，它将向我们显示容器的指标、日志和环境变量。
- en: '**Container metrics, logs, and environment variables**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器指标、日志和环境变量**'
- en: Clicking on the **Containers** tab lists the container metrics, environment
    variables, and access to its logs, as shown in *Figure 7.36:*
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“容器”选项卡会列出容器指标、环境变量以及访问其日志，如*图7.36*所示：
- en: '![The Containers tab showing all the individual containers.](image/Figure_7.36.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![容器选项卡显示了所有单独的容器。](image/Figure_7.36.jpg)'
- en: 'Figure 7.36: The Containers tab shows us all the individual containers'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.36：容器选项卡显示了所有单独的容器
- en: Note
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You might notice a couple of containers with an `Unknown` state. This is to
    be expected in our situation. Our time range in Azure Monitor is set to the last
    6 hours, and in the past 6 hours, we have created and deleted a number of Pods.
    They no longer exist, but Azure Monitor knows of their existence and even kept
    logs for them.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到一些容器处于“未知”状态。在我们的情况下，这是可以预料的。在Azure Monitor中，我们的时间范围设置为过去6小时，在过去6小时内，我们创建并删除了许多Pod。它们不再存在，但Azure
    Monitor知道它们的存在，甚至为它们保留了日志。
- en: 'We can get access to our container''s logs from this view:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个视图中访问我们容器的日志：
- en: '![Option in the containers tab to access the container''s logs.](image/Figure_7.37.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![在容器选项卡中访问容器的日志的选项。](image/Figure_7.37.jpg)'
- en: 'Figure 7.37: Access the container''s logs'
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.37：访问容器的日志
- en: 'This shows us all the logs that Kubernetes logged from our application. We
    accessed these logs manually earlier in this chapter. Using this approach can
    be a lot more productive, as we can edit the log queries and correlate logs from
    different Pods and applications in a single view:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了Kubernetes从我们的应用程序中记录的所有日志。我们在本章前面手动访问了这些日志。使用这种方法可能会更加高效，因为我们可以编辑日志查询并在单个视图中关联来自不同Pod和应用程序的日志：
- en: '![Editing the log queries and correlating logs from different Pods and applications
    in a single view through the Logs window.](image/Figure_7.38.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![通过日志窗口编辑日志查询并在单个视图中关联来自不同Pod和应用程序的日志。](image/Figure_7.38.jpg)'
- en: 'Figure 7.38: Logs are collected and can be queried'
  id: totrans-364
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.38：日志已被收集并可以查询
- en: 'Apart from the logs, this view also shows the environment variables that are
    set for the container. To see the environment variables, scroll down in the right
    cell of this view:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日志之外，这个视图还显示了为容器设置的环境变量。要查看环境变量，请在此视图的右侧单元格中向下滚动：
- en: '![Displaying the environment variables set for the container by scrolling down
    in the right cell of the Logs view.](image/Figure_7.39.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![通过在日志视图的右侧单元格中向下滚动来显示为容器设置的环境变量。](image/Figure_7.39.jpg)'
- en: 'Figure 7.39: The environment variables set for the container'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.39：为容器设置的环境变量
- en: 'And that concludes this section. Let''s make sure to clean up our Deployments
    so we can continue with a clean guestbook in the next chapter:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以上就是本节的内容。让我们确保清理我们的部署，这样我们就可以在下一章中继续使用一个干净的留言板：
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this section, we explored monitoring applications running on top of Kubernetes.
    We used the AKS **Insights** tab in the Azure portal to get a detailed view of
    our cluster and the containers running on our cluster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在Kubernetes上运行的应用程序的监控。我们在Azure门户中使用AKS **Insights**选项卡来详细查看我们的集群和运行在集群上的容器。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We started the chapter by showing how to use different `kubectl` commands to
    monitor an application. Then, we showed how the logs Kubernetes creates can be
    used to debug that application. The logs contain all the information that is written
    to `stdout` and `stderr`. Lastly, we explained the use of Azure Monitor to show
    the AKS metrics and environment variables, as well as logs with log filtering.
    We also showed how to debug application and cluster issues by using `kubectl`
    and Azure Monitor monitoring.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时展示了如何使用不同的`kubectl`命令来监视应用程序。然后，我们展示了Kubernetes创建的日志如何用于调试该应用程序。日志包含写入`stdout`和`stderr`的所有信息。最后，我们解释了使用Azure
    Monitor来显示AKS指标和环境变量，以及使用日志过滤显示日志。我们还展示了如何使用`kubectl`和Azure Monitor监控来调试应用程序和集群问题。
- en: In the next chapter, we will learn how to connect an AKS cluster to Azure PaaS
    services. We will specifically focus on how you can connect an AKS cluster to
    a MySQL database managed by Azure.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将AKS集群连接到Azure PaaS服务。我们将重点关注如何将AKS集群连接到Azure管理的MySQL数据库。
