- en: Refactoring Legacy Code – Making It Young Again
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构遗留代码-使其年轻化
- en: TDD may not adjust to legacy code straight away. You may have to fiddle a bit
    with the steps to make it work. Understand that your TDD may change in this case,
    because somehow, you are no longer performing the TDD you were used to. This chapter
    will introduce you to the world of legacy code, taking as much as we can from
    TDD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TDD可能不会立即适应遗留代码。你可能需要稍微调整一下步骤才能使其工作。要明白，在这种情况下，你的TDD可能会发生变化，因为你不再执行你习惯的TDD。本章将向你介绍遗留代码的世界，尽可能多地从TDD中获取。
- en: We'll start afresh, with a legacy application that is currently in production.
    We'll alter it in small ways without introducing defects or regressions, and we'll
    even have time to have an early lunch!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从头开始，处理目前正在生产中的遗留应用程序。我们将以微小的方式进行修改，而不引入缺陷或回归，甚至有时间提前吃午饭！
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Legacy code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗留代码
- en: Dealing with legacy code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理遗留代码
- en: REST communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST通信
- en: Dependency injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Tests at different levels: end-to-end, integration, and unit'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同级别的测试：端到端、集成和单元
- en: Legacy code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗留代码
- en: 'Let''s start with the definition of legacy code. While there are many authors
    with different definitions, such as lack of trust in your application or your
    tests, code that is no longer supported, and so on. We like the one created by
    Michael Feathers the most:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从遗留代码的定义开始。虽然有许多作者对此有不同的定义，比如对应用程序或测试的不信任、不再受支持的代码等等。我们最喜欢迈克尔·菲瑟斯创造的定义：
- en: '"Legacy code is code without tests. The reason for this definition is that
    it is objective: either there are or there aren''t tests."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"遗留代码是没有测试的代码。这个定义的原因是客观的：要么有测试，要么没有测试。"'
- en: – Michael Feathers
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '- 迈克尔·菲瑟斯'
- en: How do we detect legacy code? Although legacy code usually equates to bad code,
    Michael Feathers exposes some smells in his book, *Working Effectively with Legacy*
    *Code*, by Dorling Kindersley (India) Pvt. Ltd. (1993).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何检测遗留代码？尽管遗留代码通常等同于糟糕的代码，但迈克尔·菲瑟斯在他的书《与遗留代码有效地工作》中揭露了一些问题，由Dorling Kindersley（印度）私人有限公司（1993年）出版。
- en: '**Code smell**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码异味**。'
- en: Smells are certain structures in the code that indicate violation of fundamental
    design principles and negatively impact design quality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是指代码中的某些结构，表明违反了基本设计原则，并对设计质量产生了负面影响。
- en: Code smells are usually not bugs—they are not technically incorrect and do not
    currently prevent the program from functioning. Instead, they indicate weaknesses
    in design that may be slowing down development or increasing the risk of bugs
    or failures in the future.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味通常不是错误——它们在技术上不是不正确的，也不会阻止程序当前的运行。相反，它们表明设计上的弱点可能会减缓开发速度或增加将来出现错误或故障的风险。
- en: 'Source: [http://en.wikipedia.org/wiki/Code_smell](http://en.wikipedia.org/wiki/Code_smell).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://en.wikipedia.org/wiki/Code_smell](http://en.wikipedia.org/wiki/Code_smell)。
- en: One of the common smells for legacy code is *I can't test this code*. It is
    accessing outside resources, introducing other side effects, using a new operator,
    and so on. In general, good design is easy to test. Let's see some legacy code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留代码的常见问题之一是*我无法测试这段代码*。它正在访问外部资源，引入其他副作用，使用新的操作符等。一般来说，良好的设计易于测试。让我们看一些遗留代码。
- en: Legacy code example
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗留代码示例
- en: 'Software concepts are often easiest to explain through code, and this one is
    no exception. We have seen and worked with the Tic-Tac-Toe application (see [Chapter
    3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor – From Failure
    Through Success until Perfection*). The following code performs position validation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件概念通常通过代码最容易解释，这个也不例外。我们已经看到并使用了井字棋应用程序（参见[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)，*红-绿-重构-从失败到成功直至完美*）。以下代码执行位置验证：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The specification that corresponds with this code is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与此代码对应的规范如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The JaCoCo report indicates that everything is covered (except the last line,
    the method''s closing bracket):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo报告表明一切都被覆盖了（除了最后一行，方法的结束括号）：
- en: '![](img/5ab5211c-027a-4b93-ad7c-e7b568e5a1c3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ab5211c-027a-4b93-ad7c-e7b568e5a1c3.png)'
- en: 'As we believe we have good coverage, we can perform an automatic and safe refactor
    (fragment):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们相信我们有很好的覆盖率，我们可以进行自动和安全的重构（片段）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code should be ready, as the tests are successful and it has very good
    test coverage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该准备好了，因为测试成功，并且测试覆盖率非常高。
- en: Maybe you have already realized as much, but there is a catch. The message in
    the `RuntimeException` block is not checked for correctness; even the code coverage
    shows it as covering all the branches in that line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经意识到了，但有一个问题。`RuntimeException`块中的消息没有经过正确检查；即使代码覆盖率显示它覆盖了该行中的所有分支。
- en: What is coverage all about?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率到底是什么？
- en: 'Coverage is a measure used to describe the degree to which the source code
    of a program is tested by a particular test suite. Source: [http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率是一个用来描述程序源代码被特定测试套件测试的程度的度量。来源：[http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage)。
- en: Let's imagine a single end-to-end test that covers an easy part of the code.
    This test will get you a high coverage percentage, but not much security, as there
    are many other parts that are still not covered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个覆盖了代码的一部分简单部分的单一端到端测试。这个测试将使你的覆盖率百分比很高，但安全性不高，因为还有许多其他部分没有被覆盖。
- en: We have already introduced legacy code in our codebase—the exception messages.
    There might be nothing wrong with this as long as this is not an expected behavior—no
    one should depend on exception messages, not programmers to debug their programs,
    or logs, or even users. Those parts of the program that are not covered by tests
    are likely to suffer regressions in the near future. This might be fine if you
    accept the risk. Maybe the exception type and the line number are enough.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的代码库中引入了遗留代码——异常消息。只要这不是预期行为，这可能没有什么问题——没有人应该依赖异常消息，不是程序员调试他们的程序，或者日志，甚至用户。那些没有被测试覆盖的程序部分很可能在不久的将来遭受回归。如果你接受风险，这可能没问题。也许异常类型和行号就足够了。
- en: 'We have decided to remove the exception message, as it is not tested:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定删除异常消息，因为它没有经过测试：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other ways to recognize legacy code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别遗留代码的其他方法
- en: 'You may be familiar with some of the following common signs of legacy applications:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉以下一些常见的遗留应用程序的迹象：
- en: A patch on top of a patch, just like a living Frankenstein application
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个补丁的基础上，就像一个活着的弗兰肯斯坦应用程序
- en: Known bugs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的错误
- en: Changes are expensive
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改是昂贵的
- en: Fragile
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱
- en: Difficult to understand
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以理解
- en: Old, outdated, static or, often, non-existent documentation
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的，过时的，静态的或者经常是不存在的文档
- en: Shotgun surgery
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散弹手术
- en: Broken windows
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破窗效应
- en: 'Regarding the team that maintains it, these are some of the effects it produces
    on the members of the team:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于维护它的团队，这是它对团队成员产生的一些影响：
- en: 'Resignation: The people in charge of the software see a huge task in front'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辞职：负责软件的人看到了面前的巨大任务
- en: of them
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 他们
- en: 'No one cares anymore: If you already have broken windows in your system, it
    is easier to introduce new ones'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人再关心：如果你的系统已经有了破窗，引入新的破窗就更容易。
- en: As legacy code is usually more difficult than other kinds of software, you would
    want your best people to work on it. However, we are often in a hurry imposed
    by deadlines, with the idea of programming the required functionalities as fast
    as possible and ignoring the quality of the solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遗留代码通常比其他类型的软件更难，你会希望你最好的人来处理它。然而，我们经常受到截止日期的催促，想要尽快编程所需的功能，并忽略解决方案的质量。
- en: 'Therefore, to avoid wasting our talented developers in such a bad way, we expect
    a non-legacy application to fulfill just the opposite. It should be:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了避免以这种糟糕的方式浪费我们才华横溢的开发人员，我们期望非遗留应用程序能够实现完全相反的情况。它应该是：
- en: Easy to change
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于更改
- en: Generalizable, configurable, and expansible
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可概括，可配置和可扩展
- en: Easy to deploy
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于部署
- en: Robust
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健壮
- en: No known defects or limitations
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有已知的缺陷或限制
- en: Easy to teach to others/learn from others
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于教给他人/从他人学习
- en: Extensive suite of tests
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛的测试套件
- en: Self-validating
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我验证
- en: Able to use keyhole surgery
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用钥匙孔手术
- en: As we have outlined some of the properties of legacy and non-legacy code, it
    should be easy to replace some qualities with others. Right? Stop shotgun surgery
    and use keyhole surgery, a few more details and you are done. Isn't that right?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经概述了遗留和非遗留代码的一些属性，应该很容易用其他质量替换一些质量。对吧？停止散弹手术，使用钥匙孔手术，再加上一些细节，你就完成了。对吧？
- en: It is not as easy as it sounds. Luckily, there are some tricks and rules that,
    when applied, improve our code and the application comes closer to a non-legacy
    one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像听起来那么容易。幸运的是，有一些技巧和规则，当应用时，可以改进我们的代码，应用程序更接近非遗留代码。
- en: A lack of dependency injection
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺乏依赖注入
- en: This is one of the smells often detected in a legacy codebase. As there is no
    need to test the classes in isolation, the collaborators are instantiated where
    they are needed, putting the responsibility for creating collaborators and using
    them in the same class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是遗留代码库中经常检测到的一种味道。由于没有必要单独测试类，协作者在需要时被实例化，将创建协作者和使用它们的责任放在同一个类中。
- en: 'Here''s an example, using the `new` operator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，使用`new`操作符：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the current state, the `BirthdayGreeting` service is not unit-testable. It
    has the dependency to `EmailMessageSender` hardcoded in the constructor. It is
    not possible to replace this dependency without modifying the codebase (except
    for injecting objects using reflection or replacing objects on the `new` operator).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，`BirthdayGreeting`服务不可单元测试。它在构造函数中硬编码了对`EmailMessageSender`的依赖。除了使用反射注入对象或在`new`操作符上替换对象之外，无法替换这种依赖。
- en: Modifying the codebase is always a source of possible regressions, so it should
    be done with caution. Refactoring requires tests, except when it is not possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 修改代码库总是可能引起回归的源头，所以应该谨慎进行。重构需要测试，除非不可能。
- en: The Legacy Code Dilemma.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留代码困境。
- en: When we change code, we should have tests in place. To put tests in place, we
    often have to change code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变代码时，应该有测试。要进行测试，我们经常必须改变代码。
- en: The legacy code change algorithm
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗留代码更改算法
- en: 'When you have to make a change in a legacy codebase, here is an algorithm you
    can use:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须在遗留代码库中进行更改时，这是一个你可以使用的算法：
- en: Identify change points
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别更改点
- en: Find test points
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到测试点
- en: Break dependencies
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破依赖关系
- en: Write tests
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试
- en: Make changes and refactor
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改和重构
- en: Applying the legacy code change algorithm
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用遗留代码更改算法
- en: To apply this algorithm, we usually start with a suite of tests and always keep
    it green while refactoring. This is different from the normal cycle of TDD because
    refactoring should not introduce any new features (that is, it should not write
    any new specifications).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个算法，我们通常从一套测试开始，并在重构时始终保持绿色。这与TDD的正常周期不同，因为重构不应引入任何新功能（也就是说，不应编写任何新的规范）。
- en: 'To better explain the algorithm, imagine that we received the following change
    request: To greet my employees in a more informal way, I want to send them a tweet
    instead of an email.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这个算法，想象一下我们收到了以下更改请求：为了以更非正式的方式向我的员工致以问候，我想发送一条推文而不是一封电子邮件。
- en: Identifying change points
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别更改点
- en: 'The system is only able to send emails right now, so a change is necessary.
    Where? A quick investigation shows that the strategy for sending the greeting
    is decided in the constructor for the `BirthdayGreetingService` class following
    the strategy pattern ([https://en.wikipedia.org/?title=Strategy_pattern](https://en.wikipedia.org/?title=Strategy_pattern)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 系统目前只能发送电子邮件，因此需要进行更改。在哪里？快速调查显示，发送祝福的策略是在`BirthdayGreetingService`类的构造函数中决定的，遵循策略模式（[https://en.wikipedia.org/?title=Strategy_pattern](https://en.wikipedia.org/?title=Strategy_pattern)）：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finding test points
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到测试点
- en: As the `BirthdayGreetingService` class does not have a collaborator injected
    that could be used to attach additional responsibilities to the object, the only
    option is to go outside this service class to test it. An option would be to change
    the `EmailMessageSender` class for a mock or fake implementation, but this would
    risk the implementation in that class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BirthdayGreetingService`类没有注入的协作者可以用来给对象附加额外的责任，唯一的选择是离开这个服务类来进行测试。一个选择是将`EmailMessageSender`类更改为模拟或虚拟实现，但这会对该类的实现造成风险。
- en: 'Another option is to create an end-to-end test for this functionality:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是为这个功能创建一个端到端的测试：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code has been used with permission from [https://github.com/GMaur/legacyutils](https://github.com/GMaur/legacyutils).
    This library helps you perform the technique of capturing the system out (`System.out`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码已经获得了[https://github.com/GMaur/legacyutils](https://github.com/GMaur/legacyutils)的许可使用。这个库可以帮助你执行捕获系统输出（`System.out`）的技术。
- en: The name of the file does not end in Specification (or `Spec`), such as `TicTacToeSpec`,
    because this is not a specification. It is a test, to ensure the functionality
    remains constant. The file has been named `EndToEndTest` because we try to cover
    as much functionality as possible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的名称不以Specification（或`Spec`）结尾，比如`TicTacToeSpec`，因为这不是一个规范。这是一个测试，以确保功能保持不变。文件被命名为`EndToEndTest`，因为我们试图尽可能多地覆盖功能。
- en: Breaking dependencies
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破依赖关系
- en: 'After having created a test that guarantees the expected behavior does not
    change, we will break the hardcoded dependency between `BirthdayGreetingService`
    and `EmailMessageSender`. For this, we will use a technique called **extract**
    and **override call**, which is first explained in Michael Feathers'' book:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个保证预期行为不会改变的测试之后，我们将打破`BirthdayGreetingService`和`EmailMessageSender`之间的硬编码依赖。为此，我们将使用一种称为**提取**和**重写调用**的技术，这首先在Michael
    Feathers的书中解释过：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Execute the tests again and verify that the lonely test we previously created
    still is green. Additionally, we need to make this method `protected` or more
    open to be able to override it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行测试，并验证我们之前创建的孤立测试仍然是绿色的。此外，我们需要将这个方法`protected`或更加开放以便进行重写：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that the method can be overridden, we create a fake service to replace the
    original instance of the service. Introducing fakes in code is a pattern that
    consists of creating an object that could replace an existing one, with the particularity
    that we can control its behavior. This way, we can inject some customized fakes
    to achieve what we need. More information is available at [http://xunitpatterns.com/](http://xunitpatterns.com/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该方法可以被重写，我们创建一个虚拟服务来替换原始服务的实例。在代码中引入虚拟是一种模式，它包括创建一个可以替换现有对象的对象，其特点是我们可以控制其行为。这样，我们可以注入一些定制的虚拟来实现我们的需求。更多信息请参阅[http://xunitpatterns.com/](http://xunitpatterns.com/)。
- en: 'In this particular case, we should create a fake service that extends the original
    service. The next step is to override complicated methods in order to bypass irrelevant
    parts of code for testing purposes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们应该创建一个扩展原始服务的虚拟服务。下一步是重写复杂的方法，以便为测试目的绕过代码的无关部分：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can use the fake, instead of the `BirthdayGreetingService` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用虚拟，而不是`BirthdayGreetingService`类：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The test is still green.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仍然是绿色的。
- en: 'We can now apply another dependency-breaking technique, parameterize constructor,
    explained in Feathers paper at [https://archive.org/details/WorkingEffectivelyWithLegacyCode](https://archive.org/details/WorkingEffectivelyWithLegacyCode).
    The production code may look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以应用另一种打破依赖关系的技术，即参数化构造函数，Feathers在[https://archive.org/details/WorkingEffectivelyWithLegacyCode](https://archive.org/details/WorkingEffectivelyWithLegacyCode)的论文中有解释。生产代码可能如下所示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Test code that corresponds to this implementation may be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与此实现对应的测试代码可能如下：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can also remove `FakeBirthday`, as it is no longer used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除`FakeBirthday`，因为它已经不再使用。
- en: Writing tests
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'While keeping the old end-to-end test, create an interaction to verify the
    integration of `BirthdayGreetingService` and `MessageSender`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在保留旧的端到端测试的同时，创建一个交互来验证`BirthdayGreetingService`和`MessageSender`的集成：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, a new `TweetMessageSender` can be written, completing the last
    step of the algorithm.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可以编写一个新的`TweetMessageSender`，完成算法的最后一步。
- en: The kata exercise
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kata练习
- en: The only way a programmer will be able to improve is through practice. Creating
    programs of different types and using different technologies usually provide a
    programmer with new insights into software construction. Based on this idea, a
    kata is an exercise that defines some requirements or fixed features to be implemented
    in order to achieve some goals.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员唯一能够提高的方法是通过实践。创建不同类型的程序并使用不同的技术通常会为程序员提供对软件构建的新见解。基于这个想法，kata是一种定义了一些要求或固定特性的练习，以实现一些目标。
- en: The programmer is asked to implement a possible solution and then compare it
    with others trying to find the best. The key value of this exercise is not getting
    the fastest implementation but discussing decisions taken while designing the
    solution. In most cases, all programs created in kata are dropped at the end.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员被要求实现一个可能的解决方案，然后与其他解决方案进行比较，试图找到最佳解决方案。这个练习的关键价值不在于获得最快的实现，而在于讨论在设计解决方案时所做的决定。在大多数情况下，kata中创建的所有程序最终都会被丢弃。
- en: The kata exercise in this chapter is about a legacy system. This is a sufficiently
    simple program to be processed in this chapter but also complex enough to pose
    some difficulties.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的kata练习是关于一个传统系统。这是一个足够简单的程序，在本章中可以处理，但也足够复杂，会带来一些困难。
- en: Legacy kata
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统kata
- en: 'You have been given a task to adopt a system that is already in production,
    a working piece of software for a book library: the Alexandria project.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经被分配了一个任务，即接管一个已经在生产中的系统，一个用于图书馆的工作软件：Alexandria项目。
- en: The project currently lacks documentation, and the old maintainer is no longer
    available for discussion. So, should you accept this mission, it is going to be
    entirely your responsibility, as there is no one else to rely on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目目前缺乏文档，旧的维护者也不再提供讨论。因此，如果您接受这个任务，这将完全是您的责任，因为没有其他人可以依靠。
- en: Description
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述
- en: 'We have been able to recover these specification snippets from the time the
    original project was written:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够从原始项目编写时恢复这些规范片段：
- en: The Alexandria software should be able to store books and lend them to users,
    who have the power to return them. The user can also query the system for books,
    by author, book title, status, and ID.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alexandria软件应该能够存储图书并将它们借给用户，用户有权归还图书。用户还可以通过作者、书名、状态和ID查询系统中的图书。
- en: There is no time frame for returning the books.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有时间限制归还图书。
- en: The books can also be censored as this is considered important for business
    reasons.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图书也可以被审查，因为这对业务原因很重要。
- en: The software should not accept new users.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件不应接受新用户。
- en: The user should be told, at any moment, the server's time.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该在任何时候被告知服务器的时间。
- en: Technical comments
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术评论
- en: The Alexandria is a backend project written in Java, which communicates information
    to the frontend using a REST API. For the purpose of this kata exercise,  persistence
    has been implemented as an in-memory object, using the fake test double explained
    at[ http://xunitpatterns.com/Fake%20Object.html](http://xunitpatterns.com/Fake%20Object.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Alexandria是一个用Java编写的后端项目，它使用REST API向前端通信信息。为了这个kata练习的目的，持久性已经实现为一个内存对象，使用了在[http://xunitpatterns.com/Fake%20Object.html](http://xunitpatterns.com/Fake%20Object.html)中解释的假测试替身。
- en: The code is available at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria/).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在[https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria/)找到。
- en: Adding a new feature
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新功能
- en: Until the point of adding a new feature, the legacy code might not be a disturbance
    to the programmer's productivity. The codebase is in a state that is worse than
    desired, but the production systems work without any inconvenience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新功能之前，传统代码可能不会干扰程序员的生产力。代码库的状态比期望的要差，但生产系统可以正常工作，没有任何不便。
- en: Now is the time when the problems start to appear. The **product owner** (**PO**)
    wants to add a new feature.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是问题开始出现的时候。**产品所有者**（**PO**）想要添加一个新功能。
- en: For example, as a library manager, I want to know all the history for a given
    book so that I can measure which books are more in demand than others.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，作为图书管理员，我想知道给定图书的所有历史，以便我可以衡量哪些图书比其他图书更受欢迎。
- en: Black-box or spike testing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑盒或尖刺测试
- en: As the old maintainer of the Alexandria project is no longer available for questions
    and there is no documentation, black-box testing is more difficult. Thus, we decide
    to get to know the software better through investigation and then doing some spikes
    that will leak internal knowledge to us about the system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Alexandria项目的旧维护者不再提供问题，并且没有文档，黑盒测试变得更加困难。因此，我们决定通过调查更好地了解软件，然后进行一些会泄露系统内部知识的尖刺。
- en: We will later use this knowledge to implement the new feature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后使用这些知识来实现新功能。
- en: 'Black-box testing is a method of software testing that examines the functionality
    of an application without peering into its internal structures or workings. This
    type of test can be applied to virtually every level of software testing: unit,
    integration, system, and acceptance. It typically most if not all higher-level
    testing, but can dominate unit testing as well.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试是一种软件测试方法，它检查应用程序的功能，而不查看其内部结构或工作原理。这种类型的测试可以应用于几乎每个软件测试的级别：单元、集成、系统和验收。它通常占据大部分，如果不是所有的高级别测试，但也可以主导单元测试。
- en: 'Source: [http://en.wikipedia.org/wiki/Black-box_testing](http://en.wikipedia.org/wiki/Black-box_testing).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://en.wikipedia.org/wiki/Black-box_testing](http://en.wikipedia.org/wiki/Black-box_testing)。
- en: Preliminary investigation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初步调查
- en: 'When we know the required feature, we will start looking at the Alexandria
    project:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道所需的功能时，我们将开始查看Alexandria项目：
- en: 15 files
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15个文件
- en: Gradle-based (`build.gradle`)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Gradle（`build.gradle`）
- en: 0 tests
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0个测试
- en: 'Firstly, we want to confirm that this project has never been tested, and the
    lack of a test folder reveals so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想确认这个项目从未经过测试，缺少测试文件夹也证实了这一点：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are the folder contents for the Java part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Java部分的文件夹内容：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the rest:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是剩下的内容：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This seems to be a web project (indicated by the `web.xml` file) using Spring
    (indicated by the `applicationContext.xml`). The dependencies in the `build.gradle` show
    the following (fragment):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个Web项目（由`web.xml`文件指示），使用Spring（由`applicationContext.xml`指示）。`build.gradle`中的依赖项显示如下（片段）：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Having Spring is already a good sign, as it can help with the dependency injection,
    but a quick look showed that the context is not really being used. Maybe something
    that was used in the past?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有Spring已经是一个好迹象，因为它可以帮助进行依赖注入，但快速查看显示上下文并没有真正被使用。也许这是过去使用过的东西？
- en: 'In the `web.xml` file, we can find this fragment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`文件中，我们可以找到这个片段：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this file, we discover the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们发现了以下内容：
- en: The context in `applicationContext.xml` will be loaded
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicationContext.xml`中的上下文将被加载'
- en: There is an application file (`com.packtpublishing.tddjava.alexandria.MyApplication`)
    that will be executed inside a servlet
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个应用文件（`com.packtpublishing.tddjava.alexandria.MyApplication`）将在一个servlet内执行
- en: 'The `MyApplication` file is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyApplication`文件如下：'
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This configures the necessary classes for executing the `BooksEndpoint` endpoint
    (fragment):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 配置执行`BooksEndpoint`端点所需的必要类（片段）：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can start by writing down the element that will be used during refactoring;
    we write the code for the **dependency injection** in `BooksEndpoint`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从写下将在重构过程中使用的元素开始；我们在`BooksEndpoint`中编写**依赖注入**的代码。
- en: How to find candidates for refactoring
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何寻找重构的候选对象
- en: There are different paradigms of programming (for example, functional, imperative,
    and object-oriented) and styles (for example, compact, verbose, minimalistic,
    and too clever). Therefore, the candidates for refactoring are different from
    one person to the other.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的编程范式（例如，函数式、命令式和面向对象）和风格（例如，紧凑、冗长、简约和过于聪明）。因此，不同的人对重构的候选对象也不同。
- en: There is another way, as opposed to subjectively, of finding candidates for
    refactoring—objectively. There are many papers investigating how to find candidates
    for refactoring objectively. This is just an introduction and it is left to the
    reader to learn more about these techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方式，与主观相反，可以客观地寻找重构的候选对象。有许多论文调查了如何客观地寻找重构的候选对象。这只是一个介绍，读者可以自行了解更多有关这些技术的信息。
- en: Introducing the new feature
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入新功能
- en: 'After getting to know the code more, it seems that the most important functional
    change is to replace the current `status` (fragment):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入了解代码之后，似乎最重要的功能性更改是替换当前的“状态”（片段）：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And replace it with a collection of them (fragment):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并用它们的集合替换（片段）：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This might seem to work (after changing all access to the field to the array,
    for example), but this also prompts a functional requirement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来可以工作（例如，将所有对该字段的访问更改为数组），但这也引发了一个功能性需求。
- en: The Alexandria software should be able to store books and lend them to users
    who have the power to return them. The user can also query the system for books,
    by author, book title, status, and ID.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Alexandria软件应该能够存储图书并将它们借给有权归还的用户。用户还可以通过作者、书名、状态和ID查询系统中的图书。
- en: The PO confirms that searching books via `status` has now changed now, it also
    allows  searching for any previous `status`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PO确认通过“状态”搜索图书现在已经更改，它还允许搜索任何先前的“状态”。
- en: This change is getting bigger and bigger. Whenever we feel that the time for
    removing this legacy code has come, we start applying the legacy code algorithm.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变越来越大。每当我们觉得是时候移除这个传统代码时，我们就开始应用传统代码算法。
- en: 'We have also detected a primitive obsession and feature envy smell: storing
    the `status` as an integer (primitive obsession) and then actuating on another
    object''s state (feature envy). We will add this to the following to-do list:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了原始执念和特性嫉妒的迹象：将“状态”存储为整数（原始执念），然后对另一个对象的状态进行操作（特性嫉妒）。我们将把这加入以下待办事项清单：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BooksEndpoint`中的依赖注入'
- en: Change `status` for `statuses`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“状态”更改为“状态”
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对“状态”的原始执念（可选）
- en: Applying the legacy code algorithm
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用传统代码算法
- en: In this case, the whole middle-end works as a standalone, using in-memory persistence.
    The same algorithm could be used if the persistence was saved into a database,
    but we would require some extra code to clean and populate the database between
    test runs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整个中间端作为独立运行，使用内存持久性。如果持久性保存在数据库中，可以使用相同的算法，但我们需要一些额外的代码来在测试运行之间清理和填充数据库。
- en: We'll use DbUnit. More information can be found at [http://dbunit.sourceforge.net/](http://dbunit.sourceforge.net/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用DbUnit。更多信息可以在[http://dbunit.sourceforge.net/](http://dbunit.sourceforge.net/)找到。
- en: Writing end-to-end test cases
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写端到端测试用例
- en: The first step we've decided to take to ensure that behavior is maintained during
    refactoring is to write end-to-end tests. In other applications that include frontends,
    this could be using a higher-level tool, such as Selenium/Selenide.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定采取的第一步，以确保在重构过程中保持行为的一致性，是编写端到端测试。在包括前端的其他应用程序中，可以使用更高级的工具，如Selenium/Selenide。
- en: In our case, as the frontend is not subject to refactoring, the tool can be
    lower-level. We have chosen to write HTTP requests for the purpose of end-to-end
    tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于前端不需要重构，所以工具可以是更低级的。我们选择编写HTTP请求，以进行端到端测试。
- en: These requests should be automatic and testable, and should follow all existing
    rules for automatic tests or specifications. As we were discovering the real application
    behavior while writing these tests, we have decided to write a spike in a tool
    called Postman.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求应该是自动的和可测试的，并且应该遵循所有现有的自动测试或规范。当我们在编写这些测试时发现真实的应用行为时，我们决定在一个名为Postman的工具中编写一个试验。
- en: 'The product website is here: [https://www.getpostman.com/](https://www.getpostman.com/).
    This is also possible with a tool called curl ([http://curl.haxx.se/](http://curl.haxx.se/)).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 产品网站在这里：[https://www.getpostman.com/](https://www.getpostman.com/)。这也可以使用一个名为curl的工具（[http://curl.haxx.se/](http://curl.haxx.se/)）。
- en: What is curl?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: curl是什么？
- en: curl is a command-line tool and library for transferring data with URL syntax,
    supporting `[...] HTTP`, `HTTPS, [...]`, `HTTP POST`, `HTTP PUT`, and `[...]`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: curl是一个命令行工具和库，用于使用URL语法传输数据，支持`[...] HTTP`、`HTTPS`、`HTTP POST`、`HTTP PUT`和`[...]`。
- en: What's curl used for?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: curl用于什么？
- en: curl is used in command lines or scripts to transfer data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: curl用于命令行或脚本中传输数据。
- en: 'Source: [http://curl.haxx.se/](http://curl.haxx.se/).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://curl.haxx.se/](http://curl.haxx.se/)。
- en: 'To do this, we decide to execute the legacy software locally with the following
    line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们决定使用以下命令在本地执行传统软件：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This fires up a local jetty server that processes requests. The big benefit
    is that deployment is done automatically and there is no need to package everything
    and manually deploy to an application server (for example, JBoss AS, GlassFish,
    Geronimo, and TomEE). This can greatly speed up the process of making changes
    and seeing the effects, therefore decreasing the feedback lead time. Later on,
    we will start the server programmatically from Java code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个处理请求的本地jetty服务器。最大的好处是部署是自动完成的，不需要打包一切并手动部署到应用服务器（例如，JBoss AS，GlassFish，Geronimo和TomEE）。这可以大大加快进行更改并看到效果的过程，从而减少反馈时间。以后，我们将从Java代码中以编程方式启动服务器。
- en: 'We start looking for functionalities. As we discovered earlier that the `BooksEndpoint`
    class contains the webservice endpoint definitions, this is a good place to start
    looking for functionalities. They are listed as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始寻找功能。正如我们之前发现的那样，`BooksEndpoint`类包含了webservice端点的定义，这是一个开始寻找功能的好地方。它们列如下：
- en: Add a new book
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一本新书
- en: List all the books
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有的书
- en: Search for books by ID, by author, by title, and by status
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按ID、作者、标题和状态搜索书籍
- en: Prepare this book to be rented
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备这本书出租
- en: Rent this book
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 租借这本书
- en: Censor this book
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查这本书
- en: Uncensor the book
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消审查这本书
- en: 'We launch the server manually and start writing requests:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动启动服务器并开始编写请求：
- en: '![](img/d210ad49-9c7a-48e2-b98e-a6fb7c9f6819.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d210ad49-9c7a-48e2-b98e-a6fb7c9f6819.png)'
- en: 'These tests seem good enough for a spike. One thing that we have realized is
    that each response contains a timestamp, so this makes our automation more difficult:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试对于一个暂时的测试来说似乎足够好。我们意识到的一件事是，每个响应都包含一个时间戳，所以这使得我们的自动化更加困难：
- en: '![](img/a2cb8545-b5bd-4d7a-adb3-bcd27600297a.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2cb8545-b5bd-4d7a-adb3-bcd27600297a.png)'
- en: For the tests to have more value, they should be automated and exhaustive. For
    the moment, they are not, so we consider them spikes. They will be automated in
    the future.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试具有更多的价值，它们应该是自动化和详尽的。目前它们不是，所以我们认为它们是暂时的。它们将在将来自动化。
- en: Each and every single test that we perform is not automated. In this case, the
    tests from the Postman interface are much faster to write than the automated ones.
    Also, the experience is far more representative of what production use would be
    like. The test client (thankfully, in this case) could introduce some problems
    with the production one, and therefore not return trusted results.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行的每一个测试都没有自动化。在这种情况下，Postman界面的测试比自动化测试更快。而且，这种体验更加符合实际生产的使用情况。测试客户端（幸运的是，在这种情况下）可能会对生产环境产生一些问题，因此不能返回可信的结果。
- en: In this particular case, we have found that the Postman tests are a better investment
    because, even after writing them, we will throw them away. They give very rapid
    feedback on the API and results. We also use this tool for prototyping the REST
    APIs, as its tools are both effective and useful.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们发现Postman测试是一个更好的投资，因为即使在编写完它们之后，我们也会将它们丢弃。它们对API和结果提供了非常快速的反馈。我们还使用这个工具来原型化REST
    API，因为它的工具既有效又有用。
- en: 'The general idea here is this: depending on whether you want to save those
    tests for the future or not, use one tool or another. This also depends on how
    often you want to execute them, and in which environment.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般想法是：根据你是否想要将这些测试保存到未来，使用一个工具或另一个工具。这也取决于你想要多频繁地执行它们，以及在哪个环境中执行。
- en: 'After writing down all the requests, these are the states that we have found
    in the application, represented by a state diagram:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在写下所有请求后，这些是我们在应用程序中发现的状态，由状态图表示：
- en: '![](img/3ea6c926-39d3-41cc-b9e4-8b78c3c4263b.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ea6c926-39d3-41cc-b9e4-8b78c3c4263b.png)'
- en: After these tests are ready and we start to understand the application, it is
    time to automate the tests. After all, if they are not automated, we don't really
    feel confident enough for refactoring.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试准备好后，我们开始理解应用程序，现在是时候自动化测试了。毕竟，如果它们没有自动化，我们对重构就不够自信。
- en: Automating the test cases
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试用例
- en: 'We start the server programmatically. For this, we have decided to use a Grizzly ([https://javaee.github.io/grizzly/](https://javaee.github.io/grizzly/)),
    which allows us to start the server using the configuration from Jersey''s `ResourceConfig`
    (FQCN: `org.glassfish.jersey.server.ResourceConfig`), as shown in the test `BooksEndpointTest`
    (fragment).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以编程方式启动服务器。为此，我们决定使用Grizzly（[https://javaee.github.io/grizzly/](https://javaee.github.io/grizzly/)），它允许我们使用Jersey的`ResourceConfig`（FQCN：`org.glassfish.jersey.server.ResourceConfig`）的配置来启动服务器，如测试`BooksEndpointTest`（片段）中所示。
- en: 'The code can be found at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在[https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria)找到：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This prepares a local server at the address `http://localhost:8080/alexandria`.
    It will only be available for a short period of time (while the tests run), so,
    if you need to manually access the server, whenever you want to pause the execution,
    insert a call to the following method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在地址`http://localhost:8080/alexandria`上准备一个本地服务器。它只会在短时间内可用（测试运行时），所以，如果你需要手动访问服务器，每当你想要暂停执行时，插入一个调用以下方法：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you want to stop the server, stop the execution or hit *Enter* in the allocated
    console.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要停止服务器时，停止执行或在分配的控制台中按*Enter*。
- en: Now we can start the server programmatically, pause it (with the preceding method),
    and execute the spike again. The results are the same, so the refactor is successful.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以编程方式启动服务器，暂停它（使用前面的方法），并再次执行暂时测试。结果是一样的，所以重构是成功的。
- en: We add the first automated test to the system.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向系统添加了第一个自动化测试。
- en: 'The code can be found at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在[https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria)找到：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For testing purposes, we're using a library called `RestAssured` ([https://github.com/rest-assured/rest-assured](https://github.com/rest-assured/rest-assured))
    that allows for easier testing of REST and JSON.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们使用了一个名为`RestAssured`的库（[https://github.com/rest-assured/rest-assured](https://github.com/rest-assured/rest-assured)），它可以更轻松地测试REST和JSON。
- en: 'To complete the automated test suite, we create these tests:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成自动化测试套件，我们创建了这些测试：
- en: '`add_one_book()`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_one_book()`'
- en: '`add_a_second_book()`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_a_second_book()`'
- en: '`get_book_details_by_id()`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_book_details_by_id()`'
- en: '`get_several_books_in_a_row()`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_several_books_in_a_row()`'
- en: '`censor_a_book()`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`censor_a_book()`'
- en: '`cannot_retrieve_a_censored_book()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cannot_retrieve_a_censored_book()`'
- en: The code can be found at[ https://bitbucket.org/vfarcic/tdd-java-alexandria/](https://bitbucket.org/vfarcic/tdd-java-alexandria/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在[ https://bitbucket.org/vfarcic/tdd-java-alexandria/](https://bitbucket.org/vfarcic/tdd-java-alexandria/)找到。
- en: 'Now that we have a suite that ensures that no regression is introduced, we
    take a look at the following to-do list:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个确保没有引入回归的测试套件，我们来看一下以下的待办事项清单：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 书籍的`BooksEndpoint`中的依赖注入
- en: Change `status` for `statuses`
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`status`更改为`statuses`
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`status`（可选）去除原始偏执
- en: We will tackle dependency injection first.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解决依赖注入。
- en: Injecting the BookRepository dependency
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入`BookRepository`依赖项
- en: 'The code for the `BookRepository` dependency is in `BooksEndpoint` (fragment):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookRepository`的依赖代码在`BooksEndpoint`中（片段）：'
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Extract and override call
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取和重写调用
- en: 'We will apply the already introduced refactoring technique extract and override
    call. For this, we create a failing specification, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用已经介绍的重构技术提取和重写调用。为此，我们创建一个失败的规范，如下所示：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To pass this red specification, also known as a failing specificiation, we
    will first extract the dependency creation to a `protected` method in the `BookRepository`
    class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过这个红色的规范，也被称为失败的规范，我们首先将依赖项创建提取到`BookRepository`类的`protected`方法中：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We copy the `MyApplication` launcher to this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`MyApplication`启动器复制到这里：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This allows us to inject any `BooksEndpoint`. In this case, in the test `BooksEndpointInteractionTest`,
    we will override the dependency getter with a mock. In this way, we can check
    that the necessary calls are being made (fragment from `BooksEndpointInteractionTest`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们注入任何`BooksEndpoint`。在这种情况下，在测试`BooksEndpointInteractionTest`中，我们将使用模拟重写依赖项获取器。这样，我们可以检查是否进行了必要的调用（来自`BooksEndpointInteractionTest`的片段）：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the tests; everything is green. Even though the specifications are successful,
    we have introduced a piece of design only for test purposes, and the production
    code is not executing this new launcher, `TestApplication`, but is still executing
    the old `MyApplication`. To solve this, we have to unify both launchers into one.
    This can be solved with the refactor parametrize constructor, also explained in
    Roy Osherove's book, *The Art of Unit Testing* ([http://artofunittesting.com](http://artofunittesting.com)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试；一切正常。尽管规范是成功的，但我们为了测试目的引入了一段设计，并且生产代码没有执行这个新的启动器`TestApplication`，而是仍然执行旧的`MyApplication`。为了解决这个问题，我们必须将两个启动器统一为一个。这可以通过重构参数化构造函数来解决，这也在Roy
    Osherove的书《单元测试的艺术》中有解释（[http://artofunittesting.com](http://artofunittesting.com)）。
- en: Parameterizing a constructor
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数参数化
- en: 'We can unify the launchers by accepting a `BooksEndpoint` dependency. If we
    don''t specify it, it will register the dependency with the real instance of `BooksRepository`.
    Otherwise, it will register the received one:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过接受`BooksEndpoint`依赖项来统一启动器。如果我们不指定，它将使用`BooksRepository`的真实实例注册依赖项。否则，它将注册接收到的依赖项：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, we have opted for **constructor chaining** to avoid repetition
    in the constructors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择了**构造函数链接**来避免构造函数中的重复。
- en: After doing this refactor, the `BooksEndpointInteractionTest` class is as follows
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了这次重构之后，`BooksEndpointInteractionTest`类如下
- en: 'in its final state:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终状态中：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first test passed, so we can mark the dependency injection task as done.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试通过了，所以我们可以将依赖注入任务标记为完成。
- en: 'Tasks performed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 已执行的任务：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的`BooksEndpoint`中的依赖注入
- en: 'The to-do list:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项清单：
- en: Change `status` for `statuses`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`status`更改为`statuses`
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除原始偏执`status`（可选）
- en: Adding a new feature
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个新功能
- en: Once we have the necessary test environment in place, we can add the new feature.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了必要的测试环境，我们就可以添加新功能。
- en: As a library manager, I want to know all the history for a given book so that
    I can measure which books are more in demand than others.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图书管理员，我想知道给定书籍的所有历史，以便我可以衡量哪些书籍比其他书籍更受欢迎。
- en: 'We will start with a red specification:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个红色的规范开始：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run all the tests and see the last one fail.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试并查看最后一个失败。
- en: 'Implement the search on all states (fragment):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有状态的搜索（片段）：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this fragment, we have omitted the irrelevant parts—things that were not
    modified, or more modifier methods, such as `rent`, that have changed the implementation
    in the same fashion:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们省略了不相关的部分——未修改的部分，或者更改了实现方式的更多修改方法，比如`rent`，它们以相同的方式改变了实现：
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The outside methods, especially the serialization to JSON, are not affected,
    as the `getStatus` method still returns an `int` value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法，特别是转换为JSON的方法，都没有受到影响，因为`getStatus`方法仍然返回一个`int`值。
- en: We run all the tests and everything is green.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行所有测试，一切正常。
- en: 'Tasks performed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 已执行的任务：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的`BooksEndpoint`中的依赖注入
- en: Change `status` for `statuses`
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`status`更改为`statuses`
- en: 'The to-do list:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项清单：
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除原始偏执`status`（可选）
- en: Removing the primitive obsession with status as int
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态的原始偏执移除为int
- en: We have decided to also tackle the optional item in our to-do list.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定也解决待办事项清单中的可选项目。
- en: 'The to-do list:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项清单：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的`BooksEndpoint`中的依赖注入
- en: Change `status` for `statuses`
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`status`更改为`statuses`
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对`status`的原始执着（可选）
- en: 'The smell: Primitive obsession involves using primitive data types to represent
    domain ideas. For example, we use a string to represent a message, an integer
    to represent an amount of money, or a struct/dictionary/hash to represent a specific
    object.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 气味：原始执着涉及使用原始数据类型来表示领域思想。 例如，我们使用字符串表示消息，整数表示金额，或者使用结构/字典/哈希表示特定对象。
- en: The source is [http://c2.com/cgi/wiki?PrimitiveObsession](http://c2.com/cgi/wiki?PrimitiveObsession).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 来源是[http://c2.com/cgi/wiki?PrimitiveObsession](http://c2.com/cgi/wiki?PrimitiveObsession)。
- en: As this is a refactor step (that is, we are not introducing any new behavior
    into the system), we don't need any new specification. We will proceed and try
    to always stay green, or leave it for as little time as possible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一项重构步骤（即，我们不会向系统引入任何新行为），因此我们不需要任何新的规范。 我们将继续努力，尽量保持绿色，或者尽可能少的时间离开。
- en: 'We have converted  `States` from a Java class with constants:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`States`从具有常量的Java类转换为：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And turned it into an `enum`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其转换为`enum`：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Adapt the tests as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调整测试如下：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Adapt the production code. The code snippet is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调整生产代码。 代码片段如下：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还有以下内容：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this case, the serialization has been done using the annotation:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用注释进行了序列化：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This converts the result of the method into the field named `status`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法的结果转换为名为`status`的字段。
- en: Also, the `status` field, now `ArrayList<States>`, is marked with `@XmlTransient`
    so it is not serialized to JSON.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在将`status`字段标记为`ArrayList<States>`，并使用`@XmlTransient`标记，因此不会序列化为JSON。
- en: We execute all the tests and they are green, so we can now cross off the optional
    element in our to-do list.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了所有测试，它们都是绿色的，因此我们现在可以划掉待办清单中的可选元素。
- en: 'Tasks performed:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的任务：
- en: Dependency injection in `BooksEndpoint` for books
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BooksEndpoint`进行依赖注入
- en: Change `status` for `statuses`
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`status`更改为`statuses`
- en: Remove the primitive obsession with `status` (optional)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对`status`的原始执着（可选）
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you already know, inheriting a legacy codebase may be a daunting task.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，继承传统代码库可能是一项艰巨的任务。
- en: 'We stated that legacy code is code without tests, so the first step in dealing
    with it is to create tests to help you preserve the same functionality during
    the process. Unfortunately, creating tests is not always as easy as it sounds.
    Many times, legacy code is tightly coupled and presents other symptoms that show
    a poor design or at least a lack of interest in the code''s quality in the past.
    Worry not: you can perform some of the tedious tasks step by step, as shown in
    [http://martinfowler.com/bliki/ParallelChange.html](http://martinfowler.com/bliki/ParallelChange.html).
    Moreover, it is also well known that software development is a learning process.
    Working code is a side effect. Therefore, the most important part is to learn
    more about the codebase, to be able to modify it with security. Please visit [http://www.slideshare.net/ziobrando/model-storming](http://www.slideshare.net/ziobrando/model-storming)
    for more information.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明传统代码是没有测试的代码，因此处理传统代码的第一步是创建测试，以帮助您在过程中保持相同的功能。 不幸的是，创建测试并不总是像听起来那么容易。 许多时候，传统代码是紧密耦合的，并呈现出其他症状，表明过去设计不佳，或者至少对代码质量缺乏兴趣。
    请不要担心：您可以逐步执行一些繁琐的任务，如[http://martinfowler.com/bliki/ParallelChange.html](http://martinfowler.com/bliki/ParallelChange.html)所示。
    此外，众所周知，软件开发是一个学习过程。 工作代码是一个副作用。 因此，最重要的部分是更多地了解代码库，以便能够安全地修改它。 请访问[http://www.slideshare.net/ziobrando/model-storming](http://www.slideshare.net/ziobrando/model-storming)获取更多信息。
- en: Finally, we encourage you to read Michael Feathers book called *Working Effectively
    with Legacy Code*. It has plenty of techniques for this kind of codebase, and
    as a result is very useful for understanding the whole process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们鼓励您阅读迈克尔·菲瑟斯的书《与传统代码有效地工作》。 它有很多针对这种类型代码库的技术，因此对于理解整个过程非常有用。
