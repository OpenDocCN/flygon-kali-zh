- en: Running a Containerized App in the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中运行容器化应用程序
- en: In the previous chapter, we learned how to deploy, monitor, and troubleshoot
    an application in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在生产环境中部署、监控和排除故障。
- en: In this chapter, we will give an overview of some of the most popular ways of
    running containerized applications in the cloud. We will explore self-hosting
    and hosted solutions and discuss their pros and cons. Fully managed offerings
    from vendors such as Microsoft Azure and Google Cloud Engine will be briefly discussed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述在云中运行容器化应用程序的一些最流行的方法。我们将探讨自托管和托管解决方案，并讨论它们的优缺点。我们将简要讨论来自供应商如Microsoft
    Azure和Google Cloud Engine的完全托管的解决方案。
- en: 'Here are the topics we will be discussing in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将讨论的主题：
- en: Deploying and using Docker **Enterprise Edition** (**EE**) on **Amazon Web Services**
    (**AWS**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Amazon Web Services** (**AWS**)上部署和使用Docker **Enterprise Edition** (**EE**)
- en: Exploring Microsoft's **Azure Kubernetes Service** (**AKS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Microsoft的**Azure Kubernetes Service** (**AKS**)
- en: Understanding **Google Kubernetes Engine** (**GKE**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**Google Kubernetes Engine** (**GKE**)
- en: 'After reading this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您将能够做到以下几点：
- en: Create a Kubernetes cluster in AWS using Docker EE
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker EE在AWS中创建一个Kubernetes集群
- en: Deploy and run a simple distributed application in a Docker EE cluster in AWS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS上部署和运行一个简单的分布式应用程序的Docker EE集群
- en: Deploy and run a simple distributed application on Microsoft's AKS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Microsoft的AKS上部署和运行一个简单的分布式应用程序
- en: Deploy and run a simple distributed application on GKE
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE上部署和运行一个简单的分布式应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We are going to use AWS, Microsoft Azure, and Google Cloud in this chapter.
    Therefore, it is necessary to have an account for each platform. If you do not
    have an existing account, you can ask for a trial account for all of these cloud
    providers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用AWS、Microsoft Azure和Google Cloud。因此，需要为每个平台拥有一个账户。如果您没有现有账户，可以要求这些云服务提供商提供试用账户。
- en: We'll also use the files in the `~/fod-solution/ch18` folder of our `labs` repository
    from GitHub at [https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18](https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用GitHub上我们的`labs`仓库中`~/fod-solution/ch18`文件夹中的文件，网址为[https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18](https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18)。
- en: Deploying and using Docker EE on AWS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署和使用Docker EE
- en: In this section, we're going to install Docker **Universal Control Plane** (**UCP**)
    version 3.0\. UCP is part of Docker's enterprise offering and supports two orchestration engines,
    Docker Swarm and Kubernetes. UCP can be installed in the cloud or on-premises.
    Even hybrid clouds are possible with UCP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将安装Docker **Universal Control Plane** (**UCP**) 版本3.0。UCP是Docker企业套件的一部分，支持两种编排引擎，Docker
    Swarm和Kubernetes。UCP可以在云端或本地安装。甚至可以在UCP中使用混合云。
- en: To try this, you need a valid license for Docker EE or you can claim a free
    test license on Docker Store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，您需要一个Docker EE的有效许可证，或者您可以在Docker Store上申请免费测试许可证。
- en: Provisioning the infrastructure
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施的规划
- en: 'In this first section, we are going to set up the infrastructure needed to
    install Docker UCP. This is relatively straightforward if you are somewhat familiar
    with AWS. Let''s do this by following these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将设置安装Docker UCP所需的基础设施。如果您对AWS有一定了解，这相对比较简单。让我们按照以下步骤来做：
- en: 'Create an **A****uto Scaling group** (**ASG**) in AWS using the Ubuntu 16.04
    server AMI. Configure the ASG to contain three instances of size `t2.xlarge`.
    Here is the result of this:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS中使用Ubuntu 16.04服务器AMI创建一个**自动扩展组**（**ASG**）。配置ASG包含三个大小为`t2.xlarge`的实例。这是此操作的结果：
- en: '![](assets/3aef6cd3-8664-4019-8eff-5ef9712222f7.png)ASG on AWS ready for Docker
    EE'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3aef6cd3-8664-4019-8eff-5ef9712222f7.png)AWS上准备好Docker EE的ASG'
- en: Once the ASG has been created, and before we continue, we need to open the **security
    group** (**SG**) a bit (which our ASG is part of) so that we can access it through
    SSH from our laptop and also so that the **virtual machines** (**VMs**) can communicate
    with each other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ASG创建完成，并且在继续之前，我们需要稍微打开**安全组**（**SG**）（我们的ASG是其中的一部分），以便我们可以通过SSH从我们的笔记本访问它，也以便**虚拟机**（**VMs**）可以相互通信。
- en: 'Navigate to your SG and add two new inbound rules, which are shown here:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的SG并添加两个新的入站规则，如下所示：
- en: '![](assets/00df1c32-a142-4c54-9890-8f69a6fa1a88.png)AWS SG settings'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/00df1c32-a142-4c54-9890-8f69a6fa1a88.png)AWS SG设置'
- en: In the preceding screenshot, the first rule allows any traffic from my personal
    laptop (with the IP address `70.113.114.234`) to access any resource in the SG. The
    second rule allows any traffic inside the SG itself. These settings are not meant
    to be used in a production-like environment as they are way too permissive. However,
    for this demo environment, they work well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，第一个规则允许来自我的个人笔记本（IP地址为`70.113.114.234`）的任何流量访问SG中的任何资源。第二个规则允许SG内部的任何流量。这些设置不适用于生产环境，因为它们太过宽松。但是，对于此演示环境，它们效果很好。
- en: Next, we will show you how to install Docker on the VMs we just prepared.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向您展示如何在我们刚准备好的虚拟机上安装Docker。
- en: Installing Docker
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'After having provisioned the cluster nodes, we need to install Docker on each
    of them. This can be easily achieved by following these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置完集群节点之后，我们需要在每个节点上安装Docker。按照以下步骤可以轻松实现：
- en: 'SSH into all three instances and install Docker. Using the downloaded key,
    SSH into the first machine:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH进入所有三个实例并安装Docker。使用下载的密钥，SSH进入第一台机器：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<IP address>` is the public IP address of the VM we want to SSH into.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<IP地址>`是我们要SSH进入的VM的公共IP地址。
- en: Now we can install Docker. For detailed instructions, refer to [https://dockr.ly/2HiWfBc](https://dockr.ly/2HiWfBc).
    We have a script in the `~/fod/ch18/aws` folder called `install-docker.sh` that
    we can use.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以安装Docker了。有关详细说明，请参阅[https://dockr.ly/2HiWfBc](https://dockr.ly/2HiWfBc)。我们在`~/fod/ch18/aws`文件夹中有一个名为`install-docker.sh`的脚本可以使用。
- en: 'First, we need to clone the `labs` GitHub repository to the VM:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`labs` GitHub存储库克隆到虚拟机中：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we run the script to install Docker:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行脚本来安装Docker：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the script is finished, we can verify that Docker is indeed installed using `sudo
    docker version`. Repeat the preceding code for the two other VMs.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本完成后，我们可以使用`sudo docker version`验证Docker是否已安装。对其他两个VM重复前面的代码。
- en: '`sudo` is only necessary until the next SSH session is opened to this VM since
    we have added the `ubuntu` user to the `docker` group. So, we need to exit the
    current SSH session and connect again. This time, `sudo` should not be needed
    in conjunction with `docker`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`只在下一个SSH会话打开到此VM之前是必要的，因为我们已将`ubuntu`用户添加到`docker`组中。因此，我们需要退出当前的SSH会话并重新连接。这次，`sudo`不应与`docker`一起使用。'
- en: Next, we will show how to install Docker UCP on the infrastructure we just prepared.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何在我们刚准备好的基础设施上安装Docker UCP。
- en: Installing Docker UCP
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker UCP
- en: 'We need to set a few environment variables, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置一些环境变量，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `<IP address>` and `<FQDN>` are the public IP address and the public DNS
    name of the AWS EC2 instance we're installing in UCP.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<IP地址>`和`<FQDN>`是我们在UCP中安装的AWS EC2实例的公共IP地址和公共DNS名称。
- en: 'After that, we can use the following command to download all the images that
    UCP needs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用以下命令下载UCP需要的所有镜像：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can install UCP:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以安装UCP：
- en: '![](assets/cd7dc52c-302c-4bee-8746-89a1bde6a8da.png)Installing UCP 3.0.0-beta2
    on a VM in AWS'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cd7dc52c-302c-4bee-8746-89a1bde6a8da.png)在AWS的VM中安装UCP 3.0.0-beta2'
- en: Now, we can open a browser window and navigate to `https://<IP address>`. Log
    in with your username, `admin`, and password, `adminadmin`. When asked for the
    license, upload your license key or follow the link to procure a trial license.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开浏览器窗口并导航到`https://<IP地址>`。使用您的用户名“admin”和密码“adminadmin”登录。当要求许可证时，上传您的许可证密钥或按照链接获取试用许可证。
- en: 'Once logged in, on the left-hand side under the Shared Resources section, select Nodes and
    then click on the Add Node button:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，在左侧的“共享资源”部分下，选择“节点”，然后单击“添加节点”按钮：
- en: '![](assets/fbd3044c-9c09-4899-ab0b-8dd5ba14112b.png)Adding a new node to UCP'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fbd3044c-9c09-4899-ab0b-8dd5ba14112b.png)向UCP添加新节点'
- en: 'In the subsequent Add Node dialog box, make sure that the node type is Linux and
    the Worker node role is selected. Then, copy the `docker swarm join` command at
    the bottom of the dialog box. SSH into the other two VMs you created and run this
    command to have the respective node join the Docker swarm as a worker node:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的“添加节点”对话框中，请确保节点类型为Linux，并选择“工作节点”角色。然后，复制对话框底部的“docker swarm join”命令。SSH进入您创建的另外两个VM并运行此命令，使相应的节点加入Docker
    Swarm作为工作节点：
- en: '![](assets/a45a4a6d-6e7d-4c02-be40-c3175c9511b8.png)Joining a node as a worker
    to the UCP cluster'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a45a4a6d-6e7d-4c02-be40-c3175c9511b8.png)将节点作为工作节点加入到UCP集群'
- en: 'Back in the web UI of UCP, you should see that we now have three nodes ready,
    as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到UCP的Web UI中，您应该看到我们现在有三个准备好的节点，如下所示：
- en: '![](assets/ee9b3da4-5b1e-4a53-be1a-72c52291bd58.png)List of nodes in the UCP
    cluster'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ee9b3da4-5b1e-4a53-be1a-72c52291bd58.png)UCP集群中的节点列表'
- en: 'By default, worker nodes are configured so that they can only run the Docker
    Swarm workload. This can be changed in the node details, though. In this, three settings are
    possible: Swarm only, Kubernetes only, or mixed workload. Let''s start with Docker
    Swarm as the orchestration engine and deploy our pets application.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工作节点被配置为只能运行Docker Swarm工作负载。但是，这可以在节点详细信息中更改。在此，有三种设置可能：仅Swarm、仅Kubernetes或混合工作负载。让我们从Docker
    Swarm作为编排引擎开始，并部署我们的宠物应用程序。
- en: Using remote admin for the UCP cluster
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程管理员管理UCP集群
- en: 'To be able to manage our UCP cluster remotely from our laptop, we need to create and
    download a so-called **client bundle** from UCP. Proceed with the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从我们的笔记本电脑远程管理我们的UCP集群，我们需要从UCP中创建并下载一个所谓的**客户端包**。按照以下步骤进行：
- en: In the UCP web UI, on the left-hand side under admin, select the My Profile option.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UCP Web UI中，在左侧的“管理员”下，选择“我的个人资料”选项。
- en: 'In the subsequent dialog, select the New Client Bundle option and then Generate
    Client Bundle:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后的对话中，选择“新客户端包”选项，然后生成客户端包：
- en: '![](assets/e6dd0c9c-f925-4ae3-a78f-5113da2f806d.png)Generating and downloading
    a UCP client bundle'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e6dd0c9c-f925-4ae3-a78f-5113da2f806d.png)生成并下载UCP客户端包'
- en: Locate the downloaded bundle on your disk and unzip it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的磁盘上找到并解压下载的包。
- en: 'In a new Terminal window, navigate to that folder and source the `env.sh` file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端窗口中，导航到该文件夹并源化“env.sh”文件：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get an output similar to this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于这样的输出：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can verify that we can indeed remotely access the UCP cluster by, for
    example, listing all the nodes of the cluster:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证我们确实可以远程访问UCP集群，例如，列出集群的所有节点：
- en: '![](assets/8d630be3-12cd-4a63-9a0b-d9b2a8aab377.png)Listing all the nodes of
    our remote UCP cluster'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8d630be3-12cd-4a63-9a0b-d9b2a8aab377.png)列出远程UCP集群的所有节点'
- en: In the next section, we will look at how to deploy the pets application as a
    stack using Docker Swarm as the orchestration engine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用Docker Swarm作为编排引擎将宠物应用程序部署为堆栈。
- en: Deploying to Docker Swarm
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Docker Swarm
- en: 'It is now time to deploy our distributed application to our cluster orchestrated
    by Docker Swarm. Follow these steps to do so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的分布式应用程序部署到由Docker Swarm编排的集群了。按照以下步骤进行操作：
- en: 'In the Terminal, navigate to the `~/fod/ch18/ucp` folder and create the `pets` stack
    using the `stack.yml` file:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，导航到`〜/fod/ch18/ucp`文件夹，并使用`stack.yml`文件创建`pets`堆栈：
- en: '![](assets/b83cbe73-2b3b-4b9b-9812-f81f645566b5.png)Deploying the pets stack
    into the UCP cluster'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将宠物堆栈部署到UCP集群
- en: 'In the UCP web UI, we can verify that the stack has been created:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UCP Web UI中，我们可以验证已创建堆栈：
- en: '![](assets/a520aaa1-33d0-4ec8-9365-8f17118a6a54.png)The pets stack listing
    in the UCP web UI'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UCP Web UI中的宠物堆栈列表
- en: 'To test the application, we can navigate to Services under the main menu, Swarm.
    The list of services running in the cluster will be displayed as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试应用程序，我们可以在主菜单的Swarm下导航到Services。集群中运行的服务列表将显示如下：
- en: '![](assets/738af281-8a2d-4e01-a299-c9580ae9e18c.png)Details of the ''web''
    services of the pets stack'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物堆栈的“web”服务的详细信息
- en: In the preceding screenshot, we see our two services, `web` and `db`, of the `pets` stack.
    If we click on the `web` service, its details are displayed on the right-hand
    side. There we find an entry, Published Endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们看到了`pets`堆栈的两个服务`web`和`db`。如果我们点击`web`服务，它的详细信息将显示在右侧。在那里，我们找到了一个条目，发布的端点。
- en: Click on the link and our `pets` application should be displayed in the browser.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击链接，我们的`pets`应用程序应该显示在浏览器中。
- en: 'When done, remove the stack from the console with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用以下命令从控制台中删除堆栈：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, you can try to remove that stack from within the UCP web UI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以尝试从UCP Web UI中删除该堆栈。
- en: Deploying to Kubernetes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Kubernetes
- en: From the same Terminal that you used to remotely access the UCP cluster to deploy
    the pets application as a stack using Docker Swarm as the orchestration engine,
    we can now try to deploy the pets application to the UCP cluster using Kubernetes
    as the orchestration engine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从用于远程访问UCP集群以使用Docker Swarm作为编排引擎部署宠物应用程序的堆栈的同一终端，我们现在可以尝试使用Kubernetes作为编排引擎将宠物应用程序部署到UCP集群。
- en: 'Make sure you''re still in the `~/fod/ch18/ucp` folder. Use `kubectl` to deploy
    the pets application. First, we need to test that we can get all the nodes of
    the cluster with the Kubernetes CLI:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您仍然在`〜/fod/ch18/ucp`文件夹中。使用`kubectl`部署宠物应用程序。首先，我们需要测试是否可以使用Kubernetes CLI获取集群的所有节点：
- en: '![](assets/cf58df9f-5abd-4502-8992-0b22ae829ff9.png)Getting all the nodes of
    the UCP cluster using the Kubernetes CLI'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes CLI获取UCP集群的所有节点
- en: 'Apparently, my environment is configured correctly and `kubectl` can indeed
    list all the nodes in the UCP cluster. That means I can now deploy the pets application
    using the definitions in the `pets.yaml` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我的环境已正确配置，并且`kubectl`确实可以列出UCP集群中的所有节点。这意味着我现在可以使用`pets.yaml`文件中的定义部署宠物应用程序：
- en: '![](assets/ea01cf48-9dc5-4983-8d4d-b0febc33cb13.png)Creating the pets application
    in the UCP cluster using the Kubernetes CLI'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes CLI在UCP集群中创建宠物应用程序
- en: We can list the objects created by using `kubectl get all`. In a browser, we
    can then navigate to `http://<IP address>:<port>` to access the pets application,
    where `<IP address>` is the public IP address of one of the UCP cluster nodes
    and `<port>` is the port published by the `web` Kubernetes service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl get all`可以列出通过创建的对象。然后在浏览器中，我们可以导航到`http://<IP地址>:<端口>`来访问宠物应用程序，其中`<IP地址>`是UCP集群节点之一的公共IP地址，`<端口>`是`web`
    Kubernetes服务发布的端口。
- en: We have created a cluster of three VMs in an AWS ASG and have installed Docker
    and UCP 3.0 on them. We then deployed our famous pets application into the UCP
    cluster, once using Docker Swarm as the orchestration engine and once Kubernetes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在AWS ASG中创建了一个由三个VM组成的集群，并在其中安装了Docker和UCP 3.0。然后我们将我们著名的宠物应用程序部署到UCP集群中，一次使用Docker
    Swarm作为编排引擎，一次使用Kubernetes。
- en: Docker UCP is a platform-agnostic container platform that offers a secure enterprise-grade
    software supply chain in any cloud and on-premises, on bare metal, or in virtualized
    environments. It even offers freedom of choice when it comes to orchestration
    engines. The user can choose between Docker Swarm and Kubernetes. It is also possible
    to run applications in both orchestrators in the same cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Docker UCP是一个平台无关的容器平台，可以在任何云和本地、裸机或虚拟化环境中提供安全的企业级软件供应链。甚至在编排引擎方面也提供了选择的自由。用户可以在Docker
    Swarm和Kubernetes之间进行选择。还可以在同一集群中在两个编排器中运行应用程序。
- en: Exploring Microsoft's Azure Kubernetes Service (AKS)
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索微软的Azure Kubernetes服务（AKS）
- en: To experiment with Microsoft's container-related offerings in Azure, we need an
    account on Azure. You can create a trial account or use an existing account. You
    can get a free trial account here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Azure中尝试微软的与容器相关的服务，我们需要在Azure上拥有一个帐户。您可以创建一个试用帐户或使用现有帐户。您可以在此处获取免费试用帐户：https://azure.microsoft.com/en-us/free/。
- en: Microsoft offers different container-related services on Azure. The easiest one
    to use is probably Azure Container Instances, which promises the fastest and simplest
    way to run a container in Azure, without having to provision any virtual machines
    and without having to adopt a higher-level service. This service is only really
    useful if you want to run a single container in a hosted environment. The setup
    is quite easy. In the Azure portal ([portal.azure.com](http://portal.azure.com)),
    you first create a new resource group and then create an Azure container instance.
    You only need to fill out a short form with properties such as the name of the
    container, the image to use, and the port to open. The container can be made available
    on a public or private IP address and will be automatically restarted if it crashes.
    There is a decent management console available, for example, to monitor resource
    consumption such as CPU and memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在Azure上提供了不同的与容器相关的服务。最容易使用的可能是Azure容器实例，它承诺在Azure中以最快最简单的方式运行容器，而无需预配任何虚拟机，也无需采用更高级别的服务。如果您想在托管环境中运行单个容器，这项服务确实非常有用。设置非常简单。在Azure门户（portal.azure.com）中，您首先创建一个新的资源组，然后创建一个Azure容器实例。您只需要填写一个简短的表单，包括容器的名称、要使用的镜像和要打开的端口等属性。容器可以在公共或私有IP地址上提供，并且如果崩溃，将自动重新启动。还有一个不错的管理控制台可用，例如用于监视CPU和内存等资源消耗。
- en: 'The second choice is **Azure Container Service** (**ACS**), which provides
    a way to simplify the creation, configuration, and management of a cluster of
    VMs that are preconfigured to run containerized applications. ACS uses Docker
    images and provides a choice between three orchestrators: Kubernetes, Docker Swarm,
    and DC/OS (powered by Apache Mesos). Microsoft claims that their service can be
    scaled to tens of thousands of containers. ACS is free and you are only charged
    for computing resources.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是Azure容器服务（ACS），它提供了一种简化创建、配置和管理预配置为运行容器化应用程序的虚拟机集群的方式。ACS使用Docker镜像，并提供了三种编排器选择：Kubernetes、Docker
    Swarm和DC/OS（由Apache Mesos提供支持）。微软声称他们的服务可以扩展到数万个容器。ACS是免费的，您只需要为计算资源付费。
- en: In this section, we will concentrate on the most popular offering, based on
    Kubernetes. It is called AKS and can be found here: [https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/).
    AKS makes it easy for you to deploy applications into the cloud and run them on
    Kubernetes. All the difficult and tedious management tasks are handled by Microsoft
    and you can concentrate fully on your applications. What that means is that you
    will never have to deal with tasks such as installing and managing Kubernetes,
    upgrading Kubernetes, or upgrading the operating system of the underlying Kubernetes
    nodes. All this is handled by the experts at Microsoft Azure. Furthermore, you
    will never have to deal with `etc` or Kubernetes master nodes. This is all hidden
    from you, and the only things you will interact with are the Kubernetes worker
    nodes that run your applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将集中讨论基于Kubernetes的最受欢迎的服务。它被称为AKS，可以在这里找到：[https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/)。AKS使您能够轻松将应用程序部署到云中，并在Kubernetes上运行它们。所有繁琐和困难的管理任务都由微软处理，您可以完全专注于您的应用程序。这意味着您永远不必处理诸如安装和管理Kubernetes、升级Kubernetes或升级底层Kubernetes节点操作系统等任务。所有这些都由微软Azure的专家处理。此外，您永远不必处理`etc`或Kubernetes主节点。这些都对您隐藏，您唯一需要与之交互的是运行您的应用程序的Kubernetes工作节点。
- en: Preparing the Azure CLI
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备Azure CLI
- en: That said, let's start. We assume that you have created a free trial account
    or that you are using an existing account on Azure. There are various ways to
    interact with your Azure account. We will use the Azure CLI running on our local
    computer. We can either download and install the Azure CLI natively on our computer
    or run it from within a container running on our local Docker for Desktop. Since
    this book is all about containers, let's select the latter approach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，让我们开始吧。我们假设您已经创建了一个免费试用账户，或者您正在使用Azure上的现有账户。与Azure账户交互的方式有很多种。我们将使用在本地计算机上运行的Azure
    CLI。我们可以在本地计算机上本地下载和安装Azure CLI，也可以在本地Docker for Desktop上运行容器中的Azure CLI。由于本书都是关于容器的，让我们选择后一种方法。
- en: 'The latest version of the Azure CLI can be found on Docker Hub. Let''s pull
    it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI的最新版本可以在Docker Hub上找到。让我们拉取它：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be running a container from this CLI and executing all subsequent commands
    from within the shell running inside this container. Now, there is a little problem
    we need to overcome. This container will not have a Docker client installed. But
    we will also run some Docker commands, so we have to create a custom image derived
    from the preceding image, which contains a Docker client. The `Dockerfile` that''s
    needed to do so can be found in the `~/fod/ch18` folder and has this content:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从此CLI运行一个容器，并在容器内部运行所有后续命令。现在，我们需要克服一个小问题。这个容器将不会安装Docker客户端。但我们也将运行一些Docker命令，所以我们必须创建一个从前面的镜像派生出来的自定义镜像，其中包含一个Docker客户端。需要的`Dockerfile`可以在`~/fod/ch18`文件夹中找到，内容如下：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On line 2, we are just using the Alpine package manager, `apk`, to install
    Docker. We can then use Docker Compose to build and run this custom image. The
    corresponding `docker-compose.yml` file looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们只是使用Alpine软件包管理器`apk`来安装Docker。然后我们可以使用Docker Compose来构建和运行这个自定义镜像。相应的`docker-compose.yml`文件如下：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note the command that is used to keep the container running, as well
    as the mounting of the Docker socket and the current folder in the `volumes` section. If
    you are running Docker for Desktop on Windows, then you need to define the `COMPOSE_CONVERT_WINDOWS_PATHS`
    environment variable to be able to mount the Docker socket. Use
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意用于保持容器运行的命令，以及在`volumes`部分中挂载Docker套接字和当前文件夹的命令。如果您在Windows上运行Docker for
    Desktop，则需要定义`COMPOSE_CONVERT_WINDOWS_PATHS`环境变量以能够挂载Docker套接字。使用
- en: '`export COMPOSE_CONVERT_WINDOWS_PATHS=1` from a Bash shell or `$Env:COMPOSE_CONVERT_WINDOWS_PATHS=1`
    when running PowerShell. Please refer to the following link for more details: [https://github.com/docker/compose/issues/4240](https://github.com/docker/compose/issues/4240).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Bash shell执行`export COMPOSE_CONVERT_WINDOWS_PATHS=1`，或者在运行PowerShell时执行`$Env:COMPOSE_CONVERT_WINDOWS_PATHS=1`。请参考以下链接获取更多详情：[https://github.com/docker/compose/issues/4240](https://github.com/docker/compose/issues/4240)。
- en: 'Now, let''s build and run this container:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行这个容器：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, let''s execute into the `az` container and run a Bash shell in it with
    the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们进入`az`容器，并在其中运行一个Bash shell，命令如下：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will find ourselves running in a Bash shell inside the container. Let''s
    first check the version of the CLI:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现自己在容器内部的Bash shell中运行。让我们首先检查CLI的版本：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should result in an output similar to this (shortened):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似于以下内容的输出（缩短版）：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'OK, we''re running on version `2.0.78`. Next, we need to log in to our account.
    Execute this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们正在运行版本`2.0.78`。接下来，我们需要登录到我们的账户。执行以下命令：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will be presented with the following message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下消息：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Follow the instructions and log in through the browser. Once you have successfully
    authenticated your Azure account, you can go back to your Terminal and you should
    be logged in, as indicated by the output you''ll get:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明通过浏览器登录。一旦您成功验证了您的Azure账户，您可以回到您的终端，您应该已经登录了，这将由您得到的输出所指示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we are ready to first move our container images to Azure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备首先将我们的容器映像移动到Azure。
- en: Creating a container registry on Azure
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure上创建一个容器注册表
- en: 'First, we create a new resource group named `animal-rg`. In Azure, resource
    groups are used to logically group a collection of associated resources. To have
    an optimal cloud experience and keep latency low, it is important that you select
    a data center located in a region near you. You can use the following command
    to list all regions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`animal-rg`的新资源组。在Azure中，资源组用于逻辑地组合一组相关的资源。为了获得最佳的云体验并保持延迟低，重要的是您选择一个靠近您的地区的数据中心。您可以使用以下命令列出所有地区：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will give you a rather long list of all possible regions you can select
    from. Use the `name`, for example, `eastasia`, to identify the region of your
    choice. In my case, I will be selecting `westeurope`. Please note that not all
    locations listed are valid for resource groups.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一个相当长的列表，列出了您可以选择的所有可能区域。使用`name`，例如`eastasia`，来标识您选择的区域。在我的情况下，我将选择`westeurope`。请注意，并非所有列出的位置都适用于资源组。
- en: 'The command to create a resource group is simple; we just need a name for the
    group and the location:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源组的命令很简单；我们只需要为组和位置命名：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make sure that your output shows `"provisioningState": "Succeeded"`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '确保您的输出显示`"provisioningState": "Succeeded"`。'
- en: When running a containerized application in production, we want to make sure
    that we can freely download the corresponding container images from a container
    registry. So far, we have always downloaded our images from Docker Hub. But this
    is often not possible. For security reasons, the servers of a production system
    often have no direct access to the internet and thus are not able to reach out
    to Docker Hub. Let's follow this best practice and assume the same for our Kubernetes
    cluster that we are going to create in an instant.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行容器化应用程序时，我们希望确保可以自由地从容器注册表中下载相应的容器图像。到目前为止，我们一直从Docker Hub下载我们的图像。但这通常是不可能的。出于安全原因，生产系统的服务器通常无法直接访问互联网，因此无法访问Docker
    Hub。让我们遵循这个最佳实践，并假设我们即将创建的Kubernetes集群也是如此。
- en: 'So, what can we do? Well, the solution is to use a container image registry
    that is close to our cluster and that is in the same security context. In Azure,
    we can create an **Azure container registry** (**ACR**) and host our images there.
    Let''s first create such a registry:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能做什么呢？嗯，解决方案是使用一个靠近我们集群的容器镜像注册表，并且处于相同的安全上下文中。在Azure中，我们可以创建一个**Azure容器注册表**（**ACR**）并在那里托管我们的图像。让我们首先创建这样一个注册表：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that `<acr-name>` needs to be unique. In my case, I have chosen the name
    `fodanimalsacr`. The (shortened) output looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<acr-name>`需要是唯一的。在我的情况下，我选择了名称`fodanimalsacr`。输出（缩短版）如下所示：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After successfully creating the container registry, we need to log in to that
    registry using the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建容器注册表后，我们需要使用以下命令登录到该注册表：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we are successfully logged in to the container registry on Azure, we need
    to tag our containers correctly so that we can then push them to ACR. Tagging
    and pushing images to ACR will be described next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功登录到Azure上的容器注册表，我们需要正确标记我们的容器，以便我们可以将它们推送到ACR。接下来将描述标记和推送图像到ACR。
- en: Pushing our images to ACR
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的图像推送到ACR
- en: 'Once we have successfully logged in to ACR, we can tag our images such that
    they can be pushed to the registry. For this, we need to get the URL of our ACR
    instance. We can do so with this command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功登录到ACR，我们就可以标记我们的图像，以便它们可以推送到注册表。为此，我们需要获取我们ACR实例的URL。我们可以使用以下命令来实现：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now use the preceding URL to tag our images:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用前面的URL来标记我们的图像：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can push them to our ACR:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将它们推送到我们的ACR中：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To double-check that our images are indeed in our ACR, we can use this command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了再次检查我们的图像确实在我们的ACR中，我们可以使用这个命令：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Indeed, the two images we just pushed are listed. With that, we are ready to
    create our Kubernetes cluster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们刚刚推送的两个图像已列出。有了这个，我们就可以创建我们的Kubernetes集群了。
- en: Creating a Kubernetes cluster
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Kubernetes集群
- en: 'Once again, we will be using our custom Azure CLI to create the Kubernetes
    cluster. We will have to make sure that the cluster can access our ACR instance,
    which we just created and is where our container images reside. So, the command
    to create a cluster named `animals-cluster` with two worker nodes looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用我们的自定义Azure CLI来创建Kubernetes集群。我们必须确保集群可以访问我们刚刚创建的ACR实例，那里存放着我们的容器映像。因此，创建一个名为`animals-cluster`的集群，带有两个工作节点的命令如下：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command takes a while, but after a few minutes, we should receive some
    JSON-formatted output with all the details about the newly created cluster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令需要一段时间，但几分钟后，我们应该会收到一些JSON格式的输出，其中包含了关于新创建的集群的所有细节。
- en: 'To access the cluster, we need `kubectl`. We can easily get it installed in
    our Azure CLI container using this command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问集群，我们需要`kubectl`。我们可以使用这个命令在我们的Azure CLI容器中轻松安装它：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Having installed `kubectl`, we need the necessary credentials to use the tool
    to operate on our new Kubernetes cluster in Azure. We can get the necessary credentials
    with this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`kubectl`之后，我们需要必要的凭据来使用这个工具在Azure中操作我们的新Kubernetes集群。我们可以用这个命令获取必要的凭据：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the success of the preceding command, we can list all the nodes in our
    cluster:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令成功执行后，我们可以列出集群中的所有节点：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As expected, we have two worker nodes up and running. The version of Kubernetes
    that is running on those nodes is `1.14.8`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们有两个工作节点正在运行。这些节点上运行的Kubernetes版本是`1.14.8`。
- en: We are now ready to deploy our application to this cluster. In the next section,
    we are going to learn how we can do this.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将我们的应用程序部署到这个集群中。在下一节中，我们将学习如何做到这一点。
- en: Deploying our application to the Kubernetes cluster
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序部署到Kubernetes集群
- en: 'To deploy the application, we can use the `kubectl apply` command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署应用程序，我们可以使用`kubectl apply`命令：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the preceding command should look similar to this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出应该类似于这样：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we want to test the application. Remember that we had created a service
    of type `LoadBalancer` for the web component. This service exposes the application
    to the internet. This process can take a moment, as AKS, among other tasks, needs
    to assign a public IP address to this service. We can observe this with the following
    command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要测试这个应用程序。记住，我们为web组件创建了一个`LoadBalancer`类型的服务。这个服务将应用程序暴露给互联网。这个过程可能需要一些时间，因为AKS除了其他任务外，还需要为这个服务分配一个公共IP地址。我们可以用以下命令观察到这一点：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Please note the `--watch` parameter in the preceding command. It allows us
    to monitor the progress of the command over time. Initially, we should see output
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上一个命令中的`--watch`参数。它允许我们随着时间监视命令的进展。最初，我们应该看到类似于这样的输出：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The public IP address is marked as pending. After a few minutes, that should
    change to this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 公共IP地址标记为待定。几分钟后，应该会变成这样：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our application is now ready at the IP address `51.105.229.192` and port number
    `3000`. Note that the load balancer maps the internal port `32618` to the external
    port `3000`; this was not evident to me the first time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在准备就绪，位于IP地址`51.105.229.192`和端口号`3000`。请注意，负载均衡器将内部端口`32618`映射到外部端口`3000`；这在第一次对我来说并不明显。
- en: 'Let''s check it out. In a new browser tab, navigate to `http://51.105.229.192:3000/pet`
    and you should see our familiar application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下。在新的浏览器标签中，导航至`http://51.105.229.192:3000/pet`，你应该能看到我们熟悉的应用程序：
- en: '![](assets/f45ab4b8-610f-4909-b6ce-4fce569200c8.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f45ab4b8-610f-4909-b6ce-4fce569200c8.png)'
- en: Our sample application running on AKS
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在AKS上运行的示例应用程序
- en: With that, we have successfully deployed our distributed application to Kubernetes
    hosted in Azure. We did not have to worry about installing or managing Kubernetes;
    we could concentrate on the application itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已成功将我们的分布式应用部署到了Azure中托管的Kubernetes。我们不必担心安装或管理Kubernetes；我们可以专注于应用本身。
- en: 'Now that we are done experimenting with the application, we should not forget
    to delete all resources on Azure to avoid incurring unnecessary costs. We can
    delete all resources created by deleting the resource group as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对应用程序的实验，我们不应忘记在Azure上删除所有资源，以避免产生不必要的成本。我们可以通过删除资源组来删除所有创建的资源，方法如下：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Azure has a few compelling offerings regarding the container workload, and the
    lock-in is not as evident as it is on AWS due to the fact that Azure does mainly offer open
    source orchestration engines, such as Kubernetes, Docker Swarm, DC/OS, and Rancher.
    Technically, we remain mobile if we initially run our containerized applications
    in Azure and later decide to move to another cloud provider. The cost should be
    limited.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Azure在容器工作负载方面有一些引人注目的提供，由于Azure主要提供开源编排引擎（如Kubernetes、Docker Swarm、DC/OS和Rancher），因此与AWS相比，锁定不太明显。从技术上讲，如果我们最初在Azure中运行我们的容器化应用程序，然后决定迁移到另一个云提供商，我们仍然可以保持灵活性。成本应该是有限的。
- en: It is worth noting that, when you delete your resource group, the Azure Active
    Directory service principal used by the AKS cluster is not removed. Refer to the
    online help for details on how to delete the service principal.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当您删除资源组时，AKS集群使用的Azure Active Directory服务主体不会被删除。有关如何删除服务主体的详细信息，请参考在线帮助。
- en: Next on the list is Google with their Kubernetes Engine.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是谷歌和他们的Kubernetes Engine。
- en: Understanding GKE
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解GKE
- en: 'Google is the inventor of Kubernetes and, to this date, the driving force behind
    it. You would therefore expect that Google has a compelling offering around hosted
    Kubernetes. Let''s have a peek into it now. To continue, you need to either have
    an existing account with Google Cloud or create a test account here: [https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial).
    Proceed with the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌是Kubernetes的发明者，迄今为止，也是其背后的推动力。因此，您会期望谷歌在托管Kubernetes方面有一个引人注目的提供。现在让我们来看一下。要继续，您需要在谷歌云上拥有现有帐户或在此创建一个测试帐户：[https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial)。按照以下步骤进行：
- en: In the main menu, select Kubernetes Engine. The first time you do that, it will
    take a few moments until the Kubernetes engine is initialized.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中，选择Kubernetes Engine。第一次这样做时，Kubernetes引擎初始化需要一些时间。
- en: Next, create a new project and name it `massai-mara`; this may take a moment.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新项目并将其命名为`massai-mara`；这可能需要一些时间。
- en: Once this is ready, we can create a cluster by clicking on Create Cluster in
    the popup.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦准备就绪，我们可以通过点击弹出窗口中的Create Cluster来创建一个集群。
- en: Select the **Your first cluster** template on the left-hand side of the form.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单的左侧选择**Your first cluster**模板。
- en: Name the cluster `animals-cluster`, select the region or zone that's closest
    to you, leave all other settings in the Create a Kubernetes Cluster form with
    their default values, and click on Create at the bottom of the form.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将集群命名为`animals-cluster`，选择离您最近的区域或区域，将创建Kubernetes集群表单中的所有其他设置保持为默认值，并在表单底部点击Create。
- en: 'It will again take a few moments to provision the cluster for us. Once the
    cluster has been created, we can open Cloud Shellby clicking on the shell icon
    in the upper-right corner of the view. This should look similar to the following
    screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次花费一些时间为我们提供集群。一旦集群创建完成，我们可以通过点击视图右上角的shell图标来打开Cloud Shell。这应该看起来类似于以下截图：
- en: '![](assets/f1bd8565-7c02-4260-bb8e-0dc482fc8051.png)The first Kubernetes cluster
    ready and Cloud Shell open in GKE'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Kubernetes集群已准备就绪，并且Cloud Shell在GKE中打开
- en: 'We can now clone our `labs` GitHub repository to this environment with the
    following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将我们的`labs`GitHub存储库克隆到这个环境中：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We should now find an `animals.yaml` file in the current folder, which we can
    use to deploy the animals application into our Kubernetes cluster. Have a look
    at the file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在当前文件夹中找到一个`animals.yaml`文件，我们可以使用它来将动物应用程序部署到我们的Kubernetes集群中。看一下这个文件：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It has pretty much the same content as the same file we used in the previous
    chapter. The two differences are these:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内容基本与我们在上一章中使用的文件相同。两个不同之处在于：
- en: We use a service of type `LoadBalancer` (instead of `NodePort`) to publicly
    expose the `web` component.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`LoadBalancer`类型的服务（而不是`NodePort`）来公开`web`组件。
- en: We do not use volumes for the PostgreSQL database since configuring StatefulSets
    correctly on GKE is a bit more involved than in Minikube. The consequence of this
    is that our animals application will not persist the state if the `db` pod crashes.
    How to use persistent volumes on GKE lies outside the scope of this book.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用卷来配置PostgreSQL数据库，因为在GKE上正确配置StatefulSets比在Minikube中更复杂一些。这样做的后果是，如果`db`
    pod崩溃，我们的动物应用程序将不会保持状态。如何在GKE上使用持久卷超出了本书的范围。
- en: Also, note that we are not using Google Container Registry to host the container
    images but are instead directly pulling them from Docker Hub. It is very easy,
    and similar to what we have learned in the section about AKS, to create such a
    container registry in Google Cloud.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们不是使用Google容器注册表来托管容器映像，而是直接从Docker Hub拉取它们。在Google Cloud中创建这样的容器注册表非常简单，类似于我们在AKS部分学到的内容。
- en: 'Before we can continue, we need to set up `gcloud` and `kubectl` credentials:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要设置`gcloud`和`kubectl`凭据：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Having done that, it''s time to deploy the application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，现在是部署应用程序的时候了：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the objects have been created, we can observe the `LoadBalancer` service `web` until
    it is assigned a public IP address:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象后，我们可以观察`LoadBalancer`服务`web`，直到它被分配一个公共IP地址：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second line in the output is showing the situation while the creation of
    the load balancer is still pending, and the third one gives the final state. Press
    *Ctrl* + *C* to quit the `watch` command. Apparently, we got the public IP address
    `146.148.23.70` assigned and the port is `3000`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的第二行显示了负载均衡器创建仍在等待的情况，第三行显示了最终状态。按*Ctrl* + *C*退出`watch`命令。显然，我们得到了分配的公共IP地址`146.148.23.70`，端口为`3000`。
- en: We can then use this IP address and navigate to `http://<IP address>:3000/pet`, and
    we should be greeted by the familiar animal image.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用此IP地址并导航至`http://<IP地址>:3000/pet`，我们应该会看到熟悉的动物图像。
- en: Once you are done playing with the application, delete the cluster and the project
    in the Google Cloud console to avoid any unnecessary costs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成应用程序的操作后，请删除Google Cloud控制台中的集群和项目，以避免不必要的成本。
- en: We have created a hosted Kubernetes cluster in GKE. We have then used Cloud
    Shell, provided through the GKE portal, to first clone our `labs` GitHub repository
    and then the `kubectl` tool to deploy the animals application into the Kubernetes
    cluster.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在GKE中创建了一个托管的Kubernetes集群。然后，我们使用GKE门户提供的Cloud Shell首先克隆了我们的`labs`GitHub存储库，然后使用`kubectl`工具将动物应用程序部署到Kubernetes集群中。
- en: When looking into a hosted Kubernetes solution, GKE is a compelling offering.
    It makes it very easy to start, and since Google is the main driving force behind
    Kubernetes, we can rest assured that we will always be able to leverage the full
    functionality of Kubernetes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究托管的Kubernetes解决方案时，GKE是一个引人注目的选择。它非常容易上手，而且由于Google是Kubernetes背后的主要推动力，我们可以放心地利用Kubernetes的全部功能。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter of the book, you first got a quick introduction to how
    to install and use Docker's UCP, which is part of Docker's enterprise offering
    on AWS. Then, you learned how to create a hosted Kubernetes cluster in AKS and
    run the animals application on it, followed by the same for Google's own hosted
    Kubernetes offering, GKE.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，你首先快速了解了如何安装和使用Docker的UCP，这是Docker在AWS上的企业产品的一部分。然后，你学会了如何在AKS上创建一个托管的Kubernetes集群，并在其上运行动物应用程序，接着是在Google自己的托管Kubernetes解决方案GKE上做同样的操作。
- en: I am honored that you selected this book, and I want to thank you for accompanying
    me on this journey, where we explored Docker containers and container orchestration
    engines. I hope that this book has served as a valuable resource on your learning
    journey. I wish you all the best and much success when using containers in your
    current and future projects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我很荣幸你选择了这本书，我想感谢你陪伴我一起探索Docker容器和容器编排引擎的旅程。我希望这本书对你的学习之旅有所帮助。祝你在当前和未来的项目中使用容器时一切顺利并取得成功。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your knowledge, please answer the following questions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你的知识，请回答以下问题：
- en: Give a high-level description of the tasks needed to provision and run Docker
    UPC on AWS.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请提供所需的任务高级描述，以在AWS上配置和运行Docker UPC。
- en: List a few reasons why you would select a hosted Kubernetes offering, such as
    Microsoft's AKS or Google's GKE, to run your applications on Kubernetes.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些选择托管的Kubernetes解决方案（如Microsoft的AKS或Google的GKE）来在Kubernetes上运行应用程序的原因。
- en: Name two reasons when using a hosted Kubernetes solution, such as AKS or GKE,
    to consider hosting your container images in the container registry of the respective
    cloud provider.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举两个使用托管的Kubernetes解决方案（如AKS或GKE）时，考虑将容器映像托管在相应云提供商的容器注册表的原因。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章为你提供了一些与本章讨论的主题相关的更多信息：
- en: Install individual Docker EE components on Linux servers at [https://dockr.ly/2vH5dpN](https://dockr.ly/2vH5dpN)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux服务器上安装单独的Docker EE组件 [https://dockr.ly/2vH5dpN](https://dockr.ly/2vH5dpN)
- en: Azure Container Service (AKS) at [https://bit.ly/2JglX9d](https://bit.ly/2JglX9d)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure容器服务（AKS）at [https://bit.ly/2JglX9d](https://bit.ly/2JglX9d)
- en: Google Kubernetes Engine at [https://bit.ly/2I8MjJx](https://bit.ly/2I8MjJx)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine at [https://bit.ly/2I8MjJx](https://bit.ly/2I8MjJx)
