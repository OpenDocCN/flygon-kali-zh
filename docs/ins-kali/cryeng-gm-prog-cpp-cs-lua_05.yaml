- en: Chapter 5. Creating Custom Actors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。创建自定义角色
- en: Using the CryENGINE actor system, we can create players or AI-controlled entities
    with custom behaviors to populate our game world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CryENGINE角色系统，我们可以创建具有自定义行为的玩家或AI控制实体，以填充我们的游戏世界。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning the purpose of actors and the core idea behind implementing them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解角色的目的以及实现它们背后的核心思想
- en: Creating a custom actor in C++ and C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++和C#中创建自定义角色
- en: Creating our first player camera handler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个玩家摄像头处理程序
- en: Implementing basic player movement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本玩家移动
- en: Introducing the actor system
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍角色系统
- en: We learned what game object extensions were, and how to use them, in [Chapter
    3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"), *Creating and
    Utilizing Custom Entities*. We'll be building upon this knowledge to create a
    custom actor in C++ and C#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。创建和利用自定义实体")中学习了游戏对象扩展是什么，以及如何使用它们，*创建和利用自定义实体*。我们将在此基础上创建一个C++和C#中的自定义角色。
- en: Actors are represented by the `IActor` struct, and they are the game object
    extensions in the core. This means that each actor has a backing entity, and a
    game object to handle networking and the `IActor` extension.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 角色由`IActor`结构表示，它们是核心中的游戏对象扩展。这意味着每个角色都有一个支持实体和一个处理网络和`IActor`扩展的游戏对象。
- en: Actors are handled by the `IActorSystem` interface, which manages the creation,
    removal, and registration of each actor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 角色由`IActorSystem`接口处理，该接口管理每个角色的创建、移除和注册。
- en: Channel identifiers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道标识符
- en: In networked contexts, each player is assigned a channel ID and an index for
    the Net Nub, which we'll cover further in [Chapter 8](ch08.html "Chapter 8. Multiplayer
    and Networking"), *Multiplayer and Networking*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上下文中，每个玩家都被分配一个通道ID和Net Nub的索引，我们将在[第8章](ch08.html "第8章。多人游戏和网络")中进一步介绍，*多人游戏和网络*。
- en: Actor spawning
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色生成
- en: 'Player actors should be spawned when a client connects to the game, inside
    `IGameRules::OnClientConnect`. To spawn an actor, use `IActorSystem::CreateActor`
    as shown:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色应在客户端连接到游戏时生成，在`IGameRules::OnClientConnect`中。要生成角色，请使用`IActorSystem::CreateActor`如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the previous code only applies to player-controlled actors. Non-player
    actors can be created at any time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，先前的代码仅适用于由玩家控制的角色。非玩家角色可以随时创建。
- en: Removing actors
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除角色
- en: 'To make sure that the player actor is properly removed when the client disconnects,
    we''ll need to manually remove it via the `IGameRules::OnClientDisconnect` callback:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在客户端断开连接时正确删除玩家角色，我们需要通过`IGameRules::OnClientDisconnect`回调手动删除它：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Forgetting to remove the players actor after they have disconnected is likely
    to result in crashes or severe artifacts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家断开连接后忘记移除玩家角色可能会导致崩溃或严重的伪影。
- en: The view system
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图系统
- en: In order to facilitate the need for a way to handle views for players and other
    camera sources, CryENGINE provides the view system, accessible via the `IViewSystem`
    interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足处理玩家和其他摄像头来源的视图的需求，CryENGINE提供了视图系统，可通过`IViewSystem`接口访问。
- en: The view system is based around having any number of views, represented by the
    `IView` interface, each with the ability to update the position, orientation,
    and configuration (such as the field of view) of the view camera.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 视图系统是围绕着任意数量的视图，由`IView`接口表示，每个视图都有更新位置、方向和配置（如视野）的能力。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that only one view can be active at any one point in time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一次只能激活一个视图。
- en: 'New views can be created using the `IViewSystem::CreateView` method as shown:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`IViewSystem::CreateView`方法创建新视图，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then set the active view using the `IViewSystem::SetActiveView` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`IViewSystem::SetActiveView`函数设置活动视图：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once activated, the view will update the system camera for each frame. To modify
    the parameters of your view, we can call `IView::SetCurrentParams`. For example,
    to change the position, use the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活，视图将在每一帧更新系统相机。要修改视图的参数，我们可以调用`IView::SetCurrentParams`。例如，要更改位置，请使用以下代码片段：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The current position of the view will now be (0, 0, 10).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当前视图的位置现在是（0，0，10）。
- en: Linking views to game objects
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将视图链接到游戏对象
- en: Each view can also link itself to a game object, allowing its game object extensions
    to subscribe to `UpdateView` and `PostUpdateView` functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图还可以将自己链接到游戏对象，允许其游戏对象扩展订阅`UpdateView`和`PostUpdateView`函数。
- en: These functions allow the position, orientation, and configuration of the assigned
    view of each frame, to be easily updated. For example, this is used for actors
    in order to provide an accessible way of creating custom camera handling for each
    player.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许每帧更新的视图的位置、方向和配置很容易地更新。例如，这用于角色，以提供为每个玩家创建自定义相机处理的可访问方式。
- en: For more information on camera handling, see the *Camera handling* section later
    in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关相机操作的更多信息，请参见本章后面的*相机操作*部分。
- en: Creating custom actors
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义角色
- en: Now that we know how the actor system works, we can move on to creating our
    first actor in C# and C++.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道角色系统是如何工作的，我们可以继续在C#和C++中创建我们的第一个角色。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, it is not possible to create actors purely using the Lua scripts.
    Typically, the actor is created in C++ and handles custom callbacks to a Lua script
    contained in the `Game/Scripts/Entities/Actors` folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，无法仅使用Lua脚本创建角色。通常，角色是在C++中创建的，并处理自定义回调以包含在`Game/Scripts/Entities/Actors`文件夹中的Lua脚本。
- en: Creating actors in C#
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中创建角色
- en: 'Using CryMono, we can create custom actors entirely in C#. To do so, we can
    derive from the `Actor` class as shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CryMono，我们可以完全在C#中创建自定义角色。为此，我们可以从`Actor`类派生，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code is the bare minimum for creating an actor in CryMono. You
    can then navigate to your game rules implementation and spawn the actor once the
    client connects via the `Actor.Create` static method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是在CryMono中创建演员的最低要求。然后你可以转到你的游戏规则实现，并在客户端连接时通过`Actor.Create`静态方法生成演员。
- en: The CryMono class hierarchy
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CryMono类层次结构
- en: 'If you find yourself confused by the various CryMono/C# classes, see the following
    inheritance graph:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对各种CryMono/C#类感到困惑，请参阅以下继承图：
- en: '![The CryMono class hierarchy](img/5909_05_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CryMono类层次结构](img/5909_05_01.jpg)'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while querying entities using `Entity.Get` (or actors via `Actor.Get`),
    you'll get an object of type `EntityBase` or `ActorBase`. This is because the
    native entities and actors exist outside the managed systems, and a limited representation
    is returned when queried for.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`Entity.Get`（或通过`Actor.Get`查询演员）查询实体时，你将得到一个`EntityBase`或`ActorBase`类型的对象。这是因为本地实体和演员存在于托管系统之外，当查询时返回了有限的表示。
- en: Using native and CryMono actors alongside each other
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同时使用本地和CryMono演员
- en: 'If you prefer creating your actor on your own in C++, you can still refer to
    it in CryMono code by using the `NativeActor` class. To do this, simply create
    a new class in C# with the name you registered your `IActor` implementation with,
    and derive from `NativeActor` as shown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在C++中自己创建你的演员，你仍然可以通过使用`NativeActor`类在CryMono代码中引用它。为此，只需在C#中创建一个新的类，名称与你注册的`IActor`实现相同，并从`NativeActor`派生，如下所示：
- en: C++ actor registration
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C++演员注册
- en: 'Actor registration is done using a registration factory. This process can be
    automated using the `REGISTER_FACTORY` macro as shown:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '演员注册是使用注册工厂完成的。这个过程可以使用`REGISTER_FACTORY`宏自动化，如下所示： '
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: C# declaration
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C#声明
- en: 'Declaring a native-based actor in C# is very easy, and only requires deriving
    from the `CryEngine.NativeActor` class as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中声明基于本地的演员非常简单，只需要从`CryEngine.NativeActor`类派生，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This allows C# code to still be used, but keeps the majority of your code in
    your C++ `IActor` implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许C#代码仍然可以使用，但保持大部分代码在你的C++ `IActor`实现中。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`CryEngine.NativeActor` derives directly from `CryEngine.ActorBase`, and, therefore,
    does not contain common `CryEngine.Actor` callbacks such as OnEditorReset. To
    get this additional functionality, you''ll need to create it in your `IActor`
    implementation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CryEngine.NativeActor`直接派生自`CryEngine.ActorBase`，因此不包含常见的`CryEngine.Actor`回调，比如OnEditorReset。要获得这个额外的功能，你需要在你的`IActor`实现中创建它。'
- en: Creating actors in C++
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中创建演员
- en: 'To create an actor in C++, we rely on the `IActor` interface. As actors are
    game object extensions in the core, we can''t simply derive from `IActor`, but
    have to use the `CGameObjectExtensionHelper` template as shown in the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中创建一个演员，我们依赖于`IActor`接口。由于演员是核心中的游戏对象扩展，我们不能简单地从`IActor`派生，而是必须像下面的代码中所示使用`CGameObjectExtensionHelper`模板：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The third `CGameObjectExtensionHelper` parameter defines the maximum number
    of RMI's (remote machine invocations) this game object supports. We'll cover it
    further in [Chapter 8](ch08.html "Chapter 8. Multiplayer and Networking"), *Multiplayer
    and Networking*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`CGameObjectExtensionHelper`参数定义了这个游戏对象支持的最大RMI（远程机器调用）数量。我们将在[第8章](ch08.html
    "第8章。多人游戏和网络")中进一步介绍，*多人游戏和网络*。
- en: Now that we have the class, we'll need to implement the pure virtual methods
    defined in the `IActor` struct.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个类，我们需要实现`IActor`结构中定义的纯虚方法。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `IActor` derives from `IGameObjectExtension`, which means that we'll
    also need to implement its pure virtual methods. For information on this, please
    see the *Implementing the game rules interface* section of [Chapter 4](ch04.html
    "Chapter 4. Game Rules"), *Game Rules*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IActor`派生自`IGameObjectExtension`，这意味着我们还需要实现它的纯虚方法。有关此信息，请参阅[第4章](ch04.html
    "第4章。游戏规则")中的*实现游戏规则接口*部分，*游戏规则*。
- en: 'For most of the `IActor` methods, we can implement dummies that either return
    nothing, or a dummy value such as nullptr, zero, or an empty string. The exceptions
    are listed in the following table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数`IActor`方法，我们可以实现虚拟方法，要么返回空，要么返回虚拟值，比如nullptr，零，或者空字符串。以下表格列出了例外情况：
- en: '| Function name | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IGameObjectExtension::Init` | Called to initialize the game object extension.
    Should call `IGameObjectExtension::SetGameObject` and `IActorSystem::AddActor`.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `IGameObjectExtension::Init` | 用于初始化游戏对象扩展。应该调用`IGameObjectExtension::SetGameObject`和`IActorSystem::AddActor`。
    |'
- en: '| Class destructor | Should always invoke `IActorSystem::RemoveActor`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 类析构函数 | 应该始终调用`IActorSystem::RemoveActor`。 |'
- en: '| `IActor::IsPlayer` | Used to determine whether the actor is controlled by
    a human player. We can simply return `GetChannelId() != 0` here, as the channel
    identifier is only non-zero for players. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `IActor::IsPlayer` | 用于确定演员是否由人类玩家控制。我们可以简单地返回`GetChannelId() != 0`，因为通道标识符只对玩家非零。
    |'
- en: '| `IActor::GetActorClassName` | Called to get the name of the actor class,
    for example, in our case `CMyCppActor`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `IActor::GetActorClassName` | 用于获取演员类的名称，例如，在我们的情况下是`CMyCppActor`。 |'
- en: '| `IActor::GetEntityClassName` | Helper function to get the name of the entity
    class. We can simply return `GetEntity()->GetClass()->GetName()`. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `IActor::GetEntityClassName` | 获取实体类的名称的辅助函数。我们可以简单地返回`GetEntity()->GetClass()->GetName()`。
    |'
- en: When you've resolved the pure virtual functions, move on to the next section
    to register your actor. After having done so, you can create your actor for connecting
    players in `IGameRules::OnClientConnect`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解决了纯虚函数后，继续下一节注册你的演员。完成后，你可以在`IGameRules::OnClientConnect`中为连接的玩家创建你的演员。
- en: Registering actors
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册演员
- en: 'To register an actor with the game framework (contained in `CryAction.dll`),
    we can use the same setup as we used while registering our C++ game rules implementation
    in `GameFactory.cpp`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏框架（包含在`CryAction.dll`中）中注册一个演员，我们可以使用与在`GameFactory.cpp`中注册C++游戏规则实现时相同的设置：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the previous code has been executed, you'll be able to spawn your actor
    via the `IActorSystem::CreateActor` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码之后，您将能够通过`IActorSystem::CreateActor`函数生成您的演员。
- en: Camera handling
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机处理
- en: Player-controlled actors manage the viewport camera within the `IActor::UpdateView(SViewParams
    &viewParams)` and `IActor::PostUpdateView(SViewParams &viewParams)` functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制的演员在`IActor::UpdateView(SViewParams &viewParams)`和`IActor::PostUpdateView(SViewParams
    &viewParams)`函数中管理视口摄像机。
- en: The `SViewParams` struct is used to define camera properties such as position,
    rotation, and field of view. By modifying the `viewParams` reference inside the
    `UpdateView` method, we can move our camera to the position we require for our
    game.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SViewParams`结构用于定义摄像机属性，如位置、旋转和视野。通过修改`UpdateView`方法中的`viewParams`引用，我们可以将摄像机移动到游戏所需的位置。'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CryMono actors receive and handle the `UpdateView(ref ViewParams viewParams)`
    and `PostUpdateView(ref ViewParams viewParams)` events in the same way C++ actors
    do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: CryMono演员以与C++演员相同的方式接收和处理`UpdateView(ref ViewParams viewParams)`和`PostUpdateView(ref
    ViewParams viewParams)`事件。
- en: Implementing IGameObjectView
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现IGameObjectView
- en: 'In order to get view events, we''ll need to implement and register a game object
    view. To do so, start by deriving from `IGameObjectView`, and implement the following
    two pure virtuals it includes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得视图事件，我们需要实现并注册一个游戏对象视图。要做到这一点，首先从`IGameObjectView`派生，并实现它包括的以下两个纯虚函数：
- en: '`UpdateView`: This is called to update the view position, rotation, and field
    of view'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateView`：用于更新视图位置、旋转和视野'
- en: '`PostUpdateView`: This is called after having updated the view'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostUpdateView`：在更新视图后调用'
- en: 'After implementing the game object view, we''ll need to make sure we capture
    it when our actor extension is initialized (in Init):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现游戏对象视图之后，我们需要确保在演员扩展初始化时捕获它（在Init中）：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your actor should now receive view update callbacks, which can be utilized
    to move the viewport camera. Don''t forget to release the view in your destructor:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的演员现在应该接收视图更新回调，可以利用它来移动视口摄像机。不要忘记在析构函数中释放视图：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a top-down camera
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建俯视摄像机
- en: To show how create a custom camera, we'll be expanding the sample we created
    in the previous chapter to add a custom top-down view camera. The idea is simply
    to view the character from the top, and follow its movements from a distance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何创建自定义摄像机，我们将扩展我们在上一章中创建的示例，添加一个自定义的俯视摄像机。简单来说，就是从上方查看角色，并从远处跟随其动作。
- en: To start, open your C# actor's `UpdateView` method, or implement it in your
    `.cs` source file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您的C#演员的`UpdateView`方法，或者在您的`.cs`源文件中实现它。
- en: View rotation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图旋转
- en: To make the view face the top of the player, we'll be using the second column
    of the player's rotation in order to get the up direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使视图朝向玩家的顶部，我们将使用玩家旋转的第二列来获取向上的方向。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Quaternions represent the player''s rotation in a manner that allows for easy
    interpolation and avoiding gimbal locks. You can obtain three columns representing
    directions of each quaternion: 0 (right), 1 (forward), and 2 (up). This is very
    useful, for example, to get a vector facing the player''s forward direction.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数以一种允许轻松插值和避免万向节锁的方式表示玩家的旋转。您可以获得代表每个四元数方向的三列：0（右）、1（前）、2（上）。例如，这非常有用，可以获得一个面向玩家前方的向量。
- en: 'Unless you''ve made any changes to your actors `UpdateView` function since
    the last function, it should look similar to the following code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您自上次函数以来对演员的`UpdateView`函数进行了任何更改，否则它应该看起来与以下代码片段类似：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This simply puts the view camera in the exactly same position as the player,
    with the same orientation. The first change we'll have to do is move the camera
    up a bit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将视角摄像机放在与玩家完全相同的位置，具有相同的方向。我们需要做的第一个改变是将摄像机向上移动一点。
- en: 'To do so, we''ll simply append the second column of the player''s rotation
    to its position, and placing the camera at the same x and y position as the player,
    but slightly above it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将简单地将玩家旋转的第二列附加到其位置，并将摄像机放置在与玩家相同的x和y位置，但略高于玩家：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Feel free to go in-game and check it out. When you''re ready, we also have
    to change the view rotation to look straight down:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随时随地进入游戏并查看。当您准备好时，我们还必须将视图旋转为直接向下：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Done! Our camera should now be facing straight down.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们的摄像机现在应该正对着下方。
- en: '![View rotation](img/5909_05_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![视图旋转](img/5909_05_02.jpg)'
- en: This is roughly what you should be seeing with the new camera.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致是您应该看到的新摄像机。
- en: 'Note the lack of a player character in view. This is because we haven''t loaded
    an object into the player entity. We can quickly resolve this by calling `EntityBase.LoadObject`
    in the `OnSpawn` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意视图中缺少玩家角色。这是因为我们还没有将对象加载到玩家实体中。我们可以通过在`OnSpawn`函数中调用`EntityBase.LoadObject`来快速解决这个问题：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should now be able to see a cube representing the player character in the
    scene. Note that it is also physicalized, allowing it to push or get pushed by
    other physicalized objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够在场景中看到代表玩家角色的立方体。请注意，它也是物理化的，允许它推动或被其他物理化的对象推动。
- en: '![View rotation](img/5909_05_03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![视图旋转](img/5909_05_03.jpg)'
- en: You should now have a basic understanding of how the player views function.
    To learn more, why not try and create your own camera, that is, an RPG-style isometric
    camera?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对玩家视图功能有了基本的了解。要了解更多，为什么不尝试创建您自己的摄像机，即RPG风格的等距摄像机？
- en: We can now move on to the next section, *Player input*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续下一节，*玩家输入*。
- en: Player inputs
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家输入
- en: 'Actors tend to be pretty boring when you can''t control them. To aid in mapping
    events to inputs, we can make use of the following three systems:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您无法控制演员时，演员往往会变得相当无聊。为了将事件映射到输入，我们可以利用以下三个系统：
- en: '| System name | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 系统名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| IHardwareMouse | Used when there is a need for getting mouse events directly,
    such as x/y screen position and mousewheel delta. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| IHardwareMouse | 当需要直接获取鼠标事件时使用，例如x/y屏幕位置和鼠标滚轮增量。 |'
- en: '| IActionMapManager | Allows the registration of callbacks linked to key bindings.
    This is the preferred approach for keyboard and mouse button input due to it allowing
    each player to customize their preferred inputs via their action map profile.Action
    maps are commonly exposed via an in-game interface to simplify key mapping for
    the end user. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| IActionMapManager | 允许注册与按键绑定相关的回调。这是首选的键盘和鼠标按钮输入方法，因为它允许每个玩家通过他们的行动地图配置文件自定义他们喜欢的输入方式。行动地图通常通过游戏界面公开，以简化最终用户的按键映射。|'
- en: '| IInput | Used to listen to raw input events, for example, to detect when
    the Space bar was pressed or released.It is not recommended to use raw input except
    for rare edge cases such as chat and text input, instead action maps are preferable.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| IInput | 用于监听原始输入事件，例如检测空格键何时被按下或释放。除了在聊天和文本输入等极少数情况下，不建议使用原始输入，而是使用行动地图更可取。|'
- en: The hardware mouse
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件鼠标
- en: 'The hardware mouse implementation provides the `IHardwareMouseEventListener`
    struct to allow receiving mouse event callbacks. After deriving from and implementing
    its pure virtuals, use `IHardwareMouse::AddListener` to utilize it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件鼠标实现提供了`IHardwareMouseEventListener`结构，允许接收鼠标事件回调。在派生并实现其纯虚函数后，使用`IHardwareMouse::AddListener`来使用它：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listeners are most commonly called from constructors or initialization functions.
    Make sure you don't register listeners twice, and always remove them in your class
    destructor to prevent dangling pointers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器通常在构造函数或初始化函数中调用。确保不要注册两次监听器，并始终在类析构函数中移除它们以防止悬空指针。
- en: Action maps
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动地图
- en: Briefly mentioned in the table earlier, action maps allow binding keys to a
    named action. This is used to allow simple re-mapping of inputs from different
    game states. For example, if you have a game with two types of vehicles, you might
    not want the same keys to be used for both.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中简要提到，行动地图允许将按键绑定到命名动作。这用于允许从不同的游戏状态简单重新映射输入。例如，如果你有一个有两种类型车辆的游戏，你可能不希望相同的按键用于两种车辆。
- en: Action maps also allow changing the key an action is mapped to in real time.
    This allows the player to customize their preferred input methods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 行动地图还允许实时更改动作映射到的按键。这允许玩家自定义他们喜欢的输入方式。
- en: Listening for action map events
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听行动地图事件
- en: The default action map profile is contained in `Game/Libs/Config/defaultProfile.xml`.
    When a game is released, the default profile is copied to the user's personal
    folder (typically in `My Games/Game_Title`) and can be modified by the user to
    remap keys, for example, to change which key triggers the **screenshot** action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的行动地图配置文件包含在`Game/Libs/Config/defaultProfile.xml`中。游戏发布时，默认配置文件会被复制到用户的个人文件夹（通常在`My
    Games/Game_Title`），用户可以修改它来重新映射按键，例如更改触发**截图**动作的按键。
- en: '![Listening for action map events](img/5909_05_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![监听行动地图事件](img/5909_05_04.jpg)'
- en: To listen to action map events, we'll first have to either create a new action
    in the profile xml, or choose an existing one and modify it. For this example,
    we'll utilize the existing screenshot action.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听行动地图事件，我们首先要么在配置文件中创建一个新的动作，要么选择一个现有的动作并修改它。在这个例子中，我们将利用现有的截图动作。
- en: IActionListener
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IActionListener
- en: The action map system provides the `IActionListener` struct to support providing
    callbacks for classes that require action map events.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 行动地图系统提供了`IActionListener`结构来支持为需要行动地图事件的类提供回调函数。
- en: 'Utilizing the listener is relatively easy:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 利用监听器相对容易：
- en: Derive from the `IActorListener` struct.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派生自`IActorListener`结构。
- en: Implement the `OnAction` event.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnAction`事件。
- en: 'Register your listener:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册你的监听器：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listeners should only be registered once, which is why registration is preferred
    to take place in a constructor or initialization function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器应该只注册一次，这就是为什么注册最好在构造函数或初始化函数中进行。
- en: Make sure to remove your listener when the class instance is destroyed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在类实例销毁时移除你的监听器。
- en: Enabling action map sections
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用行动地图部分
- en: The action map system allows for creating several action map sections in the
    same profile, giving the game code the ability to toggle different action map
    sections in real time. This is very useful for games with multiple player states,
    such as walking and using vehicles. In that case, the vehicle and walking action
    maps would be contained in different sections that are then enabled/disabled while
    exiting or entering vehicles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 行动地图系统允许在同一个配置文件中创建多个行动地图部分，使游戏代码能够实时切换不同的行动地图部分。这对于具有多个玩家状态的游戏非常有用，比如行走和使用车辆。在这种情况下，车辆和行走行动地图将包含在不同的部分中，然后在退出或进入车辆时启用/禁用它们。
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To enable your custom action map, call `IActionMapManager::EnableActionMap`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用自定义的行动地图，调用`IActionMapManager::EnableActionMap`：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This should be done at the precise moment the player should be able to receive
    these new actions. In the case of the previous example, enable the "walk" action
    when the player exits a vehicle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在玩家应该能够接收这些新动作的确切时刻完成。在前面的例子中，当玩家退出车辆时启用“行走”动作。
- en: Animated characters
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画角色
- en: '`IAnimatedCharacter` is a game object extension which allows for locomotion
    and physics integration for objects. By using it, characters can request physical
    move requests, utilize animation graph functionality, and more.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAnimatedCharacter`是一个游戏对象扩展，允许对象进行运动和物理整合。通过使用它，角色可以请求物理移动请求，利用动画图功能等。'
- en: As the extension is optional, it can be activated by any game object by simply
    acquiring it as explained in the [Chapter 3](ch03.html "Chapter 3. Creating and
    Utilizing Custom Entities"), *Creating and Utilizing Custom Entities*
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该扩展是可选的，任何游戏对象都可以通过简单获取它来激活它，如[第3章](ch03.html "第3章. 创建和利用自定义实体")中所述，*创建和利用自定义实体*
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once acquired, the animated character can be used right away.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取，动画角色可以立即使用。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Animated character functionality such as movement requests require eEPE_OnPostStepImmediate
    physics events, which can be enabled via `IGameObject::EnablePhysicsEvent`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 动画角色功能，如移动请求，需要通过`IGameObject::EnablePhysicsEvent`启用eEPE_OnPostStepImmediate物理事件。
- en: Movement requests
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动请求
- en: When an animated character is physicalized as a living entity, it can request
    movement. This is essentially a wrapper for the pe_action_move physics request
    (see [Chapter 9](ch09.html "Chapter 9. Physics Programming"), *Physics Programming*,
    for more information) to allow simpler usage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画角色作为生物实体物理化时，可以请求移动。这本质上是pe_action_move物理请求的包装（有关更多信息，请参见[第9章](ch09.html
    "第9章. 物理编程")，“物理编程”）以允许更简单的使用。
- en: Character movement requests are very useful when dealing with advanced mechanics
    such as player movement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 处理高级机制，如玩家移动时，角色移动请求非常有用。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the difference between requesting movement, and simply setting the player
    position directly. By requesting velocity changes, we are able to have our entity
    react to collisions naturally.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意请求移动和直接设置玩家位置之间的区别。通过请求速度变化，我们能够使我们的实体自然地对碰撞做出反应。
- en: Adding a movement request
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加移动请求
- en: 'To add movement requests, utilize `IAnimatedCharacter::AddMovement`, which
    requires a `SCharacterMoveRequest` object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加移动请求，利用`IAnimatedCharacter::AddMovement`，需要一个`SCharacterMoveRequest`对象：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Seen in the previous code is a very basic example of a movement request, which
    will set the target on a course forward (world-space) indefinitely (if submitted
    continuously).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中看到的是一个非常基本的移动请求示例，它将目标设置为无限制地向前（世界空间）（如果连续提交）。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Movement requests have to be added via the physics loop, see ENTITY_EVENT_PREPHYSICSUPDATE
    sent via `IGameObjectExtension::ProcessEvent`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 移动请求必须通过物理循环添加，参见通过`IGameObjectExtension::ProcessEvent`发送的ENTITY_EVENT_PREPHYSICSUPDATE。
- en: The Mannequin animation system
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模特动画系统
- en: Introduced with CryENGINE 3.5 is the high-level Mannequin animation system.
    The system was designed with the goal of decoupling animation and game logic,
    effectively sitting as an additional layer between the CryAnimation module and
    the game code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE 3.5引入了高级模特动画系统。该系统旨在解耦动画和游戏逻辑，有效地作为CryAnimation模块和游戏代码之间的附加层。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that Mannequin can be applied to any entity, not just actors. However,
    Mannequin is integrated by default into the `IAnimatedCharacter` extension, making
    it easier for actors to utilize the new animation system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，模特可以应用于任何实体，而不仅仅是演员。但是，默认情况下，模特集成到`IAnimatedCharacter`扩展中，使演员更容易利用新的动画系统。
- en: 'Mannequin relies on a set of types that should be clearly understood before
    starting to use it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用之前，模特依赖一组类型，这些类型应该在开始使用之前清楚地理解：
- en: '| Name | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Fragment | A fragment refers to a state, for example, "Landing". Each fragment
    can specify multiple animations on several layers, as well as a selection of effects.This
    allows for much smoother animations when dealing with, for example, first- and
    third-person views simultaneously. For that issue, each fragment would contain
    one full-body animation, one first-person, and then additional sounds, particles,
    and gameplay events. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 片段 | 片段指的是一个状态，例如，“着陆”。每个片段可以在多个层上指定多个动画，以及一系列效果。这允许在同时处理第一人称和第三人称视图时，动画更加流畅。对于这个问题，每个片段将包含一个全身动画，一个第一人称动画，然后额外的声音，粒子和游戏事件。
    |'
- en: '| Fragment ID | In order to avoid passing fragments directly, we can identify
    them by their Fragment ID. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 片段ID | 为了避免直接传递片段，我们可以通过它们的片段ID来识别它们。 |'
- en: '| Scope | Scopes allows the decoupling parts of characters in order to keep
    handle, for example, upper and lower body animations separately.While creating
    a new scope, each fragment will be able to add additional animations and effects
    to that scope to extend its behavior.For Crysis 3, the first- and third-person
    modes were declared as separate scopes in order to allow for the same fragments
    to handle both the states simultaneously. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 范围允许解耦角色的部分，以便保持处理，例如，上半身和下半身动画分开。在创建新的范围时，每个片段将能够向该范围添加额外的动画和效果，以扩展其行为。对于Crysis
    3，第一人称和第三人称模式被声明为单独的范围，以允许相同的片段同时处理这两种状态。 |'
- en: '| Tag | Tags refer to a selection criteria, allowing subfragments to be selected
    based on the tags active.For example, if we have two fragments named "Idle" but
    one assigned to the "Injured" tag, we could dynamically switch between the two
    fragment variations based on if the player is injured or not. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 标签是指选择标准，允许根据活动的标签选择子片段。例如，如果我们有两个名为“空闲”的片段，但一个分配给“受伤”标签，我们可以根据玩家是否受伤动态地在两个片段变化之间切换。
    |'
- en: '| Options | If we end up with multiple fragments that share the same identifier
    and tag, we have multiple options. The default behavior is to randomly select
    one of these options when the fragment is queried, effectively creating variation
    in the entity''s animations. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 如果我们最终有多个共享相同标识和标签的片段，我们有多种选择。默认行为是在查询片段时随机选择其中一个，从而有效地创建实体动画的变化。 |'
- en: The Mannequin Editor
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模特编辑器
- en: The **Mannequin Editor** is used to tweak character animations and mannequin
    configuration in real-time via the Sandbox Editor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**模特编辑器**用于通过沙盒编辑器实时调整角色动画和模特配置。'
- en: Preview setup
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预览设置
- en: The **Mannequin Editor** uses the preview files stored in `Animations/Mannequin/Preview`
    in order to load a default model and animation database. When starting the **Mannequin
    Editor**, we need to load our preview setup by selecting **File** | **Load Preview
    Setup**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**模特编辑器**使用存储在`Animations/Mannequin/Preview`中的预览文件，以加载默认模型和动画数据库。启动**模特编辑器**时，我们需要通过选择**文件**
    | **加载预览设置**来加载我们的预览设置。'
- en: 'Once loaded, we''ll be given a visual representation of the preview setup,
    as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，我们将得到预览设置的可视表示，如下面的截图所示：
- en: '![Preview setup](img/5909_05_05.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![预览设置](img/5909_05_05.jpg)'
- en: 'The contents of our preview file are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预览文件的内容如下：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll be going through the details such as controller definitions, context data,
    and more, further into the chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面进一步介绍控制器定义、上下文数据等详细信息。
- en: Creating contexts
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建上下文
- en: As mentioned earlier in the chapter, contexts can be used to apply different
    animations and effects based on the character state.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，上下文可用于根据角色状态应用不同的动画和效果。
- en: We can create and modify contexts via the **Context Editor**, accessible by
    selecting **File** | **Context Editor** in the **Mannequin Editor**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择**文件** | **上下文编辑器**在**人体模型编辑器**中访问**上下文编辑器**，来创建和修改上下文。
- en: '![Creating contexts](img/5909_05_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![创建上下文](img/5909_05_06.jpg)'
- en: 'To create a new context, simply click on **New** in the upper-left corner,
    resulting in the **New Context** dialog being opened, as shown in the following
    screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新上下文，只需单击左上角的**新建**，将打开**新上下文**对话框，如下屏幕截图所示：
- en: '![Creating contexts](img/5909_05_07.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![创建上下文](img/5909_05_07.jpg)'
- en: This allows us to tweak the context before creating it, including selecting
    which animation database and model to use.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在创建之前调整上下文，包括选择要使用的动画数据库和模型。
- en: When you're done, simply click on **OK** to see your context created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，只需单击**确定**即可查看您创建的上下文。
- en: Creating fragments
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建片段
- en: By default, we can see the fragments toolbox in the upper-left section of the
    **Mannequin Editor**. This tool is what we'll be using to create and edit fragments,
    in addition to adding or editing options.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们可以在**人体模型编辑器**的左上部看到片段工具箱。这个工具是我们将用来创建和编辑片段的工具，还可以添加或编辑选项。
- en: '![Creating fragments](img/5909_05_08.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![创建片段](img/5909_05_08.jpg)'
- en: Seen in the previous screenshot is the fragments toolbox with the **BackFlip**
    fragment opened up, exposing two options.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个屏幕截图中，可以看到片段工具箱中打开了**BackFlip**片段，显示了两个选项。
- en: To create a new fragment, click on the **New Id…** button, type in the desired
    name into the newly-opened message box, and then click on **OK**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新片段，请单击**新ID…**按钮，在新打开的消息框中输入所需的名称，然后单击**确定**。
- en: 'You should now see the **Mannequin FragmentID Editor** dialog as shown in the
    following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在**人体模型片段ID编辑器**对话框中看到如下屏幕截图所示：
- en: '![Creating fragments](img/5909_05_09.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![创建片段](img/5909_05_09.jpg)'
- en: We'll now be able to select which scopes this fragment should run in. In our
    case, we simply need to check **Char3P** and click on **OK**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够选择该片段应在哪些范围内运行。在我们的情况下，我们只需要检查**Char3P**并单击**确定**。
- en: 'You should now be able to see your fragment in the fragment toolbox:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够在片段工具箱中看到您的片段：
- en: '![Creating fragments](img/5909_05_10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![创建片段](img/5909_05_10.jpg)'
- en: Adding options
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加选项
- en: 'There are two methods to adding new options to your fragment:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以向片段添加新选项：
- en: Open the Character Editor, select your animation and then drag it onto your
    Mannequin Fragment.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开角色编辑器，选择您的动画，然后将其拖放到人体模型片段上。
- en: Click the New button in the Fragment toolbox, and manually modify the option.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在片段工具箱中单击新建按钮，然后手动修改选项。
- en: Creating and using tags
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用标签
- en: As mentioned earlier, the Mannequin system allows the creation of **Tags** that
    allow for selecting specific options for each Fragment based on if the tag is
    currently active or not.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，人体模型系统允许创建**标签**，允许根据标签当前是否激活来选择每个片段的特定选项。
- en: 'To create a new Tag, open the Mannequin Editor and select **File -> Tag Definition
    Editor**:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新标签，请打开人体模型编辑器，然后选择**文件 -> 标签定义编辑器**：
- en: '![Creating and using tags](img/5909_05_11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![创建和使用标签](img/5909_05_11.jpg)'
- en: 'Once opened, you''ll be presented with the **Mannequin Tag Definitions Editor**.
    The editor provides you with two sections: **Tag Definitions** and **Tags**.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开，您将看到**人体模型标签定义编辑器**。编辑器为您提供了两个部分：**标签定义**和**标签**。
- en: The first thing we'll need to do is create a **Tag Definition**. This is a file
    that keeps track of a set of tags. To do so, press the plus (*+*) symbol in the
    **Tag Definitions** section and then specify the name of your definition.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个**标签定义**。这是一个跟踪一组标签的文件。要这样做，请在**标签定义**部分按加号（*+*）符号，然后指定您的定义的名称。
- en: '![Creating and using tags](img/5909_05_12.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![创建和使用标签](img/5909_05_12.jpg)'
- en: Great! You should now see your tag definition in the **Mannequin Tag Definitions
    Editor**. To create a new tag, select **MyTags.xml** and click on the tag creation
    icon (third from the right in the **Tags** section).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您应该在**人体模型标签定义编辑器**中看到您的标签定义。要创建新标签，请选择**MyTags.xml**，然后单击标签创建图标（在**标签**部分的第三个）。
- en: 'This presents you with a **Tag Creation** dialog in which you only need to
    specify the name of your tag. When you''re done, click on **OK** and you should
    see the tag in the **Tags** section immediately (as shown in the following screenshot):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您呈现一个**标签创建**对话框，在其中您只需要指定您的标签的名称。完成后，单击**确定**，您应该立即在**标签**部分看到该标签（如下屏幕截图所示）：
- en: '![Creating and using tags](img/5909_05_13.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![创建和使用标签](img/5909_05_13.jpg)'
- en: Appending tags to Options
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向选项附加标签
- en: 'Now that you have created your custom tag(s), we can select any fragment option
    in the Fragment Editor and then look a bit further down to find the Tag Toolbox:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了自定义标签，我们可以在片段编辑器中选择任何片段选项，然后向下查找标签工具箱：
- en: '![Appending tags to Options](img/5909_05_14.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![向选项附加标签](img/5909_05_14.jpg)'
- en: By simply selecting the checkbox next to each tag when a fragment option is
    selected, we tell the animation system that the option should be prioritized when
    the specified tag is active.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在选择片段选项时简单地选中每个标签旁边的复选框，我们就告诉动画系统在指定标签激活时应优先考虑该选项。
- en: Saving
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存
- en: 'To save your **Mannequin Editor** changes, simply click on **File** | **Save
    Changes** and verify your changes in the **Mannequin File Manager** dialog that
    appears (as shown in the following screenshot):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存你的**Mannequin Editor**更改，只需点击**文件** | **保存更改**，并在出现的**Mannequin文件管理器**对话框中验证你的更改（如下截图所示）：
- en: '![Saving](img/5909_05_15.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Saving](img/5909_05_15.jpg)'
- en: When you're ready to save, simply click on **Save** to have the system update
    the files.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好保存时，只需点击**保存**，系统将更新文件。
- en: Starting fragments
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始片段
- en: In C++, fragments are represented by the `IAction` interface that can be implemented
    or extended freely by each game if it is desired.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，片段由`IAction`接口表示，可以由每个游戏自由实现或扩展。
- en: Queuing a fragment is done by calling the `IActionController::Queue` function,
    but before we do that we'll have to obtain our fragment's `FragmentId`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`IActionController::Queue`函数来排队一个片段，但在这之前，我们必须获取我们片段的`FragmentId`。
- en: Acquiring the fragment identifier
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取片段标识符
- en: 'To acquire the fragment identifier, we''ll have to get our current animation
    context in order to obtain the current controller definition, from which we can
    get the fragment ID:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取片段标识符，我们需要获取当前的动画上下文，以便从中获取当前的控制器定义，从中获取片段ID：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how we call `IAnimatedCharacter::GetAnimationContext`. As mentioned earlier
    in the chapter, the animated character extension implements Mannequin functionality
    for us.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何调用`IAnimatedCharacter::GetAnimationContext`。正如本章前面提到的，动画角色扩展为我们实现了Mannequin功能。
- en: Queuing the fragment
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排队片段
- en: 'Now that we have the fragment identifier, we can simply create a new instance
    of the action we choose to use. In our case, we''ll use the default Mannequin
    action exposed via the `TAction` template:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了片段标识符，我们可以简单地创建我们选择使用的动作的新实例。在我们的情况下，我们将使用通过`TAction`模板公开的默认Mannequin动作：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We now have our action, with priority 0\. The animation system will compare
    the priority of queued actions in order to determine which should be used. For
    example, if two actions are queued simultaneously, with one having priority 0
    and the other priority 1, the second action with priority 1 will be selected first.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了优先级为0的动作。动画系统将比较排队动作的优先级，以确定应该使用哪个。例如，如果两个动作同时排队，一个优先级为0，另一个优先级为1，那么优先级为1的第二个动作将首先被选择。
- en: 'Now to queue the action, simply call `IActionController::Queue`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要排队动作，只需调用`IActionController::Queue`：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Setting tags
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置标签
- en: 'To enable tags at runtime, we first have to obtain our tag''s identifier as
    shown:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时启用标签，我们首先需要获取我们标签的标识符，如下所示：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we simply have to call `CTagState::Set`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要调用`CTagState::Set`：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Done! Our tag is now activated, and will show as active in the animation system.
    If your action is set to update dynamically, it will select the appropriate option
    right away.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们的标签现在已激活，并将在动画系统中显示为活动状态。如果你的动作设置为动态更新，它将立即选择适当的选项。
- en: Forcing actions into requerying options
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制动作重新查询选项
- en: 'The default `IAction` implementation does not automatically select the relevant
    option when a tag is changed. To change this, we''ll need to create a new class
    that derives from it and override its `Update` function with the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`IAction`实现在更改标签时不会自动选择相关选项。要更改这一点，我们需要创建一个从中派生的新类，并用以下代码覆盖其`Update`函数：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What the previous code does is check when a better option is available, and
    select that instead.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码所做的是检查是否有更好的选项可用，并选择那个选项。
- en: Debugging Mannequin
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试Mannequin
- en: 'To enable Mannequin debug, we''ll need to append the `AC_DebugDraw` flag to
    the action controller:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Mannequin调试，我们需要向动作控制器附加`AC_DebugDraw`标志：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You are now presented with visual fragment and tag selection debug information.
    This is very useful when working with Mannequin.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将看到可视片段和标签选择调试信息。在使用Mannequin时非常有用。
- en: Setting up Mannequin for a custom entity
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为自定义实体设置Mannequin
- en: As mentioned earlier in the chapter, the animated character game object extension
    integrates Mannequin by default. This is very handy when using actors, but in
    some cases it might be relevant to use the functionality Mannequin provides on
    custom entities.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，动画角色游戏对象扩展默认集成了Mannequin。在使用演员时非常方便，但在某些情况下，可能需要在自定义实体上使用Mannequin提供的功能。
- en: 'To start, we''ll need to store pointers to our action controllers and animation
    contexts in our entity extension as shown:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在实体扩展中存储指向我们的动作控制器和动画上下文的指针，如下所示：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll then need to initialize Mannequin; this is commonly done in the game object
    extension's `PostInit` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要初始化Mannequin；这通常在游戏对象扩展的`PostInit`函数中完成。
- en: Initializing Mannequin
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Mannequin
- en: 'The first thing to do is get the Mannequin interfaces:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是获取Mannequin接口：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Loading the controller definition
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载控制器定义
- en: 'Next, we have to load the controller definition we created for our entity:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要加载为我们实体创建的控制器定义：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Great! Now that we have the controller definition, we can create our animation
    context with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们有了控制器定义，可以用以下代码创建我们的动画上下文：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now create our action controller:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的动作控制器：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Setting the active context
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置活动上下文
- en: Now that we have initialized our action controller, we'll need to set our default
    context.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了我们的动作控制器，我们需要设置默认的上下文。
- en: 'To start, get the context identifier:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取上下文标识符：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then load the animation database we''ll be using:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后加载我们将要使用的动画数据库：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once loaded, simply call `IActionController::SetScopeContext`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，只需调用`IActionController::SetScopeContext`：
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the context has been set, Mannequin is initialized and ready to process
    the queued fragments for your entity.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文设置好，Mannequin就初始化好了，可以处理你实体的排队片段。
- en: Remember that you can change scope context at any time using the `IActionController::SetScopeContext`
    function we used previously.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以随时使用之前使用过的`IActionController::SetScopeContext`函数来改变作用域上下文。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how the actor system functions and created custom
    actors in C# and C++. By looking at the input and camera systems, we'll be able
    to handle basic player input and view setups.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了演员系统的功能，并在C＃和C ++中创建了自定义演员。通过查看输入和摄像头系统，我们将能够处理基本的玩家输入和视图设置。
- en: You should also have a good understanding of the use cases of Mannequin, and
    how to set up custom entities to utilize them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该对Mannequin的用例有很好的理解，并知道如何设置自定义实体来利用它们。
- en: 'We now have all the core functionalities required for a game: flow nodes, entities,
    game rules, and actors. In the following chapters, we''ll build upon existing
    knowledge and go into detail on how these systems can be used together.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了游戏所需的所有核心功能：流节点、实体、游戏规则和演员。在接下来的章节中，我们将在现有知识的基础上进行扩展，并详细介绍这些系统如何一起使用。
- en: If you want to continue working on actors before moving on, feel free to try
    and implement your own actor customized for a new scenario; for example, an isometric
    camera paired with basic RPG player elements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在继续之前继续研究演员，请随时尝试并实现自己定制的演员，以适应新的情景；例如，配备基本RPG玩家元素的等距摄像头。
- en: In the next chapter, we'll be using the knowledge learned on actors to create
    **Artificial Intelligence** (**AI**).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用在演员身上学到的知识来创建**人工智能**（**AI**）。
