- en: Building a Weather App for Multiple Form Factors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多种形态因素构建天气应用程序
- en: 'Xamarin.Forms isn''t only be used for creating apps for phones; it can also
    be used for creating apps for tablets and desktop computers. In this chapter,
    we will build an app that will work on all of these platforms. As well as using
    three different form factors, we are also going to be working on three different
    operating systems: iOS, Android, and Windows.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms不仅可以用于创建手机应用程序；它也可以用于创建平板电脑和台式电脑应用程序。在本章中，我们将构建一个可以在所有这些平台上运行的应用程序。除了使用三种不同的形态因素外，我们还将在三种不同的操作系统上工作：iOS、Android和Windows。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use `FlexLayout` in Xamarin.Forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Xamarin.Forms中使用`FlexLayout`
- en: How to use `VisualStateManager`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`VisualStateManager`
- en: How to use different views for different form factors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为不同的形态因素使用不同的视图
- en: How to use behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用行为
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work on this project, we need to have Visual Studio for Mac or PC installed,
    as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin,* for more details on how to set up your environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发这个项目，我们需要安装Visual Studio for Mac或PC，以及Xamarin组件。有关如何设置您的环境的更多详细信息，请参阅[Xamarin简介](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)。
- en: Project overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Applications for iOS and Android can run on both phones and tablets. Very often,
    apps are just optimized for phones. In this chapter, we will build an app that
    will work on different form factors, but we aren't going to stick to just phones
    and tablets—we are going to target desktop computers as well. The desktop version
    will be for the **Universal Windows Platform** (**UWP**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android的应用程序可以在手机和平板上运行。很多时候，应用程序只是针对手机进行了优化。在本章中，我们将构建一个可以在不同形态因素上运行的应用程序，但我们不仅仅针对手机和平板——我们还将针对台式电脑。桌面版本将用于**Universal
    Windows Platform** (**UWP**)。
- en: The app that we are going to build is a weather app that displays the weather
    forecast based on the location of the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的应用程序是一个天气应用程序，根据用户的位置显示天气预报。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: We can use either Visual Studio 2017 for PC or Visual Studio for Mac to work
    on this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have access to a Mac at all, you can choose to just
    work on the Windows and Android parts of this project. Similarly, if you only
    have a Mac, you can choose to work on only the iOS and Android parts of this project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Visual Studio 2017 for PC或Visual Studio for Mac来开发这个项目。要使用Visual Studio
    for PC构建iOS应用程序，您必须连接Mac。如果您根本没有Mac，您可以选择只在这个项目的Windows和Android部分上工作。同样，如果您只有Mac，您可以选择只在这个项目的iOS和Android部分上工作。
- en: Building the weather app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气应用程序
- en: It's time to start building the app. Create a new blank Xamarin.Forms app using .NET
    Standard as the Code Sharing Strategy, and select iOS, Android, and Windows (UWP) as
    the platforms. We will name the project `Weather`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建应用程序了。使用.NET Standard作为代码共享策略，创建一个新的空白Xamarin.Forms应用程序，并选择iOS、Android和Windows
    (UWP)作为平台。我们将项目命名为`Weather`。
- en: As the data source for this app, we will use an external weather API. This project
    will use `OpenWeatherMap`, a service that offers a couple of free APIs. You can
    find this service at [https://openweathermap.org/api](https://openweathermap.org/).
    We will use the service called `5 day / 3 hour forecast `in this project, which
    provides a five-day forecast in three-hour intervals. To use the `OpenWeather`
    API, we have to create an account to get an API key. If you don't want to create
    an API key, we can mock the data instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个应用程序的数据源，我们将使用外部天气API。这个项目将使用`OpenWeatherMap`，这是一个提供几个免费API的服务。您可以在[https://openweathermap.org/api](https://openweathermap.org/)找到这个服务。在这个项目中，我们将使用名为`5
    day / 3 hour forecast`的服务，它提供了五天的三小时间隔的天气预报。要使用`OpenWeather` API，我们必须创建一个帐户以获取API密钥。如果您不想创建API密钥，我们可以使用模拟数据。
- en: Creating models for the weather data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为天气数据创建模型
- en: Before we write the code to fetch data from the external weather service, we
    will create models in order to deserialize the results from the service so that
    we have a common model that we can use to return data from the service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码从外部天气服务获取数据之前，我们将创建模型，以便从服务中反序列化结果，以便我们有一个通用模型，可以用来从服务返回数据。
- en: The easiest way to generate models to use when we are deserializing results
    from the service is to make a call to the service either in the browser or with
    a tool (such as Postman) to see the structure of the JSON. We can either create
    classes manually or use a tool that can generate C# classes from the JSON. One
    tool that can be used is **quicktype**, which can be found at [https://quicktype.io/](https://quicktype.io/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务中反序列化结果时，生成模型的最简单方法是在浏览器中或使用工具（如Postman）调用服务，以查看JSON的结构。我们可以手动创建类，也可以使用一个可以从JSON生成C#类的工具。可以使用的一个工具是**quicktype**，可以在[https://quicktype.io/](https://quicktype.io/)找到。
- en: If you generate them manually, make sure to set the namespace to `Weather.Models`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手动生成它们，请确保将命名空间设置为`Weather.Models`。
- en: As stated, you can also create these models manually. We will describe how to
    do this in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，您也可以手动创建这些模型。我们将在下一节中描述如何做到这一点。
- en: Adding the weather API models manually
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动添加天气API模型
- en: 'If you choose to add the models manually, then go through the following instructions.
    We will be adding a single code file called `WeatherData.cs` that will contain
    multiple classes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择手动添加模型，则按照以下说明进行。我们将添加一个名为`WeatherData.cs`的单个代码文件，其中包含多个类：
- en: In the `Weather` project, create a folder named `Models`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，创建一个名为`Models`的文件夹。
- en: Add a file called `WeatherData.cs`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`WeatherData.cs`的文件。
- en: 'Add the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there are quite a lot of classes. These map directly to the
    response we get from the service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有相当多的类。这些直接映射到我们从服务获取的响应。
- en: Adding the app-specific models
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加特定于应用程序的模型
- en: 'In this section, we will create the models that our app will translate the
    Weather API models into. Let''s start by adding the `WeatherData` class (unless
    you created this manually in the preceding section), using the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建我们的应用程序将天气API模型转换为的模型。让我们首先通过以下步骤添加`WeatherData`类（除非您在前一部分手动创建了它）：
- en: Create a new folder with the name `Models` in the `Weather` project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中创建一个名为`Models`的新文件夹。
- en: Add a new file with the name `WeatherData`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`WeatherData`的新文件。
- en: Paste or write the code for the classes based on the JSON. If code other than
    the properties is generated, ignore it and just use the properties.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴或编写基于JSON的类的代码。如果生成了除属性之外的代码，请忽略它，只使用属性。
- en: Rename `MainClass` (this is what quicktype names the root object) as `WeatherData`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainClass`（这是quicktype命名的根对象）重命名为`WeatherData`。
- en: We will now create models based on the data we are interested in. This will
    make the rest of the code more loosely coupled to the data source.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将根据我们感兴趣的数据创建模型。这将使代码的其余部分与数据源更松散地耦合。
- en: Adding the ForecastItem model
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ForecastItem模型
- en: 'The first model we are going to add is `ForecastItem`, which represents a specific
    forecast for a point in time. We do this by going through the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第一个模型是`ForecastItem`，它表示特定时间点的具体预报。具体步骤如下：
- en: In the `Weather` project, create a new class called `ForecastItem`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，创建一个名为`ForecastItem`的新类。
- en: 'Add the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding the Forecast model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Forecast模型
- en: 'Next, we''ll create a model called `Forecast` that will keep track of a single
    forecast for a city. The `Forecast` keeps a list of multiple `ForeCastItem` objects,
    each representing a forecast for a specific point in time. Let''s set this up
    by going through the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`Forecast`的模型，它将跟踪城市的单个预报。`Forecast`保留了多个`ForeCastItem`对象的列表，每个对象代表特定时间点的预报。让我们通过以下步骤设置这个：
- en: In the `Weather` project, create a new class called `Forecast`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，创建一个名为`Forecast`的新类。
- en: 'Add the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our models for both the Weather API and the app, we need to
    fetch data from the Weather API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为天气API和应用程序创建了模型，我们需要从天气API获取数据。
- en: Creating a service for fetching the weather data
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于获取天气数据的服务
- en: 'To make it easier to change the external weather service and to make the code
    more testable, we will create an interface for the service. Here''s how we go
    about it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地更改外部天气服务并使代码更具可测试性，我们将为服务创建一个接口。具体步骤如下：
- en: In the `Weather` project, create a new folder and name it `Services`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，创建一个新文件夹并命名为`Services`。
- en: Create a new `public interface` and name it `IWeatherService`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`public interface`并命名为`IWeatherService`。
- en: 'Add a method for fetching data based on the location of the user, as shown
    in the following code. Name the method `GetForecast`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个根据用户位置获取数据的方法，如下所示。将方法命名为`GetForecast`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we have an interface, we can create an implementation for it by going
    through the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了一个接口，我们可以通过以下步骤为其创建一个实现：
- en: In the `Services` folder, create a new class with the name `OpenWeatherMapWeatherService`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中，创建一个名为`OpenWeatherMapWeatherService`的新类。
- en: Implement the interface and add the `async` keyword to the `GetForecast` method.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口并在`GetForecast`方法中添加`async`关键字。
- en: 'The code should look as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we call the `OpenWeatherMap` API, we need to build a URI for the call
    to the Weather API. It will be a `GET` call and the latitude and longitude will
    be added as query parameters. We will also add the API key and the language in
    which we would like the response. Let''s set this up by going through the following
    steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`OpenWeatherMap` API之前，我们需要为调用天气API构建一个URI。这将是一个`GET`调用，纬度和经度将被添加为查询参数。我们还将添加API密钥和我们希望得到响应的语言。让我们通过以下步骤来设置这个：
- en: In the `WeatherProject`, open the `OpenWeatherMapWeatherService` class.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherProject`中，打开`OpenWeatherMapWeatherService`类。
- en: 'Add the code marked in bold in the following code fragment:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码片段中添加粗体标记的代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to deserialize the JSON that we will get from the external service,
    we will use `Json.NET`, the most popular NuGet package for serializing and deserializing
    JSON in .NET applications. We can install it using the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化我们从外部服务获取的JSON，我们将使用`Json.NET`，这是.NET应用程序中最流行的用于序列化和反序列化JSON的NuGet包。我们可以通过以下步骤安装它：
- en: Open the NuGet Package Manager.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开NuGet包管理器。
- en: Install the `Json.NET` package. The ID of the package is `Newtonsoft.Json`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Json.NET`包。包的ID是`Newtonsoft.Json`。
- en: 'To make the call to the `Weather` service, we will use the `HttpClient` class
    and the `GetStringAsync` method using the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用`Weather`服务，我们将使用`HttpClient`类和`GetStringAsync`方法，具体步骤如下：
- en: Create a new instance of the `HttpClient` class.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`HttpClient`类的新实例。
- en: Call `GetStringAsync` and pass the URL as the argument.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`GetStringAsync`并将URL作为参数传递。
- en: Use the `JsonConvert` class and the `DeserializeObject `method from `Json.NET`
    to convert the JSON string in to an object.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`JsonConvert`类和`Json.NET`的`DeserializeObject`方法将JSON字符串转换为对象。
- en: Map the `WeatherData` object to a `Forecast` object.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WeatherData`对象映射到`Forecast`对象。
- en: 'The code should look like the bold code in the following fragment:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应如下代码片段中的粗体代码所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To optimize the performance, we can use `HttpClient` as a singleton and reuse
    it for all network calls in the application. The following information is from
    Microsoft's documentation: *HttpClient** is intended to be instantiated once and
    reused throughout the life of an application. Instantiating an HttpClient class
    for every request will exhaust the number of sockets available under heavy loads.
    This will result in SocketException errors. *This can be found at: [https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0](https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化性能，我们可以将`HttpClient`用作单例，并在应用程序中的所有网络调用中重复使用它。以下信息来自Microsoft的文档：*HttpClient**旨在实例化一次并在应用程序的整个生命周期内重复使用。为每个请求实例化HttpClient类将在重负载下耗尽可用的套接字数量。这将导致SocketException错误。*这可以在以下网址找到：[https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0](https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0)。
- en: 'In the previous code, we have a call to a `ToDateTime` method, which is a method
    that we will need to create. This method converts the date from a Unix timestamp
    in to a `DateTime` object, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们调用了一个`ToDateTime`方法，这是一个我们需要创建的方法。该方法将日期从Unix时间戳转换为`DateTime`对象，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By default, `HttpClient` uses the Mono implementation of `HttpClient` (iOS and
    Android). To increase performance, we can use a platform-specific implementation
    instead. For iOS, use `NSUrlSession`. This can be set in the project settings
    of the iOS project under the iOS Build tab. For Android, use Android. This can
    be set in the project settings of the Android project under Android Options | Advanced.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`HttpClient`使用`HttpClient`的Mono实现（iOS和Android）。为了提高性能，我们可以改用特定于平台的实现。对于iOS，使用`NSUrlSession`。这可以在iOS项目的项目设置中的iOS
    Build选项卡下设置。对于Android，使用Android。这可以在Android项目的项目设置中的Android Options | Advanced下设置。
- en: Configuring the applications to use location services
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序以使用位置服务
- en: To be able to use location services, we need to carry out some configurations
    on each platform. We will use Xamarin.Essentials and the classes it contains.
    Ensure that you have installed Xamarin.Essentials from NuGet into all projects
    in the solution before going through the steps in the following sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用位置服务，我们需要在每个平台上进行一些配置。我们将使用Xamarin.Essentials及其包含的类。在进行以下各节中的步骤之前，请确保已将Xamarin.Essentials从NuGet安装到解决方案中的所有项目中。
- en: Configuring the iOS app to use location services
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置iOS应用程序以使用位置服务
- en: 'To use location services in an iOS app, we need to add a description to indicate
    why we want to use the location in the `info.plist` file. In this app, we only
    need to get the location when we are using the app, so we only need to add a description
    for this. Let''s set this up by going through the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在iOS应用程序中使用位置服务，我们需要在`info.plist`文件中添加描述，以指示为什么要在应用程序中使用位置。在这个应用程序中，我们只需要在使用应用程序时获取位置，因此我们只需要为此添加描述。让我们通过以下步骤设置这一点：
- en: Open `info.plist` in `Weather.iOS` with the XML (Text) Editor.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用XML（文本）编辑器在`Weather.iOS`中打开`info.plist`。
- en: 'Add the key, which is `NSLocationWhenInUseUsageDescription`, using the following
    code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加键`NSLocationWhenInUseUsageDescription`：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Configuring the Android app to use location services
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Android应用程序以使用位置服务
- en: 'For Android, we need to set the app to require the following two permissions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们需要设置应用程序需要以下两个权限：
- en: ACCESS_COARSE_LOCATION
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACCESS_COARSE_LOCATION
- en: ACCESS_FINE_LOCATION
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACCESS_FINE_LOCATION
- en: 'We can set this in the `AndroidManifest.xml` file that can be found in the
    `Properties` folder in the `Weather.Android` project, but we can also set it in
    the project properties under the Android Manifest tab as well, as shown in the
    following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Weather.Android`项目的`Properties`文件夹中找到的`AndroidManifest.xml`文件中设置这一点，但我们也可以在项目属性下的Android清单选项卡中设置，如下面的屏幕截图所示：
- en: '![](img/234daa3f-c5a6-471f-8efd-9a1b53904304.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/234daa3f-c5a6-471f-8efd-9a1b53904304.png)'
- en: 'When we request permissions in an Android app, we also need to add the following
    code to `MainActivity.cs` file in the Android project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Android应用程序中请求权限时，还需要在Android项目的`MainActivity.cs`文件中添加以下代码：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For Android, we also need to initialize Xamarin.Essentials. We will do this
    in the `OnCreate` method of the `MainActivity`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们还需要初始化Xamarin.Essentials。我们将在`MainActivity`的`OnCreate`方法中执行此操作：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring the UWP app to use location services
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置UWP应用程序以使用位置服务
- en: 'Since we will use location services in the UWP app, we need to add the Location
    capability under Capabilities in the `Package.appxmanifest` file of the `Weather.UWP`
    project, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在UWP应用程序中使用位置服务，因此我们需要在`Weather.UWP`项目的`Package.appxmanifest`文件的Capabilities下添加Location
    capability，如下面的屏幕截图所示：
- en: '![](img/2a04a344-7e1a-4ee7-9bd3-aa2124362a41.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a04a344-7e1a-4ee7-9bd3-aa2124362a41.png)'
- en: Creating the ViewModel class
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ViewModel类
- en: 'We now have a service that is responsible for fetching weather data from the
    external weather source. It''s time to create a `ViewModel`. First, however, we
    will create a base view model, where we can put the code that can be shared between
    all view models of the app. Let''s set this up by going through the following
    steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个负责从外部天气源获取天气数据的服务。是时候创建一个`ViewModel`了。但是，首先，我们将创建一个基本视图模型，在其中可以放置可以在应用程序的所有视图模型之间共享的代码。让我们通过以下步骤设置这一点：
- en: Create a new folder with the name `ViewModels`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModels`的新文件夹。
- en: Create a new class with the name `ViewModel`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModel`的新类。
- en: Make the new class `public` and `abstract`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使新类`public`和`abstract`。
- en: Add and implement the `INotifiedPropertyChanged` interface. This is necessary
    because we want to use data bindings.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并实现`INotifiedPropertyChanged`接口。这是必要的，因为我们想要使用数据绑定。
- en: 'Add a `Set` method that will make it easier to raise the `PropertyChanged`
    event from the `INotifiedPropertyChanged` interface, as shown in the following
    code. The method will check whether the value has changed. If it has, it will
    raise the event:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Set`方法，它将使得从`INotifiedPropertyChanged`接口中引发`PropertyChanged`事件更容易，如下所示。该方法将检查值是否已更改。如果已更改，它将引发事件：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `CallerMemberName` attribute can be used in a method body if you want the
    name of the method or the property that made the call to the method to be a parameter.
    We can always override this, however, by simply passing a value to it. The default
    value of the parameter is required when you are using the `CallerMember` attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在方法体中使用`CallerMemberName`属性，可以使用该方法的名称或调用该方法的属性作为参数。但是，我们可以通过简单地向其传递值来始终覆盖这一点。当使用`CallerMember`属性时，参数的默认值是必需的。
- en: We now have a base view model. We can use this for the view model that we are
    creating now, as well as for all of the other view models that we will add later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的视图模型。我们可以将其用于我们现在正在创建的视图模型，以及以后将添加的所有其他视图模型。
- en: 'It''s now time to create `MainViewModel`, which will be `ViewModel` for our
    `MainView` in the app. We do this by going through the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建`MainViewModel`了，它将是我们应用程序中`MainView`的`ViewModel`。我们通过以下步骤来实现这一点：
- en: In the `ViewModels` folder, create a new class called `MainViewModel`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中，创建一个名为`MainViewModel`的新类。
- en: Add the abstract `ViewModel` class as a base class.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将抽象的`ViewModel`类添加为基类。
- en: Because we are going to use constructor injection, we will add a constructor
    with the `IWeatherService` interface as a parameter.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用构造函数注入，所以我们将添加一个带有`IWeatherService`接口作为参数的构造函数。
- en: 'Create a read-only `private` field that we will use to store the `IWeatherService`
    instance using the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个只读的`private`字段，我们将使用它来存储`IWeatherService`实例，使用以下代码：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MainViewModel` takes any object that implements `IWeatherService` and stores
    a reference to that service in a field. We will be adding functionality to fetch
    weather data in the next section.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel`接受任何实现`IWeatherService`的对象，并将对该服务的引用存储在一个字段中。我们将在下一节中添加获取天气数据的功能。'
- en: Getting the weather data
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取天气数据
- en: We will now create a new method for loading the data. This will be a three-step
    process. First, we will get the location of the user. Once we have this, we can
    fetch data related to that location. The final step is to prepare the data that
    the views can consume to create a user interface for the user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的加载数据的方法。这将是一个三步过程。首先，我们将获取用户的位置。一旦我们拥有了这个，我们就可以获取与该位置相关的数据。最后一步是准备数据，以便视图可以使用它来为用户创建用户界面。
- en: 'To get the location of the user, we will use Xamarin.Essentials, which we installed
    earlier as a NuGet package, and the `Geolocation` class, which exposes methods
    to fetch the location of the user. We do this by going through the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取用户的位置，我们将使用Xamarin.Essentials，这是我们之前安装的NuGet包，以及`Geolocation`类，该类公开了获取用户位置的方法。我们通过以下步骤来实现这一点：
- en: Create a new method called `LoadData`. Make it an asynchronous method that returns
    a `Task`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`LoadData`的新方法。将其设置为异步方法，返回一个`Task`。
- en: Use the `GetLocationAsync` method on the `Geolocation` class to get the location
    of the user.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Geolocation`类上的`GetLocationAsync`方法获取用户的位置。
- en: 'Pass the latitude and longitude from the result of the `GetLocationAsync` call
    and pass it to the `GetForecast` method on the object that implements `IWeatherService`
    using the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetLocationAsync`调用的结果中传递纬度和经度，并将其传递给实现`IWeatherService`的对象上的`GetForecast`方法，使用以下代码：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Grouping the weather data
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对天气数据进行分组
- en: 'When we present the weather data, we will group it by day so that all of the
    forecasts for one day will be under the same header. To do this, we will create
    a new model that we will name `ForecastGroup`. To make it possible to use this
    model with the Xamarin.Forms `ListView`, it has to have an `IEnumerable` type
    as the base class. Let''s set this up by going through the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们呈现天气数据时，我们将按天分组，以便所有一天的预报都在同一个标题下。为此，我们将创建一个名为`ForecastGroup`的新模型。为了能够将此模型与Xamarin.Forms的`ListView`一起使用，它必须具有`IEnumerable`类型作为基类。让我们通过以下步骤来设置这一点：
- en: Create a new class called `ForecastGroup` in the `Models` folder.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹中创建一个名为`ForecastGroup`的新类。
- en: Add `List<ForecastItem>` as the base class for the new model.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`List<ForecastItem>`添加为新模型的基类。
- en: Add an empty constructor and a constructor that has a list of `ForecastItem` instances
    as a parameter.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空构造函数和一个带有`ForecastItem`实例列表作为参数的构造函数。
- en: Add a `Date` property.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Date`属性。
- en: Add a property, `DateAsString`, that returns the `Date` property as a short
    date string.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`DateAsString`的属性，返回`Date`属性的短日期字符串。
- en: 'Add a property, `Items`, that returns the list of `ForecastItem` instances,
    as shown in the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Items`的属性，返回`ForecastItem`实例的列表，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we have done this, we can update `MainViewModel` with two new properties
    by going through the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以通过以下步骤更新`MainViewModel`，添加两个新属性：
- en: Create a property called `City` for the name of the city for which we are fetching
    the weather data.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们获取天气数据的城市名称创建一个名为`City`的属性。
- en: Create a property called `Days` that will contain the grouped weather data.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Days`的属性，用于包含分组的天气数据。
- en: 'The `MainViewModel` class should look like the bold code in the following fragment:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainViewModel`类应该像以下片段中的粗体代码一样：'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are now ready to do the actual grouping of the data. We will do this in
    the `LoadData` method. We will loop through the data from the service and add
    items to groups by going through the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备对数据进行实际分组。我们将在`LoadData`方法中执行此操作。我们将通过以下步骤循环遍历来自服务的数据，并通过以下步骤将项目添加到组中：
- en: Create a `itemGroups `variable of the `List<ForecastGroup>`type .
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`itemGroups`变量，类型为`List<ForecastGroup>`。
- en: Create a `foreach` loop that loops through all items in the `forecast` variable.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个“foreach”循环，循环遍历“forecast”变量中的所有项目。
- en: Add an `if` statement that checks whether the `itemGroups` property is empty.
    If it is empty, add a new `ForecastGroup` to the variable and continue to the
    next item in the item list.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“if”语句，检查“itemGroups”属性是否为空。如果为空，向变量中添加一个新的“ForecastGroup”，并继续到项目列表中的下一个项目。
- en: Use the `SingleOrDefault` method (this is an extension method from System.Linq)
    on the `itemGroups` variable to get a group based on the date of the current `ForecastItem`.
    Add the result to a new variable, `group`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“itemGroups”变量上使用“SingleOrDefault”方法（这是System.Linq中的一个扩展方法），以根据当前“ForecastItem”的日期获取一个组。将结果添加到一个新变量“group”中。
- en: If the group property is `null`, then there is no group with the current day
    in the list of groups. If this is the case, a new `ForecastGroup` should be added to
    the list in the `itemGroups` variable, and the execution of the code will continue
    to the next `forecast` item in the `forecast.Items` list. If a group is found,
    it should be added to the list in the `itemGroups` variable.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果group属性为null，则列表中没有当前日期的组。如果是这种情况，应向“itemGroups”变量中添加一个新的“ForecastGroup”，并且代码的执行将继续到“forecast.Items”列表中的下一个“forecast”项目。如果找到一个组，则应将其添加到“itemGroups”变量中的列表中。
- en: After the `foreach` loop, set the `Days` property with a new `ObservableCollection<ForecastGroup>`and
    use the `itemGroups` variable as an argument in the constructor.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“foreach”循环之后，使用新的“ObservableCollection<ForecastGroup>”设置“Days”属性，并将“itemGroups”变量作为构造函数的参数。
- en: Set the `City` property to the `City` property of the `forecast` variable.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“City”属性设置为“forecast”变量的“City”属性。
- en: 'The `LoadData` method should now look as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，“LoadData”方法应该如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don't use the `Add` method on `ObservableCollection` when you want to add more
    than a couple of items. It is better to create a new instance of `ObservableCollection`
    and pass a collection to the constructor. The reason for this is that every time
    you use the `Add` method, you will have a binding to it from the view, and it
    will trigger a rendering of the view. We will get a better performance if we avoid
    using the `Add` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要添加多个项目时，不要在“ObservableCollection”上使用“Add”方法。最好创建一个新的“ObservableCollection”实例，并将集合传递给构造函数。原因是每次使用“Add”方法时，您都会从视图中进行绑定，并且它将触发视图的渲染。如果我们避免使用“Add”方法，我们将获得更好的性能。
- en: Creating a Resolver
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Resolver
- en: 'We will create a helper class for **Inversion of Control** (**IoC**). This
    will help us to create types based on a configured IoC container. In this project,
    we will use Autofac as the IoC library. Let''s set this up by going through the
    following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为**Inversion of Control**（**IoC**）创建一个辅助类。这将帮助我们基于配置的IoC容器创建类型。在这个项目中，我们将使用Autofac作为IoC库。让我们通过以下步骤来设置这一点：
- en: Install the NuGet package Autofac in the `Weather` project.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Weather”项目中安装NuGet包Autofac。
- en: Create a new class called `Resolver` in the `Weather` project.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Weather”项目中创建一个名为“Resolver”的新类。
- en: Add a `private static` field called `container` of the `IContainer` type (from
    Autofac).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“container”的“private static”字段，类型为“IContainer”（来自Autofac）。
- en: Add a `public static` method called `Initialize` with `IContainer` as a parameter.
    Set the value of the parameter to the `container` field.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“Initialize”的“public static”方法，带有“IContainer”作为参数。将参数的值设置为“container”字段。
- en: Add a generic `public static` method called `Resolve<T>`, which will return
    an instance of an object of the type specified with the `T` parameter. The `Resolve<T>`
    method will then call the `Resolve<T>` method on the `IContainer` instance that
    was passed to it during initialization.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“Resolve<T>”的通用的“public static”方法，它将返回指定类型的对象实例。然后，“Resolve<T>”方法将调用传递给它的“IContainer”实例上的“Resolve<T>”方法。
- en: 'The code should now look like the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在代码应该如下所示：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating a bootstrapper
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个bootstrapper
- en: 'In this section, we will create a `Bootstrapper` class that we will use to
    set up the common configurations that we need in the startup phase of the app.
    Usually, there is one part of the bootstrapper for each target platform and one
    that is shared for all platforms. In this project, we only need the shared part.
    Let''s set this up by going through the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个“Bootstrapper”类，用于在应用程序启动阶段设置我们需要的常见配置。通常，每个目标平台都有一个bootstrapper的部分，而所有平台都有一个共享的部分。在这个项目中，我们只需要共享部分。让我们通过以下步骤来设置这一点：
- en: In the `Weather` project, create a new class called `Bootstrapper`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Weather”项目中，创建一个名为“Bootstrapper”的新类。
- en: Add a new `public static` method called `Init`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“Init”的新的“public static”方法。
- en: Create a new `ContainerBuilder` and register the types to `container`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“ContainerBuilder”并将类型注册到“container”中。
- en: Create a `Container` by using the `Build` method of the `ContainerBuilder`.
    Create a variable called `container` that contains the instance of `Container`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“ContainerBuilder”的“Build”方法创建一个“Container”。创建一个名为“container”的变量，其中包含“Container”的实例。
- en: Use the `Initialize` method on `Resolver` and pass `container` variable as an
    argument.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Resolver”上使用“Initialize”方法，并将“container”变量作为参数传递。
- en: 'The `Bootstrapper` class should now look like the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在“Bootstrapper”类应该如下所示：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Call the `Init` method of `Bootstrapper` in the constructor in the `App.xaml.cs`
    file after the call to the `InitializeComponent` method. Also, set the `MainPage` property
    to `MainView`, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在“App.xaml.cs”文件的构造函数中调用“Bootstrapper”的“Init”方法，该方法在调用“InitializeComponent”方法后调用。另外，将“MainPage”属性设置为“MainView”，如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating a RepeaterView based on a FlexLayout
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于FlexLayout创建一个RepeaterView
- en: In Xamarin.Forms, we can use `ListView` if we want to show a collection of data.
    Using `ListView` is great, and we will use it later in this chapter, but it can
    only show data vertically. In this app, we want to show data in both directions.
    In the vertical direction, we will have the days (we group forecasts based on
    days), while in the horizontal direction, we will have the forecasts within a
    particular day. We also want the forecasts within a day to wrap if there is not
    enough space for all of them in one row. With `FlexLayout`, we are able to add
    items in both directions. However, `FlexLayout` is a layout, which means that
    we can't bind items to it, so we have to extend its functionality. We will name
    our extended `FlexLayout` `RepeaterView`. The `RepeaterView` class will render
    content based on a `DataTemplate` and the items added to it will appear as if
    you have used `ListView`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中，如果我们想显示一组数据，可以使用`ListView`。使用`ListView`非常方便，我们稍后会在本章中使用它，但它只能垂直显示数据。在这个应用程序中，我们希望在两个方向上显示数据。在垂直方向上，我们将有天数（根据天数分组预测），而在水平方向上，我们将有特定一天内的预测。我们还希望一天内的预测在一行中没有足够的空间时换行。使用`FlexLayout`，我们可以在两个方向上添加项目。但是，`FlexLayout`是一个布局，这意味着我们无法将项目绑定到它，因此我们必须扩展其功能。我们将命名我们扩展的`FlexLayout`为`RepeaterView`。`RepeaterView`类将基于`DataTemplate`和添加到其中的项目呈现内容，就像使用了`ListView`一样。
- en: 'Let''s create `RepeaterView` by following these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建`RepeaterView`：
- en: Create a new folder called `Controls` in the `Weather` project.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中创建一个名为`Controls`的新文件夹。
- en: Add a new class called `RepeaterView` to the `Controls` folder.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Controls`文件夹中添加一个名为`RepeaterView`的新类。
- en: Create an empty method called `Generate`**. **We will add code to this method
    later.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Generate`的空方法。我们稍后会向这个方法添加代码。
- en: Create a new private field called `itemsTemplate` of the `DataTemplate`type.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`itemsTemplate`的`DataTemplate`类型的新私有字段。
- en: 'Create a new property called `ItemsTemplate` of the `DataTemplate`type. The
    `get` method will just return the `itemsTemplate` field. The `set` method will
    set the `itemsTemplate` field to the new value. However, it will also call the
    `Generate` method to trigger a regeneration of the data when we have a new template
    that needs to be generated. The generation has to be done on the main thread,
    as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ItemsTemplate`的`DataTemplate`类型的新属性。`get`方法将只返回`itemsTemplate`字段。`set`方法将设置`itemsTemplate`字段为新值。但是，它还将调用`Generate`方法来触发数据的重新生成。生成必须在主线程上进行，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to bind to a property, we need to add `BindableProperty` by going
    through the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绑定到属性，我们需要按照以下步骤添加`BindableProperty`：
- en: Add a `public static BindableProperty` field called `ItemsSourceProperty` that
    returns `null` as a default value.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ItemsSourceProperty`的`public static BindableProperty`字段，返回默认值为`null`。
- en: Add a `public` property called `ItemsSource`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ItemsSource`的`public`属性。
- en: Add a setter to the `ItemSource` that sets the value of `ItemsSourceProperty`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`ItemSource`添加一个setter，设置`ItemsSourceProperty`的值。
- en: 'Add a getter to the `ItemsSource` property that returns the value of `ItemsSourceProperty`,
    as shown in the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ItemsSource`属性的getter，返回`ItemsSourceProperty`的值，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In a bindable property declaration like the one in the preceding code, we can
    take action on different actions. The one we are interested in is the `propertyChanged`
    action. If we assign a delegate to this property, then it will get called any
    time that property changes in value and we can take action on that change. In
    this case, we will regenerate the content of `RepeaterView`. We do this by going
    through the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中的可绑定属性声明中，我们可以对不同的操作采取行动。我们感兴趣的是`propertyChanged`操作。如果我们为此属性分配一个委托，那么每当该属性的值发生变化时，它都会被调用，我们可以对该变化采取行动。在这种情况下，我们将重新生成`RepeaterView`的内容。我们通过以下步骤来实现这一点：
- en: Add a property-changed delegate (as shown in the following code) as an argument
    to the `Create` method of `BindableProperty` to regenerate the UI when the `ItemsSource` property
    changes.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性更改委托（如下面的代码所示）作为`BindableProperty`的`Create`方法的参数，以在`ItemsSource`属性更改时重新生成UI。
- en: 'Check that `DateTemplate` is not `null` before regenerating the UI on the main
    thread, as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主线程上重新生成UI之前，检查`DateTemplate`是否不为`null`，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The last step of `RepeaterView` is to generate content in the `Generate` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeaterView`的最后一步是在`Generate`方法中生成内容。'
- en: 'Let''s implement the `Generate` method by going through the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来实现`Generate`方法：
- en: Clear all child controls with `Children.Clear();`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除所有子控件，使用`Children.Clear();`。
- en: Verify that `ItemSource` is not `null`. If it is `null`, do an empty `return`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`ItemSource`不为`null`。如果为`null`，则返回空。
- en: 'Loop through all items and generate content from `DataTemplate`. Set the current
    item as `BindingContext` and add it as a child of `FlexLayout`, as shown in the
    following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历所有项目，并从`DataTemplate`生成内容。将当前项目设置为`BindingContext`并将其添加为`FlexLayout`的子项，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating the view for tablets and desktop computers
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为平板电脑和台式电脑创建视图
- en: 'The next step is to create the view that we will use when the app is running
    on a tablet or a desktop computer. Let''s set this up by going through the following
    steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建应用程序在平板电脑或台式电脑上运行时将使用的视图。让我们通过以下步骤设置这一点：
- en: Create a new folder in the `Weather` project and name it `Views`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中创建一个名为`Views`的新文件夹。
- en: Create a new Content Page with XAML and name it `MainView`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用XAML创建一个名为`MainView`的新内容页。
- en: 'Use the `Resolver` in the constructor of the view to set`BindingContext` to `MainViewModel`,
    as shown in the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的构造函数中使用`Resolver`将`BindingContext`设置为`MainViewModel`，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To trigger `LoadData` method in `MainViewModel`, call the `LoadData` method by
    overriding the `OnAppearing` method on the main thread. We need to make sure that
    the call gets marshaled to the UI thread since it will interact directly with
    the user interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`OnAppearing`方法在主线程上调用`LoadData`方法来触发`MainViewModel`中的`LoadData`方法。我们需要确保调用被调度到UI线程，因为它将直接与用户界面交互。
- en: 'To do this, follow these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤进行：
- en: In the `Weather` project, open the `MainView.xaml.cs` file.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView.xaml.cs`文件。
- en: Create an override of the `OnAppearing` method.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`OnAppearing`方法的重写。
- en: 'Add the code in bold in the following fragment:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下片段中加粗显示的代码：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the XAML, add a binding for the `Title` property of `ContentPage` to the
    `City` property in`ViewModel` by going through the following steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中，通过以下步骤将`ContentPage`的`Title`属性绑定到`ViewModel`中的`City`属性：
- en: In the `Weather` project, open the `MainView.xaml` file.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView.xaml`文件。
- en: 'Add the `Title` binding to the `ContentPage` element, as highlighted in bold
    in the following code fragment:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码片段中加粗显示的地方将`Title`绑定到`ContentPage`元素。
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using RepeaterView
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RepeaterView
- en: 'To add a custom control to a view, we need to import a namespace to the view.
    If the view is in another assembly, we also need to specify the assembly, but
    in this case, we have both the view and the control in the same namespace, as
    shown in the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要将自定义控件添加到视图中，我们需要将命名空间导入视图。如果视图在另一个程序集中，我们还需要指定程序集，但在这种情况下，视图和控件都在同一个命名空间中，如以下代码所示：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Follow the steps below to build the view:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建视图：
- en: Add a `Grid` as the root view of the page.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Grid`添加为页面的根视图。
- en: Add a `ScrollView` to `Grid`. We need this to be able to scroll if the content
    is higher than the height of the page.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScrollView`添加到`Grid`。如果内容高于页面的高度，我们需要这样做才能滚动。
- en: Add `RepeaterView` to `ScrollView` and set the direction to `Column` so the
    content will be in a vertical direction.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RepeaterView`添加到`ScrollView`中，并将方向设置为`Column`，以便内容以垂直方向排列。
- en: Add a binding to the `Days` property in `MainViewModel`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewModel`中为`Days`属性添加绑定。
- en: 'Set a `DataTemplate` to the content of `ItemsTemplate`, as shown in the following
    code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DataTemplate`设置为`ItemsTemplate`的内容，如以下代码所示：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The content for each item will be a header with the date and a horizontal `RepeaterView`
    with the forecasts for the day. Let''s set this up by going through the following
    steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目的内容将是带有日期的页眉和一行预测的水平`RepeaterView`。通过以下步骤设置这一点：
- en: In the `Weather` project, open the `MainView.xaml` file.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView.xaml`文件。
- en: Add `StackLayout` so that the children we are adding to it will be placed in
    a vertical direction.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`StackLayout`，以便将要添加到其中的子元素以垂直方向放置。
- en: Add `ContentView` to `StackLayout` with `Padding` set to `10` and `BackgroundColor` set
    to `#9F5010`. This will be the header. The reason that we need `ContentView` is
    that we want to have padding around the text.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ContentView`添加到`StackLayout`中，将`Padding`设置为`10`，将`BackgroundColor`设置为`#9F5010`。这将是页眉。我们需要`ContentView`的原因是我们希望文本周围有填充。
- en: Add `Label`to `ContentView` with the `TextColor` set to `White` and `FontAttributes` set
    to `Bold`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Label`添加到`ContentView`，将`TextColor`设置为`White`，将`FontAttributes`设置为`Bold`。
- en: Add a binding to `DateAsString` for the `Text` property of `Label`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Label`的`Text`属性添加`DateAsString`的绑定。
- en: 'The code should be placed at the  `<!-- Content will be added here -->` comment,
    and should look like the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该放在`<!-- Content will be added here -->`注释处，并且应该如以下代码所示：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have the date in the user interface, we need to add a `RepeaterView`
    that will repeat through `Items` in `MainViewModel` by going through the following
    steps. `RepeaterView` is the control we created earlier that inherits from `FlexLayout`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在用户界面中有了日期，我们需要通过以下步骤添加一个将在`MainViewModel`中的`Items`中重复的`RepeaterView`。`RepeaterView`是我们之前创建的从`FlexLayout`继承的控件：
- en: Add a `RepeaterView` after the `</ContentView>` tag, but before the `</StackLayout>`
    tag.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`</ContentView>`标记之后但在`</StackLayout>`标记之前添加一个`RepeaterView`。
- en: Set `JustifyContent` to `Start`to set the `Items` to be added from the left
    side without distributing them over the available space.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`JustifyContent`设置为`Start`，以便从左侧添加`Items`而不是在可用空间上分布它们。
- en: 'Set `AlignItems` to `Start` to set the content to the left of each item in `FlexLayout`
    that `RepeaterView` is based on, as shown in the following code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AlignItems`设置为`Start`，以将`RepeaterView`基于的`FlexLayout`中的每个项目的内容设置为左侧。
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After defining `RepeaterView`, we need to provide an `ItemsTemplate` that defines
    how each item in the list should be rendered. Continue adding the XAML directly
    under the `<controls:RepeaterView>` tag you just added by going through the following
    steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`RepeaterView`后，我们需要提供一个`ItemsTemplate`，定义列表中每个项目的呈现方式。继续通过以下步骤直接在刚刚添加的`<controls:RepeaterView>`标签下添加XAML：
- en: Set the `ItemsTemplate` property to `DataTemplate`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ItemsTemplate`属性设置为`DataTemplate`。
- en: 'Fill the `DataTemplate` with elements, as shown in the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码所示填充`DataTemplate`中的元素：
- en: If we want to add formatting to a binding, we can use `StringFormat`. In this
    case, we want to add the degree symbol after the temperature. We can do this by
    using the `{Binding Temperature, StringFormat='{0}° C'}` phrase. With the `StringFormat`
    property of the binding, we can format data with the same arguments that we would
    use if we did it in C#. This is the same as `string.Format("{0}° C", Temperature)`
    in C#. We can also use it to format a date—for example `{Binding Date, StringFormat='yyyy'}`.
    In C#, this would look like `Date.ToString("yyyy")`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对绑定添加格式，我们可以使用`StringFormat`。在这种情况下，我们希望在温度后添加度符号。我们可以通过使用`{Binding Temperature,
    StringFormat='{0}° C'}`来实现这一点。通过绑定的`StringFormat`属性，我们可以使用与在C#中执行相同的参数来格式化数据。这与在C#中执行`string.Format("{0}°
    C", Temperature)`相同。我们也可以用它来格式化日期，例如`{Binding Date, StringFormat='yyyy'}`。在C#中，这看起来像`Date.ToString("yyyy")`。
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `AspectFill `phrase, as a value of the `Aspect` property for `Image`, means
    that the whole image will always be visible and that aspects will not be changed.
    The `AspectFit`phrase will also keep the aspect of an image, but the image can
    be zoomed and cropped to fill the whole `Image` element. The last value that `Aspect`
    can be set to, `Fill`, means that the image can be stretched or compressed to
    match the `Image` view without ensuring that the aspect is kept.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“Image”的“Aspect”属性的值，“AspectFill”短语表示整个图像始终可见，而且不会改变方面。 “AspectFit”短语也会保持图像的方面，但可以对图像进行缩放和裁剪以填充整个“Image”元素。
    “Aspect”可以设置的最后一个值，“Fill”，表示图像可以被拉伸或压缩以匹配“Image”视图，而不必确保保持方面。
- en: Adding a toolbar item to refresh the weather data
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个工具栏项以刷新天气数据
- en: To be able to refresh the data without restarting the app, we will add a Refresh
    button to the toolbar. `MainViewModel` is responsible for handling any logic that
    we want to perform, and we must expose any action as an `ICommand` that we can
    bind to.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在不重新启动应用程序的情况下刷新数据，我们将在工具栏中添加一个刷新按钮。“MainViewModel”负责处理我们想要执行的任何逻辑，并且我们必须将任何操作公开为可以绑定的“ICommand”。
- en: 'Let''s start by creating the `Refresh` command property on `MainViewModel`
    by going through the following steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过以下步骤在“MainViewModel”上创建“Refresh”命令属性：
- en: In the `Weather` project, open the `MainViewModel` class.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“天气”项目中，打开“MainViewModel”类。
- en: Add an `ICommand` property with the name `Refresh` and a `get` method that returns
    a new `Command`
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“Refresh”的“ICommand”属性和返回新“Command”的“get”方法
- en: 'Add an action as an expression to the constructor of the `Command`that calls
    the `LoadData` method, as shown in the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个表达式作为“Command”的构造函数中的操作，调用“LoadData”方法，如下所示：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that we have defined `Command`, we need to bind it to the user interface
    so that when the user clicks the toolbar button, the action will be executed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了“Command”，我们需要将其绑定到用户界面，以便当用户单击工具栏按钮时，将执行该操作。
- en: 'To do this, follow these steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请按照以下步骤操作：
- en: In the `Weather` app, open the `MainView.xaml` file.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“天气”应用程序中，打开“MainView.xaml”文件。
- en: Add a new `ToolbarItem` with the `Text` property set to `Refresh` to the `ToolbarItems` property
    of `ContentPage` and set the `Icon` property to `refresh.png` (the icon can be
    downloaded from GitHub; see [https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5)).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的“ToolbarItem”添加到“ContentPage”的“ToolbarItems”属性中，将“Text”属性设置为“Refresh”，并将“Icon”属性设置为“refresh.png”（可以从GitHub下载图标；请参阅[https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5)）。
- en: 'Bind the `Command` property to the `Refresh` property in `MainViewModel`, as
    shown in the following code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Command”属性绑定到“MainViewModel”中的“Refresh”属性，如下所示：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That's all for refreshing the data. Now we need some kind of indicator that
    data is loading.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新数据到此结束。现在我们需要一种数据加载的指示器。
- en: Adding a loading indicator
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加加载指示器
- en: 'When we refresh the data, we want to show a loading indicator so the user will
    know that something is happening. To do this, we will add `ActivityIndicator`,
    which is what this control is called in Xamarin.Forms. Let''s set this up by going
    through the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新数据时，我们希望显示一个加载指示器，以便用户知道正在发生某事。为此，我们将添加“ActivityIndicator”，这是Xamarin.Forms中称呼此控件的名称。让我们通过以下步骤设置这一点：
- en: In the `Weather` project, open the `MainViewModel` class.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“天气”项目中，打开“MainViewModel”类。
- en: Add a Boolean property with the name `IsRefreshing` to the `MainViewModel`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向“MainViewModel”添加名为“IsRefreshing”的布尔属性。
- en: Set the `IsRefreshing` property to `true` at the beginning of the `LoadData`
    method.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“LoadData”方法的开头将“IsRefreshing”属性设置为“true”。
- en: 'At the end of the `LoadData` method, set the `IsRefreshing` property to `false`,
    as shown in the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“LoadData”方法的末尾，将“IsRefreshing”属性设置为“false”，如下所示：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have added some code in the `MainViewModel`, we need to bind the `IsRefreshing`
    property to a user interface element that will be displayed when the `IsRefreshing`
    property is `true`, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在“MainViewModel”中添加了一些代码，我们需要将“IsRefreshing”属性绑定到用户界面元素，当“IsRefreshing”属性为“true”时将显示该元素，如下所示：
- en: In the `MainView.xaml`, add a `Frame` after the `ScrollView` as the last element
    in the `Grid`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Grid”的最后一个元素“ScrollView”之后添加一个“Frame”。
- en: Bind the `IsVisible` property to the `IsRefreshing` method that we created in
    the `MainViewModel`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“IsVisible”属性绑定到我们在“MainViewModel”中创建的“IsRefreshing”方法。
- en: Set the `HeightRequest` and the `WidthRequest` to `100`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“HeightRequest”和“WidthRequest”设置为“100”。
- en: Set the `VerticalOptions` and the `HorizontalOptions` to `Center` so that the
    `Frame` will be in the middle of the view.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“VerticalOptions”和“HorizontalOptions”设置为“Center”，以便“Frame”位于视图的中间。
- en: Set the `BackgroundColor` to `#99000000` to set the background to white with
    a little bit of transparency.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“BackgroundColor”设置为“＃99000000”以将背景设置为略带透明的白色。
- en: 'Add `ActivityIndicator` to the `Frame` with the `Color` set to `Black` and
    `IsRunning` set to `True`, as shown in the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码将“ActivityIndicator”添加到“Frame”中，其中“Color”设置为“Black”，“IsRunning”设置为“True”：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will create a spinner that will be visible while data is loading, a really
    good practice when creating any user interface. Now we'll add a background image
    to make the app look a bit nicer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个旋转器，当数据加载时将可见，这是创建任何用户界面时的一个非常好的实践。现在我们将添加一个背景图片，使应用程序看起来更加美观。
- en: Setting a background image
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置背景图片
- en: 'The last thing we will do to this view for the moment is to add a background
    image. The image we are using in this example is a result of a Google search for
    images that are free to use. Let''s set this up by going through the following
    steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图的最后一件事是添加背景图片。我们在此示例中使用的图像是通过Google搜索免费使用的图像而获得的。让我们通过以下步骤设置这一点：
- en: In the `Weather` project, open the `MainView.xaml` file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“天气”项目中，打开“MainView.xaml”文件。
- en: Wrap the `ScrollView` in a `Grid`. Using a `Grid` is great if we want to have
    our elements in layers.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScrollView`包装在`Grid`中。如果我们想要将元素分层，使用`Grid`是很好的。
- en: Set the `Background` property of the `ScrollView` to `Transparent`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScrollView`的`Background`属性设置为`Transparent`。
- en: Add an `Image` element in the `Grid` with `UriImageSource` as the value of the
    `Source` property.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`中添加一个`Image`元素，将`UriImageSource`作为`Source`属性的值。
- en: Set the `CachingEnabled` property to `true` and the `CacheValidity` to `5`.
    This means that the image will be cached in five days.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CachingEnabled`属性设置为`true`，将`CacheValidity`设置为`5`。这意味着图像将在五天内被缓存。
- en: 'The XAML should now look like the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在XAML应该如下所示：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can also set the URL directly in the `Source` property by using `<Image Source="https://ourgreatimage.url"
    />`. However, if we do this, we can't specify the caching for the image.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接在`Source`属性中设置URL，使用`<Image Source="https://ourgreatimage.url" />`。但是，如果我们这样做，就无法为图像指定缓存。
- en: Creating the view for phones
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为手机创建视图
- en: 'Structuring content on a tablet and on a desktop computer is very similar in
    many ways. On phones, however, we are much more limited in what we can do. Therefore,
    in this section, we will create a specific view for this app when used on phones
    by going through the following steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在平板电脑和台式电脑上构建内容在许多方面非常相似。然而，在手机上，我们在可以做的事情上受到了更大的限制。因此，在本节中，我们将通过以下步骤为手机上使用此应用程序创建一个特定的视图：
- en: Create a new XAML-based Content Page in the `Views` folder.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Views`文件夹中创建一个基于XAML的新内容页。
- en: Name the new view called `MainView_Phone`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新视图命名为`MainView_Phone`。
- en: 'Use the `Resolver` in the constructor of the view to set the `BindingContext`
    to the `MainViewModel`, as shown in the following code:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的构造函数中使用`Resolver`将`BindingContext`设置为`MainViewModel`，如下所示：
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To trigger the `LoadData` method in the `MainViewModel`, call the `LoadData`
    method by overriding the `OnAppearing` method on the main thread. To do this,
    go through the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`OnAppearing`方法在主线程上调用`MainViewModel`中的`LoadData`方法来触发`LoadData`方法。通过以下步骤来实现这一点：
- en: In the `Weather` project, open the `MainView_Phone.xaml.cs` file.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView_Phone.xaml.cs`文件。
- en: 'Add the override of the `OnAppearing` method, as shown in the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`OnAppearing`方法的重写，如下所示：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the XAML, add a binding for the `Title` property of the `ContentPage` to
    the `City` property in the `ViewModel`, as shown in the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中，将`ContentPage`的`Title`属性的绑定添加到`ViewModel`中的`City`属性，如下所示：
- en: In the `Weather` project, open the `MainView_Phone.xaml` file.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView_Phone.xaml`文件。
- en: 'Add the `Title` property with a binding to the `City` property of the `MainViewModel`,
    as shown in the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个绑定到`MainViewModel`的`City`属性的`Title`属性，如下所示：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using a grouped ListView
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分组的ListView
- en: We could use `RepeaterView` for the phone's view, but because we want our user
    experience to be as good as possible, we will use `ListView` instead. To get the
    headers for each day, we will use grouping for the `ListView`. For `RepeaterView`,
    we had `ScrollView`, but for `ListView`, we don't need that because `ListView`
    can handle scrolling by default.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在手机视图中使用`RepeaterView`，但是因为我们希望用户体验尽可能好，所以我们将使用`ListView`。为了获得每天的标题，我们将在`ListView`中使用分组。对于`RepeaterView`，我们有`ScrollView`，但对于`ListView`，我们不需要，因为`ListView`默认可以处理滚动。
- en: 'Let''s continue to create the user interface for the phone''s view by going
    through the following steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过以下步骤为手机视图创建用户界面：
- en: In the `Weather` project, open the `MainView_Phone.xaml` file.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView_Phone.xaml`文件。
- en: Add `ListView` to the root of the page.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ListView`添加到页面的根部。
- en: Set a binding to the `Days` property in `MainViewModel` for the `ItemSource`
    property.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`ListView`的`ItemSource`属性设置`MainViewModel`中的`Days`属性的绑定。
- en: Set the `IsGroupingEnabled` to `True` to enable grouping in the `ListView`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsGroupingEnabled`设置为`True`，以在`ListView`中启用分组。
- en: Set `HasUnevenRows` to `True` so the height of each cell will be calculated
    for each item in the `ListView`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HasUnevenRows`设置为`True`，这样`ListView`中每个单元格的高度将为每个项目计算。
- en: Set the `CachingStrategy` to `RecycleElement` to reuse cells that are not on
    the screen.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CachingStrategy`设置为`RecycleElement`，以重用不在屏幕上的单元格。
- en: 'Set the `BackgroundColor` to `Transparent`, as shown in the following code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BackgroundColor`设置为`Transparent`，如下所示：
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Set the `CachingStrategy` to `RecycleElement` to get better performance from
    the `ListView`. This means it will reuse cells that are not shown on the screen,
    so it will use less memory and we will get a smoother scrolling experience if
    we have many items in the `ListView`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CachingStrategy`设置为`RecycleElement`，以从`ListView`中获得更好的性能。这意味着它将重用不显示在屏幕上的单元格，因此它将使用更少的内存，如果`ListView`中有许多项目，我们将获得更流畅的滚动体验。
- en: 'To format how each header will look, we will create a `DataTemplate` by going
    through the following steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化每个标题的外观，我们将通过以下步骤创建一个`DataTemplate`：
- en: Add a `DataTemplate` to the `GroupHeaderTemplate` property of the `ListView`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DataTemplate`添加到`ListView`的`GroupHeaderTemplate`属性中。
- en: Add `ViewCell` to the `DataTemplate`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ViewCell`添加到`DataTemplate`中。
- en: 'Add the content for the row to the `ViewCell`, as shown in the following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行的内容添加到`ViewCell`中，如下所示：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To format how each forecast will look, we will create a `DataTemplate`, as
    we did with the group header. Let''s set this up by going through the following
    steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化每个预测的外观，我们将创建一个`DataTemplate`，就像我们对分组标题所做的那样。让我们通过以下步骤来设置这个：
- en: Add a `DataTemplate` to the `ItemTemplate` property of the `ListView`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DataTemplate`添加到`ListView`的`ItemTemplate`属性中。
- en: Add `ViewCell` to the `DataTemplate`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ViewCell`添加到`DataTemplate`中。
- en: In the `ViewCell`, add a `Grid` that contains four columns. Use the `ColumnDefinition`
    property to specify the width of the columns. The second column should be `50`
    and the other three will share the rest of the space. We will do this by setting
    the `Width` to `*`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewCell`中，添加一个包含四列的`Grid`。使用`ColumnDefinition`属性来指定列的宽度。第二列应为`50`，其他三列将共享其余的空间。我们将通过将`Width`设置为`*`来实现这一点。
- en: 'Add content to the `Grid`, as shown in the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加内容到`Grid`，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding pull to refresh functionality
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加下拉刷新功能
- en: 'For the tablet and desktop version of the view, we added a button to the toolbar
    to refresh the weather forecast. In the phone version of the view, however, we
    will instead add pull to refresh, which is a common way to refresh content in
    a list of data. The `ListView` in Xamarin.Forms has built-in support for pull
    to refresh. Let''s set this up by going through the following steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图的平板电脑和台式机版本，我们在工具栏中添加了一个按钮来刷新天气预报。然而，在手机版本的视图中，我们将添加下拉刷新，这是一种常见的刷新数据列表内容的方式。Xamarin.Forms中的`ListView`内置支持下拉刷新。让我们通过以下步骤来设置这个功能：
- en: Go to the `MainView_Phone.xaml`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`MainView_Phone.xaml`。
- en: Set the `IsPullToRefreshEnabled` property to `True`to enable pull-to-refresh
    for the `ListView`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsPullToRefreshEnabled`属性设置为`True`，以启用`ListView`的下拉刷新。
- en: Bind the `Refresh` property in the `MainViewModel` to the `RefreshCommand` property
    of the `ListView` to trigger a refresh when the user performs a pull-to-refresh
    gesture.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainViewModel`中的`Refresh`属性绑定到`ListView`的`RefreshCommand`属性，以在用户执行下拉刷新手势时触发刷新。
- en: 'To show a loading icon when the refresh is in progress, bind the `IsRefreshing`
    property in the `MainViewModel` to the `IsRefreshing` property of the `ListView`.
    When we are setting this, we will also get a loading indicator when the initial
    load is running, as shown in the following code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在刷新进行中显示加载图标，将`MainViewModel`中的`IsRefreshing`属性绑定到`ListView`的`IsRefreshing`属性。当我们设置这个属性时，当初始加载正在运行时，我们也会得到一个加载指示器，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Navigating to different views based on the form factor
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据形态因素导航到不同的视图
- en: We now have two different views that should be loaded in the same place in the
    app. `MainView` should be loaded if the app is running on a tablet or on a desktop
    and `MainView_Phone` should be loaded if the app is running on a phone.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的视图，应该在应用程序的同一个位置加载。如果应用程序在平板电脑或台式机上运行，应该加载`MainView`，如果应用程序在手机上运行，应该加载`MainView_Phone`。
- en: The `Device` class in Xamarin.Forms has a static `Idiom` property that we can
    use to check which form factor the app is running on. The value of `Idiom` can
    be `Phone`, `Table`, `Desktop`, `Watch`, or `TV`. Because we only have one view
    in this app, we could have used an `if` statement when we were setting `MainPage`
    in `App.xaml.cs` and checked what the `Idiom` value was. Instead, however, we
    are going to build a solution that we can also use for a bigger app.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms中的`Device`类有一个静态的`Idiom`属性，我们可以使用它来检查应用程序运行在哪种形态因素上。`Idiom`的值可以是`Phone`、`Table`、`Desktop`、`Watch`或`TV`。因为我们在这个应用程序中只有一个视图，所以当我们在`App.xaml.cs`中设置`MainPage`时，我们可以使用`if`语句来检查`Idiom`的值。然而，相反地，我们将构建一个解决方案，也可以用于更大的应用程序。
- en: One solution is to build a navigation service that we can use to navigate to
    different views based on a key. Which view will be loaded for which key will be
    configured upon starting the app. With this solution, we can configure different
    views on the same key on different types of devices. An open source navigation
    service that we can use for this purpose is `TinyNavigationHelper`, which can
    be found at [https://github.com/TinyStuff/TinyNavigationHelper](https://github.com/TinyStuff/TinyNavigationHelper)
    and was created by the authors of this book.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是构建一个导航服务，我们可以使用它根据键导航到不同的视图。哪个视图将根据启动应用程序进行配置。通过这个解决方案，我们可以在不同类型的设备上为相同的键配置不同的视图。我们可以用于此目的的开源导航服务是`TinyNavigationHelper`，可以在[https://github.com/TinyStuff/TinyNavigationHelper](https://github.com/TinyStuff/TinyNavigationHelper)找到，由本书的作者创建。
- en: There is also an MVVM library called `TinyMvvm` that includes `TinyNavigationHelper`
    as a dependency. The `TinyMvvm` library is a library that contains helper classes
    to get started quicker with MVVM in a Xamarin.Forms app. We created `TinyMvvm`
    because we want to avoid writing the same code again and again. You can read more
    at [https://github.com/TinyStuff/TinyMvvm](https://github.com/TinyStuff/TinyMvvm).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`TinyMvvm`的MVVM库，它包含`TinyNavigationHelper`作为依赖项。`TinyMvvm`库是一个包含辅助类的库，可以让您在Xamarin.Forms应用程序中更快地开始使用MVVM。我们创建了`TinyMvvm`，因为我们希望避免一遍又一遍地编写相同的代码。您可以在[https://github.com/TinyStuff/TinyMvvm](https://github.com/TinyStuff/TinyMvvm)上阅读更多信息。
- en: 'Follow the steps below to add `TinyNavigationHelper` to the app:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`TinyNavigationHelper`添加到应用程序中：
- en: Install the `TinyNavigationHelper.Forms` NuGet package in the `Weather` project.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中安装`TinyNavigationHelper.Forms` NuGet包。
- en: Go to `Bootstrapper.cs`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Bootstrapper.cs`。
- en: At the start of the `Execute` method, create a `FormsNavigationHelper` and pass
    the current application to the constructor.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Execute`方法的开头，创建一个`FormsNavigationHelper`并将当前应用程序传递给构造函数。
- en: Add an `if` statement to check whether the `Idiom` is `Phone`. If this is true,
    the `MainView_Phone` view should be registered for the `MainView` key.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Idiom`为`Phone`时添加一个`if`语句来检查。如果是这样，`MainView_Phone`视图应该被注册为`MainView`键。
- en: Add an `else` statement that registers the `MainView` for the `MainView` key.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`else`语句，为`MainView`注册`MainView`键。
- en: 'The `Bootstrapper` class should now look as shown in the following code, with
    the new code marked in bold:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bootstrapper`类现在应该如下面的代码所示，新代码用粗体标记出来：'
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can use the `NavigationHelper` class to set the root view of the app
    in the constructor of the `App` class by going through the following steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下步骤在`App`类的构造函数中使用`NavigationHelper`类来设置应用程序的根视图：
- en: In the `Weather` app, open the `App.xaml.cs` file.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`应用程序中，打开`App.xaml.cs`文件。
- en: Locate the constructor of the `App` class.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`App`类的构造函数。
- en: Remove the assignment of the `MainPage` property.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`MainPage`属性的赋值。
- en: Add the code to set the root view via the `NavigationHelper`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码以通过`NavigationHelper`设置根视图。
- en: 'The constructor should now look like the bold code in the following fragment:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数现在应该看起来像以下片段中的粗体代码：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we want to load different views on different operating systems, we can use
    the static `RuntimePlatform `method on the Xamarin.Forms `Device` class—for example, `if(Device.RuntimePlatform
    == Device.iOS)`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在不同的操作系统上加载不同的视图，我们可以使用Xamarin.Forms的`Device`类上的静态`RuntimePlatform`方法，例如`if(Device.RuntimePlatform
    == Device.iOS)`。
- en: Handling states with VisualStateManager
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VisualStateManager处理状态
- en: '`VisualStateManager` was introduced in Xamarin.Forms 3.0\. It is a way to make
    changes in the UI from the code. We can define states and set values for selected
    properties to apply for a specific state. `VisualStateManager` can be really useful
    in cases where we want to use the same view for devices with different screen
    resolutions. It was first introduced in UWP to make it easier to create Windows
    10 applications for multiple platforms because Windows 10 could run on Windows
    Phone as well as on desktops and tablets (the OS was called Windows 10 Mobile).
    However, Windows Phone has now been depreciated. `VisualStateManager` is really
    interesting for us as Xamarin.Forms developers, especially when both iOS and Android
    can run on both phones and tablets.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualStateManager`在Xamarin.Forms 3.0中引入。这是一种从代码中对UI进行更改的方法。我们可以定义状态，并为选定的属性设置值，以应用于特定状态。`VisualStateManager`在我们想要在具有不同屏幕分辨率的设备上使用相同视图的情况下非常有用。它最初是在UWP中引入的，以便更容易地为多个平台创建Windows
    10应用程序，因为Windows 10可以在Windows Phone以及台式机和平板电脑上运行（操作系统被称为Windows 10 Mobile）。然而，Windows
    Phone现在已经被淘汰。对于我们作为Xamarin.Forms开发人员来说，`VisualStateManager`非常有趣，特别是当iOS和Android都可以在手机和平板电脑上运行时。'
- en: 'In this project, we will use it to make a forecast item bigger when the app
    is running in landscape mode on a tablet or on a desktop. We will also make the
    weather icon bigger. Let''s set this up by going through the following steps:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用它在平板电脑或台式机上以横向模式运行应用程序时使预报项目变大。我们还将使天气图标变大。让我们通过以下步骤来设置这个：
- en: In the `Weather` project, open the `MainView.xaml` file.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView.xaml`文件。
- en: 'In the first `RepeaterView` and in the `DataTemplate`, insert a `VisualStateManager.VisualStateGroups`
    element in the first `StackLayout`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`RepeaterView`和`DataTemplate`中，在第一个`StackLayout`中插入一个`VisualStateManager.VisualStateGroups`元素：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To the `VisualStateGroup`, we should add two states, we will do that by following
    these steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对`VisualStateGroup`添加两个状态，我们将按照以下步骤进行：
- en: Add a new `VisualState` called `Portrait` to the `VisualStateGroup`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`VisualStateGroup`添加一个名为`Portrait`的新`VisualState`。
- en: Create a setter in the `VisualState` and set the `WidthRequest` to `150`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VisualState`中创建一个setter，并将`WidthRequest`设置为`150`。
- en: Create another `VisualState` called `Landscape` to the `VisualStateGroup`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VisualStateGroup`中创建另一个名为`Landscape`的`VisualState`。
- en: 'Create a setter in the `VisualState` and set the `WidthRequest` to `200`, as
    shown in the following code:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VisualState`中创建一个setter，并将`WidthRequest`设置为`200`，如下所示：
- en: '[PRE47]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also want the icons in a forecast item to be bigger when the item itself
    is bigger. To do this, we will use the `VisualStateManager` again. Let''s set
    this up by going through the following steps:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目本身变大时，我们还希望预报项目中的图标变大。为此，我们将再次使用`VisualStateManager`。让我们通过以下步骤来设置这个：
- en: Insert a `VisualStateManager.VisualStateGroups` element in the second `RepeaterView`
    and in the `Image` element in the `DataTemplate`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个`RepeaterView`和`DataTemplate`中的`Image`元素中插入一个`VisualStateManager.VisualStateGroups`元素。
- en: Add `VisualState` for both `Portrait` and `Landscape`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Portrait`和`Landscape`添加`VisualState`。
- en: 'Add setters to the states to set the `WidthRequest` and the `HeightRequest`.
    The value should be `1oo` in the `Portrait` state and `150` in the `Landscape`
    state, as shown in the following code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向状态添加setter，设置`WidthRequest`和`HeightRequest`。在`Portrait`状态中，值应为`100`，在`Landscape`状态中，值应为`150`，如下所示：
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating a behavior to set state changes
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于设置状态更改的行为
- en: With `Behavior`, we can add functionality to controls without having to subclass
    them. With behaviors, we can also create a more reusable code than we could if
    we subclassed a control. The more specific the `Behavior` we create, the more
    reusable it will be. For example, a `Behavior` that inherits from `Behavior<View>`
    could be used on all controls, but a `Behavior` that inherits from a `Button` can only be
    used for buttons. Because of this, we always want to create behaviors with a less
    specific base class.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Behavior`，我们可以为控件添加功能，而无需对它们进行子类化。使用行为，我们还可以创建比对控件进行子类化更可重用的代码。我们创建的`Behavior`越具体，它就越可重用。例如，从`Behavior<View>`继承的`Behavior`可以用于所有控件，但从`Button`继承的`Behavior`只能用于按钮。因此，我们总是希望使用更少特定基类创建行为。
- en: When we create a `Behavior`, we need to override two methods: `OnAttached` and
    `OnDetachingFrom`. It is really important to remove event listeners in the `OnDeattached`
    method if we have added them in the `OnAttached` method. This will make the app
    use less memory. It is also important to set back values to the value that they
    had before the `OnAppearing` method ran; otherwise, we might see some strange
    behavior, especially if the behavior is in a `ListView` that is reusing cells.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`Behavior`时，我们需要重写两个方法：`OnAttached`和`OnDetachingFrom`。如果我们在`OnAttached`方法中添加了事件监听器，那么在`OnDeattached`方法中将其移除是非常重要的。这将使应用程序使用更少的内存。在`OnAppearing`方法运行之前，将值设置回它们之前的值也是非常重要的；否则，我们可能会看到一些奇怪的行为，特别是如果行为在重用单元的`ListView`中。
- en: 'In this app, we will create a `Behavior` for the `RepeaterView`. This is because
    we can''t set the state of an item in the `RepeaterView` from the code behind.
    We could have added the code to check whether the app runs in portrait or landscape
    in the `RepeaterView`, but if we use `Behavior` instead, we can separate that
    code from the `RepeaterView` so that it will be more reusable. Instead, we will
    add a `Property `string to the `RepeaterView`, which will set the state for the
    `RepeaterView` and all children in it. Let''s set this up by going through the
    following steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将为`RepeaterView`创建一个`Behavior`。这是因为我们无法从代码后台设置`RepeaterView`中项目的状态。我们本可以在`RepeaterView`中添加代码来检查应用程序是在纵向还是横向运行，但如果我们使用`Behavior`，我们可以将该代码与`RepeaterView`分离，使其更具可重用性。相反，我们将在`RepeaterView`中添加一个`Property
    string`，它将设置`RepeaterView`及其中所有子项的状态。让我们通过以下步骤来设置这一点：
- en: In the `Weather` project, open the `RepeaterView.cs` file.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`RepeaterView.cs`文件。
- en: Create a new `private string` field called `visualState`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`visualState`的新`private string`字段。
- en: Create a new `string` property called `VisualState`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`VisualState`的新`string`属性。
- en: Create a getter that uses an expression to return `visualState`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用表达式返回`visualState`的getter。
- en: 'In the setter, set the state of the `RepeaterView` and all children, as shown
    in the following code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在setter中，设置`RepeaterView`及所有子项的状态，如下所示：
- en: '[PRE49]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will iterate through each `child` control and set the visual state. Now
    let''s create the behavior that will trigger state changes by following these
    steps:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历每个`child`控件并设置视觉状态。现在让我们按照以下步骤创建将触发状态更改的行为：
- en: In the `Weather` project, create a new folder called `Behaviors`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，创建一个名为`Behaviors`的新文件夹。
- en: Create a new class called `RepeaterViewBehavior`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RepeaterViewBehavior`的新类。
- en: Add the `Behavior<RepeaterView>` as a base class.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Behavior<RepeaterView>`作为基类添加。
- en: Create a `private` field of the `RepeaterView` type called `view`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`view`的`private`类型为`RepeaterView`的字段。
- en: 'The code should look like the following:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应如下所示：
- en: '[PRE50]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`RepeaterViewBehavior` is a class that inherits from the `Behavior<RepeaterView>`
    base class. This will give us the ability to override some virtual methods that
    will be called when we attach and detach the behavior from a `RepeaterView`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeaterViewBehavior`是一个从`Behavior<RepeaterView>`基类继承的类。这将使我们能够重写一些虚拟方法，当我们将行为附加和分离到`RepeaterView`时将被调用。'
- en: 'But first, we need to create a method to handle the change in state by going
    through the following steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要通过以下步骤创建一个处理状态变化的方法：
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs` file.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`RepeaterViewBehavior.cs`文件。
- en: Create a `private` method called `UpdateState`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UpdateState`的`private`方法。
- en: Run the code on the `MainThread` to check whether the app is running in portrait
    or landscape mode.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainThread`上运行代码，以检查应用程序是在纵向还是横向模式下运行。
- en: Create a variable called `page` and set its value to `Application.Current.MainPage`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`page`的变量，并将其值设置为`Application.Current.MainPage`。
- en: 'Check whether the `Width` is larger than the `Height`. If this is true, set
    the `VisualState` property on the view variable to `Landscape`. If this is not
    true, set the `VisualState` property on the view variable to `Portrait`, as shown
    in the following code:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`Width`是否大于`Height`。如果是，则将视图变量的`VisualState`属性设置为`Landscape`。如果不是，则将视图变量的`VisualState`属性设置为`Portrait`，如下所示：
- en: '[PRE51]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `UpdateState` method is now added. Now we need to override the `OnAttachedTo`
    method that will be called when the behavior is added to the `RepeaterView`. When
    it is, we want to update the state by calling this method and also hook up to
    the `SizeChanged` event of the `MainPage` so that when the size changes, we will
    update the state again.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加了`UpdateState`方法。现在我们需要重写`OnAttachedTo`方法，当行为添加到`RepeaterView`时将被调用。当行为添加到`RepeaterView`时，我们希望通过调用此方法来更新状态，并且还要连接到`MainPage`的`SizeChanged`事件，以便在大小更改时再次更新状态。
- en: 'Let''s set this up by going through the following steps:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤设置这一点：
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs`file.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`RepeaterViewBehavior.cs`文件。
- en: Override the `OnAttachedTo` method from the base class.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写基类中的`OnAttachedTo`方法。
- en: Set the `view` property to the parameter from the `OnAttachedTo` method.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`view`属性设置为`OnAttachedTo`方法的参数。
- en: 'Add an event listener to `Application.Current.MainPage.SizeChanged`. In the
    event listener, add a call to the `UpdateState` method, as shown in the following
    code:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Application.Current.MainPage.SizeChanged`添加事件监听器。在事件监听器中，调用`UpdateState`方法，如下所示：
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When we remove behaviors from a control, it''s very important to also remove
    any event handlers from it in order to avoid memory leaks, and in the worst case,
    a crash of the app. Let''s do this by going through the following steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从控件中移除行为时，非常重要的是还要移除任何事件处理程序，以避免内存泄漏，并在最坏的情况下，导致应用程序崩溃。让我们通过以下步骤来做到这一点：
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs`file.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`RepeaterViewBehavior.cs`文件。
- en: Override `OnDetachingFrom` from the base class.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写基类中的`OnDetachingFrom`。
- en: Remove the event listener from `Application.Current.MainPage.SizeChanged`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Application.Current.MainPage.SizeChanged`中删除事件监听器。
- en: 'Set the `view` field to `null`, as shown in the following code:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`view`字段设置为`null`，如下所示：
- en: '[PRE53]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Follow the steps below to add the `behavior` to the view:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`behavior`添加到视图中：
- en: In the `Weather` project, open the `MainView.xaml` file.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Weather`项目中，打开`MainView.xaml`文件。
- en: 'Import the `Weather.Behaviors` namespace, as shown in the following code:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Weather.Behaviors`命名空间，如下所示：
- en: '[PRE54]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The last thing we will do is add the `RepeaterViewBehavior` to the second `RepeaterView`,
    as shown in the following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是将`RepeaterViewBehavior`添加到第二个`RepeaterView`中，如下所示：
- en: '[PRE55]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have now successfully created an app for three different operating systems—iOS,
    Android, and Windows—and three different form factors—phones, tablets, and desktop
    computers. To create a good user experience on all platforms and form factors,
    we used `FlexLayout` and `VisualStateManager`. We also learned a way of handling
    when we want to use different views for different form factors, as well as how
    to use `Behaviors`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地为三种不同的操作系统——iOS、Android和Windows——以及三种不同的形态因素——手机、平板和台式电脑创建了一个应用。为了在所有平台和形态因素上创造良好的用户体验，我们使用了`FlexLayout`和`VisualStateManager`。我们还学会了如何处理当我们想要为不同的形态因素使用不同的视图，以及如何使用`Behaviors`。
- en: The next app we will build is a chat app with real-time communication. In the
    next chapter, we will take a look at how we can use the SignalR service in Azure
    as the backend for the chat app.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要构建的应用是一个具有实时通讯功能的聊天应用。在下一章中，我们将看看如何在Azure中使用SignalR服务作为聊天应用的后端。
