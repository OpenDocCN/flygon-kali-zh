- en: Chapter 5. Bidirectional Communication in Real Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。实时双向通信
- en: We have been using COMET techniques to implement bidirectional communication
    between a web browser and web server. Long polling is the most popular technique
    of achieving bidirectional communication between a web browser and web server
    because it works without compromising user experience and without any extra server
    configuration, and it works on all web browsers that support AJAX. Long polling
    can easily be implemented in any existing HTTP server. But the problem with long
    polling and other comet techniques is that none of them are suitable for building
    real-time apps because of HTTP overhead. This means that every time an HTTP request
    is made, a bunch of headers and cookie data is transferred to the server, which
    in turn increases the latency, therefore making it unsuitable for creating applications
    such as multiplayer games, chat apps, social networks, and live score websites,
    which require bidirectional communication in real time. Therefore, a new protocol
    called **WebSocket** was introduced, which was designed to enable bidirectional
    communication in real time between a web browser and WebSocket server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用COMET技术来实现Web浏览器和Web服务器之间的双向通信。长轮询是实现Web浏览器和Web服务器之间双向通信的最流行技术，因为它可以在不影响用户体验和不需要额外服务器配置的情况下工作，并且可以在支持AJAX的所有Web浏览器上工作。长轮询可以很容易地在任何现有的HTTP服务器中实现。但是，长轮询和其他COMET技术的问题在于它们都不适合构建实时应用程序，因为存在HTTP开销。这意味着每次发出HTTP请求时，一大堆头部和cookie数据被传输到服务器，从而增加了延迟，因此不适合创建需要实时双向通信的应用程序，如多人游戏、聊天应用程序、社交网络和实时比分网站。因此，引入了一种名为**WebSocket**的新协议，旨在实现Web浏览器和WebSocket服务器之间的实时双向通信。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An overview of WebSocket
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket概述
- en: The relationship between WebSocket and HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket与HTTP之间的关系
- en: The interaction of WebSocket with proxy servers and firewalls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket与代理服务器和防火墙的交互
- en: Implementing WebSocket using Socket.IO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO实现WebSocket
- en: The Socket.IO API in depth
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Socket.IO API
- en: Many other important things related to WebSocket and Socket.IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket和Socket.IO的许多其他重要事项
- en: Introducing WebSocket
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebSocket
- en: '**WebSocket** is an application-layer protocol designed to facilitate bidirectional
    (either the client or server can send a message to the other party whenever a
    message is available) and full-duplex communication (both the client and server
    can send messages to each other simultaneously) between a web browser and WebSocket
    server in real time.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**是一种应用层协议，旨在促进Web浏览器和WebSocket服务器之间的实时双向（每当消息可用时，客户端或服务器都可以向对方发送消息）和全双工通信（客户端和服务器可以同时向对方发送消息）。'
- en: WebSocket is a binary protocol; therefore, it is faster than the HTTP protocol,
    which is a text-based protocol.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种二进制协议；因此，它比基于文本的HTTP协议更快。
- en: WebSocket has gained popularity and is already being used by many websites due
    to its real-time and full-duplex features. Due to overhead caused by comet techniques,
    it was not suitable for real-time bidirectional message transfer, and it was also
    not possible to establish a full-duplex communication system between a web browser
    and web server using comet. That is, comet techniques let us achieve only half-duplex
    communication system (only the client or server can send messages to the other
    party at a given time).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket因其实时和全双工特性而受到欢迎，并已被许多网站使用。由于COMET技术引起的开销，它不适合实时双向消息传输，并且也不可能使用COMET在Web浏览器和Web服务器之间建立全双工通信系统。也就是说，COMET技术只能实现半双工通信系统（在给定时间只有客户端或服务器可以向对方发送消息）。
- en: WebSocket is designed to facilitate bidirectional communication between a web
    browser and WebSocket server, but it can be used by any client. In this chapter,
    we will only concentrate on how it's implemented in a web browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket旨在促进Web浏览器和WebSocket服务器之间的双向通信，但任何客户端都可以使用它。在本章中，我们将只关注它在Web浏览器中的实现。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is the WebSocket API?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API是什么？
- en: Web browsers provide an API for creating and managing a WebSocket connection
    to a WebSocket server as well as for sending and receiving data on the connection.
    We won't use this API for implementing WebSocket; instead, we will use the Socket.IO
    library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器提供了一个API，用于创建和管理与WebSocket服务器的WebSocket连接，以及在连接上发送和接收数据。我们不会使用这个API来实现WebSocket；相反，我们将使用Socket.IO库。
- en: The relationship between WebSocket and HTTP
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket与HTTP之间的关系
- en: The only relationship between WebSocket and HTTP is that a WebSocket handshake
    between a web browser and WebSocket server is done using HTTP. Therefore, a WebSocket
    server is also an HTTP server. Once the handshake is successful, the same TCP
    connection is used for WebSocket communication, that is, communication switches
    to the bidirectional binary protocol, which does not conform to the HTTP protocol.
    The default port number for WebSocket is 80, same as for HTTP.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket与HTTP之间唯一的关系是，Web浏览器和WebSocket服务器之间的WebSocket握手是使用HTTP完成的。因此，WebSocket服务器也是一个HTTP服务器。一旦握手成功，相同的TCP连接用于WebSocket通信，即通信切换到双向二进制协议，不符合HTTP协议。WebSocket的默认端口号是80，与HTTP相同。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why is the default WebSocket port 80?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么默认的WebSocket端口是80？
- en: The main reason for integrating HTTP and WebSocket so tightly and making WebSocket
    share the HTTP port is to prevent firewalls from blocking non-web content.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTTP和WebSocket紧密集成并使WebSocket共享HTTP端口的主要原因是防止防火墙阻止非Web内容。
- en: Although you can implement your own WebSocket handshake mechanism if you are
    using WebSocket outside a web browser environment, the official WebSocket documentation
    only states the HTTP handshake mechanism because WebSocket is designed to enable
    bidirectional communication between web browsers and WebSocket servers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你在Web浏览器环境之外使用WebSocket，可以实现自己的WebSocket握手机制，但官方WebSocket文档只说明了HTTP握手机制，因为WebSocket旨在实现Web浏览器和WebSocket服务器之间的双向通信。
- en: You can integrate a WebSocket server into your main web server that serves your
    HTML pages, or you can use a separate web server for WebSocket communication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将WebSocket服务器集成到提供HTML页面的主要Web服务器中，或者可以使用单独的Web服务器进行WebSocket通信。
- en: Sending and receiving data on a WebSocket connection
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WebSocket连接上发送和接收数据
- en: Data is transferred through a WebSocket connection as messages, each of which
    consists of one or more frames containing the data you are sending (called the
    payload). In order to ensure that the message can be properly reconstructed when
    it reaches the other party, each frame is prefixed with 4-12 bytes of data about
    the payload. Using this frame-based messaging system helps reduce the amount of
    non-payload data that is transferred, leading to significant reductions in latency,
    therefore making it possible to build real-time components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过WebSocket连接作为消息传输，每个消息由一个或多个包含正在发送的数据（称为有效负载）的帧组成。为了确保消息在到达对方时可以正确重建，每个帧都以关于有效负载的4-12个字节的数据为前缀。使用这种基于帧的消息系统有助于减少传输的非有效负载数据量，从而大大减少延迟，因此可以构建实时组件。
- en: We won't get into the exact data format and other details of the WebSocket handshake,
    data framing, and sending and receiving data as this is only required if you are
    planning to create your own WebSocket server. We will use Socket.IO JavaScript
    library to implement WebSocket in our application, which takes care of all the
    internal details of WebSocket and provides an easy-to-use API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍WebSocket握手、数据帧和发送接收数据的确切数据格式和其他细节，除非你打算创建自己的WebSocket服务器。我们将使用Socket.IO
    JavaScript库在我们的应用程序中实现WebSocket，该库负责WebSocket的所有内部细节，并提供易于使用的API。
- en: WebSocket schemes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket方案
- en: WebSocket protocol specifications have introduced two new URL schemes, called
    **ws** and **wss**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议规范引入了两个新的URL方案，称为**ws**和**wss**。
- en: '`ws` represents an unencrypted connection whereas `wss` represents an encrypted
    connection. Encrypted connections use TLS to encrypt messages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ws`表示未加密连接，而`wss`表示加密连接。加密连接使用TLS加密消息。'
- en: So, when making a WebSocket handshake request using HTTP, we need to use `ws`
    or `wss` instead of `http` or `https`, respectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用HTTP进行WebSocket握手请求时，我们需要分别使用`ws`或`wss`，而不是`http`或`https`。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why `ws` and `wss` instead of `http` and `https`?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`ws`和`wss`而不是`http`和`https`？
- en: You must be wondering what the point of introducing a new scheme instead of
    just using `http`. Well, the reason behind this is that WebSocket can also be
    used outside a web browser environment, and a handshake can be negotiated via
    a non-HTTP server. Therefore, a different scheme is required when not using HTTP
    for the handshake.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定想知道引入新方案而不是只使用`http`的意义在哪里。这背后的原因是WebSocket也可以在Web浏览器环境之外使用，并且可以通过非HTTP服务器协商握手。因此，在不使用HTTP进行握手时，需要使用不同的方案。
- en: The interaction of WebSocket with proxy servers, load balancers, and firewalls
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket与代理服务器、负载均衡器和防火墙的交互
- en: The WebSocket protocol is unaware of proxy servers by itself. When a WebSocket
    connection is established behind a proxy server, the WebSocket connection can
    fail or work properly, depending on whether the proxy server is transparent or
    explicit and also whether we have established a secure or unsecure connection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议本身不知道代理服务器。当WebSocket连接在代理服务器后面建立时，WebSocket连接可能会失败或正常工作，这取决于代理服务器是透明的还是显式的，以及我们是否建立了安全或非安全连接。
- en: If the browser is configured to use an explicit proxy server, then it will first
    issue an `HTTP CONNECT` method to that proxy server when establishing the WebSocket
    connection. The `CONNECT` method is used to tell a proxy to make a connection
    to another host and simply reply with the content, without attempting to parse
    or cache it. A browser issues the `HTTP CONNECT` method regardless of whether
    the connection is encrypted or unencrypted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器配置为使用显式代理服务器，则在建立WebSocket连接时，它将首先向代理服务器发出`HTTP CONNECT`方法。`CONNECT`方法用于告诉代理服务器与另一个主机建立连接，并简单地回复内容，而不尝试解析或缓存它。无论连接是加密还是未加密，浏览器都会发出`HTTP
    CONNECT`方法。
- en: If we are using a transparent proxy server (that is, a proxy server that the
    web browser is unaware of) and the connection is encrypted, then the browser doesn't
    issue an `HTTP CONNECT` method because it's unaware of the proxy server. But as
    the connection is encrypted, the proxy server will most probably let all the encrypted
    data through, therefore causing no problems to the WebSocket connection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用透明代理服务器（即Web浏览器不知道的代理服务器）并且连接是加密的，那么浏览器不会发出`HTTP CONNECT`方法，因为它不知道代理服务器。但由于连接是加密的，代理服务器很可能会让所有加密数据通过，因此不会对WebSocket连接造成问题。
- en: If we are using a transparent proxy server and the connection is unencrypted,
    then the browser doesn't issue an `HTTP CONNECT` method because it's unaware of
    the proxy server. But as the connection is unencrypted, the proxy server is likely
    to try to cache, parse, or block the data, therefore causing issues for the WebSocket
    connection. In this case, the proxy server should be upgraded or explicitly configured
    to support WebSocket connections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用透明代理服务器并且连接未加密，那么浏览器不会发出`HTTP CONNECT`方法，因为它不知道代理服务器。但由于连接未加密，代理服务器很可能会尝试缓存、解析或阻止数据，因此会对WebSocket连接造成问题。在这种情况下，代理服务器应该升级或明确配置以支持WebSocket连接。
- en: The WebSocket protocol is unaware of load balancers by itself. If you are using
    a TCP load balancer, it is unlikely to cause any problems for a WebSocket connection.
    But if you are using an HTTP load balancer, it's likely to cause problems; therefore,
    it needs to be upgraded or explicitly configured to handle WebSocket connections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议本身不知道负载均衡器。如果您使用TCP负载均衡器，它不太可能对WebSocket连接造成任何问题。但是，如果您使用HTTP负载均衡器，它可能会导致问题；因此，需要升级或显式配置以处理WebSocket连接。
- en: The WebSocket protocol is unaware of firewalls by itself. Firewalls are unlikely
    to cause any problems for a WebSocket connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议本身不知道防火墙。防火墙不太可能对WebSocket连接造成任何问题。
- en: The same-origin policy for WebSocket
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket的同源策略
- en: Browsers as well as WebSocket instances can perform cross-domain communication,
    that is, they are not restricted by any same-origin policy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和WebSocket实例都可以执行跨域通信，也就是说，它们不受任何同源策略的限制。
- en: While making an HTTP request for a handshake, the browser sends an `Origin`
    header assigned to the webpage origin.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行握手的HTTP请求时，浏览器会发送一个分配给网页来源的`Origin`头。
- en: If a WebSocket server wants to restrict communication to a particular domain,
    it can read the `Origin` HTTP header of the handshake HTTP request and block or
    allow the handshake accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果WebSocket服务器希望限制通信到特定域，它可以读取握手HTTP请求的`Origin`头，并相应地阻止或允许握手。
- en: Introduction to Socket.IO
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO简介
- en: Socket.IO is a combination of the client-side JavaScript library and Node.js
    library used to integrate bidirectional communication between a browser and Node.js
    backend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个结合了客户端JavaScript库和Node.js库的工具，用于在浏览器和Node.js后端之间实现双向通信。
- en: The Socket.IO client-side library is used to create a Socket.IO client whereas
    the Socket.IO Node.js library is used to create a Socket.IO server. The Socker.IO
    client and server can communicate with each other bidirectionally. Socket.IO primarily
    uses WebSocket to achieve bidirectional communication.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO客户端库用于创建Socket.IO客户端，而Socket.IO Node.js库用于创建Socket.IO服务器。Socker.IO客户端和服务器可以进行双向通信。Socket.IO主要使用WebSocket实现双向通信。
- en: The main reason for using the Socket.IO client-side library instead of using
    the WebSocket API is that WebSocket is a relatively new protocol at the time of
    writing and not all browsers support the API. If Socket.IO sees that the browser
    doesn't support WebSocket, then it jumps to one of the other mechanisms, such
    as Flash sockets, long polling, multipart streaming, iframes, or JSONP polling,
    to implement bidirectional communication between browsers and servers. Therefore,
    we can say that Socket.IO is guaranteed to work on every browser. The Socket.IO
    backend library provides APIs to create namespaces and rooms, broadcast messages,
    and so on, which are very useful in some cases. Therefore, Socket.IO is the best
    way to implement bidirectional communication between a browser and Node.js server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Socket.IO客户端库而不是WebSocket API的主要原因是WebSocket在撰写时是一个相对较新的协议，并非所有浏览器都支持该API。如果Socket.IO发现浏览器不支持WebSocket，则会跳转到其他机制，如Flash
    sockets、长轮询、多部分流、iframes或JSONP轮询，以实现浏览器和服务器之间的双向通信。因此，我们可以说Socket.IO保证在每个浏览器上都能工作。Socket.IO后端库提供了创建命名空间和房间、广播消息等API，这在某些情况下非常有用。因此，Socket.IO是在浏览器和Node.js服务器之间实现双向通信的最佳方式。
- en: Setting up your project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: Before we start learning about the Socket.IO API, let's first set up our project
    directory and files. Create a directory named `SocketIO-Example`. Inside the directory,
    create files called `package.json`, `app.js`, and `socket.js`, and a directory
    called `public`. Inside the `public` directory, create two directories, `html`
    and `js`. Inside the `html` directory, create a file called `index.html`. Finally,
    in the `js` directory, download and place the Socket.IO library from [https://cdn.socket.io/socket.io-1.3.7.js](https://cdn.socket.io/socket.io-1.3.7.js).
    At the time of writing, the latest version of Socket.IO is 1.3.7; therefore, we
    will be using that version.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习Socket.IO API之前，让我们先设置项目目录和文件。创建一个名为`SocketIO-Example`的目录。在该目录中，创建名为`package.json`、`app.js`和`socket.js`的文件，以及一个名为`public`的目录。在`public`目录中，创建两个目录，`html`和`js`。在`html`目录中，创建一个名为`index.html`的文件。最后，在`js`目录中，从[https://cdn.socket.io/socket.io-1.3.7.js](https://cdn.socket.io/socket.io-1.3.7.js)下载并放置Socket.IO库。在撰写时，Socket.IO的最新版本是1.3.7；因此，我们将使用该版本。
- en: Inside the `app.js` file, we will write code for the web server, and inside
    the `socket.js` file, we will write code for the Socket.IO server. For now, we
    will run two different servers, that is, a separate web server serving the website,
    and another server for bidirectional communication. In the next chapter, we will
    learn how to integrate the Socket.IO server with the Express server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，我们将编写Web服务器的代码，在`socket.js`文件中，我们将编写Socket.IO服务器的代码。目前，我们将运行两个不同的服务器，即一个用于提供网站的独立Web服务器，另一个用于双向通信的服务器。在下一章中，我们将学习如何将Socket.IO服务器与Express服务器集成。
- en: 'Inside the `package.json` file, place this code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，放置以下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, run the `npm install` command inside the `SocketIO-Example` directory in
    order to download and install Express and the Socket.IO Node.js library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`SocketIO-Example`目录中运行`npm install`命令，以下载并安装Express和Socket.IO Node.js库。
- en: 'Now, inside the `index.html` file, place this HTML code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`index.html`文件中，放置以下HTML代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the second `<script>` tag, you will be placing the Socket.IO client-side
    code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`<script>`标签内，您将放置Socket.IO客户端代码。
- en: 'Now, place this code in the `app.js` file to serve the `index.html` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`app.js`文件中放置以下代码以提供`index.html`文件：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are listening on port `8080`. Run the `app.js` file and visit the `http://localhost:8080/`
    URL to load the `index.html` page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在监听端口`8080`。运行`app.js`文件并访问`http://localhost:8080/` URL以加载`index.html`页面。
- en: We are done with setting up the files and directories. Now, let's learn about
    the Socket.IO client-side and server-side APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置好了文件和目录。现在，让我们了解一下Socket.IO客户端和服务器端的API。
- en: Diving into the Socket.IO API
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解Socket.IO API
- en: Let's first look at an overview of the Socket.IO API. After that, we will get
    into the advanced features one by one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下Socket.IO API的概述。之后，我们将逐一介绍高级功能。
- en: 'Let''s first build a Socket.IO server. The following is the code to create
    a Socket.IO server instance and listen to new Socket.IO client handshake requests.
    Place it in the `socket.js` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建一个Socket.IO服务器。以下是创建Socket.IO服务器实例并监听新的Socket.IO客户端握手请求的代码。将其放在`socket.js`文件中：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作方式：
- en: First, we import the Socket.IO Node.js library.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入了Socket.IO Node.js库。
- en: Then, we create a new instance of the Socket.IO server using the `Server` constructor.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`Server`构造函数创建一个Socket.IO服务器的新实例。
- en: Then, while creating a new instance, we pass the HTTP path to which the Socket.IO
    client will make a handshake request. If we don't pass the path, it defaults to
    /`socket.io`
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在创建新实例时，我们将HTTP路径传递给Socket.IO客户端进行握手请求。如果我们不传递路径，默认为/`socket.io`
- en: Finally, we listen on port `3000`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们监听端口`3000`。
- en: I created a single Socket.IO server in the code, but we have the freedom to
    create multiple servers listening on different ports.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中创建了一个单一的Socket.IO服务器，但我们可以自由地创建多个监听不同端口的服务器。
- en: 'Now, Socket.IO clients can send a handshake request, and the Socket.IO server
    can establish a Socket.IO connection with its clients. Let''s write some code
    to do something on a Socket.IO server after a Socket.IO connection has been established.
    Place this code in the `socket.js` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Socket.IO客户端可以发送握手请求，Socket.IO服务器可以与其客户端建立Socket.IO连接。让我们编写一些代码，在Socket.IO连接建立后在Socket.IO服务器上执行一些操作。将此代码放在`socket.js`文件中：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see how this code works and what the `send()`, `on()`, and `emit()`
    methods do:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码是如何工作的，`send()`、`on()`和`emit()`方法是做什么的：
- en: The `on()` method of the `io` object is used to attach event handlers to events
    triggered on the Socket.IO server by itself.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io`对象的`on()`方法用于将事件处理程序附加到Socket.IO服务器自身触发的事件。'
- en: We first attach an event handler for the `connection` event. As soon as a Socket.IO
    connection has been established, the `connection` event is fired. The event handler
    has a single parameter, which is an object representing the Socket.IO client.
    Here, we've named the parameter `socket`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先为`connection`事件附加了一个事件处理程序。一旦建立了Socket.IO连接，就会触发`connection`事件。事件处理程序有一个参数，表示Socket.IO客户端的对象。在这里，我们将参数命名为`socket`。
- en: The `on()` method of the `socket` object is used to attach event handlers to
    the events emitted by the Socket.IO client to the server.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`on()`方法用于将事件处理程序附加到Socket.IO客户端发送到服务器的事件。'
- en: The `send()` method of the `socket` object is used to send a message to the
    Socket.IO client. We are sending a string here, but you can also send an instance
    of `ArrayBuffer`, `Blob Node.js Buffer`, and even `File`. You can also send a
    simple JavaScript object.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`send()`方法用于向Socket.IO客户端发送消息。我们在这里发送一个字符串，但您也可以发送`ArrayBuffer`、`Blob
    Node.js Buffer`甚至`File`的实例。您还可以发送一个简单的JavaScript对象。'
- en: Then, we attached an event handler for the `message` event, which is triggered
    when the Socket.IO client sends a message to the Socket.IO server.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们为`message`事件附加了一个事件处理程序，当Socket.IO客户端向Socket.IO服务器发送消息时触发。
- en: After that, we attached an event handler to the `disconnect` event, which is
    triggered when the Socket.IO client disconnects from the Socket.IO server.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们为`disconnect`事件附加了一个事件处理程序，当Socket.IO客户端从Socket.IO服务器断开连接时触发。
- en: The `emit` method of the `socket` object is used to send custom events to the
    Socket.IO client. It can take an infinite number of arguments. The first argument
    it takes is the event name, and the rest of the arguments are the parameters of
    the event handler, which is triggered on the Socket.IO client.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`emit`方法用于向Socket.IO客户端发送自定义事件。它可以接受无限数量的参数。它接受的第一个参数是事件名称，其余的参数是事件处理程序的参数，在Socket.IO客户端上触发。'
- en: Finally, we use the `on()` method of the `socket` object to register an event
    handler for a custom event named `custom-event`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket`对象的`on()`方法为名为`custom-event`的自定义事件注册事件处理程序。
- en: So now, we have finished creating a very simple Socket.IO server that lets Socket.IO
    clients establish a connection with it. It is also listening to `message` and
    `custom-event` events. It also sends a message and emits a custom event to the
    Socket.IO clients as soon as they are connected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了创建一个非常简单的Socket.IO服务器，让Socket.IO客户端与其建立连接。它还监听`message`和`custom-event`事件。一旦它们连接，它还会向Socket.IO客户端发送消息并触发自定义事件。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As every Socket.IO client gets a separate `socket` object on the Socket.IO server,
    if we want a `socket` object to be able to access the `socket` object of another
    Socket.IO client, then we can keep a reference to the `socket` objects of every
    Socket.IO client in a global array. This can be useful if we are creating a chat
    app in which a `socket` object needs to access another `socket` object to send
    messages to it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Socket.IO客户端在Socket.IO服务器上都有一个单独的`socket`对象，如果我们希望一个`socket`对象能够访问另一个Socket.IO客户端的`socket`对象，那么我们可以在全局数组中保留对每个Socket.IO客户端的`socket`对象的引用。如果我们正在创建一个聊天应用程序，这可能很有用，其中一个`socket`对象需要访问另一个`socket`对象以向其发送消息。
- en: You can now run the Socket.IO server using the `node socket.js` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`node socket.js`命令运行Socket.IO服务器。
- en: 'Now, let''s build the Socket.IO client. The following is the code to create
    a Socket.IO client instance and establish a Socket.IO connection with the Socker.IO
    server. Place this code in the `<script>` tag of the `index.html` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建Socket.IO客户端。以下是创建Socket.IO客户端实例并与Socker.IO服务器建立Socket.IO连接的代码。将此代码放在`index.html`文件的`<script>`标签中：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are first creating a Socket.IO client instance and establishing a connection
    with the Socket.IO server using the `io` constructor. The first argument is the
    base URL of the Socket.IO server. The second argument is an optional object to
    which we have passed the URL path that the handshake request should be made to.
    If we don't pass the path, then the default path will be `/socket.io`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建了一个Socket.IO客户端实例，并使用`io`构造函数与Socket.IO服务器建立了连接。第一个参数是Socket.IO服务器的基本URL。第二个参数是一个可选对象，我们已经传递了应该进行握手请求的URL路径。如果我们不传递路径，则默认路径将是`/socket.io`。
- en: We created a single Socket.IO client instance here, but we have the freedom
    to create multiple Socket.IO client instances if we want to connect to multiple
    Socket.IO servers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个单独的Socket.IO客户端实例，但是如果我们想要连接到多个Socket.IO服务器，我们可以自由地创建多个Socket.IO客户端实例。
- en: We are using the `http` scheme instead of the `ws` scheme here because Socket.IO
    can use any technique or protocol other than WebSocket to achieve bidirectional
    communication. If Socket.IO chooses to use WebSocket, then it will automatically
    replace `http` with `ws`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`http`方案而不是`ws`方案，因为Socket.IO可以使用除WebSocket之外的任何技术或协议来实现双向通信。如果Socket.IO选择使用WebSocket，那么它将自动将`http`替换为`ws`。
- en: 'Let''s write some code to do something on a Socket.IO client after a Socket.IO
    connection has been established. Place this code in the `<script>` tag of `index.html`
    file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，在Socket.IO连接建立后在Socket.IO客户端上执行某些操作。将此代码放入`index.html`文件的`<script>`标签中：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s understand how this code works and what the `send()`, `on()`, and `emit()`
    methods do:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下这段代码是如何工作的，`send()`，`on()`和`emit()`方法是做什么的：
- en: The `on()` method of the `socket` object is used to attach event handlers to
    the events triggered on the Socket.IO client by itself.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`on()`方法用于将事件处理程序附加到Socket.IO客户端自身触发的事件上。'
- en: We first attach an event handler to the `connect` event. As soon as a Socket.IO
    connection has been established, the `connect` event is fired.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将事件处理程序附加到`connect`事件上。一旦建立了Socket.IO连接，`connect`事件就会被触发。
- en: The `send()` method's `socket` object is used to send a message to the Socket.IO
    server. We are sending a string here, but you can also send an instance of `ArrayBuffer`,
    `Blob`, or even `File`. You can also send a simple JavaScript object.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()`方法的`socket`对象用于向Socket.IO服务器发送消息。我们在这里发送一个字符串，但您也可以发送`ArrayBuffer`，`Blob`甚至`File`的实例。您还可以发送一个简单的JavaScript对象。'
- en: Then, we attached an event handler to the `message` event, which is triggered
    when the Socket.IO server sends a message to the Socket.IO client.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将事件处理程序附加到`message`事件上，当Socket.IO服务器向Socket.IO客户端发送消息时触发该事件。
- en: We then attached an event handler to the `disconnect` event, which is triggered
    when the Socket.IO client disconnects from the Socket.IO server. As soon as a
    Socket.IO connection breaks, the Socket.IO client keeps trying to connect again
    automatically.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将事件处理程序附加到`disconnect`事件上，当Socket.IO客户端从Socket.IO服务器断开连接时触发该事件。一旦Socket.IO连接断开，Socket.IO客户端会自动尝试重新连接。
- en: After that, we use the `on()` method of the `socket` object to register an event
    handler for a custom event named `custom-event`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用`socket`对象的`on()`方法为名为`custom-event`的自定义事件注册事件处理程序。
- en: The `emit` method of the `socket` object is used to send custom events to the
    Socket.IO server. It can take an infinite number of arguments. The first argument
    it takes is the event name, and the rest of the arguments are the parameters of
    the event handler, which is triggered in the Socket.IO client.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`emit`方法用于向Socket.IO服务器发送自定义事件。它可以接受无限数量的参数。它接受的第一个参数是事件名称，其余的参数是事件处理程序的参数，该处理程序在Socket.IO客户端中触发。'
- en: 'Now, open the URL `http://localhost:8080/` in your browser, and you should
    see the following console output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开URL `http://localhost:8080/`，您应该看到以下控制台输出：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And you will see the following output in the shell running the Socket.IO server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将在运行Socket.IO服务器的shell中看到以下输出：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Restricting connections based on origin
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于来源限制连接
- en: By default, a Socket.IO server lets Socket.IO clients from any origin establish
    a Socket.IO connection with it. Socket.IO provides a way to restrict connections
    to a particular origin.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Socket.IO服务器允许来自任何来源的Socket.IO客户端与其建立Socket.IO连接。Socket.IO提供了一种限制连接到特定来源的方法。
- en: To restrict connections to a particular origin or set of origins, we can use
    the `origins` method of the `Server` instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制连接到特定来源或一组来源，我们可以使用`Server`实例的`origins`方法。
- en: 'Place this code in the `socket.js` file to only allow Socket.IO clients running
    on the `localhost` domain and port number `8080` to connect to the Socket.IO server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入`socket.js`文件中，以仅允许运行在`localhost`域和端口号`8080`上的Socket.IO客户端连接到Socket.IO服务器：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We cannot simply pass any `origin` to the `origins` method. Here are examples
    of some valid `origins`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将任何`origin`传递给`origins`方法。以下是一些有效的`origins`示例：
- en: '`testsite.com:80`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:80`'
- en: '`http://testsite.com:80`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com:80`'
- en: '`http://*:8080` (* is a wildcard)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://*:8080`（*是通配符）'
- en: '`*:8080`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*:8080`'
- en: '`testsite.com:* http://someotherdomain.com:8080` (multiple origins separated
    by spaces)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:* http://someotherdomain.com:8080`（多个来源以空格分隔）'
- en: '`testsite.com:*/somepath` (Socket.IO will ignore /somepath)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:*/somepath`（Socket.IO将忽略/somepath）'
- en: '`*:*`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*:*`'
- en: In the previous list, every origin has a port number associated with it because
    it is compulsory to provide a port number or * in place of the port number, indicating
    any port.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的列表中，每个来源都有与之关联的端口号，因为必须提供端口号或*代替端口号，表示任何端口。
- en: 'Here are some examples of invalid origins:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些无效来源的示例：
- en: '`testsite.com`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com`'
- en: '`http://testsite.com`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com`'
- en: '`http://testsite.com/somepath`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com/somepath`'
- en: These are invalid because they don't have port numbers associated with them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是无效的，因为它们没有与之关联的端口号。
- en: Also note that if you specify `sub.testsite.com` as the `origins` value, `testsite.com`
    will be a valid origin.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果您将`sub.testsite.com`指定为`origins`值，则`testsite.com`将是一个有效的来源。
- en: Namespaces in Socket.IO
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的命名空间
- en: A Socket.IO server is actually divided into child servers called **namespaces**.
    A Socket.IO client always connects to a namespace. Every namespace has a name,
    which looks like an HTTP path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器实际上被分成了称为**命名空间**的子服务器。Socket.IO客户端总是连接到一个命名空间。每个命名空间都有一个类似HTTP路径的名称。
- en: In the previous code, when we created a Socket.IO server, a default namespace
    was created. The default namespace is identified by the `/` path. If we don't
    mention a namespace when creating a Socket.IO client, then it connects to the
    default namespace. So, the `connection` event is specific to a particular namespace,
    that is, for every namespace, we have to register a different `connection` event
    handler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们创建了一个Socket.IO服务器时，会创建一个默认命名空间。默认命名空间由`/`路径标识。如果在创建Socket.IO客户端时不指定命名空间，则它将连接到默认命名空间。因此，`connection`事件是特定于特定命名空间的，也就是说，对于每个命名空间，我们必须注册一个不同的`connection`事件处理程序。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What is the benefit of namespaces?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间的好处是什么？**'
- en: You must be wondering what the point of introducing namespaces is. Well, namespaces
    make writing complex code easier. Let's look at an example to understand this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道引入命名空间的意义是什么。好吧，命名空间使编写复杂的代码变得更容易。让我们看一个例子来理解这一点。
- en: Suppose you have a web page that has multiple components that update in real
    time. You would then either create multiple Socket.IO servers for a component
    or use a single Socket.IO server and rely on the data format of a message or custom
    event to find which data belongs to which component. Both of these techniques
    have demerits, that is, creating multiple Socket.IO servers occupies multiple
    ports, so it's not suitable for a large number of components, and relying on the
    data formats of messages and custom events make it difficult to move frontend
    components to a separate application, as the new application will get a lot of
    unnecessary messages and events, causing bandwidth issues on both sides. Therefore,
    namespaces were introduced, which combine the benefits of both techniques while
    omitting their demerits.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个网页，其中有多个组件实时更新。那么您要么为每个组件创建多个Socket.IO服务器，要么使用单个Socket.IO服务器并依赖消息或自定义事件的数据格式来找到哪些数据属于哪个组件。这两种技术都有缺点，即创建多个Socket.IO服务器占用多个端口，因此不适合大量组件，依赖消息和自定义事件的数据格式使得将前端组件移动到单独的应用程序变得困难，因为新应用程序将获得大量不必要的消息和事件，导致双方带宽问题。因此，引入了命名空间，它结合了这两种技术的优点，同时省略了它们的缺点。
- en: 'Here is how to create a custom namespace. Place this code in the `socket.js`
    file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建自定义命名空间的代码。将此代码放入`socket.js`文件中：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On adding this code to the `socket.js` file, we will have two namespaces, that
    is, the default one, which we created earlier, and this one, called `/custom-namespace`.
    Here, you can see that we registered a new connection event handler for this namespace.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`socket.js`文件后，我们将有两个命名空间，即我们之前创建的默认命名空间和这个名为`/custom-namespace`的命名空间。在这里，您可以看到我们为这个命名空间注册了一个新的连接事件处理程序。
- en: 'Now, let''s create another Socket.IO client, one which connects to the `/custom-namespace`
    namespace. Place this code in the `<script>` tag of `index.html` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个Socket.IO客户端，连接到`/custom-namespace`命名空间。将此代码放入`index.html`文件的`<script>`标签中：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are creating another Socket.IO client; this one connects to the `/custom-namespace`
    namespace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建另一个Socket.IO客户端；这个客户端连接到`/custom-namespace`命名空间。
- en: 'Now, rerun the `socket.js` file and visit `http://localhost:8080/`. This will
    be the browser console output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行`socket.js`文件并访问`http://localhost:8080/`。这将是浏览器控制台的输出：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this will be the new shell output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是新的shell输出：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we restrict access based on origin using the `origins()` method, it is
    applied to all namespaces.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`origins()`方法基于来源限制访问时，它适用于所有命名空间。
- en: Referring to all connected Socket.IO clients
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引用所有连接的Socket.IO客户端
- en: The Socket.IO server API also provides us with a way of sending a message or
    custom event to everyone in a namespace.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器API还为我们提供了一种向命名空间中的所有人发送消息或自定义事件的方法。
- en: 'Let''s look at an example of how to do this. Place the following code in the
    `socket.js` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何做到这一点的例子。将以下代码放入`socket.js`文件中：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, to send a message or custom event to all the Socket.IO clients connected
    to the default namespace, we use the `io` object. And to send to Socker.IO clients
    connected to a custom namespace, we use the object returned by the `of()` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要向连接到默认命名空间的所有Socket.IO客户端发送消息或自定义事件，我们使用`io`对象。而要发送到连接到自定义命名空间的Socker.IO客户端，我们使用`of()`方法返回的对象。
- en: Here, we are simply sending a message and custom event to everyone in both the
    namespaces every `5` seconds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是每`5`秒向两个命名空间中的所有人发送消息和自定义事件。
- en: Rooms in Socket.IO
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的房间
- en: A **room** simply represents a group of Socket.IO clients connected to a particular
    namespace. A room belongs to a particular namespace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**房间**只是表示连接到特定命名空间的一组Socket.IO客户端。一个房间属于特定的命名空间。'
- en: A namespace cannot have two rooms with the same name, but two different namespaces
    can have rooms with the same name. Rooms with the same name on different namespaces
    are different rooms entirely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命名空间不能有两个同名的房间，但是两个不同的命名空间可以有同名的房间。不同命名空间上同名的房间是完全不同的房间。
- en: Every Socket.IO client connected to a namespace must belong to one or more groups.
    By default, when a Socket.IO client is connected, a new group is created and the
    client is added to it. Therefore, every Socket.IO client belongs to a unique group
    by default.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到命名空间的每个Socket.IO客户端必须属于一个或多个组。默认情况下，当连接Socket.IO客户端时，会创建一个新组并将客户端添加到其中。因此，每个Socket.IO客户端默认属于一个唯一的组。
- en: 'Here is the code that prints the unique group name of a Socket.IO client after
    it has connected. Place it inside the default and `/custom-namespace` namespaces''
    `connection` event handlers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Socket.IO客户端连接后打印唯一组名的代码。将其放入默认和`/custom-namespace`命名空间的`connection`事件处理程序中：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `id` property of the `socket` object holds the unique room name.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`对象的`id`属性保存唯一的房间名称。'
- en: Joining and leaving a room
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加入和离开一个房间
- en: To add a Socket.IO client to a custom room, we need to use the `socket.use()`
    method. To remove a Socket.IO client from a custom room, we need to use the `socket.leave()`
    method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Socket.IO客户端添加到自定义房间，我们需要使用`socket.use()`方法。要从自定义房间中移除Socket.IO客户端，我们需要使用`socket.leave()`方法。
- en: 'The following code adds every Socket.IO client connected to the default and
    `/custom-namespace` servers to a room called `my-custom-room`. Place it inside
    the default and `/custom-namespace` namespaces'' `connection` event handlers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将连接到默认和`/custom-namespace`服务器的每个Socket.IO客户端添加到名为`my-custom-room`的房间中。将其放入默认和`/custom-namespace`命名空间的`connection`事件处理程序中：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, to remove a user from `my-custom-room`, you can use this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要从`my-custom-room`中移除用户，您可以使用以下代码：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Referring to all connected Socket.IO clients in a room
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提及房间中所有连接的Socket.IO客户端
- en: The Socket.IO server API also provides us with a way to send a message or custom
    event to everyone in a room.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器API还为我们提供了一种向房间中的所有人发送消息或自定义事件的方法。
- en: 'Let''s look at an example of how to do this. Place the following code in the
    `socket.js` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何做到这一点的例子。将以下代码放入`socket.js`文件中：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, to send a message or custom event to all the Socket.IO clients in the
    `my-custom-room` room of the default namespace, we need to use the `io.to().send()`
    method. And to send a message or custom event to all the Socket.IO clients in
    the `my-custom-room` room of the `/custom-namespace` namespace, we need to use
    the `nsp.to().send()` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要向默认命名空间的`my-custom-room`房间中的所有Socket.IO客户端发送消息或自定义事件，我们需要使用`io.to().send()`方法。而要向`/custom-namespace`命名空间的`my-custom-room`房间中的所有Socket.IO客户端发送消息或自定义事件，我们需要使用`nsp.to().send()`方法。
- en: Broadcasting messages and custom events to namespaces and rooms
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向命名空间和房间广播消息和自定义事件
- en: Broadcasting is a feature of the Socket.IO server API that lets a `socket` object
    send a message or custom event to everyone in the namespace or room except itself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是Socket.IO服务器API的一个特性，它允许`socket`对象向命名空间或房间中的所有人发送消息或自定义事件，除了自己。
- en: Broadcasting to a namespace
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向命名空间广播
- en: To broadcast a message to all Socket.IO clients in a namespace, we need to use
    the `socket.broadcast.send()` method, and to broadcast a custom event, we need
    to use the `socket.broadcast.emit()` method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要向命名空间中的所有Socket.IO客户端广播消息，我们需要使用`socket.broadcast.send()`方法，要广播自定义事件，我们需要使用`socket.broadcast.emit()`方法。
- en: 'Let''s look at an example. Place the following code in the `connection` event
    handler of the default namespace to broadcast a message every time a new Socket.IO
    client joins:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。将以下代码放入默认命名空间的`connection`事件处理程序中，以便在每次新的Socket.IO客户端加入时广播消息：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, open `http://localhost:8080/` in two different tabs. In the first tab''s
    console, you will see this output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在两个不同的标签页中打开`http://localhost:8080/`。在第一个标签页的控制台中，您将看到以下输出：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the second tab''s console, you will see this output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个标签页的控制台中，您将看到以下输出：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Broadcasting to a room
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向房间广播
- en: To broadcast a message to all Socket.IO clients in a room, we need to use the
    `socket.broadcast.to().send()` method, and to broadcast a custom event, we need
    to use the `socket.broadcast.to.emit()` method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要向房间中的所有Socket.IO客户端广播消息，我们需要使用`socket.broadcast.to().send()`方法，要广播自定义事件，我们需要使用`socket.broadcast.to.emit()`方法。
- en: 'Place this code inside the default and `/custom-namespace` namespaces'' `connection`
    event handlers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入默认和`/custom-namespace`命名空间的`connection`事件处理程序中：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, as soon as a Socket.IO client is connected, it sends a message to everyone
    else in the room.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦Socket.IO客户端连接，它就会向房间中的其他人发送消息。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a Socket.IO client doesn't have to be a member of a room to broadcast
    a message to its Socket.IO clients.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Socket.IO客户端不必是房间的成员就可以向其Socket.IO客户端广播消息。
- en: Middleware in Socket.IO
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的中间件
- en: Middleware in Socket.IO server is a callback that's executed when a Socket.IO
    client makes a handshake request, before the Socket.IO server replies to it. Middleware
    allows us to allow or reject handshakes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器中的中间件是在Socket.IO客户端发出握手请求之前执行的回调，在Socket.IO服务器回复之前执行。中间件允许我们允许或拒绝握手。
- en: The middleware concept of Socket.IO is similar to that of Express, but the difference
    is that the middleware doesn't get access to the HTTP response object; also, the
    `parameter` signature is different. Therefore, Express middleware cannot be used
    in Socket.IO.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO的中间件概念类似于Express的中间件，但不同之处在于中间件无法访问HTTP响应对象；另外，`parameter`签名也不同。因此，Express中间件无法在Socket.IO中使用。
- en: 'An instance of middleware is attached to a specific namespace. Here is a basic
    example that demonstrates how to register a middleware instance with all namespaces.
    Place this code in the `Socket.IO` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件实例附加到特定的命名空间。以下是一个基本示例，演示了如何向所有命名空间注册中间件实例。将此代码放入`Socket.IO`文件中：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that we need to use the `io.use()` method to register a middleware
    instance with all namespaces. To attach middleware to the `/custom-namespace`
    namespace, we can use the `nsp.use()` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们需要使用`io.use()`方法来注册一个中间件实例到所有的命名空间。要将中间件附加到`/custom-namespace`命名空间，我们可以使用`nsp.use()`方法。
- en: Disconnecting manually
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动断开连接
- en: You can also manually disconnect a Socket.IO connection. To disconnect from
    the client side, you need to use the `disconnect()` method of the `io` instance.
    To disconnect from the server side, you need to use the `socket.disconnect()`
    method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以手动断开Socket.IO连接。要从客户端断开连接，您需要使用`io`实例的`disconnect()`方法。要从服务器端断开连接，您需要使用`socket.disconnect()`方法。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the fundamentals of the WebSocket protocol. We learned
    about its relationship with HTTP and how it behaves with proxies, load balancers,
    and firewalls. Then, we jumped into the Socket.IO library, which primarily uses
    WebSocket to achieve bidirectional full-duplex communication in real time. You
    should be comfortable with implementing bidirectional communication between a
    browser and a Node.js server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了WebSocket协议的基础知识。我们了解了它与HTTP的关系，以及它在代理、负载均衡器和防火墙中的行为。然后，我们进入了Socket.IO库，它主要使用WebSocket实现实时的双向全双工通信。您应该能够在浏览器和Node.js服务器之间实现双向通信。
- en: In the next chapter, we will build a real-world application using Socket.IO.
    You will learn more advanced things, such as integrating a Socket.IO server with
    an Express server and checking authentication before connecting to a WebSocket
    server.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Socket.IO构建一个真实世界的应用程序。您将学习更高级的内容，比如将Socket.IO服务器与Express服务器集成，并在连接到WebSocket服务器之前检查身份验证。
