- en: Azure and Serverless Computing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure和无服务器计算
- en: 'Right about now, I bet that there are some of you coming to this chapter asking,
    "What does serverless computing even mean?" The name is confusing, I agree. It
    makes no sense (to me anyway), but when you understand the concept it kind of
    makes sense. In this chapter, we will have a look at what the term Serverless
    Computing means. We will also take a look at:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我敢打赌，有些人来到这一章，问道：“无服务器计算到底是什么意思？”名字很令人困惑，我同意。对我来说毫无意义，但当你理解这个概念时，它有点意义。在这一章中，我们将看看无服务器计算这个术语的含义。我们还将看一下：
- en: Creating an Azure Function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Azure函数
- en: Providing print functionality with DocRaptor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DocRaptor提供打印功能
- en: Using AWS and S3
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS和S3
- en: Creating C# lambda functions with AWS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS和S3创建C# lambda函数
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Serverless does not mean the lack of a server, but rather you (or the application)
    does not know which server is used to provide some functionality to an application.
    Serverless, therefore, describes an application that depends on some 3rd party
    app or service that lives in the cloud to provide some logic or functionality
    to the application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器并不意味着没有服务器，而是你（或应用程序）不知道用于为应用程序提供某些功能的服务器是哪个。因此，无服务器描述了一个依赖于云中的某些第三方应用程序或服务来为应用程序提供一些逻辑或功能的应用程序。
- en: Let us use the example of a student research portal. Students research a certain
    topic and create documents in the portal related to what they need to research.
    They can then load print credits against their profile and print the saved documents they
    need. After a page is printed, the print credit is deducted from their profile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以学生研究门户的例子来说明。学生研究某个主题并在门户中创建相关的文档。然后他们可以加载打印信用到他们的个人资料中，并打印他们需要的保存的文档。在打印一页后，打印信用将从他们的个人资料中扣除。
- en: 'While this is a very simple example, I am using it to illustrate the concept
    of serverless computing. We can split the application up into various components.
    These are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常简单的例子，但我用它来说明无服务器计算的概念。我们可以将应用程序分成各种组件。具体如下：
- en: Login authentication
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录认证
- en: Purchasing print credits
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 购买打印信用
- en: Updating remaining print credits
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新剩余的打印信用
- en: Printing documents
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印文档
- en: There could be several other components required not mentioned here, but this
    is not the real world. We are just creating this hypothetical application to illustrate
    the concept of serverless computing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能需要其他未提及的组件，但这不是现实世界。我们只是创建这个假设的应用程序来说明无服务器计算的概念。
- en: Why write the code to provide login authentication in your application when
    there are already third-party services out there that do just that? Similarly,
    why write code to print documents when there are services that provide quite rich
    functionality you can just consume in your application? Anything specific such
    as the purchasing and loading of student print credits, can be created using an
    Azure Function. The topic of serverless computing is broad and still in its infancy.
    There is much to learn and experience. Let's take the first steps and explore
    what benefits this can have for developers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当已经有第三方服务提供登录认证时，为什么还要在您的应用程序中编写代码来提供登录认证呢？同样，当有提供打印文档的服务时，为什么还要编写代码来打印文档呢？任何特定的功能，比如购买和加载学生打印信用，都可以使用Azure函数来创建。无服务器计算的主题是广泛的，而且还处于起步阶段。还有很多东西要学习和体验。让我们迈出第一步，探索这对开发人员有什么好处。
- en: Creating an Azure function
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Azure函数
- en: Why Azure Functions? Imagine that you have an application that needs to provide
    some specific functionality, but that still scales up when the call rate to your
    function increases. This is where Azure Functions provide a benefit. With Azure
    Functions, you only pay for the compute that your function needs at a specific
    instance in time, and it is immediately available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Azure Functions？想象一下，您有一个应用程序需要提供一些特定的功能，但当对函数的调用率增加时，它仍然会扩展。这就是Azure Functions提供的好处所在。使用Azure
    Functions，您只支付函数在特定时间点所需的计算，而且它立即可用。
- en: To get started, head on over to [https://azure.microsoft.com/en-us/services/functions](https://azure.microsoft.com/en-us/services/functions) 
    and create a free account.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请访问[https://azure.microsoft.com/en-us/services/functions](https://azure.microsoft.com/en-us/services/functions)并创建一个免费账户。
- en: Because you only pay for the actual computing time you use when running Azure
    Functions, it is imperative that your code is as optimized as possible. If you
    refactor the Azure Function code and gain a 40% code execution improvement, you
    are directly saving 40% in your monthly expense. The more you refactor and improve
    your code, the more money you will save.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在运行Azure Functions时，您只支付实际使用的计算时间，所以您的代码尽可能优化是至关重要的。如果您重构Azure Function代码并获得了40%的代码执行改进，那么您直接节省了40%的月度费用。您重构和改进代码的越多，您就能节省更多的钱。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need to have an Azure account set up. If you don''t have one, you can set
    one up for free. From the Azure portal, on the left-side menu, click on New to
    get started:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要设置一个Azure账户。如果您还没有账户，可以免费设置一个。从Azure门户，在左侧菜单中，点击“新建”开始：
- en: '![](img/B06434_17_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_01.jpg)'
- en: In the search box, type in `Function App` and hit the *Enter* button. The first
    result should be Function App. Select that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索框中，输入“函数应用程序”并点击“Enter”按钮。第一个结果应该是函数应用程序。选择它。
- en: '![](img/B06434_17_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_02.jpg)'
- en: When you select the Function App, you will see this screen pop out to the right.
    The description perfectly describes what Azure Functions do. Click the Create
    button at the bottom of this form.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择函数应用程序时，您将看到右侧弹出此屏幕。描述完美地描述了Azure Functions的功能。在此表单底部点击“创建”按钮。
- en: '![](img/B06434_17_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_03.jpg)'
- en: You now see a form that allows you to give your function a name and select the
    Resource Group and other settings. Click on the Create button when you are done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '现在您看到一个表单，允许您为函数命名并选择资源组和其他设置。完成后，点击“创建”按钮。 '
- en: '![](img/B06434_17_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_04.jpg)'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: After Azure has created the new Function App, you will then be able to create
    an Azure Function. All that we are going to do is to create an Azure Function
    that will be triggered whenever something happens on a GitHub repository. Click
    on the Create your own custom function link.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure创建新的函数应用程序后，您将能够创建Azure函数。我们要做的就是创建一个Azure函数，每当GitHub存储库上发生某些事情时就会触发。单击创建自定义函数链接。
- en: '![](img/B06434_17_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_05.jpg)'
- en: 'According to the Microsoft Azure site, the following are supported when writing
    Azure Functions: JavaScript, C#, F#, and scripting options such as Python, PHP,
    Bash, Batch, and PowerShell.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Microsoft Azure网站，编写Azure Functions时支持以下内容：JavaScript、C#、F#以及Python、PHP、Bash、Batch和PowerShell等脚本选项。
- en: You will now see that you are given a choice between several templates. Choose
    C# from the Language selection and API & Webhooks from the Scenario selection
    and then select the GitHubWebHook-CSharp template. Azure will now ask you to give
    your function a name. I called mine `GithubAzureFunctionWebHook`. Click on the
    Create button to create the function.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将看到可以在几个模板之间进行选择。从语言选择中选择C#，从场景选择中选择API和Webhooks，然后选择GitHubWebHook-CSharp模板。Azure现在会要求您为函数命名。我将我的命名为`GithubAzureFunctionWebHook`。单击创建按钮创建函数。
- en: '![](img/B06434_17_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_06.jpg)'
- en: When your function is created, you will see that it has added some default code
    for you in the online code editor.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数后，您将看到在线代码编辑器中为您添加了一些默认代码。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Preceding the `return` statement, add the following line of code: `log.Info($"Message
    from GitHub: {gitHubComment}");`. This is so that we will see what was sent from
    GitHub.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return`语句之前，添加以下代码行：`log.Info($"来自GitHub的消息：{gitHubComment}");`。这样我们就可以看到从GitHub发送的内容。
- en: Your code should now look as follows. Note that there are two links that allow
    you to get the function URL and the GitHub secret. Click on those links and copy
    the values of each to Notepad. Click on the Save and run button.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的代码现在应如下所示。请注意，有两个链接可让您获取函数URL和GitHub秘钥。单击这些链接，然后将每个值复制到记事本中。单击保存并运行按钮。
- en: Your Azure Function URL should be something like: `https://funccredits.azurewebsites.net/api/GithubAzureFunctionWebHook`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Azure函数URL应类似于：`https://funccredits.azurewebsites.net/api/GithubAzureFunctionWebHook`
- en: '![](img/B06434_17_07.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_07.jpg)'
- en: Head on over to GitHub at [https://github.com/](https://github.com/). If you
    don't have an account, create one and create a repository (GitHub is free for
    open source projects). Go to the repository you created, and click on the Settings
    tab. To the left, you will see a link called Webhooks. Click on that link.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到GitHub网站[https://github.com/](https://github.com/)。如果您没有帐户，请创建一个并创建一个存储库（GitHub对开源项目免费）。转到您创建的存储库，然后单击设置选项卡。在左侧，您将看到一个名为Webhooks的链接。单击该链接。
- en: '![](img/B06434_17_08.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_08.jpg)'
- en: You will now see a button to the right called Add webhook. Click on that button.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将看到右侧有一个名为添加webhook的按钮。单击该按钮。
- en: '![](img/B06434_17_09.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_09.jpg)'
- en: Add the Azure Function URL you copied earlier to the Payload URL field. Change
    the Content type to application/json and add the GitHub secret you copied earlier
    to the Secret field. Select Send me everything and click on the Add webhook button.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前复制的Azure Function URL添加到Payload URL字段。将内容类型更改为application/json，并将之前复制的GitHub秘钥添加到秘钥字段。选择Send
    me everything，然后单击添加webhook按钮。
- en: '![](img/B06434_17_10.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_10.jpg)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Still in your GitHub repository, open a file and add a comment to it. Click
    on the Comment on this commit button.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的GitHub存储库中，打开一个文件并向其添加评论。单击此提交上的评论按钮。
- en: '![](img/B06434_17_11.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_11.jpg)'
- en: Swing back to your Azure Function and take a look at the Logs window. This window
    is directly below the code window. You will see that the comment we posted in
    GitHub pops up in the log output of the Azure Function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到Azure Function并查看日志窗口。此窗口直接位于代码窗口下方。您将看到我们在GitHub中发布的评论出现在Azure Function的日志输出中。
- en: '![](img/B06434_17_12.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_12.jpg)'
- en: If nothing appears in the log window, ensure that you have clicked on the Run
    button of the Azure Function. If all else fails, click on the Run button at the
    bottom of the Test window.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志窗口中没有显示任何内容，请确保您已单击Azure Function的运行按钮。如果一切都失败了，请单击测试窗口底部的运行按钮。
- en: While this is a very simple example, the usefulness of Azure Functions should
    become evident to you. You will also notice that the function has a `.csx` extension.
    What is important to note is that Azure Functions share a few core concepts and
    components irrespective of which programming language you choose to code it in.
    At the end of the day, a function is the primary concept here. You also have a
    `function.json` file that contains JSON configuration data. You can see this and
    other files by clicking on the View files link to the right.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个非常简单的例子，但Azure Functions的实用性应该变得明显。您还会注意到函数具有`.csx`扩展名。重要的是要注意，无论您选择使用哪种编程语言编写代码，Azure
    Functions都共享一些核心概念和组件。归根结底，函数是这里的主要概念。您还有一个包含JSON配置数据的`function.json`文件。您可以通过单击右侧的查看文件链接来查看此文件和其他文件。
- en: '![](img/B06434_17_13.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_13.jpg)'
- en: Clicking on the `function.json` file, you will see the contents of the JSON
    file. Changing the `disabled` property to `true` will effectively stop the function
    from executing if called. You will also notice the `bindings` property. Here,
    you configure your web hook. All these settings can be set from within the Integrate
    and other sections of the Azure Function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单击`function.json`文件，您将看到JSON文件的内容。将`disabled`属性更改为`true`将有效地阻止函数在调用时执行。您还会注意到`bindings`属性。在这里，您可以配置您的web
    hook。所有这些设置都可以在Azure Function的集成和其他部分中设置。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Azure Functions and the benefits exposed to developers is an exciting concept.
    This is one area of your programming repertoire that will surely keep you busy
    for many hours as you explore more intricate and complex tasks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions和向开发人员提供的好处是一个令人兴奋的概念。这是您编程技能中的一个领域，肯定会让您忙碌很多小时，因为您将探索更复杂和复杂的任务。
- en: Providing print functionality with DocRaptor
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DocRaptor提供打印功能
- en: Printing from a web application has always been tricky. This is much easier
    these days with the availability of numerous third-party controls that provide
    print functionality to your application. The reality, however, is that I have
    come across many projects where, when they were developed, used a third-party
    control to provide print functionality. At the time it was developed, the third-party
    control was good and did exactly what they needed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从Web应用程序中打印一直是棘手的。如今，由于提供打印功能的众多第三方控件的可用性，这变得更加容易。然而，现实情况是，我遇到过许多项目，在开发时使用了第三方控件来提供打印功能。当时，第三方控件很好，确实满足了他们的需求。
- en: Having this functionality available to the application means that the companies
    that purchase the licenses for these third-party controls, rarely continue renewing
    their licenses. Within a few years, however, this results in a web application
    that contains old and dated print technology. While there is nothing wrong with
    this, it does have some drawbacks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序具有这种功能意味着购买这些第三方控件的公司很少继续续订他们的许可证。然而，几年后，这将导致Web应用程序包含旧的和过时的打印技术。虽然这没有什么问题，但它确实有一些缺点。
- en: The developers are usually stuck with maintaining an aging code base, which
    is locked into this third-party control. Any change in requirements, and you'll
    find that developers are faced with making code work within the limitations of
    the third-party controls. Alternatively, they need to approach the powers that
    be and suggest that the third-party controls be updated to the latest version.
    This means that the small change needed in the print module, turns out to be more
    costly than anyone had budgeted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常被困在维护老化的代码库中，这些代码库被锁定在这个第三方控件中。一旦需求发生变化，你会发现开发人员不得不使代码在第三方控件的限制内工作。或者，他们需要向管理层提出建议，建议更新第三方控件到最新版本。这意味着在打印模块中需要的小改动，结果比任何人的预算都要昂贵。
- en: 'Real world: I used to work for a company that would have consultants quote
    customers on what a change to some application functionality would cost. After
    the quote was given and accepted, it was handed to development to make it work
    within the allotted time frame and budget. This resulted in developers having
    to hack code to make it work and meet budget and deadlines because of a lack of
    proper project management skills. Replacing third-party controls would be virtually
    impossible because the budget was already set without input from development.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界：我曾经在一家公司工作，这家公司会让顾问为客户报价某个应用功能的更改。一旦报价得到接受，就交给开发人员在规定的时间和预算内使其工作。这导致开发人员不得不修改代码以使其工作，并满足预算和截止日期，因为缺乏适当的项目管理技能。替换第三方控件几乎是不可能的，因为预算已经在没有开发人员参与的情况下确定了。
- en: 'I agree that there are some developers that do a very good job of providing
    and maintaining functionality in an aging code base. I also really love third-party
    controls and the functionality they provide. There are a select few big players
    that a developer can choose from. But here is the catch: why purchase a suite
    of third-party controls, when all you need is the ability to print an invoice
    for example? Using this logic, serverless make much more sense in many cases (this
    one included).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意有一些开发人员在维护老化的代码库中提供和维护功能方面做得非常好。我也非常喜欢第三方控件和它们提供的功能。开发人员可以选择一些大型的供应商。但问题是：当你只需要打印发票时，为什么要购买一套第三方控件？按照这种逻辑，在许多情况下（包括本例），无服务器更有意义。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This example will take a look at a service called DocRaptor. The service isn't
    free, but consider the cost of writing and maintaining code to provide print functionality
    in your web application. Consider the cost of buying third-party controls to provide
    the same functionality. It all comes down to what makes the most sense for you
    as a developer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将介绍一个名为DocRaptor的服务。这项服务并不是免费的，但考虑一下在您的Web应用程序中编写和维护提供打印功能的代码的成本。考虑购买第三方控件以提供相同的功能的成本。最终取决于作为开发人员的您选择什么才是最合理的。
- en: Create a basic web application and go to Tools, NuGet Package Manager, Package
    Manager Console. Type the following command in the console to install the DocRaptor
    NuGet package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的Web应用程序，然后转到工具，NuGet包管理器，包管理器控制台。在控制台中键入以下命令以安装DocRaptor NuGet包。
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once DocRaptor is installed, you can head on over to their web page ([http://docraptor.com/](http://docraptor.com/))
    to read through some of the API documentation or you can also swing by the GitHub
    page ([https://github.com/DocRaptor/docraptor-csharp](https://github.com/DocRaptor/docraptor-csharp))
    for additional information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了DocRaptor后，您可以访问他们的网页（[http://docraptor.com/](http://docraptor.com/)）阅读一些API文档，或者您也可以访问GitHub页面（[https://github.com/DocRaptor/docraptor-csharp](https://github.com/DocRaptor/docraptor-csharp)）获取更多信息。
- en: It will be better to have a look at the source code accompanying this book in
    order to copy the code for this recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最好查看本书附带的源代码，以便复制本示例的代码。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add an aspx web page that contains invoice details. I have simply taken from
    the example on DocRaptor's site and modified it slightly. Call this page `InvoicePrint.aspx`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含发票详细信息的aspx网页。我只是从DocRaptor网站的示例中简单地提取并稍作修改。将此页面命名为`InvoicePrint.aspx`。
- en: I have included the CSS in a style sheet called `invoice.css`. Be sure to get
    this from the source code accompanying this book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在名为`invoice.css`的样式表中包含了CSS。一定要从本书附带的源代码中获取这个。
- en: There are a few ways you could approach this code. This is not necessarily the
    only way to create the web pages. If you are using .NET Core MVC, your approach
    would probably be different. However if you do this, remember that this code is
    just to illustrate the concept here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以处理这段代码。这并不一定是创建Web页面的唯一方法。如果您使用.NET Core MVC，您的方法可能会有所不同。但是，如果您这样做，请记住，这段代码只是为了说明这里的概念。
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I also created a print friendly version of the invoice page called `invoice.html`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我还创建了一个名为`invoice.html`的发票页面的打印友好版本。
- en: 'The next step is to create a click event for the link button. Add the following
    code to the click event. You will notice that I have just hard coded the path
    to generate the PDF document to as: `C:tempinvoiceDownloads`. You need to make
    sure that you change this path if you want to output to a different path (or get
    a path relative to the server you''re on).'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为链接按钮创建一个单击事件。将以下代码添加到单击事件。您会注意到，我只是将生成PDF文档的路径硬编码为：`C:tempinvoiceDownloads`。如果您想要输出到不同的路径（或者获取相对于您所在服务器的路径），请确保更改此路径。
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make sure that you include the following namespaces in your web page:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在您的网页中包含以下命名空间：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, get the HTML content of the print friendly page called `invoice.html`.
    The URL in the code below will differ on your machine because your port number
    will probably be different.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，获取名为`invoice.html`的打印友好页面的HTML内容。下面代码中的URL在您的机器上会有所不同，因为您的端口号可能不同。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Run your web application and see the basic invoice displayed on the web page.
    Make sure that you have set your `InvoicePrint.aspx` page as the start page for
    your web application. Click on the Print this invoice link.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的Web应用程序并查看在Web页面上显示的基本发票。确保您已将`InvoicePrint.aspx`页面设置为Web应用程序的起始页面。单击“打印此发票”链接。
- en: '![](img/B06434_17_14.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_14.jpg)'
- en: You will see that the invoice is created in the output path you specified.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到发票已创建在您指定的输出路径中。
- en: '![](img/B06434_17_15.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_15.jpg)'
- en: Click on the PDF document to open the invoice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单击PDF文档以打开发票。
- en: '![](img/B06434_17_16.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_16.jpg)'
- en: DocRaptor provides a service that is really useful to developers creating web
    solutions. If you need to create PDF or Excel documents from your application,
    DocRaptor can benefit your team. The test document used in this example is free
    to use without it being deducted from your monthly quota (if you are on a paid
    plan).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: DocRaptor为开发人员创建Web解决方案提供了一个非常有用的服务。如果您需要从您的应用程序创建PDF或Excel文档，DocRaptor可以使您的团队受益。本例中使用的测试文档可免费使用，不会从您的月配额中扣除（如果您是付费计划用户）。
- en: In the true serverless sense of the word, DocRaptor provides functionality to
    you without you having to write a lot of extra code. It is super easy to implement
    and super easy to maintain. The preceding example is really basic, but you can
    pass DocRaptor a URL instead of the `DocumentContent` to print the page you want.
    From the developer's perspective, they don't care how DocRaptor does what they
    do. It just works. And this is the idea behind serverless computing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从真正无服务器的意义上讲，DocRaptor为您提供功能，而无需您编写大量额外的代码。它非常容易实现，也非常容易维护。前面的例子非常基本，但您可以传递给DocRaptor一个URL，而不是`DocumentContent`，以打印您想要的页面。从开发人员的角度来看，他们不关心DocRaptor是如何做到的。它只是有效。这就是无服务器计算背后的理念。
- en: Developers can implement solutions in their applications easily, effortlessly,
    and in record time, using minimal code while adding a lot of value to the application
    they're developing. The functionality being implemented can also easily scale
    as demand increases. There are, however, overage charges on the professional plan.
    Lastly, creating a few PDF documents will probably not make much of a difference
    in server computing power. Consider then that DocRaptor is used by some large
    companies that probably generate thousands of documents each month. All those
    document generation requests do not get processed by the customer using DocRaptor,
    but by the DocRaptor servers themselves.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以轻松、毫不费力地在他们的应用程序中实现解决方案，并在记录时间内使用最少的代码为他们正在开发的应用程序增加了很多价值。随着需求的增加，实施的功能也可以轻松扩展。但是，专业计划会有超额费用。最后，创建几个PDF文档可能不会对服务器计算能力产生太大影响。然后考虑到DocRaptor被一些大公司使用，这些公司可能每个月生成数千份文档。所有这些文档生成请求都不是由使用DocRaptor的客户处理的，而是由DocRaptor服务器自己处理的。
- en: You are then left with being able to develop a lightweight, streamlined web
    application that will not place huge demand on your server as volumes increase.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以开发一个轻量级、简化的Web应用程序，随着访问量的增加，不会对您的服务器造成巨大的需求。
- en: Using AWS and S3
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS和S3
- en: This chapter can't be considered complete without looking at Amazon Web Services
    (AWS). The topic of AWS is really vast. There is a lot of functionality provided
    by the platform. Developers can harness this in their applications and provide
    rich functionality with minimal code on their part. AWS also has really good documentation
    that developers can review to get up to speed quickly. S3 is Amazon's Simple Storage
    Service and allows you to store and retrieve data in the cloud.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 没有看到Amazon Web Services（AWS）这一章就不能算完整。AWS的主题非常广泛。该平台提供了许多功能。开发人员可以在他们的应用程序中利用这一点，并在他们自己的部分上使用最少的代码提供丰富的功能。AWS还有非常好的文档，开发人员可以快速查看以迅速掌握。S3是亚马逊的简单存储服务，允许您在云中存储和检索数据。
- en: I enjoy playing Minecraft with my kids. Some of the things they create are mind
    boggling, especially since my daughter (who plays as CupcakeSparkle) is 7 years
    old and my son (who plays as Cheetah) is only 4 years old. My daughter has been
    playing Minecraft since she was 5 and as you can imagine, she has created quite
    a few incredible structures. Joseph Garrett is by far my kids' favorite YouTuber
    who plays as Stampy Cat. They watch his Let's Play videos religiously (including
    Building Time with Squid Nugget). We often have Building Time competitions of
    our own and Stampy Cat and his lovely world serve as an inspiration for my kids
    in everything they do in Minecraft.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢和我的孩子们一起玩Minecraft。他们创造的一些东西令人难以置信，尤其是因为我的女儿（以CupcakeSparkle的身份玩耍）只有7岁，而我的儿子（以Cheetah的身份玩耍）只有4岁。我的女儿从5岁开始玩Minecraft，可以想象，她已经创造了相当多令人难以置信的结构。Joseph
    Garrett绝对是我孩子们最喜欢的YouTuber，他以Stampy Cat的身份玩耍。他们经常（包括与Squid Nugget一起建造时间）看他的游戏视频。我们经常举行自己的建造时间比赛，而Stampy
    Cat和他美丽的世界则成为我的孩子们在Minecraft中所做的一切的灵感来源。
- en: Here is the picture of Stampy Cat that my daughter built.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我女儿建造的Stampy Cat的图片。
- en: '![](img/B06434_17_23.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_23.png)'
- en: Here is the picture of Squid Nugget that my son built.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我儿子建造的Squid Nugget的图片。
- en: '![](img/B06434_17_24.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_24.png)'
- en: So, I want to create a place to upload some of their Minecraft pictures, screenshots,
    and other documents related to our Minecraft adventures. For this, we will use
    S3.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我想创建一个地方来上传一些他们的Minecraft图片、截图和与我们的Minecraft冒险相关的其他文档。为此，我们将使用S3。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This chapter assumes that you have signed up for an AWS account using the free
    tier. For more details regarding the free tier, navigate to [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
    One section I want to highlight though is the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经注册了AWS账户并使用了免费套餐。有关免费套餐的更多详细信息，请转到[https://aws.amazon.com/free/](https://aws.amazon.com/free/)。不过，我想要强调的一个部分是：
- en: <q>The Amazon Web Services (AWS) Free Tier is designed to enable you to get
    hands-on experience with AWS Cloud Services. The AWS Free Tier includes services
    with a free tier available for 12 months following your AWS sign-up date, as well
    as additional service offers that do not automatically expire at the end of your
    12 month AWS Free Tier term.</q>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <q>亚马逊网络服务（AWS）免费套餐旨在让您能够亲身体验AWS云服务。AWS免费套餐包括在您注册AWS后的12个月内提供免费套餐的服务，以及在您的12个月AWS免费套餐期满后不会自动到期的其他服务提供。</q>
- en: In order to sign up, you need to provide your credit card information. When
    the free tier period expires (or if your application exceeds the usage limitations),
    you will be charged the pay-as-you-go service rates. Regarding S3 specifically,
    the free tier allows 5GB of storage, 20,000 get requests and 2,000 put requests.
    First you will need to create an S3 bucket. From the Services selection, locate
    the Storage group and click on S3.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册，您需要提供您的信用卡信息。免费套餐期满后（或者如果您的应用程序超出了使用限制），您将按照按使用量付费的服务费率收费。特别是关于S3，免费套餐允许5GB的存储空间，20,000个获取请求和2,000个放置请求。首先，您需要创建一个S3存储桶。从服务选择中，找到存储组，然后点击S3。
- en: '![](img/B06434_17_21.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_21.jpg)'
- en: Create your first bucket. I named mine `familyvaultdocs` and selected the EU
    (Frankfurt) region. Click on Next until you have completed the creation of the
    bucket.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '创建您的第一个存储桶。我将其命名为`familyvaultdocs`并选择了EU（法兰克福）地区。点击下一步，直到完成存储桶的创建。 '
- en: '![](img/B06434_17_17.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_17.jpg)'
- en: After the bucket is created, you can review the permissions for the bucket.
    For simplicity's sake I have selected that Everyone has Read and Write permissions
    for Object access and Permissions access.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存储桶后，您可以查看存储桶的权限。为简单起见，我已选择让所有人对对象访问和权限访问具有读取和写入权限。
- en: '![](img/B06434_17_18.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_18.jpg)'
- en: Lastly, you will also need to create an access key and secret key for your application.
    From the Services, look for the Security, Identity & Compliance group and click
    on IAM (**Identity and Access Management**). Add a user with the Access type of
    Programmatic access. This will provide you with the access key ID and secret access
    key you need.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还需要为您的应用程序创建访问密钥和秘密密钥。从服务中查找安全、身份和合规性组，然后点击IAM（身份和访问管理）。添加一个访问类型为程序访问的用户。这将为您提供所需的访问密钥ID和秘密访问密钥。
- en: '![](img/B06434_17_22.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_22.jpg)'
- en: With your bucket created, user permissions set to Everyone and access keys created,
    let's write some code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了您的存储桶，用户权限设置为所有人，并创建了访问密钥，让我们写一些代码。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will just create a console application that will upload the picture to the
    S3 bucket we created earlier. Start off by opening the NuGet Package Manager and
    adding the AWSSDK NuGet package to your Console Application.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个控制台应用程序，将图片上传到之前创建的S3存储桶中。首先打开NuGet包管理器，并将AWSSDK NuGet包添加到您的控制台应用程序中。
- en: It might be worth your while to have a look at the AWS SDK for .NET at the following
    link [https://aws.amazon.com/sdk-for-net/](https://aws.amazon.com/sdk-for-net/).
    This helps developers get up to speed quickly with the SDK.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能值得查看以下链接中的.NET的AWS SDK[https://aws.amazon.com/sdk-for-net/](https://aws.amazon.com/sdk-for-net/)。这有助于开发人员快速掌握SDK。
- en: Next, create a class called `StampysLovelyWorld` and a method called `SaveStampy()`.
    There is really nothing complicated about the code. Create a client object that
    specifies the region of your bucket, create the `TransferUtilityUploadRequest`
    object that specifies the file to upload, the bucket name and directory and, lastly,
    upload the file to the bucket via a `TransferUtility`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`StampysLovelyWorld`的类和一个名为`SaveStampy()`的方法。代码真的没有什么复杂的地方。创建一个指定存储桶区域的客户端对象，创建一个指定要上传的文件、存储桶名称和目录的`TransferUtilityUploadRequest`对象，最后，通过`TransferUtility`将文件上传到存储桶。
- en: The AWS `RegionEndpoint` enumeration for EU (Frankfurt) is `EUCentral1`. Refer
    to the following link on the AWS Regions and Endpoints [https://docs.aws.amazon.com/general/latest/gr/rande.html.](https://docs.aws.amazon.com/general/latest/gr/rande.html.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AWS的`RegionEndpoint`枚举为EU（法兰克福）是`EUCentral1`。请参考AWS区域和端点的以下链接[https://docs.aws.amazon.com/general/latest/gr/rande.html.](https://docs.aws.amazon.com/general/latest/gr/rande.html.)
- en: In reality, we would probably enumerate the contents of a folder or even allow
    the user to select several files. This class is only to illustrate the concept
    of uploading a file to our bucket. As you will see, this code is really uncomplicated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可能会枚举文件夹的内容，甚至允许用户选择多个文件。这个类只是为了说明将文件上传到我们的存储桶的概念。正如您将看到的，这段代码真的很简单。
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `static void Main` method of the console application, specify the bucket
    name you created earlier, a folder to create in the bucket and the filename you
    want in the S3 folder. Pass these along with the path to your file, to the `SaveStampy()`
    method in the `StampysLovelyWorld` class.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序的`static void Main`方法中，指定您之前创建的存储桶名称，要在存储桶中创建的文件夹以及您想要在S3文件夹中的文件名。将这些与文件的路径一起传递给`StampysLovelyWorld`类中的`SaveStampy()`方法。
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last thing we need to do is add the access key and secret key to the App.config
    file of our console application. Just add an `<appSettings>` section and add the
    keys listed here. You will obviously use the access key and secret key you generated
    in the IAM earlier.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将访问密钥和秘密密钥添加到我们控制台应用程序的App.config文件中。只需添加一个`<appSettings>`部分，并添加此处列出的密钥。您显然会使用之前在IAM中生成的访问密钥和秘密密钥。
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run your console application. After the file is uploaded, your console application
    will just display the text uploaded in the output.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序。文件上传后，您的控制台应用程序将在输出中显示上传的文本。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Swing back to your `familyvaultdocs` bucket in AWS and click on the refresh
    icon next to the EU (Frankfurt) region. You will see the folder `MinecraftPictures`
    you specified in code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到AWS中的`familyvaultdocs`存储桶，并单击欧盟（法兰克福）区域旁边的刷新图标。您将看到您在代码中指定的`MinecraftPictures`文件夹。
- en: '![](img/B06434_17_19.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_19.jpg)'
- en: Clicking on the folder, you will see the contents listed. I previously uploaded
    the `SquidNugget.png` image, but the `StampyCat.png` image we uploaded in our
    code sample has been prefixed with the date as specified in code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单击文件夹，您将看到列出的内容。我之前上传了`SquidNugget.png`图像，但我们在代码示例中上传的`StampyCat.png`图像已经根据代码中指定的日期前缀。
- en: '![](img/B06434_17_20.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_20.jpg)'
- en: The code is run and the files are added almost immediately. Admittedly they
    aren't very big files, but this goes to show how easy it is to add a simple storage
    service to AWS and integrate that with a .NET application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行并且文件几乎立即被添加。诚然，这些文件并不是很大，但这表明了在AWS中添加简单存储服务并将其与.NET应用程序集成是多么容易。
- en: Creating C# Lambda functions with AWS
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS创建C# Lambda函数
- en: On the 1st of December 2016, Amazon announced that C# was now a supported language
    for AWS Lambda. This is therefore really fresh off the press, so to speak, and
    developers can experiment with using AWS Lambda in their .NET applications. AWS
    Lambda allows you to deploy your code to AWS and not have to worry about the machines
    the code runs on or even worry about the scaling of those machines when demand
    increases. Your code will just work. This is really great for mobile developers.
    Up until December, AWS Lambda only supported Node.js, Pythos, and Java. Let's
    take a look at how to create a Lambda function in Visual Studio 2017 using C#.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年12月1日，亚马逊宣布C#现在是AWS Lambda支持的语言。因此，这实际上是最新的消息，开发人员可以尝试在.NET应用程序中使用AWS Lambda。AWS
    Lambda允许您将代码部署到AWS，而无需担心代码运行的机器，甚至无需担心需求增加时这些机器的扩展。您的代码将正常工作。这对移动开发人员来说非常棒。直到12月，AWS
    Lambda只支持Node.js、Pythos和Java。让我们看看如何在Visual Studio 2017中使用C#创建Lambda函数。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to ensure that you have downloaded and installed the preview of the
    AWS Toolkit for Visual Studio 2017\. At the time of this writing, the toolkit
    could be found at this link: [https://aws.amazon.com/blogs/developer/preview-of-the-aws-toolkit-for-visual-studio-2017/](https://aws.amazon.com/blogs/developer/preview-of-the-aws-toolkit-for-visual-studio-2017/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保已下载并安装了Visual Studio 2017的AWS Toolkit预览版。在撰写本文时，工具包可以在以下链接找到：[https://aws.amazon.com/blogs/developer/preview-of-the-aws-toolkit-for-visual-studio-2017/](https://aws.amazon.com/blogs/developer/preview-of-the-aws-toolkit-for-visual-studio-2017/)。
- en: If you are using an earlier version of Visual Studio, download the AWS Toolkit
    from this link: [https://aws.amazon.com/visualstudio/](https://aws.amazon.com/visualstudio/).
    This version of the toolkit supports Visual Studio 2015 and also allows you to
    download legacy versions for Visual Studio 2010-2012 and Visual Studio 2008\.
    After you have downloaded and installed the toolkit, you are ready to create your
    first AWS Lambda function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是较早版本的Visual Studio，请从此链接下载AWS Toolkit：[https://aws.amazon.com/visualstudio/](https://aws.amazon.com/visualstudio/)。该工具包支持Visual
    Studio 2015，并允许您下载Visual Studio 2010-2012和Visual Studio 2008的旧版本。下载并安装工具包后，您就可以创建您的第一个AWS
    Lambda函数了。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Launch Visual Studio and create a new project. Under the Visual C# templates,
    you will see a new type called AWS Lambda. Click on the AWS Lambda Project (.NET
    Core) template. That's right, these are .NET Core apps.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio并创建一个新项目。在Visual C#模板下，您将看到一个名为AWS Lambda的新类型。单击AWS Lambda项目(.NET
    Core)模板。没错，这些是.NET Core应用程序。
- en: '![](img/B06434_17_25.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_25.jpg)'
- en: The next screen will allow us to select a blueprint. For our purposes, we will
    just select a Simple S3 Function blueprint that responds to S3 event notifications.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个屏幕将允许我们选择一个蓝图。对于我们的目的，我们将选择一个简单的S3函数蓝图，用于响应S3事件通知。
- en: '![](img/B06434_17_26.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_26.jpg)'
- en: The function is created and your Solution Explorer in Visual Studio will look
    as follows.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数已创建，您的Visual Studio中的解决方案资源管理器将如下所示。
- en: '![](img/B06434_17_27.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_27.jpg)'
- en: 'The code that is added to the `Function.cs` file is simply a class that has
    at its heart a method called `FunctionHandler()`. You will also notice an assembly
    attribute at the top of the class as follows: `[assembly: LambdaSerializerAttribute(typeof(Amazon.Lambda.Serialization.Json.JsonSerializer))]`.
    This is required and registers the  Lambda JSON serializer that is using `Newtonsoft.Json`
    to create our typed class. Since this code just works, I will not spend much time
    on explaining it.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加到`Function.cs`文件的代码只是一个具有名为`FunctionHandler()`的方法的类。您还会注意到类顶部的程序集属性如下：`[assembly:
    LambdaSerializerAttribute(typeof(Amazon.Lambda.Serialization.Json.JsonSerializer))]`。这是必需的，并注册了使用`Newtonsoft.Json`创建我们的类型化类的Lambda
    JSON序列化程序。由于这段代码只是起作用，我不会花太多时间来解释它。'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can now publish the function to AWS directly from within Visual Studio.
    Right-click on the project that you created and from the context menu, select
    Publish to AWS Lambda....
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以直接从Visual Studio中发布函数到AWS。右键单击您创建的项目，从上下文菜单中选择发布到AWS Lambda....
- en: '![](img/B06434_17_28.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_28.jpg)'
- en: You now need to complete the deployment wizard. Give your function a name, and
    if you do not have an account profile selected, add one.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要完成部署向导。为您的函数命名，如果您没有选择帐户配置文件，请添加一个。
- en: '![](img/B06434_17_29.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_29.jpg)'
- en: For your AWS Lambda function, be sure to select the same region as that of your
    S3 bucket created in the previous recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的AWS Lambda函数，请确保选择与上一篇文章中创建的S3存储桶相同的区域。
- en: Adding an account profile is really easy. This is the account you configured
    in IAM.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加账户配置文件非常简单。这是您在IAM中配置的帐户。
- en: '![](img/B06434_17_30.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_30.jpg)'
- en: Clicking next will allow you to select the IAM Role Name that provides access
    permissions to S3 and our function. This is configured in the **IAM** (**Identity
    and Access Management**).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“下一步”将允许您选择为S3和我们的函数提供访问权限的IAM角色名称。这是在**IAM**（身份和访问管理）中配置的。
- en: '![](img/B06434_17_31.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_31.jpg)'
- en: Click on Upload to upload the function to AWS.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“上传”将函数上传到AWS。
- en: '![](img/B06434_17_32.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_32.jpg)'
- en: 'Take note, however, that there might be several permission issues encountered
    at this step. You might encounter something like the following:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在这一步可能会遇到几个权限问题。您可能会遇到以下内容：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can in fact receive several such errors when trying to upload your function
    to AWS. The Identity and Access Management area in AWS is your friend here. You
    should have a look at the user you are using (in this case the user is S3Lambda)
    and review the permissions attributed to the user. Here, the error is informing
    us that the user S3Lambda does not have permission to create the function on AWS
    for the S3LambdaFunction resource. Modify your permissions and try uploading again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在尝试将函数上传到AWS时，您可能会收到几个此类错误。AWS中的身份和访问管理区域在这里是您的朋友。您应该查看您正在使用的用户（在本例中是S3Lambda）并审查分配给用户的权限。在这里，错误通知我们，用户S3Lambda没有权限在AWS上为S3LambdaFunction资源创建函数。修改您的权限，然后尝试重新上传。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After you have uploaded your function to AWS, click on the View menu in Visual
    Studio and select the AWS Explorer. Expanding the AWS Lambda node will show us
    the function we previously uploaded. If you see an error when expanding the node,
    you might need to give your user the ListFunctions permission. Expanding the AWS
    Identity and Access Management node will also show you the users, groups and roles
    you have configured. You can easily test your AWS Lambda function from within
    Visual Studio here by selecting one of the Example Requests and clicking on the
    Invoke button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数上传到AWS后，在Visual Studio中单击“查看”菜单，然后选择AWS资源管理器。展开AWS Lambda节点将显示我们之前上传的函数。如果在展开节点时看到错误，可能需要为您的用户提供ListFunctions权限。展开AWS身份和访问管理节点还将显示您配置的用户、组和角色。您可以通过选择一个示例请求并单击“调用”按钮在Visual
    Studio中轻松测试AWS Lambda函数。
- en: '![](img/B06434_17_33.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_33.jpg)'
- en: What we want to do, however, is hook up our S3 that stores files to send events
    to our function. Click on the Event Sources tab and click the Add button. Select
    Amazon S3 as the Source Type and select the `familyvaultdocs` bucket we created
    in the previous recipe. When you are done, click on the OK button.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想要做的是将存储文件的S3连接到我们的函数以发送事件。单击“事件源”选项卡，然后单击“添加”按钮。选择Amazon S3作为源类型，并选择我们在上一篇文章中创建的“familyvaultdocs”存储桶。完成后，单击“确定”按钮。
- en: '![](img/B06434_17_34.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_34.jpg)'
- en: Running the console application in the previous recipe to upload a new file
    to our S3 bucket will trigger our Lambda function. We can confirm this by looking
    at the Logs section in our function view.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一篇文章中的控制台应用程序以将新文件上传到我们的S3存储桶将触发我们的Lambda函数。我们可以通过查看函数视图中的日志部分来确认这一点。
- en: '![](img/B06434_17_35.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_35.jpg)'
- en: You can also upload files from the AWS Explorer. Expand the Amazon S3 node and
    click on the Upload File button to the bucket.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从AWS资源管理器上传文件。展开Amazon S3节点，然后单击“上传文件”按钮到存储桶。
- en: '![](img/B06434_17_36.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_36.jpg)'
- en: Your file is uploaded and the progress is shown in the status window at the
    bottom.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您的文件已上传，并且进度显示在底部的状态窗口中。
- en: '![](img/B06434_17_37.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_17_37.jpg)'
- en: While this example is not too complicated (with the exception of the permission
    settings perhaps), it does illustrate the concept of AWS Lambda functions. We
    can use the function to do a host of actions when triggered from something as
    simple as an event in an S3 bucket. Start to combine functionality and you can
    create a very powerful, serverless module to support and enhance your applications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子并不太复杂（除了权限设置可能有点复杂），但它确实说明了AWS Lambda函数的概念。我们可以使用该函数在触发来自S3存储桶中的事件等简单事件时执行一系列操作。开始结合功能，您可以创建一个非常强大的无服务器模块，以支持和增强您的应用程序。
- en: It does not matter if you are using AWS, Azure or something such as DocRaptor
    (or any of the other 3rd party services available). Serverless computing is here
    to stay and C# Lambda functions will change the face of development in a big way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用AWS、Azure还是诸如DocRaptor（或任何其他第三方服务），无服务器计算都将长存下去，C# Lambda函数将以一种重大的方式改变开发的面貌。
