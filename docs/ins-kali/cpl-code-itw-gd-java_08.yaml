- en: '*Chapter 6*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6章*：'
- en: Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: This chapter covers the most popular questions and problems relating to **Object-Oriented
    Programming** (**OOP**) that are encountered at Java interviews.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在Java面试中遇到的与**面向对象编程**（**OOP**）相关的最流行的问题和问题。
- en: Please bear in mind that my goal is not to teach you about OOP or, in more general
    terms, the aim of this book is not to teach you about Java. My goal is to teach
    you how to answer questions and solve problems in the context of an interview.
    In such a context, the interviewer wants a clear and concise answer; you'll not
    have the time for dissertations and tutorials. You have to be able to express
    your ideas lucidly and cogently. Your answers should be meaningful and you have
    to convince the interviewer that you really understand what you are saying and
    that you are not just reciting a number of sterile definitions. Most of the time,
    you should be able to express an article of several pages or a chapter of a book
    in one or several key paragraphs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我的目标不是教你面向对象编程，或者更一般地说，这本书的目标不是教你Java。我的目标是教你如何在面试的情境下回答问题和解决问题。在这样的情境下，面试官希望得到一个清晰而简洁的答案；你没有时间写论文和教程。你必须能够清晰而有力地表达你的想法。你的答案应该是有意义的，你必须说服面试官你真正理解你在说什么，而不只是背诵一些空洞的定义。大多数情况下，你应该能够用一两个关键段落表达一篇文章或一本书的一章。
- en: By the end of this chapter, you'll know how to answer 40+ questions and problems
    that cover the fundamental aspects of OOP. Being fundamental aspects, you have
    to know them in detail. There is no excuse in the event that you don't know the
    correct and concise answers to these problems. A lack of knowledge in this area
    can severely affect your chances of success at interview.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将知道如何回答40多个涵盖面向对象编程基本方面的问题和问题。作为基本方面，你必须详细了解它们。如果你不知道这些问题的正确和简洁的答案，那么在面试中成功的机会将受到严重影响。
- en: 'So, let''s summarize our agenda as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结我们的议程如下：
- en: OOP concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程概念
- en: SOLID principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: GOF design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOF设计模式
- en: Coding challenges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Let's start with questions relating to OOP concepts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与面向对象编程概念相关的问题开始。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find all the codes present in this chapter on GitHub. Please visit the
    following link:[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中的所有代码。请访问以下链接：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter06)
- en: Understanding OOP concepts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程概念
- en: 'The OOP model is based on several concepts. These concepts must be familiar
    to any developer who is planning to design and program applications relying on
    objects. Therefore, let''s start by enumerating them as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象模型基于几个概念。这些概念对于计划设计和编写依赖于对象的应用程序的任何开发人员来说都必须熟悉。因此，让我们从以下列举它们开始：
- en: Object
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Class
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Abstraction
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Encapsulation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Association
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协会
- en: Aggregation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Composition
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Commonly, when these concepts are wrapped in questions, they are prefixed by
    *What is ...?* For example, *What is an object?*, or *What is polymorphism?*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当这些概念被包含在问题中时，它们会以*什么是...?*为前缀。例如，*什么是对象?*，或者*什么是多态?*
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The correct answers to these questions are a combination of technical knowledge
    and real-world analogies or examples. Avoid cold answers with super-technical
    details and no examples (for example, don't talk about the internal representation
    of an object). Pay attention to what you're saying because the interviewer may
    extract questions directly from your answers. If your answer has mentioned a notion
    in passing, then the next question may refer to that notion. In other words, don't
    add to your answer any aspects that you are unfamiliar with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的正确答案是技术知识和现实世界的类比或例子的结合。避免冷冰冰的答案，没有超级技术细节和没有例子（例如，不要谈论对象的内部表示）。注意你说的话，因为面试官可能直接从你的答案中提取问题。如果你的答案中提到了一个概念，那么下一个问题可能会涉及到那个概念。换句话说，不要在你的答案中添加任何你不熟悉的方面。
- en: So, let's answer the questions relating to OOP concepts in an interview context.
    Notice that we apply what we've learned in [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072),
    *How to Approach a Coding Challenge*. More precisely, we follow the **Understand
    the question**|**Nominate the key words/key points**|**Wrap an answer** technique.
    To begin with, in order to become familiar with this technique, I'll extract the
    key points as a bulleted list, and I will italicize them in the answer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在面试情境下回答与面向对象编程概念相关的问题。请注意，我们应用了[*第5章*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)中学到的内容，*如何应对编码挑战*。更确切地说，我们遵循**理解问题**|**确定关键词/关键点**|**给出答案**的技巧。首先，为了熟悉这种技巧，我将提取关键点作为一个项目列表，并在答案中用斜体标出它们。
- en: What is an object?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你的答案中应该包含以下关键点：
- en: An object is one of the core concepts of OOP.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是面向对象编程的核心概念之一。
- en: An object is a real-world entity.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是一个现实世界的实体。
- en: An object has state (fields) and behaviors (methods).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象具有状态（字段）和行为（方法）。
- en: An object represents an instance of a class.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象表示类的一个实例。
- en: An object takes up some space in memory.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象占据内存中的一些空间。
- en: An object can communicate with other objects.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以与其他对象通信。
- en: 'Now, we can present an answer as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式提出答案：
- en: '*An object is one of the core concepts of OOP. An object is a real-world entity,
    such as a car,* *table, or cat*. During its life cycle, an object *has state and
    behaviors*. For example, a cat''s state can be color, name, and breed, while its
    behaviors can be playing, eating, sleeping, and meowing. In Java, an object is
    an instance of a class usually built via the `new` keyword, and *it has state
    stored in fields and exposes its behavior through methods. Each instance takes
    some space in memory and can communicate with other objects*. For example, a boy,
    which is another object, can caress a cat and it sleeps.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象是面向对象编程的核心概念之一。对象是现实世界的实体，比如汽车、桌子或猫。在其生命周期中，对象具有状态和行为。例如，猫的状态可以是颜色、名字和品种，而其行为可以是玩耍、吃饭、睡觉和喵喵叫。在Java中，对象通常是通过`new`关键字构建的类的实例，它的状态存储在字段中，并通过方法公开其行为。每个实例在内存中占据一些空间，并且可以与其他对象通信。例如，另一个对象男孩可以抚摸一只猫，然后它就会睡觉。'
- en: If further details are required, then you may want to talk about the fact that
    objects can have different access modifiers and visibility ranges, can be mutable,
    unmodifiable, or immutable, and are collected via the garbage collector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可能想谈论对象可以具有不同的访问修饰符和可见性范围，可以是可变的、不可变的或不可变的，并且可以通过垃圾收集器进行收集。
- en: What is a class?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是类？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中封装的关键点是：
- en: A class is one of the core concepts of OOP.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是面向对象编程的核心概念之一。
- en: A class is a template or a blueprint for creating objects.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是创建对象的模板或蓝图。
- en: A class doesn't consume memory.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不会占用内存。
- en: A class can be instantiated multiple times.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以被实例化多次。
- en: A class does one, and only one, thing.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类只做一件事。
- en: 'Now, we can present an answer as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样提出一个答案：
- en: '*A class is one of the core concepts of OOP.* A class is a set of instructions
    that are required to build a specific type of object. We can *think of a class
    as a template, a blueprint*, or a recipe that tells us how to create objects of
    that class. *Creating an object of that class is a process called instantiation*
    and is usually done via the `new` keyword. *We can instantiate as many objects
    as we wish. A class definition doesn''t consume memory* being saved as a file
    on the hard drive. One of the best practices that a class should follow is the
    **Single Responsibility Principle** **(SRP)**. While conforming to this principle,
    *a class should be designed and written to do one, and only one, thing.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*类是面向对象编程的核心概念之一。类是构建特定类型对象所需的一组指令。我们可以把类想象成一个模板、蓝图或配方，告诉我们如何创建该类的对象。创建该类的对象是一个称为实例化的过程，通常通过`new`关键字完成。我们可以实例化任意多个对象。类定义不会占用内存，而是保存在硬盘上的文件中。一个类应该遵循的最佳实践之一是**单一职责原则**（SRP）。在遵循这个原则的同时，一个类应该被设计和编写成只做一件事。'
- en: If further details are required, then you may want to talk about the fact that
    classes can have different access modifiers and visibility ranges, support different
    types of variables (local, class, and instance variables), and can be declared
    as `abstract`, `final`, or `private`, nested in another class (inner class), and
    so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可能想谈论类可以具有不同的访问修饰符和可见性范围，支持不同类型的变量（局部、类和实例变量），并且可以声明为`abstract`、`final`或`private`，嵌套在另一个类中（内部类），等等。
- en: What is abstraction?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是抽象？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中封装的关键点是：
- en: Abstraction is one of the core concepts of OOP.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象是面向对象编程的核心概念之一。
- en: Abstraction is the concept of exposing to the user only those things that are
    relevant to them and hiding the remainder of the details.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象是将对用户有意义的东西暴露给他们，隐藏其余的细节。
- en: Abstraction allows the user to focus on what the application does instead of
    how it does it.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象允许用户专注于应用程序的功能，而不是它是如何实现的。
- en: Abstraction is achieved in Java via abstract classes and interfaces.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，通过抽象类和接口实现抽象。
- en: 'Now, we can present an answer as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样提出一个答案：
- en: Einstein claims that *Everything should be made as simple as possible, but not
    simpler*. *Abstraction is one of the main OOP concepts* that strive to make things
    as simple as possible for the user. In other words, *abstraction exposes the user
    only to the things that are relevant to them and hides the remainder of the details*.
    In OOP terms, we say that an object should expose to its users only a set of high-level
    operations, while the internal implementation of those operations is hidden. So,
    *abstraction allows the user to focus on what the application does instead of
    how it does it*. This way, abstraction reduces the complexity of exposing the
    things, increases code reusability, avoids code duplications, and sustains low
    coupling and high cohesion. Moreover, it maintains the security and discretion
    of the application by exposing only the important details.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 爱因斯坦声称*一切都应该尽可能简单，但不要过于简单*。*抽象是面向对象编程的主要概念之一*，旨在尽可能简化用户的操作。换句话说，*抽象只向用户展示对他们有意义的东西，隐藏其余的细节*。在面向对象编程的术语中，我们说一个对象应该向其用户只公开一组高级操作，而这些操作的内部实现是隐藏的。因此，*抽象允许用户专注于应用程序的功能，而不是它是如何实现的*。这样，抽象减少了暴露事物的复杂性，增加了代码的可重用性，避免了代码重复，并保持了低耦合和高内聚。此外，它通过只暴露重要细节来维护应用程序的安全性和保密性。
- en: 'Let''s consider a real-life example: a man driving a car. The man knows what
    each pedal does and what the steering wheel does, but he doesn''t know how these
    things are done internally by the car. He doesn''t know about the inner mechanisms
    that empower these things. This is what abstraction is. *In Java, abstraction
    can be achieved via abstract classes and interfaces*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个现实生活的例子：一个人开车。这个人知道每个踏板的作用，以及方向盘的作用，但他不知道这些事情是车内部是如何完成的。他不知道赋予这些事情力量的内部机制。这就是抽象。*在Java中，可以通过抽象类和接口实现抽象*。
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'So, we said that a man is driving a car. The man can speed up or slow down
    the car via the corresponding pedals. He also can turn left and right with the
    aid of the steering wheel. All these actions are grouped in an interface named
    `Car`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们说一个人在开车。这个人可以通过相应的踏板加速或减速汽车。他还可以通过方向盘左转和右转。所有这些操作都被分组在一个名为`Car`的接口中：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, each type of car should implement the `Car` interface and override these
    methods to provide the implementation of these actions. This implementation is
    hidden from the user (the man driving the car). For example, the `ElectricCar`
    class appears as follows (in reality, in place of `System.out.println`, we have
    complex business logic):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每种类型的汽车都应该实现`Car`接口，并重写这些方法来提供这些操作的实现。这个实现对用户（驾驶汽车的人）是隐藏的。例如，`ElectricCar`类如下所示（实际上，我们有复杂的业务逻辑代替了`System.out.println`）：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The user of this class has access to these `public` methods without being aware
    of the implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的用户可以访问这些公共方法，而不需要了解具体的实现：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is listed as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列举如下：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, this was an example of abstraction via an interface. The complete application
    is named *Abstraction/AbstractionViaInterface*. In the code bundled to this book,
    you can find the same scenario implemented via an abstract class. The complete
    application is named *Abstraction/AbstractionViaAbstractClass***.**
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是一个通过接口进行抽象的例子。完整的应用程序名为*Abstraction/AbstractionViaInterface*。在本书附带的代码中，你可以找到通过抽象类实现相同场景的代码。完整的应用程序名为*Abstraction/AbstractionViaAbstractClass*。
- en: Moving on, let's talk about encapsulation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈封装。
- en: What is encapsulation?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是封装？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中封装的关键点如下：
- en: Encapsulation is one of the core concepts of OOP.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装是面向对象编程的核心概念之一。
- en: Encapsulation is the technique whereby the object state is hidden from the outer
    world and a set of public methods for accessing this state are exposed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装是一种技术，通过它，对象状态被隐藏，同时提供了一组公共方法来访问这个状态。
- en: Encapsulation is achieved when each object keeps its state private, inside a
    class.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个对象将其状态私有化在一个类内部时，封装就实现了。
- en: Encapsulation is known as the *data-hiding* mechanism.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装被称为*数据隐藏*机制。
- en: Encapsulation has a number of important advantages associated with it, such
    as loosely coupled, reusable, secure, and easy-to-test code.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装有许多重要的优点，比如松散耦合、可重用、安全和易于测试的代码。
- en: In Java, encapsulation is implemented via the access modifiers – `public`, `private`,
    and `protected.`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，封装是通过访问修饰符（`public`、`private`和`protected`）实现的。
- en: 'Now, we can present an answer as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样呈现一个答案：
- en: '*Encapsulation is one of the core concepts of OOP*. Mainly, encapsulation binds
    together the code and data in a single unit of work (a class) and acts as a defensive
    shield that doesn''t allow external code to access this data directly. Mainly,
    *it is the technique of hiding the object state from the outer world and exposing
    a set of* `public` *methods for accessing this state. When each object keeps its
    state* `private` *inside a class, we can say that encapsulation was achieved.
    This is why encapsulation is also referenced as the* `public`, `private`, and
    `protected`. Commonly, when an object manages its own state, its state is declared
    via `private` variables and is accessed and/or modified via `public` methods.
    Let''s consider an example: a `Cat` class can have its state represented by fields
    such as `mood`, `hungry`, and `energy`. While the code external to the `Cat` class
    cannot modify any of these fields directly, it can call `public` methods, such
    as `play()`, `feed()`, and `sleep()` that modify the `Cat` state internally. The
    `Cat` class may also have `private` methods that are not accessible outside the
    class, such as `meow()`.This is encapsulation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程的核心概念之一。主要来说，封装将代码和数据绑定在一个单元（类）中，并充当一个防御屏障，不允许外部代码直接访问这些数据。主要来说，它是隐藏对象状态，向外部提供一组公共方法来访问这个状态的技术。当每个对象将其状态私有化在一个类内部时，我们可以说封装已经实现。这就是为什么封装也被称为公共、私有和受保护。通常，当一个对象管理自己的状态时，其状态通过私有变量声明，并通过公共方法访问和/或修改。让我们举个例子：一个`Cat`类可以通过`mood`、`hungry`和`energy`等字段来表示其状态。虽然`Cat`类外部的代码不能直接修改这些字段中的任何一个，但它可以调用`play()`、`feed()`和`sleep()`等公共方法来在内部修改`Cat`的状态。`Cat`类也可能有私有方法，外部无法访问，比如`meow()`。这就是封装。
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'So, the `Cat` class from our example can be coded as indicated in the following
    code block. Notice that the state of this class was encapsulated via `private`
    fields, and is therefore not directly accessible from outside the class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的例子中的`Cat`类可以按照下面的代码块进行编码。注意，这个类的状态是通过私有字段封装的，因此不能直接从类外部访问：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only way to modify the state is via the public methods, `play()`, `feed()`,
    and `sleep()`, as in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 修改状态的唯一方式是通过`play()`、`feed()`和`sleep()`这些公共方法，就像下面的例子一样：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete application is named *Encapsulation***.** Now, let's have a rundown
    on inheritance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*Encapsulation*。现在，让我们来了解一下继承。
- en: What is inheritance?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是继承？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中封装的关键点如下：
- en: Inheritance is one of the core concepts of OOP.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的核心概念之一。
- en: Inheritance allows an object to be based on another object.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承允许一个对象基于另一个对象。
- en: Inheritance sustains code reusability by allowing an object to reuse the code
    of another object and adds its own logic as well.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承通过允许一个对象重用另一个对象的代码并添加自己的逻辑来实现代码的可重用性。
- en: Inheritance is known as an **IS-A** relationship, also referenced as a parent-child
    relationship.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承被称为**IS-A**关系，也被称为父子关系。
- en: In Java, inheritance is achieved via the `extends` keyword.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，继承是通过`extends`关键字实现的。
- en: The inherited object is referenced as the superclass, and the object that inherits
    the superclass is referenced as the subclass.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承的对象被称为超类，继承超类的对象被称为子类。
- en: In Java, multiple classes cannot be inherited.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，不能继承多个类。
- en: 'Now, we can present an answer as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样呈现一个答案：
- en: '*Inheritance is one of the core concepts of OOP. It allows an object to be
    based on another object*, which is useful when different objects are pretty similar
    and share some common logic, but they are not identical. *Inheritance sustains
    code reusability by allowing an object to reuse the code of another object while
    it adds its own logic as well*. So, in order to achieve inheritance, we reuse
    the common logic and extract the unique logic in another class. *This is known
    as an IS-A relationship, also referenced as a parent-child relationship*. It is
    just like saying `Foo` IS-A `Buzz` type of thing. For example, cat IS-A feline,
    and train IS-A vehicle. An IS-A relationship is the unit of work used to define
    hierarchies of classes. *In Java, inheritance is accomplished via the* `extends`
    *keyword by deriving the child from its parent*. The child can reuse the fields
    and methods of its parent and add its own fields and methods. *The inherited object
    is referenced as the superclass, or the parent class, and the object that inherits
    the superclass is referenced as the subclass, or the child class. In Java, inheritance
    cannot be multiple*; therefore, a subclass or child class cannot inherit fields
    and methods of more than one superclass or parent class. For example, an `Employee`
    class (parent class) can define the common logic of any employee in a software
    company, while another class (child class), named `Programmer`, can extend the
    `Employee` to use this common logic and add logic specific to a programmer. Other
    classes can extend the `Programmer` or `Employee` classes as well.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “继承是面向对象编程的核心概念之一。它允许一个对象基于另一个对象”，当不同的对象非常相似并共享一些公共逻辑时，这是很有用的，但它们并不完全相同。“继承通过允许一个对象重用另一个对象的代码来实现代码的可重用性，同时它也添加了自己的逻辑”。因此，为了实现继承，我们重用公共逻辑并将独特的逻辑提取到另一个类中。“这被称为IS-A关系，也被称为父子关系”。就像说`Foo`是`Buzz`类型的东西一样。例如，猫是猫科动物，火车是车辆。IS-A关系是用来定义类层次结构的工作单元。“在Java中，继承是通过`extends`关键字实现的，通过从父类派生子类”。子类可以重用其父类的字段和方法，并添加自己的字段和方法。“继承的对象被称为超类，或者父类，继承超类的对象被称为子类，或者子类。在Java中，继承不能是多重的；因此，子类或子类不能继承多于一个超类或父类的字段和方法。例如，`Employee`类（父类）可以定义软件公司任何员工的公共逻辑，而另一个类（子类），名为`Programmer`，可以扩展`Employee`以使用这个公共逻辑并添加特定于程序员的逻辑。其他类也可以扩展`Programmer`或`Employee`类。”
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'The `Employee` class is quite simple. It wraps the name of the employee:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类非常简单。它包装了员工的名字：'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the `Programmer` class extends the `Employee`. As any employee, a programmer
    has a name, but they are also assigned to a team:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Programmer`类扩展了`Employee`。像任何员工一样，程序员有一个名字，但他们也被分配到一个团队中：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s test inheritance by creating a `Programmer` and calling `getName()`,
    inherited from the `Employee` class, and `getTeam()`, inherited from the `Programmer`
    class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个`Programmer`并调用从`Employee`类继承的`getName()`和从`Programmer`类继承的`getTeam()`来测试继承：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete application is named *Inheritance*. Moving on, let's talk about
    polymorphism.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序被命名为*继承*。接下来，让我们谈谈多态。
- en: What is polymorphism?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是多态？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中包含的关键点是：
- en: Polymorphism is one of the core concepts of OOP.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态是面向对象编程的核心概念之一。
- en: Polymorphism means *many forms* in Greek.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态在希腊语中意味着“多种形式”。
- en: Polymorphism allows an object to behave differently in certain cases.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态允许对象在某些情况下表现得不同。
- en: Polymorphism can be shaped via method overloading (known as Compile-Time Polymorphism)
    or via method overriding in the case of an IS-A relationship (known as Runtime
    Polymorphism).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态可以通过方法重载（称为编译时多态）或通过方法重写来实现IS-A关系（称为运行时多态）。
- en: 'Now, we can present an answer as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样呈现一个答案：
- en: '*Polymorphism is one of the core concepts of OOP*. Polymorphism is a word composed
    of two Greek words: *poly*, which means *many*, and *morph*, which means *forms*.
    Therefore, *polymorphism means many forms*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*多态是面向对象编程的核心概念之一*。多态是由两个希腊单词组成的：*poly*，意思是*多*，*morph*，意思是*形式*。因此，*多态意味着多种形式*。'
- en: More precisely, in the OOP context, *polymorphism allows an object to behave
    differently in certain cases* or, in other words, allows an action to be accomplished
    in different ways (approaches). *One way to implement polymorphism is via method
    overloading. This is known as Compile-Time Polymorphism* because the compiler
    can identify at compile time which form of an overloaded method to call (multiple
    methods with the same name but different arguments). So, depending on which form
    of the overloaded method is called, the object behaves differently. For example,
    a class named `Triangle` can define multiple methods named `draw()` with different
    arguments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，在面向对象编程的上下文中，*多态性允许对象在某些情况下表现不同*，或者换句话说，允许以不同的方式（方法）完成某个动作。*实现多态性的一种方式是通过方法重载。这被称为编译时多态性*，因为编译器可以在编译时识别调用重载方法的形式（具有相同名称但不同参数的多个方法）。因此，根据调用的重载方法的形式，对象的行为会有所不同。例如，名为`Triangle`的类可以定义多个带有不同参数的`draw()`方法。
- en: '*Another way to implement polymorphism is via method overriding, and this is
    the common approach when we have an IS-A relationship. It is known as Runtime
    Polymorphism, or Dynamic Method Dispatch*. Typically, we start with an interface
    containing a bunch of methods. Next, each class implements this interface and
    overrides these methods to provide a specific behavior. This time, polymorphism
    allows us to use any of these classes exactly like its parent (the interface)
    without any confusion of their types. This is possible because, at runtime, Java
    can distinguish between these classes and knows which one is used. For example,
    an interface named `Shape` can declare a method named `draw()`, and the `Triangle`,
    `Rectangle`, and `Circle` classes implement the `Shape` interface and override
    the `draw()` method to draw the corresponding shape.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*另一种实现多态性的方法是通过方法重写，当我们有一个IS-A关系时，这是常见的方法。这被称为运行时多态性，或动态方法分派*。通常，我们从一个包含一堆方法的接口开始。接下来，每个类实现这个接口并重写这些方法以提供特定的行为。这次，多态性允许我们像使用其父类（接口）一样使用这些类中的任何一个，而不会混淆它们的类型。这是可能的，因为在运行时，Java可以区分这些类并知道使用哪一个。例如，一个名为`Shape`的接口可以声明一个名为`draw()`的方法，而`Triangle`、`Rectangle`和`Circle`类实现了`Shape`接口并重写了`draw()`方法来绘制相应的形状。'
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可以分享屏幕或使用纸和笔编写你的例子。
- en: Polymorphism via method overloading (compile time)
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过方法重载实现多态性（编译时）
- en: 'The `Triangle` class contains three `draws()` methods, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`类包含三个`draw()`方法，如下所示：'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, notice how the corresponding `draw()` method is called:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意相应的`draw()`方法是如何被调用的：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The complete application is named *Polymorphism/CompileTime*. Moving on, let's
    look at an example of implementing runtime polymorphism.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*多态性/编译时*。接下来，让我们看一个实现运行时多态性的例子。
- en: Polymorphism via method overriding (runtime)
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过方法重写实现多态性（运行时）
- en: 'This time, the `draw()` method is declared in an interface, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`draw()`方法是在一个接口中声明的，如下所示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Triangle`, `Rectangle`, and `Circle` classes implement the `Shape` interface
    and override the `draw()` method to draw the corresponding shape:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`、`Rectangle`和`Circle`类实现了`Shape`接口并重写了`draw()`方法来绘制相应的形状：'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create a triangle, a rectangle, and a circle. For each of these instances,
    let''s call the `draw()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个三角形、一个矩形和一个圆。对于这些实例中的每一个，让我们调用`draw()`方法：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output reveals that, at runtime, Java called the proper `draw()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，在运行时，Java调用了正确的`draw()`方法：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete application is named *Polymorphism/Runtime*. Moving on, let's talk
    about association.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*多态性/运行时*。接下来，让我们谈谈关联。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are people who consider polymorphism as the most important concept in
    OOP. Moreover, there are voices that consider runtime polymorphism as the only
    genuine polymorphism, while compile-time polymorphism is not actually a form of
    polymorphism. During an interview, initiating such a debate is not recommended.
    It is better to act as a mediator and present both sides of the coin. We will
    discuss soon how to tackle such situations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为多态性是面向对象编程中最重要的概念。此外，也有声音认为运行时多态性是唯一真正的多态性，而编译时多态性实际上并不是一种多态性形式。在面试中引发这样的辩论是不建议的。最好是充当调解人，提出事情的两面。我们很快将讨论如何处理这种情况。
- en: What is association?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是关联？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你的答案中应该包含的关键点是：
- en: Association is one of the core concepts of OOP.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联是面向对象编程的核心概念之一。
- en: Association defines the relation between two classes that are independent of
    one another.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联定义了两个相互独立的类之间的关系。
- en: Association has no owner.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联没有所有者。
- en: Association can be one-to-one, one-to-many, many-to-one, and many-to-many.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联可以是一对一、一对多、多对一和多对多。
- en: 'Now, we can present an answer as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以给出如下答案：
- en: '*Association is one of the core concepts of OOP. The association goal is to
    define the relation between two classes independent of one another* and is also
    referenced as the multiplicity relation between objects. *There is no owner of
    the association*. The objects involved in an association can use one another (bidirectional
    association), or only one uses the other one (unidirectional association), but
    they have their own life span. *Association can be unidirectional/bidirectional,
    one-to-one, one-to-many, many-to-one, and many-to-many*. For example, between
    the `Person` and `Address` objects, we may have a bidirectional many-to-many relationship.
    In other words, a person can be associated with multiple addresses, while an address
    can belong to multiple people. However, people can exist without addresses, and
    vice versa.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*关联是面向对象编程的核心概念之一。关联的目标是定义两个类之间独立于彼此的关系*，也被称为对象之间的多重性关系。*没有关联的所有者*。参与关联的对象可以互相使用（双向关联），或者只有一个使用另一个（单向关联），但它们有自己的生命周期。*关联可以是单向/双向，一对一，一对多，多对一和多对多*。例如，在`Person`和`Address`对象之间，我们可能有一个双向多对多的关系。换句话说，一个人可以与多个地址相关联，而一个地址可以属于多个人。然而，人可以存在而没有地址，反之亦然。'
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'The `Person` and `Address` classes are very simple:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`和`Address`类非常简单：'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The association between `Person` and `Address` is accomplished in the `main()`
    method, as shown in the following code block:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`和`Address`之间的关联是在`main()`方法中完成的，如下面的代码块所示：'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is listed as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is named *Association*. Moving on, let's talk about
    aggregation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序被命名为*Association*。接下来，让我们谈谈聚合。
- en: What is aggregation?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是聚合？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的答案中应该包含的关键点如下：
- en: Aggregation is one of the core concepts of OOP.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合是面向对象编程的核心概念之一。
- en: Aggregation is a special case of unidirectional association.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合是单向关联的特殊情况。
- en: Aggregation represents a HAS-A relationship.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合代表一个HAS-A关系。
- en: Two aggregated objects have their own life cycle, but one of the objects is
    the owner of the HAS-A relationship.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个聚合对象有各自的生命周期，但其中一个对象是HAS-A关系的所有者。
- en: 'Now, we can present an answer as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样呈现一个答案：
- en: '*Aggregation is one of the core concepts of OOP*. Mainly, aggregation is a
    special case of unidirectional association. While an association defines the relationship
    between two classes independent of one another, *aggregation represents a HAS-A
    relationship between these two classes*. In other words, *two aggregated objects
    have their own life cycle, but one of the objects is the owner of the HAS-A relationship*.
    Having their own life cycle means that ending one object will not affect the other
    object. For example, a `TennisPlayer` has a `Racket`. This is a unidirectional
    association since a `Racket` cannot have a `TennisPlayer`. Even if the `TennisPlayer`
    dies, the `Racket` is not affected.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合是面向对象编程的核心概念之一*。主要是，聚合是单向关联的特殊情况。当一个关联定义了两个类之间独立于彼此的关系时，*聚合代表这两个类之间的HAS-A关系*。换句话说，*两个聚合对象有各自的生命周期，但其中一个对象是HAS-A关系的所有者*。有自己的生命周期意味着结束一个对象不会影响另一个对象。例如，一个`TennisPlayer`有一个`Racket`。这是一个单向关联，因为一个`Racket`不能拥有一个`TennisPlayer`。即使`TennisPlayer`死亡，`Racket`也不会受到影响。'
- en: Important note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that, when we define the notion of aggregation, we also have a statement
    regarding what an association is. Follow this approach whenever two notions are
    tightly related and one of them is a special case of the other one. The same practice
    is applied next for defining composition as a special case of aggregation. The
    interviewer will notice and appreciate that you have an overview of things and
    that you can provide a meaningful answer that didn't overlook the context.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们定义聚合的概念时，我们也对关联有了一个陈述。每当两个概念紧密相关且其中一个是另一个的特殊情况时，都要遵循这种方法。下一步，同样的做法被应用于将组合定义为聚合的特殊情况。面试官会注意到并赞赏你对事物的概览，并且你能够提供一个有意义的答案，没有忽视上下文。
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'We start with the `Rocket` class. This is a simple representation of a tennis
    racket:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Rocket`类开始。这是网球拍的简单表示：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `TennisPlayer` HAS-A `Racket`. Therefore, the `TennisPlayer` class must be
    capable of receiving a `Racket` as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`TennisPlayer`拥有一个`Racket`。因此，`TennisPlayer`类必须能够接收一个`Racket`，如下所示：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we create a `Racket` and a `TennisPlayer` that uses this `Racket`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Racket`和一个使用这个`Racket`的`TennisPlayer`：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete application is named *Aggregation*. Moving on, let's talk about
    composition.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序被命名为*Aggregation*。接下来，让我们谈谈组合。
- en: What is composition?
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是组合？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的答案中应该包含的关键点如下：
- en: Composition is one of the core concepts of OOP.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合是面向对象编程的核心概念之一。
- en: Composition is a more restrictive case of aggregation.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合是聚合的一种更为严格的情况。
- en: Composition represents a HAS-A relationship that contains an object that cannot
    exist on its own.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合代表一个包含一个不能独立存在的对象的HAS-A关系。
- en: Composition sustains code reuse and the visibility control of objects.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合支持对象的代码重用和可见性控制。
- en: 'Now, we can present an answer as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样呈现一个答案：
- en: '*Composition is one of the core concepts of OOP*. *Primarily, composition is
    a more restrictive case of aggregation*. While aggregation represents a HAS-A
    relationship between two objects having their own life cycle, *composition represents
    a HAS-A relationship that contains an object that cannot exist on its own*. In
    order to highlight this coupling, the HAS-A relationship can be named PART-OF
    as well. For example, a `Car` has an `Engine`. In other words, the engine is PART-OF
    the car. If the car is destroyed, then the engine is destroyed as well. Composition
    is said to be better than inheritance because *it sustains code reuse and the
    visibility control of objects*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合是面向对象编程的核心概念之一*。*主要来说，组合是聚合的一种更严格的情况*。聚合表示两个对象之间具有自己的生命周期的HAS-A关系，*组合表示包含一个不能独立存在的对象的HAS-A关系*。为了突出这种耦合，HAS-A关系也可以被称为PART-OF。例如，一个`Car`有一个`Engine`。换句话说，发动机是汽车的一部分。如果汽车被销毁，那么发动机也会被销毁。组合被认为比继承更好，因为*它维护了对象的代码重用和可见性控制*。'
- en: If further details are required, then you may share the screen or use paper
    and a pen and code your example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么你可以分享屏幕或使用纸和笔编写你的例子。
- en: 'The `Engine` class is quite simple:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine`类非常简单：'
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we have the `Car` class. Check out the constructor of this class. Since
    `Engine` is part of `Car`, we create it with the `Car`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`Car`类。查看这个类的构造函数。由于`Engine`是`Car`的一部分，我们用`Car`创建它：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we can test composition from the `main()` method as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以从`main()`方法中测试组合如下：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The complete application is named *Composition***.**
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序被命名为*组合***。**
- en: So far, we have covered the essential questions regarding OOP concepts. Keep
    in mind that such questions can occur in Java technical interviews for almost
    any position that involves coding or architecting applications. Especially if
    you have around 2–4 years of experience, the chances are high that you will be
    asked the preceding questions, and you must know the answers, otherwise this will
    be a black mark against you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了关于面向对象编程概念的基本问题。请记住，这些问题几乎可以在涉及编码或架构应用程序的任何职位的Java技术面试中出现。特别是如果你有大约2-4年的经验，那么你被问到上述问题的机会很高，你必须知道答案，否则这将成为你的一个污点。
- en: Now, let's continue with the SOLID principles. This is another fundamental area
    and a must-know topic alongside the OOP concepts. A lack of knowledge in this
    area will prove detrimental when it comes to a final decision regarding your interview.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论SOLID原则。这是另一个基本领域，与面向对象编程概念并列的必须知道的主题。在这个领域缺乏知识将在最终决定你的面试时证明是有害的。
- en: Getting to know the SOLID principles
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解SOLID原则
- en: 'In this section, we will formulate answers to the questions corresponding to
    the five famous design patterns for writing classes – the SOLID principles. By
    way of a quick remainder, SOLID is an acronym of the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将对与编写类的五个著名设计模式对应的问题进行回答 - SOLID原则。简而言之，SOLID是以下内容的首字母缩写：
- en: '**S**: Single Responsibility Principle'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：单一责任原则'
- en: '**O**: Open Closed Principle'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：开闭原则'
- en: '**L**: Liskov''s Substitution Principle'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：里氏替换原则'
- en: '**I**: Interface Segregation Principle'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：接口隔离原则'
- en: '**D**: Dependency Inversion Principle'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：依赖反转原则'
- en: In interviews, the most common questions pertaining to SOLID are of the *What
    is ...?* type. For example, *What is S?* or *What is D?* Typically, OOP-related
    questions are intentionally vague. This way, the interviewer tests your level
    of knowledge and wants to see whether you request further clarification. So, let's
    tackle each of these questions in turn and provide an awesome answer that will
    impress the interviewer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，与SOLID相关的最常见的问题是*什么是...?*类型的。例如，*S是什么？*或者* D是什么？*通常，与面向对象编程相关的问题是故意模糊的。这样，面试官测试你的知识水平，并希望看到你是否需要进一步的澄清。因此，让我们依次解决这些问题，并提供一个令面试官印象深刻的答案。
- en: What is S?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: S是什么？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中概括的关键点如下：
- en: S stands for the **Single Responsibility Principle** (SRP).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S代表**单一责任原则**（SRP）。
- en: S stands for *One class should have one, and only one, responsibility*.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S代表*一个类应该只有一个责任*。
- en: S tells us to write a class for only one goal.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S告诉我们为了一个目标编写一个类。
- en: S sustains high maintainability and visibility control across the application
    modules.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S维护了整个应用程序模块的高可维护性和可见性控制。
- en: 'Now, we can present an answer as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以给出以下答案：
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *S* is the first principle from SOLID and is known as the **Single Responsibility
    Principle** (**SRP**). *This principle translates to the fact that one class should
    have one, and only one, responsibility*. This is a very important principle that
    should be followed in any type of project for any type of class (model, service,
    controller, manager class, and so on). *As long as we write a class for only one
    goal, we will sustain high maintainability and visibility control across the application
    modules*. In other words, by *sustaining high maintainability*, this principle
    has a significant business impact, and by *providing visibility control across
    the application modules*, this principle sustains encapsulation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SOLID是Robert C. Martin（也被称为Uncle Bob）阐述的前五个**面向对象设计（OOD）**原则的首字母缩写。*S*是SOLID的第一个原则，被称为**单一责任原则**（**SRP**）。*这个原则意味着一个类应该只有一个责任*。这是一个非常重要的原则，应该在任何类型的项目中遵循，无论是任何类型的类（模型、服务、控制器、管理类等）。*只要我们为一个目标编写一个类，我们就能在整个应用程序模块中保持高可维护性和可见性控制*。换句话说，通过*保持高可维护性*，这个原则对业务有重大影响，通过*提供应用程序模块的可见性控制*，这个原则维护了封装性。
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example as the one presented here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，那么你可以分享屏幕或使用纸和笔编写一个像这里呈现的例子一样的例子。
- en: For example, you want to calculate the area of a rectangle. The dimensions of
    the rectangle are initially given in meters and the area is computed in meters
    as well, but we want to be able to convert the computed area to other units, such
    as inches. Let's see the approach that breaks the SRP.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你想计算一个矩形的面积。矩形的尺寸最初以米为单位给出，面积也以米为单位计算，但我们希望能够将计算出的面积转换为其他单位，比如英寸。让我们看一下违反SRP的方法。
- en: Breaking the SRP
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 违反SRP
- en: 'Implementing the preceding problem in a single class, `RectangleAreaCalculator`,
    can be done as follows. But this class does more than one thing: it breaks SRP.
    Keep in mind that, typically, when you use the word **and** to express what a
    class does, this is a sign that the SRP is broken. For example, the following
    class computes the area **and** converts it to inches:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个类“RectangleAreaCalculator”中实现前面的问题可以这样做。但是这个类做了不止一件事：它违反了SRP。请记住，通常当你用“和”这个词来表达一个类做了什么时，这是SRP被违反的迹象。例如，下面的类计算面积并将其转换为英寸：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since this code contravenes the SRP, we must fix it in order to follow the SRP.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码违反了SRP，我们必须修复它以遵循SRP。
- en: Following the SRP
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循SRP
- en: 'The situation can be remedied by removing the `metersToInches()` method from
    `RectangleAreaCalculator`, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从“RectangleAreaCalculator”中删除“metersToInches（）”方法来解决这种情况，如下所示：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, `RectangleAreaCalculator` does only one thing (it computes the rectangle
    area), thereby observing the SRP.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“RectangleAreaCalculator”只做一件事（计算矩形面积），从而遵守SRP。
- en: 'Next, `metersToInches()` can be extracted in a separate class. Moreover, we
    can add a new method for converting from meters to feet as well:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以将“metersToInches（）”提取到一个单独的类中。此外，我们还可以添加一个新的方法来将米转换为英尺：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class also follows the SRP, hence our job is done. The complete application
    is named *SingleResponsabilityPrinciple*. Moving on, let's talk about the second
    SOLID principle, the Open Closed Principle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也遵循了SRP，因此我们的工作完成了。完整的应用程序被命名为“SingleResponsabilityPrinciple”。接下来，让我们谈谈第二个SOLID原则，即开闭原则。
- en: What is O?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: O是什么？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的答案中包含的关键点是：
- en: O stands for the **Open Closed Principle** (OCP).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O代表开闭原则（OCP）。
- en: O stands for *Software components should be open for extension, but closed for
    modification*.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O代表“软件组件应该对扩展开放，但对修改关闭”。
- en: O sustains the fact that our classes should not contain constraints that will
    require other developers to modify our classes in order to accomplish their job
    – other developers should only extend our classes to accomplish their job.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O维持了这样一个事实，即我们的类不应该包含需要其他开发人员修改我们的类才能完成工作的约束条件-其他开发人员应该只能扩展我们的类来完成他们的工作。
- en: O sustains software extensibility in a versatile, intuitive, and non-harmful
    way.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O以一种多才多艺、直观且无害的方式维持软件的可扩展性。
- en: 'Now, we can present an answer as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样回答：
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *O* is the second principle from SOLID and is known as the **Open Closed
    Principle** (OCP). This principle stands for *Software components should be open
    for extension, but closed for modification*. This means that our classes should
    be designed and written in such a way that other developers can change the behavior
    of these classes by simply extending them. So, *our classes should not contain
    constraints that will require other developers to modify our classes in order
    to accomplish their job – other developers should only extend our classes to accomplish
    their job*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SOLID是Robert C. Martin提出的前五个面向对象设计（OOD）原则的首字母缩写，也被称为Uncle Bob（可选短语）。 O是SOLID中的第二个原则，被称为开闭原则（OCP）。这个原则代表“软件组件应该对扩展开放，但对修改关闭”。这意味着我们的类应该被设计和编写成其他开发人员可以通过简单地扩展它们来改变这些类的行为。因此，“我们的类不应该包含需要其他开发人员修改我们的类才能完成工作的约束条件-其他开发人员应该只能扩展我们的类来完成工作”。
- en: While we *must sustain software extensibility in a versatile, intuitive, and
    non-harmful way*, we don't have to think that other developers will want to change
    the whole logic or the core logic of our classes. Primarily, if we follow this
    principle, then our code will act as a good framework that doesn't give us access
    to modify their core logic, but we can modify their flow and/or behavior by extending
    some classes, passing initialization parameters, overriding methods, passing different
    options, and so on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们“必须以一种多才多艺、直观且无害的方式维持软件的可扩展性”，但我们不必认为其他开发人员会想要改变我们的类的整个逻辑或核心逻辑。主要是，如果我们遵循这个原则，那么我们的代码将作为一个良好的框架，不会让我们修改它们的核心逻辑，但我们可以通过扩展一些类、传递初始化参数、重写方法、传递不同的选项等来修改它们的流程和/或行为。
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，那么你可以分享屏幕或使用纸和笔编写一个像这里呈现的例子一样的例子。
- en: Now, for instance, you have different shapes (for example, rectangles, circles)
    and we want to sum their areas. First, let's see the implementation that breaks
    the OCP.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，例如，你有不同的形状（例如矩形、圆）并且我们想要求它们的面积之和。首先，让我们看一下违反OCP的实现。
- en: Breaking the OCP
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 违反OCP
- en: 'Each shape will implement the `Shape` interface. Therefore, the code is pretty
    straightforward:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个形状都将实现“Shape”接口。因此，代码非常简单：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this point, we can easily use the constructors of these classes to create
    rectangles and circles of different sizes. Once we have several shapes, we want
    to sum their areas. For this, we can define an `AreaCalculator` class as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以很容易地使用这些类的构造函数来创建不同尺寸的矩形和圆。一旦我们有了几种形状，我们想要求它们的面积之和。为此，我们可以定义一个“AreaCalculator”类，如下所示：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since each shape has its own formula for area, we require an `if-else` (or `switch`)
    structure to determine the type of shape. Furthermore, if we want to add a new
    shape (for example, a triangle), we have to modify the `AreaCalculator` class
    to add a new `if` case. This means that the preceding code breaks the OCP. Fixing
    this code to observe the OCP imposes several modifications in all classes. Hence,
    be aware that fixing code that doesn't follow the OCP can be quite tricky, even
    in the case of a simple example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种形状都有自己的面积公式，我们需要一个`if-else`（或`switch`）结构来确定形状的类型。此外，如果我们想要添加一个新的形状（例如三角形），我们必须修改`AreaCalculator`类以添加一个新的`if`情况。这意味着前面的代码违反了OCP。修复这段代码以遵守OCP会对所有类进行多处修改。因此，请注意，即使是简单的例子，修复不遵循OCP的代码可能会非常棘手。
- en: Following the OCP
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循OCP
- en: 'The main idea is to extract from `AreaCalculator` the area formula of each
    shape in the corresponding `Shape` class. Hence, the rectangle will compute its
    area, the circle as well, and so on. To enforce the fact that each shape must
    calculate its area, we add the `area()` method to the `Shape` contract:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是从`AreaCalculator`中提取每种形状的面积公式，并将其放入相应的`Shape`类中。因此，矩形将计算其面积，圆形也是如此，依此类推。为了强制每种形状必须计算其面积，我们将`area()`方法添加到`Shape`合同中：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, `Rectangle` and `Circle` implements `Shape` as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Rectangle`和`Circle`实现`Shape`如下：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, the `AreaCalculator` can loop the list of shapes and sum the areas by
    calling the proper `area()` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`AreaCalculator`可以循环遍历形状列表，并通过调用适当的`area()`方法来计算面积。
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code is OCP-compliant. We can add a new shape and there is no need to modify
    the `AreaCalculator`. So, `AreaCalculator` is closed for modifications and, of
    course, is open for extension. The complete application is named the *OpenClosedPrinciple*.
    Moving on, let's talk about the third SOLID principle, Liskov's Substitution Principle.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 代码符合OCP。我们可以添加一个新的形状，而不需要修改`AreaCalculator`。因此，`AreaCalculator`对于修改是封闭的，当然，对于扩展是开放的。完整的应用程序被命名为*开闭原则*。接下来，让我们谈谈第三个SOLID原则，Liskov替换原则。
- en: What is L?
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是L？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的答案中封装以下关键点：
- en: L stands for **Liskov's Substitution Principle** **(LSP)**.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L代表**Liskov替换原则** **（LSP）**。
- en: L stands for *Derived types must be completely substitutable for their base
    types*.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L代表*派生类型必须完全可替换其基类型*。
- en: L sustains the fact that objects of subclasses must behave in the same way as
    the objects of superclasses.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L支持子类的对象必须与超类的对象以相同的方式行为。
- en: L is useful for runtime-type identification followed by the cast.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L对于运行时类型识别后跟随转换是有用的。
- en: 'Now, we can present an answer as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以如下呈现一个答案：
- en: First of all, SOLID is an acronym for the first five `foo(p)`, where `p` is
    of the type `T`. Then, `foo(q)` should work fine if `q` is of the type `S` and
    `S` is a subtype of `T`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SOLID是前五个`foo(p)`的首字母缩写，其中`p`是类型`T`。然后，如果`q`是类型`S`，并且`S`是`T`的子类型，那么`foo(q)`应该正常工作。
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么您可以共享屏幕或使用纸张和笔来编写一个像这里呈现的例子一样的例子。
- en: 'We have a chess club that accepts three types of members: Premium, VIP, and
    Free. We have an abstract class named `Member` that acts as the base class, and
    three subclasses – `PremiumMember`, `VipMember`, and `FreeMember`. Let''s see
    whether each of these member types can substitute the base class.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个接受三种类型会员的国际象棋俱乐部：高级会员、VIP会员和免费会员。我们有一个名为`Member`的抽象类，它充当基类，以及三个子类-`PremiumMember`、`VipMember`和`FreeMember`。让我们看看这些会员类型是否可以替代基类。
- en: Breaking the LSP
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 违反LSP
- en: 'The `Member` class is abstract, and it represents the base class for all members
    of our chess club:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Member`类是抽象的，它代表了我们国际象棋俱乐部所有成员的基类。'
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `PremiumMember` class can join chess tournaments or organize such tournaments
    as well. So, its implementation is quite simple:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`PremiumMember`类可以加入国际象棋比赛，也可以组织这样的比赛。因此，它的实现非常简单。'
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `VipMember` class is roughly the same as `PremiumMember`, so we can skip
    it and focus on the `FreeMember` class. The `FreeMember` class can join tournaments,
    but cannot organize tournaments. This is an issue that we need to tackle in the
    `organizeTournament()` method. We can throw an exception with a meaningful message
    or we can display a message as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`VipMember`类与`PremiumMember`类大致相同，因此我们可以跳过它，专注于`FreeMember`类。`FreeMember`类可以参加比赛，但不能组织比赛。这是我们需要在`organizeTournament()`方法中解决的问题。我们可以抛出一个带有有意义消息的异常，或者我们可以显示一条消息，如下所示：'
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But throwing an exception or displaying a message doesn''t mean that we follow
    LSP. Since a free member cannot organize tournaments, it cannot be a substitute
    for the base class, therefore it breaks the LSP. Check out the following list
    of members:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但是抛出异常或显示消息并不意味着我们遵循LSP。由于免费会员无法组织比赛，因此它不能替代基类，因此它违反了LSP。请查看以下会员列表：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following loop reveals that our code is not LSP-compliant because when
    the `FreeMember` class has to substitute the `Member` class, it cannot accomplish
    its job since `FreeMember` cannot organize chess tournaments:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环显示了我们的代码不符合LSP，因为当`FreeMember`类必须替换`Member`类时，它无法完成其工作，因为`FreeMember`无法组织国际象棋比赛。
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This situation is a showstopper. We cannot continue the implementation of our
    application. We must redesign our solution to obtain a code that is LSP-compliant.
    So let's do this!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是一个停滞不前的问题。我们无法继续实现我们的应用程序。我们必须重新设计我们的解决方案，以获得符合LSP的代码。所以让我们这样做！
- en: Following the LSP
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循LSP
- en: 'The refactoring process starts by defining two interfaces meant to separate
    the two actions, joining and organizing chess tournaments:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重构过程从定义两个接口开始，这两个接口用于分离两个操作，即加入和组织国际象棋比赛：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, the abstract base class implements these two interfaces as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，抽象基类实现这两个接口如下：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`PremiumMember` and `VipMember` remain untouched. They extend the `Member`
    base class. However, the `FreeMember` class, which cannot organize tournaments,
    will not extend the `Member` base class. It will implement the `TournamentJoiner`
    interface only:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`PremiumMember`和`VipMember`保持不变。它们扩展了`Member`基类。然而，`FreeMember`类不能组织比赛，因此不会扩展`Member`基类。它只会实现`TournamentJoiner`接口：'
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can define a list of members who can join chess tournaments as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个能够参加国际象棋比赛的成员列表如下：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Looping this list and substituting the `TournamentJoiner` interface with each
    type of member works as expected and observes the LSP:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 循环此列表，并用每种类型的成员替换`TournamentJoiner`接口，可以正常工作并遵守LSP：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Following the same logic, a list of members who can organize chess tournaments
    can be written as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑，可以将能够组织国际象棋比赛的成员列表编写如下：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`FreeMember` doesn''t implement the `TournamentOrganizer` interface. Therefore,
    it cannot be added to this list. Looping this list and substituting the `TournamentOrganizer`
    interface with each type of member works as expected and follows the LSP:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`FreeMember`没有实现`TournamentOrganizer`接口。因此，它不能添加到此列表中。循环此列表，并用每种类型的成员替换`TournamentOrganizer`接口可以正常工作并遵守LSP：'
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Done! Now we have an LSP-compliant code. The complete application is named *LiskovSubstitutionPrinciple*.
    Moving on, let's talk about the fourth SOLID principle, the Interface Segregation
    Principle.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在我们有一个符合LSP的代码。完整的应用程序命名为*LiskovSubstitutionPrinciple*。接下来，让我们谈谈第四个SOLID原则，接口隔离原则。
- en: What is I?
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是I？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在答案中封装的关键点如下：
- en: I stands for the **Interface Segregation Principle** (**ISP**).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I代表**接口隔离原则**（ISP）。
- en: I stands for *Clients should not be forced to implement unnecessary methods
    that they will not use*.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I代表*客户端不应被强制实现他们不会使用的不必要的方法*。
- en: I splits an interface into two or more interfaces until clients are not forced
    to implement methods that they will not use.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将一个接口分割成两个或更多个接口，直到客户端不被强制实现他们不会使用的方法。
- en: 'Now, we can present an answer as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以如下呈现一个答案：
- en: 'First of all, SOLID is an acronym for the first five `Connection` interface,
    which has three methods: `connect()`, `socket()`, and `http()`. A client may want
    to implement this interface only for connections via HTTP. Therefore, they don''t
    need the `socket()` method. Most of the time, the client will leave this method
    empty, and this is a bad design. In order to avoid such situations, simply split
    the `Connection` interface into two interfaces; `SocketConnection` with the `socket()`
    method, and `HttpConnection` with the `http()` method. Both interfaces will extend
    the `Connection` interface that remains with the common method, `connect()`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SOLID是前五个`Connection`接口的首字母缩写，它有三种方法：`connect()`，`socket()`和`http()`。客户端可能只想为通过HTTP的连接实现此接口。因此，他们不需要`socket()`方法。大多数情况下，客户端会将此方法留空，这是一个糟糕的设计。为了避免这种情况，只需将`Connection`接口拆分为两个接口；`SocketConnection`具有`socket()`方法，`HttpConnection`具有`http()`方法。这两个接口将扩展保留有共同方法`connect()`的`Connection`接口。
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example like the one presented here. Since we've described
    the preceding example, let's jump into the section about breaking the ISP.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的细节，那么您可以共享屏幕或使用纸和笔编写一个像这里呈现的示例。由于我们已经描述了前面的例子，让我们跳到关于违反ISP的部分。
- en: Breaking the ISP
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 违反ISP
- en: 'The `Connection` interface defines three methods as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection`接口定义了三种方法如下：'
- en: '[PRE49]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`WwwPingConnection` is a class that pings different websites via HTTP; hence,
    it requires the `http()` method, but doesn''t need the `socket()` method. Notice
    the dummy `socket()` implementation – since `WwwPingConnection` implements `Connection`,
    it is forced to provide an implementation to the `socket()` method as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`WwwPingConnection`是一个通过HTTP对不同网站进行ping的类；因此，它需要`http()`方法，但不需要`socket()`方法。请注意虚拟的`socket()`实现-由于`WwwPingConnection`实现了`Connection`，它被强制提供`socket()`方法的实现：'
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Having an empty implementation or throwing a meaningful exception from methods
    that are not needed, such as `socket()`, is a really ugly solution. Check the
    following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要的方法中具有空实现或抛出有意义的异常，比如`socket()`，是一个非常丑陋的解决方案。检查以下代码：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'What do we expect to obtain from this code? A working code that does nothing,
    or an exception caused by the `connect()` method because there is no HTTP endpoint?
    Or, we can throw an exception from `socket()` of the type: *Socket is not supported!*.
    Then, why is it here?! Hence, it is now time to refactor the code to follow the
    ISP.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望从这段代码中获得什么？一个什么都不做的工作代码，或者由于没有HTTP端点而导致`connect()`方法引发的异常？或者，我们可以从`socket()`中抛出类型为*Socket
    is not supported!*的异常。那么，它为什么在这里？！因此，现在是时候重构代码以遵循ISP了。
- en: Following the ISP
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循ISP
- en: 'In order to comply with the ISP, we need to segregate the `Connection` interface.
    Since the `connect()` method is required by any client, we leave it in this interface:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵守ISP，我们需要分隔`Connection`接口。由于任何客户端都需要`connect()`方法，我们将其留在这个接口中：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `http()` and `socket()` methods are distributed in to separate interfaces
    that extend the `Connection` interface as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`http()`和`socket()`方法分布在扩展`Connection`接口的两个单独的接口中，如下所示：'
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This time, the `WwwPingConnection` class can implement only the `HttpConnection`
    interface and use the `http()` method:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`WwwPingConnection`类只能实现`HttpConnection`接口并使用`http()`方法：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Done! Now, the code follows the ISP. The complete application is named *InterfaceSegregationPrinciple*.
    Moving on, let's talk about the last SOLID principle, the Dependency Inversion
    Principle.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，代码遵循ISP。完整的应用程序命名为*InterfaceSegregationPrinciple*。接下来，让我们谈谈最后一个SOLID原则，依赖倒置原则。
- en: What is D?
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是D？
- en: 'The key points that you should encapsulate in your answer are the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在答案中封装的关键点如下：
- en: '*D* stands for the **Dependency Inversion Principle** **(DIP)**.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*代表**依赖倒置原则**（DIP）。'
- en: '*D* stands for *Depend on abstractions, not on concretions*.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*代表*依赖于抽象，而不是具体实现*。'
- en: '*D* sustains the use of abstract layers to bind concrete modules together instead
    of having concrete modules that depend on other concrete modules.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*支持使用抽象层来绑定具体模块，而不是依赖于其他具体模块。'
- en: '*D* sustains the decoupling of concrete modules.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*维持了具体模块的解耦。'
- en: 'Now, we can present an answer as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以提出一个答案如下：
- en: First of all, SOLID is an acronym for the first five **Object-Oriented Design**
    **(OOD)** principles enunciated by Robert C. Martin, also known as Uncle Bob (*optional
    phrase*). *D* is the last principle from SOLID and is known as the **Dependency
    Inversion Principle****(DIP)**. This principle stands for *Depend on abstractions,
    not on concretions*. This means that we should *rely on abstract layers to bind
    concrete modules together instead of having concrete modules that depend on other
    concrete modules*. To accomplish this, all concrete modules should expose abstractions
    only. This way, the concrete modules allow extension of the functionality or plug-in
    in another concrete module while retaining the decoupling of concrete modules.
    Commonly, high coupling occurs between high-level concrete modules and low-level
    concrete modules.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SOLID是Robert C. Martin提出的前五个**面向对象设计**（OOD）原则的首字母缩写，也被称为Uncle Bob（*可选短语*）。*D*是SOLID原则中的最后一个原则，被称为**依赖倒置原则**（DIP）。这个原则代表*依赖于抽象，而不是具体实现*。这意味着我们应该*依赖于抽象层来绑定具体模块，而不是依赖于具体模块*。为了实现这一点，所有具体模块应该只暴露抽象。这样，具体模块允许扩展功能或在另一个具体模块中插入，同时保持具体模块的解耦。通常，高级具体模块和低级具体模块之间存在高耦合。
- en: If further details are required, then you may share the screen or use paper
    and a pen to code an example.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，你可以分享屏幕或使用纸和笔编写一个例子。
- en: A database JDBC URL, `PostgreSQLJdbcUrl`, can be a low-level module, while a
    class that connects to the database may represent a high-level module, such as
    `ConnectToDatabase#connect()`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库JDBC URL，`PostgreSQLJdbcUrl`，可以是一个低级模块，而连接到数据库的类可能代表一个高级模块，比如`ConnectToDatabase#connect()`。
- en: Breaking the DIP
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打破DIP
- en: 'If we pass to the `connect()` method an argument of the `PostgreSQLJdbcUrl`
    type, then we have violated the DIP. Let''s look at the code of `PostgreSQLJdbcUrl`
    and `ConnectToDatabase`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`connect()`方法传递`PostgreSQLJdbcUrl`类型的参数，那么我们就违反了DIP。让我们来看看`PostgreSQLJdbcUrl`和`ConnectToDatabase`的代码：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we create another type of JDBC URL (for example, `MySQLJdbcUrl`), then we
    cannot use the preceding `connect(PostgreSQLJdbcUrl postgreSQL)` method. So, we
    have to drop this dependency on concrete and create a dependency on abstraction.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建另一种类型的JDBC URL（例如`MySQLJdbcUrl`），那么我们就不能使用之前的`connect(PostgreSQLJdbcUrl
    postgreSQL)`方法。因此，我们必须放弃对具体的依赖，创建对抽象的依赖。
- en: Following the DIP
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循DIP
- en: 'The abstraction can be represented by an interface that should be implemented
    by each type of JDBC URL:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以由一个接口表示，每种类型的JDBC URL都应该实现该接口：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, `PostgreSQLJdbcUrl` implements `JdbcUrl` to return a JDBC URL specific
    to PostgreSQL databases:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`PostgreSQLJdbcUrl`实现了`JdbcUrl`以返回特定于PostgreSQL数据库的JDBC URL：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In precisely the same manner, we can write `MySQLJdbcUrl`, `OracleJdbcUrl`,
    and so on. Finally, the `ConnectToDatabase#connect()` method is dependent on the
    `JdbcUrl` abstraction, so it can connect to any JDBC URL that implements this
    abstraction:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以完全相同的方式，我们可以编写`MySQLJdbcUrl`、`OracleJdbcUrl`等。最后，`ConnectToDatabase#connect()`方法依赖于`JdbcUrl`抽象，因此它可以连接到实现了这个抽象的任何JDBC
    URL：
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Done! The complete application is named *DependencyInversionPrinciple*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序命名为*DependencyInversionPrinciple*。
- en: So far, we've covered the OOP fundamental concepts and the popular SOLID principles.
    If you plan to apply for a Java position that includes the design and architecture
    of applications, then it is recommended that you take a look at the **General
    Responsibility Assignment Software Principles** **(GRASP)** as well ([https://en.wikipedia.org/wiki/GRASP_(object-oriented_design](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)).
    This is not a popular topic in interviews, but you never know!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了OOP的基本概念和流行的SOLID原则。如果你计划申请一个包括应用程序设计和架构的Java职位，那么建议你看看**通用责任分配软件原则**（GRASP）（[https://en.wikipedia.org/wiki/GRASP_(object-oriented_design](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)）。这在面试中并不是一个常见的话题，但你永远不知道！
- en: Moving on, we will scan a bunch of popular questions that combine these notions.
    Now that you are familiar with the **Understand the Question** | **Nominate key
    points | Answer** technique, I will only highlight the key points in the answer
    without extracting them as a list beforehand.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扫描一系列结合了这些概念的热门问题。现在你已经熟悉了**理解问题** | **提名关键点** | **回答**的技巧，我将只突出回答中的关键点，而不是事先提取它们作为一个列表。
- en: Popular questions pertaining to OOP, SOLID, and GOF design patterns
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与OOP、SOLID和GOF设计模式相关的热门问题
- en: In this section, we will tackle some more difficult questions that require a
    true understanding of OOP concepts, SOLID design principles, and **Gang of Four**
    **(GOF)** design patterns. Note that this book doesn't cover GOF design patterns,
    but there are great books and videos out there that are dedicated to this topic.
    I recommend that you try *Learn Design Patterns with Java*, by Aseem Jain ([https://www.packtpub.com/application-development/learn-design-patterns-java-video](https://www.packtpub.com/application-development/learn-design-patterns-java-video)).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将解决一些更难的问题，这些问题需要对OOP概念、SOLID设计原则和**四人帮**（GOF）设计模式有真正的理解。请注意，本书不涵盖GOF设计模式，但有很多专门讨论这个主题的优秀书籍和视频。我建议你尝试Aseem
    Jain的《用Java学习设计模式》（[https://www.packtpub.com/application-development/learn-design-patterns-java-video](https://www.packtpub.com/application-development/learn-design-patterns-java-video)）。
- en: What is method overriding in OOP (Java)?
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（Java）中的方法重写是什么？
- en: '*Method overriding is an object-oriented programming technique that allows
    the developer to write two methods (***non-static, non-private and non-final***)
    with the same name and signature but different behavior.* Method overriding can
    be used in the presence of **Inheritance** or **Runtime Polymorphism**.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重写是一种面向对象的编程技术，允许开发人员编写两个具有相同名称和签名但具有不同行为的方法（非静态，非私有和非最终）。在**继承**或**运行时多态**的情况下，可以使用方法重写。
- en: In the presence of inheritance, we have a method in the superclass (referenced
    as the overridden method) and we override it in the subclass (referenced as the
    overriding method). In Runtime Polymorphism, we have a method in an interface
    and the classes that implements this interface are overriding this method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承的情况下，我们在超类中有一个方法（称为被重写方法），并且我们在子类中重写它（称为重写方法）。在运行时多态中，我们在一个接口中有一个方法，实现这个接口的类正在重写这个方法。
- en: '*Java decides at runtime the actual method that should be called, depending
    upon the type of object*. Method overriding sustains flexible and extensible code,
    or, in other words, *it sustains the addition of new functionality with minimal
    code changes*.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Java在运行时决定应该调用的实际方法，取决于对象的类型。方法重写支持灵活和可扩展的代码，换句话说，它支持以最小的代码更改添加新功能。
- en: 'If further details are required, then you can list the main rules that govern
    method overriding:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，那么可以列出管理方法重写的主要规则：
- en: The name and signature (including the same return type or subtype) of the method
    is the same in the superclass and subclass, or in the interface and implementations.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的名称和签名（包括相同的返回类型或子类型）在超类和子类中，或在接口和实现中是相同的。
- en: We cannot override a method in the same class (but we can overload it in the
    same class).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在同一个类中重写一个方法（但我们可以在同一个类中重载它）。
- en: We cannot override `private`, `static`, and `final` methods.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能重写`private`，`static`和`final`方法。
- en: The overriding method cannot reduce the accessibility of the overridden method,
    but the opposite is possible.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法不能降低被重写方法的可访问性，但相反是可能的。
- en: The overriding method cannot throw checked exceptions that are higher in the
    exception hierarchy than the checked exception thrown by the overridden method.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法不能抛出比被重写方法抛出的检查异常更高的检查异常。
- en: Always use the `@Override` annotation for the overriding method.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终为重写方法使用`@Override`注解。
- en: An example of overriding methods in Java is available in the code bundled to
    this book under the name *MethodOverriding*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Java中重写方法的示例可在本书附带的代码中找到，名称为MethodOverriding。
- en: What is method overloading in OOP (Java)?
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在面向对象编程（Java）中，什么是方法重载？
- en: '*Method overloading is an object-oriented programming technique that allows
    the developer to write two methods (both static or non-static) with the same name,
    but a different signature and different functionalities*. By different signature,
    we understand a different number of arguments, different types of arguments, and/or
    a different order of arguments list. *The return type is not part of the method
    signature*. Therefore, the case when two methods have identical signatures, but
    different return types, is not a valid case of method overloading. So, this is
    a powerful technique that allows us to write methods (both static or non-static)
    having the same name but with different inputs. The *compiler bind overloaded
    method calls to the actual method; therefore, no binding is done during runtime*.
    A famous example of method overloading is `System.out.println()`. The `println()`
    method has several overloading flavors.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载是一种面向对象的编程技术，允许开发人员编写两个具有相同名称但不同签名和不同功能的方法（静态或非静态）。通过不同的签名，我们理解为不同数量的参数，不同类型的参数和/或参数列表的不同顺序。返回类型不是方法签名的一部分。因此，当两个方法具有相同的签名但不同的返回类型时，这不是方法重载的有效情况。因此，这是一种强大的技术，允许我们编写具有相同名称但具有不同输入的方法（静态或非静态）。编译器将重载的方法调用绑定到实际方法；因此，在运行时不进行绑定。方法重载的一个著名例子是`System.out.println()`。`println()`方法有几种重载的版本。
- en: 'Hence, there are four main rules that govern method overloading:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有四条主要规则来管理方法重载：
- en: Overloading is accomplished by changing the method signature.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改方法签名来实现重载。
- en: The return type is not part of the method signature.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型不是方法签名的一部分。
- en: We can overload `private`, `static`, and `final` methods.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重载`private`，`static`和`final`方法。
- en: We can overload a method in the same class (but we cannot override it in the
    same class).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在同一个类中重载一个方法（但不能在同一个类中重写它）。
- en: If further details are required, you can try to code an example. An example
    of overloading methods in Java is available in the code bundled to this book under
    the name *MethodOverloading*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，可以尝试编写一个示例。Java中重载方法的示例可在本书附带的代码中找到，名称为MethodOverloading。
- en: Important note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Besides the two aforementioned questions, you may need to answer some other
    related questions, including *What rules govern method overloading and overriding*
    (see above)?, *What are the main differences between method overloading and overriding*
    (see above)?, *Can we override a static or a private method* (the short answer
    is *No*, see above)?, *Can we override a final method* (the short answer is *No*,
    see above)?, *Can we overload a static method* (the short answer is *Yes*, see
    above)?, *Can we change the argument list of an overriding method* (the short
    answer is *No*, see above)? So, it is advisable to extract and prepare the answers
    to such questions. All the information required is available in the preceding
    section. Also, pay attention to questions such as *Is it true that we can only
    prevent overriding a method via the final modifier*? This type of wording is meant
    to confuse the candidate because the answer requires an overview of the notion
    involved. The answer here can be formulated as *This is not true, because we can
    prevent overriding a method by marking it as private or static as well. Such methods
    cannot be overridden*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的两个问题，您可能需要回答一些其他相关的问题，包括*什么规则管理方法的重载和重写*（见上文）？*方法重载和重写的主要区别是什么*（见上文）？*我们可以重写静态或私有方法吗*（简短的答案是*不可以*，见上文）？*我们可以重写final方法吗*（简短的答案是*不可以*，见上文）？*我们可以重载静态方法吗*（简短的答案是*可以*，见上文）？*我们可以改变重写方法的参数列表吗*（简短的答案是*不可以*，见上文）？因此，建议提取和准备这些问题的答案。所有所需的信息都可以在前面的部分找到。此外，注意诸如*只有通过final修饰符才能防止重写方法*这样的问题。这种措辞旨在混淆候选人，因为答案需要概述所涉及的概念。这里的答案可以表述为*这是不正确的，因为我们也可以通过将其标记为私有或静态来防止重写方法。这样的方法不能被重写*。
- en: Moving on, let's examine several other questions related to overriding and overloading
    methods.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查几个与重写和重载方法相关的其他问题。
- en: What is covariant method overriding in Java?
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中，协变方法重写是什么？
- en: Covariant method overriding is a less known feature introduced in Java 5\. By
    means of this feature, *an overriding method can return a subtype of its actual
    return type.* This means that a client of the overriding method doesn't need an
    explicit type casting of the returned type. For example, the Java `clone()` method
    returns `Object`. This means that, when we override this method to return a clone,
    we get back an `Object` that must be explicitly casted to the actual subclass
    of `Object` that we need. However, if we take advantage of the Java 5 covariant
    method overriding feature, then the overriding `clone()` method can return the
    requisite subclass directly instead of `Object`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 协变方法重写是Java 5引入的一个不太知名的特性。通过这个特性，*重写方法可以返回其实际返回类型的子类型*。这意味着重写方法的客户端不需要对返回类型进行显式类型转换。例如，Java的`clone()`方法返回`Object`。这意味着，当我们重写这个方法返回一个克隆时，我们得到一个`Object`，必须显式转换为我们需要的`Object`的实际子类。然而，如果我们利用Java
    5的协变方法重写特性，那么重写的`clone()`方法可以直接返回所需的子类，而不是`Object`。
- en: 'Almost always, a question such as this requires an example as part of the answer,
    so let''s consider the `Rectangle` class that implements the `Cloneable` interface.
    The `clone()` method can return `Rectangle` instead of `Object` as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，这样的问题需要一个示例作为答案的一部分，因此让我们考虑实现`Cloneable`接口的`Rectangle`类。`clone()`方法可以返回`Rectangle`而不是`Object`，如下所示：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Calling the `clone()` method doesn''t require an explicit cast:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`clone()`方法不需要显式转换：
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The complete application is named *CovariantMethodOverriding*. Pay attention
    to less direct questions regarding covariant method overriding. For example, it
    can be formulated like this: *Can we modify the return type of method to subclass
    while overriding?* The answer to this question is the same as *What is covariant
    method overriding in Java?*, discussed here.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*CovariantMethodOverriding*。注意一些关于协变方法重写的间接问题。例如，可以这样表述：*我们可以在重写时修改方法的返回类型为子类吗？*
    对于这个问题的答案与*Java中的协变方法重写是什么？*相同，在这里讨论过。
- en: Important note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Knowing the answer to questions that target less known features of Java can
    be a big plus at the interview. This demonstrates to the interviewer that you
    have a deep level of knowledge and that you are up to date with the Java evolution.
    If you require a supersonic update of all JDK 8 to JDK 13 features via tons of
    examples and minimum theory, then you will love my book entitled *Java Coding
    Problems*, published by Packt ([packtpub.com/au/programming/java-coding-problems](https://www.packtpub.com/product/java-coding-problems/9781789801415)).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 了解针对Java的一些不太知名特性的问题的答案可能是面试中的一个重要加分项。这向面试官表明您具有深入的知识水平，并且您对Java的发展了如指掌。如果您需要通过大量示例和最少理论来快速了解所有JDK
    8到JDK 13的功能，那么您一定会喜欢我出版的名为*Java编程问题*的书，由Packt出版（[packtpub.com/au/programming/java-coding-problems](https://www.packtpub.com/product/java-coding-problems/9781789801415)）。
- en: What are the main restrictions in terms of working with exceptions in overriding
    and overloading methods?
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在重写和重载方法方面，主要的限制是什么？
- en: First, let's discuss the overriding methods. *If we talk about unchecked exceptions,
    then we must say that there are no restrictions on using them in overriding methods*.
    Such methods can throw an unchecked exception, hence, any `RuntimeException`.
    On the other hand, *in the case of checked exceptions, the overriding methods
    can throw only the checked exception of the overridden method or a subclass of
    that checked exception*. In other words, an overriding method cannot throw a checked
    exception that has a broader scope than the checked exception thrown by the overridden
    method. For example, if the overridden method throws `SQLException`, then the
    overriding method can throw subclasses such as `BatchUpdateException`, but it
    cannot throw super classes such as `Exception`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论重写方法。*如果我们谈论未经检查的异常，那么我们必须说在重写方法中使用它们没有限制*。这样的方法可以抛出未经检查的异常，因此任何`RuntimeException`。另一方面，*在检查异常的情况下，重写方法只能抛出被重写方法的检查异常或该检查异常的子类*。换句话说，重写方法不能抛出比被重写方法抛出的检查异常范围更广的检查异常。例如，如果被重写的方法抛出`SQLException`，那么重写方法可以抛出子类，如`BatchUpdateException`，但不能抛出超类，如`Exception`。
- en: Second, let's discuss the overloading methods. *Such methods do not impose any
    kind of restrictions*. This means that we can modify the `throw` clause as required.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们讨论重载方法。*这样的方法不会施加任何限制*。这意味着我们可以根据需要修改`throw`子句。
- en: Important note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Pay attention to questions that are worded along the lines of *What are the
    main ...?, Can you enumerate the certain ...?, Can you nominate the...?, Can you
    highlight the ...?*, and so on. Commonly, when the question contains words such
    as *main, certain, nominate,* and *highlight*, the interviewer expects a clear
    and concise answer that should sound like a bullet list. The best practice for
    answering such questions is to jump into the response directly and enumerate each
    item as a compressed and meaningful statement. Don't make the common mistake of
    embarking on a story or dissertation of the notions involved before giving the
    expected answer. The interviewer wants to see your ability to synthesize and sanitize
    things and extract the essence while checking your level of knowledge.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些以*主要是什么...？你能列举某些...吗？你能提名...吗？你能强调...吗？*等方式措辞的问题。通常，当问题包含*主要，某些，提名*和*强调*等词时，面试官期望得到一个清晰简洁的答案，应该听起来像一个项目列表。回答这类问题的最佳实践是直接进入回答并将每个项目列举为一个简洁而有意义的陈述。在给出预期答案之前，不要犯常见错误，即着手讲述所涉及的概念的故事或论文。面试官希望看到你的综合和整理能力，并在检查你的知识水平的同时提取本质。
- en: If more detail is required, then you can code an example like those from the
    code bundled to this book. Consider checking the *OverridingException* and *OverloadingException*
    applications. Now, let's continue with some more questions.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，那么你可以编写一个示例，就像这本书中捆绑的代码一样。考虑检查*OverridingException*和*OverloadingException*应用程序。现在，让我们继续看一些更多的问题。
- en: How can the superclass overridden method be called from the subclass overriding
    method?
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何从子类重写的方法中调用超类重写的方法？
- en: '*We can call the superclass overridden method from the subclass overriding
    method via the Java* `super` *keyword*. For example, consider a superclass, `A`,
    that contains a method, `foo()`, and a subclass of `A` named `B`. If we override
    the `foo()` method in subclass `B`, and we call `super.foo()` from the overriding
    method, `B#foo()`, then we call the overridden method, `A#foo()`.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以通过Java的* `super` *关键字从子类重写的方法中调用超类重写的方法*。例如，考虑一个包含方法`foo()`的超类`A`，以及一个名为`B`的`A`子类。如果我们在子类`B`中重写`foo()`方法，并且我们从重写方法`B#foo()`中调用`super.foo()`，那么我们调用被重写的方法`A#foo()`。'
- en: Can we override or overload the main() method?
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能重写或重载main()方法吗？
- en: We must keep in mind that the `main()` method is static. This means that we
    can overload it. However, we cannot override it because the static methods are
    resolved at compile time, while the methods that we can override are resolved
    at runtime depending upon the type of object.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住`main()`方法是静态的。这意味着我们可以对其进行重载。但是，我们不能对其进行重写，因为静态方法在编译时解析，而我们可以重写的方法在运行时根据对象类型解析。
- en: Can we override a non-static method as static in Java?
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能将非静态方法重写为静态方法吗？
- en: No. *We cannot override a non-static method as static*. Moreover, the reverse
    is not possible either. Both lead to compilation errors.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 不。*我们不能将非静态方法重写为静态方法*。此外，反之亦然也不可能。两者都会导致编译错误。
- en: Important note
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Questions that are to the point, like the last two aforementioned questions,
    deserve a short and concise answer. Interviewers trigger such flashlight questions
    to measure your ability to analyze a situation and make a decision. Mainly, the
    answer is brief, but you need some time to say *Yes* or *No*. Such questions don't
    carry a high score, but they may have a significant negative impact if you don't
    know the answer. If you know the answer, the interviewer might say in his mind,
    *Well, OK, this was an easy question anyway!* But, if you don't know the answer,
    then he might say, *He missed an easy one! There is a serious shortcoming in her/his
    basic knowledge.*
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面提到的最后两个问题一样直截了当的问题，值得一个简短而简洁的答案。面试官触发这样的闪光灯问题来衡量你分析情况并做出决定的能力。主要是，答案是简短的，但你需要一些时间来说*是*或*否*。这类问题并不具有很高的分数，但如果你不知道答案，可能会产生重大的负面影响。如果你知道答案，面试官可能会在心里说*好吧，这本来就是一个容易的问题！*但是，如果你不知道答案，他可能会说*他错过了一个简单的问题！她/他的基础知识有严重缺陷*。
- en: Next, let's look at some more questions related to other OOP concepts.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一些与其他面向对象编程概念相关的更多问题。
- en: Can we have a non-abstract method inside a Java interface?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能在Java接口中有一个非抽象方法吗？
- en: '*Until Java 8, we could not have a non-abstract method in a Java interface*.
    All methods from an interface were implicitly public and abstract. However, starting
    with Java 8, we have new types of methods that can be added to an interface. *In
    practical terms, starting with Java 8, we can add methods that have implementations
    directly in interfaces. This can be done by using the* `default` *and* `static`
    *keywords. The* `default` *keyword was introduced in Java 8 for including in interfaces
    the methods known as*`static` *methods in interfaces are quite similar to the
    default methods, the only difference being that we cannot override* `static` *methods
    in the classes that implement these interfaces*. Since `static` methods are not
    bound to an object, they can be called by using the interface name preceded by
    a dot and the method name. Moreover, `static` methods can be called within other
    `default` and `static` methods.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*直到Java 8，我们不能在Java接口中有非抽象方法*。接口中的所有方法都是隐式公共和抽象的。然而，从Java 8开始，我们可以向接口添加新类型的方法。*从实际角度来看，从Java
    8开始，我们可以直接在接口中添加具体实现的方法。这可以通过使用* `default` *和* `static` *关键字来实现。* `default` *关键字是在Java
    8中引入的，用于在接口中包含称为* `static` *方法的方法，接口中的* `static` *方法与默认方法非常相似，唯一的区别是我们不能在实现这些接口的类中重写*
    `static` *方法*。由于`static`方法不绑定到对象，因此可以通过使用接口名称加上点和方法名称来调用它们。此外，`static`方法可以在其他`default`和`static`方法中调用。'
- en: 'If further details are required, then you can try to code an example. Consider
    that we have an interface for shaping a vehicle like a steam car (this is an old
    car type exactly like old code):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，那么您可以尝试编写一个示例。考虑到我们有一个用于塑造蒸汽车辆的接口（这是一种旧的汽车类型，与旧代码完全相同）：
- en: '[PRE61]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Obviously, different kinds of steam cars have been built by means of the following
    `SteamCar` class:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过以下“SteamCar”类已经建造了不同种类的蒸汽车：
- en: '[PRE62]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Since the `SteamCar` class implements the `Vehicle` interface, it overrides
    the `speedUp()` and `slowDown()` methods. After a while, petrol cars are invented,
    and people start to care about horsepower and fuel consumption. So, our code must
    evolve to provide support for petrol cars as well. To compute the level of consumption,
    we can evolve the `Vehicle` interface by adding the `computeConsumption()` default
    method as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“SteamCar”类实现了“Vehicle”接口，它重写了“speedUp()”和“slowDown()”方法。过了一段时间，汽油车被发明出来，人们开始关心马力和燃油消耗。因此，我们的代码必须发展以支持汽油车。为了计算消耗水平，我们可以通过添加“computeConsumption()”默认方法来发展“Vehicle”接口，如下所示：
- en: '[PRE63]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Evolving the `Vehicle` interface doesn''t break `SteamCar` compatibility. Furthermore,
    electric cars have been invented. Computing the consumption of an electric car
    is not the same as in the case of a petrol car, but the formula relies on the
    same terms: the fuel, distance, and horsepower. This means that `ElectricCar`
    will override `computeConsumption()` as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 发展“Vehicle”接口不会破坏“SteamCar”的兼容性。此外，电动汽车已经被发明。计算电动汽车的消耗与汽油汽车的情况不同，但公式依赖于相同的术语：燃料、距离和马力。这意味着“ElectricCar”将重写“computeConsumption()”，如下所示：
- en: '[PRE64]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'So, we can override a `default` method, or we can use the implicit implementation.
    Finally, we have to add a description to our interface since now it serves steam,
    petrol, and electric cars. We can do this by adding to `Vehicle` a `static` method
    named `description()`, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以重写“default”方法，或者我们可以使用隐式实现。最后，我们必须为我们的接口添加描述，因为现在它服务于蒸汽、汽油和电动汽车。我们可以通过为“Vehicle”添加一个名为“description()”的“static”方法来实现这一点，如下所示：
- en: '[PRE65]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This `static` method is not bound to any type of car and it can be called directly
    via `Vehicle.description()`. The complete code is named *Java8DefaultStaticMethods*.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“static”方法不绑定到任何类型的汽车，可以直接通过“Vehicle.description()”调用。完整的代码名为*Java8DefaultStaticMethods*。
- en: Next, let's continue with other questions. So far, you should be pretty familiar
    with the **Understand the Question**|**Nominate key points**|**Answer** technique,
    so I will stop highlighting the key points. From now on, it is your job to spot
    them.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续其他问题。到目前为止，您应该对“理解问题”|“提名关键点”|“回答”技术非常熟悉，所以我将停止突出显示关键点。从现在开始，找到它们就是你的工作了。
- en: What are the main differences between interfaces with default methods and abstract
    classes?
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和抽象类之间的主要区别是什么？
- en: Among the differences between Java 8 interfaces and abstract classes, we can
    mention the fact that an abstract class can have a constructor while an interface
    doesn't support constructors. So, an abstract class can have a state while an
    interface cannot have a state. Moreover, interfaces remain the first citizens
    of full abstraction, with the main purpose of being implemented, while abstract
    classes are meant for partial abstraction. Interfaces are still designed to target
    completely abstract things that don't do anything by themselves, but specify contracts
    about how things will work at implementation. The default methods represent an
    approach for adding additional features to the interfaces without affecting the
    client code and without changing the state. They shouldn't be used for other purposes.
    In other words, another difference consists of the fact that it is perfectly fine
    to have an abstract class with no abstract methods, but it is an anti-pattern
    to have an interface only with default methods. This means that we have created
    the interface as a utility class substitute. This way, we defeat the main purpose
    of an interface, which is to be implemented.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8接口和抽象类之间的差异中，我们可以提到抽象类可以有构造函数，而接口不支持构造函数。因此，抽象类可以有状态，而接口不能有状态。此外，接口仍然是完全抽象的第一公民，其主要目的是被实现，而抽象类是为了部分抽象。接口仍然被设计为针对完全抽象的事物，它们本身不做任何事情，但是指定了如何在实现中工作的合同。默认方法代表了一种方法，可以在不影响客户端代码和不改变状态的情况下向接口添加附加功能。它们不应该用于其他目的。换句话说，另一个差异在于，拥有没有抽象方法的抽象类是完全可以的，但是只有默认方法的接口是一种反模式。这意味着我们已经创建了接口作为实用类的替代品。这样，我们就打败了接口的主要目的，即被实现。
- en: Important note
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: When you have to enumerate a bunch of differences or similarities between two
    notions, pay attention to limit your answer to the coordinates settled by the
    question. For example, in the case of the preceding question, do not say that
    one difference lies in the fact that interfaces sustain multiple inheritance while
    abstract classes don't. This is a general variation between interfaces and classes,
    and not specifically between Java 8 interfaces and abstract classes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不得不列举两个概念之间的许多差异或相似之处时，注意限制你的答案在问题确定的坐标内。例如，在前面的问题中，不要说接口支持多重继承而抽象类不支持这一点。这是接口和类之间的一般变化，而不是特别是Java
    8接口和抽象类之间的变化。
- en: What is the main difference between abstract classes and interfaces?
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和接口之间的主要区别是什么？
- en: Until Java 8, the main difference between abstract classes and interfaces consisted
    of the fact that an abstract class can contain non-abstract methods, while an
    interface cannot contain such methods. Starting with Java 8, the main difference
    consists of the fact that an abstract class can have constructors and state while
    an interface cannot have either of these.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Java 8，抽象类和接口的主要区别在于抽象类可以包含非抽象方法，而接口不能包含这样的方法。从Java 8开始，主要区别在于抽象类可以有构造函数和状态，而接口两者都不能有。
- en: Can we have an abstract class without an abstract method?
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以有一个没有抽象方法的抽象类吗？
- en: Yes, we can. By adding the `abstract` keyword to a class, it becomes abstract.
    It cannot be instantiated, but it can have constructors and only non-abstract
    methods.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以。通过向类添加`abstract`关键字，它变成了抽象类。它不能被实例化，但可以有构造函数和只有非抽象方法。
- en: Can we have a class that is both abstract and final at the same time?
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以同时拥有一个既是抽象又是最终的类吗？
- en: A final class cannot be sub-classed or inherited. An abstract class is meant
    to be extended in order to be used. Therefore, final and abstract are opposite
    notions. This means that they cannot be applied to the same class at the same
    time. The compiler will throw an error.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最终类不能被子类化或继承。抽象类意味着要被扩展才能使用。因此，最终和抽象是相反的概念。这意味着它们不能同时应用于同一个类。编译器会报错。
- en: What is the difference between polymorphism, overriding, and overloading?
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态、重写和重载之间有什么区别？
- en: In the context of this question, the overloading technique is known as **Compiled-Time
    Polymorphism**, while the overriding technique is known as **Runtime Polymorphism**.
    Overloading involves the use of static (or early) binding, while overriding uses
    dynamic (or late) binding.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题的背景下，重载技术被称为**编译时多态**，而重写技术被称为**运行时多态**。重载涉及使用静态（或早期）绑定，而重写使用动态（或晚期）绑定。
- en: The next two questions constitute add-ons to this one, but they can be formulated
    as standalone as well.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个问题构成了这个问题的附加部分，但它们也可以作为独立的问题来表述。
- en: What is a binding operation?
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是绑定操作？
- en: A binding operation determines the method (or variable) to be called as a result
    of its references in the code lines. In other words, the process of associating
    a method call to the method body is known as a binding operation. Some references
    are bound at compile time, while other references are bound at runtime. Those
    that are bound at runtime depend upon the type of object. The references resolved
    at compile time are known as static binding operations, while those resolved at
    runtime are known as dynamic binding operations.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定操作确定由于代码行中的引用而调用的方法（或变量）。换句话说，将方法调用与方法体关联的过程称为绑定操作。一些引用在编译时解析，而其他引用在运行时解析。在运行时解析的引用取决于对象的类型。在编译时解析的引用称为静态绑定操作，而在运行时解析的引用称为动态绑定操作。
- en: What are the main differences between static and dynamic binding?
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态绑定和动态绑定之间的主要区别是什么？
- en: First of all, static binding occurs at compile time, while dynamic binding occurs
    at runtime. The second thing to consider involves the fact that private, static,
    and final members (methods and variables) use static binding, while virtual methods
    are bonded at runtime based upon the type of object. In other words, static binding
    is accomplished via `Type` (class in Java) information, while dynamic binding
    is accomplished via `Object`, meaning that a method relying on static binding
    is not associated with an object, but is instead called on `Type` (class in Java),
    while a method relying on dynamic binding is associated with an `Object`. The
    execution of methods that rely on static binding is marginally faster than those
    that rely on dynamic binding. Static and dynamic binding are used in polymorphism
    as well. Static binding is used by compile-time polymorphism (overloading methods),
    while dynamic binding is used in runtime polymorphism (overriding methods). Static
    binding adds overhead in terms of performance at compile time, while dynamic binding
    adds overhead in terms of performance at runtime, meaning that static binding
    is preferable.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，静态绑定发生在编译时，而动态绑定发生在运行时。要考虑的第二件事是，私有、静态和最终成员（方法和变量）使用静态绑定，而虚方法根据对象类型在运行时进行绑定。换句话说，静态绑定是通过`Type`（Java中的类）信息实现的，而动态绑定是通过`Object`实现的，这意味着依赖静态绑定的方法与对象无关，而是在`Type`（Java中的类）上调用的，而依赖动态绑定的方法与`Object`相关。依赖静态绑定的方法的执行速度比依赖动态绑定的方法的执行速度稍快。静态和动态绑定也用于多态。静态绑定用于编译时多态（重载方法），而动态绑定用于运行时多态（重写方法）。静态绑定在编译时增加了性能开销，而动态绑定在运行时增加了性能开销，这意味着静态绑定更可取。
- en: What is method hiding in Java?
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中什么是方法隐藏？
- en: Method hiding is specific to static methods. More precisely, if we declare two
    static methods with the same signature and name in the superclass and in the subclass,
    then they will hide each other. Calling the method from the superclass will call
    the static method from the superclass, and calling the same method from the subclass
    will call the static method from the subclass. Hiding is not the same thing with
    overriding because static methods cannot be polymorphic.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 方法隐藏是特定于静态方法的。更确切地说，如果我们在超类和子类中声明具有相同签名和名称的两个静态方法，那么它们将互相隐藏。从超类调用方法将调用超类的静态方法，从子类调用相同的方法将调用子类的静态方法。隐藏与覆盖不同，因为静态方法不能是多态的。
- en: 'If further details are required, then you can write an example. Consider the
    `Vehicle` superclass having the `move()` static method:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多细节，你可以写一个例子。考虑`Vehicle`超类具有`move()`静态方法：
- en: '[PRE66]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, consider the `Car` subclass having the same static method:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑`Car`子类具有相同的静态方法：
- en: '[PRE67]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s call these two static methods from the `main()` method:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`main()`方法中调用这两个静态方法：
- en: '[PRE68]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output reveals that these two static methods are hiding one another:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示这两个静态方法互相隐藏：
- en: '[PRE69]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that we call static methods via the class name. Calling static methods
    on instances is a very bad practice, so avoid doing this during an interview!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过类名调用静态方法。在实例上调用静态方法是非常糟糕的做法，所以在面试中要避免这样做！
- en: Can we write virtual methods in Java?
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以在Java中编写虚方法吗？
- en: Yes, we can! Actually, in Java, all non-static methods are, by default, virtual
    methods. We can write a non-virtual method by marking it with the `private` and/or
    `final` keyword. In other words, the methods that can be inherited for polymorphic
    behavior are virtual methods. Or, if we turn the logic of this statement on its
    head, the methods that cannot be inherited (marked as `private`) and the methods
    that cannot be overridden (marked as `final`) are non-virtual.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以！实际上，在Java中，所有非静态方法默认都是虚方法。我们可以通过使用`private`和/或`final`关键字标记来编写非虚方法。换句话说，可以继承以实现多态行为的方法是虚方法。或者，如果我们颠倒这个说法的逻辑，那些不能被继承（标记为`private`）和不能被覆盖（标记为`final`）的方法是非虚方法。
- en: What is the difference between polymorphism and abstraction?
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态和抽象之间有什么区别？
- en: Abstraction and polymorphism represent two fundamental OOP concepts that are
    interdependent. Abstraction allows the developer to design general solutions that
    are reusable and customizable, while polymorphism allows the developer to defer
    choosing the code that should be executed at runtime. While abstraction is implemented
    via interfaces and abstract classes, polymorphism relies on overriding and overloading
    techniques.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象和多态代表两个相互依存的基本面向对象的概念。抽象允许开发人员设计可重用和可定制的通用解决方案，而多态允许开发人员推迟在运行时选择应该执行的代码。虽然抽象是通过接口和抽象类实现的，多态依赖于覆盖和重载技术。
- en: Do you consider overloading an approach for implementing polymorphism?
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你认为重载是实现多态的一种方法吗？
- en: This is a controversial topic. Some people do not regard overloading as polymorphism;
    therefore, they do not accept the idea of compile-time polymorphism. Such voices
    maintain that the only overriding method is genuine polymorphism. The argument
    behind this statement says that only overriding allows code to behave differently
    depending on the runtime conditions. In other words, exhibiting polymorphic behavior
    is the privilege of method overriding. I consider that as long as we understand
    the premises of overloading and overriding, we also understand how both variants
    sustain polymorphic behavior.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有争议的话题。有些人不认为重载是多态；因此，他们不接受编译时多态的概念。这些声音认为，唯一的覆盖方法才是真正的多态。这种说法背后的论点是，只有覆盖才允许代码根据运行时条件而表现出不同的行为。换句话说，表现多态行为是方法覆盖的特权。我认为只要我们理解重载和覆盖的前提条件，我们也就理解了这两种变体如何维持多态行为。
- en: Important note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Questions that tackle controversial topics are delicate and hard to approach
    correctly. Therefore, it is advisable to jump into the answer directly with this
    statement *This is a controversial topic*. Of course, the interviewer is interested
    to hear your opinion as well, but he will be pleased to see that you know both
    sides of the coin. As a rule of thumb, try to answer in an objective manner and
    don't approach one side of a coin with radicalism or with a poor arsenal of arguments.
    Controversial things remain controversial after all, and this is not the proper
    time and place to demystify them.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 处理有争议的话题的问题是微妙且难以正确处理的。因此，最好直接跳入答案，陈述*这是一个有争议的话题*。当然，面试官也对听到你的观点感兴趣，但他会很高兴看到你了解事情的两面。作为一个经验法则，尽量客观地回答问题，不要以激进的方式或者缺乏论据的方式处理问题的一面。有争议的事情毕竟还是有争议的，这不是揭开它们的神秘面纱的合适时间和地点。
- en: OK, now let's continue with some questions based on the SOLID principles and
    the famous and indispensable **Gang Of Four** **(GOF)** design patterns. Note
    that this book doesn't cover GOF design patterns, but there are great books and
    videos out there that are dedicated to this topic. I recommend that you try *Learn
    Design Patterns with Java*, by Aseem Jain ([https://www.packtpub.com/application-development/learn-design-patterns-java-video)](https://www.packtpub.com/application-development/learn-design-patterns-java-video)).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们继续一些基于SOLID原则和著名且不可或缺的**四人帮**（GOF）设计模式的问题。请注意，本书不涵盖GOF设计模式，但有很多专门讨论这个话题的优秀书籍和视频。我建议你尝试*Aseem
    Jain*的*Learn Design Patterns with Java*（[https://www.packtpub.com/application-development/learn-design-patterns-java-video)](https://www.packtpub.com/application-development/learn-design-patterns-java-video)）。
- en: Which OOP concept serves the Decorator design pattern?
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪个面向对象的概念服务于装饰者设计模式？
- en: The OOP concept that serves the Decorator design pattern is **Composition**.
    Via this OOP concept, the Decorator design pattern provides new functionalities
    without modifying the original class.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 服务装饰者设计模式的面向对象编程概念是**组合**。通过这个面向对象编程概念，装饰者设计模式在不修改原始类的情况下提供新功能。
- en: When should the Singleton design pattern be used?
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例设计模式应该在什么时候使用？
- en: The Singleton design pattern seems to be the proper choice when we need just
    one application-level (global) instance of a class. Nevertheless, a Singleton
    should be used with precaution because it increases the coupling between classes
    and can become a bottleneck during development, testing, and debugging. As the
    famous *Effective Java* points out, using Java enums is the best way of implementing
    this pattern. It is a common scenario to rely on a Singleton pattern for global
    configurations (for example, loggers, `java.lang.Runtime`), hardware access, database
    connections, and so on.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式似乎是在我们只需要一个类的应用级（全局）实例时的正确选择。然而，应该谨慎使用单例，因为它增加了类之间的耦合，并且在开发、测试和调试过程中可能成为瓶颈。正如著名的《Effective
    Java》所指出的，使用Java枚举是实现这种模式的最佳方式。在全局配置（例如日志记录器、`java.lang.Runtime`）、硬件访问、数据库连接等方面，依赖单例模式是一种常见情况。
- en: Important note
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Whenever you can cite or mention famous references, do so.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每当可以引用或提及著名参考资料时，请这样做。
- en: What is the difference between the Strategy and State design patterns?
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略和状态设计模式之间有什么区别？
- en: The State design pattern is meant to do a certain thing depending upon the *state*
    (it exhibits certain behaviors in different *states* without changing the class).
    The Strategy design pattern, on the other hand, is meant to be used for switching
    between a range of algorithms without modifying the code that uses it (the client
    uses algorithms interchangeably via composition and runtime delegation). Moreover,
    in State, we have a clear order of *state* transition (the flow is created by
    linking each *state* to another *state*), while in Strategy, the client can choose
    the algorithm that it wants in any order. For example, the State pattern can define
    the *states* of sending a package to a client.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式旨在根据*状态*执行某些操作（在不更改类的情况下，在不同*状态*下展示某些行为）。另一方面，策略设计模式旨在用于在不修改使用它的代码的情况下在一系列算法之间进行切换（客户端通过组合和运行时委托可互换地使用算法）。此外，在状态中，我们有清晰的*状态*转换顺序（流程是通过将每个*状态*链接到另一个*状态*来创建的），而在策略中，客户端可以以任何顺序选择它想要的算法。例如，状态模式可以定义发送包裹给客户的*状态*。
- en: The package starts from the *ordered state*, and continues with the *delivered
    state* and so on until it passes through each *state* and reaches the final *state*
    when the client has *received* the package. On the other hand, the Strategy pattern
    defines different strategies for accomplishing each *state* (for example, we may
    have different strategies for delivering the package).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹从*有序状态*开始，然后继续到*已交付状态*，依此类推，直到通过每个*状态*并在客户端*接收*包裹时达到最终*状态*。另一方面，策略模式定义了完成每个*状态*的不同策略（例如，我们可能有不同的交付包裹策略）。
- en: What is the difference between the Proxy and Decorator patterns?
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理和装饰者模式之间有什么区别？
- en: The Proxy design pattern is useful for providing an access control gateway to
    something. Commonly, this pattern creates proxy objects that stand in place of
    the real object. Each request for the real object must pass through the proxy
    objects, which decides how and when to forward it to the real object. The Decorator
    design pattern never creates an object, it just decorates an existing object at
    runtime with new functionality. While chaining proxies is not an advisable practice,
    chaining decorators in a certain order exploits this pattern in the right way.
    For example, while the Proxy pattern can represent a proxy server for the internet,
    the Decorator pattern can be used to decorate the proxy server with different
    custom settings.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式对于提供对某物的访问控制网关非常有用。通常，该模式创建代理对象，代替真实对象。对真实对象的每个请求都必须通过代理对象，代理对象决定如何何时将其转发给真实对象。装饰者设计模式从不创建对象，它只是在运行时用新功能装饰现有对象。虽然链接代理不是一个可取的做法，但以一定顺序链接装饰者可以以正确的方式利用这种模式。例如，代理模式可以表示互联网的代理服务器，而装饰者模式可以用于用不同的自定义设置装饰代理服务器。
- en: What is the difference between the Facade and Decorator patterns?
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观和装饰者模式之间有什么区别？
- en: While the Decorator design pattern is meant to add new functionalities to an
    object (in other words, to decorate the object), the Facade design pattern doesn't
    add new functionalities at all. It just facades the existing functionalities (hides
    the complexities of a system) and calls them behind the scenes via a *friendly
    face* exposed to the client. The Facade pattern can expose a simple interface
    that calls individual components to accomplish complex tasks. For example, the
    Decorator pattern can be used to build a car by decorating a chassis with an engine,
    a gearbox, and so on, while the Facade pattern can hide the complexity of building
    the car by exposing a simple interface for command industrial robots that know
    the building process details.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者设计模式旨在为对象添加新功能（换句话说，装饰对象），而外观设计模式根本不添加新功能。它只是外观现有功能（隐藏系统的复杂性），并通过向客户端暴露的“友好界面”在幕后调用它们。外观模式可以暴露一个简单的接口，调用各个组件来完成复杂的任务。例如，装饰者模式可以用来通过用发动机、变速箱等装饰底盘来建造汽车，而外观模式可以通过暴露一个简单的接口来隐藏建造汽车的复杂性，以便命令了解建造过程细节的工业机器人。
- en: What is the key difference between the Template Method and the Strategy pattern?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法和策略模式之间的关键区别是什么？
- en: The Template Method and Strategy patterns encapsulate domain-specific sets of
    algorithms into objects, but they don't do it in the same way. The key difference
    consists of the fact that the Strategy pattern is meant to decide at runtime between
    different strategies (algorithms) based on the requirements, while the Template
    Method pattern is meant to follow a fixed skeleton (predefined sequence of steps)
    implementation of an algorithm. Some steps are fixed, while other steps can be
    modified for different uses. For example, the Strategy pattern may decide between
    different payment strategies (for example, a credit card or PayPal), while the
    Template Method can describe the predefined sequence of steps for paying with
    a certain strategy (for example, payment via PayPal requires a fixed sequence
    of steps).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法和策略模式将特定领域的算法集合封装成对象，但它们的实现方式并不相同。关键区别在于策略模式旨在根据需求在运行时在不同策略（算法）之间做出决定，而模板方法模式旨在遵循算法的固定骨架（预定义的步骤序列）实现。一些步骤是固定的，而其他步骤可以根据不同的用途进行修改。例如，策略模式可以在不同的支付策略之间做出决定（例如信用卡或PayPal），而模板方法可以描述使用特定策略进行支付的预定义步骤序列（例如，通过PayPal进行支付需要固定的步骤序列）。
- en: What is the key difference between the Builder and Factory patterns?
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器和工厂模式之间的关键区别是什么？
- en: The Factory pattern creates an object in a single method call. We have to pass
    in this call all the necessary parameters and the factory will return the object
    (commonly, by invoking a constructor). On the other hand, the Builder pattern
    is designed for building complex objects via chains of setter methods that allow
    us to shape any combination of parameters. At the end of the chain, the Builder
    method exposes a `build()` method that signals that the list of parameters is
    set, and it is time to build the object. In other words, Factory acts as a wrapper
    of a constructor, while Builder is much granular, acting as a wrapper of all the
    possible parameters you might want to pass into a constructor. Via Builder, we
    avoid the telescopic constructor used to expose all the possible combinations
    of parameters. For example, think back to the `Book` object. A book is characterized
    by a hand of fixed parameters such as the author, title, ISBN, and format. Most
    probably, you will not be juggling with the number of these parameters when creating
    books, and therefore the factory pattern will be a good fit for factoring books.
    But how about a `Server` object? Well, a server is a complex object with tons
    of optional parameters, and so the Builder pattern is much more appropriate here,
    or even a combination of these patterns where Factory relies internally on Builder.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式在单个方法调用中创建对象。我们必须在此调用中传递所有必要的参数，工厂将返回对象（通常通过调用构造函数）。另一方面，生成器模式旨在通过一系列setter方法构建复杂对象，允许我们塑造任何组合的参数。在链的末尾，生成器方法公开了一个`build()`方法，表示参数列表已设置，现在是构建对象的时候了。换句话说，工厂充当构造函数的包装器，而生成器更加精细，充当您可能想要传递到构造函数的所有可能参数的包装器。通过生成器，我们避免了望远镜构造函数用于公开所有可能的参数组合。例如，回想一下`Book`对象。一本书由一些固定参数来描述，例如作者、标题、ISBN和格式。在创建书籍时，您很可能不会在这些参数的数量上纠结，因此工厂模式将是适合创建书籍的选择。但是`Server`对象呢？嗯，服务器是一个具有大量可选参数的复杂对象，因此生成器模式在这里更加合适，甚至是工厂在内部依赖于生成器的这些模式的组合。
- en: What is the key difference between the Adapter and Bridge patterns?
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器和桥接模式之间的关键区别是什么？
- en: The Adapter pattern strives to provide compatibility between an existing code
    that we cannot modify (for example, third-party code) and a new system or interface.
    On the other hand, the Bridge pattern is implemented upfront and is meant to decouple
    an abstraction from implementation in order to avoid an insane number of classes.
    So, Adapter strives to provide compatibility between things after they were designed
    (think along the lines of *A comes from After*), while Bridge is built upfront
    to let the abstraction and the implementation vary independently (think along
    the lines of *B comes from Before*). While Adapter acts as the `ReadJsonRequest`
    and `ReadXmlRequest`, which are capable of reading from several devices, such
    as `D1`, `D2`, and `D3`. `D1` and `D2` produce only JSON requests, while `D3`
    produces XML requests only. Via Adapter, we can convert between JSON and XML,
    meaning that these two classes can communicate with all three devices. On the
    other hand, via the Bridge pattern, we can avoid ending with many classes such
    as `ReadXMLRequestD1`, `ReadXMLRequestD2`, `ReadXMLRequestD3`, `ReadJsonRequestD1`,
    `ReadJsonRequestD2`, and `ReadJsonRequestD3`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式致力于提供现有代码（例如第三方代码）与新系统或接口之间的兼容性。另一方面，桥接模式是提前实现的，旨在将抽象与实现解耦，以避免大量的类。因此，适配器致力于在设计后提供事物之间的兼容性（可以想象为*A来自After*），而桥接是提前构建的，以使抽象和实现可以独立变化（可以想象为*B来自Before*）。适配器充当`ReadJsonRequest`和`ReadXmlRequest`，它们能够从多个设备读取，例如`D1`、`D2`和`D3`。`D1`和`D2`只产生JSON请求，而`D3`只产生XML请求。通过适配器，我们可以在JSON和XML之间进行转换，这意味着这两个类可以与所有三个设备进行通信。另一方面，通过桥接模式，我们可以避免最终产生许多类，例如`ReadXMLRequestD1`、`ReadXMLRequestD2`、`ReadXMLRequestD3`、`ReadJsonRequestD1`、`ReadJsonRequestD2`和`ReadJsonRequestD3`。
- en: We can continue to compare design patterns until we finish all the possible
    combinations. The final few of these questions have covered the most popular questions
    of the type **Design Pattern 1 versus Design Pattern 2**. It is strongly advisable
    to challenge yourself with these types of questions and try to identify similarities
    and differences between two or more given design patterns. Most of the time, these
    questions use two design patterns from the same category (for example, two structural
    or two creational patterns), but they can be from different categories as well.
    In such a case, this is the first statement that the interviewer expects to hear.
    So, in such cases, start by saying to which category each of the design patterns
    involved belongs.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续比较设计模式，直到完成所有可能的组合。最后几个问题涵盖了类型**设计模式1与设计模式2**的最受欢迎的问题。强烈建议您挑战自己，尝试识别两种或更多给定设计模式之间的相似之处和不同之处。大多数情况下，这些问题使用来自同一类别的两种设计模式（例如，两种结构或两种创建模式），但它们也可以来自不同的类别。在这种情况下，这是面试官期望听到的第一句话。因此，在这种情况下，首先说出每个涉及的设计模式属于哪个类别。
- en: Notice that we skipped all simple questions of the type, *What is an interface?,
    What is an abstract class?,* and so on. Typically, such questions are avoided
    since they don't say much about your understanding level, being more about reciting
    some definitions. The interviewer can ask *What is the main difference between
    abstract classes and interfaces?*, and he can deduce from your answer whether
    you know what an interface and an abstract class is. Always be prepared to give
    examples. The inability to shape an example reveals a serious lack of understanding
    of the essence of things.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们跳过了所有简单问题，比如*什么是接口？什么是抽象类？*等等。通常，这类问题是要避免的，因为它们并不能说明您的理解水平，更多的是背诵一些定义。面试官可以问*抽象类和接口的主要区别是什么？*，他可以从您的回答中推断出您是否知道接口和抽象类是什么。始终要准备好举例。无法举例说明严重缺乏对事物本质的理解。
- en: Having OOP knowledge is just half of the problem. The other half is represented
    by having the vision and agility to put this knowledge into designing applications.
    This is what we will do in the next 10 examples. Keep in mind that we are focused
    on design, not on implementation.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有OOP知识只是问题的一半。另一半是具有将这些知识转化为设计应用程序的愿景和灵活性。这就是我们将在接下来的10个示例中做的事情。请记住，我们专注于设计，而不是实现。
- en: Coding challenges
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Next, we will tackle several coding challenges regarding object-oriented programming.
    For each problem, we will follow Figure 5.2 from [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*,
    How to Approach a Coding Challenge*. Mainly, we will start by asking the interviewer
    a question such as *What are the design constraints?* Commonly, coding challenges
    that orbit OOD are expressed by the interviewer in a general way. This is done
    intentionally to make you ask details about design constraints.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解决关于面向对象编程的几个编码挑战。对于每个问题，我们将遵循[*第5章*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*中的图5.2*，*如何处理编码挑战*。主要是，我们将首先向面试官提出一个问题，比如*设计约束是什么？*通常，围绕OOD的编码挑战是以一种一般的方式由面试官表达的。这是故意这样做的，以便让您询问有关设计约束的细节。
- en: Once we have a clear picture of the constraints, we can try an example (which
    can be a sketch, a step-by-step runtime visualization, a bullet list, and suchlike).
    Then, we figure out the algorithm(s)/solution(s), and finally, we provide the
    design skeleton.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们清楚地了解了约束条件，我们可以尝试一个示例（可以是草图、逐步运行时可视化、项目列表等）。然后，我们找出算法/解决方案，最后，我们提供设计骨架。
- en: 'Example 1: Jukebox'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1：自动唱机
- en: '**Amazon**, **Google**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Design the main classes of the jukebox musical machine.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计自动唱机音乐机的主要类。'
- en: '**What to ask**: What is the jukebox playing – CDs, MP3s? What should I design
    – the jukebox building process, how it works, or something else? It is a free
    jukebox or is money required?'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**要问的问题**：自动唱机播放什么-CD、MP3？我应该设计什么-自动唱机建造过程，它是如何工作的，还是其他什么？是免费的自动唱机还是需要钱？'
- en: '**Interviewer**: Is a free jukebox playing only CDs? Design its main functionalities,
    and therefore design how it works.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：免费的自动唱机只播放CD吗？设计它的主要功能，因此设计它是如何工作的。'
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can try to visualize a jukebox and identify its main parts and functionalities.
    Sketching a diagram along the lines of the one here also helps the interviewer
    to see how you think. I suggest that you always take the approach of visualizing
    the problem in a written form – a sketch is a perfect start:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了理解我们的设计应该涉及哪些类，我们可以尝试想象一台自动唱机并确定其主要部分和功能。沿着这里的线条画一个图表也有助于面试官了解您的思维方式。我建议您始终采取以书面形式将问题可视化的方法-草图是一个完美的开始：'
- en: '![Figure 6.1 – Jukebox'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 自动唱机'
- en: '](img/Figure_6.1_B15403.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B15403.jpg)'
- en: Figure 6.1 – Jukebox
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 自动唱机
- en: 'So, we can identify the two main parts of a jukebox: a CD player (or a specific
    jukebox-playing mechanism) and an interface with commands for the users. The CD
    player is capable of managing a playlist and playing those songs. We can think
    of the interface of commands as a Java interface implemented by a Jukebox as shown
    in the next code. Along with the following code, you can use the UML diagram from
    here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以确定自动唱机的两个主要部分：CD播放器（或特定的自动唱机播放机制）和用户命令的接口。CD播放器能够管理播放列表并播放这些歌曲。我们可以将命令接口想象为一个由自动唱机实现的Java接口，如下面的代码所示。除了以下代码，您还可以使用这里的UML图：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/Jukebox/JukeboxUML.png)
- en: '[PRE70]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `CDPlayer` is the heart of the jukebox. Via `Selector`, we control the
    `CDPlayer` behavior. `CDPlayer` must have access to the set of available CDs and
    to the playlist:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`CDPlayer`是点唱机的核心。通过`Selector`，我们控制`CDPlayer`的行为。`CDPlayer`必须能够访问可用的CD和播放列表：'
- en: '[PRE71]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, the `Playlist` manages a list of `Song`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Playlist`管理一个`Song`列表：
- en: '[PRE72]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `User`, `CD`, and `Song` classes are skipped for now, but you can find them
    all in the complete application named *Jukebox*. This kind of problem can be implemented
    in a wide variety of ways, so feel free to try your own designs as well.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`、`CD`和`Song`类暂时被跳过，但你可以在名为*点唱机*的完整应用程序中找到它们。这种问题可以以多种方式实现，所以也可以尝试你自己的设计。'
- en: 'Example 2: Vending machine'
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2：自动售货机
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Design the main classes that sustain the implementation of the
    functionalities of a typical vending machine.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计支持典型自动售货机功能实现的主要类。'
- en: '**What to ask**: Is this a vending machine with different types of coins and
    items? Does it expose functionalities, such as checking an item price, buying
    an item, a refund, and resetting?'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**要问的问题**：这是一个带有不同类型硬币和物品的自动售货机吗？它暴露了功能，比如检查物品价格、购买物品、退款和重置吗？'
- en: '**Interviewer**: Yes, exactly! For coins, you can consider a penny, a nickel,
    a dime, and a quarter.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：是的，确实！对于硬币，你可以考虑一分硬币、五分硬币、一角硬币和一美元硬币。'
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can try to sketch a vending machine. There are a wide range of vending
    machine types. Simply sketch one that you know (like the one in the following
    diagram):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了理解我们的设计应该涉及哪些类，我们可以尝试勾画一个自动售货机。有各种各样的自动售货机类型。简单地勾画一个你知道的（比如下图中的那种）：'
- en: '![Figure 6.2 – Vending machine'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 自动售货机'
- en: '](img/Figure_6.2_B15403.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B15403.jpg)'
- en: Figure 6.2 – Vending machine
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 自动售货机
- en: 'First of all, we immediately notice that items and coins are good candidates
    for Java enums. We have four types of coins and several types of items, so we
    can write two Java enums as follows. Along with the following code, you can use
    the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们立即注意到物品和硬币是Java枚举的良好候选。我们有四种硬币和几种物品，所以我们可以编写两个Java枚举如下。除了以下代码，你还可以使用这里的UML图表：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/VendingMachine/VendingMachineUML.png)
- en: '[PRE73]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The vending machine needs an internal inventory to track the items and status
    of the coins. We can shape this generically as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 自动售货机需要一个内部库存来跟踪物品和硬币的状态。我们可以将其通用地塑造如下：
- en: '[PRE74]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we can focus on the buttons used by a client to interact with the vending
    machine. As you saw in the previous example as well, it is common practice to
    extract these buttons to an interface as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以关注客户用来与自动售货机交互的按钮。正如你在前面的例子中看到的，将这些按钮提取到一个接口中是常见做法，如下所示：
- en: '[PRE75]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, the vending machine can be shaped to implement the `Selector` interface
    and provide a bunch of private methods used to accomplish the internal tasks:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，自动售货机可以被塑造成实现`Selector`接口并提供一堆用于完成内部任务的私有方法：
- en: '[PRE76]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The complete application is named *VendingMachine*. By following the two aforementioned
    examples, you can try to design an ATM, a washing machine, and similar things.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*自动售货机*。通过遵循前面提到的两个例子，你可以尝试设计一个ATM、洗衣机和类似的东西。
- en: 'Example 3: Deck of cards'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例3：一副卡牌
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**'
- en: '**Problem**: Design the main classes of a generic deck of cards.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计一个通用卡牌组的主要类。'
- en: '**What to ask**: Since a card can be almost anything, can you define *generic*?'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**要问的问题**：由于卡可以是几乎任何东西，你能定义*通用*吗？'
- en: '**Interviewer**: A card is characterized by a symbol (suit) and a value. For
    example, think of a standard 52-card set.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：一张卡由一个符号（花色）和一个点数来描述。例如，想象一副标准的52张卡牌组。'
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can quickly sketch a card and a deck of cards for the standard 52-card
    set, as shown in Figure 6.3:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了理解我们的设计应该涉及哪些类，我们可以快速勾画一个标准52张卡牌组的卡牌和一副卡牌，如图6.3所示：'
- en: '![Figure 6.3 – A deck of cards'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 一副卡牌'
- en: '](img/Figure_6.3_B15403.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B15403.jpg)'
- en: Figure 6.3 – A deck of cards
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 一副卡牌
- en: Since every card has a suit and a value, we will need a class that encapsulates
    these fields. Let's call this class `StandardCard`. A suit for `StandardCard`
    contains a *Spade, Heart, Diamond*, or *Club*, so this suit is a good candidate
    for a Java enum. A `StandardCard` value can be between 1 and 13.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每张卡都有花色和点数，我们将需要一个封装这些字段的类。让我们称这个类为`StandardCard`。`StandardCard`的花色包括*黑桃，红心，方块*或*梅花*，因此这个花色是Java枚举的一个很好的候选。`StandardCard`的点数可以在1到13之间。
- en: A card can live as a standalone or be a part of a pack of cards. Multiple cards
    form a pack of cards (for example, a standard 52-card set forms a pack of cards).
    The number of cards in a pack is usually obtained as a Cartesian product between
    the possible suits and values (for example, 4 suits x 13 values = 52 cards). So,
    52 `StandardCard` objects form `StandardPack`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一张卡可以独立存在，也可以是一副卡牌的一部分。多张卡组成一副卡牌（例如，一副标准的52张卡牌组形成一副卡牌）。一副卡牌中的卡的数量通常是可能的花色和点数的笛卡尔积（例如，4种花色
    x 13个点数 = 52张卡）。因此，52个`StandardCard`对象形成了`StandardPack`。
- en: Finally, a deck of cards should be a class capable of performing some actions
    with this `StandardPack`. For example, a deck of cards can shuffle the cards,
    can deal a hand or a card, and so on. This means that a `Deck` class is also needed.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一副牌应该是一个能够执行一些与这个“标准包”相关的操作的类。例如，一副牌可以洗牌，可以发牌或发一张牌，等等。这意味着还需要一个“Deck”类。
- en: 'So far, we have settled on having a Java `enum` and the `StandardCard`, `StandardPack`,
    and `Deck` classes. If we add the abstraction layers needed to avoid high coupling
    between these concrete layers, then we obtain the following implementation. Along
    with the following code, you can use the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了一个Java的“enum”和“StandardCard”、“StandardPack”和“Deck”类。如果我们添加了所需的抽象层，以避免这些具体层之间的高耦合，那么我们就得到了以下的实现。除了以下代码，您还可以使用这里的UML图：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/DeckOfCards/DeckOfCardsUML.png)
- en: 'For standard card implementation:'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标准牌实现：
- en: '[PRE77]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Standard pack of cards implementation gives the following code:'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准牌组实现提供以下代码：
- en: '[PRE78]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Deck of cards implementation provides the following:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 牌组实现提供以下内容：
- en: '[PRE79]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A demo of the code can be quickly written as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的演示可以快速写成如下：
- en: '[PRE80]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Furthermore, you can easily add more types of cards by extending the `Card`
    and `Pack` classes. The complete code is named *DeckOfCards*.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过扩展`Card`和`Pack`类轻松添加更多类型的卡。完整的代码名为*DeckOfCards*。
- en: 'Example 4: Parking lot'
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例4：停车场
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**'
- en: '**Problem**: Design the main classes of a parking lot.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计停车场的主要类。'
- en: '**What to ask**: Is it a single-level or multi-level parking lot? Are all parking
    space spots the same? What type of vehicles should we park? Is it free parking?
    Do we use parking tickets?'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要询问的问题**：这是单层停车场还是多层停车场？所有停车位是否相同？我们应该停放什么类型的车辆？这是免费停车吗？我们使用停车票吗？'
- en: '**Interviewer**: It is a synchronous automatic multi-level free parking lot.
    All parking spots are the same size, but we expect cars (1 spot needed), vans
    (2 spots needed) and trucks (5 spots needed). Other types of vehicles should be
    added without modifying the code. The system releases a parking ticket that can
    be used later to unpark the vehicle. But if the driver introduces only the vehicle
    information (assuming a lost ticket), the system should still work and locate
    the vehicle in the parking lot and unpark it.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：这是一个同步自动多层免费停车场。所有停车位大小相同，但我们期望有汽车（需要1个停车位）、货车（需要2个停车位）和卡车（需要5个停车位）。其他类型的车辆应该可以在不修改代码的情况下添加。系统会释放一个停车票，以便以后用于取车。但是，如果司机只提供车辆信息（假设丢失了停车票），系统仍然应该能够工作并在停车场中找到车辆并将其取出。'
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can quickly sketch a parking lot to identify the main actors and behaviors
    as in Figure 6.4:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了了解我们的设计应该涉及哪些类，我们可以快速勾画一个停车场，以识别主要的参与者和行为，如图6.4所示：'
- en: '![Figure 6.4 – A parking lot'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 - 停车场'
- en: '](img/Figure_6.4_B15403.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B15403.jpg)'
- en: Figure 6.4 – A parking lot
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 - 停车场
- en: 'The diagram reveals two major actors: the parking lot and the automatic parking
    system.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表显示了两个主要的参与者：停车场和自动停车系统。
- en: 'First, let''s focus on the parking lot. The main purpose of a parking lot is
    to park vehicles; therefore, we need to shape the accepted vehicles (car, van,
    and truck). This looks like a typical case for an abstract class (`Vehicle`) and
    three subclasses (`Car`, `Van`, and `Truck`). But this is not true! The driver
    provides information about their vehicle. They don''t effectively push the vehicle
    (the object) into the parking system, so our system does not need dedicated objects
    for cars, vans, trucks, and so on. Think from the perspective of a parking lot.
    It needs the vehicle license plate and the free spots required for parking. It
    doesn''t care about the characteristics of a van or a truck. So, we can shape
    a `Vehicle` as follows. Along with the following code, you can use the UML diagram
    from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们专注于停车场。停车场的主要目的是停放车辆；因此，我们需要确定可接受的车辆（汽车、货车和卡车）。这看起来像是一个抽象类（`Vehicle`）和三个子类（`Car`、`Van`和`Truck`）的典型情况。但这并不是真的！司机提供有关他们的车辆的信息。他们并没有真正将车辆（对象）推入停车系统，因此我们的系统不需要为汽车、货车、卡车等专门的对象。从停车场的角度来看。它需要车辆牌照和停车所需的空闲车位。它不关心货车或卡车的特征。因此，我们可以将`Vehicle`塑造如下。除了以下代码，您还可以使用这里的UML图：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/ParkingLot/ParkingLotUML.png)
- en: '[PRE81]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we have to design the parking lot. Mainly, a parking lot has several
    floors (or levels) and each floor has parking spots. Among others, a parking lot
    should expose methods for parking/unparking a vehicle. These methods will delegate
    the parking/unparking tasks to each floor (or to a certain floor) until it succeeds
    or there is no floor to scan:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设计停车场。主要是，停车场有几层（或级别），每层都有停车位。除其他外，停车场应该暴露出停车/取车的方法。这些方法将把停车/取车的任务委托给每一层（或特定的一层），直到成功或没有要扫描的层为止。
- en: '[PRE82]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A parking floor controls the parking/unparking process on a certain floor.
    It has its own registry of parking tickets and is capable of managing its parking
    spots. Mainly, each parking floor acts as an independent parking lot. This way,
    we can shut down a complete floor while the remainder of the floors are not affected:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 停车楼控制某一楼层的停车/取车过程。它有自己的停车票注册表，并能够管理其停车位。主要上，每个停车楼都充当独立的停车场。这样，我们可以关闭一个完整的楼层，而其余楼层不受影响：
- en: '[PRE83]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, a parking spot is an object that holds information about its name
    (label or number), availability (whether it is free) and vehicle (whether a vehicle
    is parked on that spot). It also has methods for assigning/removing a vehicle
    to/from this spot:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，停车位是一个对象，它保存有关其名称（标签或编号）、可用性（是否空闲）和车辆（是否停放在该位置的车辆）的信息。它还具有分配/移除车辆到/从此位置的方法：
- en: '[PRE84]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'At this moment, we have all the major classes of the parking lot. Next, we
    are going to focus on the automatic parking system. This can be shaped as a single
    class that acts as a dispatcher of the parking lot:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，我们已经拥有了停车场的所有主要类。接下来，我们将专注于自动停车系统。这可以被塑造为一个作为停车场调度员的单一类：
- en: '[PRE85]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The complete application containing a partial implementation as well is named
    *ParkingLot*.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 包含部分实现的完整应用程序被命名为*ParkingLot*。
- en: 'Example 5: Online reader system'
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例5：在线阅读系统
- en: '**Problem**: Design the main classes of an online reader system.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计在线阅读系统的主要类。'
- en: '**What to ask**: What are the required functionalities? How many books can
    be read simultaneously?'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要询问的问题**：需要哪些功能？可以同时阅读多少本书？'
- en: '**Interviewer**: The system should be capable of managing readers and books.
    Your code should be able to add/remove a reader/book and to display a reader/book.
    The system can serve a single reader and a single book at a time.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：系统应该能够管理读者和书籍。您的代码应该能够添加/移除读者/书籍并显示读者/书籍。系统一次只能为一个读者和一本书提供服务。'
- en: '**Solution**: In order to understand what classes should be involved in our
    design, we can think about sketching something as in Figure 6.5:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了理解我们的设计应该涉及哪些类，我们可以考虑草绘一些东西，如图6.5所示：'
- en: '![Figure 6.5 – An online reader system'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – 一个在线阅读系统'
- en: '](img/Figure_6.5_B15403.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.5_B15403.jpg)'
- en: Figure 6.5 – An online reader system
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 一个在线阅读系统
- en: 'In order to manage readers and books, we need to have such objects. This is
    a small and easy part, and starting with such parts in an interview is very helpful
    for breaking the ice and accommodating the problem at hand. When we design objects
    in an interview, there is no need to come up with a full version of an object.
    For example, a reader having a name and email, and a book having an author, title,
    and ISBN is more than sufficient. Let''s see them in the following code. Along
    with the following code, you can use the UML diagram from here: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理读者和书籍，我们需要拥有这样的对象。这是一个小而简单的部分，在面试中从这样的部分开始对打破僵局和适应手头的问题非常有帮助。当我们在面试中设计对象时，没有必要提出一个对象的完整版本。例如，一个读者有姓名和电子邮件，一本书有作者、标题和ISBN就足够了。让我们在下面的代码中看到它们。除了下面的代码，您还可以使用这里的UML图：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/OnlineReaderSystem/OnlineReaderSystemUML.png)
- en: '[PRE86]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, if we consider that books are usually managed by a library, then we can
    wrap several functionalities, such as adding, finding, and removing a book, in
    a class as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们考虑到书籍通常由图书馆管理，那么我们可以将添加、查找和移除书籍等多个功能封装在一个类中，如下所示：
- en: '[PRE87]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Readers can be managed by a similar class named `ReaderManager`. You can find
    this class in the complete application. To read a book, we require a displayer.
    The `Displayer` should display the reader and the book details and should be capable
    of navigating through the books pages:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以由一个名为`ReaderManager`的类来管理。您可以在完整的应用程序中找到这个类。为了阅读一本书，我们需要一个显示器。`Displayer`应该显示读者和书籍的详细信息，并且应该能够浏览书籍的页面：
- en: '[PRE88]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, all we have to do is to wrap `Library`, `ReaderManager`, and `Displayer`
    in the `OnlineReaderSystem` class. This class is listed here:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们所要做的就是将`Library`、`ReaderManager`和`Displayer`封装在`OnlineReaderSystem`类中。这个类在这里列出：
- en: '[PRE89]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The complete application is named *OnlineReaderSystem*.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*OnlineReaderSystem*。
- en: 'Example 6: Hash table'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例6：哈希表
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**、**谷歌**、**Adobe**、**微软**'
- en: '**Problem**: Design a hash table (this is a very popular problem in interviews).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计一个哈希表（这是面试中非常流行的问题）。'
- en: '**What to ask**: What are the required functionalities? What technique should
    be applied to solve index collisions? What is the data type of the key-value pairs?'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要询问的问题**：需要哪些功能？应该应用什么技术来解决索引冲突？键值对的数据类型是什么？'
- en: '`add()` and `get()` operations. For solving index collisions, I suggest you
    use the *chaining* technique. The key-value pairs should be generic.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`和`get()`操作。为了解决索引冲突，我建议您使用*链接*技术。键值对应该是通用的。'
- en: '**A brief overview of a hash table:** A hash table is a type of data structure
    that stores key-value pairs. Commonly, an array holds all the key-value entries
    in the table and the size of this array is set to accommodate the amount of data
    anticipated. The key of each key-value is passed through a hash function (or several
    hash functions) that outputs a hash value or a hash. Mainly, the hash value represents
    the index of the key-value pair in the hash table (for example, if we use an array
    to store all key-value pairs, then the hash function returns the index of this
    array that should hold the current key-value pair). Passing the same key through
    the hash function should produce the same index every time – this is useful for
    finding a value via its key.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表的简要概述**：哈希表是一种存储键值对的数据结构。通常，数组保存表中所有键值条目，该数组的大小设置为容纳预期数据量。每个键值的键通过哈希函数（或多个哈希函数）传递，输出哈希值或哈希。主要，哈希值表示哈希表中键值对的索引（例如，如果我们使用数组存储所有键值对，则哈希函数返回应该保存当前键值对的数组的索引）。通过哈希函数传递相同的键应该每次产生相同的索引
    - 这对于通过其键查找值很有用。'
- en: 'When a hash function generates two identical indexes for different keys, we
    face an index collision. The most frequently used techniques for solving an index
    collision problem are *linear probing* (this technique searches linearly for the
    next free slot in the table – trying to find in the array a slot (an index) that
    doesn''t hold a key-value pair) and *chaining* (this technique represents a hash
    table implemented as an array of linked lists – collisions are stored at the same
    array index as linked list nodes). The following diagram is a hash table for storing
    *name-phone* pairs. It has *chaining* capabilities (check the *Marius-0838234*
    entry, which is chained to *Karina-0727928*, because their keys, *Marius* and
    *Karina*, lead to the same array index, *126*):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当哈希函数为不同的键生成两个相同的索引时，我们面临索引冲突。解决索引冲突问题最常用的技术是*线性探测*（这种技术在表中线性搜索下一个空槽位 - 尝试在数组中找到一个不包含键值对的槽位（索引））和*chaining*（这种技术表示作为链表数组实现的哈希表
    - 冲突存储在与链表节点相同的数组索引中）。下图是用于存储*名称-电话*对的哈希表。它具有*chaining*功能（检查*马里乌斯-0838234*条目，它被链接到*卡琳娜-0727928*，因为它们的键*马里乌斯*和*卡琳娜*导致相同的数组索引*126*）：
- en: '![Figure 6.6 – A hash table'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 - 哈希表'
- en: '](img/Figure_6.6_B15403.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.6_B15403.jpg)'
- en: Figure 6.6 – A hash table
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 - 哈希表
- en: '`HashEntry`). As you can see in the preceding diagram, a key-value pair has
    three main parts: the key, the value, and a link to the next key-value pair (this
    way, we implement *chaining*). Since a hash table entry should be accessed only
    via dedicated methods, such as `get()` and `put()`, we encapsulate it as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashEntry`）。正如您在前面的图中所看到的，键值对有三个主要部分：键、值和指向下一个键值对的链接（这样，我们实现*chaining*）。由于哈希表条目应该只能通过专用方法（如`get()`和`put()`）访问，因此我们将其封装如下：'
- en: '[PRE90]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we define the array that holds `HashEntry`. For testing purposes, a size
    of `10` elements is enough and it allows us to test *chaining* easily (having
    a small size is prone to collisions). In reality, such an array is much bigger:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义包含`HashEntry`的数组。为了测试目的，大小为`10`的元素足够了，并且可以轻松测试*chaining*（大小较小容易发生碰撞）。实际上，这样的数组要大得多：
- en: '[PRE91]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we add the `get()` and `put()` methods. Their code is quite intuitive:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`get()`和`put()`方法。它们的代码非常直观：
- en: '[PRE92]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we add a dummy hash function (in reality, we use hash functions such
    as Murmur 3 – [https://en.wikipedia.org/wiki/MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个虚拟哈希函数（实际上，我们使用诸如Murmur 3之类的哈希函数 - [https://en.wikipedia.org/wiki/MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)）：
- en: '[PRE93]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Done! The complete application is named *HashTable*.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序名为*HashTable*。
- en: For the following four examples, we skipped the source code from the book. Take
    your time and dissect each example. Being able to understand an existing design
    is just another tool that you can use to shape your design skills. Of course,
    you can try your own approach before looking into the book's code and compare
    the results in the end.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下四个示例，我们跳过了书中的源代码。花点时间分析每个示例。能够理解现有设计是塑造设计技能的另一个工具。当然，您可以在查看书中代码之前尝试自己的方法，并最终比较结果。
- en: 'Example 7: File system'
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例7：文件系统
- en: '**Problem**: Design the main classes of a file system.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计文件系统的主要类。'
- en: '**What to ask**: What are the required functionalities? What are the pieces
    of the file system?'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**要问的问题**：需要哪些功能？文件系统的组成部分是什么？'
- en: '**Interviewer**: Your design should support the addition, deletion, and renaming
    of directories and files. We are talking about a hierarchical structure of directories
    and files, like most operating systems have.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：您的设计应支持目录和文件的添加、删除和重命名。我们谈论的是目录和文件的分层结构，就像大多数操作系统一样。'
- en: '**Solution**: The complete application is named *FileSystem*. Please visit
    the following link to check the UML: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：完整的应用程序名为*FileSystem*。请访问以下链接以查看UML：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/FileSystem/FileSystemUML.png)'
- en: 'Example 8: Tuple'
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例8：元组
- en: '**Amazon**, **Google**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Design a tuple data structure.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计一个元组数据结构。'
- en: '**What to ask**: A tuple can have from 1 to *n* elements. So, what kind of
    tuple do you expect? What data types should be stored in the tuple?'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**要问的问题**：元组可以有1到*n*个元素。那么，您期望什么样的元组？元组中应存储什么数据类型？'
- en: '**Interviewer**: I am expecting a tuple with two generic elements. The tuple
    is also known as a *pair*.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**面试官**：我期望一个包含两个通用元素的元组。元组也被称为*pair*。'
- en: '**Solution**: The complete application is named *Tuple*.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：完整的应用程序名为*Tuple*。'
- en: 'Example 9: Cinema with a movie ticket booking system'
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例9：带有电影票预订系统的电影院
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软
- en: '**Problem**: Design a cinema with a movie ticket booking system.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：设计一个带有电影票预订系统的电影院。
- en: '**What to ask**: What is the main structure of the cinema? Does it have multiple
    cinema rooms? What types of tickets do we have? How do we play a movie (only in
    a room, just once a day)?'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要问什么：电影院的主要结构是什么？它有多个影厅吗？我们有哪些类型的票？我们如何播放电影（只在一个房间，每天只播放一次）？
- en: '**Interviewer**: I am expecting a cinema with multiple identical rooms. A movie
    can run in multiple rooms at the same time and can run multiple times in a day
    in the same room. There are three types of tickets, simple, silver, and gold,
    based on the seat type. A movie can be added/removed in a very versatile way (for
    example, we can remove a movie from certain rooms at certain start times, or we
    can add a movie to all rooms).'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官：我期望一个有多个相同房间的电影院。一部电影可以同时在多个房间播放，同一部电影一天内可以在同一个房间播放多次。有三种类型的票，简单、白银和黄金，根据座位类型。电影可以以非常灵活的方式添加/移除（例如，我们可以在特定的开始时间从某些房间中移除一部电影，或者我们可以将一部电影添加到所有房间）。
- en: '**Solution**: The complete application is named *MovieTicketBooking*. Please
    visit the following link to check the UML: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：完整的应用程序名为MovieTicketBooking。请访问以下链接查看UML：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/blob/master/Chapter06/MovieTicketBooking/MovieTicketBookingUML.png)
- en: 'Example 10: Circular byte buffer'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10：循环字节缓冲区
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe
- en: '**Problem**: Design a circular byte buffer.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：设计一个循环字节缓冲区。
- en: '**What to ask**: It should be resizable?'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 要问什么：它应该是可调整大小的？
- en: '**Interviewer**: Yes, it should be resizable. Mainly, I expect you to design
    the signatures of all methods that you consider necessary.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官：是的，它应该是可调整大小的。主要是，我希望你设计所有你认为必要的方法的签名。
- en: '**Solution**: The complete application is named *CircularByteBuffer*.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：完整的应用程序名为CircularByteBuffer。
- en: So far so good! I suggest you try your own designs for the preceding 10 problems
    as well. Do not consider that the solutions presented are the only ones that are
    correct. Practice as much as you can by varying the context of the problem and
    challenge yourself with other problems as well.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止一切顺利！我建议你也尝试为前面的10个问题设计你自己的解决方案。不要认为所提供的解决方案是唯一正确的。尽可能多地练习，通过改变问题的背景来挑战自己，也尝试其他问题。
- en: The source code bundle for this chapter is available under the name *Chapter06*.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码包名称为Chapter06。
- en: Summary
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered the most popular questions about OOP fundamentals and 10
    design coding challenges that are very popular in interviews. In the first part,
    we began with OOP concepts (object, class, abstraction, encapsulation, inheritance,
    polymorphism, association, aggregation, and composition), continued with the SOLID
    principles, and finished with an amalgam of questions combining OOP Concepts,
    SOLID principles, and design pattern knowledge. In the second part, we tackled
    10 carefully crafted design coding challenges, including designing a jukebox,
    a vending machine, and the famous hash table.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了关于面向对象编程基础知识的最受欢迎的问题和10个设计编码挑战，在面试中非常受欢迎。在第一部分，我们从面向对象的概念（对象、类、抽象、封装、继承、多态、关联、聚合和组合）开始，继续讲解了SOLID原则，并以结合了面向对象编程概念、SOLID原则和设计模式知识的问题为结束。在第二部分，我们解决了10个精心设计的设计编码挑战，包括设计点唱机、自动售货机和著名的哈希表。
- en: Practicing these questions and problems will give you the ability to tackle
    any OOP problem encountered in an interview.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 练习这些问题和问题将使你有能力解决面试中遇到的任何面向对象编程问题。
- en: In the next chapter, we will tackle Big O notation and time.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决大O符号和时间的问题。
