- en: Creating a Markdown Editor with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript创建一个Markdown编辑器
- en: It is hard to deal with content on the internet without encountering markdown.
    Markdown is a simplified way to create content using plain text that is easily
    converted into simple HTML. In this chapter, we are going to investigate what
    it takes to create a parser that will convert a subset of the markup format into
    HTML content. We will automatically convert relevant tags into the first three
    header levels, the horizontal rule, and paragraphs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上处理内容时很难避免遇到markdown。Markdown是一种使用纯文本创建内容的简化方式，可以轻松转换为简单的HTML。在本章中，我们将调查创建一个解析器所需的步骤，该解析器将把标记格式的子集转换为HTML内容。我们将自动将相关标签转换为前三个标题级别、水平规则和段落。
- en: By the end of this chapter, we will have covered how to create a simple Bootstrap
    web page and reference the JavaScript generated from our TypeScript, as well as
    hooking up to a simple event handler. We will also cover how to create classes
    using simple design patterns and how to design classes with single responsibilities,
    which are techniques that serve us well as professional developers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将学习如何创建一个简单的Bootstrap网页，并引用从我们的TypeScript生成的JavaScript，以及如何连接到一个简单的事件处理程序。我们还将学习如何使用简单的设计模式创建类，以及如何设计具有单一职责的类，这些技术将成为我们作为专业开发人员的有用技能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a Bootstrap page that overrides the Bootstrap styling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个覆盖Bootstrap样式的Bootstrap页面
- en: Choosing which tags we are going to use in our markdown
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择我们在markdown中要使用的标签
- en: Defining requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义需求
- en: Mapping our markdown tag types to HTML tag types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的markdown标记类型映射到HTML标记类型
- en: Storing our converted markdown in a custom class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们转换的markdown存储在自定义类中
- en: Using the visitor pattern to update our document
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问者模式更新我们的文档
- en: Using the chain-of-responsibility pattern to apply tags
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用责任链模式应用标签
- en: Hooking this back to our HTML
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其连接回我们的HTML
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02)下载。
- en: Understanding the project overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解项目概述
- en: Now that we have a grasp of some of the concepts that we are going to cover
    throughout the rest of this book, we are going to start putting them into practice
    by creating a project that parses a very simple markdown format while the user
    types into a text area and displays the resulting web page alongside it. Unlike
    full markdown parsers, we are going to concentrate on formatting the first three
    header types, the horizontal rule, and paragraphs. The markup is restricted to
    breaking lines down by newline characters and looking at the start of a line.
    It then determines whether or not a particular tag is present and, if not, it
    assumes the current line is a paragraph. The reason we have chosen this implementation
    is because it is a simple task to pick up immediately. While it is simple, it
    offers sufficient depth to show that we are going to tackle topics that require
    us to give real thought to how we will structure the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了本书中将要涵盖的一些概念，我们将开始将它们付诸实践，创建一个项目，该项目在用户输入到文本区域时解析一个非常简单的markdown格式，并在其旁边显示生成的网页。与完整的markdown解析器不同，我们将集中于格式化前三个标题类型、水平规则和段落。标记受限于通过换行符分解行并查看行的开头。然后确定特定标签是否存在，如果不存在，则假定当前行是一个段落。我们选择这种实现的原因是因为它是一个可以立即掌握的简单任务。虽然简单，但它提供了足够的深度，以表明我们将处理需要我们认真考虑如何构建应用程序的主题。
- en: 'The **user interface** (**UI**), uses Bootstrap, and we will look at how to
    hook up to a change event handler and how to get and update HTML content from
    the current web page. This is what our project will look like when we have finished:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）使用Bootstrap，我们将看看如何连接到更改事件处理程序以及如何获取和更新当前网页的HTML内容。这是我们完成后项目的样子：'
- en: '![](assets/6e9cd123-84da-441a-b275-ff822a2de7c7.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e9cd123-84da-441a-b275-ff822a2de7c7.png)'
- en: Now that we have our overview, we can move on to getting started with creating
    the HTML project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了概述，我们可以继续开始创建HTML项目。
- en: Getting started with a simple HTML project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个简单的HTML项目
- en: 'This project is a simple HTML and TypeScript file combination. Create a directory
    to hold the HTML and TypeScript files. Our JavaScript will reside in a script
    folder under this directory. The following `tsconfig.json` file is used:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是一个简单的HTML和TypeScript文件组合。创建一个目录来保存HTML和TypeScript文件。我们的JavaScript将驻留在此目录下的脚本文件夹中。使用以下`tsconfig.json`文件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Writing a simple markdown parser
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的markdown解析器
- en: When I was thinking about the project that we are going to tackle in this chapter,
    I had a clear objective in mind. While we are writing this code, we are going
    to try out things such as patterns and good **object-oriented** (**OO**) practices,
    such as classes having a single responsibility. If we can apply these techniques
    right from the start, we will soon get into the habit of using them and this will
    translate into useful development skills.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在考虑本章我们将要处理的项目时，我心中有一个明确的目标。在编写这段代码的同时，我们将尝试诸如模式和良好的**面向对象**（**OO**）实践，比如类具有单一职责。如果我们能从一开始就应用这些技术，我们很快就会养成使用它们的习惯，这将转化为有用的开发技能。
- en: As professional developers, before we write any code, we should gather the requirements
    that we are going to use and ensure that we are making no assumptions about what
    our application will do. We may think that we know what we want our application
    to do, but if we make a list of our requirements, we'll make sure that we understand
    everything that we are meant to deliver and we'll come up with a handy checklist
    to tick features off as we complete them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为专业开发人员，在编写任何代码之前，我们应该收集我们将使用的要求，并确保我们对我们的应用程序将要做什么没有任何假设。我们可能认为我们知道我们想要我们的应用程序做什么，但是如果我们列出我们的要求，我们将确保我们理解我们应该交付的一切，并且我们将得到一个方便的清单，以便在完成它们时勾选功能。
- en: 'So, here is my list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是我的清单：
- en: We are going to create an application to parse markdown
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个解析markdown的应用程序
- en: The user will type into a text area
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将在文本区域中输入
- en: Every time the text area changes, we will parse the entire document again
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当文本区域发生变化时，我们将重新解析整个文档
- en: We will break the document down based on where the user presses the *Enter*
    key
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根据用户按下*Enter*键的位置来分解文档
- en: The opening characters will determine whether or not the line is markdown
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开头的字符将决定该行是否是markdown
- en: 'Entering # followed by a space is replaced by an H1 heading'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入#后跟一个空格将被替换为H1标题
- en: 'Entering ## followed by a space is replaced by an H2 heading'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入##后跟一个空格将被替换为H2标题
- en: 'Entering ### followed by a space is replaced by an H3 heading'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入###后跟一个空格将被替换为H3标题
- en: Entering --- is replaced by a horizontal rule
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入---将被替换为水平线
- en: If the line does not start with markdown, the line is treated as a paragraph
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该行不以markdown开头，则该行将被视为段落
- en: The resulting HTML will be displayed in a label
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的HTML将显示在一个标签中
- en: If the content in the markdown text area is empty, the label will contain an
    empty paragraph
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果markdown文本区域中的内容为空，则标签将包含一个空段落
- en: The layout will be done in Bootstrap and the content will stretch to 100% height
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局将在Bootstrap中完成，内容将拉伸到100%的高度
- en: Given those requirements, we have a good idea of what we are going to deliver,
    so we are starting off by creating our UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要求，我们对我们将要交付的内容有一个很好的想法，所以我们要开始创建我们的UI。
- en: Building our Bootstrap UI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的Bootstrap UI
- en: 'In [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features*, we looked at the basics of creating a UI using Bootstrap. We will take
    the same basic page and adjust it to fit our needs with a couple of little tweaks.
    Our starting point is this page, which stretches across the full width of the
    screen by setting the container to use `container-fluid`, and divides the interface
    into two equal parts by setting `col-lg-6` on both sides:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml)中，*高级TypeScript功能*，我们看了使用Bootstrap创建UI的基础知识。我们将采用相同的基本页面，并通过一些小调整来调整它以满足我们的需求。我们的起点是这个页面，通过将容器设置为使用`container-fluid`，并在两侧设置`col-lg-6`，将界面分成两个相等的部分：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we add our text area and label components to our form, we find that rendering
    them in this row does not automatically expand them to fill the height of the
    screen. We need to make a couple of adjustments. First, we need to manually set
    the style of the `html` and `body` tags to fill the available space. To do this,
    we add the following in the header:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将文本区域和标签组件添加到我们的表单中时，我们发现在此行中呈现它们不会自动将它们扩展到填满屏幕的高度。我们需要做一些调整。首先，我们需要手动设置`html`和`body`标签的样式以填充可用空间。为此，我们在头部添加以下内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With that in place, we can take advantage of a new feature in Bootstrap 4,
    which is applying `h-100` to these classes to fill 100% of the space. We are also
    going to take this opportunity to add the text area and label, as well as giving
    them IDs that we can look up from our TypeScript code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以利用Bootstrap 4中的一个新功能，即将`h-100`应用于这些类，以填充100%的空间。我们还将利用这个机会添加文本区域和标签，并为它们添加我们可以从我们的TypeScript代码中查找的ID：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we finish off our page, we are going to start writing TypeScript code
    that we can use in our application. Add a file called `MarkdownParser.ts` to hold
    our TypeScript code and add the following code to it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成页面之前，我们将开始编写我们可以在应用程序中使用的TypeScript代码。添加一个名为`MarkdownParser.ts`的文件来保存我们的TypeScript代码，并将以下代码添加到其中：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We created this class so that we could get the text area and the label based
    on their IDs. Once we have these, we are going to hook into the text area, key
    up the event, and write the keypress value back to the label. Notice how, even
    though we are not in a web page at this point, TypeScript implicitly gives us
    access to standard web page behaviors. This allows us to retrieve the text area
    and label based on the IDs we previously entered, and to cast them to the appropriate
    type. With this, we gain the ability to do things such as subscribe to events
    or access an element's `innerHTML`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了这个类，以便我们可以根据它们的ID获取文本区域和标签。一旦我们有了这些，我们将连接到文本区域，按键事件，并将按键值写回标签。请注意，即使在这一点上我们不在网页上，TypeScript也会隐式地给我们访问标准网页行为的权限。这使我们能够根据我们先前输入的ID检索文本区域和标签，并将它们转换为适当的类型。有了这个，我们就能够做一些事情，比如订阅事件或访问元素的`innerHTML`。
- en: For the sake of simplicity, we are going to use the `MarkdownParser.ts` file
    for all of our TypeScript in this chapter. Normally, we would separate the classes
    into their own files, but this single-file structure should be simpler to review
    as we progress through the code. In future chapters, we will be moving away from
    a single file because those projects are much more complex.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在本章中使用`MarkdownParser.ts`文件中的所有TypeScript。通常情况下，我们会将类分开放在它们自己的文件中，但是这种单文件结构应该更容易在我们逐步进行代码审查时进行复习。在未来的章节中，我们将摆脱单一文件，因为那些项目要复杂得多。
- en: Once we have these interface elements, we hook up to the keyup event. When the
    event is fired, we look to see if we have any text in the text area and set the
    HTML of the label with the content (if it is present), or the empty paragraph
    (if it is not present). The reason we have written this code is because we want
    to use it to ensure that we properly link up our generated JavaScript and the
    web page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些接口元素，我们就可以连接到keyup事件。当事件触发时，我们查看文本区域中是否有任何文本，并使用内容（如果存在）或空段落（如果不存在）设置标签的HTML。我们编写这段代码的原因是因为我们希望使用它来确保我们正确地链接生成的JavaScript和网页。
- en: We use the keyup event—rather than the keydown or keypress events—because the
    key is not added into the text area until the keypress event is completed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用keyup事件而不是keydown或keypress事件，因为在keypress事件完成之前，键不会添加到文本区域中。
- en: 'We can now revisit our web page and add the missing bits so that we can update
    our label when our text area changes. Just before the `</body>` tag, add the following
    to reference the JavaScript file that TypeScript produces, in order to create
    an instance of our `HtmlHandler` class and hook the `markdown` and `markdown-output`
    elements together:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重新访问我们的网页，并添加缺失的部分，以便在文本区域更改时更新我们的标签。在`</body>`标记之前，添加以下内容以引用TypeScript生成的JavaScript文件，以创建我们的`HtmlHandler`类的实例，并将`markdown`和`markdown-output`元素连接在一起：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a quick review, this is what the HTML file looks like at this point:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下，这是目前HTML文件的样子：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run our application at this point, typing in the text area automatically
    updates the label. The following screenshot shows what our application looks like
    in action:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这一点运行我们的应用程序，在文本区域中输入将自动更新标签。以下屏幕截图显示了我们的应用程序在操作时的样子：
- en: '![](assets/a9ef6ff7-6136-43b3-9684-ad5644531509.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9ef6ff7-6136-43b3-9684-ad5644531509.png)'
- en: Now we know that we can automatically update our web page, we have no more changes
    that need to be made to it. All the code that we are about to write will be done
    entirely in the TypeScript file. Going back to our list of requirements, we have
    done enough to satisfy the last three requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以自动更新我们的网页，我们不需要对其进行任何更改。我们即将编写的所有代码将完全在TypeScript文件中完成。回到我们的需求列表，我们已经做了足够的工作来满足最后三个需求。
- en: Mapping our markdown tag types to HTML tag types
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的markdown标记类型映射到HTML标记类型
- en: 'In our requirements, we set out a master list of tags that our parser is going
    to handle. In order to identify these tags, we are going to add an enumeration
    consisting of the tags we are making available to our users:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的需求中，我们列出了我们的解析器将处理的标记的主列表。为了识别这些标记，我们将添加一个包含我们向用户提供的标记的枚举：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From our requirements, we also know that we need to translate between these
    tags and their equivalent opening and closing HTML tags. The way that we are going
    to do this is to map `tagType` to an equivalent HTML tag. To do this, we are going
    to create a class that has the sole responsibility of handling this mapping for
    us. The following code shows this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们还知道我们需要在这些标记和它们的等效开放和关闭HTML标记之间进行转换。我们将要做的是将`tagType`映射到等效的HTML标记。为此，我们将创建一个专门负责处理此映射的类。以下代码显示了这一点：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At first, the use of `readonly` on a type can appear confusing. What this keyword
    means is that, after the class has been instantiated, `tagType` cannot be recreated
    elsewhere in the class. This means that we can set up our mappings in the constructor
    safe, knowing that we are not going to call `this.tagType = new Map<TagType, string>();`
    later on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在类型上使用`readonly`可能看起来令人困惑。这个关键字的意思是，在类被实例化之后，`tagType`不能在类的其他地方重新创建。这意味着我们可以在构造函数中设置我们的映射，知道我们不会在以后调用`this.tagType
    = new Map<TagType, string>();`。
- en: 'We also need a way to retrieve opening and closing tags from this class. We''re
    going to start by creating a method to get the opening tag from `tagType`, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来从这个类中检索开放和关闭标签。我们将首先创建一个方法来从`tagType`获取开放标签，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is pretty straightforward. It starts by trying to get `tagType`
    from the map. With the code we currently have, we will always have an entry in
    the map, but we could extend the enumeration in the future and forget to add the
    tag to the list of tags. That is why we check to see if the tag is present; if
    it is, we return the tag enclosed in `<>`. If the tag is not present, we return
    a paragraph tag as a default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单。它首先尝试从映射中获取`tagType`。根据我们目前的代码，我们将始终在映射中有一个条目，但是我们将来可能会扩展枚举并忘记将标记添加到标记列表中。这就是为什么我们要检查标记是否存在；如果存在，我们返回用`<>`括起来的标记。如果标记不存在，我们返回一个段落标记作为默认值。
- en: 'Now, let''s look at `ClosingTag`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`ClosingTag`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Looking at these two methods, we can see that they are almost identical. When
    we think about the problem of creating our HTML tag, we realize that the only
    difference between an opening and a closing tag is that the closing tag has a
    `/` in it. With that in mind, we can change the code to use a helper method that
    accepts whether the tag starts with `<` or `</`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这两种方法，我们可以看到它们几乎是相同的。当我们考虑创建HTML标记的问题时，我们意识到开放和关闭标记之间唯一的区别是关闭标记中有一个`/`。有了这个想法，我们可以改变代码，使用一个辅助方法，接受标记是否以`<`或`</`开头：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All that remains is for us to add methods to retrieve the opening and closing
    tags:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是添加方法来检索开放和关闭标签：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Pulling this all together, the code for our `TagTypeToHtml` class now looks
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些内容汇总起来，我们的`TagTypeToHtml`类的代码现在看起来像这样：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The single responsibility of our `TagTypeToHtml` class is mapping `tagType`
    to an HTML tag. Something that we are going to keep coming back to throughout
    this chapter is that we want classes to have a single responsibility. In OO theory,
    this is known as one of the principles of **SOLID** (short for **Single Responsibility
    Principle**, **Open/Closed Principle**, **Liskov Substitution Principle**, **Interface
    Segregation Principle**, **Dependency Inversion Principle**) design. The acronym
    refers to a set of complementary development techniques to create more robust
    code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`TagTypeToHtml`类的单一责任是将`tagType`映射到HTML标签。在本章中，我们将一直回到的一个问题是，我们希望类具有单一责任。在面向对象理论中，这被称为**SOLID**（单一责任原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则）设计原则之一。这个首字母缩略词指的是一组互补的开发技术，用于创建更健壮的代码。'
- en: This handy acronym serves to guide us on how to structure classes and the most
    important part, in my opinion, is the Single Responsibility Principle, which states
    that a class should do one thing and one thing only. While I would certainly recommend
    reading about this topic (and we will touch on other aspects of it as we progress),
    in my opinion, the most important part of SOLID design is that classes are responsible
    for one thing and one thing only; everything else flows out of that principle.
    Classes that only do one thing are generally much easier to test and they are
    a lot easier to understand. That does not mean that they should only have one
    method. They can have many methods, as long as they are all related to the purpose
    of the class. We will cover this topic again and again throughout the book because
    it is so important.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方便的首字母缩略词指导我们如何构建类和最重要的部分，在我看来，就是单一责任原则，它规定一个类应该只做一件事。虽然我肯定建议阅读这个主题（随着我们的进展，我们将涉及其他方面），但在我看来，SOLID设计最重要的部分是类只负责一件事；其他一切都源自这个原则。只做一件事的类通常更容易测试，也更容易理解。这并不意味着它们只能有一个方法。它们可以有很多方法，只要它们都与类的目的相关。因为这一点非常重要，所以我们将在整本书中一再涉及这个主题。
- en: Representing our converted markdown using a markdown document
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Markdown文档表示我们转换后的Markdown
- en: While we are parsing our content, we need a mechanism to actually store the
    text that we are creating during the parsing process. We could just use a global
    string and update it directly, but that would become problematic if we decided
    to asynchronously add to it later on. The main reason for not using a string is
    down to Single Responsibility Principle again. If we were using a simple string,
    then each piece of code that we add to the text would end up having to write to
    the string in the correct way, which means that they would be mixing reading the
    markdown with writing to the HTML output. When we discuss it like that, it becomes
    apparent that we need to have a separate means of writing the HTML content out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析内容的同时，我们需要一种机制来实际存储在解析过程中创建的文本。我们可以直接使用全局字符串并直接更新它，但如果我们决定以后异步添加内容，那将会变得很麻烦。不使用字符串的主要原因又回到了单一责任原则。如果我们使用简单的字符串，那么每个添加到文本的代码片段最终都要以正确的方式写入字符串，这意味着它们会将读取的Markdown与写入HTML输出混合在一起。当我们这样讨论时，显然我们需要另一种方式来输出HTML内容。
- en: 'What this means for us is that we are going to want code that can accept a
    number of strings to form the content (these could include our HTML tags, so we
    don''t want to just accept a single string). We also want a means of getting our
    document when we have finished building it up. We are going to start by defining
    an interface, which will act as the contract that consuming code will implement.
    Of particular interest here is that we are going to allow our code to accept any
    number of items in our `Add` method, so we will be using a REST parameter here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这意味着我们需要编写能够接受多个字符串以形成内容的代码（这些字符串可能包括我们的HTML标签，因此我们不希望只接受单个字符串）。我们还需要一种在构建完成后获取文档的方法。我们将首先定义一个接口，它将作为消费代码实现的契约。特别感兴趣的是，我们将允许我们的代码在`Add`方法中接受任意数量的项目，因此我们将在这里使用REST参数。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Given this interface, we can create our `MarkdownDocument` class as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个接口，我们可以创建我们的`MarkdownDocument`类如下：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class is incredibly straightforward. For each piece of content passed in
    to our `Add` method, we add it to a member variable called `content`. As this
    is declared as private, our `Get` method returns the same variable. This is why
    I like having classes with a single responsibility—in this case, they are just
    updating the content; they tend to be a lot cleaner and easier to understand than
    convoluted classes that do many different things. The main thing is that we can
    do whatever we like to keep our content updated internally, as we have hidden
    *how* we maintain the document from the consuming code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单。对于传递给我们的`Add`方法的每个内容片段，我们都将其添加到一个名为`content`的成员变量中。由于这被声明为私有，我们的`Get`方法返回相同的变量。这就是为什么我喜欢有单一责任的类——在这种情况下，它们只是更新内容；它们往往比做很多不同事情的复杂类更清晰、更容易理解。最重要的是，我们可以随心所欲地在内部保持我们的内容更新，因为我们已经将如何维护文档的细节隐藏在了消费代码之外。
- en: 'As we are going to be parsing our document one line at a time, we are going
    to use a class to represent the current line that we are processing:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将逐行解析文档，我们将使用一个类来表示我们正在处理的当前行：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our class is very simple. Again, we have decided not to go with a simple string
    to pass around our code base because this class makes our intent clear—we want
    to parse the current line. If we had just used a string to represent the line,
    it would be too easy to pass the wrong thing when we wanted to use the line.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类非常简单。同样，我们决定不使用简单的字符串在我们的代码库中传递，因为这个类清晰地表明了我们的意图——我们要解析当前行。如果我们只是使用一个字符串来表示行，当我们想要使用这行时，很容易传递错误的内容。
- en: Updating markdown document using visitors
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问者更新Markdown文档
- en: In [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features*, we briefly touched on patterns. Simply put, patterns in the software
    development process are general solutions to particular problems. This simply
    means that we use the name of a pattern to convey to others that we are solving
    a problem using particular and well-established code examples. For instance, if
    we say to another developer that we are solving a problem using a mediator pattern,
    as long as the other developer is aware of patterns, they will have a pretty good
    idea as to how we will be structuring our code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml)中，*高级TypeScript特性*，我们简要涉及了模式。简而言之，软件开发过程中的模式是特定问题的一般解决方案。这意味着我们使用模式的名称来向他人传达我们正在使用特定和成熟的代码示例来解决问题。例如，如果我们告诉另一个开发人员我们正在使用中介者模式来解决问题，只要另一个开发人员了解模式，他们就会对我们将如何构建我们的代码有一个很好的想法。
- en: When I was planning this code out, I made a conscious decision early on that
    we would be using something called the visitor pattern with our code. Before we
    look at the code we are going to create, we will have a look at what this pattern
    is and why we are going to use it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我规划这段代码时，我早早地做出了一个有意识的决定，即我们将在我们的代码中使用一种称为访问者模式的东西。在我们看看我们将要创建的代码之前，我们将看一下这种模式是什么，以及为什么我们要使用它。
- en: Understanding the visitor pattern
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解访问者模式
- en: The visitor pattern is what is known as a **behavioral pattern**. The term behavioral
    pattern is simply a classification of a group of patterns that are concerned with
    the way that classes and objects communicate. What the visitor pattern gives us
    is the ability to separate an algorithm from the object that the algorithm works
    on. This sounds a lot more complicated than it really is.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是所谓的**行为模式**。行为模式这个术语只是一组关于类和对象如何通信的模式的分类。访问者模式给我们的是能够将算法与算法作用的对象分离开来的能力。这听起来比实际情况复杂得多。
- en: 'One of the motivations behind us using the visitor pattern is that we want
    to take the common `ParseElement` class and apply different operations on it,
    depending on what the underlying markdown is, which ultimately leads to us building
    up the `MarkdownDocument` class. The idea here is that if the content the user
    types in is something we would represent in HTML as a paragraph, we want to add
    different tags to those used, for example, when the content represents a horizontal
    rule. The convention for the visitor pattern is that we have two interfaces, `IVisitor`
    and `IVisitable`. At their most basic, these interfaces look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用访问者模式的动机之一是，我们想对通用的`ParseElement`类应用不同的操作，这取决于底层的markdown是什么，最终导致我们构建`MarkdownDocument`类。这里的想法是，如果用户输入的内容是我们在HTML中表示为段落的内容，我们希望为其添加不同的标签，例如，当内容表示水平规则时。访问者模式的约定是我们有两个接口，`IVisitor`和`IVisitable`。在最基本的情况下，这些接口看起来像这样：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The idea behind these interfaces is that the object will be visitable, so when
    it needs to perform the relevant operations, it accepts the visitor so that it
    can visit the object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口的背后思想是对象将是可访问的，因此当它需要执行相关操作时，它接受访问者以便访问对象。
- en: Applying the visitor pattern to our code
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将访问者模式应用到我们的代码中
- en: 'Now that we know what the visitor pattern is, let''s take a look at how we
    are going to apply it to our code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了访问者模式是什么，让我们看看我们将如何将其应用到我们的代码中：
- en: 'First, we are going to create the `IVisitor` and `IVisitable` interfaces as
    follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`IVisitor`和`IVisitable`接口如下：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When our code reaches the point where `Visit` is called, we are going to use
    the `TagTypeToHtml` class to add the relevant opening HTML tag, the line of text,
    and then the matching closing HTML tag to our `MarkdownDocument`. As this is common
    to each of our tag types, we can implement a base class that encapsulates this
    behavior, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的代码达到调用`Visit`的点时，我们将使用`TagTypeToHtml`类将相关的开放HTML标签、文本行，以及匹配的闭合HTML标签添加到我们的`MarkdownDocument`中。由于这对于我们的每种标签类型都是通用的，我们可以实现一个封装这种行为的基类，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to add the concrete visitor implementations. This is as simple
    as creating the following classes:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加具体的访问者实现。这就像创建以下类一样简单：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At first, this code may seem like overkill, but it serves a purpose. If we
    take `Header1Visitor`, for instance, we have a class that has the single responsibility
    of taking the current line and adding it to our markdown document wrapped in H1
    tags. We could litter our code with classes that were responsible for checking
    whether the line started with #, and then remove the # from the start, prior to
    adding the H1 tags and the current line. However, that makes the code harder to
    test and more likely to break, especially if we want to change the behavior. Also,
    the more tags we add, the more fragile this code will become.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这段代码可能看起来有些多余，但它有其目的。例如，如果我们看`Header1Visitor`，我们有一个类，它的单一责任是获取当前行并将其添加到我们的markdown文档中，用H1标签包裹起来。我们可以在代码中散布许多负责检查行是否以#开头的类，然后在添加H1标签和当前行之前删除#。然而，这样会使代码更难测试，更容易出错，特别是如果我们想要改变行为。此外，我们添加的标签越多，这段代码就会变得越脆弱。
- en: 'The other side of the visitor pattern code is the `IVisitable` implementation. For
    our current code, we know that we want to visit the relevant visitor whenever
    we call `Accept`. What this means to our code is that we can have a single visitable
    class that implements our `IVisitable` interface. This is shown in the following
    code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式代码的另一面是`IVisitable`的实现。对于我们当前的代码，我们知道每当调用`Accept`时，我们都希望访问相关的访问者。对我们的代码来说，这意味着我们可以有一个单一的可访问类来实现我们的`IVisitable`接口。以下是示例代码：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For this example, we have put the simplest visitor pattern implementation in
    place that we could. There are many variants of the visitor pattern, so we have
    gone with an implementation that respects the design philosophy of the pattern
    without slavishly sticking to it. That's the beauty of patterns—while they give
    us a guide as to how to do something, we should not feel that we have to blindly
    follow a particular implementation if modifying it slightly differently suits
    our needs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们已经放置了最简单的访问者模式实现。访问者模式有许多变体，所以我们选择了一种尊重模式设计哲学的实现，而不是盲目地坚持它。这就是模式的美妙之处——虽然它们指导我们如何做某事，但我们不应该觉得必须盲目地遵循特定的实现，如果稍微修改它可以满足我们的需求。
- en: Deciding which tags to apply by using the chain-of-responsibility pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用责任链模式决定应用哪些标签
- en: Now that we have the means to transform a simple line into an HTML encoded line,
    we need a way to decide which tags we should apply. Right from the start, I knew
    that we would be applying yet another pattern, one that is eminently suitable
    for asking the question, "*Should I handle this tag?*" If no, then I will forward
    this on so that something else can decide whether or not it should handle the
    tag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将简单行转换为HTML编码行的方法，我们需要一种方法来决定应该应用哪些标签。从一开始，我就知道我们将应用另一种模式，这种模式非常适合提出问题：“*我应该处理这个标签吗？*”如果不应该，那么我将把这个问题转发出去，让其他东西决定是否应该处理这个标签。
- en: We are going to use another behavioral pattern to handle this—the chain-of-responsibility
    pattern. This pattern lets us chain together a series of classes by creating a
    class that accepts the next class in the chain, along with a method to handle
    a request. Depending on the internal logic of the request handler, it may pass
    processing onto the next class in the chain.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一种行为模式来处理这个问题——责任链模式。这种模式让我们通过创建一个接受链中下一个类的类，以及一个处理请求的方法，来将一系列类链接在一起。根据请求处理程序的内部逻辑，它可能将处理传递给链中的下一个类。
- en: 'If we start off with our base class, we can see what this pattern gives us
    and how we are going to use it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从基类开始，我们可以看到这种模式给了我们什么，以及我们将如何使用它：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The next class in our chain is set using `SetNext`. `HandleRequest` works by
    calling our abstract `CanHandle` method to see whether the current class can handle
    the request. If it cannot handle the request and if `this.next` is not `null`
    (note the use of union types here), we forward the request onto the next class.
    This is repeated until we can either handle the request or `this.next` is `null`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链中的下一个类是使用`SetNext`设置的。`HandleRequest`通过调用我们的抽象`CanHandle`方法来查看当前类是否能够处理请求。如果它无法处理请求，并且`this.next`不是`null`（注意这里使用了联合类型），我们将请求转发到下一个类。这样重复进行，直到我们可以处理请求或`this.next`为`null`。
- en: 'We can now add a concrete implementation of our `Handler` class. First, we
    will add our constructor and member variables, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的`Handler`类的具体实现。首先，我们将添加我们的构造函数和成员变量，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our constructor accepts the instance of the markdown document; the `string`
    that represents our `tagType`, for example, *#;* and the relevant visitor will
    visit the class if we get a matching tag. Before we see what the code for `CanHandle`
    looks like, we need to take a slight detour and introduce a class that will help
    us parse the current line and see if the tag is present at the start.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数接受markdown文档的实例；表示我们的`tagType`的`string`，例如，*#;*；如果我们得到匹配的标签，相关的访问者将访问该类。在看看`CanHandle`的代码之前，我们需要稍微绕个弯，介绍一个将帮助我们解析当前行并查看标签是否出现在开头的类。
- en: 'We are going to create a class that exists purely to parse the string, and
    looks to see if it starts with the relevant markdown tag. What is special about
    our `Parse` method is that we are returning something called a **tuple**. We can
    think of a tuple as a fixed-size array that can have different types at different
    positions in the array. In our case, we are going to return a `boolean` type and
    a `string` type. The `boolean` type indicates whether or not the tag was found,
    and the `string` type will return the text without the tag at the start; for example,
    if the `string` was `# Hello` and the tag was `#` , we would want to return `Hello`.
    The code that checks for the tag is very straightforward; it simply looks to see
    if the text starts with the tag. If it does, we set the `boolean` part of our
    tuple to `true` and use `substr` to get the remainder of our text. Consider the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个纯粹用于解析字符串的类，并查看它是否以相关的markdown标签开头。我们的`Parse`方法的特殊之处在于我们返回了一个**元组**。我们可以将元组视为一个固定大小的数组，在数组的不同位置可以有不同类型。在我们的情况下，我们将返回一个`boolean`类型和一个`string`类型。`boolean`类型表示标签是否被找到，`string`类型将返回不带标签的文本开头；例如，如果`string`是`#
    Hello`，标签是`#`，我们希望返回`Hello`。检查标签的代码非常简单；它只是查看文本是否以标签开头。如果是，我们将元组的`boolean`部分设置为`true`，并使用`substr`获取我们文本的其余部分。考虑以下代码：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have our `LineParser` class, we can apply that in our `CanHandle`
    method as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`LineParser`类，我们可以在我们的`CanHandle`方法中应用它：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are using our parser to build a tuple where the first parameter states
    whether or not the tag was present, and the second parameter contains the text
    without the tag if the tag was present. If the markdown tag was present in our
    string, we call the `Accept` method on our `Visitable` implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的解析器构建一个元组，第一个参数说明标签是否存在，第二个参数包含不带标签的文本（如果标签存在）。如果我们的字符串中存在markdown标签，我们调用我们的`Visitable`实现的`Accept`方法。
- en: Strictly speaking, we could have directly called `this.visitor.Visit(request,
    this.document);`, however, that provides us with more knowledge about how to perform
    the visit into this class than I would like. By using the `Accept` approach, if
    we make our visitors more complex, we avoid having to revisit this method as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们本可以直接调用 `this.visitor.Visit(request, this.document);`，但是，这会让我们对如何访问这个类有更多的了解，而我不希望如此。通过使用“接受”方法，如果我们的访问者更复杂，我们就避免了不得不重新访问这个方法的情况。
- en: 'This is what our `ParseChainHandler` looks like now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`ParseChainHandler`看起来是这样的：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have a special case that we need to handle. We know that the paragraph has
    no tag associated with it—if there are no matches through the rest of the chain,
    by default, it''s a paragraph. This means that we need a slightly different handler
    to cope with paragraphs, shown as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个特殊情况需要处理。我们知道段落没有与之关联的标签——如果在链的其余部分没有匹配项，那么默认情况下是一个段落。这意味着我们需要一个稍微不同的处理程序来处理段落，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this infrastructure in place, we are now ready to create the concrete
    handlers for the appropriate tags as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基础设施，我们现在可以为适当的标签创建具体的处理程序，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have a route through from the tag, for example, `---`,to the appropriate
    visitor. We have now linked our chain-of-responsibility pattern to our visitor
    pattern. We have one final thing that we need to do: set up the chain. To do this,
    let''s use a separate class that builds our chain:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从标签，例如`---`，到适当的访问者有了一条路径。我们现在将我们的责任链模式与访问者模式联系起来。我们还有最后一件事要做：设置链。为此，让我们使用一个单独的类来构建我们的链：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This simple-looking method accomplishes a lot for us. The first few statements
    initialize the chain-of-responsibility handlers for us; first for the headers,
    then for the horizontal rule, and finally for the paragraph handler. Remembering
    that this is only part of what we need to do here, we then go through the headers
    and the horizontal rule and set up the next item in the chain. Header 1 will forward
    calls on to header 2, header 2 forwards to header 3, and so on. The reason we
    don't set any further chained items after the paragraph handler is because that
    is the last case we want to handle. If the user isn't typing `header1`, `header2`,
    `header3`, or `horizontalRule`, then we're going to treat this as a paragraph.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似简单的方法为我们做了很多事情。前几个语句为我们初始化了责任链处理程序；首先是标题，然后是水平线，最后是段落处理程序。记住这只是我们需要在这里做的一部分，然后我们遍历标题和水平线，并设置链中的下一个项目。标题1将调用转发到标题2，标题2转发到标题3，依此类推。我们之所以在段落处理程序之后不设置任何进一步的链接项，是因为那是我们想要处理的最后一种情况。如果用户没有输入`header1`、`header2`、`header3`或`horizontalRule`，那么我们将把它视为段落。
- en: Bringing it all together
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'The last class that we are going to write is used to take the text that the
    user is typing in and split it into individual lines, and create our `ParseElement`,
    chain-of-responsibility handlers, and `MarkdownDocument` instance. Each line is
    then forwarded to `Header1ChainHandler` to start the processing of the line. Finally,
    we get the text from the document and return it so that we can display it in the
    label:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写的最后一个类用于接收用户输入的文本并将其拆分为单独的行，并创建我们的`ParseElement`、责任链处理程序和`MarkdownDocument`实例。然后，每一行都被转发到`Header1ChainHandler`来开始处理该行。最后，我们从文档中获取文本并返回它，以便我们可以在标签中显示它：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we can generate our HTML content, we have one change left to do. We
    are going to revisit the `HtmlHandler` method and change it so that it calls our `ToHtml`
    markdown method. At the same time, we are going to address an issue with our original
    implementation where refreshing the page loses our content until we press a key.
    To handle this, we are going to add a `window.onload` event handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成我们的HTML内容，还有一件事要做。我们将重新访问`HtmlHandler`方法，并更改它，以便调用我们的`ToHtml` markdown方法。同时，我们还将解决原始实现中的一个问题，即刷新页面会导致我们的内容丢失，直到我们按下一个键。为了解决这个问题，我们将添加一个`window.onload`事件处理程序：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, when we run our application, it displays the rendered HTML content, even
    when we refresh our page. We have successfully created a simple markdown editor
    that satisfies the points that we laid out in our requirements, gathering stage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的应用程序时，即使刷新页面，它也会显示渲染后的HTML内容。我们已经成功地创建了一个简单的Markdown编辑器，满足了我们在需求收集阶段制定的要点。
- en: I cannot stress enough how important the requirements, gathering stage is. All
    too often, poor requirements lead to us having to make assumptions about the behavior
    of an application. These assumptions can lead to delivering an application that
    users do not want. If you find yourself making an assumption, go back and ask
    your users exactly what they want. As we built our code here, we referred back
    to our requirements to make sure that we were building exactly what we were meant
    to build.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法再次强调需求收集阶段有多么重要。往往，糟糕的需求会导致我们不得不对应用程序的行为进行假设。这些假设可能导致交付给用户不想要的应用程序。如果你发现自己在做假设，请回去问问用户他们到底想要什么。在构建代码时，我们参考了我们的需求，以确保我们正在构建确切的东西。
- en: A final point about requirements—they change. It is common for requirements
    to evolve or get removed while we are writing an application. When they do change,
    we make sure that the requirements are updated, that we are making no assumptions,
    and that we check the work that has already been produced to make sure that it
    matches the updated requirements. This is what we do because we are professionals.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于需求的最后一点——它们会变化。在编写应用程序时，需求通常会发生变化或被删除。当它们发生变化时，我们确保更新了需求，不做任何假设，并检查已经产生的工作，以确保它符合更新后的需求。这是我们作为专业人士所做的。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have built an application that responded to what the user
    was typing into a text area, and updated a label with converted text. The conversion
    of this text was handled by classes, each of which had a single responsibility.
    The reason we concentrated on producing classes that only did one thing was to
    learn, right from the start, how to use industry best practices to make our code
    cleaner and less prone to errors, since a well-designed class that only does one
    thing is less likely to have problems than classes that do lots of different things.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个应用程序，根据用户在文本区域中输入的内容做出响应，并使用转换后的文本更新标签。这些文本的转换由各自负责的类处理。我们专注于创建只做一件事情的类的原因是为了从一开始就学习如何使用行业最佳实践，使我们的代码更清晰，更不容易出错，因为一个设计良好的只做一件事情的类比做很多不同事情的类更不容易出问题。
- en: We introduced the visitor and chain-of-responsibility patterns in order to see
    how we could separate the text processing into deciding whether a line contained
    markdown and adding the appropriate HTML-encoded text. We started introducing
    patterns because patterns occur in so many different software development problems.
    Not only do they provide clear details about how to solve a problem; they also
    provide a clear language so that if someone says that a piece of code needs a
    particular pattern, there is no ambiguity for other developers about what that
    code needs to do.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了访问者和责任链模式，以便看到如何将文本处理分离为决定一行是否包含Markdown并添加适当的HTML编码文本。我们开始引入模式，因为模式在许多不同的软件开发问题中都会出现。它们不仅提供了如何解决问题的清晰细节；它们还提供了一种清晰的语言，因此如果有人说一段代码需要特定的模式，其他开发人员就不会对该代码需要做什么产生歧义。
- en: In the next chapter, we are going to look at our first application using React.js,
    for when we build a personal contacts manager.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用React.js来构建我们的第一个应用程序，用于构建个人联系人管理器。
- en: Questions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The application currently only reacts to the user changing the content using
    the keyboard. It is possible that the user could use the context menu to paste
    the text in. Enhance the `HtmlHandler` method to cope with the user pasting text
    in.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该应用程序目前只对用户使用键盘更改内容做出反应。用户也可能使用上下文菜单粘贴文本。增强`HtmlHandler`方法以处理用户粘贴文本。
- en: We added H1 to H3 support. HTML also supports H4, H5, and H6\. Add support for
    these tags.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了对H1到H3的支持。HTML还支持H4、H5和H6。添加对这些标签的支持。
- en: In the `CanHandle` code, we are calling the `Visitable` code. Change the base
    `Handler` class so that it calls the `Accept` method.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CanHandle`代码中，我们正在调用`Visitable`代码。更改基本的`Handler`类，以便调用`Accept`方法。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For further information about using design patterns, I would recommend the book
    *TypeScript Design Patterns (*[https://www.packtpub.com/application-development/typescript-design-patterns](https://www.packtpub.com/application-development/typescript-design-patterns))
    by Vilic Vane, published by Packt.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用设计模式的更多信息，我建议阅读Vilic Vane撰写的书籍*TypeScript Design Patterns*（[https://www.packtpub.com/application-development/typescript-design-patterns](https://www.packtpub.com/application-development/typescript-design-patterns)），由Packt出版。
