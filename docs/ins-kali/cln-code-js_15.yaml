- en: Real-World Challenges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界的挑战
- en: Many challenges a JavaScript programmer faces may not be with the language itself
    but with the ecosystems that their code must exist within and interface with.
    JavaScript is usually used in the context of the web, on either a browser or server,
    and so the problem domains encountered are usually characterized by topics such
    as HTTP and the DOM. We often have to wrestle with frameworks, APIs, and mechanisms
    that can sometimes seem awkward, unintuitive, and complicated. In this chapter,
    we're going to familiarize ourselves with some of the most common challenges and
    the approaches and abstractions we can use to surmount them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序员面临的许多挑战可能不在于语言本身，而在于他们的代码必须存在并与之交互的生态系统。JavaScript通常用于Web的上下文中，无论是在浏览器还是服务器上，因此遇到的问题领域通常以HTTP和DOM等主题为特征。我们经常不得不应对有时似乎笨拙、不直观和复杂的框架、API和机制。在本章中，我们将熟悉一些最常见的挑战以及我们可以使用的方法和抽象来克服它们。
- en: We will begin by exploring the DOM and the challenges inherent in building ambitious
    **Single-Page Applications** (**SPAs**) in JavaScript. We'll then explore the
    topics of **dependency management** and **security** as these are both increasingly
    vital competencies in today's landscape. This chapter is not intended as an exhaustive
    coverage of topics, but rather a quick whirlwind of deep-dives that you may find
    relevant to the weighty task of crafting clean JavaScript on today's web platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨DOM和在JavaScript中构建雄心勃勃的单页应用程序（SPA）时固有的挑战。然后，我们将探讨依赖管理和安全性等主题，因为这些在当今的环境中变得越来越重要。本章并不旨在详尽覆盖所有主题，而是快速深入探讨，您可能会发现这些对于在当今的Web平台上编写干净的JavaScript的重要任务是相关的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The DOM and single-page applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM和单页应用程序
- en: Dependency management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Security (XSS, CSRF, and so on)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性（XSS、CSRF等）
- en: The DOM and single-page applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM和单页应用程序
- en: The **Document Object Model** (**DOM**) API is provided within browsers to allow
    developers to read from and dynamically mutate web documents. Upon its initial
    introduction in 1997, it was very limited in scope but has expanded greatly in
    the last two decades, allowing us to now have programmatic access to a wide variety
    of browser functionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型（DOM）API是浏览器提供的，允许开发人员读取和动态改变Web文档。在1997年首次引入时，它的范围非常有限，但在过去的20年里已经大大扩展，使我们现在可以以编程方式访问各种浏览器功能。
- en: 'The DOM itself presents us with a hierarchy of elements that are derived from
    the parsed HTML of a given page. This hierarchy is made accessible to JavaScript
    via an API. This API allows us to select elements, traverse trees of elements,
    and inspect element properties and characteristics. Here is an example of a DOM
    tree with the corresponding JavaScript used to access it:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DOM本身向我们展示了从给定页面的解析HTML中派生出的元素的层次结构。通过API，JavaScript可以访问这个层次结构。这个API允许我们选择元素，遍历元素树，并检查元素的属性和特征。以下是一个DOM树的示例，以及用于访问它的相应JavaScript：
- en: '![](assets/e30de7af-6916-41c0-b2ab-0059d0644e66.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e30de7af-6916-41c0-b2ab-0059d0644e66.png)'
- en: The way we access specific DOM nodes has changed over the years but its fundamental
    tree-like structure has remained the same. Via access to this structure, we can
    read from the elements, mutate them, or indeed add to the tree of elements ourselves.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们访问特定DOM节点的方式已经发生了变化，但其基本的树状结构仍然保持不变。通过访问这个结构，我们可以从元素中读取、改变它们，或者确实向元素树中添加内容。
- en: Alongside the DOM API is a collection of other natively provided browser APIs
    that make it possible to do things such as reading cookies, mutating local storage,
    setting up background tasks (*workers*), and operating on the **CSS Object Model**
    (**CSSOM**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了DOM API之外，还有一系列其他由浏览器原生提供的API，使得可以进行诸如读取cookie、改变本地存储、设置后台任务（*workers*）以及操作CSS对象模型（CSSOM）等操作。
- en: As recently as the year 2012, it was quite typical for web developers to only
    use JavaScript to enhance experiences already manifested in the markup of a page.
    For example, they might've simply added a rollover state to a button or validation
    to a form field. Such additions were considered a type of *progressive enhancement*,
    where the user could experience the website without JavaScript if they wanted
    but having JavaScript enabled would enhance their experience in some small way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就在2012年，Web开发人员通常只使用JavaScript来增强已经在页面标记中体现的体验。例如，他们可能只是为按钮添加了一个鼠标悬停状态，或者为表单字段添加了验证。这些增强被认为是一种*渐进增强*的类型，用户可以选择在没有JavaScript的情况下体验网站，但启用JavaScript会在某种程度上增强他们的体验。
- en: '**Progressive enhancement** is a principle that espouses the importance of
    functionality that is resilient to environmental constraints. It tells us that
    we should try to provide all users with as much functionality as their environment
    allows. It is often conceptually paired with **graceful** **d****egradation**,
    which is the ability for a piece of software to maintain limited functionality
    even when its dependencies are unmet or only partially met (for example, a client-side
    validated `<form>` that is submittable even on browsers without JavaScript support
    is said to *gracefully degrade*).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强是一个主张功能对环境约束具有弹性的原则。它告诉我们，我们应该尽量为所有用户提供尽可能多的功能，以适应他们的环境。它通常与优雅降级的概念相配对，即软件在其依赖未满足或部分满足时仍能保持有限的功能（例如，即使在没有JavaScript支持的浏览器上，客户端验证的<form>也可以提交，这被称为*优雅降级*）。
- en: Nowadays, however, it is far more common to have the frontend portion of a web
    application built almost entirely with JavaScript and expressed within a single
    *page*. These are often termed SPAs. Instead of having the user naturally navigate
    around a website, loading up new pages within the browser upon each action, the
    SPA will instead rewrite the current page's content and the current browser address.
    SPAs are therefore dependent upon the user's browser supporting JavaScript and
    potentially other APIs too. SPAs typically do not gracefully degrade, although
    it is best practice (and good sense!) to provide a series of fallbacks so that
    the entire audience can receive functionality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，前端部分几乎完全由JavaScript构建，并在单个*页面*中表达。这些通常被称为SPA。与让用户自然地在网站上导航，每次操作都在浏览器中加载新页面不同，SPA将重写当前页面的内容和当前浏览器地址。因此，SPA依赖于用户的浏览器支持JavaScript，可能还有其他API。SPA通常不会优雅地退化，尽管最佳做法（和明智之举！）是提供一系列备用方案，以便整个受众都能接收功能。
- en: 'The proliferation of the SPA can be attributed to both developer experience
    and user experience boosts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SPA的普及可以归因于开发者体验和用户体验的提升：
- en: '**Architecture (DX)**: There is a nicer *separation of concerns* between the
    frontend client and the backend API layer. This can lead to a cleaner architecture
    that helpfully delineates *business logic* from UI. Having one code base that
    governs both the rendering and dynamic enhancement can vastly simplify things
    as well.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构（DX）**：前端客户端和后端API层之间有更好的*关注点分离*。这可以导致更清晰的架构，有助于将*业务逻辑*与UI区分开来。拥有一个统一的代码库来管理渲染和动态增强可以大大简化事情。'
- en: '**State persistence (UX)**: Users can navigate and execute actions within a
    web application without having to lose in-page state, such as populated input
    fields or scroll-position. Additionally, the UX can include multiple different
    panes, modals, or sections that populate independently and can be persisted regardless
    of other actions taken.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态持久性（UX）**：用户可以在Web应用程序中导航和执行操作，而无需丢失页面状态，例如填充的输入字段或滚动位置。此外，UX可以包括多个不同的窗格、模态框或部分，这些部分可以独立填充并且可以在采取其他操作时保持不变。'
- en: '**Performance (UX)**: The bulk of HTTP resources can be loaded just once within
    the user''s browser, increasing the performance of any further actions or navigations
    within the application. That is, after the initial load of the application, any
    further requests can be optimized to be simple JSON REST responses with no unnecessary
    boilerplate markup so the browser spends less time re-parsing or re-rendering
    boilerplate HTML, CSS, and JavaScript.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能（UX）**：大部分HTTP资源可以在用户的浏览器中加载一次，提高应用程序内进一步操作或导航的性能。也就是说，在应用程序初始加载后，任何进一步的请求都可以优化为简单的JSON
    REST响应，没有不必要的样板标记，因此浏览器花费更少的时间重新解析或重新渲染样板HTML、CSS和JavaScript。'
- en: The growing demands on web applications and the proliferation of the SPA have
    meant that programmers have come to rely much more on browser APIs, especially
    the DOM, to create rich and dynamic experiences. The painful truth, however, is
    that the DOM was never intended to cater to the creation of rich desktop-like
    experiences. Because of this, there have been many growing pains in bringing the
    DOM up to scratch with current demands. Additionally, there has been a slow and
    iterative process of creating frameworks that enable the development of rich experiences
    atop a platform that was not originally designed for them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对Web应用程序的不断增长的需求和SPA的普及意味着程序员更多地依赖浏览器API，特别是DOM，来创建丰富和动态的体验。然而，痛苦的事实是，DOM从未打算满足创建丰富类似桌面的体验。因此，在使DOM符合当前需求方面存在许多成长的痛苦。此外，还存在一个缓慢和迭代的过程，即创建能够在最初未设计用于它们的平台上实现丰富体验的框架。
- en: One of the most obvious ways in which the DOM (and browser APIs generally) does
    not meet the current demands of SPAs is experienced when trying to *bind the DOM
    to data*. We will now explore this topic in more depth.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试*将DOM绑定到数据*时，DOM（以及浏览器API一般）无法满足SPA当前的需求，这是最明显的方式。我们现在将更深入地探讨这个话题。
- en: DOM binding and reconciliation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM绑定和协调
- en: One specific challenge that multiple frameworks have attempted to solve over
    the years is the *binding* of the DOM to data. We briefly discussed data-binding
    in the last chapter's section on MVVM. Any GUI needs to have a way of having its
    displayed pixels reflect its underlying data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 多个框架多年来尝试解决的一个具体挑战是将DOM与数据*绑定*起来。我们将在接下来更深入地探讨这个话题。
- en: Via the DOM, we can dynamically create specific elements and place them as we
    wish. The user can then impose their intent on the application by interfacing
    with these elements, usually via input fields and buttons. These user actions,
    which we bind to via DOM events, may then affect a change in underlying data.
    This change needs to be reflected in the DOM. This *back-and-forth* is usually
    termed *two-way-binding.* Historically, to achieve this, we would manually create
    a DOM tree, set up event listeners on elements, and then manually mutate those
    DOM elements when any underlying data (or *state*) changed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过DOM，我们可以动态创建特定元素并根据需要放置它们。然后用户可以通过与这些元素进行交互来对应用程序施加他们的意图，通常是通过输入字段和按钮。这些用户操作，我们通过DOM事件进行绑定，然后可能会影响底层数据的变化。这种变化需要在DOM中反映出来。这种*来回*通常被称为*双向绑定*。从历史上看，为了实现这一点，我们通常会手动创建DOM树，在元素上设置事件监听器，然后在任何底层数据（或*状态*）发生变化时手动改变这些DOM元素。
- en: '**A reminder**: *State* is the current *situation* of a program: everything
    the user sees and everything that underlies what they see. The *state* of a given
    application may be represented in more than one place, and these representations
    may become out-of-sync. We can imagine a scenario in which the same data is displayed
    in two places but is not consistent.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**提醒**：*状态*是程序的当前*情况*：用户看到的一切以及支持他们所看到的一切。给定应用程序的*状态*可以在多个位置表示，并且这些表示可能变得不同步。我们可以想象这样一种情况，即相同的数据显示在两个地方，但不一致。'
- en: The challenge in manually fiddling with the DOM ourselves is that it doesn't
    scale very well without some kind of abstraction. It is easy enough to take a
    piece of data and derive a DOM tree from that data, but having the DOM tree tied
    to changes within the data and having the data tied to user-derived changes in
    the DOM (for example, clicking on buttons) are quite burdensome things to implement.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动操作DOM的挑战在于，没有某种抽象，它就无法很好地扩展。很容易从数据中获取DOM树，但是将DOM树与数据内部的更改联系起来，并且将数据与用户导出的DOM更改联系起来（例如，单击按钮）是相当繁琐的事情。
- en: DOM reconciliation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM协调
- en: 'To illustrate this challenge, consider a simple shopping list in the form of
    an array composed of individual items as strings:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一挑战，考虑一个简单的购物清单，由字符串组成的数组形式：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Deriving a DOM tree from this data is quite simple:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据中派生DOM树非常简单：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code would produce the following DOM tree (and append it to `<body>`):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成以下DOM树（并将其附加到`<body>`）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But what happens if our data changes? And what would happen if there were `<input>`
    via which users could add new items? To accommodate these things, we would have
    to implement an abstraction to hold our data and raise events (or invoke callbacks)
    whenever the data changes. Additionally, we''d need some way of tying each individual
    data item to a DOM node. If the first item, `"Bananas"` were to be changed to
    `"Melons"`, then we should only make the minimum mutations necessary to the DOM
    to reflect that change. In this case, we would want to replace the first `<li>`
    element''s inner text node''s `data` property (in other words, the actual text
    contained within the text node):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们的数据发生了变化会发生什么呢？如果有`<input>`，用户可以通过它添加新项目会发生什么？为了适应这些情况，我们需要实现一个抽象来保存我们的数据，并在数据更改时引发事件（或调用回调）。此外，我们需要一种将每个单独的数据项与DOM节点联系起来的方法。如果第一项“香蕉”更改为“甜瓜”，那么我们应该只对DOM进行最小的变化以反映这种变化。在这种情况下，我们希望替换第一个`<li>`元素的内部文本节点的`data`属性（换句话说，文本节点中包含的实际文本）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This type of change, in abstract terms, is known as *DOM reconciliation* and
    involves reflecting any changes made to data within the DOM. There are broadly
    three types of reconciliation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象术语中，这种类型的更改被称为*DOM协调*，涉及反映在DOM中对数据所做的任何更改。协调主要有三种类型：
- en: '**Update**: If an existing data item is updated, then the corresponding DOM
    node should be updated to reflect the change'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：如果更新现有的数据项，则应更新相应的DOM节点以反映更改'
- en: '**Deletion**: If an existing data item is removed, then the corresponding DOM
    node should also be removed'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：如果删除现有的数据项，则相应的DOM节点也应该被删除'
- en: '**Creation**: If a new data item is added, then a new DOM node should be created,
    appended to the correct place in the live DOM tree, and then linked as the corresponding
    DOM node for that data item'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：如果添加了新的数据项，则应创建一个新的DOM节点，将其附加到实时DOM树的正确位置，然后将其链接为该数据项的相应DOM节点'
- en: DOM reconciliation is a relatively simple process. We could easily create `ShoppingListComponent`
    ourselves with the ability to update/add/remove items, but it would be very highly
    coupled to the structure of the data and the DOM. The logic pertaining just to
    a singular update may involve, as we've seen, the specific mutation of a text
    node's content. If we want to change our DOM tree slightly or the structure of
    our data, then we have to significantly refactor our `ShoppingListComponent`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DOM协调是一个相对简单的过程。我们可以很容易地自己创建`ShoppingListComponent`，并具有更新/添加/删除项目的功能，但它将与数据和DOM的结构高度耦合。仅涉及单个更新的逻辑可能涉及，正如我们所见，特定文本节点内容的具体变化。如果我们想稍微更改DOM树或数据结构，那么我们必须显着重构我们的`ShoppingListComponent`。
- en: React's approach
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React的方法
- en: Many modern libraries and frameworks have sought to make this a less burdensome
    process by abstracting the DOM reconciliation process away behind a declarative
    interface. A good example of this is React, which allows you to declare your DOM
    tree declaratively using its JSX syntax within your JavaScript. JSX looks like
    regular HTML with the addition of interpolation delimiters (`{...}`) where regular
    JavaScript can be written to express data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代库和框架试图通过在声明性接口的背后抽象DOM协调过程来减轻这一过程的负担。React就是一个很好的例子，它允许您使用其JSX语法在JavaScript中声明DOM树。JSX看起来像常规的HTML，其中添加了插值分隔符（`{...}`），可以在其中编写常规JavaScript来表示数据。
- en: 'Here, we are creating a component that produces a simple `<h1>` greeting populated
    with an uppercase `name`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个组件，它生成一个简单的带有大写`name`的`<h1>`问候语：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `LoudGreeting` component could be rendered to `<body>` like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoudGreeting`组件可以这样渲染到`<body>`中：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And that would result in the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会得到以下结果：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We might implement a `ShoppingList` component in the following way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式实现`ShoppingList`组件：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then we could render it in the following way, passing our specific shopping
    list items in our invocation of the component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以以以下方式渲染它，通过在组件的调用中传递我们特定的购物清单项目：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a simple example but gives us an idea of how React works. The true magic
    of React is in its ability to selectively re-render the DOM in reaction to changes
    in data. We can explore this in our example by changing data in reaction to a
    user action.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，但它让我们了解了React的工作原理。React真正的魔力在于它有能力根据数据的更改有选择性地重新渲染DOM。我们可以通过在用户操作时更改数据来探索这一点。
- en: 'React and most other frameworks give us a straightforward mechanism of event-listening
    so that we can listen for user events in the same manner as we would conventionally.
    Via React''s JSX, we can do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: React和大多数其他框架为我们提供了一个直接的事件监听机制，这样我们就可以以与传统方式相同的方式监听用户事件。通过React的JSX，我们可以做到以下几点：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our case of the shopping list problem domain, we want to create `<input
    />`, which can receive new items from users. To accomplish this, we can create
    a separate component called `ShoppingListAdder`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的购物清单问题领域中，我们想要创建一个`<input />`，它可以接收用户的新项目。为了实现这一点，我们可以创建一个名为`ShoppingListAdder`的单独组件：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are using a React Hook (called `useRef`) to give us a persistent reference
    that we can re-use between component renders to reference our `<input />`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个React Hook（称为`useRef`）来给我们一个持久的引用，我们可以在组件渲染之间重复使用来引用我们的`<input />`。
- en: '**React Hooks** (typically named `use[Something]`) are a relatively recent
    addition to React. They''ve simplified the process of keeping persistent state
    across component renders. A re-render occurs whenever our `ShoppingListAdder`
    function is invoked. But `useRef()` will return the same reference on every single
    call within `ShoppingListAdder`. A singular React Hook can be thought of as the
    *Model* in MVC.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Hooks**（通常命名为`use[Something]`）是React的一个相对较新的添加。它们简化了在组件渲染中保持持久状态的过程。每当我们调用`ShoppingListAdder`函数时，都会发生重新渲染。但是`useRef()`将在`ShoppingListAdder`中的每次调用中返回相同的引用。一个单一的React
    Hook可以被认为是MVC中的*模型*。'
- en: 'To our `ShoppingListAdder` component, we are passing an `onAdd` callback, which
    we can see is called whenever the user has added a new item (in other words, when
    the `<form>` submits). To make use of a new component, we want to place it within
    `ShoppingList` and then respond when `onAdd` is invoked by adding a new item to
    our list of food:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`ShoppingListAdder`组件，我们传递了一个`onAdd`回调，我们可以看到每当用户添加了一个新项目（换句话说，当`<form>`提交时）时，它就会被调用。为了使用一个新组件，我们想把它放在`ShoppingList`中，然后在调用`onAdd`时做出响应，向我们的食品列表中添加一个新项目：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we are using another type of React Hook called `useState` to
    persist the storage of our items. `initialItems` can be passed into our component
    (as an argument) but we then derive a set of persistent items from these that
    we can mutate freely across re-renders of our component. And that''s what our
    `onAdd` callback is doing: it is adding a new item (entered by the user) to the
    current list of items:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用了另一种称为`useState`的React Hook来持久存储我们的项目。`initialItems`可以被传递到我们的组件中（作为参数），但我们可以从中派生一组持久项目，可以在我们的组件重新渲染时自由地改变。这就是我们的`onAdd`回调所做的事情：它将一个新项目（由用户输入）添加到当前项目列表中：
- en: '![](assets/34c61e29-1f0f-445c-9c15-1f7fcbcf5027.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34c61e29-1f0f-445c-9c15-1f7fcbcf5027.png)'
- en: Calling `setItems` will, behind the scenes, invoke a re-render of our component,
    causing `<li>Coffee</li>` to be appended to the live DOM. Creations, updates,
    and deletions are all handled similarly. The beauty of abstractions like React
    is that you don't need to think of these mutations as distinct pieces of DOM logic.
    All we need to do is derive a component/DOM tree from our set of data and React
    will figure out the precise changes needed to reconcile the DOM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setItems`将在幕后调用我们的组件的重新渲染，导致`<li>Coffee</li>`被附加到实时DOM上。创建、更新和删除都是类似处理的。像React这样的抽象的美妙之处在于，你不需要把这些变化看作是DOM逻辑的不同部分。我们所需要做的就是从我们的一组数据中派生一个组件/DOM树，React将找出协调DOM所需的精确变化。
- en: 'To ensure we understand what''s going on, when a piece of data (*state*) is
    changed via a Hook (for example, `setItems(...)`), React does the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们理解发生了什么，当通过Hook改变了一段数据（*状态*）时（例如，`setItems(...)`），React会执行以下操作：
- en: React re-invokes the component (re-renders)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React重新调用组件（重新渲染）
- en: React compares the tree returned from the re-render with the previous tree
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React将从重新渲染返回的树与先前的树进行比较
- en: React makes the essential granular mutations to the live DOM for all of the
    changes to be reflected
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React对所有更改进行了必要的细粒度变化，以反映在实时DOM中
- en: Other modern frameworks borrow from this approach as well. One nice side-effect
    of DOM reconciliation mechanisms built into these abstractions is that, via their
    declarative syntax, we can derive a deterministic tree of components from any
    given data. This is in stark contrast to the imperative approach, within which
    we must manually select and mutate specific DOM nodes ourselves. The declarative
    approach gives us a functional purity that enables us to produce outputs that
    are deterministic and idempotent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他现代框架也借鉴了这种方法。这些抽象中内置的DOM协调机制的一个好处是，通过它们的声明性语法，我们可以从任何给定的数据中得出一个确定性的组件树。这与命令式方法形成鲜明对比，在命令式方法中，我们必须手动选择和改变特定的DOM节点。声明性方法给我们带来了功能纯度，使我们能够产生确定性和幂等性的输出。
- en: As you may recall from [Chapter 4](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml), *SOLID
    and Other Principles*, **functional purity** and **idempotence** give us standalone
    testable units of predictable input and output. They allow us to say *X input
    will always result in Y output*. This transparency aids tremendously in both the
    reliability and the comprehensibility of our code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得的[第4章](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml)，*SOLID和其他原则*，**功能纯度**和**幂等性**给了我们可预测的输入和输出的独立可测试单元。它们使我们能够说*X输入将始终导致Y输出*。这种透明度在我们代码的可靠性和可理解性方面都有很大帮助。
- en: Building large web applications, even with the reconciliation puzzle out of
    the way, is still a challenge. Every component or view within a given page needs
    to be populated with its correct data and needs to propagate changes. We'll be
    exploring this challenge next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大型Web应用程序，即使协调问题已经解决，仍然是一个挑战。给定页面中的每个组件或视图都需要填充其正确的数据并传播更改。我们将在下一步探讨这个挑战。
- en: Messaging and data propagation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递和数据传播
- en: When building a web application, you'll quickly run into the challenge of getting
    different *parts* or *components* within your page to talk to each other. At any
    single time, your application should be representing the exact same set of data.
    If something changes, either via user action or some other mechanism, that change
    needs to be reflected in all of the appropriate places.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Web应用程序时，您很快就会遇到一个挑战，即让页面内的不同*部分*或*组件*相互通信。在任何单一时间，您的应用程序应该表示完全相同的数据集。如果发生变化，无论是通过用户操作还是其他机制，都需要在所有适当的位置反映这种变化。
- en: 'This problem occurs at different scales. You may have a *chat* application
    where an entered message needs to be propagated to all participants as fast as
    possible. Or you may have a piece of data that needs to be represented several
    times within the same application view and hence all of these representations
    need to be kept in sync. For example, if a user changes their forename in a *profile
    settings* pane, then this should reasonably update other places in the visible
    application where their forename appears:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题出现在不同的规模上。您可能有一个*聊天*应用程序，其中输入的消息需要尽快传播给所有参与者。或者您可能有一条数据需要在同一应用程序视图中表示多次，因此所有这些表示都需要保持同步。例如，如果用户在*配置文件设置*窗格中更改他们的名字，那么这应该合理地更新出现他们名字的应用程序中的其他位置。
- en: '![](assets/45bf7759-0c3f-42e9-aa07-22663cda0a84.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45bf7759-0c3f-42e9-aa07-22663cda0a84.png)'
- en: In a conventional non-SPA, the Save personal info button would simply submit
    a `<form>` and the page would then fully reload and a brand new chunk of markup
    with the updated state would be sent down from the server. Within an SPA, it is
    slightly more complicated. We would need to both submit the data to the server
    and then somehow update only the relevant portions of the page with the new data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的非SPA中，保存个人信息的按钮将简单地提交一个`<form>`，然后页面将完全重新加载，并且从服务器发送下来的更新状态的全新标记块。在SPA中，情况稍微复杂。我们需要将数据提交到服务器，然后以某种方式仅更新页面的相关部分以显示新数据。
- en: 'To solve this problem, we have to think carefully about the flow of data or
    *state* within our application. The challenge is reflecting the *source of truth* for
    the relevant data as soon as possible in all of the places it needs to be represented.
    To achieve this, we need a way for different parts of our code base to talk to
    each other. There are a couple of paradigms we can use here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须仔细考虑应用程序中数据或*状态*的流动。挑战在于尽快在所有需要表示的地方反映相关数据的*真相来源*。为了实现这一点，我们需要一种让代码库中的不同部分相互通信的方法。在这里，我们可以使用几种范式：
- en: '**Event-oriented**: This means having specific global events that can be emitted
    and listened to (for example, `userProfileNameChange`). Any component or view
    within a page can then bind to this event and react accordingly by updating its
    content. The *state*, therefore, exists at the same time in many different areas
    (amongst various components or views).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的范式：这意味着具有可以发出和侦听的特定全局事件（例如`userProfileNameChange`）。页面内的任何组件或视图都可以绑定到此事件，并通过更新其内容做出相应反应。因此，*状态*同时存在于许多不同的区域（在各种组件或视图之间）。
- en: '**State-oriented**: This means having a global state object that contains the
    single *source of truth* for the user''s forename. This state object, or parts
    of it, can be recursively passed down through a component tree, meaning that,
    upon any change, the entire component tree is *fed* with the new state. The *state* is
    therefore centralized yet propagated whenever a change occurs.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于状态的范式：这意味着具有包含用户名字的单一*真相来源*的全局状态对象。这个状态对象，或其中的部分，可以通过组件树递归传递，这意味着在任何更改时，整个组件树都会被新状态*喂养*。因此，*状态*是集中的，但在更改发生时传播。
- en: 'If we consider a user changing their forename via `<input />`, we can envisage
    the following distinct paths of data flow to all components that depend upon the
    forename data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑用户通过`<input />`更改他们的名字，我们可以设想以下不同的数据流路径，以便所有依赖于名字数据的组件都能得到更新：
- en: '![](assets/29c6b943-7c84-425e-99b5-13e87aa6fb50.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/29c6b943-7c84-425e-99b5-13e87aa6fb50.png)'
- en: 'Fundamentally, these approaches achieve the same thing: they render data to
    the DOM. The crucial thing that differs is how the change, in this case, a mutation
    of the forename, is communicated throughout the application and where the data
    resides at any one time:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，这些方法实现了相同的目标：它们将数据呈现到DOM中。不同的关键在于如何在应用程序中传达变化，例如名字的变化，并且数据在任何时候都驻留在哪里：
- en: The **event-oriented** paradigm has data living in several places at once. So,
    if, for whatever reason, one of those places fails to bind to the mutation of
    that event, then you can end up with out-of-sync data representations.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的范式使数据同时存在于多个位置。因此，如果由于某种原因，其中一个位置未能绑定到该事件的变化，那么您可能会得到不同步的数据表示。
- en: The **state-oriented** paradigm only has one canonical representation of the
    data and effectively *pipes* it to the relevant views or components, so that they
    are always hydrated with the latest version.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于状态的范式只有一个数据的规范表示，并有效地将其传送到相关的视图或组件，以便它们始终使用最新版本。
- en: 'The state-oriented paradigm is the increasingly more prevalent approach as
    it enables us to think in a clearer way about our data and its representations.
    We can say that we have a single representation of the data and that we derive
    components (or UI) from that data. It''s a functionally pure approach since a
    component is really just a deterministic *mapping* of data to a given UI. Since
    any given component only cares about its input data, it doesn''t need to make
    too many assumptions about the context it lives within. For example, we may have
    a `UserInfo` component, with an expected input of four values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 面向状态的范式是越来越普遍的方法，因为它使我们能够更清晰地思考我们的数据及其表示方式。我们可以说我们有数据的单一表示，并且我们从该数据派生组件（或UI）。这是一种功能纯净的方法，因为组件实际上只是数据对给定UI的确定性*映射*。由于任何给定组件只关心其输入数据，它不需要对其所在的上下文做太多假设。例如，我们可能有一个`UserInfo`组件，其预期输入为四个值：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since this component does not rely on any global events or other contextual
    assumptions, it can be easily isolated. This aids not only in comprehension and
    maintainability but also enables us to write simpler tests. The `UserInfo` component
    can be extracted and tested by itself, with no inter-dependencies with the application
    in which it will eventually reside.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个组件不依赖于任何全局事件或其他上下文假设，它可以很容易地被隔离。这不仅有助于理解和可维护性，还使我们能够编写更简单的测试。`UserInfo`组件可以被单独提取和测试，而不会与最终所在的应用程序产生相互依赖。
- en: 'React is a popular framework for expressing this state-oriented paradigm, but
    many other frameworks are following suit. In React, combined with JSX, we may
    express our `UserInfo` component like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个流行的框架，用于表达这种面向状态的范式，但许多其他框架也在效仿。在React中，结合JSX，我们可以这样表达我们的`UserInfo`组件：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we can see that this component''s output is merely a mapping of its input.
    Such a simple case of I/O can easily be tested and reasoned about. The beauty
    of this harks back to the **Law of Demeter** (**LoD**), which we covered in [Chapter
    4](https://cdp.packtpub.com/clean_code_in_javascript/wp-admin/post.php?post=356&action=edit#post_139), *SOLID
    and Other Principles*, which tells us that the `UserInfo` component has no business
    knowing where its data comes from or where it is used; it only needs to fulfill
    its singular responsibility: from its four inputs, it simply needs to provide
    us with a DOM hierarchy—clean and beautiful.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个组件的输出只是其输入的映射。这样简单的I/O案例可以很容易地进行测试和推理。这种美丽的事情可以追溯到**迪米特法则**（**LoD**），我们在[第4章](https://cdp.packtpub.com/clean_code_in_javascript/wp-admin/post.php?post=356&action=edit#post_139)中介绍过，*SOLID和其他原则*，它告诉我们`UserInfo`组件不需要知道其数据来自何处或者它被使用在哪里；它只需要履行其单一责任：从其四个输入中，它只需要为我们提供一个DOM层次结构-干净而美丽。
- en: There is, naturally, a lot more complexity in real-life web applications that
    we have not been able to draw out with our forename example. However, if we remember
    the basics of separating concerns, and building views or components that are well
    isolated and functionally pure, then there are few challenges we won't be able
    to solve cleanly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的Web应用程序中，可能存在更多的复杂性，我们无法用我们的名字示例来描绘出来。然而，如果我们记住分离关注点的基础知识，并构建良好隔离和功能纯净的视图或组件，那么我们几乎没有解决不了的挑战。
- en: Frontend routing
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端路由
- en: When building web applications, we will likely need to mutate the address the
    user sees within the browser to reflect the current resource being accessed. This
    is a core tenet of how browsers and HTTP work. An HTTP address should represent
    a resource. And so, when the user wishes to change the resource they are viewing,
    the address should correspondingly change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用程序时，我们可能需要突变用户在浏览器中看到的地址，以反映当前正在访问的资源。这是浏览器和HTTP工作的核心原则。HTTP地址应该代表一个资源。因此，当用户希望更改他们正在查看的资源时，地址应相应地更改。
- en: Historically, the only way of mutating the current URL within the browser would
    be for the user to navigate to a different page via an `<a href>` or similar.
    When SPAs started to become popular, however, JavaScript programmers needed to
    get creative. In the early days, a popular *hack* would be to mutate the hash
    component of a URL (`example.org/path/#hash`), which would give the user the experience
    of traversing a traditional website where each navigation or action would result
    in a new address and a new entry in the browser's history, hence enabling the
    use of the back-and-forward buttons in the browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中突变当前URL的唯一方法是用户通过`<a href>`或类似的方式导航到不同的页面。然而，当单页应用程序开始变得流行时，JavaScript程序员需要变得有创造力。在早期，一个流行的*hack*是突变URL的哈希部分（`example.org/path/#hash`），这将给用户带来在传统网站上遍历的体验，其中每个导航或操作都会导致新的地址和浏览器历史记录中的新条目，从而使浏览器的后退和前进按钮可用。
- en: The approach of mutating the `#hash` of a URL was famously used in Google's
    Gmail application when it launched in 2004 so that the address bar in the browser
    would accurately express what email or view you were currently looking at. Many
    other SPAs followed suit.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的Gmail应用程序在2004年推出时，采用了突变URL的`#hash`的方法，以便浏览器的地址栏准确地表达您当前正在查看的电子邮件或视图。许多其他单页应用程序也效仿此举。
- en: 'A few years later, thankfully, the History API found its way into browsers
    and is now the standard for mutating the address in response to navigations or
    actions within an SPA. Specifically, this API allows us to manipulate the browser
    session history by pushing new *states* or replacing current ones. For example,
    when a user expresses a wish to change to the `About Us` view within a fictional
    SPA, we can express this as a new state pushed to their history, like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，幸运的是，历史API进入了浏览器，并且现在是在单页应用程序中响应导航或操作时突变地址的标准。具体来说，这个API允许我们通过推送新的*状态*或替换当前状态来操纵浏览器会话历史。例如，当用户希望切换到虚构单页应用程序中的`关于我们`视图时，我们可以将其表达为推送到他们历史记录中的新状态，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would immediately change the address in the browser to `''/about''`*.*
    Typically, the calling code would also instigate the rendering of the associated
    view. Routing is the name given to these combined processes of rendering the new
    DOM and mutating the browser''s history. Specifically, a router takes responsibility
    for the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即在浏览器中将地址更改为`'/about'`*.* 通常，调用代码还会引发相关视图的渲染。路由是指呈现新DOM和改变浏览器历史记录的这些组合过程的名称。具体而言，路由器负责以下内容：
- en: Rendering the view, component, or page that corresponds to the current address
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现与当前地址对应的视图、组件或页面
- en: Exposing an interface to other code so that navigation can be instigated
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其他代码公开接口，以便引发导航
- en: Listening for changes to the address made by the user (the `popstate` event)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听用户更改的地址（`popstate`事件）
- en: 'To illustrate these responsibilities, we can create a simple router for an
    application that very simply displays `Hello {color}!` atop a background of that
    very color for any color represented in the path of the URL. Hence, `/red` will
    render a red background with the text, `Hello red!`. And `/magenta` will render
    a magenta background with the text, `Hello magenta!`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些职责，我们可以为一个应用程序创建一个简单的路由器，该应用程序非常简单地在URL路径中显示`Hello {color}!`，并在该颜色的背景上方显示该颜色。因此，`/red`将呈现红色背景，并显示文本`Hello
    red!`。而`/magenta`将呈现品红色背景，并显示文本`Hello magenta!`：
- en: '![](assets/a9fc8405-78c4-41c6-94f5-9281586c763e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9fc8405-78c4-41c6-94f5-9281586c763e.png)'
- en: 'And here is our implementation of `colorRouter`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`colorRouter`的实现：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how we're using the C*lass Singleton pattern* here (as introduced in
    the last chapter). Our `colorRouter` abstraction is well-suited to this pattern
    as we need specific construction logic and we want to present a singular interface.
    We could have also used the **Revealing Module** pattern.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用了C*lass Singleton模式*（如上一章介绍的）。我们的`colorRouter`抽象非常适合这种模式，因为我们需要特定的构造逻辑，并且希望呈现一个单一的接口。我们也可以使用**Revealing
    Module**模式。
- en: 'With this router, we can then call `colorRouter.go()` with our color and it''ll
    change the address and be rendered as expected:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个路由器，我们可以调用`colorRouter.go()`并传入颜色，它会改变地址并按预期渲染：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is, even in this simple scenario, some complexity in our router. When
    the user originally lands on the page via conventional browsing, for example, perhaps
    by typing `example.org/red` into the address bar, the state of the history object
    will be empty, as we have not yet informed that browser session that `/red` is
    tied to the piece of state, `{ color: "red" }`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '即使在这种简单的情况下，我们的路由器也存在一些复杂性。例如，当用户通过传统浏览方式最初登陆页面时，可能通过在地址栏中输入`example.org/red`来实现，历史对象的状态将为空，因为我们尚未通知浏览器会话`/red`与状态`{
    color: "red" }`相关联。'
- en: 'To populate this initial state, we need to grab the current `location.pathname`
    (`/red`) and then extract the color from it by removing the initial forward-slash.
    You can see this logic in the `colorRouter` constructor function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这个初始状态，我们需要获取当前的`location.pathname`（`/red`），然后通过删除初始斜杠来从中提取颜色。您可以在`colorRouter`的构造函数中看到这种逻辑：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For more complex paths, this logic can start to get quite complex. In a typical
    router, many different patterns of paths will need to be accommodated for. As
    such, usually, a URL parsing library will be used to properly extract each part
    of the URL and allow the router to route that address correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的路径，这种逻辑可能会变得相当复杂。在典型的路由器中，许多不同模式的路径都需要被容纳。因此，通常会使用URL解析库来正确提取URL的每个部分，并允许路由器正确路由该地址。
- en: It's important to use a properly constructed URL parsing library for use in
    production routers. Such libraries tend to accommodate all of the edge-cases implicit
    in URLs, and should ideally be compliant with the URI specification (*RFC 3986*).
    An example of this would be `URI.js` (available on npm as `uri-js`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产路由器中使用一个正确构建的URL解析库非常重要。这样的库往往可以适应URL中隐含的所有边缘情况，并且最好符合URI规范（*RFC 3986*）。一个例子是`URI.js`（在npm上可用作`uri-js`）。
- en: 'Various routing libraries and routing abstractions within larger frameworks
    have emerged over the years. They are all slightly different in the interface
    they present to the programmer. React Router, for example, allows you to declare
    your independent routes as a series of React components via JSX syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，出现了各种不同的路由库和大型框架中的路由抽象。它们在向程序员呈现的接口上略有不同。例如，React Router允许您通过JSX语法将独立路由声明为一系列React组件：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Vue.js, a different framework, provides a unique routing abstraction of its
    own:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js，一个不同的框架，提供了自己独特的路由抽象：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You may notice that, in both examples, there is a URL path specified as `/about/:employee`.
    The colon followed by a given token or word is a common way to designate that
    a specific portion of the path is dynamic. It''s typical to need to dynamically
    respond to a URL that contains a piece of identifying information concerning a
    specific resource. It''s reasonable that all of the following pages should produce
    different content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，在这两个示例中，都指定了URL路径为`/about/:employee`。冒号后面跟着给定的标记或单词是指定路径的特定部分是动态的常见方式。通常需要动态响应包含有关特定资源的标识信息的URL是合理的。所有以下页面应该产生不同的内容：
- en: '`/about/john`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/about/john`'
- en: '`/about/mary`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/about/mary`'
- en: '`/about/nika`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/about/nika`'
- en: 'It would be incredibly burdensome to specify these all as individual routes
    (and near impossible with large datasets), so routers will always have some way
    of expressing these dynamic portions. The hierarchical nature of URLs is usually
    also mirrored in the declarative APIs provided by routers and will typically allow
    us to specify a hierarchy of components or views to render in response to such
    hierarchical URLs. Here''s an example of a `routes` designation that could be
    passed to the Router service of Angular (another popular framework!):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些都指定为单独的路由将是非常繁重的（对于大型数据集几乎不可能），因此路由器总是有一种方式来表达这些动态部分。URL的分层性质通常也在路由器提供的声明性API中得到反映，并且通常允许我们指定要呈现响应这些分层URL的组件或视图的层次结构。以下是一个可以传递给Angular的Router服务的`routes`指定的示例（另一个流行的框架！）：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can see that `AboutEmployeeComponent` is attached to the path of `about/:employee` and
    has sub-components that are each attached to the sub-paths of `hobbies` and `hobbies/:hobby`.
    An address such as `/about/john/hobbies/kayaking` would intuitively render `AboutEmployeeComponent`
    and within that would render `EmployeeHobbyComponent`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`AboutEmployeeComponent`附加到`about/:employee`路径，并且具有每个附加到`hobbies`和`hobbies/:hobby`子路径的子组件。例如`/about/john/hobbies/kayaking`这样的地址直观地呈现`AboutEmployeeComponent`，并在其中呈现`EmployeeHobbyComponent`。
- en: You can probably observe here how intertwined a router is with rendering. It
    is indeed possible to have standalone routing libraries, but it's far more typical
    for frameworks to provide a routing abstraction themselves. This allows us to
    specify our routes alongside a view or component or widget, or whatever abstraction
    our framework provides for rendering things to the DOM. Fundamentally, although
    different on the surface, all of these frontend routing abstractions will achieve
    the same result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会观察到路由器与呈现是多么交织在一起。确实可能有独立的路由库，但更典型的是框架提供路由抽象。这使我们能够在视图、组件或小部件等框架提供的呈现DOM的抽象旁边指定路由。基本上，尽管在表面上不同，所有这些前端路由抽象都将实现相同的结果。
- en: Another real-world challenge that many JavaScript programmers will expose themselves
    to, whether they're predominately working on the client side or server side, is
    that of dependency management. We'll begin exploring this next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript程序员将面临的另一个现实挑战，无论他们主要是在客户端还是服务器端工作，就是依赖管理。我们将在下一节开始探讨这个问题。
- en: Dependency management
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Loading JavaScript within the context of a single web page used to be simple.
    We could simply place a couple of `<script>` tags somewhere within the document's
    source and call it a day.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个网页的上下文中加载JavaScript曾经很简单。我们可以简单地在文档源代码的某个地方放置一对`<script>`标签，然后就可以了。
- en: Over the years, however, the complexity of our JavaScript has grown tremendously,
    alongside the demands of our users. Alongside this, our code bases have grown
    as well. It was, for a period, natural to just keep adding more and more `<script>`
    tags. At a certain point, though, this approach falters. Apart from the burden
    of multiple HTTP requests being made on every page load, this approach also made
    it hard for programmers to juggle their dependencies. JavaScript was typical,
    in those days, to spend time carefully ordering `<script>` placements so that,
    for any particular script, its dependencies were in place before it itself loaded.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们的JavaScript的复杂性与用户的需求一样大幅增长。随着这一点，我们的代码库也在增长。有一段时间，自然而然地只是不断添加更多的`<script>`标签。然而，在某一点上，这种方法会失败。除了在每个页面加载时进行多个HTTP请求的负担外，这种方法还使程序员难以处理他们的依赖关系。在那些日子里，JavaScript通常要花费时间仔细地安排`<script>`的位置，以便对于任何特定的脚本，它的依赖关系在它自己加载之前就已经准备好了。
- en: 'It was not uncommon to see HTML markup like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以前经常看到这样的HTML标记：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This approach was expensive from a performance perspective as the browser had
    to fetch every resource before continuing to parse and render the remaining document.
    Large collections of inline scripts in the `<head>` of an HTML document were hence
    considered an anti-pattern as they would block the user from being able to use
    the website for a significant amount of time. Even moving scripts to the bottom
    of `<body>` wasn't ideal as browsers would still have to load and execute them
    serially.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，这种方法是昂贵的，因为浏览器必须在继续解析和呈现剩余文档之前获取每个资源。因此，HTML文档的`<head>`中的大量内联脚本被认为是一种反模式，因为它们会阻止用户在相当长的时间内使用网站。即使将脚本移动到`<body>`的底部也不理想，因为浏览器仍然必须按顺序加载和执行它们。
- en: Predictably, our increasingly complex applications started to outgrow this approach.
    Developers needed more performance and a finer level of control over script loading.
    Thankfully, over the years, various improvements have been made in how we manage
    dependencies, how we bundle them, and how we then serve our code bases to the
    browser.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可预见的是，我们日益复杂的应用程序开始超越这种方法。开发人员需要更高的性能和对脚本加载的更精细控制。幸运的是，多年来，在我们管理依赖关系、打包它们以及然后将我们的代码库提供给浏览器方面已经进行了各种改进。
- en: In this section, we'll explore the improvements that have occurred over the
    years and will seek to understand what the current best practices are, as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨多年来发生的改进，并试图了解当前的最佳实践。
- en: Module definition – then and now
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块定义-过去和现在
- en: Before 2010 (*approximately*), there were very few agreed upon methods of loading
    large and complex JavaScript code bases within the browser. Soon, however, developers
    created the **Asynchronous Module Definition** (**AMD**) format. This was the
    first popular attempt at a standard that prescribed the definition of modules
    within JavaScript. It included both the ability to declare dependencies on each
    module and an asynchronous loading mechanism. This was a vast improvement upon
    the slow and blocking nature of multiple inline `<script>` tags.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年之前（*大约*），在浏览器中加载大型和复杂的JavaScript代码库的方法很少达成一致。然而，开发人员很快创建了**异步模块定义**（**AMD**）格式。这是对在JavaScript中定义模块的标准的第一次尝试。它包括声明每个模块的依赖关系的能力和异步加载机制。这是对多个内联`<script>`标签的缓慢和阻塞性质的巨大改进。
- en: 'RequireJS was a popular library that supported this format. To use it, you
    only needed to place a single entry point `<script>` in your document:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS是一个支持这种格式的流行库。要使用它，您只需要在文档中放置一个单一的入口点`<script>`：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `data-main` attribute here would specify the entry point of our code base,
    which itself would then load the initial set of dependencies and initialize the
    application, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`data-main`属性将指定我们代码库的入口点，然后加载初始依赖项并初始化应用程序，如下所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each dependency would then `define` itself and its own dependencies, like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个依赖项将`define`自己和自己的依赖项，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is similar in spirit to modules as now specified in the ECMAScript specification,
    except AMD is not related to any particular language syntax. It was entirely a
    community-driven effort to bring something like modules to JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这在精神上类似于ECMAScript规范中现在指定的模块，但AMD与任何特定的语言语法无关。这完全是一个由社区驱动的努力，旨在将类似模块的东西带到JavaScript中。
- en: The fact that AMD prescribed that each module was defined within a callback,
    to which dependencies could be passed, meant that loading utilities such as RequireJS
    could load all dependencies asynchronously and then invoke the callback when it
    was done. This was a significant boost to frontend JavaScript at the time because
    it meant we could quite easily load massive dependency graphs in a way that eased
    the process of writing the code (less dependency juggling) and enabled the code
    to be loaded into the browser in a non-blocking and more performant fashion.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: AMD规定每个模块都在回调函数中定义，可以在其中传递依赖项，这意味着加载工具（如RequireJS）可以异步加载所有依赖项，然后在完成后调用回调函数。这对前端JavaScript来说是一个重大提升，因为这意味着我们可以相当轻松地以一种减轻了编写代码过程（减少依赖项处理）并且使代码以非阻塞和更高性能方式加载到浏览器中的方式加载大量依赖图。
- en: 'At a similar time to AMD, a new standards-driven effort started to emerge called
    **CommonJS**. This sought to make the `require(...)` syntax a standard in various
    non-browser environments, with the hopeful, eventual intention of such syntax
    being supported on the frontend as well. Here''s an example of a CommonJS module
    (this may appear familiar if you''re accustomed to programming in Node.js):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与AMD类似的时间，一个名为**CommonJS**的新的标准驱动的努力开始出现。这试图使`require(...)`语法成为各种非浏览器环境中的标准，并希望最终该语法也能在前端得到支持。以下是一个CommonJS模块的示例（如果您习惯于在Node.js中编程，这可能会很熟悉）：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This became the standard in various non-browser environments such as Node.js,
    SproutCore, and CouchDB. It was also possible to compile your CommonJS modules
    into browser-consumable scripts similar to AMD using the CommonJS Compiler. Sometime
    after this, around 2017, **ES Modules** emerged. This gave us language support
    for `import` and `export` statements, effectively solving the historical challenge
    of *how to define modules* in JavaScript:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这成为了各种非浏览器环境的标准，如Node.js、SproutCore和CouchDB。还可以使用CommonJS编译器将您的CommonJS模块编译成类似AMD的浏览器可消耗的脚本。在此之后，大约在2017年，**ES模块**出现了。这为我们提供了对`import`和`export`语句的语言支持，有效地解决了JavaScript中*如何定义模块*的历史挑战。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In Node.js, such modules must have filename suffixes of `.mjs` instead of `.js`
    so the engine knows to expect `import` and `export` and not the conventional CommonJS
    module definition syntax. In the browser, such modules can be loaded by using `<script
    type="module">`. However, even with ES Modules supported in browsers, it''s still
    arguably preferable to build and bundle your JavaScript into conventional non-modular
    script tags. This is due to factors of performance and compatibility across browsers.
    Not to worry though: we can still use ES Modules when writing our code! Tools
    such as Babel can be used to compile and bundle the latest JavaScript syntax into
    JavaScript that is compatible across many environments. It''s typical to set up
    a tool such as Babel as part of your build and development process.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，这些模块的文件名后缀必须是`.mjs`而不是`.js`，这样引擎就知道要期望`import`和`export`而不是传统的CommonJS模块定义语法。在浏览器中，可以使用`<script
    type="module">`加载这些模块。然而，即使浏览器支持ES模块，在构建和捆绑JavaScript成传统的非模块化脚本标签仍然可能更可取。这是由于性能和跨浏览器的兼容性因素。不过不用担心：我们仍然可以在编写代码时使用ES模块！诸如Babel之类的工具可以用来将最新的JavaScript语法编译和捆绑成兼容多个环境的JavaScript。通常在构建和开发过程中设置Babel这样的工具是很典型的。
- en: npm and package.json
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm和package.json
- en: In the past, there was no package manager available for the JavaScript community.
    Instead, individuals and organizations would typically release code themselves,
    enabling developers to manually download the latest releases. With the introduction
    of Node.js and npm, this all changed. Finally, there was a central repository
    of packages available to pull into our projects with ease. This wasn't only useful
    for server-side Node.js projects but also entirely frontend projects as well.
    The emergence of npm is likely one of the most significant events that precipitated
    the maturation of the JavaScript ecosystem.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，JavaScript社区没有可用的包管理器。相反，个人和组织通常会自行发布代码，使开发人员可以手动下载最新版本。随着Node.js和npm的引入，一切都发生了变化。最终，有一个中央的包存储库可供轻松地引入我们的项目。这不仅对于服务器端的Node.js项目有用，对于完全的前端项目也是如此。npm的出现很可能是导致JavaScript生态系统成熟的最重要事件之一。
- en: 'Nowadays, every project that heavily involves JavaScript will set out its manifest
    in a top-level `package.json` file, usually specifying, at the very least, a name,
    a description, a version, and a list of versioned dependencies:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎每个涉及JavaScript的项目都会在顶层`package.json`文件中设置其清单，通常至少指定名称、描述、版本和一个版本化的依赖项列表：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are a variety of available fields you can use in `package.json` so it''s
    worth exploring the npm documentation to understand all of them. Here''s a rundown
    of the most common ones:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`中有许多可用字段，因此值得探索npm文档以了解所有这些字段。以下是最常见字段的概述：'
- en: '`name`: The name of the package is perhaps the most important thing. If you
    plan to publish the package to npm, then this name will need to be unique.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 包的名称可能是最重要的事情。如果您计划将包发布到npm，则此名称需要是唯一的。'
- en: '`description`: This is a brief description of your module, to help developers
    understand its purpose. More detailed information is typically placed in a `README`
    or `README.md` file.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这是您的模块的简要描述，以帮助开发人员了解其目的。更详细的信息通常放在`README`或`README.md`文件中。'
- en: '`version`: This is a **Semantic Versioning** (**SemVer**) compatible version
    (of the form, `[Major].[Minor].[Patch]`, for example, `5.11.23`).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 这是一个**语义化版本**（**SemVer**）兼容的版本（形式为`[Major].[Minor].[Patch]`，例如`5.11.23`）。'
- en: '`dependencies`: This is an object that maps every dependency package name to
    a version range. The version range is a string that has one or more space-separated
    descriptors. Dependencies can also be specified as a tarball/Git URL.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`: 这是一个将每个依赖包名称映射到版本范围的对象。版本范围是一个字符串，其中包含一个或多个以空格分隔的描述符。依赖项也可以指定为tarball/Git
    URL。'
- en: '`devDependencies`: This is identical in function to `dependencies` except for
    the fact that it is intended only for dependencies that are required during development,
    such as code quality analyzers and testing libraries.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`: 这在功能上与`dependencies`相同，只是它仅用于开发过程中需要的依赖项，例如代码质量分析器和测试库。'
- en: '`main`: This can refer to the module ID that is the primary entry point to
    your program. For example, if your package were named `super-utils`, and someone
    installed it and then did `require("super-utils")`, then your `main` module''s
    export object would be returned.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`: 这可以是指向程序的主要入口点的模块ID。例如，如果您的包名为`super-utils`，有人安装了它，然后执行了`require("super-utils")`，那么您的`main`模块的导出对象将被返回。'
- en: npm assumes that your package and any packages you rely on follow the rules
    of SemVer, which uses a pattern of `[Major].[Minor].[Patch]` (for example, `1.0.2`).
    SemVer prescribes that any breaking changes must result in the *major* portion
    incrementing, whereas backward-compatible feature additions should result in only
    the *\minor* portion incrementing, and backward-compatible bug fixes should result
    in the *patch* portion incrementing. Full details can be found at [https://semver.org/](https://semver.org/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: npm假定您的包和您依赖的任何包都遵循SemVer的规则，该规则使用模式`[Major].[Minor].[Patch]`（例如`1.0.2`）。SemVer规定任何重大更改必须导致*主要*部分增加，而向后兼容的功能添加应该只导致*次要*部分增加，向后兼容的错误修复应该只导致*补丁*部分增加。完整的详细信息可以在[https://semver.org/](https://semver.org/)找到。
- en: Running `npm install` in the directory where `package.json` resides will cause
    npm to download the versions of dependencies that you have specified. When declaring
    dependencies, by default, npm will do so with a caret (`^`) attached, meaning
    that npm will pick the latest available version that complies with the major version
    specified. So, if you specify `^1.2.3`, then anything up to `1.99.99` (and so
    on) may validly be installed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`所在的目录中运行`npm install`将导致npm下载您指定的依赖项的版本。在声明依赖项时，默认情况下，npm会附加一个插入符(`^`)，这意味着npm将选择符合指定主要版本的最新可用版本。因此，如果您指定`^1.2.3`，那么任何`1.99.99`（依此类推）之前的版本都可以被有效安装。
- en: 'There are several fuzzy *version ranges* that you can use:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个模糊的*版本范围*可以使用：
- en: '`version`: Must match `version` exactly'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 必须与`version`完全匹配'
- en: '`>version`: Must be greater than `version`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>version`: 必须大于`version`'
- en: '`>=version`: Must be greater than or equal to `version`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=version`: 必须大于或等于`version`'
- en: '`<version`: Must be less than `version`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<version`: 必须小于`version`'
- en: '`<=version`: Must be less than or equal to `version`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=version`: 必须小于或等于`version`'
- en: '`~version`: Approximately equivalent to `version` (increment patch portion
    only)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~version`: 大约等同于`version`（仅增加`patch`部分）'
- en: '`^version`: Compatible with `version` (increment minor/patch portions only)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^version`: 兼容`version`（仅增加`minor/patch`部分）'
- en: '`1.2.x`: `1.2.0`, `1.2.1`, and so on, but not `1.3.0` (`x` means anything here)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.x`: `1.2.0`，`1.2.1`等，但不包括`1.3.0`（`x`在这里表示任何内容）'
- en: Arguably, the greatest issue with npm is that the unchecked introduction of
    new packages and their granularity in terms of functionality has led to projects
    with incredibly large and unwieldy dependency graphs. It's not unheard of for
    there to be individual packages that only export a singular narrow utility function.
    For example, in addition to a generic *string utility* package, you may also find
    a specific string function as a package of its own, such as *uppercase*. These
    packages are not inherently problematic—many of them serve useful purposes—but
    having an unwieldy dependency graph can lead to problems of its own. Any popular
    package that either is compromised or has not followed SemVer religiously can
    result in a propagation of issues across the JavaScript ecosystem, eventually
    affecting your project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: npm的最大问题可能是未经检查地引入新包及其功能的细粒度导致了具有非常庞大和难以控制的依赖图的项目。并不罕见的是，有些单独的包只导出一个狭窄的实用功能。例如，除了一个通用的*字符串实用程序*包，你可能还会发现一个特定的字符串函数作为一个独立的包，比如*大写*。这些包本身并不是问题，很多包都有有用的用途，但是拥有一个难以控制的依赖图可能会导致自身的问题。任何受到影响或者没有严格遵循SemVer规范的流行包都可能导致JavaScript生态系统中问题的传播，最终影响到你的项目。
- en: To help to prevent bugs and security issues, it is highly recommended to specify
    your dependencies with fixed versions and update dependencies manually only when
    you have checked their respective changelogs. Nowadays, some tools can help you
    to keep dependencies up to date without sacrificing security (for example, *dependabot*,
    owned by GitHub).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止错误和安全问题，强烈建议使用固定版本来指定你的依赖，并且只有在检查了各自的变更日志后才手动更新依赖。现在，一些工具可以帮助你保持依赖的最新状态，而不会牺牲安全性（例如，由GitHub拥有的*dependabot*）。
- en: 'It''s recommended to use a dependency management system that ensures the integrity
    of downloaded packages with cryptographic hashes (a checksum that would highlight
    malicious changes), to ensure that the package you end up executing is definitely
    the one you intended to install and has not been compromised or damaged during
    transmission. Yarn is an example of such a system (see [https://yarnpkg.com](https://yarnpkg.com)).
    It is effectively a more secure and efficient abstraction atop npm. In addition
    to being more secure, Yarn has the added benefit of avoiding inconsistent package
    resolution, which is when two installs of a given code base''s dependencies will
    result in a potentially different set of downloaded dependencies (due to the potentially
    fuzzy nature of npm''s version declarations). Such inconsistencies can result
    in the same code base behaving differently across two instances (a massive headache
    and harbinger of bugs!). Yarn stores the current *locked* dependency graph and
    corresponding versions and checksums in a `yarn.lock` file, which would look like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用一个依赖管理系统，通过加密哈希（一个检查恶意更改的校验和）来确保下载的包的完整性，以确保你最终执行的包确实是你打算安装的包，并且在传输过程中没有被破坏或损坏。Yarn就是这样一个系统的例子（参见[https://yarnpkg.com](https://yarnpkg.com)）。它实际上是在npm之上更安全和高效的抽象。除了更安全之外，Yarn还有一个额外的好处，就是避免不一致的包解析，这是指给定代码库的两次安装可能会导致一组不同的下载依赖（因为npm版本声明的可能模糊性）。这种不一致可能导致同一代码库在两个实例中表现不同（一个巨大的头痛和错误的预兆！）。Yarn将当前的*锁定*依赖图和相应的版本和校验和存储在一个`yarn.lock`文件中，看起来像这样：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we see just one dependency but there'd usually be hundreds if not thousands
    as it would have to include not only your direct dependencies but also dependencies
    of those dependencies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只看到一个依赖，但通常会有数百甚至数千个，因为它不仅包括你的直接依赖，还包括这些依赖的依赖。
- en: Dependency management is a topic that has had much written about it, so if you
    look online, there is no shortage of opinions and solutions. Fundamentally, as
    our concern is clean code, we should go back to our principles. Foremost, what
    we should seek in both our dependency systems and the dependencies themselves
    is reliability, efficiency, maintainability, and usability. In the context of
    dependencies, when it comes to maintainability, we are interested in both our
    ability to maintain code that consumes and depends upon the dependency and the
    ability for the dependency's maintainers to keep the dependency up to date and
    bug-free.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是一个已经有很多文章写过的话题，所以如果你上网搜索，就会发现各种意见和解决方案。从根本上讲，因为我们关心的是清晰的代码，我们应该回到我们的原则。首先，我们在我们的依赖系统和依赖本身中应该寻求的是可靠性、效率、可维护性和可用性。在依赖的上下文中，当涉及到可维护性时，我们对我们能够维护依赖的代码以及依赖的维护者能够保持依赖最新和无bug的能力都感兴趣。
- en: Bundling and serving
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑和服务
- en: In the land of JavaScript, around the same time as AMD and CommonJS started
    to emerge, the rise of command-line bundlers and build tools was also on the rise.
    This gave us the ability to bundle large dependency graphs into singular files
    that could be loaded with a single `<script>`. The proliferation of build tools
    such as GruntJS and gulp.js meant that, slowly, the JavaScript we wrote as programmers
    could be oriented to cleanliness and comprehension and not the loading idiosyncrasies
    of browsers. We could also begin to take advantage of spin-off languages and subsets
    such as CoffeeScript, TypeScript, and JSX. Such JavaScript adaptations could easily
    be compiled and then bundled into fully operable JavaScript sent down to the browser.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的世界中，大约在AMD和CommonJS开始出现的同时，命令行打包工具和构建工具也开始兴起。这使我们能够将大量的依赖图捆绑成单个文件，可以通过单个`<script>`加载。构建工具的大量出现，比如GruntJS和gulp.js，意味着我们编写的JavaScript可以慢慢地朝着清晰和易懂的方向发展，而不是浏览器加载的怪癖。我们还可以开始利用分支语言和子集，比如CoffeeScript、TypeScript和JSX。这样的JavaScript适应可以很容易地编译，然后捆绑成完全可操作的JavaScript发送到浏览器。
- en: The world that we have now is one in which build and bundling tools are incredibly
    common. There are several specific build tools, such as Grunt, gulp.js, webpack,
    and Browserify. Additionally, developers can easily use the npm `scripts` directive
    to create shortcuts to common command-line instructions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所处的世界是构建和捆绑工具非常普遍的世界。有一些特定的构建工具，如Grunt、gulp.js、webpack和Browserify。此外，开发人员可以轻松地使用npm的`scripts`指令来创建常见命令行指令的快捷方式。
- en: 'Generally, building involves any preparations that need to occur on development
    code bases to make them production-ready. This can include anything from linting
    your CSS to bundling your JavaScript. Bundling, specifically, is concerned with the
    compilation and collation of large dependency graphs (of JavaScript files) into
    single JavaScript files. This is necessary so that we can serve our JavaScript
    code bases to the browser in the most performant and compatible way. Bundling
    utilities will usually output a file with a hash of the file''s content as part
    of the filename, for example, `main-f522dccf1ff37b.js`. This filename can then
    be dynamically or statically inserted into a `<script>` tag within your HTML to
    be served to the browser:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，构建涉及对开发代码库进行的任何准备工作，使其能够投入生产使用。这可能包括从清理你的CSS到捆绑你的JavaScript等任何事情。特别是捆绑，涉及将大型依赖图（JavaScript文件）编译和整合成单个JavaScript文件。这是必要的，这样我们才能以最高效和兼容的方式将JavaScript代码库提供给浏览器。捆绑工具通常会输出一个带有文件内容哈希的文件作为文件名的一部分，例如`main-f522dccf1ff37b.js`。然后可以将这个文件名动态或静态地插入到HTML中的`<script>`标签中，以便提供给浏览器：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Having a hash of the file's contents in the filename ensures that browsers always
    load the updated file and do not rely on a previously cached version of it. These
    files are usually *minified* as well. *Minification* involves parsing your JavaScript
    and producing a functionally identical but much smaller representation of it where
    all possible measures have been taken to take up less space, such as shortening
    variable names and removing whitespace and newlines. This is used in combination
    with HTTP compression techniques (such as `.gzip`) to ensure that the transmission
    over HTTP from a server to a client is as small and quick as possible. Usually,
    you will have distinct *development* and *production* builds since some build
    steps, such as minification, would make development (and debugging!) harder.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件名中包含文件内容的哈希值可以确保浏览器始终加载更新的文件，而不依赖于先前缓存的版本。这些文件通常也会被*压缩*。*压缩*涉及解析你的JavaScript并生成一个在功能上相同但更小的表示形式，其中已经采取了尽可能少的措施，比如缩短变量名和删除空格和换行符。这与HTTP压缩技术（如`.gzip`）结合使用，以确保从服务器到客户端的HTTP传输尽可能小和快。通常，你会有不同的*开发*和*生产*构建，因为一些构建步骤，比如压缩，会使开发（和调试！）更加困难。
- en: 'Serving bundled JavaScript to the browser is usually done with a singular `<script>`
    tag referencing the bundled JavaScript filename, placed at somewhere within the
    HTML that you serve to the browser. There are several important performance considerations
    when selecting an approach. The most important metric is how quickly, from the
    time of the initial request, a user can start using the application. When loading
    up superWebApp.example.com, we can imagine the following possible latencies experienced
    by the user:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 向浏览器提供捆绑的JavaScript通常是通过一个单独的`<script>`标签引用捆绑的JavaScript文件名来完成的，放置在你提供给浏览器的HTML中的某个位置。在选择方法时有几个重要的性能考虑。最重要的指标是用户从初始请求开始使用应用程序的时间。当加载superWebApp.example.com时，用户可能会遇到以下可能的延迟：
- en: '**Fetching resources**: Each resource fetch may involve a DNS lookup, an SSL
    handshake, and the completion of an HTTP request and response cycle. Responses
    are usually streamed, meaning that the browser may begin parsing a response before
    it is completed. Browsers typically make a moderate amount of requests concurrently.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取资源**：每个资源获取可能涉及DNS查找、SSL握手和HTTP请求和响应周期的完成。响应通常是流式传输的，这意味着浏览器可能在完成之前开始解析响应。浏览器通常会同时发出适量的请求。'
- en: '**Parsing HTML**: This involves the browser parsing every tag name and iteratively
    building up a DOM representation of the HTML. Some encountered tags will cause
    a new fetchable resource to be enqueued, such as `<img src>`, `<script src>`,
    or `<link type="stylesheet" href>`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析HTML**：这涉及浏览器解析每个标记名称，并逐步构建HTML的DOM表示。遇到的一些标记会导致一个新的可获取资源被排队，比如`<img src>`、`<script
    src>`或`<link type="stylesheet" href>`。'
- en: '**Parsing CSS**: This involves the browser parsing every ruleset within any
    fetched CSS. Referenced resources such as background images will only be fetched
    later if the corresponding element is found to exist on the page.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析CSS**：这涉及浏览器解析获取的每个CSS中的每个规则集。引用的资源，如背景图片，只有在页面上找到相应的元素时才会被获取。'
- en: '**Parsing / compiling JavaScript**: Following the fetching of each JavaScript
    resource, its contents will be parsed and compiled, ready to execute.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析/编译JavaScript**：在获取每个JavaScript资源之后，其内容将被解析和编译，准备执行。'
- en: '**Rendering HTML with CSS applied**: This will ideally occur only once, when
    all CSS has been loaded. If there are asynchronously loaded CSS or other aesthetic
    resources (such as typefaces or images), then there may be several repaints/re-renders
    before the page can be considered fully rendered.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用CSS渲染HTML**：这将理想地只发生一次，当所有CSS都已加载时。如果有异步加载的CSS或其他美观资源（如字体或图像），那么在页面被认为完全渲染之前可能会有几次重绘/重新渲染。'
- en: '**Executing JavaScript**: Depending on the location of the corresponding `<script>`,
    a piece of JavaScript will execute and may then mutate the DOM or perform its
    own fetches. This can potentially block any other fetching/parsing/rendering from
    occurring.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行JavaScript**：根据相应的`<script>`的位置，一段JavaScript将执行，然后可能改变DOM或执行自己的获取。这可能会阻止其他的获取/解析/渲染发生。'
- en: It's usually preferable to have the execution of your JavaScript occur last,
    when the browser has done everything else. However, this is not always ideal.
    Some JavaScript may be necessary to load vital resources, and so it should be
    executed as early as possible so those HTTP fetches can occur concurrently with
    the rest of the browser's preparatory work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，最好在浏览器完成其他所有工作后再执行JavaScript。然而，这并不总是理想的。一些JavaScript可能需要加载重要资源，因此应尽早执行，以便这些HTTP获取可以与浏览器的其他准备工作同时进行。
- en: Placement of your primary bundled `<script>` (your `main` code base) is vital
    in determining when your JavaScript will be fetched, when it will execute, and
    what the state of the DOM will be when it executes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 放置主要捆绑的`<script>`（您的`main`代码库）对于确定JavaScript何时获取、何时执行以及执行时DOM的状态至关重要。
- en: 'Here''s a rundown of the most popular `<script>` placements and their respective
    advantages:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最流行的`<script>`放置位置及其各自的优势：
- en: '**`<script src>` within `<head>`**: This script will be fetched as soon as `<script>`
    is encountered during parsing. Fetching and execution will occur in serial order
    and will block other parsing from occurring. This is considered a bad practice
    as it needlessly blocks the continued parsing of the rest of the document (and
    hence increases the latency of the page load, from the user''s perspective).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<head>`中的`<script src>`：遇到`<script>`标签时，此脚本将被获取。获取和执行将按顺序进行，并且会阻止其他解析的进行。这被认为是一种不好的做法，因为它无端地阻止了文档的继续解析（因此从用户的角度增加了页面加载的延迟）。'
- en: '**`<script src>` at the end of `<body>`**: This script will be fetched as soon
    as `<script>` is encountered during parsing. Fetching and execution will occur
    in serial and will block other parsing from occurring. Usually, parsing can be
    considered mostly complete as `<script>` is the very last thing in `<body>`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<body>`末尾的`<script src>`：遇到`<script>`标签时，此脚本将被获取。获取和执行将按顺序进行，并且会阻止其他解析的进行。通常，当`<script>`是`<body>`中的最后一件事时，解析可以被认为是基本完成的。'
- en: '**`<script src defer>` within `<head>`**: This script will be enqueued for
    fetching as soon as `<script>` is encountered during parsing, and this fetch will
    occur concurrently with the parsing of the HTML at a time that is convenient for
    the browser. The script will only execute once the entire document is parsed.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<head>`中的`<script src defer>`：遇到`<script>`标签时，此脚本将被排队获取，并且此获取将与HTML解析同时进行，并且在浏览器方便的时间并发进行。脚本只有在整个文档解析完成后才会执行。'
- en: '**`<script src async>` within `<head>`**: This script will be enqueued for
    fetching as soon as `<script>` is encountered during parsing, and this fetch will
    occur concurrently with the parsing of the HTML at a time that is convenient for
    the browser. The execution of the script will occur immediately following its
    fetch and will block continued parsing.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<head>`中的`<script src async>`：遇到`<script>`标签时，此脚本将被排队获取，并且此获取将与HTML解析同时进行，并且在浏览器方便的时间并发进行。脚本的执行将在获取后立即进行，并且会阻止继续解析。'
- en: Having `<script defer>` in `<head>` is usually preferable as it can be fetched
    as soon as possible, it won't block parsing, and it'll only be executed once parsing
    has completed. This tends to give the user the fastest experience if you're serving
    up one singular bundled script and gives your JavaScript a completely parsed DOM
    that it can manipulate and render within immediately.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在`<head>`中使用`<script defer>`是可取的，因为它可以尽快获取，不会阻止解析，并且只有在解析完成后才会执行。这往往会给用户提供最快的体验，如果您提供了一个单一的捆绑脚本，并且给您的JavaScript一个完全解析的DOM，它可以立即操作和渲染。
- en: Serving JavaScript to the browser is a simple thing, in truth. It is only complicated
    by the need for us to have our web applications perform quickly for the benefit
    of users. Increasingly complex JavaScript code bases produce increasingly large
    bundles, and so loading these bundles takes time. Hence, the loading performance
    of your JavaScript is something you'll likely need to take seriously and spend
    time investigating. Performance is something easily forgotten but incredibly important.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 向浏览器提供JavaScript是一件简单的事情，事实上。只有我们需要网页应用程序快速执行以造福用户的需求才会变得复杂。日益复杂的JavaScript代码库会产生越来越大的捆绑包，因此加载这些捆绑包需要时间。因此，JavaScript的加载性能很可能是您需要认真对待并花时间调查的事情。性能是一件容易被忘记但非常重要的事情。
- en: Another similarly easily forgotten topic in the JavaScript ecosystem is security,
    and that's what we'll now be exploring.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript生态系统中同样容易被忘记的一个话题是安全性，这就是我们现在要探讨的。
- en: Security
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a vital part of a reliable code base. From the user, there is an
    implicit assumption that any given piece of software will act according to its
    functional expectations and will not lead to the compromise of their data or devices.
    *Clean code* considers security as it does other functional expectations—as a
    vital requirement that should be carefully fulfilled and thoroughly tested.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是可靠代码库的重要组成部分。用户有一个内在的假设，即任何给定的软件都会按照其功能期望的方式行事，并且不会导致其数据或设备的妥协。*干净的代码*将安全性视为其他功能期望一样重要的要求，应该仔细履行并经过彻底测试。
- en: Since JavaScript is predominantly used in a networked situation—either on the
    server side or client side, it is forever fraught with the possibility of security
    vulnerabilities. And the fact that browsers are, effectively, sandboxed vehicles
    of *remote code execution* means that our end users are susceptible to just as
    much risk as we are. To protect ourselves and our users, we need to have a diverse
    understanding of the types of vulnerabilities that exist and how to counteract
    them. There are reams and reams of intimidating information about security vulnerabilities
    in the wild. We cannot hope to cover all of them in this book, but hopefully,
    if we explore a couple of the common vulnerabilities, then we'll be more generally
    cautious and aware and can begin to understand the types of measures we should
    put in place.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript主要用于网络环境，无论是在服务器端还是客户端，它都存在安全漏洞的可能性。而浏览器实际上是沙盒化的*远程代码执行*工具，这意味着我们的最终用户和我们一样容易受到风险。为了保护自己和用户，我们需要对存在的各种漏洞类型以及如何对抗它们有多方面的了解。关于安全漏洞的信息非常庞大且令人生畏。我们无法希望在本书中涵盖所有内容，但希望如果我们探讨一些常见的漏洞，那么我们将更加谨慎和警觉，并且可以开始理解我们应该采取的措施类型。
- en: Cross-Site Scripting
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: '**Cross-Site Scripting** (**XSS**) is a vulnerability that enables attackers
    to inject their own executable code (usually JavaScript) into the frontend of
    a web application so that browsers will execute as if it were trusted. There are
    many ways XSS can manifest but these can all be boiled down to two core types:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**（**XSS**）是一种漏洞，使攻击者能够将自己的可执行代码（通常是JavaScript）注入到Web应用程序的前端，以便浏览器将其执行为受信任的代码。XSS可以以许多方式表现，但都可以归结为两种核心类型：'
- en: '**Stored XSS**: This involves an attacker somehow saving executable code within
    seemingly innocuous data to a web application that is persisted and then rendered
    back to other users of the web application. A primitive example of this is a social
    media website that allows me to specify my name as HTML (for example, `<em>James!</em>`)
    but without preventing the inclusion of potentially dangerous executable HTML,
    allowing me to specify a name such as `<script>alert(''XSS!'')...`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储型XSS**：这涉及攻击者以某种方式将可执行代码保存在看似无害的数据中，然后将其持久化到Web应用程序中，然后再呈现给Web应用程序的其他用户。一个简单的例子是一个社交媒体网站，允许我将我的名字指定为HTML（例如，`<em>James!</em>`），但没有阻止包含潜在危险的可执行HTML，允许我指定一个名字，例如`<script>alert(''XSS!'')...`。'
- en: '**Reflected XSS**: This involves an attacker sending a victim to a URL whilst
    sending their executable payload along with the request, either in the URL, an
    HTTP header, or the request body. This executable payload is then executed when
    the user lands on the page. An example of this would be a search page that reflects a
    query back to the user (a common feature of any search page) but does so in a
    way that fails to escape HTML, meaning that the attacker need only send their
    victim to `/search?q=<script>alert(''XSS!'')...`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反射型XSS**：这涉及攻击者向受害者发送URL的同时，将可执行有效负载发送到请求中，无论是在URL、HTTP标头还是请求正文中。当用户登陆页面时，将执行此可执行有效负载。一个例子是反射查询回到用户的搜索页面（任何搜索页面的常见特征），但以未能转义HTML的方式进行，这意味着攻击者只需将其受害者发送到`/search?q=<script>alert(''XSS!'')...`。'
- en: The way that either stored or reflected payloads are rendered within a page
    is crucial here. Traditionally, XSS vectors were limited to the server-side rendering
    of unescaped user-entered HTML. So, if Bob sets his social media account name
    to `<script>alert("Bob's XSS")...`, then when Bob's page is requested from the
    server, the markup returned will include that `<script>` ready to be parsed and
    executed by the browser. Nowadays, however, SPAs and websites that involve client-side
    rendering are far more common, meaning that instead of the server being at fault
    for allowing unescaped HTML into the document's markup, it is the client (the
    JavaScript code base) that is at fault for rendering dangerous content directly
    into the DOM. XSS attacks that rely on client-side rendering are hence often called
    **DOM-based XSS**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 存储或反射的有效负载在页面中的呈现方式至关重要。传统上，XSS向量仅限于未经转义的用户输入HTML的服务器端呈现。因此，如果Bob将他的社交媒体账户名称设置为`<script>alert("Bob's
    XSS")...`，那么当服务器请求Bob的页面时，返回的标记将包括该`<script>`，准备由浏览器解析和执行。然而，现在，单页应用程序和涉及客户端呈现的网站更加普遍，这意味着服务器不再因允许未经转义的HTML进入文档标记而受到责备，而是客户端（JavaScript代码库）因将危险内容直接呈现到DOM而受到责备。因此，依赖于客户端呈现的XSS攻击通常被称为**基于DOM的XSS**。
- en: XSS payloads can come in a variety of forms. It's very rarely as simple as a
    `<script>` tag. Attackers use a variety of complex encodings, archaic HTML, and
    even CSS to embed their nefarious JavaScript. Cleansing XSS from strings is therefore
    not trivial and it is instead recommended to place **no trust whatsoever** in
    user-entered content.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: XSS有效负载可以采用各种形式。很少是一个简单的`<script>`标签。攻击者使用各种复杂的编码、古老的HTML，甚至CSS来嵌入他们邪恶的JavaScript。因此，从字符串中清除XSS并不是微不足道的，而是建议**绝对不要信任**用户输入的内容。
- en: 'We can imagine a scenario in which our JavaScript code base has a `UserProfile`
    component that renders the name and profile information of any user. Upon initialization,
    this component requests its data from a REST endpoint that looks like `/profile/{id}.json`,
    returning the following JSON:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象这样一个场景，我们的JavaScript代码库有一个`UserProfile`组件，用于呈现任何用户的名称和个人资料信息。在初始化时，该组件从一个看起来像`/profile/{id}.json`的REST端点请求其数据，返回以下JSON：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This component then renders the received name to the DOM via `innerHTML`, without
    escaping or cleansing its contents:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该组件通过`innerHTML`将接收到的名称呈现到DOM中，而不转义或清理其内容：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All users who render the `UserProfile` component are liable to execute arbitrary
    (potentially damaging) HTML. This would be an issue whether the arbitrary HTML
    comes from a reflected or a stored source.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有呈现`UserProfile`组件的用户都有可能执行任意（可能有害的）HTML。无论任意HTML来自反射还是存储的来源，这都将是一个问题。
- en: 'The prevalence of common JavaScript frameworks that abstract DOM rendering
    means that an attacker need only find a vulnerability within a library or framework
    to attack thousands of different websites. Most frameworks, thankfully, by default,
    have interpolation mechanisms that force inserted data to be rendered as text,
    not HTML. React, for example, will always produce text nodes for any data inserted
    via JSX''s interpolation delimiters (curly braces). We can see this in effect
    here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的JavaScript框架的普及使得攻击者只需在库或框架中找到漏洞，就可以攻击成千上万个不同的网站。大多数框架默认情况下都有插值机制，强制插入的数据被呈现为文本而不是HTML。例如，React将始终为通过JSX的插值定界符（花括号）插入的任何数据生成文本节点。我们可以在这里看到这种效果：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This results in the data containing `<script>` to be literally rendered as
    text, so that the resulting `innerHTML` of the `<body>` element is this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致包含`<script>`的数据被文字直接呈现，因此`<body>`元素的`innerHTML`结果是这样的：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because the potentially dangerous HTML was rendered as text, no execution can
    occur and the XSS attack is prevented. This isn''t the only way that an XSS attack
    can occur though. It''s common for client-side frameworks to have templating solutions
    that rely on inline `<script>` tags, like so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为潜在危险的HTML被呈现为文本，所以不会发生执行，XSS攻击被阻止了。然而，这并不是XSS攻击发生的唯一方式。客户端框架通常有依赖于内联`<script>`标签的模板解决方案，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is a convenient way of declaring templates to be used in the later rendering
    of specific components, but such templates are often used in combination with
    server-side rendering and interpolation, and such a combination is liable to XSS
    if an attacker can force a dangerous string to be interpolated by the server into
    the template, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方便的声明模板，用于以后渲染特定组件，但这种模板通常与服务器端渲染和插值结合使用，如果攻击者可以强制服务器将危险字符串插值到模板中，则可能会导致XSS，如下所示：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If `user.data.name` contains nefarious HTML, then there is nothing that our
    JavaScript can do on the client side to prevent the attack. By the time we render
    our code, it may even be too late.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`user.data.name`包含恶意HTML，则我们的JavaScript在客户端无法阻止攻击。当我们渲染我们的代码时，甚至可能已经太迟了。
- en: 'In modern web applications, we have to be wary of XSS, either stored or reflected,
    rendered on both the server and the client. It''s a mind-bending combination of
    possible vectors, so it''s crucial to ensure that you''re employing a combination
    of countermeasures:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web应用程序中，我们必须警惕存储或反射的XSS，在服务器和客户端上都会渲染。这是可能矢量的令人费解的组合，因此至关重要的是确保您使用一系列对策：
- en: Never trust user-entered data. Ideally, do not allow users to enter any HTML.
    If they can, then use an HTML parsing library and whitelist specific tags and
    attributes that you trust.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要相信用户输入的数据。最好不要允许用户输入任何HTML。如果他们可以，那么使用HTML解析库并列出您信任的特定标签和属性。
- en: Never place untrusted data in an HTML comment, a `<script>` element, a `<style>`
    element, or where an HTML tag or attribute name should appear (for example, `<HERE
    ...>` or `<div HERE=...>`). If you must, place it within an HTML element and ensure
    it is fully escaped (for example, `&` → `&amp;` and `"` → `&quot;`).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在HTML注释、`<script>`元素、`<style>`元素或应该出现HTML标签或属性名称的地方（例如`<HERE ...>`或`<div
    HERE=...>`）中放置不受信任的数据。如果必须这样做，请将其放在HTML元素中，并确保它已完全转义（例如`&` → `&amp;`和`"` → `&quot;`）。
- en: 'If inserting untrusted data into regular (non-JavaScript) HTML attributes,
    escape all ASCII values less than `256` with the `&#xHH;` format. If inserting
    into a regular HTML element''s contents, then escaping the following characters
    is sufficient: `&`, `<`, `>`, `"`, `''`, and `/`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将不受信任的数据插入常规（非JavaScript）HTML属性，则使用`&#xHH;`格式转义所有小于`256`的ASCII值。如果插入到常规HTML元素的内容中，则转义以下字符就足够了：`&`、`<`、`>`、`"`、`'`和`/`。
- en: Avoid inserting untrusted data into areas where JavaScript is executed, such
    as `<script>x = 'HERE'</script>` or `<img onmouseover="x='HERE'">`, but if you
    absolutely must, ensure that the data is escaped so that it cannot break out of
    its quotes or its containing HTML.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将不受信任的数据插入JavaScript执行的区域，例如`<script>x = 'HERE'</script>`或`<img onmouseover="x='HERE'">`，但如果您绝对必须这样做，请确保数据已转义，以便它无法打破其引号或包含的HTML。
- en: Instead of embedding JavaScript-readable data in a `<script>`, use JSON to transmit
    data to the client, either via a request or by embedding it in a no-op element
    such as `<div>` (ensuring it's fully HTML-escaped!) and then extracting and deserializing
    it yourself.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在`<script>`中嵌入JavaScript可读数据，而是使用JSON将数据传输到客户端，可以通过请求或将其嵌入到`<div>`（确保已完全HTML转义！），然后自行提取和反序列化。
- en: Use an appropriately restrictive **Content Security Policy** (**CSP**) (we will
    explain this in the next section).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当限制的**内容安全策略**（**CSP**）（我们将在下一节中解释）。
- en: These countermeasures are not exhaustive, so it's advisable to also have a thorough
    readthrough of the **Open Web Application Security Project's** (**OWASP**) Cross-Site
    Scripting Prevention Cheatsheet: [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对策并不详尽，因此建议您仔细阅读**开放Web应用程序安全项目**（**OWASP**）跨站脚本攻击预防备忘单：[https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)。
- en: Content Security Policy
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容安全策略
- en: As an added security measure, it's important to also configure an appropriate
    CSP.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的安全措施，配置适当的CSP也很重要。
- en: CSP is a relatively new HTTP header that is available on all modern browsers.
    It is *not* universally supported or respected, so it should not be depended upon
    as our sole defense against XSS. Nonetheless, if correctly configured, it can
    prevent the majority of XSS vulnerabilities. Browsers that don't support CSP will
    fall back to their default behavior of the same-origin policy, which itself provides
    a level of crucial security.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: CSP 是一个相对较新的 HTTP 标头，在所有现代浏览器上都可用。它 *不* 是普遍支持或受尊重的，因此不应该依赖它作为我们对抗 XSS 的唯一防御。尽管如此，如果正确配置，它可以防止大多数
    XSS 漏洞。不支持 CSP 的浏览器将退回到它们的同源策略的默认行为，这本身提供了一定级别的关键安全性。
- en: The same-origin policy is a vital security mechanism employed by all browsers
    that restricts the ability of documents or scripts when accessing some resources
    from other origins (origins match when they share the same protocol, port, and
    host). This policy means that, for example, JavaScript within `leah.example.org`
    cannot fetch `alice.example.org/data.json`. With the advent of CSP, it is, however,
    possible for `alice.example.org` to express a level of trust and provide such
    access by disabling the same-origin policy just for `leah.example.org`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略是所有浏览器采用的一种重要的安全机制，它限制了文档或脚本在访问其他来源的一些资源时的能力（当它们共享相同的协议、端口和主机时，来源匹配）。这一政策意味着，例如，`leah.example.org`
    中的 JavaScript 不能获取 `alice.example.org/data.json`。然而，随着 CSP 的出现，`alice.example.org`
    可以通过禁用同源策略来表达对 `leah.example.org` 的信任并提供这样的访问。
- en: The `Content-Security-Policy` header allows you to specify where different types
    of resources are allowed to be loaded from. It is essentially an origin whitelist
    that the browser will validate all outgoing requests against.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Security-Policy` 标头允许您指定不同类型的资源允许从哪里加载。它本质上是一个浏览器将根据其验证所有传出请求的来源白名单。'
- en: 'It can be specified as a regular HTTP header:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被指定为常规的 HTTP 标头：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or it can be specified as a `meta` tag:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以指定为 `meta` 标签：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The format of the value is one or more policy directives, separated by semicolons,
    where each policy directive starts with the `fetch` directive. These designate
    the type of resource (for example, `img-src`, `media-src`, and `font-src`), or
    the default (`default-src`) that all directives will fall back on if they're not
    separately specified. The fetch directive is followed by one or more space-separated
    sources, where each source specifies where resources can be loaded from for that
    resource type. Possible sources include URLs, protocols, `'self'` (to refer to
    the document's own origin), and more.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 值的格式是一个或多个策略指令，用分号分隔，每个策略指令以 `fetch` 指令开头。这些指定资源类型（例如 `img-src`、`media-src`
    和 `font-src`）或默认（`default-src`），如果它们没有单独指定，所有指令都将回退到默认。fetch 指令后面是一个或多个以空格分隔的来源，其中每个来源指定该资源类型的资源可以从哪里加载。可能的来源包括
    URL、协议、`'self'`（指文档自己的来源）等。
- en: 'Here are some examples of CSP values with explanations for each one:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 CSP 值的示例，以及每个值的解释：
- en: '`default-src ''self''`: This is the maximally restrictive directive that declares
    that only resources from the same origin as the document itself can be loaded
    within the document (whether from `<img>`, `<script>`, XHR, or anything else).
    No other origins are allowed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src ''self''`：这是最大限度的限制指令，声明只有来自文档本身相同来源的资源才能在文档内加载（无论是来自 `<img>`、`<script>`、XHR
    还是其他任何地方）。不允许其他来源。'
- en: '`default-src ''self''; img-src cdn.example.com`: This directive declares that
    only resources from the same origin as the document itself can be loaded, except
    in the case of images (for example, `<img src>` and CSS-declared images), which
    can be loaded from the origin, `cdn.example.com`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src ''self''; img-src cdn.example.com`：这个指令声明只有来自文档本身相同来源的资源才能被加载，除了图片（例如
    `<img src>` 和 CSS 声明的图片）可以从 `cdn.example.com` 来加载。'
- en: '`default-src ''self'' *.trusted.example.com`: This declares that only resources
    from the same origin *or* resources from `*.trusted.example.com` are valid.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src ''self'' *.trusted.example.com`：这声明只有来自相同来源的资源 *或* 来自 `*.trusted.example.com`
    的资源是有效的。'
- en: '`default-src https://bank.example.com`: This declares that only resources from
    the SSL-secured origin, `https://bank.example.com`, can be loaded.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src https://bank.example.com`：这声明只有来自 SSL 安全来源 `https://bank.example.com`
    的资源才能被加载。'
- en: '`default-src *; script-src https:`: This declares that resources can be loaded
    from any valid URL except in the case of `<script src>`, which must load its resources
    from an HTTPS URL.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src *; script-src https:`：这声明资源可以从任何有效的 URL 加载，除了 `<script src>` 必须从
    HTTPS URL 加载其资源的情况。'
- en: 'What an appropriately restrictive CSP is will depend entirely upon your specific
    web application, what kind of user-generated content you may be dealing with,
    and the sensitivity of the data you deal with. Having an appropriate CSP not only
    protects you from creating potential vectors of XSS (by loading from potentially
    compromised origins) but can help to counteract executing XSS vulnerabilities
    as well. CSP defends against XSS in the following specific ways:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 适当限制的 CSP 完全取决于您的特定 Web 应用程序、您可能正在处理的用户生成的内容的类型以及您处理的数据的敏感性。适当的 CSP 不仅可以保护您免受创建潜在的
    XSS 向量（通过从潜在受损的来源加载）的威胁，还可以帮助抵消执行 XSS 漏洞。CSP 以以下特定方式防御 XSS：
- en: CSP disables `eval()` and other similar techniques from working. These are common
    vectors for XSS, especially in legacy browsers where such methods have been used
    to parse JSON. You can explicitly enable `eval` via the `'unsafe-eval'` source
    if you so desire.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSP 禁用了 `eval()` 和其他类似的技术。这些是 XSS 的常见向量，特别是在旧版浏览器中，这些方法已被用于解析 JSON。如果您愿意，可以通过
    `'unsafe-eval'` 源来显式启用 `eval`。
- en: CSP disables inline `<script>` and `<style>` tags, the JavaScript protocol,
    and inline event handles (for example, `<img onload="..." />`). These are all
    common XSS vectors. You can explicitly enable these by specifying `unsafe-inline`
    as a source for the relevant fetch directives, but it's recommended to instead
    load your scripts and styles from external sources so the origins can be validated
    against your CSP whitelist by the browser.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSP禁用了内联的`<script>`和`<style>`标签，JavaScript协议以及内联事件处理程序（例如`<img onload="..."
    />`）。这些都是常见的XSS向量。您可以通过为相关的获取指令指定`unsafe-inline`作为源来显式启用这些功能，但建议您从外部来源加载您的脚本和样式，以便浏览器可以根据CSP白名单对其来源进行验证。
- en: As a last-ditch effort, CSP, if well configured, can prevent currently executing
    XSS from loading its own malicious resources or calling home with compromised
    data, limiting its ability to do damage.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的努力，如果CSP配置良好，它可以防止当前执行的XSS加载自己的恶意资源或者使用被破坏的数据进行调用，从而限制其造成的损害。
- en: Subresource Integrity
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子资源完整性
- en: '**Subresource Integrity** (**SRI**) is a security feature within browsers that
    allows us to verify that the resources they fetch are delivered without any unexpected
    manipulation or compromise. Such manipulation could potentially occur where the
    asset is served from (for example, your CDN is hacked) or during network transmission
    (for example, a middleman attack).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**子资源完整性**（**SRI**）是浏览器内的一项安全功能，允许我们验证它们获取的资源是否在传递过程中没有受到任何意外的篡改或损害。这种篡改可能发生在资源提供的地方（例如，您的CDN被黑客攻击）或者在网络传输过程中（例如，中间人攻击）。'
- en: 'To verify your script, you must provide an integrity attribute that contains
    the name of a hashing algorithm (such as `sha256`, `sha384`, or `sha512`) and
    then the hash itself. Here''s an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的脚本，您必须提供一个包含哈希算法名称（例如`sha256`、`sha384`或`sha512`）和哈希本身的完整性属性。以下是一个例子：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To generate that hash, you can use OpenSSL''s CLI as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成该哈希，您可以使用OpenSSL的CLI如下：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to using the integrity attribute on `<script>`, you can use it
    on `<link>` for the verification of CSS style sheets. To enforce SRI, you can
    use the helpful CSP header:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在`<script>`上使用完整性属性外，您还可以在`<link>`上使用它来验证CSS样式表。要强制执行SRI，您可以使用有用的CSP头部：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Doing this will ensure that any scripts or style sheets that exist without an
    integrity hash will fail to load. Once fetched, if the provided integrity hash
    does not match the hash of the received file, then it will be ignored (as if it
    wasn't fetched). Using SRI together with CSP gives you a considerable defense
    against XSS.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将确保任何没有完整性哈希的脚本或样式表都无法加载。一旦获取，如果提供的完整性哈希与接收到的文件的哈希不匹配，那么它将被忽略（就好像没有被获取）。使用SRI和CSP一起可以有效防御XSS。
- en: Cross-Site Request Forgery
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站点请求伪造
- en: '**Cross-Site Request Forgery** (**CSRF**) is when commands, usually in the
    form of HTTP GET or POST requests, are transmitted from a user without their intent,
    by malicious code. A primitive example would be if a banking website at `bank.example.com`
    had an API endpoint that allowed logged-in users to transfer a given amount to
    a specified account number. The endpoint might be as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站点请求伪造**（**CSRF**）是指命令以HTTP GET或POST请求的形式从用户端传输，而用户并没有意识到，这是由恶意代码造成的。一个原始的例子是，如果`bank.example.com`的银行网站有一个API端点，允许已登录的用户将一定金额转账到指定的账户号码。端点可能如下所示：'
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Even if users were authenticated via a session cookie on the `bank.example.com`
    domain, a malicious website could easily embed and submit `<form>` directing the
    transfer to their own account, like so:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户通过`bank.example.com`域上的会话cookie进行了身份验证，恶意网站仍然可以轻松地嵌入并提交`<form>`，将转账指向他们自己的账户，如下所示：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Regardless of what HTTP method is used by the endpoint or what kind of request
    body or parameters it accepts, it is liable to a CSRF attack unless it ensures
    that the request comes from its own website. This problem is partially solved
    by the same-origin policy inherent to browsers, which prevents some types of requests
    from taking place (such as a JSON POST request via XHR or PUT/DELETE requests),
    but there is nothing inherent in the browser to prevent a user innocently clicking
    a link to a website or submitting a form that forges a malicious POST request.
    These actions are, after all, the entire purpose of the browser.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 无论端点使用何种HTTP方法，或者接受何种请求体或参数，除非确保请求来自自己的网站，否则它都容易受到CSRF攻击。浏览器内置的同源策略部分解决了这个问题，阻止了某些类型的请求（例如通过XHR进行的JSON
    POST请求或PUT/DELETE请求），但浏览器内部没有任何机制来防止用户无意中点击链接或提交伪造恶意POST请求的表单。毕竟，这些行为正是浏览器的整个目的。
- en: 'Since there is no inherent mechanism of the web that prevents CSRF, developers
    have come up with their own defenses. One common mechanism to prevent CSRF is
    with a CSRF token (which should really be called an **Anti-CSRF Token**). This
    is a generated key (random, long, and impossible to guess) that is sent down to
    the client with each regular request while also being stored on the server as
    part of the user''s session data. The server will then require the browser to
    send that key along with any subsequent HTTP requests to verify the source of
    each request. So, instead of just two parameters, our `/transfer` endpoint will
    now have a third, the token:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web没有内在的机制来防止CSRF，开发人员已经提出了自己的防御机制。防止CSRF的一种常见机制是CSRF令牌（实际上应该被称为**反CSRF令牌**）。这是一个生成的密钥（随机、长且不可能被猜到），它会随着每个常规请求一起发送到客户端，同时也存储在服务器上作为用户会话数据的一部分。然后服务器将要求浏览器在任何后续的HTTP请求中发送该密钥，以验证每个请求的来源。因此，我们的`/transfer`端点现在将有第三个参数，即令牌。
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The server can then verify that the provided token exists on that user''s session
    data. There are many libraries and frameworks that simplify this. There are also
    a variety of adaptations and configurations of this basic token mechanism. Some
    of them will only generate a token for a given amount of time, or a given request
    cycle, whereas others will provide a singular token for that user''s entire session.
    There are also a variety of ways for the token to be sent downstream to the client.
    The most common is within the response payload as part of the document markup,
    usually in the form of a `<meta>` element in `<head>`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以验证提供的令牌是否存在于用户的会话数据中。有许多库和框架可以简化此过程。还有许多基本令牌机制的适应和配置。其中一些仅会为特定时间或特定请求周期生成令牌，而其他一些则会为用户整个会话提供一个唯一的令牌。还有许多方法可以将令牌发送到客户端。最常见的方法是在响应有效负载中作为文档标记的一部分，通常以`<meta>`元素的形式出现在`<head>`中：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This can then be grabbed by JavaScript and sent with any subsequent GET or
    POST requests made dynamically by the JavaScript. Or in the case of a conventional
    website without client-side rendering, the CSRF token can be sent downstream directly
    embedded in the `<form>` markup as a hidden `<input>`, which naturally forms part
    of the form''s eventual submission to the server:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JavaScript可以获取这些令牌，并在JavaScript动态生成的任何后续GET或POST请求中发送。或者在没有客户端渲染的传统网站的情况下，CSRF令牌可以直接嵌入到`<form>`标记中作为隐藏的`<input>`，这自然地成为表单最终提交到服务器的一部分：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If your web application is susceptible to XSS, then it is also inherently susceptible
    to CSRF, as the attacker will usually have access to the CSRF token and hence
    be able to masquerade any requests they make as legitimate, and the server won''t
    be able to tell the difference. So, strong anti-CSRF measures are not sufficient
    on their own: you must have countermeasures for other potential vulnerabilities
    as well.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Web应用程序容易受到XSS攻击，那么它也会天然地容易受到CSRF攻击，因为攻击者通常会有访问CSRF令牌的权限，因此能够伪装成合法请求，而服务器无法区分。因此，强大的反CSRF措施本身是不够的：您还必须对其他潜在漏洞采取对策。
- en: Whatever anti-CSRF measure you use, the crucial need is for every request that
    mutates a user's data or carries out a command to be verified as coming from a
    legitimate page within the web application itself and not some maliciously crafted
    external source. To get a more thorough understanding of CSRF and the available
    countermeasures, I recommend reading and fully digesting **OWASP's CSRF Prevention
    Cheatsheet**:[https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用何种反CSRF措施，关键的需要是对每个对用户数据进行变异或执行命令的请求进行验证，以确保其来自Web应用程序本身的合法页面，而不是一些恶意构造的外部来源。为了更全面地了解CSRF和可用的对策，我建议阅读并充分消化**OWASP的CSRF预防备忘单**：[https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)。
- en: Other security vulnerabilities
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全漏洞
- en: XSS and CSRF only touch the surface of the types of attacks that we should be
    prepared for. Defending against all possible vulnerabilities is incredibly challenging
    and usually unrealistic, but we'd be foolish to not write code that is resilient
    against the most prevalent ones. A good general understanding of the types of
    vulnerabilities that exist can help us to be generally cautious in the code we
    write.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: XSS和CSRF只触及了我们应该做好准备的攻击类型的表面。防御所有可能的漏洞是非常具有挑战性的，通常是不现实的，但如果我们不编写能够抵御最普遍漏洞的代码，那就是愚蠢的。对存在的漏洞类型有一个良好的一般了解可以帮助我们在编写代码时保持一般的谨慎。
- en: XSS, as explored, is a very diverse vulnerability with many possible vectors
    of attack. But we can defend against it in a general way by consistently and correctly
    discerning between trusted and untrusted data. We can limit the possibility of
    untrusted data wreaking havoc by placing it in only very specific places, correctly
    escaping it, and ensuring that we have an appropriately restrictive CSP. Likewise,
    with CSRF, there are countless ways for an attacker to perform it, but having
    a solid Anti-CSRF Token mechanism will save you from most of them. All we can
    hope for in the realm of security, given our limited resources, is that we can
    have coverage against the majority of popular attacks.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所探讨的，XSS是一种非常多样化的漏洞，有许多可能的攻击向量。但我们可以通过一种一般的方式来防御它，即通过始终正确地区分受信任和不受信任的数据。我们可以通过将不受信任的数据放置在非常特定的位置、正确转义它，并确保我们有适当限制的CSP来限制不受信任数据造成破坏的可能性。同样，对于CSRF，攻击者可以以无数种方式执行它，但拥有一个坚固的反CSRF令牌机制将使您免受大部分攻击。在安全领域，鉴于我们有限的资源，我们所能期望的就是能够对抗大多数流行的攻击。
- en: 'Here''s a rundown of some other popular vulnerabilities that are worth being
    aware of:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他值得注意的流行漏洞：
- en: '**SQL or NoSQL injections**: Any user-submitted data that is expressed via
    a SQL or NoSQL query can, if not correctly escaped, provide an attacker with access
    to your data and the ability to read from, mutate, or destroy it. It''s similar
    to XSS in that both are forms of *injection attacks*, and so our defense against
    it, again, comes down to identifying untrusted data and then correctly escaping
    it.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL或NoSQL注入**：任何用户提交的数据，如果未正确转义，都可能使攻击者访问您的数据并能够读取、修改或销毁数据。这类似于XSS，因为两者都是*注入攻击*的形式，所以我们对其的防御又一次归结为识别不受信任的数据，然后正确转义它。'
- en: '**Authentication/password attacks**: An attacker can gain unauthorized access
    to a user''s account by guessing their password, brute-forcing combinations, or
    using a rainbow table (a database of common password hashes). Generally, it is
    advisable to not create your own authentication mechanisms, but instead to rely
    on trusted libraries and frameworks. You should always ensure that you''re using
    a secure hashing algorithm (such as *bcrypt*). A good resource is OWASP''s **Password
    Storage Cheat Sheet** ([https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证/密码攻击**：攻击者可以通过猜测密码、暴力破解组合或使用彩虹表（常见密码哈希的数据库）来未经授权地访问用户的帐户。一般来说，最好不要创建自己的身份验证机制，而是依赖于可信的库和框架。您应该始终确保使用安全的哈希算法（如*bcrypt*）。一个很好的资源是OWASP的**密码存储备忘单**（[https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)）。'
- en: '**Dependency hijacking**: An attacker can gain access over your server-side
    or frontend code base by hijacking one of your dependencies. They may gain access
    to an npm package that exists in your dependency graph (search online for the
    *left-pad incident*) or compromise a CMS or CDN that you use to store JavaScript
    assets. To counteract these types of vulnerabilities, ensure that you use a secure
    package management system such as Yarn, try to use fixed version patterns in your
    `package.json`, always check changelogs, and on the frontend, have an appropriately
    restrictive CSP to prevent any malicious code from calling home.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖劫持**：攻击者可以通过劫持您的依赖之一来获得对您的服务器端或前端代码库的访问权限。他们可能会获得对您依赖图中存在的npm包的访问权限（在网上搜索*left-pad事件*），或者损害您用于存储JavaScript资产的CMS或CDN。为了对抗这些类型的漏洞，确保您使用安全的包管理系统，如Yarn，尝试在`package.json`中使用固定版本模式，始终检查更改日志，并在前端使用适当限制的CSP，以防止任何恶意代码调用主页。'
- en: There is always the possibility of an attack, and so we need to build that risk
    into our system designs. We cannot expect to be immune to these vulnerabilities,
    but when they do occur, we can ensure that we can fix them quickly, communicate
    transparently with affected users, and ensure that we carefully consider how we
    can prevent such vulnerabilities from occurring again.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在被攻击的可能性，因此我们需要将这种风险纳入我们的系统设计中。我们不能指望对这些漏洞免疫，但当它们发生时，我们可以确保我们能够快速修复它们，与受影响的用户透明沟通，并确保我们仔细考虑如何防止这些漏洞再次发生。
- en: Whether we're creating a framework for developers or a UI for non-technical
    users, the consumers of our code will always expect it to behave securely. This
    expectation is increasingly being encoded into law (for example, in EU law, the **General
    Data Protection Regulation** (**GDPR**)), so it's crucial to take it seriously
    and spend a good amount of time on learning and prevention. The practice of security
    is yet another example of how clean code is not only about our syntax and design
    patterns but about the very significant ways that our code affects our users and
    their everyday lives.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是为开发人员创建框架还是为非技术用户创建UI，我们的代码使用者总是期望它能够安全地运行。这种期望越来越多地被编码到法律中（例如，在欧盟法律中的《通用数据保护条例》（GDPR）），因此认真对待并花费大量时间学习和预防是至关重要的。安全实践是另一个例子，说明干净的代码不仅仅关乎我们的语法和设计模式，还关乎我们的代码如何显著地影响我们的用户和他们的日常生活。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored a variety of real-world challenges—topics
    that any JavaScript programmer may find themselves exposed to both within the
    browser and on the server. Writing clean code in JavaScript is not only about
    the language itself but about the web ecosystem that it exists within and the
    demands that this brings. Through our explorations of the DOM, routing, dependency
    management, and security, we have hopefully gained an insight into the technicalities
    of the problem domains that JavaScript often deals with, and an appreciation for
    the many frameworks, libraries, and standards-driven APIs that exist to help us
    to deal with these problems.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了各种现实世界的挑战——任何JavaScript程序员在浏览器和服务器上都可能面临的话题。在JavaScript中编写干净的代码不仅仅是关于语言本身，还涉及到它存在的网络生态和这带来的需求。通过我们对DOM、路由、依赖管理和安全性的探索，我们希望能够深入了解JavaScript经常处理的问题领域的技术细节，并对存在的许多框架、库和标准驱动的API有所了解，以帮助我们解决这些问题。
- en: In the next chapter, we'll delve into the art of writing clean tests, a vitally
    important task, not only because it gives us confidence in our own code, but because
    it ensures the kind of reliability that users rightfully expect from our software.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨编写干净测试的艺术，这是一项至关重要的任务，不仅因为它让我们对自己的代码充满信心，还因为它确保了用户对我们软件的合理期望的可靠性。
