- en: Modeling with Object-Oriented Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用面向对象的Java建模
- en: In this chapter, you're going to learn how to create classes and objects in
    Java. Object-oriented programming allows us to explain highly complicated systems
    to the computer and also ourselves. In addition, there's a lot more to learn about
    object-oriented programming in terms of how objects fit together, the kinds of
    relationships they can have, and what we can do with objects to make our programs
    easier to write. We will also walk through the topics of creating custom classes,
    member variables, and member functions. Finally, we will look into a very special
    member assigned to our custom classes, that is, the constructor, and types of
    constructor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Java中创建类和对象。面向对象编程使我们能够向计算机和自己解释高度复杂的系统。此外，关于对象如何相互配合、它们可以有哪些关系以及我们可以如何使用对象来使我们的程序更容易编写，还有很多要学习的关于面向对象编程的内容。我们还将讨论创建自定义类、成员变量和成员函数的主题。最后，我们将研究分配给我们自定义类的一个非常特殊的成员，即构造函数，以及构造函数的类型。
- en: 'We are going to cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating classes and objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类和对象
- en: Creating custom classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义类
- en: Creating member variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建成员变量
- en: Creating member functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建成员函数
- en: Creating constructors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构造函数
- en: Types of constructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的类型
- en: Creating classes and objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类和对象
- en: In this section, you'll take the first real steps of learning object-oriented
    programming in Java. So I guess the first question to ask is, "What is object-oriented
    programming?" Well, at a high level, object-oriented programming is the creation
    of objects, discrete code, and logic entities that are unique and separate from
    each other but can have complicated relationships.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将迈出学习Java面向对象编程的第一步。所以我想问的第一个问题是，“什么是面向对象编程？”嗯，在高层次上，面向对象编程是创建对象的过程，这些对象是独特的、相互独立的代码和逻辑实体，但它们之间可以有复杂的关系。
- en: When we write object-oriented code, we begin to deal with and think about the
    code as though it were a collection of physical pieces or objects. Java is by
    its very nature an object-oriented language. So, if you've been learning Java,
    at the very least, you've been using objects without realizing it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写面向对象的代码时，我们开始将代码看作一组物理部件或对象。Java本质上是一种面向对象的语言。因此，如果你一直在学习Java，至少你已经在使用对象而没有意识到。
- en: 'To see the power of object-oriented programming, take a look at the following
    program (`GettingObjectOriented.java`):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到面向对象编程的威力，看一下下面的程序（`GettingObjectOriented.java`）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This program is a very basic input/output program, the kind you''ve probably
    already written if you''ve been learning Java. In this program, we make use of
    a `Scanner` object that we call `reader`, and you''ll notice that we utilize `reader`
    on two lines: on one line, we declare and initialize `reader`, and on the other
    line, we call the `next()` function of `reader` to acquire some user input.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是一个非常基本的输入/输出程序，如果你一直在学习Java，你可能已经写过这种程序。在这个程序中，我们使用了一个名为`Scanner`的对象，我们称之为`reader`，你会注意到我们在两行上使用了`reader`：在一行上，我们声明并初始化了`reader`，在另一行上，我们调用了`reader`的`next()`函数来获取一些用户输入。
- en: The important thing I'd like you to notice about the relationship between these
    two lines of code is that when we declare `reader`, we provide it with some additional
    information besides simply the command to create a new `Scanner` object. This
    is interesting because later when we utilize the `next()` function of `reader`,
    we won't have to retell it what stream it should be reading from; instead, this
    information is automatically stored and recalled by the `reader` object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你注意到这两行代码之间的关系的重要之处是，当我们声明`reader`时，我们为它提供了除了简单地创建一个新的`Scanner`对象的命令之外的一些额外信息。这很有趣，因为当我们后来使用`reader`的`next()`函数时，我们不需要重新告诉它应该从哪个流中读取；相反，这些信息会被`reader`对象自动存储和调用。
- en: 'This is the beauty of object-oriented programming: the entities or objects
    we create can be constructed in such a way that not only do they know what to
    do with the information given to them and provide us with additional functionality,
    but also that they know exactly what information to ask to perform their later
    tasks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象编程的美妙之处：我们创建的实体或对象可以被构造成这样一种方式，不仅它们知道如何处理给予它们的信息并为我们提供额外的功能，而且它们也知道要询问什么信息来执行它们以后的任务。
- en: Let's make sure we have our terminology straight. First, let's analyze the `new
    Scanner(System.in)` part of our code. This command tells Java to create a new
    object, a new `Scanner` object, for use in our program. This object has location
    and memory in which it lives, and this location is referenced by the `reader`
    variable. It would be possible for us to create multiple variables that all point
    toward the same `Scanner` object; however, in the context of this simple program,
    `reader` is our only entry point to the object's location in memory. So, we can
    often get away with referring to an object like this simply by its variable name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们的术语准确。首先，让我们分析我们代码中的`new Scanner(System.in)`部分。这个命令告诉Java为我们的程序创建一个新对象，一个新的`Scanner`对象。这个对象有它所在的位置和内存，这个位置由`reader`变量引用。我们可以创建多个变量，它们都指向同一个`Scanner`对象；然而，在这个简单程序的上下文中，`reader`是我们指向对象内存位置的唯一入口点。因此，我们通常可以通过它的变量名来简单地引用一个对象。
- en: Lastly, different objects operate in a different manner. It is possible for
    us to create multiple `Scanner` objects; they would not have the same location
    in memory, but they would share similar functionality. The piece of code and logic
    that declares what functionality an object has and how that functionality operates
    is called the object's class. In this case, we're creating an object of the `Scanner`
    class and pointing to it with the `reader` variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不同的对象以不同的方式运行。我们可以创建多个`Scanner`对象；它们在内存中的位置可能不同，但它们会共享类似的功能。声明对象具有什么功能以及该功能如何运行的代码和逻辑称为对象的类。在这种情况下，我们正在创建一个`Scanner`类的对象，并用`reader`变量指向它。
- en: This is all well and good, and we can create a whole lot of programs simply
    using the default standard libraries that Java provides; however, to really open
    the doors, we're going to need the ability to create custom classes of our own.
    Let's jump in and create one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，我们可以简单地使用Java提供的默认标准库创建许多程序；然而，为了真正打开大门，我们需要能够创建自定义的类。让我们开始并创建一个。
- en: Creating custom classes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义类
- en: Now, we could create a new class within the file we're already working in; however,
    class declaration code is a little different and logically discrete from something
    like the executed `main()` method, where the lines are executed one after another
    in order. Rather, the class we're going to create is going to serve more as a
    reference for the lines of code, such as the `Scanner reader = new Scanner(System.in);`
    code line. Generally, when working in an object-oriented language, a high-level
    object-oriented language such as Java, we simply put each and every new class
    we create in its own separate file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们已经在工作的文件中创建一个新的类；然而，类声明代码与像执行的`main()`方法之类的逻辑上是不同的，其中代码行是按顺序依次执行的。相反，我们要创建的类将更多地作为代码行的参考，比如`Scanner
    reader = new Scanner(System.in);`这行代码。通常，在面向对象的语言中，像Java这样的高级面向对象的语言，我们只需将我们创建的每一个新类放在自己单独的文件中。
- en: To create a new Java file for our class, just right-click on the package name
    on the left-hand side of the screen, that is, `gettingobjectoriented`. Then, choose
    New, followed by Java Class. Post this, we'll just be prompted to give it a name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的类创建一个新的Java文件，只需右键单击屏幕左侧的包名，即`gettingobjectoriented`。然后，选择新建，然后选择Java类。之后，我们只需提示给它一个名称。
- en: '![](img/88f2915e-e554-4960-845e-e813202442d0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88f2915e-e554-4960-845e-e813202442d0.png)'
- en: 'In this instance, we are going to create a class to provide and store some
    basic information about a person. We''ll call it the `Person` class, which creates
    person objects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建一个类来提供和存储有关一个人的一些基本信息。我们将称之为`Person`类，它创建人物对象：
- en: '![](img/ea693725-8198-41c4-97bc-b9b55944f955.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea693725-8198-41c4-97bc-b9b55944f955.png)'
- en: 'When we press Finish, NetBeans is pretty handy and sets up some really basic
    lines of code for us. It declares this class to be in our local package. This
    means that when we reference it from our `main()` method, we won''t have to import
    this class like we do with standard library ones. NetBeans is kind enough to create
    the class declaration for us. This is simply a line of code that lets the Java
    compiler know that we''re about to declare a new class as shown in the following
    screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下“完成”时，NetBeans非常方便，为我们设置了一些非常基本的代码行。它声明这个类在我们的本地包中。这意味着当我们从我们的`main()`方法中引用它时，我们不必像引用标准库那样导入这个类。NetBeans很友好地为我们创建了类声明。这只是一行代码，让Java编译器知道我们将要声明一个新的类，如下面的屏幕截图所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For now, we'll ignore the `public` keyword, but know that it's pretty necessary
    here. The `class` keyword self-explanatorily lets us know that we're about to
    declare a class, and then just like everything we create and need to reference
    at a future date, we give the class a name or a unique keyword.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将忽略`public`关键字，但知道它在这里是非常必要的。`class`关键字让我们知道我们将要声明一个类，然后就像我们创建并需要在将来引用的一切一样，我们给类一个名称或一个唯一的关键字。
- en: It's time to write the code to set up our `Person` class. Remember that what
    we're doing here is teaching future pieces of our program how to create `Person`
    objects or instances of the `Person` class. So, the code we write here is going
    to look very different from what we would write in a method that simply executes
    the lines from start to finish.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写代码来设置我们的`Person`类了。请记住，我们在这里所做的是教会程序的未来部分如何创建`Person`对象或`Person`类的实例。因此，我们在这里编写的代码将与我们在一个简单地执行从头到尾的方法中所写的代码非常不同。
- en: 'The information we place within a class declaration is going to fall into one
    of these two categories:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类声明中放置的信息将属于这两类之一：
- en: The first category is us telling Java what information a `Person` class should
    be able to store
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一类是我们告诉Java `Person`类应该能够存储什么信息
- en: The second category is us teaching Java what functionality a `Person` object
    should expose
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二类是我们教Java`Person`对象应该暴露什么功能
- en: Creating member variables
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建成员变量
- en: 'Let''s start with the first category. Let''s tell Java what information we''d
    like to store in `Person`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一类开始。让我们告诉Java我们想在`Person`中存储什么信息：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Telling Java what information to store is a lot like declaring variables in
    any other piece of code. Here, we've given the `Person` class two member variables;
    these are pieces of information that we can access in any `Person` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Java要存储的信息很像在任何其他代码中声明变量。在这里，我们给`Person`类两个成员变量；这些是我们可以在任何`Person`对象中访问的信息。
- en: Just about everything we declare in a class declaration needs to be given a
    protection level. When we become more advanced Java users, we'll begin to use
    different protection levels, but for now, we're simply going to declare everything
    "public."
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中，几乎我们声明的每一样东西都需要给予保护级别。当我们成为更高级的Java用户时，我们将开始使用不同的保护级别，但现在，我们只是简单地声明一切为“public”。
- en: So, as we've set it up here, every `Person` object has `firstName` and `lastName`.
    Remember, these member variables are unique to each instance of a `Person` object,
    so different persons do not necessarily share first and last names.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们在这里设置的那样，每个`Person`对象都有`firstName`和`lastName`。请记住，这些成员变量对于`Person`对象的每个实例都是唯一的，因此不同的人不一定共享名字和姓氏。
- en: 'To make things a little more interesting, let''s also assign birthdays to people.
    We''ll need to import `java.util` because we''re going to use another class for
    this, the `Calendar` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得更有趣，让我们也给人们分配生日。我们需要导入`java.util`，因为我们将使用另一个类`Calendar`类：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calendars are basically points and times or dates with a whole lot of functionality
    wrapped around them. The cool thing is that `Calendar` is a class of its own.
    So we're placing a class within our `Person` class; `String` is a class too, but
    Java considers it a little special.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 日历基本上是点和时间或日期，具有大量功能包装在其中。很酷的是`Calendar`是一个独立的类。因此，我们在`Person`类中放置了一个类；`String`也是一个类，但Java认为它有点特殊。
- en: Now, let's head back to the `main()` method in the `GettingObjectOriented.java`
    file and see what it looks like to create a brand new person. For now, we'll leave
    this line of code so we can use it as a template. We'd like to create a new instance
    of our `Person` class or create a new `Person` object. To do this, we're first
    going to tell Java what type of object we'd like to create.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`GettingObjectOriented.java`文件中的`main()`方法，看看创建一个全新的人是什么样子。现在，我们将保留这行代码，以便将其用作模板。我们想要创建我们的`Person`类的一个新实例或创建一个新的`Person`对象。为此，我们首先要告诉Java我们想要创建什么类型的对象。
- en: 'Because we''ve declared the `Person` class within the package that we''re using,
    Java will understand the `Person` keyword now. Then, we need to give a name to
    the variable that we will assign our new person to; let''s name the person `john`.
    Creating a new person is as simple as creating a new `Scanner` object. We use
    the `new` keyword to let Java know that we''re creating something brand new that
    doesn''t exist yet, then we ask it to create a person:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在使用的包中声明了`Person`类，Java现在将理解`Person`关键字。然后，我们需要给我们将分配新人的变量一个名字；让我们将这个人命名为`john`。创建一个新人就像创建一个新的`Scanner`对象一样简单。我们使用`new`关键字让Java知道我们正在创建一些全新的尚不存在的东西，然后要求它创建一个人：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `Person john = new Person ();` will cause the person pointed to by the
    variable `john`, who we'll just think of as a person John, to come into being.
    Now `john` already has some basic functionality just by the fact that we've declared
    some member variables for the `Person` class, so even our rudimentary declaration
    of the `Person` class has given John some member variables that we can work with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Person john = new Person ();`将导致变量`john`指向的人，我们将简单地认为是一个人John，出现。现在`john`已经具有一些基本功能，因为我们已经为`Person`类声明了一些成员变量，因此即使我们对`Person`类的基本声明也给了John一些我们可以使用的成员变量。
- en: 'For example, `john` has `firstName` that we can access as a variable with the
    dot(`.`) operator, and we can go ahead and assign a value to this variable. We
    can do the same thing with John''s last name and also, of course, his birthday:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`john`有`firstName`，我们可以使用点(`.`)运算符作为变量进行访问，并且我们可以继续为这个变量分配一个值。我们也可以用同样的方法处理John的姓和当然是他的生日：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, I had mentioned that `birthday` was going to be a little different from
    `firstName` and `lastName` by the time we reach this point. While strings are
    technically classes in Java, Java also gives them the special privilege of being
    able to be assigned to an explicit value or a string explicit. Calendars, of course,
    don't have this unique special privilege, so we're going to need to create a new
    `Calendar` object to place within our object, that is, `john`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经提到`birthday`在我们到达这一点时会与`firstName`和`lastName`有些不同。虽然字符串在Java中在技术上是类，但Java也赋予它们能够被分配给显式值或字符串显式的特权。当然，日历没有这种独特的特权，因此我们需要创建一个新的`Calendar`对象放在我们的对象中，也就是`john`。
- en: Now, `Calendar` is one of those classes that we can assign instances of; however,
    when we want to create a brand new one, we would need to create something more
    specific that is also a calendar. So, for this instance, we'll use `GregorianCalendar`.
    Then, let's assign `birthday` to `john`, say, `1988,1,5`. Then, to see that everything
    is being assigned as expected, simply print out John's first and last names.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Calendar`是我们可以分配实例的类之一；但是，当我们想要创建一个全新的实例时，我们需要创建一个更具体的也是日历的东西。因此，对于这个实例，我们将使用`GregorianCalendar`。然后，让我们将`birthday`分配给`john`，比如`1988,1,5`。然后，为了查看一切是否按预期分配，只需打印出John的名和姓。
- en: 'There we go! When we run the following program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行以下程序时：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We see `John Doe` not really properly formatted but printed to the screen,
    as expected:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`John Doe`并没有真正格式化，但是按预期打印到屏幕上：
- en: '![](img/de2afc61-669a-4365-bb7b-e1a0074faf72.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de2afc61-669a-4365-bb7b-e1a0074faf72.png)'
- en: We've successfully stored information in our `john` object. If we wanted to,
    we could create a brand new person "Jane" who would have `firstName`, `lastName`,
    and `birthday` of her own; her member variables being completely separate from
    that of John's.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将信息存储在我们的`john`对象中。如果我们愿意，我们可以创建一个全新的人“Jane”，她将拥有自己的`firstName`、`lastName`和`birthday`；她的成员变量完全独立于John的。
- en: Creating member functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建成员函数
- en: Let's go back to our `Person` class, that is, the `Person.java` file, and provide
    people with some more functionality. So, the beauty of object-oriented Java is
    that we're already beginning to think about instances of our `Person` class as
    physical objects. This makes anticipating the questions that will be asked of
    them much easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Person`类，也就是`Person.java`文件，并为人们提供更多功能。因此，面向对象的Java的美妙之处在于，我们已经开始将我们的`Person`类的实例视为物理对象。这使得预期将会问到他们的问题变得更容易。
- en: For example, when I meet someone new, I'd either want to know their first name
    or their full name in most cases. So wouldn't it be nice if our person stores
    a string called `fullName` that people could just ask of rather than having to
    individually acquire their first and last names?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我遇到一个新的人时，我大多数情况下要么想知道他们的名字，要么想知道他们的全名。所以，如果我们的人存储了一个名为`fullName`的字符串，人们可以直接询问而不必单独获取他们的名字和姓氏，这不是很好吗？
- en: Now, of course, simply adding another member variable like this is unwieldy
    because the people creating a new instance of `Person` will need to set `fullName`.
    Also, if the person's first name, last name, or full name were to ever change,
    their `fullName`, `firstName`, and `lastName` variable might not match up properly.
    But what if instead of a member variable, we provide a member method?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，简单地添加另一个成员变量是不方便的，因为创建`Person`的新实例的人需要设置`fullName`。而且，如果人的名字、姓氏或全名发生变化，他们的`fullName`、`firstName`和`lastName`变量可能不会正确匹配。但是，如果我们提供一个成员方法而不是成员变量呢？
- en: 'When we create methods within the context of a class, we have access to the
    class''s member variables. We can modify them if we want, or if we''re doing something
    like we just did, we can simply utilize their values, in this case return this
    person''s dynamically constructed full name:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类的上下文中创建方法时，我们可以访问类的成员变量。如果我们想要修改它们，或者像我们刚刚做的那样，我们可以简单地利用它们的值，比如返回这个人动态构造的全名。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's another question that I anticipate this person being asked, and that
    is how old are you? This will be a lot like the method we just wrote, with one
    exception. In order to know how old this person is, this person will need to be
    told what today's date is because that's not information that this person already
    stores.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这个人会被问到另一个问题，那就是你多大了？这将很像我们刚刚写的方法，只有一个例外。为了知道这个人多大了，这个人需要知道今天的日期，因为这不是这个人已经存储的信息。
- en: To do this, we'll ask people to pass this information when they call this method,
    and we'll simply return the difference between today's year and the birthday year
    of this person.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将要求人们在调用这个方法时传递这些信息，然后我们将简单地返回今天年份与这个人的生日年份之间的差异。
- en: 'Now, the syntax for getting a year from a calendar is a little wonky, but I
    think we should be able to follow it. We simply use the `get` method, which has
    a number of uses, and then we need to tell the method exactly what we''d like
    to get from it, and what we''d like to get is a calendar year(`Calendar.YEAR`).
    So, let''s make sure to save this file and jump over to our `main` method and
    make use of one of these new methods that we''ve just added to `Person` instances:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从日历中获取年份的语法有点奇怪，但我认为我们应该能够理解。我们只需使用`get`方法，它有许多用途，然后我们需要告诉方法我们想从中获取什么，我们想从中获取一个日历年(`Calendar.YEAR`)。所以，让我们确保保存这个文件，跳转到我们的`main`方法，并利用我们刚刚添加到`Person`实例的新方法之一：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, we've set up `john`. He has a birthday. Let's ask John how old he is, right
    in our `println` statement here. To do this, we're simply going to call John's
    `age` method and create a new `Calendar` object to pass in. I think the new `GregorianCalendar`
    instance will be set to the current date and time by default.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们设置了`john`。他有一个生日。让我们在这里的`println`语句中问John他多大了。为了做到这一点，我们只需调用John的`age`方法，并创建一个新的`Calendar`对象传递进去。我认为新的`GregorianCalendar`实例将默认设置为当前日期和时间。
- en: 'If we run the following program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下程序：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We see that John is `29` years old:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到John今年`29`岁：
- en: '![](img/f5c7490e-f32d-4a9f-9d4e-ebbcc7d3829c.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5c7490e-f32d-4a9f-9d4e-ebbcc7d3829c.png)'
- en: So there you have it. That's our basic introduction to object-oriented Java,
    but it's all going to boil down to the basics that you just learned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的基本介绍了。这是我们对面向对象的Java的基本介绍，但最终都会归结为你刚学到的基础知识。
- en: Creating constructors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建构造函数
- en: 'In this section, you''re going to learn about a very special member we can
    assign to our custom classes, that is, the constructor. To start off, let''s take
    a look at the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习到我们可以分配给自定义类的一个非常特殊的成员，那就是构造函数。首先，让我们看一下下面的代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This program creates an instance of our custom class `Person` and immediately
    assigns some values to member variables of `Person`: `firstName`, `lastName`,
    and `birthday`. Then, we utilize some of the member functions of `Person` to print
    out some information about the values we''ve just assigned.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了我们自定义类`Person`的一个实例，并立即为`Person`的成员变量`firstName`、`lastName`和`birthday`赋值。然后，我们利用`Person`的一些成员函数打印出我们刚刚分配的一些信息。
- en: 'While this is a decent program, which we''ve just written, it''s easy to see
    someone make a mistake while writing even this simple program. For example, what
    if I had forgotten, or simply didn''t realize, that `birthday` was one of the
    member variables of `Person`? If I don''t assign a birthday to a person right
    away and then attempt to use the `age()` member method as shown in the following
    code block:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个不错的程序，但很容易看到即使是这样一个简单的程序，也可能出现错误。例如，如果我忘记了或者根本没有意识到`birthday`是`Person`的成员变量之一会怎么样？如果我不立即为一个人分配生日，然后尝试使用`age()`成员方法，就像下面的代码块中所示的那样：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our program would crash when it attempts to access that birthday variable that
    has not been set to anything as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序尝试访问尚未设置任何内容的生日变量时，我们的程序将崩溃，如下面的截图所示：
- en: '![](img/0f2b5fbb-e447-4ac9-810c-03b55d08602b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f2b5fbb-e447-4ac9-810c-03b55d08602b.png)'
- en: This is a very reasonable mistake for a programmer to make, both in terms of
    not knowing that they should set this member variable to a value and also in assuming
    that this member variable would have a value because what person doesn't have
    a birthday? Fortunately, there's a system in place where we can demand information
    from the user before we allow them to even create an instance of our object. So,
    let's jump into the code that declares the `Person` class and set this class up
    so that a person can only be created if it's given all of the necessary information
    right from the start. To do this, we're going to use a constructor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，这是一个非常合理的错误，既不知道他们应该将这个成员变量设置为一个值，也假设这个成员变量会有一个值，因为什么样的人没有生日呢？幸运的是，我们有一个系统，可以在允许用户创建对象实例之前要求用户提供信息。因此，让我们进入声明`Person`类的代码，并设置这个类，以便只有在一开始就提供了所有必要的信息时才能创建一个人。为此，我们将使用构造函数。
- en: A constructor declaration looks a lot like a normal method declaration, except
    for one thing. Where a normal method would have a return value, even the value
    null if it wasn't designed to return anything, constructors don't even have that.
    Also, the name of the constructor method is the same name that we've assigned
    to our class; however, just like normal methods, we can give input to constructors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数声明看起来很像普通方法声明，除了一点。普通方法会有一个返回值，甚至如果它不打算返回任何东西，也会有一个null值；构造函数甚至没有那个。此外，构造函数方法的名称与我们分配给类的名称相同；然而，就像普通方法一样，我们可以给构造函数传入参数。
- en: 'To start off, let''s assume that all persons have `firstName`, `lastName`,
    and `birthday`; otherwise, they simply shouldn''t exist. When we create a new
    instance of the `Person` class and the `Person` class has a constructor defined,
    we will always create an instance of the class using the `Person` constructor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设所有人都有“名”、“姓”和“生日”；否则，他们根本就不应该存在。当我们创建`Person`类的新实例并且`Person`类已经定义了构造函数时，我们将始终使用`Person`构造函数创建类的实例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we save this update to our `Person` class declaration and then go back to
    the `main` method of our program, we''ll get a compiler error as shown in the
    following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存了对`Person`类声明的这个更新，然后回到我们程序的`main`方法，我们将得到一个编译器错误，如下面的截图所示：
- en: '![](img/f3ccf2f3-6332-408f-82f2-fd6311238cf4.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3ccf2f3-6332-408f-82f2-fd6311238cf4.png)'
- en: 'That''s because we''ve modified the `Person` class to demand that our newly
    created constructor be used. This constructor takes three input values: a string,
    a string, and a calendar. So, instead of modifying the member variables of `Person`
    in these three lines of code, what we''re going to do is pass these three variables
    as arguments to our constructor method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们修改了`Person`类，要求我们使用新创建的构造函数。这个构造函数接受三个输入值：一个字符串，一个字符串和一个日历。因此，我们不会在这三行代码中修改`Person`的成员变量，而是将这三个变量作为参数传递给我们的构造函数方法：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, as far as the `main` method in our program is concerned, the syntax of
    our program is once again valid. Of course, if we run this program, we're going
    to run into some trouble because while we pass these arguments to the `Person`
    constructor, we haven't yet done anything with them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就我们的程序中的`main`方法而言，程序的语法再次是有效的。当然，如果我们运行这个程序，我们将遇到一些麻烦，因为虽然我们将这些参数传递给`Person`构造函数，但我们还没有对它们做任何处理。
- en: 'Now, it needs to be the job of our `Person` constructor here, as opposed to
    the `main` method in our Java program, to translate these parameters into the
    values of the member variables of `Person`. So, let''s do that. Let''s change
    our `Person` class''s `firstName`, or rather set its value, to the variable passed
    to this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里的工作应该是我们的`Person`构造函数的工作，而不是我们Java程序中的`main`方法，将这些参数转换为`Person`的成员变量的值。所以，让我们这样做。让我们将`Person`类的`firstName`更改，或者说将其值设置为传递给这个函数的变量：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, this is a technically correct syntax that we have here; it will do what
    we want it to do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个技术上正确的语法；它将做我们想要做的事情。
- en: The `firstName = firstName` code line is really weird, and it's pretty ambiguous
    if you go about reading it. After all, which `firstName` variable are we talking
    about in each of these instances? Are we talking about `Person.firstName`, the
    member variable of this class, or are we talking about `firstName` that was passed
    in as an argument to the constructor method? To disambiguate this, we can do a
    couple of things.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstName = firstName`这行代码真的很奇怪，如果你仔细阅读它，它是相当模糊的。毕竟，在每个实例中，我们在谈论哪个`firstName`变量？我们是在谈论`Person.firstName`，这个类的成员变量，还是在谈论作为构造函数方法参数传递的`firstName`？为了消除这种歧义，我们可以做一些事情。'
- en: 'First off, we could simply change the name we assign to our method arguments
    to something that''s not identical to the local member name; however, sometimes,
    it just makes sense to explicitly ask for `firstName`. It can be a lot easier
    for people who are going to use the constructor. When we need to explicitly tell
    our program that we''re using one of `Person` class''s member variables, we should
    provide a path for it properly. The `this` keyword will allow us to access the
    class that we''re currently operating in, or rather its object instance, when
    the program runs. So, `this.firstName` will always reference the member variable
    as opposed to the one passed in as an argument. Now that we have the syntax, we
    can quickly assign the argument values to the values of our member variables:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以简单地更改我们分配给方法参数的名称，使其不与本地成员名称相同；然而，有时明确要求`firstName`是有意义的。对于将要使用构造函数的人来说，这可能更容易。当我们需要明确告诉我们的程序，我们正在使用`Person`类的成员变量之一时，我们应该正确地为其提供路径。`this`关键字将允许我们在程序运行时访问我们当前操作的类，或者说它的对象实例。因此，`this.firstName`将始终引用成员变量，而不是作为参数传递的变量。现在我们有了语法，我们可以快速地将参数值分配给我们的成员变量的值：
- en: '![](img/7fe7dc9b-4335-4baa-8a59-3b6f1594e465.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe7dc9b-4335-4baa-8a59-3b6f1594e465.png)'
- en: 'Now when we save this file and go back to our `main` method—that is, `GettingObjectOriented.java`—and
    run our program, we''ll get the original output showing us that our `Person` constructor
    has properly mapped these input values to the values stored in our `Person` object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们保存这个文件并返回到我们的`main`方法——也就是`GettingObjectOriented.java`——并运行我们的程序时，我们将得到原始输出，显示我们的`Person`构造函数已经正确地将这些输入值映射到我们`Person`对象中存储的值：
- en: '![](img/c3d6ffb7-b1f5-472c-992b-75ea6c0f336d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3d6ffb7-b1f5-472c-992b-75ea6c0f336d.png)'
- en: So this is pretty cool. We've modified our `Person` class so that it's much
    more difficult for a programmer to make an obvious mistake and call these methods
    when they're bound to fail. A programmer could still get into trouble if they
    did something along the lines of modifying one of the member variables after our
    person has been created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很酷。我们修改了我们的`Person`类，使得程序员更难犯一个明显的错误并在它们注定失败时调用这些方法。如果程序员在创建我们的人之后修改了成员变量中的一个，他们仍然可能遇到麻烦。
- en: However, there's a system in place for us to protect our classes, if we choose
    to, from having their members modified without going through a proper protocol.
    Let's say that we'd like to change our `Person` class so that the only time these
    members are ever changed is once at the very beginning when the constructor calls.
    If you remember, we've been tagging all the members of our classes with this `public`
    protection tag. Something that's tagged `public` is basically viewable anytime
    by any piece of our program that has access to its container.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们选择的话，有一个系统可以保护我们的类，使其成员不能在没有经过适当协议的情况下被修改。假设我们想要更改我们的`Person`类，以便这些成员只在构造函数调用时被修改一次。如果你记得的话，我们一直在给我们的类的所有成员打上`public`保护标签。被标记为`public`的东西基本上可以被我们程序中任何有权访问其容器的部分随时查看。
- en: 'However, we can use a couple of other different protection tags. If we were
    to tag all our member variables `private`, then they would only be viewable within
    the context of their current class. So, we could still use the member variables
    in our `Person` constructor and in our `fullName` and `age` methods, but when
    we attempt to access `lastName` outside of the actual class declaration, then
    it would be invalid:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用一些其他不同的保护标签。如果我们将所有成员变量标记为`private`，那么它们只能在其当前类的上下文中查看。因此，我们仍然可以在我们的`Person`构造函数和我们的`fullName`和`age`方法中使用成员变量，但是当我们尝试在实际类声明之外访问`lastName`时，它将是无效的：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can tag members `private` and then create public methods to modify their
    values when appropriate. By doing so, we will protect our objects from ever being
    given invalid values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将成员标记为`private`，然后创建公共方法在适当的时候修改它们的值。通过这样做，我们将保护我们的对象免受无效值的影响。
- en: Types of constructors
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的类型
- en: Now, let's go back to talking about constructors before we wrap up. As with
    normal methods, we can override constructors and have more than one option for
    our programmer to choose from.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到谈论构造函数，然后结束。与普通方法一样，我们可以重写构造函数，并为程序员提供多个选择。
- en: 'For example, let''s say that sometimes in our program, we want to create new
    people who have just been born. In this instance, it might make a lot of sense
    for us to construct a person by simply giving `firstName` and `lastName` to our
    constructor and then having `birthday` as `new Gregorian Calendar`, which will
    default to today''s date:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在我们的程序中有时我们想要创建刚出生的新人。在这种情况下，我们可能会通过简单地将`firstName`和`lastName`传递给我们的构造函数，然后将`birthday`设置为`new
    Gregorian Calendar`来构造一个人，这将默认为今天的日期：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we wanted to use this constructor in our program instead, we'd simply call
    the constructor with only two string arguments. This would map to the newly created
    constructor that we've declared here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的程序中使用这个构造函数，我们只需调用只有两个字符串参数的构造函数。这将映射到我们在这里声明的新创建的构造函数。
- en: 'Consider the following program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run it, since the birth date has been set to the current date and time,
    we will see that `John Doe` is now `0` years old, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，由于出生日期已设置为当前日期和时间，我们将看到`John Doe`现在是`0`岁，如下面的截图所示：
- en: '![](img/f0b459ab-c172-4e9d-b095-c0f2c08f85d3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b459ab-c172-4e9d-b095-c0f2c08f85d3.png)'
- en: 'Lastly, we can give someone the option of utilizing one of our constructors
    or simply creating an instance of the class without doing anything, simply by
    declaring a constructor that is empty. Then, the syntax will look just like the
    creation of John we participated in earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以让某人选择使用我们的构造函数之一，或者只需创建一个不做任何事情的类的实例，只需声明一个空的构造函数。然后，语法看起来就像我们之前参与的John的创建一样：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Generally, we don''t want to do this, though. What we want to do if we have
    an empty or default constructor is to assign default values to our member variables
    so that at the very least, we''re still not breaking our program. So, it might
    make a lot of sense for our default constructor to assign empty strings and maybe
    today''s date to our `firstName`, `lastName`, and `birthday` fields:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们不想这样做。如果我们有一个空的或默认的构造函数，我们想要做的是为我们的成员变量分配默认值，这样至少，我们仍然不会破坏我们的程序。因此，我们的默认构造函数可能会将空字符串和今天的日期分配给我们的`firstName`、`lastName`和`birthday`字段：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, even if our programmer doesn''t properly assign values to John''s fields
    after creating them, there''s still going to be some valid values in those fields
    to protect us from actually throwing an error when we run the following program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，即使我们的程序员在创建John的字段后没有正确地为它们分配值，这些字段中仍然会有一些有效的值，以保护我们免受在运行以下程序时实际抛出错误的影响：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the output of the preceding code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/1d692259-00c3-473d-b8f1-3f01ff311b19.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d692259-00c3-473d-b8f1-3f01ff311b19.png)'
- en: So that's the skinny on constructors, another tool that helps us protect and
    make the code we've already written more robust.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是构造函数的要点，它是另一个帮助我们保护和使我们已经编写的代码更加健壮的工具。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to create classes and objects and how we can create
    member variables and functions that will make our code less complicated. You also
    learned about creating constructors assigned to the class and types of constructors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何创建类和对象，以及如何创建成员变量和函数，这将使我们的代码变得不那么复杂。您还学习了关于创建分配给类的构造函数和构造函数类型的知识。
