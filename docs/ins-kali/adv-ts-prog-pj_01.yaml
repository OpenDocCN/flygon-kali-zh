- en: Advanced TypeScript Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级TypeScript功能
- en: In this chapter, we are going to look at aspects of TypeScript that go beyond
    the basics of the language. When used appropriately, these features provide a
    clean, intuitive way to work in TypeScript and will help you to craft professional-level
    code. Some of the things we cover here may not be new to you, but I am including
    them so that there is a common baseline of knowledge as we work through later
    chapters, as well as an understanding of why we will be using these features.
    We will also cover why we need these techniques; it is not merely enough to know
    how to apply something, we also need to know in what circumstances we should use
    them and what we need to consider when we do so. The focus of this chapter is
    not to create a dry, exhaustive list of each feature—instead, we are going to
    introduce the information we need to work through the rest of this book. These
    are practical techniques that we will apply again and again in our daily development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究TypeScript的一些方面，超越了语言的基础知识。当适当使用时，这些功能提供了一种清晰直观的方式来使用TypeScript，并将帮助您编写专业水平的代码。我们在这里涵盖的一些内容可能对您来说并不新鲜，但我包括它们是为了确保我们在后面的章节中有一个共同的知识基础，以及为什么我们将使用这些功能的理解。我们还将介绍为什么我们需要这些技术；仅仅知道如何应用某些东西是不够的，我们还需要知道在什么情况下应该使用它们以及在这样做时需要考虑什么。本章的重点不是创建一个枯燥的、详尽的功能列表，而是要介绍我们在本书的其余部分需要的信息。这些都是我们在日常开发中一遍又一遍应用的实用技术。
- en: As this is a book on web development, we are also going to be creating a lot
    of UIs, so we are going to look at how we can create attractive interfaces using
    the popular Bootstrap framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于Web开发的书，我们还将创建许多UI，因此我们将看看如何使用流行的Bootstrap框架创建吸引人的界面。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using different types with union types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用联合类型的不同类型
- en: Combining types with intersection types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交集类型组合类型
- en: Simplifying type declarations with type aliases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型别名简化类型声明
- en: Deconstructing objects with REST properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST属性解构对象
- en: Coping with a variable number of parameters using REST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST处理可变数量的参数
- en: '**Aspect-Oriented Programming** (**AOP**) using decorators'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器进行**面向方面的编程** (**AOP**)
- en: Composing types using mixins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合类型组合类型
- en: Using the same code with different types and using generics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的代码和不同的类型，并使用泛型
- en: Mapping values using maps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射映射值
- en: Creating asynchronous code with promises and async/await
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺和async/await创建异步代码
- en: Creating UIs with Bootstrap
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap创建UI
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to complete this chapter, you are going to need Node.js installed.
    You can download and install Node.js from [https://nodejs.org/en/](https://nodejs.org/en/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要安装Node.js。您可以从[https://nodejs.org/en/](https://nodejs.org/en/)下载并安装Node.js。
- en: 'You will also need the TypeScript compiler installed. There are two ways to
    do this through Node.js using the **Node Package Manager** (**NPM**). If you want
    the same version of TypeScript used in all of your applications and are happy
    that they will all run on the same version whenever you update it, use the following
    command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装TypeScript编译器。有两种方法可以通过Node.js使用**Node Package Manager** (**NPM**)来完成这个任务。如果您希望所有应用程序都使用相同版本的TypeScript，并且确信它们在更新时都能运行在相同的版本上，请使用以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want the version of TypeScript to be local to a particular project,
    type the following in the project folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望TypeScript的版本局限于特定项目，请在项目文件夹中输入以下内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a code editor, you can use any suitable editor or even a basic text editor.
    Throughout this book, I will be using Visual Studio Code, a free cross-platform
    **integrated development environment** (**IDE**), available at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码编辑器，您可以使用任何合适的编辑器，甚至是基本的文本编辑器。在本书中，我将使用Visual Studio Code，这是一个免费的跨平台**集成开发环境**
    (**IDE**)，可在[https://code.visualstudio.com/](https://code.visualstudio.com/)上获得。
- en: All code is available on GitHub at [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都可以在GitHub上找到[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01)。
- en: Building future-proof TypeScript with tsconfig
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tsconfig构建未来的TypeScript
- en: As TypeScript has grown in popularity, it has benefited from a rapidly evolving
    open source architecture. The design goals behind the original implementation
    means that it has proven to be a popular choice for developers, from those who
    were new to JavaScript-based development to seasoned professionals. This popularity
    means that the language has quickly gained new features, some straightforward
    and others geared toward developers who are working on the cutting edge of the
    JavaScript ecosystem. This chapter aims to address the features that TypeScript
    has introduced to match either current or upcoming ECMAScript implementations
    that you might not have encountered previously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TypeScript的流行，它受益于快速发展的开源架构。原始实现背后的设计目标意味着它已经成为开发人员的热门选择，无论是对于新手JavaScript开发者还是经验丰富的专业人士。这种流行意味着该语言迅速获得了新功能，有些功能简单直接，而其他功能则面向那些在JavaScript生态系统的前沿工作的开发人员。本章旨在介绍TypeScript引入的功能，以匹配当前或即将到来的ECMAScript实现，这些功能您可能之前没有遇到过。
- en: As we progress through this chapter, I will occasionally call out features that
    require a newer ECMAScript standard. In some cases, TypeScript will already have
    provided a poly-filled implementation of a feature that works with earlier versions
    of ECMAScript. In other cases, the version we compile against will have a feature
    that could not be back-filled beyond a certain point so it will be worth using
    a more up-to-date setting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章的进展，我会不时地指出需要较新ECMAScript标准的功能。在某些情况下，TypeScript已经提供了一个与较早版本的ECMAScript兼容的功能的poly-filled实现。在其他情况下，我们编译的版本将具有一个功能，该功能无法在某一点之后进行回填，因此值得使用更更新的设置。
- en: 'While it''s possible to compile TypeScript completely from the command line
    using nothing but parameters, I prefer to use `tsconfig.json`. You can either
    create this file manually or have TypeScript create it for you using the following
    command from the command line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以完全使用命令行编译TypeScript，但我更喜欢使用`tsconfig.json`。您可以手动创建此文件，也可以使用以下命令从命令行让TypeScript为您创建它：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to copy my settings, these are the ones I have set up by default.
    When we need to update references, I will point out the entries that need to be
    added:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想复制我的设置，这些是我默认设置的设置。当我们需要更新引用时，我会指出需要添加的条目：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Introduction to advanced TypeScript features
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍高级TypeScript功能
- en: With each release, TypeScript takes big strides forward, adding features and
    capabilities that build on the basics of the language that were introduced back
    in version 1\. Since then, JavaScript has moved on and TypeScript has added features
    to target emerging standards, providing implementations for older implementations
    of JavaScript or by calling native implementations when targeting updated ECMA
    standards. In this first chapter, we are going to look at some of these features,
    which we will be using throughout this book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个版本的发布，TypeScript不断迈出重要的步伐，增加了功能和能力，这些功能和能力是建立在语言基础之上的，这些语言基础是在1版本中引入的。从那时起，JavaScript已经发展，TypeScript已经添加了一些功能，以便针对新兴标准，提供对旧版JavaScript的实现，或者在针对更新的ECMA标准时调用本地实现。在本章中，我们将看一些这些功能，这些功能将贯穿本书的整个内容。
- en: Using different types with union types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联合类型与不同类型
- en: 'The first feature that we are going to look at is one of my favorites, that
    is, the ability to use union types. These types are used when a function expects
    a single parameter to be one type or another. Suppose, for instance, that we have
    a validation routine that needs to check whether a value is in a particular range
    and this validation could receive the value either from a textbox as a `string`
    value, or as a `number` value from a calculation. As each of the techniques for
    solving this issue have a lot in common, we''ll start off with a simple class
    that allows us to specify the minimum and maximum values that form our range and
    a function to actually perform the validation, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的第一个功能是我最喜欢的功能之一，即使用联合类型的能力。当函数期望单个参数是一种类型或另一种类型时，就会使用这些类型。例如，假设我们有一个验证例程，需要检查值是否在特定范围内，这个验证可以从文本框中接收`string`值，也可以从计算中接收`number`值。由于解决这个问题的每种技术都有很多共同之处，我们将从一个简单的类开始，这个类允许我们指定形成我们范围的最小值和最大值，并且有一个实际执行验证的函数，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you haven''t seen a `constructor` that looks like that before, that''s the
    equivalent of writing the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有见过那样的`constructor`，那就相当于编写以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you need to check your parameters or manipulate them in some way, you should
    use this expanded format of parameters. If you are simply assigning the values
    to private fields, then the first format is a very elegant way to do this and
    saves cluttering up your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查参数或以某种方式操纵它们，您应该使用参数的扩展格式。如果您只是将值分配给私有字段，那么第一种格式是一种非常优雅的方式，可以节省代码的混乱。
- en: 'There are a few ways that we could solve the problem of ensuring we only perform
    our validation using `string` or `number`. The first way we could solve this problem
    would be by providing two separate methods that accept the relevant type, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决确保我们只使用`string`或`number`进行验证的问题。我们可以通过提供两个接受相关类型的单独方法来解决这个问题，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While this technique would work, it''s not very elegant and it certainly doesn''t
    take advantage of the power of TypeScript. The second technique that we could
    use is to allow us to pass in the value without constraining it, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术可以工作，但它并不是非常优雅，而且它肯定没有充分利用TypeScript的强大功能。我们可以使用的第二种技术是允许我们传入值而不加以限制，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's definitely an improvement over our original implementation because we
    have settled on one signature for our function, which means that calling the code
    is a lot more consistent. Unfortunately, we can still pass an invalid type into
    the method, so if we passed `boolean` in, for instance, this code would compile
    successfully but it would fail at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是对我们原始实现的改进，因为我们已经确定了函数的一个签名，这意味着调用代码更加一致。不幸的是，我们仍然可以将无效类型传递给方法，因此，如果我们传递`boolean`，这段代码将成功编译，但在运行时会失败。
- en: 'If we want to constrain our validation so that it only accepts strings or numbers,
    then we can use a union type. It doesn''t differ much from the last implementation
    but it does give us the compile time type safety that we''re after, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制我们的验证只接受字符串或数字，那么我们可以使用联合类型。它与上一个实现并没有太大的不同，但它确实给了我们编译时类型安全性，这正是我们想要的，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The signature that identifies the type constraints as being a union is `type
    | type` in the function name. This tells the compiler (and us) what the valid
    types are for this method. As we have constrained the input to be `number` or `string`,
    once we have ruled out that the type is not `number`, we don't need to check `typeof`
    to see whether it's a `string` so we have simplified the code even further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标识类型约束为联合的签名是函数名称中的`type | type`。这告诉编译器（和我们）这种方法的有效类型是什么。因为我们已经限制了输入为`number`或`string`，所以一旦我们排除了类型不是`number`，我们就不需要检查`typeof`来查看它是否是`string`，所以我们甚至进一步简化了代码。
- en: We can chain as many types together as we need in a union statement. There's
    no practical limit but we have to make sure that each type in the union list needs
    a corresponding `typeof` check if we are going to handle it properly. The order
    of the types does not matter either, so `number | string` is treated the same
    as `string | number`. Something to remember though is if the function has lots
    of types combined together, then it is probably doing too much and the code should
    be looked at to see whether it can be broken up into smaller pieces.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在联合语句中链接尽可能多的类型。实际上没有实际限制，但我们必须确保联合列表中的每种类型都需要相应的`typeof`检查，如果我们要正确处理它。类型的顺序也不重要，所以`number
    | string`与`string | number`是相同的。但要记住的是，如果函数将许多类型组合在一起，那么它可能做得太多了，应该查看代码，看看是否可以将其分解成更小的部分。
- en: We can go further than this with union types. In TypeScript, we have two special
    types, `null` and `undefined`. These types can be assigned to anything unless
    we compile our code with the `–strictNullChecks` option or `strictNullChecks =
    true` if we're setting this as a flag in our `tsconfig.json` file. I like to set
    this value so that my code only handles null cases where it should, which is a
    great way to guard against side effects creeping in just because a function receives
    a null value. If we want to allow `null` (or `undefined`), we simply need to add
    these as a union type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步使用联合类型。在TypeScript中，我们有两种特殊类型，`null`和`undefined`。除非我们使用`-strictNullChecks`选项编译我们的代码，或者如果我们在`tsconfig.json`文件中将其设置为`strictNullChecks
    = true`，否则这些类型可以分配给任何东西。我喜欢设置这个值，这样我的代码只处理应该处理的空值情况，这是防止副作用潜入的好方法，只是因为一个函数接收了一个空值。如果我们想允许`null`（或`undefined`），我们只需要将它们添加为联合类型。
- en: Combining types with intersection types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交集类型组合类型
- en: 'Sometimes, it''s important for us to have the ability to handle a case where
    we can bring multiple types together and treat them as one type. Intersection
    types are the types that have all properties available from each type that is
    being combined. We can see what an intersection looks like with the following
    simple example. First of all, we are going to create classes for a `Grid` along
    with a `Margin` to apply to that `Grid`, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对我们来说很重要的是，我们有能力处理一种情况，即我们可以将多种类型合并在一起，并将它们视为一种类型。交集类型是正在合并的每种类型中都可用的所有属性的类型。我们可以通过以下简单的示例看到交集的样子。首先，我们将为`Grid`和`Margin`创建类，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What we are going to create is an intersection that will end up with `Width`
    and `Height` from the `Grid` property, along with `Left` and `Top` from `Margin`.
    To do this, we are going to create a function that takes in `Grid` and `Margin`
    and returns a type that contains all of these properties, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的是一个交集，最终会得到`Grid`属性的`Width`和`Height`，以及`Margin`的`Left`和`Top`。为此，我们将创建一个函数，该函数接受`Grid`和`Margin`，并返回一个包含所有这些属性的类型，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note, we are going to come back to this function later in this chapter when
    we look at object spread to see how we can remove a lot of the boilerplate copying
    of properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在本章后面查看对象扩展时，我们将回到这个函数，看看如何消除大量属性的样板复制。
- en: The *magic* that makes this work is the way we define `consolidatedGrid`. We
    use `&` to join together the types we want to use to create our intersection.
    As we want to bring `Grid` and `Margin` together, we are using `<Grid & Margin>`
    to tell the compiler what our type will look like. We can see that we don't have
    to explicitly name this type; the compiler is smart enough to take care of this
    for us.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使这项工作的*魔法*是我们如何定义`consolidatedGrid`。我们使用`&`来连接我们想要使用的类型，以创建我们的交集。因为我们想要将`Grid`和`Margin`合并在一起，所以我们使用`<Grid
    & Margin>`来告诉编译器我们的类型将是什么样子。我们可以看到，我们不必明确命名这种类型；编译器足够聪明，可以为我们处理这个问题。
- en: 'What happens if we have the same properties present in both types? Does TypeScript
    prevent us from mixing these types together? As long as the property is of the
    same type, then TypeScript is perfectly happy for us to use the same property
    name. To see this in action, we are going to expand our `Margin` class to also
    include `Width` and `Height` properties, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在两种类型中都有相同的属性，会发生什么？TypeScript是否会阻止我们混合这些类型？只要属性是相同类型，TypeScript就可以完全允许我们使用相同的属性名称。为了看到这一点，我们将扩展我们的`Margin`类，以包括`Width`和`Height`属性，如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How we handle these extra properties really depends on what we want to do with
    them. In our example, we are going to add `Width` and `Height` of `Margin` to
    `Width` and `Height` of `Grid`. This leaves our function looking like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这些额外的属性取决于我们想要做什么。在我们的示例中，我们将`Margin`的`Width`和`Height`添加到`Grid`的`Width`和`Height`中。这样，我们的函数看起来像这样：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If, however, we wanted to try and reuse the same property name but the types
    of those properties were different, we can end up with a problem if those types
    have restrictions on them. To see the effect this has, we are going to expand
    our `Grid` and `Margin` classes to include `Weight`. `Weight` in our `Grid` class
    is a number and `Weight` in our `Margin` class is a string, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要尝试并重用相同的属性名称，但这些属性的类型不同，如果这些类型有限制，我们可能会遇到问题。为了看到这种影响，我们将扩展我们的`Grid`和`Margin`类以包括`Weight`。我们的`Grid`类中的`Weight`是一个数字，而我们的`Margin`类中的`Weight`是一个字符串，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are going to try and add the `Weight` types together in our `ConsolidatedGrid`
    function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在我们的`ConsolidatedGrid`函数中将`Weight`类型相加：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, TypeScript complains about this line with the following error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，TypeScript会对这行代码进行以下错误提示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While there are ways to solve this issue, such as using a union type for `Weight`
    in `Grid` and parsing the input, it's generally not worth going to that trouble.
    If the type is different, this is generally a good indication that the behavior
    of the property is different, so we really should look to name it something different.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有解决这个问题的方法，比如在`Grid`中使用联合类型来解析输入的`Weight`，但通常不值得那么麻烦。如果类型不同，这通常是属性行为不同的一个很好的指示，所以我们真的应该考虑给它取一个不同的名字。
- en: While we are working with classes in our examples here, it is worth pointing
    out that intersections are not just constrained to classes. Intersections apply
    to interfaces, generics, and primitive types as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里的示例中使用类，但值得指出的是，交集不仅限于类。交集也适用于接口、泛型和原始类型。
- en: 'There are certain other rules that we need to consider when dealing with intersections.
    If we have the same property name but only one side of that property is optional,
    then the finalized property will be mandatory. We are going to introduce a padding
    property to our `Grid` and `Margin` classes and make `Padding` optional in `Margin`,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理交集时，还有一些其他规则需要考虑。如果我们有相同的属性名称，但只有一个属性是可选的，那么最终的属性将是必需的。我们将在`Grid`和`Margin`类中引入一个`padding`属性，并在`Margin`中将`Padding`设为可选，如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because we have provided a mandatory `Padding` variable, we cannot change our
    intersection, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们提供了一个强制的`Padding`变量，我们不能改变我们的交集，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As there is no guarantee that the margin padding will be assigned, the compiler
    is going to do its best to stop us. To solve this, we are going to change our
    code to apply the `margin` padding if it is set and fall back to the `grid` padding
    if it is not. To do this, we are going to make a simple fix:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不能保证边距填充会被分配，编译器会尽力阻止我们。为了解决这个问题，我们将改变我们的代码，如果设置了`margin`填充，则应用`margin`填充，如果没有，则回退到`grid`填充。为了做到这一点，我们将做一个简单的修复：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This strange-looking syntax is called the ternary operator. This is a shorthand
    way of writing the following—if `margin.Padding` has a value, let `consolidatedGrid.Padding`
    equal that value; otherwise, let it equal `grid.Padding`. This could have been
    written as an if/else statement but, as this is a common paradigm in languages
    such as TypeScript and JavaScript, it is worth becoming familiar with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看起来奇怪的语法被称为三元运算符。这是一种简写的方式，相当于写成以下形式——如果`margin.Padding`有值，则让`consolidatedGrid.Padding`等于该值；否则，让它等于`grid.Padding`。这本可以写成if/else语句，但是，由于这是TypeScript和JavaScript等语言中的常见范例，值得熟悉。
- en: Simplifying type declarations with type aliases
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型别名简化类型声明
- en: Something that goes hand in hand with intersection types and union types are
    type aliases. Rather than cluttering our code with references to `string | number
    | null`, TypeScript gives us the ability to create a handy alias that is expanded
    out by the compiler into the relevant code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与交集类型和联合类型相辅相成的是类型别名。TypeScript允许我们创建一个方便的别名，而不是在代码中引用`string | number | null`，这个别名会被编译器展开成相关的代码。
- en: 'Suppose that we want to create a type alias that represents the union type
    of `string | number`, then we can create an alias that looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个代表`string | number`联合类型的类型别名，那么我们可以创建一个如下所示的别名：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we revisit our range validation sample, we can change the signature of our
    function to use this alias, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新审视我们的范围验证示例，我们可以更改函数的签名以使用这个别名，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The important thing to notice in this code is that we don't really create any
    new types here. The type alias is just a syntactic trick that we can use to make
    our code more readable and, more importantly, help us to create code that is more
    consistent when we are working in larger teams.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中需要注意的重要事情是，我们并没有真正创建任何新类型。类型别名只是一个语法技巧，我们可以用它来使我们的代码更易读，更重要的是，帮助我们创建更一致的代码，尤其是在大型团队中工作时。
- en: 'We can combine type aliases with types to create more complex type aliases
    as well. If we wanted to add `null` support to the previous type alias, we could
    add this type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将类型别名与类型结合起来创建更复杂的类型别名。如果我们想要为之前的类型别名添加`null`支持，我们可以添加这个类型：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As the compiler still sees the underlying type and uses that, we can use the
    following syntax to call our `IsInRange` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器仍然看到了底层类型并使用它，我们可以使用以下语法来调用我们的`IsInRange`方法：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Obviously, this doesn't give us very consistent-looking code, so we can change
    `string | number` to `StringOrNumber`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这样做不会给我们带来非常一致的代码，所以我们可以将`string | number`改为`StringOrNumber`。
- en: Assigning properties using object spread
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象展开分配属性
- en: In the `ConsolidatedGrid` example from the *Intersection types* section, we
    assigned each property to our intersection individually. Depending on the effect
    that we are trying to achieve, there is another way that we could have created
    our `<Grid & Margin>` intersection type with less code. Using a spread operator,
    we could perform a shallow copy of the properties from one or more of our input
    types automatically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在*交集类型*部分的`ConsolidatedGrid`示例中，我们分别将每个属性分配给了我们的交集。根据我们试图实现的效果，我们还可以用另一种方式用更少的代码创建我们的`<Grid
    & Margin>`交集类型。使用展开运算符，我们可以自动从一个或多个输入类型中复制属性的浅层副本。
- en: 'First, let''s see how we can rewrite our earlier example so that it automatically
    populates the margin information:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何重写之前的例子，以便自动填充边距信息：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we are instantiating our `consolidatedGrid` function, this code copies
    in the properties from `margin` and fills them in. The triple dots (`...`) tell
    the compiler to treat this as a spread operation. As we have already populated
    `Width` and `Height`, we use `+=` to simply add in the elements from the grid.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化我们的`consolidatedGrid`函数时，这段代码会复制`margin`的属性并填充它们。三个点(`...`)告诉编译器将其视为展开操作。由于我们已经填充了`Width`和`Height`，我们使用`+=`来简单地添加网格中的元素。
- en: 'What happens if we wanted to apply both the values from `grid` and `margin`
    instead? To do this, we can change our instantiation to look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要同时应用`grid`和`margin`的值呢？为了做到这一点，我们可以将我们的实例化更改为如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This fills in the `Grid` values with the values from `grid` and then fills
    in the `Margin` values from `margin`. This tells us two things. The first is that
    the spread operation maps the appropriate property to the appropriate property.
    The second thing this tells us is that the order that it does this in is important.
    As `margin` and `grid` both have the same properties, the values set by `grid`
    are overwritten by the values set by `margin`. In order to set the properties
    so that we see the values from `grid` in `Width` and `Height`, we have to reverse
    the order of this line. In reality, of course, we can see the effect as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`Grid`的值填充到`grid`的值中，然后将`Margin`的值填充到`margin`的值中。这告诉我们两件事。第一，扩展操作将适当的属性映射到适当的属性。第二，这告诉我们它执行的顺序很重要。由于`margin`和`grid`都具有相同的属性，`grid`设置的值将被`margin`设置的值覆盖。为了设置属性，以便我们在`Width`和`Height`中看到`grid`的值，我们必须颠倒这行的顺序。当然，实际上，我们可以看到效果如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this stage, we should really take a look at the JavaScript that TypeScript
    produces out of this. This is what the code looks like when we compile it using
    ES5:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该真正看一下TypeScript从中产生的JavaScript。当我们使用ES5编译它时，代码看起来像这样：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If, however, we compile the code using the version ES2015 or later, the `__assign`
    function is removed and our `ConsolidatedGrid` JavaScript looks as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用ES2015或更高版本编译代码，`__assign`函数将被移除，我们的`ConsolidatedGrid` JavaScript看起来如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What we are seeing here is that TypeScript works hard to ensure that it can
    produce code that works regardless of which version of ECMAScript we are targeting.
    We didn't have to worry whether the feature was available or not; we left it to
    TypeScript to fill in the blanks for us.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是，TypeScript努力确保它可以生成无论我们针对的ECMAScript版本是哪个都能工作的代码。我们不必担心该功能是否可用；我们把这个问题留给TypeScript来填补空白。
- en: Deconstructing objects with REST properties
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST属性解构对象
- en: Where we used spread operators to build up an object, we can also deconstruct
    objects with something called a REST property. Deconstructing simply means that
    we are going to take a complex *thing* and break it down into simpler ones. In
    other words, destructuring happens when we assign the elements inside an array
    or an object's properties to individual variables. While we have always been able
    to break complex objects and arrays down into simpler types, TypeScript provides
    a clean and elegant way to break these types down using REST parameters, which
    can deconstruct both objects and arrays.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建对象时，我们使用扩展运算符，我们也可以使用REST属性解构对象。解构简单地意味着我们要把一个复杂的*东西*分解成更简单的东西。换句话说，解构发生在我们将数组或对象的属性中的元素分配给单独的变量时。虽然我们一直能够将复杂的对象和数组分解为更简单的类型，但TypeScript提供了一种干净而优雅的方式，使用REST参数来分解这些类型，可以解构对象和数组。
- en: 'In order to understand what REST properties are, we first need to understand
    how to deconstruct an object or an array. We are going to start off by deconstructing
    the following object literal, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解REST属性是什么，我们首先需要了解如何解构对象或数组。我们将从解构以下对象文字开始，如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One way that we could deconstruct this is by using the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式解构这个对象：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While this works, it''s not very elegant and there''s a lot of repetition.
    Fortunately, TypeScript adopts the JavaScript syntax for a simple deconstruction
    like this, which provides a much neater syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但不够优雅，而且有很多重复。幸运的是，TypeScript采用了JavaScript的语法，用于像这样简单的解构，提供了一个更整洁的语法：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Functionally, this results in the same individual items as the original implementation.
    The name of the individual properties must match the names of the properties in
    the object we are deconstructing—that''s how the language knows which variable
    matches with which property on the object. If we need to change the name of the
    property for some reason, we use the following syntax:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这导致与原始实现相同的单独项目。单个属性的名称必须与我们解构的对象中的属性的名称匹配——这就是语言知道哪个变量与对象上的哪个属性匹配的方式。如果我们因某种原因需要更改属性的名称，我们使用以下语法：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The idea behind a REST operator on an object is that it applies when you take
    a variable number of items, so we are going to deconstruct this object into the
    manufacturer and the other fields are going to be bundled into a REST variable,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对象上的REST运算符的想法是，当你获取可变数量的项目时，它适用于对象，因此我们将这个对象解构为制造商，其他字段将被捆绑到REST变量中，如下所示：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The REST operator must appear at the end of the assignment list; the TypeScript
    compiler complains if we add any properties after it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: REST运算符必须出现在赋值列表的末尾；如果我们在它之后添加任何属性，TypeScript编译器会抱怨。
- en: 'After this statement, `details` now contains the type and strings values. Where
    things get interesting is when we look at the JavaScript that has been produced.
    The form of destructuring in the previous example is the same in JavaScript. There
    is no equivalent to the REST property in JavaScript (certainly in versions up
    to ES2018), so TypeScript produces code for us that gives us a consistent way
    to deconstruct more complex types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句之后，`details`现在包含了类型和字符串值。有趣的地方在于我们看一下生成的JavaScript。在前面的例子中，解构的形式在JavaScript中是相同的。在JavaScript中没有REST属性的等价物（至少在ES2018之前的版本中没有），因此TypeScript为我们生成了代码，让我们以一种一致的方式解构更复杂的类型：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Array destructuring works in a similar fashion to object destructuring. The
    syntax is virtually identical to the object version; the differences being that
    it uses `[ ]` to destructure in place of `{ }`, which the object version uses,
    and that the order of the variables is based on the position of the item in the
    array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构与对象解构类似。语法与对象版本几乎相同；不同之处在于它使用`[]`来解构，而对象版本使用`{}`，以及变量的顺序是基于数组中项目的位置。
- en: 'The original method of destructuring an array relied on the variable being
    associated with an item at a certain index in the array:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解构数组的原始方法依赖于将变量与数组中特定索引处的项目关联起来：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using array destructuring, we can change this syntax to be much more concise,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组解构，我们可以将此语法更改为更简洁的形式，如下所示：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Knowing that the TypeScript team are good at providing us with a consistent
    and logical experience, it should come as no surprise that we can also apply REST
    properties to arrays, using similar syntax:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 知道TypeScript团队擅长为我们提供一致和逻辑的体验，应该不会让人感到意外，我们也可以使用类似的语法将REST属性应用于数组：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Yet again, there is no direct JavaScript equivalent, but the compiled TypeScript
    shows that JavaScript does provide the underlying fundamentals and the TypeScript
    designers have been able to elegantly roll this in using `array.slice:`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，没有直接的JavaScript等价物，但编译后的TypeScript显示JavaScript确实提供了基本原理，TypeScript设计者能够优雅地使用`array.slice`进行整合。
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Coping with a variable number of parameters using REST
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST处理可变数量的参数
- en: The final thing we need to look at with regard to REST is the idea of functions
    having REST parameters. These aren't the same as REST properties but the syntax
    is so similar that we should find it easy to pick up. The problem that REST parameters
    solves is to cope with a variable number of parameters being passed into a function.
    The way to identify a REST parameter in a function is that it is preceded by the
    ellipsis and that it is typed as an array.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST我们需要看的最后一件事是函数具有REST参数的概念。这些与REST属性不同，但语法非常相似，我们应该很容易掌握。REST参数解决的问题是处理传递给函数的可变数量的参数。在函数中识别REST参数的方法是它前面有省略号，并且它被定义为数组。
- en: 'In this example, we are going to log out a header followed by a variable number
    of `instruments`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将记录一个标题，然后是可变数量的`instruments`：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As the REST parameter is an array, this gives us access to array functions,
    which means that we can perform actions such as `forEach` from it directly. Importantly,
    REST parameters are different from the arguments object inside a JavaScript function
    because they start at the values that have not been named in the parameters list,
    whereas the arguments object contains a list of all of the arguments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST参数是一个数组，这使我们可以直接从中执行`forEach`等操作。重要的是，REST参数与JavaScript函数内的arguments对象不同，因为它们从参数列表中未命名的值开始，而arguments对象包含所有参数的列表。
- en: 'As REST parameters were not available in ES5, TypeScript does the work necessary
    to provide JavaScript that simulates the REST parameter. First, we will see what
    this looks like when compiled as ES5, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ES5中没有REST参数，TypeScript会提供必要的工作来提供模拟REST参数的JavaScript。首先，我们将看到编译为ES5时的情况，如下所示：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we look at the JavaScript produced from an ES2015 compilation (you will
    need to change the entry for target to ES2015 in the  `tsconfig.json` file), we
    see that it looks exactly the same as our TypeScript code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看从ES2015编译生成的JavaScript时（您需要在`tsconfig.json`文件中将目标更改为ES2015），我们看到它看起来与我们的TypeScript代码完全相同：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At this point, I cannot stress enough how important it is to take a look at
    the JavaScript that is being produced. TypeScript is very good at hiding complexity
    from us, but we really should be familiar with what is being produced. I find
    it a great way to understand what is going on *under the covers*, where possible,
    to compile using different versions of the ECMAScript standard and see what code
    is being produced.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我无法再强调查看生成的JavaScript有多么重要。TypeScript非常擅长隐藏复杂性，但我们确实应该熟悉生成的内容。我发现这是了解*底层*发生了什么的好方法，尽可能使用不同版本的ECMAScript标准进行编译，并查看生成的代码。
- en: AOP using decorators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器的AOP
- en: One of my favorite features in TypeScript is the ability to use decorators.
    Decorators were introduced as an experimental feature and are pieces of code that
    we can use to modify the behavior of individual classes without having to change
    the internal implementation of the class. With this concept, we can adapt the
    behavior of an existing class without having to subclass it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中我最喜欢的功能之一是使用装饰器。装饰器作为一项实验性功能被引入，它们是我们可以使用的代码片段，用于修改单个类的行为，而无需更改类的内部实现。通过这个概念，我们可以调整现有类的行为，而无需对其进行子类化。
- en: If you have come to TypeScript from a language such as Java or C#, you might
    notice that decorators look a lot like a technique known as AOP. What AOP techniques
    provide us with is the ability to extract repetitive code by cutting across a
    piece of code and separating this out into a different location. This means that
    we do not have to litter our implementations with code that will largely be boilerplate
    code, but which absolutely must be present in the running application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Java或C#等语言转到TypeScript，您可能会注意到装饰器看起来很像一种称为AOP的技术。AOP技术提供给我们的是通过跨越代码并将其分离到不同位置来提取重复代码的能力。这意味着我们不必在实现中散布大量基本代码，但这些代码在运行应用程序中必须存在。
- en: 'The easiest way to explain what a decorator is to start off with an example.
    Suppose we have a class where only users in certain roles can access certain methods,
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解释装饰器的最简单方法是从一个例子开始。假设我们有一个类，只有特定角色的用户才能访问某些方法，如下所示：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we are going to create a user who has the `admin` and `user` roles, meaning
    that there are no problems in calling both methods in this class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个具有`admin`和`user`角色的用户，这意味着在这个类中调用两种方法都没有问题：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This gives us our expected output, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们我们期望的输出，如下所示：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we were to create a user who only had the `user` role, we would expect that
    they should not be able to run the admin-only code. As our code has no role checking,
    the `AdminOnly` method will be run regardless of what roles the user has assigned.
    One way to fix this code would be to add code to check the entitlement and then
    add this inside each method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个只有`user`角色的用户，我们期望他们不应该能够运行只有管理员才能运行的代码。由于我们的代码没有角色检查，无论用户分配了什么角色，`AdminOnly`方法都将被运行。修复这段代码的一种方法是添加代码来检查权限，然后将其添加到每个方法中。
- en: 'First, we are going to create a simple function to check whether or not the
    current user belongs to a particular role:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的函数来检查当前用户是否属于特定角色：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Revisiting our existing implementation, we are going to change our functions
    to call this check and determine whether or not `user` is allowed to run that
    method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视我们现有的实现，我们将改变我们的函数来调用这个检查，并确定`user`是否被允许运行该方法：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we look at this code, we can see that there is a lot of repeated code
    in here. Worse still, while we have repeated code, there is a bug in this implementation.
    In the `AdminOnly` code, there is no return statement inside the `IsInRole` block
    so the code will still run the `AdminOnly` code, but it will tell us that the
    user is not in the `admin` role and will then output the message regardless. This
    highlights one of the problems with repeated code: it''s very easy to introduce
    subtle (or not-so-subtle) bugs without realizing it. Finally, we are violating
    one of the basic principles of good **object-oriented** (**OO**) development practice.
    Our classes and methods are doing things that they should not be doing; the code
    should be doing one thing and one thing only, so checking roles does not belong
    there. In [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml), *Creating a
    Markdown Editor with TypeScript*, we will cover this in more depth when we delve
    deeper into the OO development mindset.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看这段代码时，我们可以看到这里有很多重复的代码。更糟糕的是，虽然我们有重复的代码，但在这个实现中有一个bug。在`AdminOnly`代码中，在`IsInRole`块内没有返回语句，所以代码仍然会运行`AdminOnly`代码，但它会告诉我们用户不在`admin`角色中，然后无论如何输出消息。这突显了重复代码的一个问题：很容易引入微妙（或不那么微妙）的bug而不自知。最后，我们违反了良好的**面向对象**（**OO**）开发实践的基本原则之一。我们的类和方法正在做它们不应该做的事情；代码应该只做一件事，所以检查角色不属于那里。在[第2章](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml)，*使用TypeScript创建Markdown编辑器*，当我们更深入地探讨面向对象开发思维方式时，我们将更深入地讨论这个问题。
- en: Let's see how we can use a method decorator to remove the boilerplate code and
    address the single responsibility issue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用方法装饰器来消除样板代码并解决单一职责问题。
- en: 'Before we write our code, we need to ensure that TypeScript knows that we are
    going to use decorators, which are an experimental ES5 feature. We can do this
    by running the following command from the command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，我们需要确保TypeScript知道我们将使用装饰器，这是一个实验性的ES5功能。我们可以通过在命令行中运行以下命令来做到这一点：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or, we can set this up in our `tsconfig` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在我们的`tsconfig`文件中设置这一点：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the decorator build features enabled, we can now write our first decorator
    to ensure that a user belongs to the `admin` role:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 启用了装饰器构建功能后，我们现在可以编写我们的第一个装饰器，以确保用户属于`admin`角色：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Whenever we see a function definition that looks similar to this, we know that
    we are looking at a method decorator. TypeScript expects exactly these parameters
    in this order:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们看到一个函数定义看起来类似于这样的，我们知道我们正在看一个方法装饰器。TypeScript期望按照这个顺序精确地使用这些参数：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first parameter is used to refer to the element that we are applying it
    to. The second parameter is the name of the element, and the last parameter is
    the descriptor of the method we are applying our decorator to; this allows us
    to alter the behavior of the method. We must have a function with this signature
    to use as our decorator:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数用于引用我们正在应用的元素。第二个参数是元素的名称，最后一个参数是我们要应用装饰器的方法的描述符；这允许我们改变方法的行为。我们必须有一个具有这个签名的函数作为我们的装饰器。
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The internals of the decorator method are not as scary as they look. What we
    are doing is copying the original method from the descriptor and then replacing
    that method with our own custom implementation. This wrapped implementation is
    returned and will be the code that is executed when we encounter it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器方法的内部并不像它们看起来那么可怕。我们所做的是从描述符中复制原始方法，然后用我们自己的自定义实现替换该方法。这个包装的实现被返回，并且在我们遇到它时将被执行的代码：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In our wrapped implementation, we are performing the same role check. If the
    check passes, we apply the original method. By using a technique like this, we
    have added something that will avoid calling our methods if it does not need to
    in a consistent manner.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的包装实现中，我们正在执行相同的角色检查。如果检查通过，我们应用原始方法。通过使用这样的技术，我们已经添加了一些东西，可以以一致的方式避免调用我们的方法，如果不需要的话。
- en: 'In order to apply this, we use `@` in front of our decorator factory function
    name just before the method in our class. When we add our decorator, we must avoid
    putting a semicolon between it and the method, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这个，我们在我们的装饰器工厂函数名字前面使用`@`，就在我们的类的方法之前。当我们添加我们的装饰器时，我们必须避免在它和方法之间加上分号，如下所示：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While this code works for the `AdminOnly` code, it is not particularly flexible.
    As we add more roles, we will end up having to add more and more virtually identical
    functions. If only we had a way to create a general-purpose function that we could
    use to return a decorator that would accept a parameter that sets the role we
    wanted to allow. Fortunately, there is a way that we can do this using something
    called a decorator factory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码对于`AdminOnly`代码来说是有效的，但它并不特别灵活。随着我们添加更多的角色，我们将不得不添加越来越多几乎相同的函数。如果我们能有一种方法来创建一个通用函数，我们可以用它来返回一个接受设置我们想要允许的角色的参数的装饰器。幸运的是，我们可以使用一种叫做装饰器工厂的东西来做到这一点。
- en: 'Put simply, a TypeScript decorator factory is a function that can receive parameters and
    uses the parameters to return the actual decorator. It only needs a couple of
    minor tweaks to our code and we have a working factory where we can specify the
    role we want to guard:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TypeScript装饰器工厂是一个可以接收参数并使用这些参数返回实际装饰器的函数。我们的代码只需要进行一些微小的调整，就可以得到一个可以指定我们想要保护的角色的工作工厂：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The only real differences here are that we have a function returning our decorator,
    which no longer has a name, and the factory function parameter is being used inside
    our decorator. We can now change our class to use this factory instead:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的真正区别是我们有一个返回装饰器的函数，这个函数不再有名字，工厂函数参数被用在我们的装饰器内部。现在我们可以改变我们的类来使用这个工厂：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With this change, when we call our methods, only an admin will be able to access
    the `AdminOnly` method, while anyone who is a user will be able to call `AnyoneCanRun`.
    An important side note is that, our decorator only applies inside a class. We
    cannot use this on a standalone function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，当我们调用我们的方法时，只有管理员才能访问`AdminOnly`方法，而任何用户都可以调用`AnyoneCanRun`。一个重要的副作用是，我们的装饰器只适用于类内部。我们不能在独立的函数上使用它。
- en: The reason we call this technique a decorator is because it follows something
    called the **decorator pattern**. This pattern recognizes a technique that is
    used to add behavior to individual objects without affecting other objects from
    the same class and without having to create a subclass. A pattern is simply a
    formalized solution to problems that occur commonly in software engineering, so
    the names act as a useful shorthand for describing what is going on functionally.
    It will probably not come as much of a surprise to know that there is also a factory
    pattern. As we go through this book, we will encounter other examples of patterns,
    so we will be comfortable using them when we reach the end.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称这种技术为装饰器，是因为它遵循了一种叫做**装饰器模式**的东西。这种模式认识到一种用于向单个对象添加行为而不影响同一类的其他对象并且不必创建子类的技术。模式只是对软件工程中常见问题的正式化解决方案，因此这些名称作为描述功能上发生的事情的有用缩写。也许不会讦知道还有一种工厂模式。当我们阅读本书时，我们将遇到其他模式的例子，因此当我们到达末尾时，我们将能够自如地使用它们。
- en: 'We can apply decorators to other items in a class as well. For instance, if
    we wanted to prevent an unauthorized user from even instantiating our class, we
    could define a class decorator. A class decorator is added to the class definition
    and expects to receive the constructor as a function. This is what our constructor
    decorator looks like when created from a factory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将装饰器应用到类中的其他项目上。例如，如果我们想要防止未经授权的用户甚至实例化我们的类，我们可以定义一个类装饰器。类装饰器被添加到类定义中，并期望接收构造函数作为函数。这是我们从工厂创建的构造函数装饰器的样子：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When we apply this, we follow the same format of using the `@` prefix, so,
    when the code attempts to create a new instance of this class for a non-admin
    user, the application will throw an error, preventing this class from being created:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个时，我们遵循相同的格式，使用`@`前缀，所以当代码尝试为非管理员用户创建这个类的新实例时，应用程序会抛出错误，阻止这个类被创建：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can see that we have not declared any of our decorators inside a class. We
    should always create them as a top-level function because their usage is not suited
    for decorating a class, so we will not see syntax such as `@MyClass.Role("admin");`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们没有在类内声明任何装饰器。我们应该总是将它们创建为顶级函数，因为它们的用法不适合装饰一个类，所以我们不会看到诸如`@MyClass.Role("admin");`这样的语法。
- en: 'Beyond constructor and method decorations, we can decorate properties, accessors,
    and more. We aren''t going to go into these here, but they will be cropping up
    later on in this book. We will also be looking at how we can chain decorators
    together so we have a syntax that looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数和方法的装饰，我们还可以装饰属性、访问器等等。我们不会在这里详细介绍，但它们将在本书的后面出现。我们还将看看如何将装饰器链接在一起，以便我们有以下的语法：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Composing types using mixins
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混合类型进行组合
- en: When we first encounter classic OO theory, we come across the idea that classes
    can be inherited. The idea here is that we can create even more specialized classes
    from general-purpose classes. One of the more popular examples of this is that
    we have a vehicle class that contains basic details about a vehicle. We inherit
    from the `vehicle` class to make a `car` class. We then inherit from the `car`
    class to make a `sports car` class. Each layer of inheritance here adds features
    that aren't present in the class we are inheriting from.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次接触经典的面向对象理论时，我们会遇到类可以被继承的概念。这里的想法是我们可以从通用类创建更加专业化的类。其中一个更受欢迎的例子是我们有一个包含有关车辆基本细节的车辆类。我们从`vehicle`类继承，创建一个`car`类。然后我们从`car`类继承，创建一个`sports
    car`类。这里每一层继承都添加了在我们继承的类中不存在的特性。
- en: In general, this is a simple concept for us to work with, but what happens when
    we want to bring two or more seemingly unrelated things together to make our code?
    Let's examine a simple example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这对我们来说是一个简单的概念，但是当我们想要将两个或更多看似无关的事物结合起来编写我们的代码时会发生什么呢？让我们来看一个简单的例子。
- en: 'It is a common thing with database applications to store whether a record has
    been deleted without actually deleting the record, and the time that the last
    update occurred on the record. At first glance, it would seem that we would want
    to track this information in a person''s data entity. Rather than adding this
    information into every data entity, we might end up creating a base class that
    includes this information and then inheriting from it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库应用程序中常见的一件事是存储记录是否已被删除，而不实际删除记录，并记录记录上次更新的时间。乍一看，似乎我们希望在个人数据实体中跟踪这些信息。但我们可能不是将这些信息添加到每个数据实体中，而是创建一个包含这些信息的基类，然后从中继承：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first problem with this approach is that it mixes details about the status
    of a record with the actual record itself. As we continue further into OO designs
    over the next few chapters, we will keep reinforcing the idea that mixing items
    together like this is not a good idea because we are creating classes that have
    to do more than one thing, which can make them less robust. The other problem
    with this approach is that, if we wanted to add the date the record was updated,
    we are either going to have to add the updated date to `ActiveRecord`, which means
    that every class that extends `ActiveRecord` will also get the updated date, or
    we are going to have to create a new class that adds the updated date and add
    this into our hierarchy chain, which means that we could not have an updated field
    without a deleted field.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的第一个问题是，它混合了有关记录状态的详细信息和实际记录本身。随着我们在接下来的几章中进一步深入OO设计，我们将不断强调这样混合物的想法并不是一个好主意，因为我们正在创建必须执行多个任务的类，这可能会使它们不够健壮。这种方法的另一个问题是，如果我们想要添加记录更新日期，我们要么必须将更新日期添加到`ActiveRecord`中，这意味着每个扩展`ActiveRecord`的类也将获得更新日期，要么我们必须创建一个新类，添加更新日期并将其添加到我们的层次结构链中，这意味着我们不能有没有删除字段的更新字段。
- en: While inheritance definitely does have its place, recent years have seen the
    idea of composing objects together to make new objects gain in prominence. The
    idea behind this approach is that we build discrete elements that do not rely
    on inheritance chains. If we revisit our person implementation, we will build
    the same features using a feature called a mixin instead.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管继承确实有其用武之地，但近年来，将对象组合在一起以创建新对象的想法日益突出。这种方法的理念是我们构建不依赖于继承链的离散元素。如果我们重新审视我们的人员实现，我们将使用一种称为混合物的功能来构建相同的功能。
- en: 'The first thing we need to do is define a type that will act as a suitable
    constructor for our mixin. We could name this type anything, but the convention
    that has evolved around mixins in TypeScript is to use the following type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是定义一个类型，它将作为我们混合物的合适构造函数。我们可以给这种类型取任何名字，但在TypeScript中，围绕混合物演变出来的约定是使用以下类型：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This type definition gives us something that we can extend to create our specialized
    mixins. The strange-looking syntax effectively says that, given any particular
    type, a new instance will be created using any appropriate arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型定义为我们提供了一些可以扩展以创建我们专门的混合物的东西。这种奇怪的语法有效地表示，给定任何特定类型，将使用任何适当的参数创建一个新实例。
- en: 'Here is our record status implementation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的记录状态实现：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `RecordStatus` function extends the `Constructor` type by returning a new
    class that extends the constructor implementation. In this, we add our `Deleted`
    flag.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordStatus`函数通过返回一个扩展构造函数实现的新类来扩展`Constructor`类型。在这里，我们添加了我们的`Deleted`标志。'
- en: 'To *merge* or mix in these two types, we simply do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种类型*合并*或混合在一起，我们只需执行以下操作：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This has created something we can use to create a `Person` object with `RecordStatus`
    properties. It has not actually instantiated any objects yet. To do that, we instantiate
    the information in the same way we would with any other type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经创建了我们可以使用来创建具有`RecordStatus`属性的`Person`对象的东西。它实际上还没有实例化任何对象。为了做到这一点，我们以与任何其他类型相同的方式实例化信息：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we also want to add details about when the record was last updated. We
    create another mixin, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还想添加有关记录上次更新时间的详细信息。我们创建另一个混合物，如下所示：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To add this to `ActivePerson`, we change the definition to include `Timestamp`.
    It does not matter which mixin we put first, whether it is `Timestamp` or `RecordStatus`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此添加到`ActivePerson`，我们更改定义以包括`Timestamp`。无论我们首先放置哪个混合物，无论是`Timestamp`还是`RecordStatus`：
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As well as properties, we can also add constructors and methods to our mixins.
    We are going to change our `RecordStatus` function to log out when the record
    was deleted. To do this, we are going to convert our `Deleted` property into a
    getter method and add a new method to actually perform the deletion:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性，我们还可以向我们的混合物添加构造函数和方法。我们将把我们的`RecordStatus`函数更改为在记录被删除时记录日志。为此，我们将把我们的`Deleted`属性转换为一个getter方法，并添加一个新的方法来执行删除：
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A word of warning about using mixins like this. They are a great technique,
    and they provide the ability to neatly do some really useful things, but we cannot
    pass them as a parameter unless we relax the parameter restrictions to any. That
    means we cannot use code like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用这种混合技术的警告。它们是一种很好的技术，可以整洁地做一些非常有用的事情，但除非我们放宽参数限制到任意，否则我们不能将它们作为参数传递。这意味着我们不能使用这样的代码：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we look at mixins in the TypeScript documentation at [https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html),
    we see that the syntax looks very different. Rather than dealing with that approach,
    with all of the inherent limitations it has, we will stick with the method here,
    which I was first introduced to at [https://basarat.gitbooks.io/typescript/docs/types/mixins.html](https://basarat.gitbooks.io/typescript/docs/types/mixins.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看TypeScript文档中有关混合物的部分，我们会发现语法看起来非常不同。与处理这种方法的所有固有限制相比，我们将坚持这里的方法，这是我在[https://basarat.gitbooks.io/typescript/docs/types/mixins.html](https://basarat.gitbooks.io/typescript/docs/types/mixins.html)首次接触到的。
- en: Using the same code with different types and using generics
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相同的代码和不同的类型以及使用泛型
- en: 'When we first start developing classes in TypeScript, it is very common for
    us to repeat the same code again and again, only changing the type that we are
    relying on. For instance, if we wanted to store a queue of integers, we might
    be tempted to write the following class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在TypeScript中首次开始开发类时，很常见的是我们反复编写相同的代码，只是改变我们依赖的类型。例如，如果我们想存储整数队列，我们可能会写以下类：
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Calling this code is as easy as this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这段代码就像这样简单：
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Later on, we decide that we also need to create a queue of strings, so we add
    code to do this as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们决定还需要创建一个字符串队列，所以我们也添加了相应的代码：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is easy to see that the more code we add like this, the more tedious our
    job becomes and the more error-prone. Suppose that we forgot to put the shift
    operation in one of these implementations. The shift operation allows us to remove
    the first element from the array and return it, which gives us the core behavior
    of a queue (a queue operates as **First In First Out** (or **FIFO**)). If we had
    forgotten the shift operation, we would have implemented a stack operation instead
    (**Last In First Out** (or **LIFO**)). This could lead to subtle and dangerous
    bugs in our code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，我们添加的这些代码越多，我们的工作就变得越繁琐，错误也就越多。假设我们忘记在其中一个实现中放置了shift操作。shift操作允许我们从数组中删除第一个元素并返回它，这给了我们队列的核心行为（队列按照**先进先出**（或**FIFO**）的原则运行）。如果我们忘记了shift操作，我们实际上实现了一个堆栈操作（**后进先出**（或**LIFO**））。这可能导致代码中出现微妙且危险的错误。
- en: 'With generics, TypeScript provides us with the ability to create something
    called a generic, which is a type that uses a placeholder to denote what the type
    is that is being used. It is the responsibility of the code calling that generic
    to determine what type they are accepting. We recognize generics because they
    appear after the class name inside `<>`, or after things such as method names.
    If we rewrite our queue to use a generic, we will see what this means:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过泛型，TypeScript为我们提供了创建所谓的泛型的能力，这是一种使用占位符来表示正在使用的类型的类型。调用泛型的代码负责确定它们接受的类型。我们可以通过在类名后面的`<>`内或在方法名后面出现的泛型来识别泛型。如果我们重写我们的队列以使用泛型，我们将看到这意味着什么：
- en: '[PRE70]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s break this down:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here, we are creating a class called `Queue` that accepts any type. The `<T>`
    syntax tells TypeScript that, whenever it sees `T` inside this class, it refers
    to the type that is passed in:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`Queue`的类，它接受任何类型。`<T>`语法告诉TypeScript，每当它在这个类内部看到`T`时，它指的是传递进来的类型：
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here is our first instance of the generic type appearing. Rather than the array
    being fixed to a particular type, the compiler will use the generic type to create
    the array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是泛型类型首次出现的实例。编译器将使用泛型类型来创建数组，而不是将数组固定为特定类型：
- en: '[PRE73]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Again, we have replaced the specific type in our code with the generic instead.
    Note that TypeScript is happy to use this with the `undefined` keyword in the
    `Pop` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们用泛型替换了代码中的具体类型。请注意，TypeScript很乐意在`Pop`方法中使用`undefined`关键字。
- en: 'Changing the way we use our code, we can now just tell our `Queue` object what
    type we want to apply to it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 改变我们使用代码的方式，我们现在可以告诉我们的`Queue`对象我们想要应用的类型：
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: What is particularly helpful is that TypeScript enforces the type that we assign
    wherever it is referenced, so if we attempted to add a string to our `queue` variable,
    TypeScript would fail to compile this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有帮助的是，TypeScript在引用的任何地方都强制执行我们分配的类型，因此，如果我们尝试向我们的`queue`变量添加一个字符串，TypeScript将无法编译这个代码。
- en: While TypeScript does its best to protect us, we have to remember that it converts
    into JavaScript. This means that it cannot protect our code from being abused,
    so, while TypeScript enforces the type we assign, if we were to write external
    JavaScript that also called our generic types, there is nothing there to prevent
    adding an unsupported value. The generic is enforced at compile time only so,
    if we have code that is going to be called from outside our control, we should
    take steps to guard against incompatible types in our code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TypeScript尽力保护我们，但我们必须记住它会转换为JavaScript。这意味着它无法保护我们的代码免受滥用，因此，尽管TypeScript强制执行我们分配的类型，如果我们编写了调用我们泛型类型的外部JavaScript，就没有任何东西可以阻止添加不受支持的值。泛型仅在编译时强制执行，因此，如果我们的代码将被外部调用，我们应该采取措施防止代码中出现不兼容的类型。
- en: 'We aren''t limited to just having one type in the generic list. Generics allow
    us to specify any number of types in the definition as long as they have unique
    names, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于在泛型列表中只有一个类型。只要它们具有唯一的名称，泛型允许我们在定义中指定任意数量的类型，如下所示：
- en: '[PRE75]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Keen-eyed readers will note that we have already encountered generics. When
    we created a mixin, we were using generics in our `Constructor` type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会注意到我们已经遇到了泛型。当我们创建一个mixin时，我们在我们的`Constructor`类型中使用了泛型。
- en: 'What happens if we want to call a particular method from our generic? As TypeScript
    expects to know what the underlying implementation of the type is, it is strict
    about what we can do. This means that the following code is not acceptable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从我们的泛型中调用特定的方法会发生什么？由于TypeScript希望知道类型的底层实现，它对我们可以做什么非常严格。这意味着以下代码是不可接受的：
- en: '[PRE76]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As TypeScript cannot guess that we want to use the `IStream` interface here,
    it is going to complain if we try to compile this. Fortunately, we can use a generic
    constraint to tell TypeScript that we have a particular type that we want to use
    here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript无法猜测我们想在这里使用`IStream`接口，如果我们尝试编译这段代码，它会报错。幸运的是，我们可以使用泛型约束告诉TypeScript我们有一个特定的类型要在这里使用：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `<T extends IStream>` part tells TypeScript that we are going to use *any*
    class that is based on our `IStream` interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T extends IStream>`部分告诉TypeScript，我们将使用基于我们的`IStream`接口的*任何*类。'
- en: While we can constrain generics to types, we are generally going to want to
    constrain our generics to interfaces. This gives us a lot of flexibility in the
    classes that we use in the constraint and does not impose limitations that we
    can only use classes that inherit from a particular base class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将泛型限制为类型，但通常我们会希望将泛型限制为接口。这使我们在约束中使用的类具有很大的灵活性，并且不会强加我们只能使用从特定基类继承的类的限制。
- en: 'To see this in action, we are going to create two classes that implement `IStream`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，我们将创建两个实现`IStream`的类：
- en: '[PRE78]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'These can now be used as type constraints in our generic `Data` implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现在可以用作我们的通用`Data`实现中的类型约束：
- en: '[PRE79]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We have just told `webStream` and `diskStream` that they are going to have
    access to our classes. To use them, we would still have to pass an instance, as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚告诉`webStream`和`diskStream`它们将可以访问我们的类。要使用它们，我们仍然必须传递一个实例，如下所示：
- en: '[PRE80]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'While we declared our generic and its constraints at the class level, we don''t
    have to do that. We can declare finer-grained generics, down to the method level,
    if we need to. In this case though, it makes sense to make it a class-level generic
    if we want to refer to that generic type in multiple places in our code. If the
    only place we wanted to apply a particular generic was at one or two methods,
    we could change our class signature to this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在类级别声明了我们的泛型及其约束，但我们不必这样做。如果需要，我们可以在方法级别声明更精细的泛型。不过，在这种情况下，如果我们想要在代码中的多个地方引用该泛型类型，将其作为类级别泛型是有意义的。如果我们只想在一个或两个方法中应用特定的泛型，我们可以将我们的类签名更改为这样：
- en: '[PRE81]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Mapping values using maps
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地图映射值
- en: 'A situation that often comes up is needing to store a number of items with
    an easily looked up key. For instance, suppose we had a music collection broken
    down into a number of genres:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的情况是需要使用一个容易查找的键存储多个项目。例如，假设我们有一个按流派分类的音乐收藏：
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Against each one of these genres, we are going to store the details of a number
    of artists or composers. One approach we could take would be to create a class
    that represents each genre. While we could do that, it would be a waste of our
    coding time. The way we are going to solve this problem is by using something
    called a **map**. A map is a generic class that takes in two types: the type of
    key to use for the map and the type of objects to store in it.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些流派中的每一个，我们将存储一些艺术家或作曲家的详细信息。我们可以采取的一种方法是创建一个代表每个流派的类。虽然我们可以这样做，但这将是对我们编码时间的浪费。我们解决这个问题的方式是使用一种叫做**map**的东西。地图是一个接受两种类型的通用类：用于地图的键的类型和存储在其中的对象的类型。
- en: 'The key is a unique value that is used to allow us to store values or to quickly
    look things up—this makes maps a good choice for rapidly looking values up. We
    can have any type as a key and the value can be absolutely anything. For our music
    collection, we are going to create a class that uses a map with the genre as the
    key and a string array to represent the composer or artists:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 键是一个唯一的值，用于允许我们存储值或快速查找事物-这使得地图成为快速查找值的良好选择。我们可以将任何类型作为键，值可以是绝对任何东西。对于我们的音乐收藏，我们将创建一个使用流派作为键和字符串数组表示作曲家或艺术家的地图的类：
- en: '[PRE83]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In order to populate a map, we call the `set` method, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充地图，我们调用`set`方法，如下所示：
- en: '[PRE84]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Retrieving the values from the map is as simple as calling `Get` with the relevant
    key:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从地图中检索值就像调用`Get`与相关的键一样简单：
- en: '[PRE85]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We have to add the `undefined` keyword to the return value here because there
    is a possibility that the map entry does not exist. If we forgot to take the possibility
    of undefined into account, TypeScript helpfully warns us of this. Yet again, TypeScript
    works hard to provide that robust safety net for our code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里添加`undefined`关键字到返回值，因为地图条目可能不存在。如果我们忘记考虑undefined的可能性，TypeScript会友好地提醒我们。再一次，TypeScript努力为我们的代码提供强大的安全保障。
- en: 'We can now populate our collection, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以填充我们的集合，如下所示：
- en: '[PRE86]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If we want to add a single artist, our code becomes slightly more complex. Using
    set, we either add a new entry into our map or we replace the previous entry with
    our new one. As this is the case, we really need to check to see whether we have
    already added that particular key. To do this, we call the `has` method. If we
    have not added the genre, we are going to call set with an empty array. Finally,
    we are going to get the array out of our map using get so that we can push our
    values in:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加一个单独的艺术家，我们的代码会变得稍微复杂。使用set，我们要么在地图中添加一个新条目，要么用新条目替换先前的条目。由于情况如此，我们确实需要检查是否已经添加了特定的键。为此，我们调用`has`方法。如果我们还没有添加流派，我们将使用空数组调用set。最后，我们将使用get从地图中获取数组，以便我们可以推入我们的值：
- en: '[PRE87]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'One more thing we are going to do to our code is change the `Add` method. Right
    now, that implementation overwrites previous calls to `Add` for a particular genre,
    which means that calling `AddArtist` and then `Add` would end up overwriting the
    artist we added individually with the ones from the `Add` call:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要对我们的代码做的另一件事是改变`Add`方法。现在，该实现会覆盖对特定流派的先前调用`Add`，这意味着调用`AddArtist`然后`Add`最终会覆盖我们单独添加的艺术家与`Add`调用中的艺术家：
- en: '[PRE88]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In order to fix the `Add` method, it is a simple change to iterate over our
    artists and call the `AddArtist` method, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复`Add`方法，只需简单地迭代我们的艺术家并调用`AddArtist`方法，如下所示：
- en: '[PRE89]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, when we finish populating the `HeavyMetal` genre, our artists consist of
    `Iron Maiden`, `Tygers of Pan Tang`, `Saxon`, and `Doro`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们完成填充`HeavyMetal`流派时，我们的艺术家包括`Iron Maiden`，`Tygers of Pan Tang`，`Saxon`和`Doro`。
- en: Creating asynchronous code with promises and async/await
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺和异步/等待创建异步代码
- en: We often need to write code that behaves in an asynchronous fashion. By this,
    we mean that we need to start a task off and leave it running in the background
    while we do something else. An example of this could be when we have made a call
    out to a web service, which may take a while to return. For a long time, the standard
    way in JavaScript was to use a callback. A big problem with this approach is that
    the more callbacks we need, the more complex and potentially error-prone our code
    becomes. This is where promises come in.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要编写以异步方式行为的代码。这意味着我们需要启动一个任务并将其在后台运行，同时我们做其他事情。一个例子是当我们调用一个可能需要一段时间才能返回的web服务时。很长一段时间以来，在JavaScript中的标准方式是使用回调。这种方法的一个大问题是，我们需要的回调越多，我们的代码就变得越复杂，潜在的错误也就越多。这就是promise出现的地方。
- en: A promise tells us that something will happen asynchronously; after the asynchronous
    operation finishes, we have the option to continue processing and work with the
    result of the promise, or to catch any exceptions that have been thrown by the
    exception.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Promise告诉我们某事将以异步方式发生；在异步操作完成后，我们可以选择继续处理并处理promise的结果，或者捕获任何被异常抛出的异常。
- en: 'Here''s a sample that demonstrates this in action:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示这一点的示例：
- en: '[PRE90]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When we write a promise, we optionally take in two parameters—a `resolve` function
    and a `reject` function that can be called to trigger the error handling. Promises
    supply two functions for us to cope with these values, so `then()` will be triggered
    by successfully completing the operation and a separate `catch` function that
    copes with the `reject` function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写一个promise时，我们可以选择接受两个参数——一个`resolve`函数和一个`reject`函数，可以调用它们来触发错误处理。Promise为我们提供了两个函数来处理这些值，所以`then()`将在成功完成操作时触发，另一个`catch`函数处理`reject`函数。
- en: 'Now, we are going to run this code to see its effect:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行这段代码来看看它的效果：
- en: '[PRE91]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When we run this code, we get the following output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们得到以下输出：
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Between the `Processing continues until the web service returns` and `Finished
    web service` lines, there is a four-second delay that we would expect because
    the application is waiting for the promise to return before it writes out the
    text in the `then()` function. What this is demonstrating to us is that the code
    is behaving asynchronously here because it is not waiting for the web service
    call to come back when it executed the processing console log.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`处理继续直到web服务返回`和`完成web服务`之间，有四秒的延迟，这是我们预期的，因为应用程序在执行处理控制台日志时正在等待promise返回。这向我们展示的是，这段代码在这里是异步行为，因为它在执行处理控制台日志时并没有等待web服务调用返回。
- en: 'We might be tempted to think that this code is a bit too verbose, and that
    scattering `Promise<void>` is not the most intuitive way for others to understand
    that our code is asynchronous. TypeScript provides a syntactic equivalent that
    makes it much more apparent where our code is asynchronous. With the use of the
    `async` and `await` keywords, we easily turn our previous sample into something
    much more elegant:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会觉得这段代码有点冗长，而且散布`Promise<void>`并不是让其他人理解我们的代码是异步的最直观的方式。TypeScript提供了一个语法等效的方法，使得我们的代码异步的地方更加明显。通过使用`async`和`await`关键字，我们可以轻松地将之前的示例变得更加优雅：
- en: '[PRE93]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `async` keyword tells us that our function is returning `Promise`. It also
    tells the compiler that we want to process the function differently. Where we
    find `await` inside an `async` function, the application will pause that function
    at that point until the operation that is being awaited returns. At that point,
    processing continues, mimicking the behavior we saw inside the `then()` function
    from `Promise`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`关键字告诉我们，我们的函数正在返回`Promise`。它还告诉编译器我们希望以不同的方式处理这个函数。在`async`函数中找到`await`时，应用程序将在那一点暂停该函数，直到被等待的操作返回。在那一点，处理继续，模仿我们在`Promise`的`then()`函数中看到的行为。'
- en: 'In order to catch errors in `async`/`await`, we really should wrap the code
    inside the function in a try...catch block. Where the error was explicitly caught
    by the `catch()` function, `async`/`await` does not have an equivalent way of
    handling errors, so it is up to us to deal with problems:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获`async`/`await`中的错误，我们真的应该将函数内部的代码包装在try...catch块中。当错误被`catch()`函数明确捕获时，`async`/`await`没有处理错误的等效方式，所以我们需要处理问题：
- en: '[PRE94]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Whichever approach you choose to take is going to be a personal choice. The
    use of `async`/`await` just means it wraps the `Promise` approach so the runtime
    behavior of the different techniques is exactly the same. What I do recommend
    though is, once you decide on an approach in an application, be consistent. Don't
    mix styles as that will make it much harder for anyone reviewing your application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择采取哪种方法都是个人选择。使用`async`/`await`只是意味着它包装了`Promise`方法，因此不同技术的运行时行为完全相同。不过我建议的是，一旦你在应用程序中决定了一种方法，就要保持一致。不要混合风格，因为这会让任何审查你的应用程序的人感到困难。
- en: Creating UIs with Bootstrap
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap创建UI。
- en: In the remaining chapters, we are going to be doing a lot of work in the browser.
    Creating an attractive UI can be a difficult thing to do, especially in an era
    when we may also be targeting mobile devices in different layout modes. In order
    to make things easier for ourselves, we are going to rely quite heavily on Bootstrap.
    Bootstrap was designed to be a mobile device first UI framework that smoothly
    scales up to PC browsers. In this section, we are going to lay out the base template
    that contains the standard Bootstrap elements, and then have a look at how to
    lay out a simple page using features such as the Bootstrap grid system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将在浏览器中做很多工作。创建一个吸引人的UI可能是一件困难的事情，特别是在一个我们可能还要针对不同布局模式的移动设备的时代。为了让事情对我们自己更容易些，我们将相当依赖Bootstrap。Bootstrap被设计为一个移动设备优先的UI框架，可以平稳地扩展到PC浏览器。在本节中，我们将布置包含标准Bootstrap元素的基本模板，然后看看如何使用诸如Bootstrap网格系统等功能来布置一个简单的页面。
- en: We are going to start with the starter template from Bootstrap ([https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template](https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template)).
    With this particular template, we avoid the need to download and install the various
    CSS stylesheets and JavaScript files; instead, we rely on well-known **Content
    Delivery Networks** (**CDNs**) to source these files for us.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Bootstrap的起始模板开始（[https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template](https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template)）。使用这个特定的模板，我们避免了下载和安装各种CSS样式表和JavaScript文件的需要；相反，我们依赖于众所周知的**内容交付网络**（**CDN**）来为我们获取这些文件。
- en: Where possible, I would recommend using CDNs to source external JavaScript and
    CSS files. This provides many benefits including not needing to maintain these
    files ourselves and getting the benefit of browser caching when the browser has
    encountered this CDN file elsewhere.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我建议使用CDN来获取外部JavaScript和CSS文件。这提供了许多好处，包括不需要自己维护这些文件，并在浏览器在其他地方遇到这个CDN文件时获得浏览器缓存的好处。
- en: 'The starter template looks as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 起始模板如下所示：
- en: '[PRE95]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The starting point for laying out content is the container. This goes in the
    preceding content section. The following code shows the `div` section:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 布局内容的起点是容器。这是在前面的内容部分。以下代码显示了`div`部分：
- en: '[PRE96]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `container` class gives us that familiar Twitter look where it has a fixed
    size for each screen size. If we need to fill the full window, we can change this
    to `container-fluid`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`container`类给了我们熟悉的Twitter外观，每个屏幕尺寸都有固定的大小。如果我们需要填满整个窗口，我们可以将其更改为`container-fluid`。'
- en: 'Inside the container, Bootstrap attempts to lay items out in a grid pattern.
    Bootstrap operates a system where each row of the screen can be represented as
    up to 12 discrete columns. By default, these columns are evenly spread out across
    the page so we can make complicated layouts just by choosing the appropriate number
    of columns to occupy for each part of our UI. Fortunately for us, Bootstrap provides
    an extensive set of predefined styles that help us to make layouts for different
    types of devices, whether they are PCs, mobile phones, or tablets. These styles
    all follow the same naming convention of `.col-<<size-identifier>>-<<number-of-columns>>`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部，Bootstrap尝试以网格模式布置项目。Bootstrap操作一个系统，屏幕的每一行可以表示为最多12个离散的列。默认情况下，这些列均匀分布在页面上，因此我们可以通过选择适当数量的列来创建复杂的布局。幸运的是，Bootstrap提供了一套广泛的预定义样式，帮助我们为不同类型的设备创建布局，无论是PC、手机还是平板电脑。这些样式都遵循相同的命名约定`.col-<<size-identifier>>-<<number-of-columns>>`：
- en: '| **Type** | **Extra small devices** | **Small devices** | **Medium devices**
    | **Large devices** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **超小设备** | **小设备** | **中等设备** | **大设备** |'
- en: '| **Dimensions** | Phones < 768px | Tablets >= 768px | Desktops >= 992px |
    Desktops >= 1200px |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **尺寸** | 手机 < 768px | 平板 >= 768px | 桌面 >= 992px | 桌面 >= 1200px |'
- en: '| **Prefix** | .col-xs- | .col-sm- | .col-md- | .col-lg- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **前缀** | .col-xs- | .col-sm- | .col-md- | .col-lg- |'
- en: 'The way that the number of columns works is that each row should ideally add
    up to 12 columns. So, if we wanted to have a row made of content covering three
    columns, then six columns, and finally another three columns, we would define
    our rows to look like this inside our container:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列数的工作方式是，每行理想情况下应该加起来为12列。因此，如果我们想要一行由三列、然后六列，最后又是三列的内容，我们会在容器内定义我们的行如下：
- en: '[PRE97]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'That styling defines how this would appear on small devices. It is possible
    to override the styles for larger devices. For instance, if we wanted large devices
    to use columns of five, two, and five, we could apply this styling:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式定义了在小设备上的显示方式。可以覆盖大设备的样式。例如，如果我们希望大设备使用五列、两列和五列，我们可以应用这种样式：
- en: '[PRE98]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is the beauty of a responsive layout system. It allows us to generate content
    that is appropriate for our devices.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是响应式布局系统的美妙之处。它允许我们生成适合我们设备的内容。
- en: 'Let''s take a look at how to add some content to our page. We are going to
    add `jumbotron` to our first column, some text into our second column, and a button
    in our third column:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向我们的页面添加一些内容。我们将在第一列中添加`jumbotron`，在第二列中添加一些文本，并在第三列中添加一个按钮：
- en: '[PRE99]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Again, we are using CSS styling to control what our display looks like. By giving
    a `div` section a styling of `jumbotron`, Bootstrap immediately applies that styling
    for us. We controlled exactly what our button looks like by choosing to make it
    the primary button (`btn-primary`) and so on.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用CSS样式来控制我们的显示样式。通过给`div`部分添加`jumbotron`样式，Bootstrap立即为我们应用了该样式。我们通过选择将其设置为主按钮（`btn-primary`）等来精确控制我们的按钮的外观。
- en: '`jumbotron` normally stretches across the width of all of the columns. We put
    it inside a three-column `div` just so we can see that the width and styling is
    controlled by the grid layout system and that `jumbotron` does not have some special
    properties that force it to lay out across the page.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`jumbotron`通常横跨所有列的宽度。我们将其放在一个三列的`div`中，只是为了让我们看到宽度和样式是由网格布局系统控制的，`jumbotron`并没有一些特殊属性强制它横跨页面。'
- en: When I want to rapidly prototype a layout, I always follow a two-stage process.
    The first step is to draw on a piece of paper what I want my UI to look like.
    I could do this using a wireframe tool but I like the ability to quickly draw
    things out. Once I have got a general idea of what I want my layout to look like,
    I use a tool such as Layoutit! ([https://www.layoutit.com/](https://www.layoutit.com/))
    to put the ideas on to the screen; this also gives me the option to export the
    layout so that I can further refine it by hand.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想要快速原型设计布局时，我总是遵循两个阶段的过程。第一步是在纸上画出我想要UI看起来的样子。我可以使用线框工具来做到这一点，但我喜欢能够快速画出东西的能力。一旦我大致知道我想要的布局是什么样子，我就会使用Layoutit!（[https://www.layoutit.com/](https://www.layoutit.com/)）这样的工具将想法放到屏幕上；这也给了我导出布局的选项，这样我就可以手工进一步完善它。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a look at features of TypeScript that help us to build
    future-proof TypeScript code. We looked at how to set the appropriate ES levels
    to simulate or use modern ECMAScript features. We looked at how to use union and
    intersection types as well as how to create type aliases. We then looked into
    object spread and REST properties before we covered AOP with decorators. We also
    covered how to create and use map types, as well as using generics and promises.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了TypeScript的一些特性，这些特性帮助我们构建未来的TypeScript代码。我们看了如何设置适当的ES级别来模拟或使用现代ECMAScript特性。我们看了如何使用联合和交集类型，以及如何创建类型别名。然后我们研究了对象扩展和REST属性，然后我们涵盖了装饰器的AOP。我们还介绍了如何创建和使用映射类型，以及如何使用泛型和promises。
- en: As preparation for the UIs we will be producing in the rest of this book, we
    briefly looked at using Bootstrap to lay out UIs and covered the basics of the
    Bootstrap grid layout system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备本书其余部分中将要制作的UI，我们简要介绍了使用Bootstrap来布局UI，并介绍了Bootstrap网格布局系统的基础知识。
- en: In the next chapter, we are going to build a simple markdown editor using a
    simple Bootstrap web page hooked up to our TypeScript. We will see how techniques
    such as design patterns and single responsibility classes help us to create robust
    professional code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用一个简单的Bootstrap网页构建一个简单的Markdown编辑器，连接到我们的TypeScript。我们将看到设计模式和单一职责类等技术如何帮助我们创建健壮的专业代码。
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'We have written an application that allows users to convert from Fahrenheit
    into Celsius and from Celsius into Fahrenheit. The calculations are performed
    in the following classes:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写了一个应用程序，允许用户将华氏度转换为摄氏度，以及将摄氏度转换为华氏度。计算是在以下类中执行的：
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We want to write a method that accepts a temperature and an instance of either
    of these types, which will then perform the relevant calculation. What technique
    would we use to write this method?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个方法，该方法接受一个温度和这些类型的实例之一，然后执行相关的计算。我们将使用什么技术来编写这个方法？
- en: 'We have written the following class:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经编写了以下类：
- en: '[PRE101]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We want to use this in another class where we will add a number of commands.
    `Name` of the command is going to be the key that we can use to look up `Command`
    later on in our code. What would we use to provide this key-value functionality
    and how would we add records to it?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在另一个类中使用这个功能，我们将在其中添加多个命令。`Name`命令将作为键，我们可以在代码中稍后查找`Command`。我们将使用什么来提供这种键值功能，以及如何向其中添加记录？
- en: How would we automatically log that we were adding entries to the command we
    added in *Question 2* without adding any code inside our `Add` methods?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动记录我们在*问题2*中添加的命令的条目，而不在我们的`Add`方法中添加任何代码？
- en: We have created a Bootstrap web page where we want to display a row with six
    medium columns of equal size. How would we do this?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个Bootstrap网页，我们想要显示一个包含六个中等大小列的行。我们该如何做？
