["```cs\npublic partial class Program \n{ \n  private static intGetFactorial(intintNumber) \n  { \n    if (intNumber == 0) \n    { \n      return 1; \n    } \n    returnintNumber * GetFactorial(intNumber - 1); \n  } \n} \n\n```", "```cs\npublic static class ExtensionMethods \n{ \n  public static bool IsPrime(this int i) \n  { \n    if ((i % 2) == 0) \n    { \n      return i == 2; \n    } \n    int sqrt = (int)Math.Sqrt(i); \n    for (int t = 3; t <= sqrt; t = t + 2) \n    { \n      if (i % t == 0) \n      { \n        return false; \n      } \n    } \n    return i != 1; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static string NumberFactorType( \n    int intSelectedNumber) \n  { \n    if (intSelectedNumber < 2) \n    { \n      return \"neither prime nor composite number\"; \n    } \n    else if (intSelectedNumber.IsPrime()) \n    { \n      return \"prime number\"; \n    } \n    else \n    { \n      return \"composite number\"; \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static void TransformIntIntoText() \n  { \n    for (int i = 0; i < 10; i++) \n    { \n      Console.WriteLine( \n        \"{0} is {1}\", i, NumberFactorType(i)); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static byte HexCharToByte( \n    char c) \n  { \n    byte res; \n\n    switch (c) \n    { \n      case '1': \n        res = 1; \n        break; \n      case '2': \n        res = 2; \n        break; \n      case '3': \n        res = 3; \n        break; \n      case '4': \n        res = 4; \n        break; \n      case '5': \n        res = 5; \n        break; \n      case '6': \n        res = 6; \n        break; \n      case '7': \n        res = 7; \n        break; \n      case '8': \n        res = 8; \n        break; \n      case '9': \n        res = 9; \n        break; \n      case 'A': \n      case 'a': \n        res = 10; \n        break; \n      case 'B': \n      case 'b': \n        res = 11; \n        break; \n      case 'C': \n      case 'c': \n        res = 12; \n        break; \n      case 'D': \n      case 'd': \n        res = 13; \n        break; \n      case 'E': \n      case 'e': \n        res = 14; \n        break; \n      case 'F': \n      case 'f': \n        res = 15; \n        break; \n      default: \n        res = 0; \n        break; \n    } \n\n    return res; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static intHexStringToInt( \n    string s) \n  { \n    int iCnt = 0; \n    int retVal = 0; \n    for (inti = s.Length - 1; i>= 0; i--) \n    { \n      retVal += HexCharToByte(s[i]) *  \n        (int) Math.Pow(0x10, iCnt++); \n    } \n    return retVal; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void GetIntFromHexString() \n  { \n    string[] hexStrings = { \n      \"FF\", \"12CE\", \"F0A0\", \"3BD\", \n      \"D43\", \"35\", \"0\", \"652F\", \n      \"8DCC\", \"4125\" \n    }; \n    for (int i = 0; i < hexStrings.Length; i++) \n    { \n      Console.WriteLine( \n        \"0x{0}\\t= {1}\", \n        hexStrings[i], \n        HexStringToInt(hexStrings[i])); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static byte HexCharToByteFunctional( \n    char c) \n  { \n    return c.Match() \n      .With(ch =>ch == '1', (byte)1) \n      .With(ch =>ch == '2', 2) \n      .With(ch =>ch == '3', 3) \n      .With(ch =>ch == '4', 4) \n      .With(ch =>ch == '5', 5) \n      .With(ch =>ch == '6', 6) \n      .With(ch =>ch == '7', 7) \n      .With(ch =>ch == '8', 8) \n      .With(ch =>ch == '9', 9) \n      .With(ch =>ch == 'A', 10) \n      .With(ch =>ch == 'a', 10) \n      .With(ch =>ch == 'B', 11) \n      .With(ch =>ch == 'b', 11) \n      .With(ch =>ch == 'C', 12) \n      .With(ch =>ch == 'c', 12) \n      .With(ch =>ch == 'D', 13) \n      .With(ch =>ch == 'd', 13) \n      .With(ch =>ch == 'E', 14) \n      .With(ch =>ch == 'e', 14) \n      .With(ch =>ch == 'F', 15) \n      .With(ch =>ch == 'f', 15) \n      .Else(0) \n      .Do(); \n  } \n} \n\n```", "```cs\npublic static class PatternMatch \n{ \n  public static PatternMatchContext<TIn> Match<TIn>( \n    this TIn value) \n  { \n    return new PatternMatchContext<TIn>(value); \n  } \n} \n\n```", "```cs\npublic class PatternMatchContext<TIn> \n{ \n  private readonlyTIn _value; \n  internal PatternMatchContext(TIn value) \n  { \n    _value = value; \n  } \n\n  public PatternMatchOnValue<TIn, TOut> With<TOut>( \n    Predicate<TIn> condition,  \n    TOut result) \n  { \n    return new PatternMatchOnValue<TIn, TOut>(_value) \n      .With(condition, result); \n  } \n} \n\n```", "```cs\ninternal PatternMatchContext(TIn value) \n{ \n  _value = value; \n} \n\n```", "```cs\npublic class PatternMatchOnValue<TIn, TOut> \n{ \n  private readonlyIList<PatternMatchCase> _cases =  \n    new List<PatternMatchCase>(); \n  private readonlyTIn _value; \n  private Func<TIn, TOut> _elseCase; \n\n  internal PatternMatchOnValue(TIn value) \n  { \n    _value = value; \n  } \n\n  public PatternMatchOnValue<TIn, TOut> With( \n    Predicate<TIn> condition,  \n    Func<TIn, TOut> result) \n  { \n    _cases.Add(new PatternMatchCase \n    { \n      Condition = condition, \n      Result = result \n    }); \n\n    return this; \n  } \n\n  public PatternMatchOnValue<TIn, TOut> With( \n    Predicate<TIn> condition,  \n    TOut result) \n  { \n    return With(condition, x => result); \n  } \n\n  public PatternMatchOnValue<TIn, TOut> Else( \n  Func<TIn, TOut> result) \n  { \n    if (_elseCase != null) \n    { \n      throw new InvalidOperationException( \n        \"Cannot have multiple else cases\"); \n    } \n    _elseCase = result; \n    return this; \n  } \n\n  public PatternMatchOnValue<TIn, TOut> Else( \n    TOut result) \n  { \n    return Else(x => result); \n  } \n\n  public TOut Do() \n  { \n    if (_elseCase != null) \n    { \n      With(x => true, _elseCase); \n      _elseCase = null; \n    } \n\n    `foreach (var test in _cases) \n    { \n      if (test.Condition(_value)) \n      { \n        returntest.Result(_value); \n      } \n    } \n\n    throw new IncompletePatternMatchException(); \n  } \n\n  private structPatternMatchCase \n  { \n    public Predicate<TIn> Condition; \n    publicFunc<TIn, TOut> Result; \n  } \n} \n\n```", "```cs\ninternal PatternMatchOnValue(TIn value) \n{ \n  _value = value; \n} \n\n```", "```cs\npublic PatternMatchOnValue<TIn, TOut> With( \n  Predicate<TIn> condition, \n  TOut result) \n{ \n  return With(condition, x => result); \n} \n\n```", "```cs\npublic PatternMatchOnValue<TIn, TOut> With( \n  Predicate<TIn> condition, \n  Func<TIn, TOut> result) \n{ \n  _cases.Add(new PatternMatchCase \n  { \n    Condition = condition, \n    Result = result \n  }); \n\n  return this; \n} \n\n```", "```cs\nprivate structPatternMatchCase \n{ \n  public Predicate<TIn> Condition; \n  publicFunc<TIn, TOut> Result; \n} \n\n```", "```cs\npublic PatternMatchOnValue<TIn, TOut> Else( \n  TOut result) \n{ \n  return Else(x => result); \n} \n\n```", "```cs\npublic PatternMatchOnValue<TIn, TOut> Else( \n  Func<TIn, TOut> result) \n{ \n  if (_elseCase != null) \n  { \n    throw new InvalidOperationException( \n      \"Cannot have multiple else cases\"); \n  } \n  _elseCase = result; \n  return this; \n} \n\n```", "```cs\npublic TOut Do() \n{ \n  if (_elseCase != null) \n  { \n    With(x => true, _elseCase); \n    _elseCase = null; \n  } \n  foreach (var test in _cases) \n  { \n    if (test.Condition(_value)) \n    { \n      returntest.Result(_value); \n    } \n  } \n  throw new IncompletePatternMatchException(); \n} \n\n```", "```cs\nif (_elseCase != null) \n{ \n  With(x => true, _elseCase); \n  _elseCase = null; \n} \n\n```", "```cs\nforeach (var test in _cases) \n{ \n  if (test.Condition(_value)) \n  { \n    return test.Result(_value); \n  } \n} \n\n```", "```cs\nthrow new IncompletePatternMatchException(); \n\n```", "```cs\npublic class IncompletePatternMatchException : \n  Exception \n{ \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static intHexStringToInt( \n    string s) \n  { \n    int iCnt = 0; \n    int retVal = 0; \n    for (int i = s.Length - 1; i >= 0; i--) \n    { \n      retVal += HexCharToByteFunctional(s[i]) * \n      (int)Math.Pow(0x10, iCnt++); \n    } \n\n    return retVal; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static intHexStringToIntFunctional( \n    string s) \n  { \n    returns.ToCharArray() \n     .ToList() \n     .Select((c, i) => new { c, i }) \n     .Sum((v) => \n       HexCharToByteFunctional(v.c) * \n         (int)Math.Pow(0x10, v.i)); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void GetIntFromHexStringFunctional() \n  { \n    string[] hexStrings = { \n      \"FF\", \"12CE\", \"F0A0\", \"3BD\", \n      \"D43\", \"35\", \"0\", \"652F\", \n      \"8DCC\", \"4125\" \n    }; \n    Console.WriteLine( \n      \"Invoking GetIntFromHexStringFunctional() function\"); \n    for (int i = 0; i<hexStrings.Length; i++) \n    { \n      Console.WriteLine( \n        \"0x{0}\\t= {1}\", \n        hexStrings[i], \n        HexStringToIntFunctional( \n          hexStrings[i])); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void IsOperatorBeforeCSharp7() \n  { \n    object o = GetData(); \n    if (o is String) \n    { \n      var s = (String)o; \n      Console.WriteLine( \n        \"The object is String. Value = {0}\", \n          s); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static object GetData( \n      bool objectType = true) \n  { \n    if (objectType) \n        return \"One\"; \n    else \n        return 1; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void IsOperatorInCSharp7() \n  { \n    object o = GetData(); \n    if (o is String s) \n    { \n      Console.WriteLine( \n          \"The object is String. Value = {0}\", \n           s); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void SwitchCaseInCSharp7() \n  { \n    object x = GetData( \n        false); \n    switch (x) \n    { \n      case string s: \n          Console.WriteLine( \n              \"{0} is a string of length {1}\", \n              x, \n              s.Length); \n          break; \n      case int i: \n          Console.WriteLine( \n              \"{0} is an {1} int\", \n              x, \n              (i % 2 == 0 ? \"even\" : \"odd\")); \n          break; \n      default: \n          Console.WriteLine( \n              \"{0} is something else\", \n              x); \n          break; \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<int> WordToNumber(string word) \n  { \n    Nullable<int> returnValue; \n    if (word == null) \n    { \n      return null; \n    } \n    switch (word.ToLower()) \n    { \n      case \"zero\": \n        returnValue = 0; \n        break; \n      case \"one\": \n        returnValue = 1; \n        break; \n      case \"two\": \n        returnValue = 2; \n        break; \n      case \"three\": \n        returnValue = 3; \n        break; \n      case \"four\": \n        returnValue = 4; \n        break; \n      case \"five\": \n        returnValue = 5; \n        break; \n      default: \n        returnValue = null; \n        break; \n    } \n\n    return returnValue; \n  } \n} \n\n```", "```cs\nif (word == null) \n{ \n  return null; \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void PrintStringNumber( \n    string stringNumber) \n  { \n    if (stringNumber == null && \n      WordToNumber(stringNumber) == null) \n    { \n      Console.WriteLine( \n        \"Word: null is Int: null\"); \n    } \n    else \n    { \n      Console.WriteLine( \n        \"Word: {0} is Int: {1}\", \n        stringNumber.ToString(), \n        WordToNumber(stringNumber)); \n    } \n  } \n} \n\n```", "```cs\nif (stringNumber == null && \n  WordToNumber(stringNumber) == null) \n\n```", "```cs\npublic partial class Program \n{ \n  private static void PrintIntContainingNull() \n  { \n    PrintStringNumber(\"three\"); \n    PrintStringNumber(\"five\"); \n    PrintStringNumber(null); \n    PrintStringNumber(\"zero\"); \n    PrintStringNumber(\"four\"); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void AmplifyString() \n  { \n    IEnumerable<string> stringEnumerable \n      = YieldNames(); \n    Console.WriteLine( \n      \"Enumerate the stringEnumerable\"); \n\n    foreach (string s -> in stringEnumerable) \n    { \n      Console.WriteLine( \n        \"- {0}\", s); \n    } \n\n    IEnumerable<string>stringSorted =  \n      SortAscending(stringEnumerable); \n\n    Console.WriteLine(); \n    Console.WriteLine( \n      \"Sort the stringEnumerable\"); \n\n    foreach (string s -> in stringSorted) \n    { \n      Console.WriteLine( \n        \"- {0}\", s); \n    } \n  } \n} \n\n```", "```cs\nIEnumerable<string> stringEnumerable \n  = YieldNames(); \n\n```", "```cs\nIEnumerable<string> stringSorted = \n  SortAscending(stringEnumerable); \n\n```", "```cs\npublic partial class Program \n{ \n  private static IEnumerable<string> YieldNames() \n  { \n    yield return \"Nicholas Shaw\"; \n    yield return \"Anthony Hammond\"; \n    yield return \"Desiree Waller\"; \n    yield return \"Gloria Allen\"; \n    yield return \"Daniel McPherson\"; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static IEnumerable<string> SortAscending( \n    IEnumerable<string> enumString) \n  { \n    returnenumString.OrderBy(s => s); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  Func<int> MultipliedFunc; \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<int>MultipliedByTwo( \n    Nullable<int>nullableInt) \n  { \n    if (nullableInt.HasValue) \n    { \n      int unWrappedInt =  \n        nullableInt.Value; \n      int multipliedByTwo =  \n        unWrappedInt * 2; \n      return GetNullableFromInt( \n        multipliedByTwo); \n    } \n    else \n    { \n      return new Nullable<int>(); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<int> GetNullableFromInt( \n    int iNumber) \n  { \n    return new Nullable<int>( \n      iNumber); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void RunMultipliedByTwo() \n  { \n    for (int i = 1; i <= 5; i++) \n    { \n      Console.WriteLine( \n        \"{0} multiplied by to is equal to {1}\", \n        i, MultipliedByTwo(i)); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Func<int> GetFuncFromInt( \n    int iItem) \n  { \n    return () => iItem; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Func<int> MultipliedByTwo( \n   Func<int> funcDelegate) \n  { \n    int unWrappedFunc =  \n      funcDelegate(); \n    int multipliedByTwo =  \n      unWrappedFunc* 2; \n    return GetFuncFromInt( \n      multipliedByTwo); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static void RunMultipliedByTwoFunc() \n  { \n    Func<int> intFunc = MultipliedByTwo( \n    () => 1 + 1); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Func<int> MultipliedByTwoFunction( \n    Func<int> funcDelegate) \n  { \n    return () => \n    { \n      int unWrappedFunc =  \n        funcDelegate(); \n      int multipliedByTwo =  \n        unWrappedFunc * 2; \n      return multipliedByTwo; \n    }; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<int> MultipliedByTwoFunction( \n    Nullable<int> iNullable, \n    Func<int,int> funcDelegate) \n  { \n    if (iNullable.HasValue) \n    { \n      int unWrappedInt = \n        iNullable.Value; \n      int multipliedByTwo = \n        funcDelegate(unWrappedInt); \n      return new Nullable<int>( \n        multipliedByTwo); \n    } \n    else \n    { \n      return new Nullable<int>(); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<int> MultipliedByTwo( \n    Nullable<int> iNullable) \n  {  \n    return MultipliedByTwoFunction( \n      iNullable, \n      (int x) => x * 2); \n  } \n} \n\n```", "```cs\nreturn MultipliedByTwoFunction( \n  iNullable, \n\n (int x) => x * 2);\n\n```", "```cs\npublic partial class Program \n{ \n  private static void RunMultipliedByTwo() \n  { \n    Console.WriteLine( \n      \"RunMultipliedByTwo() implementing \" + \n      \"higher-order programming\"); \n\n    for (int i = 1; i <= 5; i++) \n    { \n      Console.WriteLine( \n        \"{0} multiplied by to is equal to {1}\", \n        i, MultipliedByTwo(i)); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<T> MultipliedByTwoFunction<T>( \n    Nullable<T> iNullable, \n    Func<T,T> funcDelegate) \n    where T : struct \n  { \n    if (iNullable.HasValue) \n    { \n      T unWrappedInt = iNullable.Value; \n      T multipliedByTwo = funcDelegate(unWrappedInt); \n      return new Nullable<T>( \n        multipliedByTwo); \n    } \n    else \n    { \n      return new Nullable<T>(); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<R> MultipliedByTwoFunction<V, R>( \n    Nullable<V> iNullable, \n    Func<V,R> funcDelegate) \n  where V : struct \n  where R : struct \n  { \n    if (iNullable.HasValue) \n    { \n      V unWrappedInt = iNullable.Value; \n      R multipliedByTwo = funcDelegate(unWrappedInt); \n      return new Nullable<R>(multipliedByTwo); \n    } \n    else \n    { \n      return new Nullable<R>(); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  static Lazy<R> MultipliedByTwoFunction<V,R>( \n    Lazy<V> lazy, \n  Func<V, R> function) \n  where V : struct \n  where R : struct \n  { \n    return new Lazy<R>(() => \n    { \n      V unWrappedInt = lazy.Value; \n      R multipliedByTwo = function(unWrappedInt); \n      return multipliedByTwo; \n    }); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static M<R> MonadFunction<V, R>( \n    M<V> amplified, \n    Func<V, R> function) \n  { \n    // Implementation \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Nullable<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    Nullable<V> nullable, \n    Func<V, Nullable<R>> function) \n  where V : struct \n  where R : struct \n  { \n    if (nullable.HasValue) \n    { \n      V unWrappedInt = nullable.Value; \n      Nullable<R >multipliedByTwo = function(unWrappedInt); \n      return multipliedByTwo; \n    } \n    else \n    { \n      return new Nullable<R>(); \n    } \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Func<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    Func<V> funcDelegate, \n    Func<V, Func<R>> function) \n  { \n    return () => \n    { \n      V unwrappedValue = funcDelegate(); \n      Func<R> resultValue = function(unwrappedValue); \n      return resultValue(); \n    }; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Lazy<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    Lazy<V> lazy, \n    Func<V, Lazy<R>> function) \n  { \n    return new Lazy<R>(() => \n    { \n      V unwrappedValue = lazy.Value; \n      Lazy<R>resultValue = function(unwrappedValue); \n      return resultValue.Value; \n    }); \n  } \n\n  Private static async Task<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    Task<V> task, \n    Func<V, Task<R>> function) \n  { \n    V unwrappedValue = await task; \n    Task<R>resultValue = function(unwrappedValue); \n    return await resultValue; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  staticIEnumerable<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    IEnumerable<V> sequence, \n    Func<V, IEnumerable<R>> function) \n  { \n    foreach (V unwrappedValue in sequence) \n    { \n      IEnumerable<R> resultValue = function(unwrappedValue); \n      foreach (R r in resultValue) \n      yield return r; \n    } \n  } \n} \n\n```", "```cs\nif (nullable.HasValue) \n{ \n  V unWrappedInt = nullable.Value; \n  Nullable<R> multipliedByTwo = function(unWrappedInt); \n  return multipliedByTwo; \n} \nelse \n{ \n  return new Nullable<R>(); \n} \n\n```", "```cs\nprivate static async Task<R> \nMultipliedByTwoFunctionSpecial<V, R>( \n  Task<V> task, \n  Func<V, Task<R>> function) \n{ \n  V unwrappedValue = await task; \n  Task<R> resultValue = function(unwrappedValue); \n  return await resultValue; \n} \n\n```", "```cs\npublic partial class Program \n{ \n\n private static M<T> MonadFunction <T>(Titem)\n\n  { \n    // Implementation \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static M<R> MultipliedByTwoFunction <V, R>( \n    M<V> wrapped, Func<V, R> function) \n  { \n    // Implementation \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  private static Func<R> \n  MultipliedByTwoFunctionSpecial<V, R>( \n    Func<V> funcDelegate, \n    Func<V, Func<R>> function) \n  { \n    // Implementation \n  } \n} \n\n```"]