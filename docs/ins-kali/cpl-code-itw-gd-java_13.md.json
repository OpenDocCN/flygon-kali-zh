["```java\nprivate static final int MAX_CODE = 65535;\n...\npublic static boolean isUnique(String str) {\n\u00a0\u00a0Map<Character, Boolean> chars = new HashMap<>();\n\u00a0\u00a0// or use, for(char ch : str.toCharArray()) { ... }\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0if (str.codePointAt(i) <= MAX_CODE) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char ch = str.charAt(i);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!Character.isWhitespace(ch)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (chars.put(ch, true) != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"The given string \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contains unallowed characters\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\nprivate static final char A_CHAR = 'a';\n...\npublic static boolean isUnique(String str) {\n\u00a0\u00a0int marker = 0;\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0int s = str.charAt(i) - A_CHAR;\n\u00a0\u00a0\u00a0\u00a0int mask = 1 << s;\n\u00a0\u00a0\u00a0\u00a0if ((marker & mask) > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0marker = marker | mask;\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\nchar[] str = \"\u00a0\u00a0String\u00a0\u00a0\u00a0with spaces\u00a0\u00a0\".toCharArray();\n```", "```java\npublic static char[] encodeWhitespaces(char[] str) {\n\u00a0\u00a0// count whitespaces (step 1)\n\u00a0\u00a0int countWhitespaces = 0;\n\u00a0\u00a0for (int i = 0; i < str.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (Character.isWhitespace(str[i])) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0countWhitespaces++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0if (countWhitespaces > 0) {\n\u00a0\u00a0\u00a0\u00a0// create the encoded char[] (step 2)\n\u00a0\u00a0\u00a0\u00a0char[] encodedStr = new char[str.length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ countWhitespaces * 2];\n\u00a0\u00a0\u00a0\u00a0// populate the encoded char[] (step 3)\n\u00a0\u00a0\u00a0\u00a0int index = 0;\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < str.length; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Character.isWhitespace(str[i])) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0encodedStr[index] = '0';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0encodedStr[index + 1] = '2';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0encodedStr[index + 2] = '%';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index = index + 3;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0encodedStr[index] = str[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return encodedStr;\n\u00a0\u00a0}\n\u00a0\u00a0return str;\n}\n```", "```java\nif (Math.abs(q.length() - p.length()) > 1) {\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static boolean isOneEditAway(String q, String p) {\n\u00a0\u00a0// if the difference between the strings is bigger than 1 \n\u00a0\u00a0// then they are at more than one edit away\n\u00a0\u00a0if (Math.abs(q.length() - p.length()) > 1) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0// get shorter and longer string\n\u00a0\u00a0String shorter = q.length() < p.length() ? q : p;\n\u00a0\u00a0String longer = q.length() < p.length() ? p : q;\n\u00a0\u00a0int is = 0;\n\u00a0\u00a0int il = 0;\n\u00a0\u00a0boolean marker = false;\n\u00a0\u00a0while (is < shorter.length() && il < longer.length()) {\n\u00a0\u00a0\u00a0\u00a0if (shorter.charAt(is) != longer.charAt(il)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// first difference was found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// at the second difference we return false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (marker) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marker = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (shorter.length() == longer.length()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0is++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0is++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0il++;\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\npublic static String shrink(String str) {\n\u00a0\u00a0StringBuilder result = new StringBuilder();\n\u00a0\u00a0int count = 0;\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0count++;\n\u00a0\u00a0\u00a0\u00a0// we don't count whitespaces, we just copy them\n\u00a0\u00a0\u00a0\u00a0if (!Character.isWhitespace(str.charAt(i))) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if there are no more characters\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// or the next character is different\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// from the counted one\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i + 1) >= str.length()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| str.charAt(i) != str.charAt(i + 1)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// append to the final result the counted character\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// and number of consecutive occurrences\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.append(str.charAt(i))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.append(count);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// reset the counter since this \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// sequence was appended to the result\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.append(str.charAt(i));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = 0;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// return the result only if it is \n\u00a0\u00a0// shorter than the given string\n\u00a0\u00a0return result.length() > str.length()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? str : result.toString();\n}\n```", "```java\npublic static List<Integer> extract(String str) {\n\u00a0\u00a0List<Integer> result = new ArrayList<>();\n\u00a0\u00a0StringBuilder temp = new StringBuilder(\n\u00a0\u00a0\u00a0\u00a0String.valueOf(Integer.MAX_VALUE).length());\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0char ch = str.charAt(i);\n\u00a0\u00a0\u00a0\u00a0// or, if (((int) ch) >= 48 && ((int) ch) <= 57)\n\u00a0\u00a0\u00a0\u00a0if (Character.isDigit(ch)) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.append(ch);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.length() > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(Integer.parseInt(temp.toString()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.delete(0, temp.length());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\nchar[] musicalScore = new char[]{'\\uD83C', '\\uDFBC'}; \nchar[] smileyFace = new char[]{'\\uD83D', '\\uDE0D'};\u00a0\u00a0\u00a0\nchar[] twoHearts = new char[]{'\\uD83D', '\\uDC95'};\u00a0\u00a0\u00a0\nchar[] cyrillicZhe = new char[]{'\\u04DC'};\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nString str = \"is\" + String.valueOf(cyrillicZhe) + \"zhe\"\n\u00a0\u00a0+ String.valueOf(twoHearts) + \"two hearts\"\n\u00a0\u00a0+ String.valueOf(smileyFace) + \"smiley face and, \"\n\u00a0\u00a0+ String.valueOf(musicalScore) + \"musical score\";\n```", "```java\nString str = String.valueOf(Character.toChars(128149));\n```", "```java\npublic static List<Integer> extract(String str) {\n\u00a0\u00a0List<Integer> result = new ArrayList<>();\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0int cp = str.codePointAt(i);\n\u00a0\u00a0\u00a0\u00a0if (i < str.length()-1 \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& str.codePointCount(i, i+2) == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(cp);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(str.codePointAt(i+1));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static List<Integer> extract(String str) {\n\u00a0\u00a0List<Integer> result = new ArrayList<>();\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0int cp = str.codePointAt(i);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// the constant 2 means a suroggate pair\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (Character.charCount(cp) == 2) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(cp);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(str.codePointAt(i+1));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i++;\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static boolean isRotation(String str1, String str2) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return (str1 + str1).matches(\"(?i).*\" \n\u00a0\u00a0\u00a0\u00a0+ Pattern.quote(str2) + \".*\");\n}\n```", "```java\nprivate static void transpose(int m[][]) {\n\u00a0\u00a0for (int i = 0; i < m.length; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = i; j < m[0].length; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int temp = m[j][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[j][i] = m[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[i][j] = temp;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic static boolean rotateWithTranspose(int m[][]) {\n\u00a0\u00a0transpose(m);\n\u00a0\u00a0for (int i = 0; i < m[0].length; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = 0, k = m[0].length - 1; j < k; j++, k--) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int temp = m[j][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[j][i] = m[k][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[k][i] = temp;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\npublic static boolean rotateRing(int[][] m) {\n\u00a0\u00a0int len = m.length;\n\u00a0\u00a0// rotate counterclockwise\n\u00a0\u00a0for (int i = 0; i < len / 2; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = i; j < len - i - 1; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int temp = m[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// right -> top \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[i][j] = m[j][len - 1 - i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// bottom -> right \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[j][len - 1 - i] = m[len - 1 - i][len - 1 - j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// left -> bottom \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[len - 1 - i][len - 1 - j] = m[len - 1 - j][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// top -> left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[len - 1 - j][i] = temp;\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0return true;\n }\n```", "```java\nboolean firstRowHasZeros = false;\nboolean firstColumnHasZeros = false;\n// Search at least a zero on first row\nfor (int j = 0; j < m[0].length; j++) {\n\u00a0\u00a0if (m[0][j] == 0) {\n\u00a0\u00a0\u00a0\u00a0firstRowHasZeros = true;\n\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0}\n}\n// Search at least a zero on first column\nfor (int i = 0; i < m.length; i++) {\n\u00a0\u00a0if (m[i][0] == 0) {\n\u00a0\u00a0\u00a0\u00a0firstColumnHasZeros = true;\n\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0}\n}\n```", "```java\n// Search all zeros in the rest of the matrix\nfor (int i = 1; i < m.length; i++) {\n\u00a0\u00a0for (int j = 1; j < m[0].length; j++) {\n\u00a0\u00a0\u00a0\u00a0if (m[i][j] == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[i][0] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[0][j] = 0;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nfor (int i = 1; i < m.length; i++) {\n\u00a0\u00a0if (m[i][0] == 0) {\n\u00a0\u00a0\u00a0\u00a0setRowOfZero(m, i);\n\u00a0\u00a0}\n}\nfor (int j = 1; j < m[0].length; j++) {\n\u00a0\u00a0if (m[0][j] == 0) {\n\u00a0\u00a0\u00a0\u00a0setColumnOfZero(m, j);\n\u00a0\u00a0}\n}\n```", "```java\nif (firstRowHasZeros) {\n\u00a0\u00a0setRowOfZero(m, 0);\n}\nif (firstColumnHasZeros) {\n\u00a0\u00a0setColumnOfZero(m, 0);\n}\n```", "```java\nprivate static void setRowOfZero(int[][] m, int r) {\n\u00a0\u00a0for (int j = 0; j < m[0].length; j++) {\n\u00a0\u00a0\u00a0\u00a0m[r][j] = 0;\n\u00a0\u00a0}\n}\nprivate static void setColumnOfZero(int[][] m, int c) {\n\u00a0\u00a0for (int i = 0; i < m.length; i++) {\n\u00a0\u00a0\u00a0\u00a0m[i][c] = 0;\n\u00a0\u00a0}\n}\n```", "```java\npublic class StackNode {\n\u00a0\u00a0int value;\n\u00a0\u00a0int backLink;\n\u00a0\u00a0StackNode(int value, int backLink) {\n\u00a0\u00a0\u00a0\u00a0this.value = value;\n\u00a0\u00a0\u00a0\u00a0this.backLink = backLink;\n\u00a0\u00a0}\n}\n```", "```java\npublic class ThreeStack {\n\u00a0\u00a0private static final int STACK_CAPACITY = 15;\n\u00a0\u00a0// the array of stacks\n\u00a0\u00a0private final StackNode[] theArray;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0ThreeStack() {\n\u00a0\u00a0\u00a0\u00a0theArray = new StackNode[STACK_CAPACITY];\n\u00a0\u00a0\u00a0\u00a0initializeSlots();\n\u00a0\u00a0}\n\u00a0\u00a0...\u00a0\u00a0\u00a0\n\u00a0\u00a0private void initializeSlots() {\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < STACK_CAPACITY; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0theArray[i] = new StackNode(0, i + 1);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic class ThreeStack {\n\u00a0\u00a0private static final int STACK_CAPACITY = 15;\n\u00a0\u00a0private int size;\n\u00a0\u00a0// next free slot in array\n\u00a0\u00a0private int nextFreeSlot;\n\u00a0\u00a0// the array of stacks\n\u00a0\u00a0private final StackNode[] theArray;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0// maintain the parent for each node\n\u00a0\u00a0private final int[] backLinks = {-1, -1, -1};\u00a0\u00a0\n\u00a0\u00a0...\n\u00a0\u00a0public void push(int stackNumber, int value) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throws OverflowException {\n\u00a0\u00a0\u00a0\u00a0int stack = stackNumber - 1;\n\u00a0\u00a0\u00a0\u00a0int free = fetchIndexOfFreeSlot();\n\u00a0\u00a0\u00a0\u00a0int top = backLinks[stack];\n\u00a0\u00a0\u00a0\u00a0StackNode node = theArray[free];\n\u00a0\u00a0\u00a0\u00a0// link the free node to the current stack\n\u00a0\u00a0\u00a0\u00a0node.value = value;\n\u00a0\u00a0\u00a0\u00a0node.backLink = top;\n\u00a0\u00a0\u00a0\u00a0// set new top\n\u00a0\u00a0\u00a0\u00a0backLinks[stack] = free;\n\u00a0\u00a0}\n\u00a0\u00a0private int fetchIndexOfFreeSlot()\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throws OverflowException {\n\u00a0\u00a0\u00a0\u00a0if (size >= STACK_CAPACITY) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new OverflowException(\"Stack Overflow\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// get next free slot in array\n\u00a0\u00a0\u00a0\u00a0int free = nextFreeSlot;\n\u00a0\u00a0\u00a0\u00a0// set next free slot in array and increase size\n\u00a0\u00a0\u00a0\u00a0nextFreeSlot = theArray[free].backLink;\n\u00a0\u00a0\u00a0\u00a0size++;\n\u00a0\u00a0\u00a0\u00a0return free;\n\u00a0\u00a0}\n}\n```", "```java\npublic class ThreeStack {\n\u00a0\u00a0private static final int STACK_CAPACITY = 15;\n\u00a0\u00a0private int size;\n\u00a0\u00a0// next free slot in array\n\u00a0\u00a0private int nextFreeSlot;\n\u00a0\u00a0// the array of stacks\n\u00a0\u00a0private final StackNode[] theArray;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0// maintain the parent for each node\n\u00a0\u00a0private final int[] backLinks = {-1, -1, -1};\u00a0\u00a0\n\u00a0\u00a0...\n\u00a0\u00a0public StackNode pop(int stackNumber)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throws UnderflowException {\n\u00a0\u00a0\u00a0\u00a0int stack = stackNumber - 1;\n\u00a0\u00a0\u00a0\u00a0int top = backLinks[stack];\n\u00a0\u00a0\u00a0\u00a0if (top == -1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new UnderflowException(\"Stack Underflow\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0StackNode node = theArray[top]; // get the top node\n\u00a0\u00a0\u00a0\u00a0backLinks[stack] = node.backLink;\n\u00a0\u00a0\u00a0\u00a0freeSlot(top);\n\u00a0\u00a0\u00a0\u00a0return node;\n\u00a0\u00a0}\n\u00a0\u00a0private void freeSlot(int index) {\n\u00a0\u00a0\u00a0\u00a0theArray[index].backLink = nextFreeSlot;\n\u00a0\u00a0\u00a0\u00a0nextFreeSlot = index;\n\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0}\n}\n```", "```java\npublic static List<String> pairs(int[] m, int k) {\n\u00a0\u00a0if (m == null || m.length < 2) {\n\u00a0\u00a0\u00a0\u00a0return Collections.emptyList();\n\u00a0\u00a0}\n\u00a0\u00a0List<String> result = new ArrayList<>();\n\u00a0\u00a0java.util.Arrays.sort(m);\n\u00a0\u00a0int l = 0;\n\u00a0\u00a0int r = m.length - 1;\n\u00a0\u00a0while (l < r) {\n\u00a0\u00a0\u00a0\u00a0int sum = m[l] + m[r];\n\u00a0\u00a0\u00a0\u00a0if (sum == k) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.add(\"(\" + m[l] + \" + \" + m[r] + \")\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0l++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r--;\n\u00a0\u00a0\u00a0\u00a0} else if (sum < k) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0l++;\n\u00a0\u00a0\u00a0\u00a0} else if (sum > k) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r--;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic class MinHeap {\n\u00a0\u00a0int data;\n\u00a0\u00a0int heapIndex;\n\u00a0\u00a0int currentIndex;\n\u00a0\u00a0public MinHeap(int data, int heapIndex,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int currentIndex) {\n\u00a0\u00a0\u00a0\u00a0this.data = data;\n\u00a0\u00a0\u00a0\u00a0this.heapIndex = heapIndex;\n\u00a0\u00a0\u00a0\u00a0this.currentIndex = currentIndex;\n\u00a0\u00a0}\n}\n```", "```java\npublic static int[] merge(int[][] arrs, int k) {\n\u00a0\u00a0// compute the total length of the resulting array\n\u00a0\u00a0int len = 0;\n\u00a0\u00a0for (int i = 0; i < arrs.length; i++) {\n\u00a0\u00a0\u00a0\u00a0len += arrs[i].length;\n\u00a0\u00a0}\n\u00a0\u00a0// create the result array\n\u00a0\u00a0int[] result = new int[len];\n\u00a0\u00a0// create the min heap\n\u00a0\u00a0MinHeap[] heap = new MinHeap[k];\n\u00a0\u00a0// add in the heap first element from each array\n\u00a0\u00a0for (int i = 0; i < k; i++) {\n\u00a0\u00a0\u00a0\u00a0heap[i] = new MinHeap(arrs[i][0], i, 0);\n\u00a0\u00a0}\n\u00a0\u00a0// perform merging\n\u00a0\u00a0for (int i = 0; i < result.length; i++) {\n\u00a0\u00a0\u00a0\u00a0heapify(heap, 0, k);\n\u00a0\u00a0\u00a0\u00a0// add an element in the final result\n\u00a0\u00a0\u00a0\u00a0result[i] = heap[0].data;\n\u00a0\u00a0\u00a0\u00a0heap[0].currentIndex++;\n\u00a0\u00a0\u00a0\u00a0int[] subarray = arrs[heap[0].heapIndex];\n\u00a0\u00a0\u00a0\u00a0if (heap[0].currentIndex >= subarray.length) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap[0].data = Integer.MAX_VALUE;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap[0].data = subarray[heap[0].currentIndex];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static float median(int[] q, int[] p) {\n\u00a0\u00a0int lenQ = q.length;\n\u00a0\u00a0int lenP = p.length;\n\u00a0\u00a0if (lenQ > lenP) {\n\u00a0\u00a0\u00a0\u00a0swap(q, p);\n\u00a0\u00a0}\n\u00a0\u00a0int qPointerMin = 0;\n\u00a0\u00a0int qPointerMax = q.length;\n\u00a0\u00a0int midLength = (q.length + p.length + 1) / 2;\n\u00a0\u00a0int qPointer;\n\u00a0\u00a0int pPointer;\n\u00a0\u00a0while (qPointerMin <= qPointerMax) {\n\u00a0\u00a0\u00a0\u00a0qPointer = (qPointerMin + qPointerMax) / 2;\n\u00a0\u00a0\u00a0\u00a0pPointer = midLength - qPointer;\n\u00a0\u00a0\u00a0\u00a0// perform binary search\n\u00a0\u00a0\u00a0\u00a0if (qPointer < q.length \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& p[pPointer-1] > q[qPointer]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// qPointer must be increased\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qPointerMin = qPointer + 1;\n\u00a0\u00a0\u00a0\u00a0} else if (qPointer > 0 \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& q[qPointer-1] > p[pPointer]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// qPointer must be decreased\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qPointerMax = qPointer - 1;\n\u00a0\u00a0\u00a0\u00a0} else { // we found the poper qPointer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int maxLeft = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (qPointer == 0) { // first element on array 'q'?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxLeft = p[pPointer - 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (pPointer == 0) { // first element \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// of array 'p'?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxLeft = q[qPointer - 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else { // we are somewhere in the middle -> find max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxLeft = Integer.max(q[qPointer-1], p[pPointer-1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if the length of 'q' + 'p' arrays is odd, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// return max of left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((q.length + p.length) % 2 == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return maxLeft;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int minRight = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (qPointer == q.length) { // last element on 'q'?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minRight = p[pPointer];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (pPointer == p.length) { // last element \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// on 'p'?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minRight = q[qPointer];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else { // we are somewhere in the middle -> find min\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minRight = Integer.min(q[qPointer], p[pPointer]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (maxLeft + minRight) / 2.0f;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```", "```java\npublic static int ofOneOptimized(int[][] matrix) {\n\u00a0\u00a0int maxSubMatrixSize = 1;\n\u00a0\u00a0int rows = matrix.length;\n\u00a0\u00a0int cols = matrix[0].length;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0int[][] subMatrix = new int[rows][cols];\n\u00a0\u00a0// copy the first row\n\u00a0\u00a0for (int i = 0; i < cols; i++) {\n\u00a0\u00a0\u00a0\u00a0subMatrix[0][i] = matrix[0][i];\n\u00a0\u00a0}\n\u00a0\u00a0// copy the first column\n\u00a0\u00a0for (int i = 0; i < rows; i++) {\n\u00a0\u00a0\u00a0\u00a0subMatrix[i][0] = matrix[i][0];\n\u00a0\u00a0}\n\u00a0\u00a0// for rest of the matrix check if matrix[i][j]=1\n\u00a0\u00a0for (int i = 1; i < rows; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = 1; j < cols; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (matrix[i][j] == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subMatrix[i][j] = Math.min(subMatrix[i - 1][j - 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Math.min(subMatrix[i][j - 1], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subMatrix[i - 1][j])) + 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// compute the maximum of the current sub-matrix\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxSubMatrixSize = Math.max(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxSubMatrixSize, subMatrix[i][j]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return maxSubMatrixSize;\n}\n```", "```java\npublic static int maxArea(int[] heights) {\n\u00a0\u00a0int maxArea = 0;\n\u00a0\u00a0for (int i = 0; i < heights.length; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = i + 1; j < heights.length; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// traverse each (i, j) pair\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxArea = Math.max(maxArea, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Math.min(heights[i], heights[j]) * (j - i));\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return maxArea;\n}\n```", "```java\npublic static int maxAreaOptimized(int[] heights) {\n\u00a0\u00a0int maxArea = 0;\n\u00a0\u00a0int i = 0; // left-hand side pointer\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0int j = heights.length - 1; // right-hand side pointer\n\u00a0\u00a0// area cannot be negative, \n\u00a0\u00a0// therefore i should not be greater than j\n\u00a0\u00a0while (i < j) {\n\u00a0\u00a0\u00a0\u00a0// calculate area for each pair\n\u00a0\u00a0\u00a0\u00a0maxArea = Math.max(maxArea, Math.min(heights[i],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heights[j]) * (j - i));\n\u00a0\u00a0\u00a0\u00a0if (heights[i] <= heights[j]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i++; // left pointer is small than right pointer\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j--; // right pointer is small than left pointer\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return maxArea;\n}\n```", "```java\npublic static int find(int[] m, int x) {\n\u00a0\u00a0int left = 0;\n\u00a0\u00a0int right = m.length - 1;\n\u00a0\u00a0while (left <= right) {\n\u00a0\u00a0\u00a0\u00a0// half the search space\n\u00a0\u00a0\u00a0\u00a0int middle = (left + right) / 2;\n\u00a0\u00a0\u00a0\u00a0// we found the searched value\n\u00a0\u00a0\u00a0\u00a0if (m[middle] == x) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return middle;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// check if the right-half is sorted (m[middle ... right])\n\u00a0\u00a0\u00a0\u00a0if (m[middle] <= m[right]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check if n is in m[middle ... right]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (x > m[middle] && x <= m[right]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = middle + 1;\u00a0\u00a0// search in the right-half\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = middle - 1;\t// search in the left-half\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else { // the left-half is sorted (A[left ... middle])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check if n is in m[left ... middle]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (x >= m[left] && x < m[middle]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = middle - 1; // search in the left-half\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = middle + 1; // search in the right-half\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```", "```java\npublic static void mergeIntervals(Interval[] intervals) {\n\u00a0\u00a0// Step 1\n\u00a0\u00a0java.util.Arrays.sort(intervals,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new Comparator<Interval>() {\n\u00a0\u00a0\u00a0\u00a0public int compare(Interval i1, Interval i2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return i1.start - i2.start;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0});\n\u00a0\u00a0Stack<Interval> stackOfIntervals = new Stack();\n\u00a0\u00a0for (Interval interval : intervals) {\n\u00a0\u00a0\u00a0\u00a0// Step 3a\n\u00a0\u00a0\u00a0\u00a0if (stackOfIntervals.empty() || interval.start\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0> stackOfIntervals.peek().end) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stackOfIntervals.push(interval);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Step 3b\n\u00a0\u00a0\u00a0\u00a0if (stackOfIntervals.peek().end < interval.end) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stackOfIntervals.peek().end = interval.end;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// print the result\n\u00a0\u00a0while (!stackOfIntervals.empty()) {\n\u00a0\u00a0\u00a0\u00a0System.out.print(stackOfIntervals.pop() + \" \");\n\u00a0\u00a0}\n}\n```", "```java\npublic static void mergeIntervals(Interval intervals[]) {\n\u00a0\u00a0// Step 1\n\u00a0\u00a0java.util.Arrays.sort(intervals,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new Comparator<Interval>() {\n\u00a0\u00a0\u00a0\u00a0public int compare(Interval i1, Interval i2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return i2.start - i1.start;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0});\n\u00a0\u00a0int index = 0;\n\u00a0\u00a0for (int i = 0; i < intervals.length; i++) {\n\u00a0\u00a0\u00a0\u00a0// Step 2a\n\u00a0\u00a0\u00a0\u00a0if (index != 0 && intervals[index - 1].start \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<= intervals[i].end) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (index != 0 && intervals[index - 1].start \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<= intervals[i].end) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// merge the previous interval with \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the current interval\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intervals[index - 1].end = Math.max(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intervals[index - 1].end, intervals[i].end);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intervals[index - 1].start = Math.min(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intervals[index - 1].start, intervals[i].start);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Step 2b\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intervals[index] = intervals[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0index++;\n\u00a0\u00a0}\n\u00a0\u00a0// print the result\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0for (int i = 0; i < index; i++) {\n\u00a0\u00a0\u00a0\u00a0System.out.print(intervals[i] + \" \");\n\u00a0\u00a0}\n}\n```", "```java\npublic static int circularTour(int[] fuel, int[] dist) {\n\u00a0\u00a0int sumRemainingFuel = 0; // track current remaining fuel\n\u00a0\u00a0int totalFuel = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// track total remaining fuel\n\u00a0\u00a0int start = 0;\n\u00a0\u00a0for (int i = 0; i < fuel.length; i++) {\n\u00a0\u00a0\u00a0\u00a0int remainingFuel = fuel[i] - dist[i];\n\u00a0\u00a0\u00a0\u00a0//if sum remaining fuel of (i-1) >= 0 then continue \n\u00a0\u00a0\u00a0\u00a0if (sumRemainingFuel >= 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumRemainingFuel += remainingFuel;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//otherwise, reset start index to be current\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumRemainingFuel = remainingFuel;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0start = i;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0totalFuel += remainingFuel;\n\u00a0\u00a0}\n\u00a0\u00a0if (totalFuel >= 0) {\n\u00a0\u00a0\u00a0\u00a0return start;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n}\n```", "```java\n// start point 1\nint[] dist = {2, 4, 1};\nint[] fuel = {0, 4, 3};\n// start point 1\nint[] dist = {6, 5, 3, 5};\nint[] fuel = {4, 6, 7, 4};\n// no solution, return -1\nint[] dist = {1, 3, 3, 4, 5};\nint[] fuel = {1, 2, 3, 4, 5};\n// start point 2\nint[] dist = {4, 6, 6};\nint[] fuel = {6, 3, 7};\n```", "```java\npublic static int trap(int[] bars) {\n\u00a0\u00a0int n = bars.length - 1;\n\u00a0\u00a0int water = 0;\n\u00a0\u00a0// store the maximum height of a bar to \n\u00a0\u00a0// the left of the current bar\n\u00a0\u00a0int[] left = new int[n];\n\u00a0\u00a0left[0] = Integer.MIN_VALUE;\n\u00a0\u00a0// iterate the bars from left to right and \n\u00a0\u00a0// compute each left[i]\n\u00a0\u00a0for (int i = 1; i < n; i++) {\n\u00a0\u00a0\u00a0\u00a0left[i] = Math.max(left[i - 1], bars[i - 1]);\n\u00a0\u00a0}\n\u00a0\u00a0// store the maximum height of a bar to the \n\u00a0\u00a0// right of the current bar\n\u00a0\u00a0int right = Integer.MIN_VALUE;\n\u00a0\u00a0// iterate the bars from right to left \n\u00a0\u00a0// and compute the trapped water\n\u00a0\u00a0for (int i = n - 1; i >= 1; i--) {\n\u00a0\u00a0\u00a0\u00a0right = Math.max(right, bars[i + 1]);\n\u00a0\u00a0\u00a0\u00a0// check if it is possible to store water \n\u00a0\u00a0\u00a0\u00a0// in the current bar\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (Math.min(left[i], right) > bars[i]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0water += Math.min(left[i], right) - bars[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return water;\n}\n```", "```java\npublic static int trap(int[] bars) {\n\u00a0\u00a0// take two pointers: left and right pointing \n\u00a0\u00a0// to 0 and bars.length-1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0int left = 0;\n\u00a0\u00a0int right = bars.length - 1;\n\u00a0\u00a0int water = 0;\n\u00a0\u00a0int maxBarLeft = bars[left];\n\u00a0\u00a0int maxBarRight = bars[right];\n\u00a0\u00a0while (left < right) {\n\u00a0\u00a0\u00a0\u00a0// move left pointer to the right\n\u00a0\u00a0\u00a0\u00a0if (bars[left] <= bars[right]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxBarLeft = Math.max(maxBarLeft, bars[left]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0water += (maxBarLeft - bars[left]);\n\u00a0\u00a0\u00a0\u00a0// move right pointer to the left\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxBarRight = Math.max(maxBarRight, bars[right]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0water += (maxBarRight - bars[right]);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return water;\n}\n```", "```java\npublic static int maxProfitOneTransaction(int[] prices) {\n\u00a0\u00a0int min = prices[0];\n\u00a0\u00a0int result = 0;\n\u00a0\u00a0for (int i = 1; i < prices.length; i++) {\n\u00a0\u00a0\u00a0\u00a0result = Math.max(result, prices[i] - min);\n\u00a0\u00a0\u00a0\u00a0min = Math.min(min, prices[i]);\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static int maxProfitTwoTransactions(int[] prices) {\n\u00a0\u00a0int[] left = new int[prices.length];\n\u00a0\u00a0int[] right = new int[prices.length];\n\u00a0\u00a0// Dynamic Programming from left to right\n\u00a0\u00a0left[0] = 0;\n\u00a0\u00a0int min = prices[0];\n\u00a0\u00a0for (int i = 1; i < prices.length; i++) {\n\u00a0\u00a0\u00a0\u00a0min = Math.min(min, prices[i]);\n\u00a0\u00a0\u00a0\u00a0left[i] = Math.max(left[i - 1], prices[i] - min);\n\u00a0\u00a0}\n\u00a0\u00a0// Dynamic Programming from right to left\n\u00a0\u00a0right[prices.length - 1] = 0;\n\u00a0\u00a0int max = prices[prices.length - 1];\n\u00a0\u00a0for (int i = prices.length - 2; i >= 0; i--) {\n\u00a0\u00a0\u00a0\u00a0max = Math.max(max, prices[i]);\n\u00a0\u00a0\u00a0\u00a0right[i] = Math.max(right[i + 1], max - prices[i]);\n\u00a0\u00a0}\n\u00a0\u00a0int result = 0;\n\u00a0\u00a0for (int i = 0; i < prices.length; i++) {\n\u00a0\u00a0\u00a0\u00a0result = Math.max(result, left[i] + right[i]);\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static int maxProfitUnlimitedTransactions(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int[] prices) {\n\u00a0\u00a0int result = 0;\n\u00a0\u00a0for (int i = 1; i < prices.length; i++) {\n\u00a0\u00a0\u00a0\u00a0int diff = prices[i] - prices[i - 1];\n\u00a0\u00a0\u00a0\u00a0if (diff > 0) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result += diff;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\n    temp[p] = Math.max(result[p - 1] \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ Math.max(diff, 0), temp[p] + diff);\n    ```", "```java\nresult[p] = Math.max(temp[p], result[p]);\n```", "```java\npublic static int maxProfitKTransactions(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int[] prices, int k) {\n\u00a0\u00a0int[] temp = new int[k + 1];\n\u00a0\u00a0int[] result = new int[k + 1];\n\u00a0\u00a0for (int q = 0; q < prices.length - 1; q++) {\n\u00a0\u00a0\u00a0\u00a0int diff = prices[q + 1] - prices[q];\n\u00a0\u00a0\u00a0\u00a0for (int p = k; p >= 1; p--) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp[p] = Math.max(result[p - 1] \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ Math.max(diff, 0), temp[p] + diff);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[p] = Math.max(temp[p], result[p]);\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result[k];\n}\n```", "```java\npublic static int findLongestConsecutive(int[] sequence) {\n\u00a0\u00a0// construct a set from the given sequence\n\u00a0\u00a0Set<Integer> sequenceSet = IntStream.of(sequence)\n\u00a0\u00a0\u00a0\u00a0.boxed()\n\u00a0\u00a0\u00a0\u00a0.collect(Collectors.toSet());\n\u00a0\u00a0int longestSequence = 1;\n\u00a0\u00a0for (int elem : sequence) {\n\u00a0\u00a0\u00a0\u00a0// if 'elem-1' is not in the set then \u00a0\u00a0\u00a0\u00a0// start a new sequence\n\u00a0\u00a0\u00a0\u00a0if (!sequenceSet.contains(elem - 1)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int sequenceLength = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// lookup in the set for elements \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// 'elem + 1', 'elem + 2', 'elem + 3' ...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (sequenceSet.contains(elem + sequenceLength)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sequenceLength++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// update the longest consecutive subsequence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0longestSequence = Math.max(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0longestSequence, sequenceLength);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return longestSequence;\n}\n```", "```java\npublic static int count(int n) {\n\u00a0\u00a0int[] table = new int[n + 1];\n\u00a0\u00a0table[0] = 1;\n\u00a0\u00a0for (int i = 3; i <= n; i++) {\n\u00a0\u00a0\u00a0\u00a0table[i] += table[i - 3];\n\u00a0\u00a0}\n\u00a0\u00a0for (int i = 5; i <= n; i++) {\n\u00a0\u00a0\u00a0\u00a0table[i] += table[i - 5];\n\u00a0\u00a0}\n\u00a0\u00a0for (int i = 10; i <= n; i++) {\n\u00a0\u00a0\u00a0\u00a0table[i] += table[i - 10];\n\u00a0\u00a0}\n\u00a0\u00a0return table[n];\n}\n```", "```java\npublic static boolean checkDuplicates(int[] arr) {\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = i + 1; j < arr.length; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] == arr[j]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static boolean checkDuplicates(int[] arr) {\n\u00a0\u00a0java.util.Arrays.sort(arr);\n\u00a0\u00a0int prev = arr[0];\n\u00a0\u00a0for (int i = 1; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[i] == prev) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0prev = arr[i];\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static boolean checkDuplicates(int[] arr) {\n\u00a0\u00a0Set<Integer> set = new HashSet<>();\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (set.contains(arr[i])) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0set.add(arr[i]);\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static boolean checkDuplicates(int[] arr) {\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[Math.abs(arr[i])] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[Math.abs(arr[i])] = -arr[Math.abs(arr[i])];\n\u00a0\u00a0\u00a0\u00a0} else if (arr[Math.abs(arr[i])] == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[Math.abs(arr[i])] = -(arr.length-1);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```"]