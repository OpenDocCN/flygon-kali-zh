- en: Chapter 10. Rendering Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。渲染编程
- en: The CryENGINE renderer is most likely the most well-known part of the engine,
    providing highly complex graphical features with great performance on platforms
    such as PC, Xbox 360, and PlayStation 3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE渲染器很可能是引擎中最著名的部分，为PC、Xbox 360和PlayStation 3等平台提供高度复杂的图形功能和出色的性能。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning the basic workings of the renderer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习渲染器的基本工作原理
- en: Seeing how each frame is rendered to the world
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解每一帧如何渲染到世界中
- en: Learning the basics of shader authoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习着色器编写的基础知识
- en: Learning how it's possible to modify static objects at runtime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在运行时修改静态对象
- en: Modifying a material at runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时修改材质
- en: The renderer details
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染器细节
- en: The CryENGINE renderer is a modular system that allows the drawing of complex
    scenes, the handling of shaders, and more.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE渲染器是一个模块化系统，允许绘制复杂的场景，处理着色器等。
- en: 'In order to facilitate different platform architectures, there exist multiple
    renderers for CryENGINE, all implementing the **IRenderer** interface. We have
    listed a selection as shown:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便不同的平台架构，CryENGINE存在多个渲染器，都实现了**IRenderer**接口。我们列出了一些选择，如下所示：
- en: 'DirectX: Used on Windows and Xbox'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectX：用于Windows和Xbox
- en: 'PSGL: Used on PlayStation 3'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSGL：用于PlayStation 3
- en: There is also most likely an **OpenGL** renderer in development, for use on
    platforms such as Linux and Mac OS X.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能也正在开发**OpenGL**渲染器，用于Linux和Mac OS X等平台。
- en: Shaders
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器
- en: Shaders in CryENGINE are written using a specialized language based on HLSL,
    called CryFX. The system is very similar to HLSL, but is specialized for core
    engine functionality such as material and shader parameters, `#include` macros,
    and more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE中的着色器是使用基于HLSL的专门语言CryFX编写的。该系统与HLSL非常相似，但专门用于核心引擎功能，如材质和着色器参数，`#include`宏等。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that shader authoring was not enabled in the Free SDK at the time this
    book was written; however, this might change in the future.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本书撰写时，Free SDK中未启用着色器编写；但这在未来可能会改变。
- en: Shader permutations
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器排列组合
- en: Each time a material alters a shader generation parameter, a permutation of
    the base shader will be created. The engine also exposes functionality for exposing
    engine variables to shaders, to disable or tweak effects at runtime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当材质改变着色器生成参数时，基本着色器的一个排列组合将被创建。引擎还公开了将引擎变量暴露给着色器的功能，以便在运行时禁用或调整效果。
- en: This is possible due to the CryFX language allowing the `#ifdef`, `#endif`,
    and `#include` blocks, allowing the engine to strip certain parts of the shader
    code out at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于CryFX语言允许`#ifdef`、`#endif`和`#include`块，允许引擎在运行时剥离着色器代码的某些部分。
- en: '![Shader permutations](img/5909_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![着色器排列组合](img/5909_10_01.jpg)'
- en: Shader cache
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器缓存
- en: Since compiling shaders at runtime is not viable on all platforms, CryENGINE
    provides the shader caching system. This allows for the storage of a collection
    of precompiled shaders, sparing quite a bit of work for the end-user's device.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在运行时编译着色器在所有平台上都不可行，CryENGINE提供了着色器缓存系统。这允许存储一系列预编译的着色器，为最终用户的设备节省了相当多的工作。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned in the previous section, shaders can contain a huge amount of variations
    of themselves. Therefore, it is necessary to make sure that all required permutations
    have been compiled when setting up the cache.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，着色器可以包含大量的变体。因此，在设置缓存时，有必要确保所有所需的排列组合都已经编译。
- en: PAK files
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PAK文件
- en: The renderer can load four `.pak` files from the `Engine` folder, containing
    shader definitions, source files, and more.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器可以从`Engine`文件夹加载四个`.pak`文件，包含着色器定义、源文件等。
- en: '| Archive name | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 存档名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Shaders.pak` | Contains shader source files and `.ext` (definition) files.
    Shader source is commonly excluded from this archive when using precompiled shader
    cache. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Shaders.pak` | 包含着色器源文件和`.ext`（定义）文件。在使用预编译着色器缓存时，着色器源通常被排除在此存档之外。'
- en: '| `ShadersBin.pak` | Contains binary parsed information of the shader source
    code. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `ShadersBin.pak` | 包含着色器源代码的二进制解析信息。'
- en: '| `ShaderCache.pak` | Contains all compiled shaders; used only when the shader
    cannot be found in the current level''s shader cache. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `ShaderCache.pak` | 包含所有已编译的着色器；仅在当前级别的着色器缓存中找不到着色器时使用。'
- en: '| `ShaderCacheStartup.pak` | Loaded during startup to speed up boot times;
    should only contain shaders that are required for the main menu. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ShaderCacheStartup.pak` | 在启动时加载以加快启动时间；应该只包含主菜单所需的着色器。'
- en: Render nodes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染节点
- en: The **IRenderNode** interface is provided in order to provide the Cry3DEngine
    system with a way to manage objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供**IRenderNode**接口，以便为Cry3DEngine系统提供管理对象的方法。
- en: This allows for generating object visibility hierarchies (allowing an easy method
    of culling objects that are not currently seen) and rendering of the object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许生成对象可见性层次结构（允许轻松地剔除当前未见的对象）和对象的渲染。
- en: Rendering breakdown
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染分解
- en: 'The rendering of games is divided into two steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的渲染分为两个步骤：
- en: Pre update
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预更新
- en: Post update
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后更新
- en: Pre update
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预更新
- en: The initial step in rendering each frame to the scene occurs in the `IGameFramework::PreUpdat`e
    function. Pre update is responsible for updating most game systems (such as flowgraph,
    view system, and more) and makes the initial call to `ISystem::RenderBegin`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染每一帧到场景的初始步骤发生在`IGameFramework::PreUpdate`函数中。预更新负责更新大多数游戏系统（如流程图、视图系统等），并首次调用`ISystem::RenderBegin`。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`PreUpdate` is most commonly called from `CGame::Update`, in the stock `CryGame.dll`.
    Always keep in mind that this process only applies to the Launcher application;
    the Editor handles game updates and rendering uniquely.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreUpdate`最常从`CGame::Update`中调用，在原始的`CryGame.dll`中。请记住，这个过程只适用于启动器应用程序；编辑器处理游戏更新和渲染的方式是独特的。'
- en: RenderBegin signals the start of a new frame, and tells the renderer to set
    the new frame ID, clear buffers, and more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: RenderBegin表示新帧的开始，并告诉渲染器设置新的帧ID，清除缓冲区等。
- en: Post update
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新后
- en: After updating the game systems, it's time to render the scene. This initial
    step is done via the `IGameFramework::PostUpdate` function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更新游戏系统后，是时候渲染场景了。这一初始步骤通过`IGameFramework::PostUpdate`函数完成。
- en: Prior to rendering, systems that are crucial to the new information retrieved
    from the game update done within and after `PreUpdate` must be updated. This includes
    flash UI, animation synching, and more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染之前，必须更新对游戏更新中和之后从新信息中检索到的关键系统。这包括闪烁UI、动画同步等。
- en: After that is done, `PostUpdate` will call `ISystem::Render`, which in turn
    renders the world using the `I3DEngine::RenderWorld` function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`PostUpdate`将调用`ISystem::Render`，然后使用`I3DEngine::RenderWorld`函数渲染世界。
- en: After rendering the world, the system will call functions such as `IFlashUI::Update`,
    and `PostUpdate` on all game objects, and more, finally ending in a call to `ISystem::RenderEnd`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染世界后，系统将调用诸如`IFlashUI::Update`和`PostUpdate`等函数，最终以调用`ISystem::RenderEnd`结束。
- en: '![Post update](img/5909_10_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![更新后](img/5909_10_02.jpg)'
- en: Rendering new viewports using render contexts
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用渲染上下文渲染新视口
- en: Render contexts are in essence wrappers for native window handles. On Windows,
    this allows you to specify a **HWND**, and then have the renderer draw directly
    to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染上下文本质上是本机窗口句柄的包装器。在Windows上，这允许您指定一个**HWND**，然后让渲染器直接绘制到它上面。
- en: The very nature of render contexts is platform-specific, and is, therefore,
    not guaranteed to work the same from one rendering module (such as, D3D) to another
    (such as, OpenGL).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染上下文的本质是特定于平台的，因此不能保证在一个渲染模块（如D3D）到另一个渲染模块（如OpenGL）之间的工作方式相同。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Render contexts are currently only supported while running in Editor
    mode on Windows, which is used for rendering viewports in tool windows.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：渲染上下文目前仅在Windows的编辑器模式下受支持，用于在工具窗口中渲染视口。
- en: In order to create a new context with your window handle, call `IRenderer::CreateContext`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用您的窗口句柄创建新的上下文，请调用`IRenderer::CreateContext`。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that contexts are automatically enabled on creation; call `IRenderer::MakeMainContextActive`
    to re-enable the main view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上下文在创建时会自动启用；调用`IRenderer::MakeMainContextActive`来重新启用主视图。
- en: Rendering
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染
- en: When rendering a context, the first thing you need to do is activate it. This
    can be done by using `IRenderer::SetCurrentContext`. Once enabled, the renderer
    is aware of the window that it should be passing to DirectX.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染上下文时，你需要做的第一件事是激活它。这可以通过使用`IRenderer::SetCurrentContext`来完成。一旦启用，渲染器就会意识到应该传递给DirectX的窗口。
- en: The next thing you need to do is update the resolution of the context by using
    `IRenderer::ChangeViewport`. This instructs the renderer about the position and
    size of the area it should render.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要做的是使用`IRenderer::ChangeViewport`来更新上下文的分辨率。这指示渲染器关于应该渲染的区域的位置和大小。
- en: After doing so, simply call the typical render functions such as `IRenderer::BeginFrame`
    (see the *Rendering breakdown* section), and then finish by making the main context
    active at the end, via `IRenderer::MakeMainContextActive`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，只需调用典型的渲染函数，如`IRenderer::BeginFrame`（参见*渲染分解*部分），最后通过`IRenderer::MakeMainContextActive`使主上下文在最后处于活动状态。
- en: Using the I3DEngine::RenderWorld function
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用I3DEngine::RenderWorld函数
- en: In some cases it might make sense to call `I3DEngine::RenderWorld` manually
    instead of relying on the game framework's update process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，手动调用`I3DEngine::RenderWorld`而不是依赖游戏框架的更新过程可能是有意义的。
- en: 'To do so, we''ll need to change the process a bit. To start, call `IRenderer::SetCurrentContext`
    followed by `IRenderer::MakeMainContextActive` as shown:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要稍微改变流程。首先，调用`IRenderer::SetCurrentContext`，然后调用`IRenderer::MakeMainContextActive`如下所示：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Good, now our context will be activated. But in order to actually render, we''ll
    need to fill up the void between. To start, we have to call `IRenderer::ChangeViewport`
    directly after `SetCurrentContext` as shown:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在我们的上下文将被激活。但为了实际渲染，我们需要填补之间的空白。首先，我们必须在`SetCurrentContext`之后直接调用`IRenderer::ChangeViewport`如下所示：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This sets the viewport to the coordinates of `0`, `0`, and our specified `width`
    and `height` variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将视口设置为`0`、`0`的坐标和我们指定的`width`和`height`变量。
- en: 'After setting the viewport size, you''ll want to configure your camera to the
    new resolution and call `IRenderer::SetCamera` as shown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设置视口大小后，您将需要根据新的分辨率配置您的摄像机，并调用`IRenderer::SetCamera`如下所示：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Great! The renderer is now aware of which camera it should use for rendering.
    We''ll also need to supply this to `I3DEngine::RenderWorld` later on. But first
    we have to clear the buffers in order to remove the previous frame with the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！渲染器现在知道应该使用哪个摄像机进行渲染。我们还需要在稍后提供给`I3DEngine::RenderWorld`。但首先我们必须清除缓冲区，以删除之前的帧，使用以下代码：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is then followed by calling `IRenderer::RenderBegin` to indicate that
    it''s time to start rendering:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`IRenderer::RenderBegin`来指示开始渲染：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now all we have to do is render the scene between the `SetViewCamera` and `RenderEnd`
    calls:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是在`SetViewCamera`和`RenderEnd`调用之间渲染场景：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Done! The world is now rendered based on our camera setup, and should be visible
    to you in the window set via `IRenderer::SetCurrentContext`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！世界现在根据我们的摄像机设置进行渲染，并应该在通过`IRenderer::SetCurrentContext`设置的窗口中可见。
- en: I3DEngine::RenderWorld flags
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: I3DEngine::RenderWorld标志
- en: 'The render flags determine how the world should be drawn. For example, we could
    exclude `SHDF_ALLOW_WATER` to completely avoid rendering water. The following
    table lists the available flags and their function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染标志确定如何绘制世界。例如，我们可以排除`SHDF_ALLOW_WATER`来完全避免渲染水。下表列出了可用标志及其功能：
- en: '| Flag name | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 标志名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SHDF_ALLOWHDR` | If not set, HDR will not be used. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `SHDF_ALLOWHDR` | 如果未设置，将不使用HDR。 |'
- en: '| `SHDF_ZPASS` | Allows the Z-Pass. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `SHDF_ZPASS` | 允许Z-Pass。 |'
- en: '| `SHDF_ZPASS_ONLY` | Allows the Z-Pass, and no other passes. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_ZPASS_ONLY` | 允许Z-Pass，而不允许其他通道。'
- en: '| `SHDF_DO_NOT_CLEAR_Z_BUFFER` | If set, the Z-buffer will never be cleared.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_DO_NOT_CLEAR_Z_BUFFER` | 如果设置，Z缓冲区将永远不会被清除。'
- en: '| `SHDF_ALLOWPOSTPROCESS` | If not set, all post-process effects will be ignored.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_ALLOWPOSTPROCESS` | 如果未设置，所有后期处理效果将被忽略。'
- en: '| `SHDF_ALLOW_AO` | If set, **Ambient Occlusion** will be used. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_ALLOW_AO` | 如果设置，将使用**环境光遮蔽**。'
- en: '| `SHDF_ALLOW_WATER` | If not set, all water will be ignored and not rendered.
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_ALLOW_WATER` | 如果未设置，所有水体将被忽略并且不会渲染。'
- en: '| `SHDF_NOASYNC` | No asynchronous drawing. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_NOASYNC` | 无异步绘制。'
- en: '| `SHDF_NO_DRAWNEAR` | Excludes all rendering in the near plane. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_NO_DRAWNEAR` | 排除所有在近平面的渲染。 |'
- en: '| `SHDF_STREAM_SYNC` | Enables synchronized texture streaming. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_STREAM_SYNC` | 启用同步纹理流式传输。'
- en: '| `SHDF_NO_DRAWCAUSTICS` | If set, no water caustics will be drawn. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '`SHDF_NO_DRAWCAUSTICS` | 如果设置，将不绘制水光。'
- en: Shaders
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: Creating a custom shader in CryENGINE is relatively easy, and can be done simply
    by copying an existing shader (`.cfx`) and its extension file (`.ext`). For the
    sake of this example, copy `Illum.ext` from `Engine/Shaders` and name it `MyShader.ext`.
    Then copy `Engine/Shaders/HWScripts/CryFX/Illum.cfx` and rename it to `MyShader.cfx`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在CryENGINE中创建自定义着色器相对容易，只需通过复制现有着色器（`.cfx`）及其扩展文件（`.ext`）即可完成。举例来说，从`Engine/Shaders`复制`Illum.ext`并命名为`MyShader.ext`。然后复制`Engine/Shaders/HWScripts/CryFX/Illum.cfx`并将其重命名为`MyShader.cfx`。
- en: Note that creating custom shaders should be thought out properly; if it is possible
    to simply use an existing shader, that would be the best option. This is due to
    the fact that CryENGINE is already reaching the viable limit of the number of
    shader permutations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建自定义着色器应该经过深思熟虑；如果可能的话，最好使用现有的着色器。这是因为CryENGINE已经接近着色器排列的可行极限。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As stated earlier in the chapter, custom shader authoring was not enabled in
    the CryENGINE Free SDK at the time this book was written.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面所述，本书撰写时，CryENGINE Free SDK中未启用自定义着色器编写。
- en: The shader description
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器描述
- en: 'Each shader needs to define a description, which sets its options. Options
    are set in the global `Script` variable, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个着色器都需要定义一个描述，以设置其选项。选项设置在全局`Script`变量中，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Texture slots
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理插槽
- en: 'Each material can specify the file path to a texture in a set of texture slots
    as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个材质可以在一组纹理插槽中指定纹理的文件路径，如下所示：
- en: '![Texture slots](img/5909_10_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![纹理插槽](img/5909_10_03.jpg)'
- en: We can access these texture slots via shaders by using a set of helpers (as
    follows), which can then be added to custom samplers that can then be loaded by
    using the `GetTexture2D` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一组助手（如下所示）在着色器中访问这些纹理插槽，然后将其添加到自定义采样器中，然后可以使用`GetTexture2D`函数加载它们。
- en: '| Slot name | Helper name |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: 插槽名称 | 助手名称 |
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Diffuse | $Diffuse |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: 扩散 | $扩散 |
- en: '| Gloss (Specular) | $Gloss |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: 光泽（高光） | $光泽 |
- en: '| Bump |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: 凹凸 |   |
- en: '| Bump heightmap | $BumpHeight |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: 凹凸高度图 | $凹凸高度 |
- en: '| Environment | $Env |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: 环境 | $环境 |
- en: '| Environment Cubemap | $EnvironmentCubeMap |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: 环境立方体贴图 | $环境立方体贴图 |
- en: '| Detail | $Detail |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: 细节 | $细节 |
- en: '| Opacity | $Opacity |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: 不透明度 | $不透明度 |
- en: '| Decal | $DecalOverlay |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: 贴花 | $贴花叠加 |
- en: '| Subsurface | $Subsurface |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: 次表面 | $次表面 |
- en: '| Custom | $CustomMap |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: 自定义 | $自定义贴图 |
- en: '| Custom Secondary | $CustomSecondaryMap |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: 自定义次要 | $自定义次要贴图 |
- en: Shader flags
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器标志
- en: By using the `#ifdef` and `#endif` preprocessor commands, it is possible to
    define areas of the code that can be removed prior to compilation or at runtime.
    This allows for the usage of a single übershader with multiple toggleable subeffects,
    such as Illum.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`#ifdef`和`#endif`预处理器命令，可以定义在编译或运行时可以删除的代码区域。这允许使用单个超级着色器具有多个可切换的子效果，如Illum。
- en: 'For example, we could check whether the user is running DX11 as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过以下方式检查用户是否正在运行DX11：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Material flags
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材质标志
- en: Material flags are set via **Material Editor**, allowing each material to use
    different effects, such as Parallax Occlusion Mapping and Tessellation. The material
    flags are evaluated at compile time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 材质标志是通过**材质编辑器**设置的，允许每个材质使用不同的效果，如视差遮挡映射和镶嵌。材质标志在编译时进行评估。
- en: 'To create a new material flag, open your shader''s `.ext` file and create a
    new property with the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的材质标志，请打开您的着色器的`.ext`文件，并使用以下代码创建一个新的属性：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now when you restart the editor, your property should appear in the Material
    Editor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您重新启动编辑器时，您的属性应该出现在材质编辑器中。
- en: 'The following is a list of possible property data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的属性数据列表：
- en: '| Property data | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: 属性数据 | 描述 |
- en: '| --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name | Defines the internal name of the property, and is what you should
    check for by using the `#ifdef` block. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: 名称 | 定义属性的内部名称，并且是您应该通过使用`#ifdef`块进行检查的名称。
- en: '| Mask | Unique mask used to identify your property. Should not conflict with
    that of other properties in your shader definition (`.ext`). |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: 掩码 | 用于识别您的属性的唯一掩码。不应与着色器定义（`.ext`）中其他属性的掩码冲突。
- en: '| Property | The public name of the property, displayed in the material editor.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: 属性 | 属性的公共名称，在材质编辑器中显示。
- en: '| Description | Public description for the property, shown when hovering over
    the property in the material editor. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: 描述 | 在材质编辑器中悬停在属性上时显示的公共描述。
- en: '| DependencySet | When the user modifies the value of the texture slot this
    property is set to, the material flag will be activated.This is most commonly
    used in combination with the Hidden flag. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: 依赖设置 | 当用户修改纹理插槽的值时，该属性被设置，材质标志将被激活。这在与隐藏标志结合使用时最常见。
- en: '| DependencyReset | When the user modifies the value of the texture slot this
    property is set to, the material flag will be cleared.Used to avoid conflicts
    with other material flags. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: 依赖重置 | 当用户修改纹理插槽的值时，将清除该属性。用于避免与其他材质标志冲突。
- en: '| Hidden | If set, the property will not be visible in the editor. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|隐藏|如果设置，属性将在编辑器中不可见。|'
- en: Engine flags
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引擎标志
- en: Engine flags are directly set by the engine, and contain information such as
    the currently supported shader model or the platform on which the engine is currently
    running.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎标志由引擎直接设置，并包含诸如当前支持的着色器模型或引擎当前运行的平台等信息。
- en: Runtime flags
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时标志
- en: Runtime flags are defined by the `%_RT_` prefix, and can be set or unset by
    the engine at runtime. All available flags can be viewed in the `RunTime.ext`
    file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时标志由`%_RT_`前缀定义，并且可以由引擎在运行时设置或取消设置。所有可用标志都可以在`RunTime.ext`文件中查看。
- en: Samplers
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样器
- en: A sampler is a representation of a single texture of a specific texture type.
    By creating custom samplers, we can refer to specific textures from within the
    shader, for example, to load a texture containing pre-generated noise.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器是特定纹理类型的单个纹理的表示。通过创建自定义采样器，我们可以在着色器内引用特定纹理，例如加载包含预生成噪音的纹理。
- en: 'An example for a pre-loaded sampler is as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载采样器的一个示例如下所示：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can now refer to `mySampler` in our code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的代码中引用`mySampler`。
- en: Using texture slots with samplers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用采样器的纹理槽
- en: In some cases, it's preferred to have your sampler point to one of the texture
    slots defined in the material.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，最好让采样器指向材质中定义的纹理槽之一。
- en: 'To do so, simply replace the path of your texture with the name of your preferred
    texture slot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，只需用您首选的纹理槽的名称替换纹理的路径：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When loaded, the texture will then be that which the material specified in the
    Diffuse slot.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，纹理将是材质在漫反射槽中指定的纹理。
- en: Obtaining a texture
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取纹理
- en: 'Now that we have a texture, we can learn how to get texture data in a shader.
    This is done by using the `GetTexture2D` function as shown:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个纹理，我们可以学习如何在着色器中获取纹理数据。这是通过使用`GetTexture2D`函数来完成的，如下所示：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first parameter specifies which sampler to use (in our case, the sampler
    we created previously), while the second specifies the texture coordinates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定要使用的采样器（在我们的情况下，我们之前创建的采样器），而第二个参数指定纹理坐标。
- en: Manipulating static objects at runtime
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时操作静态对象
- en: In this section we are going to learn how to modify a static mesh at runtime,
    allowing for the manipulation of render and physical meshes during gameplay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何在运行时修改静态网格，从而允许在游戏过程中操纵渲染和物理网格。
- en: 'To do this, firstly we need to obtain the `IStatObj` instance of our object.
    For example, if you''re modifying an entity, you can use `IEntity::GetStatObj`
    as shown:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们需要获取我们对象的`IStatObj`实例。例如，如果您正在修改一个实体，您可以使用`IEntity::GetStatObj`，如下所示：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we passed `0` as the first parameter to `IEntity::GetStatObj`. This
    is done in order to get the object with the highest **Level of Detail** (**LOD**).
    This means that changes made to this static object will not be reflected in its
    other LODs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`0`作为第一个参数传递给`IEntity::GetStatObj`。这样做是为了获取具有最高**细节级别**（**LOD**）的对象。这意味着对这个静态对象所做的更改不会反映在其其他LOD中。
- en: You now have a pointer to an interface holding the static object data for your
    model.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个指向保存模型静态对象数据的接口的指针。
- en: 'We can now call `IStatObj::GetIndexedMesh` or `IStatObj::GetRenderMesh`. The
    latter is most likely the best place to start, as it is constructed from the optimized
    indexed mesh data as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用`IStatObj::GetIndexedMesh`或`IStatObj::GetRenderMesh`。后者很可能是最好的起点，因为它是从优化的索引网格数据构建的，如下所示：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now have access to the `meshdesc` variable containing information about the
    mesh.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问包含有关网格信息的`meshdesc`变量。
- en: Note that we need to call `IStatObj::UpdateVertices` in order to carry over
    the changes we have made to the mesh.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要调用`IStatObj::UpdateVertices`以传递我们对网格所做的更改。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that changing a static object will carry over the changes to all of
    the objects using it. Use the `IStatObj::Clone` method to create a copy of it
    prior to editing, allowing you to manipulate only one object in the scene.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，更改静态对象将传递更改到使用它的所有对象。在编辑之前使用`IStatObj::Clone`方法创建其副本，从而允许您只操纵场景中的一个对象。
- en: Modifying materials at runtime
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时修改材质
- en: In this section we're going to modify a material at runtime.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在运行时修改材质。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to `IStatObj`, we can also clone our material to avoid making changes
    to all of the objects using it currently. To do so, call `IMaterialManager::CloneMaterial`,
    which is accessible via `gEnv->p3DEngine->GetMaterialManager()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与`IStatObj`类似，我们还可以克隆我们的材质，以避免对当前使用它的所有对象进行更改。为此，请调用`IMaterialManager::CloneMaterial`，可通过`gEnv->p3DEngine->GetMaterialManager()`访问。
- en: 'The first thing we need to do is obtain an instance of the material we want
    to edit. If we have an entity nearby, we can use `IEntity::GetMaterial` as shown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取我们想要编辑的材质的实例。如果附近有一个实体，我们可以使用`IEntity::GetMaterial`，如下所示：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `IEntity::GetMaterial` returns null if no custom material has been
    set. If this is the case, you might want to rely on a function such as `IStatObj::GetMaterial`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有设置自定义材质，`IEntity::GetMaterial`将返回null。如果是这种情况，您可能希望依赖于诸如`IStatObj::GetMaterial`之类的函数。
- en: Cloning a material
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆材质
- en: Note that `IMaterial` instances can be used for multiple objects. This means
    that modifying an object's parameters can result in changes on objects other than
    that you retrieved the object from.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IMaterial`实例可以用于多个对象。这意味着修改对象的参数可能会导致检索对象之外的对象发生变化。
- en: 'To resolve this, we can simply clone the material before modifying it via the
    `IMaterialManager::Clone` method as shown:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以简单地在通过`IMaterialManager::Clone`方法修改之前克隆材质，如下所示：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we just have to apply the clone to the entity we retrieved the original
    instance from:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需将克隆应用于我们检索到原始实例的实体：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can now move on to modifying the material's parameters, or parameters related
    to the shader that was assigned to it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续修改材质的参数，或者与其分配的着色器相关的参数。
- en: Material parameters
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料参数
- en: 'Modifying the parameters of our material can be useful at times. This allows
    us to tweak per-material properties such as **Opacity**, **AlphaTest**, and **Diffuse
    Color** as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下修改我们材料的参数是很有用的。这使我们能够调整每种材料的属性，比如**不透明度**、**Alpha测试**和**漫反射颜色**，如下截图所示：
- en: '![Material parameters](img/5909_10_04.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![材料参数](img/5909_10_04.jpg)'
- en: To set or get material parameters, use `IMaterial::SetGetMaterialParamFloat`
    or `IMaterial::SetGetMaterialVec3`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置或获取材料参数，请使用`IMaterial::SetGetMaterialParamFloat`或`IMaterial::SetGetMaterialVec3`。
- en: 'For example, to see the alpha of our material, use the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看我们材料的alpha值，使用以下代码：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The material should now draw alpha at half strength.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 材料现在应该以半强度绘制alpha。
- en: 'The following is a list of available parameters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用参数的列表：
- en: '| Parameter name | Type |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 参数名称 | 类型 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"alpha"` | `float` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `"alpha"` | `浮点数` |'
- en: '| `"opacity"` | `float` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `"不透明度"` | `浮点数` |'
- en: '| `"glow"` | `float` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `"发光"` | `浮点数` |'
- en: '| `"shininess"` | `float` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `"光泽度"` | `浮点数` |'
- en: '| `"diffuse"` | `Vec3` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `"漫反射"` | `Vec3` |'
- en: '| `"emissive"` | `Vec3` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `"发光"` | `Vec3` |'
- en: '| `"specular"` | `Vec3` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `"高光"` | `Vec3` |'
- en: Shader parameters
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器参数
- en: As we learned earlier, each shader can expose a set of parameters that allow
    the material to tweak the behavior of the shader without affecting the shader
    globally.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，每个着色器都可以公开一组参数，允许材料调整着色器的行为，而不会影响全局着色器。
- en: '![Shader parameters](img/5909_10_05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![着色器参数](img/5909_10_05.jpg)'
- en: 'To modify the shader parameters of our material, we''ll first need to obtain
    the shader item linked to this material:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改我们材料的着色器参数，我们首先需要获取与该材料关联的着色器项目：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the shader item, we can access `IRenderShaderResources::GetParameters`
    with the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了着色器项目，我们可以使用以下代码访问`IRenderShaderResources::GetParameters`：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now modify the parameters contained within and call `IRenderShaderResources::SetShaderParams`
    as shown:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改其中包含的参数，并调用`IRenderShaderResources::SetShaderParams`，如下所示：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example – Dynamic alpha-test for vegetation
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例-植被动态Alpha测试
- en: Now let's put your knowledge to the test!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测试一下您的知识！
- en: We have included a tree set up for use of the alpha test property with the sample
    (as shown in the following screenshot). When alpha test is increased, leaf loss
    is simulated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个树的设置，用于使用alpha测试属性与示例（如下截图所示）。当增加alpha测试时，模拟叶子掉落。
- en: '![Example – Dynamic alpha-test for vegetation](img/5909_10_06.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![示例-植被动态Alpha测试](img/5909_10_06.jpg)'
- en: To show this off, we're going to write a little snippet of code that modifies
    this at runtime.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点，我们将编写一小段代码，在运行时修改这些参数。
- en: Start by creating a new class, called `CTreeOfTime`. Either create a new game
    object extension, or derive one from the sample that we created in [Chapter 3](ch03.html
    "Chapter 3. Creating and Utilizing Custom Entities"), *Creating and Utilizing
    Custom Entities*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为`CTreeOfTime`的新类。要么创建一个新的游戏对象扩展，要么从我们在[第3章](ch03.html "第3章。创建和使用自定义实体")中创建的示例中派生一个。
- en: 'Once created, we''ll need to load our tree object on entity spawn as shown:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们需要在实体生成时加载我们的树对象，如下所示：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our entity should now load the `Objects/nature/trees/ash/tree_ash_01.cgf` object
    into its first slot (Index 0) when it is spawned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体现在应该在生成时将`Objects/nature/trees/ash/tree_ash_01.cgf`对象加载到其第一个槽（索引0）中。
- en: 'Next, we''ll need to override the entities `Update` method in order to update
    the alpha-test property based on the current time of day. When you''re done, add
    the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重写实体的`Update`方法，以便根据当前时间更新alpha测试属性。完成后，添加以下代码：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should now have a time cycle during which your tree loses and regains its
    leaves. This is one of the many techniques that are possible by modifying materials
    at runtime.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个时间周期，在这个周期内，您的树会失去并重新长出叶子。这是通过在运行时修改材料可能实现的众多技术之一。
- en: '![Example – Dynamic alpha-test for vegetation](img/5909_10_07.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![示例-植被动态Alpha测试](img/5909_10_07.jpg)'
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how shaders are used by the engine, and have
    broken down the rendering process. You should now be aware of how you can use
    render contexts, manipulate static objects at runtime, and modify materials progammatically.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习了引擎如何使用着色器，并且已经分解了渲染过程。您现在应该知道如何使用渲染上下文，在运行时操纵静态对象，并以编程方式修改材料。
- en: If you aren't ready to move on to the next chapter on effects and sound just
    yet, why not take on a challenge? For example, you could create a custom object
    that is deformed when attacked.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有准备好继续下一章关于特效和声音的内容，为什么不接受一个挑战呢？例如，您可以创建一个在受到攻击时变形的自定义对象。
