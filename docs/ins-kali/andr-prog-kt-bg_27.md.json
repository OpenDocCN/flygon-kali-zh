["```kt\ncreate table StudentsAndGrades \n   _ID integer primary key autoincrement not null,\n   name text not null,\n score int;\n```", "```kt\nINSERT INTO StudentsAndGrades\n   (name, score)\n   VALUES\n   (\"Bart\", 23);\n```", "```kt\nINSERT INTO StudentsAndGrades\n   (name, score)\n   VALUES\n   (\"Lisa\", 100);\n```", "```kt\nSELECT * FROM StudentsAndGrades;\n\n```", "```kt\nSELECT score FROM StudentsAndGrades\n where name = \"Lisa\";\n\n```", "```kt\nALTER TABLE StudentsAndGrades\n            ADD \n     age int;\n```", "```kt\ncompanion object {\n   /*\n   Next, we have a const string for\n   each row/table that we need to refer to both\n   inside and outside this class\n   */\n\n   const val DB_NAME = \"MyCollegeDB\";\n   const val TABLE_S_AND_G = \"StudentsAndGrades\";\n\n   const val TABLE_ROW_ID = \"_id\";\n   const val TABLE_ROW_NAME = \"name\";\n   const val TABLE_ROW_SCORE = \"score\";\n\n}\n```", "```kt\nval name = \"Smit\";\nval score = 95;\n\n// Add all the details to the table\nval query = \"INSERT INTO \" + TABLE_S_AND_G + \" (\" +\n         TABLE_ROW_NAME + \", \" +\n         TABLE_ROW_SCORE +\n         \") \" +\n         \"VALUES (\" +\n         \"'\" + name + \"'\" + \", \" +\n         score +\n         \");\"\n```", "```kt\nINSERT INTO StudentsAndGrades (\n   name, score)\n   VALUES ('Smit',95);\n```", "```kt\n// This is the actual database\nprivate val db: SQLiteDatabase\n\n// Create an instance of our internal CustomSQLiteOpenHelper class\nval helper = CustomSQLiteOpenHelper(context)\n\n// Get a writable database\ndb = helper.writableDatabase\n\n// Run the query\ndb.execSQL(query)\n```", "```kt\nCursor c = db.rawQuery(query, null)\n```", "```kt\nLog.i(c.getString(1), c.getString(2))\n```", "```kt\nc.moveToNext()\n\n/*\n   This same code now outputs the data in the\n   first and second column of the returned \n   data but from the SECOND row.\n*/\n\nLog.i(c.getString(1), c.getString(2))\n```", "```kt\nclass DataManager(context: Context) {\n\n    // This is the actual database\n    private val db: SQLiteDatabase\n\n    init {\n        // Create an instance of our internal\n        // CustomSQLiteOpenHelper class\n        val helper = CustomSQLiteOpenHelper(context)\n        // Get a writable database\n        db = helper.writableDatabase\n    }\n\n    companion object {\n        /*\n        Next, we have a const string for\n        each row/table that we need to refer to both\n        inside and outside this class\n        */\n\n        const val TABLE_ROW_ID = \"_id\"\n        const val TABLE_ROW_NAME = \"name\"\n        const val TABLE_ROW_AGE = \"age\"\n\n        /*\n        Next, we have a private const strings for\n        each row/table that we need to refer to just\n        inside this class\n        */\n\n        private const val DB_NAME = \"address_book_db\"\n        private const val DB_VERSION = 1\n        private const val TABLE_N_AND_A = \"names_and_addresses\"\n    }\n}\n```", "```kt\n// Insert a record\nfun insert(name: String, age: String) {\n  // Add all the details to the table\n  val query = \"INSERT INTO \" + TABLE_N_AND_A + \" (\" +\n               TABLE_ROW_NAME + \", \" +\n               TABLE_ROW_AGE +\n               \") \" +\n               \"VALUES (\" +\n               \"'\" + name + \"'\" + \", \" +\n               \"'\" + age + \"'\" +\n               \");\"\n\n  Log.i(\"insert() = \", query)\n\n  db.execSQL(query)\n}\n```", "```kt\n// Delete a record\nfun delete(name: String) {\n\n   // Delete the details from the table\n   // if already exists\n   val query = \"DELETE FROM \" + TABLE_N_AND_A +\n               \" WHERE \" + TABLE_ROW_NAME +\n               \" = '\" + name + \"';\"\n\n   Log.i(\"delete() = \", query)\n\n   db.execSQL(query)\n\n}\n```", "```kt\n// Get all the records\nfun selectAll(): Cursor {\n   return db.rawQuery(\"SELECT *\" + \" from \" +\n               TABLE_N_AND_A, null)\n}\n```", "```kt\n// Find a specific record\nfun searchName(name: String): Cursor {\n    val query = \"SELECT \" +\n                 TABLE_ROW_ID + \", \" +\n                 TABLE_ROW_NAME +\n                 \", \" + TABLE_ROW_AGE +\n                 \" from \" +\n                 TABLE_N_AND_A + \" WHERE \" +\n                 TABLE_ROW_NAME + \" = '\" + name + \"';\"\n\n   Log.i(\"searchName() = \", query)\n\n   return db.rawQuery(query, null)\n}\n```", "```kt\n// This class is created when \n// our DataManager class is instantiated\nprivate inner class CustomSQLiteOpenHelper(\n         context: Context)\n     : SQLiteOpenHelper(\n           context, DB_NAME,\n           null, DB_VERSION) {\n\n  // This function only runs the first\n  // time the database is created\n  override fun onCreate(db: SQLiteDatabase) {\n\n        // Create a table for photos and all their details\n        val newTableQueryString = (\"create table \"\n              + TABLE_N_AND_A + \" (\"\n              + TABLE_ROW_ID\n              + \" integer primary key autoincrement not null,\"\n              + TABLE_ROW_NAME\n              + \" text not null,\"\n              + TABLE_ROW_AGE\n              + \" text not null);\")\n\n        db.execSQL(newTableQueryString)\n  }\n\n  // This function only runs when we increment DB_VERSION\n  override fun onUpgrade(db: SQLiteDatabase,\n                     oldVersion: Int,\n                     newVersion: Int) {\n\n  }\n\n}\n```", "```kt\nval view = inflater.inflate(\n         R.layout.content_insert,\n         container,\n         false)\n\n// Database and UI code goes here in next chapter\nval dm = DataManager(activity!!)\n\nval btnInsert = view.findViewById(R.id.btnInsert) as Button\nval editName = view.findViewById(R.id.editName) as EditText\nval editAge = view.findViewById(R.id.editAge) as EditText\n\nbtnInsert.setOnClickListener(\n            {\n dm.insert(editName.text.toString(),\n editAge.text.toString())\n            }\n)\n\nreturn view\n```", "```kt\nval view = inflater.inflate(\n         R.layout.content_delete,\n         container,\n         false)\n\n// Database and UI code goes here in next chapter\nval dm = DataManager(activity!!)\n\nval btnDelete = \n view.findViewById(R.id.btnDelete) as Button\nval editDelete = \n view.findViewById(R.id.editDelete) as EditText\n\nbtnDelete.setOnClickListener(\n {\n dm.delete(editDelete.text.toString())\n }\n)\n\nreturn view\n```", "```kt\nval view = inflater.inflate(R.layout.content_search,\n         container,\n         false)\n\n// Database and UI code goes here in next chapter\nval btnSearch = view.findViewById(R.id.btnSearch) as Button\nval editSearch = view.findViewById(R.id.editSearch) as EditText\nval textResult = view.findViewById(R.id.textResult) as TextView\n\n// This is our DataManager instance\nval dm = DataManager(activity!!)\n\nbtnSearch.setOnClickListener(\n {\n val c = dm.searchName(editSearch.text.toString())\n\n // Make sure a result was found \n // before using the Cursor\n if (c.count > 0) {\n c.moveToNext()\n textResult.text =\n \"Result = ${c.getString(1)} - ${c.getString(2)}\"\n }\n }\n)\n\nreturn view\n```", "```kt\nval view = inflater.inflate(R.layout.content_results,\n         container,\n         false)\n\n// Database and UI code goes here in next chapter\n// Create an instance of our DataManager\nval dm = DataManager(activity!!)\n\n// Get a reference to the TextView \n// to show the results in\nval textResults = \n view.findViewById(R.id.textResults) as TextView\n\n// Create and initialize a Cursor \n// with all the results in\nval c = dm.selectAll()\n\n// A String to hold all the text\nvar list = \"\"\n\n// Loop through the results in the Cursor\nwhile (c.moveToNext()) {\n // Add the results to the String\n // with a little formatting\n list += c.getString(1) + \" - \" + c.getString(2) + \"\\n\"\n}\n\n// Display the String in the TextView\ntextResults.text = list\n\nreturn view\n```"]