- en: Smart Agriculture and Voice AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能农业和语音人工智能
- en: In [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee), *Smart
    Agriculture*, we have seen one of the mainstream areas in which IoT can create
    an impact; the agriculture sector. In this chapter, we are going to take that
    to a new level. Using a voice AI engine such as Amazon Alexa, we are going to
    talk to the smart weather station that we have built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee)中，*智能农业*，我们已经看到了物联网可以产生影响的主流领域之一；农业部门。在本章中，我们将把这一点提升到一个新的水平。使用亚马逊
    Alexa 等语音人工智能引擎，我们将与我们建立的智能气象站交谈。
- en: For example, a farmer can ask Alexa *`Alexa, ask smarty app the moisture level
    in my farm*, and Alexa would go *the moisture level in your farm is 20%. Consider
    watering now*. Then, the farmer would go, *Alexa, ask smarty app to turn on my
    motor* and Alexa would turn it on. Fascinating, isn't it?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个农民可以问 Alexa *“Alexa，请问smarty app我的农场的湿度水平是多少”*，然后 Alexa 会回答 *“你的农场湿度水平是20%。考虑现在浇水”*。然后，农民会说
    *“Alexa，请问smarty app打开我的发动机”*，然后 Alexa 会打开它。很迷人，不是吗？
- en: Generally, voice AI based IoT is more common in the concepts of smart home and
    smart office. I wanted to implement it with smart agriculture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基于语音人工智能的物联网在智能家居和智能办公的概念中更为常见。我想在智能农业中实现它。
- en: 'In this chapter, we are going to work on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将致力于以下工作：
- en: Understand Amazon Alexa
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解亚马逊 Alexa
- en: Build an IoT.js controlled water motor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个由 IoT.js 控制的水泵
- en: Understand AWS lambda
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 AWS lambda
- en: Develop a skillset for Amazon Alexa
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为亚马逊 Alexa 开发技能
- en: Test the weather station as well as the water motor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试气象站以及水泵
- en: Voice AI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音人工智能
- en: There was a time when turning something on/off using a smart phone was exciting.
    Times have changed and things have evolved quite a bit since in the space of voice
    AI. A lot of people use their voice to do a lot of things, right from making notes,
    building their grocery lists, to searching the internet. We no longer use hands
    for mundane activities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，用智能手机打开/关闭某物是令人兴奋的。时代已经改变，语音人工智能的发展已经有了很大的进步。很多人用他们的声音做很多事情，从做笔记、建立购物清单到搜索互联网。我们不再用手做琐碎的活动。
- en: '"Look Ma, No hands!"'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “看吧，不用手！”
- en: What's next? Think of it and it happens? I would love to be alive to see that,
    as I could do things at the speed of thought.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？想到了就会发生吗？我很想活着看到那一天，因为我可以以思维的速度做事情。
- en: If you are new to the world of Voice AI, you can start looking up Amazon Alexa,
    Google Now/Google Assistant, Apple Siri, or Windows Cortana to see what I am talking
    about. Since we are going to work with Amazon Alexa in this chapter, we will explore
    only that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是语音人工智能的新手，你可以开始查找亚马逊 Alexa、Google Now/Google Assistant、Apple Siri或Windows
    Cortana，看看我在说什么。由于我们将在本章中使用亚马逊 Alexa，我们只会探索它。
- en: 'Amazon recently launched a couple of devices named Amazon Echo and Amazon Echo
    Dot (recently made available in India too), which are smart speakers, enabled
    by Alexa, Amazon''s voice AI software. If you want to experience Alexa for yourself,
    without buying buying echo products, download the reverb app for Android: [https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en](https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en)
    or iOS: [https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8](https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8)
    and launch the app.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊最近推出了两款名为亚马逊 Echo 和亚马逊 Echo Dot（最近也在印度上市），它们是由 Alexa，亚马逊的语音人工智能软件驱动的智能音箱。如果你想亲自体验
    Alexa，而又不想购买 Echo 产品，可以在 Android 上下载 reverb 应用：[https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en](https://play.google.com/store/apps/details?id=agency.rain.android.alexa&hl=en)
    或者在 iOS 上下载：[https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8](https://itunes.apple.com/us/app/reverb-for-amazon-alexa/id1144695621?mt=8)，然后启动该应用。
- en: 'You should see an interface with a microphone icon. Press and hold the microphone
    and you should see the text Listening... on the top, as shown in the following
    screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个带有麦克风图标的界面。按住麦克风，你应该在顶部看到“正在听...”的文字，就像下面的截图所示：
- en: '![](../images/00065.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00065.jpeg)'
- en: Now say, *Alexa, tell me a joke* and get entertained by Alexa!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在说，*“Alexa，给我讲个笑话”*，然后被 Alexa 娱乐吧！
- en: Test drive
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试驾
- en: To test what we are going to build, press the microphone icon in the reverb
    app and say, *Alexa, ask smarty app for the weather report* and you should hear
    the latest data that is persisted in the database for the smart weather station.
    And then you can say, *Alexa, ask smarty app to turn on the motor,* or *Alexa,
    ask smarty app to turn off the motor;* if my device is online, it will turn it
    off.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们将要构建的东西，在 reverb 应用中按下麦克风图标，然后说 *“Alexa，请问smarty app天气报告”*，你应该听到保存在智能气象站数据库中的最新数据。然后你可以说
    *“Alexa，请问smarty app打开发动机”*，或者 *“Alexa，请问smarty app关闭发动机”*；如果我的设备在线，它会关闭它。
- en: Along with smart weather station, we are going to build a smart socket, which
    can be connected to a motor in a farm. And using Alexa, we are going to turn on/off
    the motor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了智能气象站，我们还将建立一个智能插座，可以连接到农场中的发动机。然后使用 Alexa，我们将打开/关闭发动机。
- en: Now, if you have an Amazon echo or echo dot, you can test the skill we are going
    to build. Or, you can do the same using the reverb app. You can also use [https://reverb.ai/](https://reverb.ai/)
    or [https://echosim.io/](https://echosim.io/) for the same.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你有亚马逊 Echo 或 Echo Dot，你可以测试我们将要构建的技能。或者，你也可以使用 reverb 应用来做同样的事情。你也可以使用
    [https://reverb.ai/](https://reverb.ai/) 或 [https://echosim.io/](https://echosim.io/)
    来做同样的事情。
- en: Till your Alexa skill is published, it will be only accessible on devices that
    are linked with your Amazon account only. If you have enabled beta testing, then
    you can allow multiple people to access this skill on their Amazon account linked
    Alexa powered devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Alexa 技能发布之前，它只能在与你的亚马逊账户关联的设备上访问。如果你启用了测试版，那么你可以允许多人在他们的亚马逊账户关联的 Alexa
    设备上访问这个技能。
- en: 'If you are facing issues to explore the demo, check out this video recording:
    `/videos/chapter5/alexa_smarty_app_demo.mov`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在探索演示时遇到问题，请查看这个视频录制：`/videos/chapter5/alexa_smarty_app_demo.mov`
- en: So, let's get started!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Building a smart socket
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建智能插座
- en: In this section, we are going to build a smart socket. The setup is going to
    be quite similar to what we had in [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee),
    *Smart Agriculture*. Create a new folder named `chapter5` and copy the contents
    of the `chapter4` folder into it. The `chapter4` folder has the code for the smart
    weather station, and now, we are going to add the required code for smart socket.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个智能插座。设置将与[第4章](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee)中的设置非常相似。创建一个名为`chapter5`的新文件夹，并将`chapter4`文件夹的内容复制到其中。`chapter4`文件夹中包含智能气象站的代码，现在，我们将添加智能插座所需的代码。
- en: The smart socket is a simple electrical socket that can be controlled over the
    internet. That is, turn on the socket and turn off the socket. We are going to
    use a **mechanical relay** to achieve this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 智能插座是一个可以通过互联网控制的简单电源插座。也就是说，打开插座和关闭插座。我们将使用**机械继电器**来实现这一点。
- en: We are going to start off by setting up the relay with the other sensors on
    the Raspberry Pi. I am going to use one Raspberry Pi to demonstrate the smart
    weather station as well as the smart socket. You can use two Raspberry Pis as
    well for this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在树莓派上设置继电器开始。我将使用一个树莓派来演示智能气象站以及智能插座。您也可以使用两个树莓派来进行演示。
- en: We are going to add the appropriate MQTT client code to the API engine; next,
    update the web, desktop, and mobile app to have a toggle switch to turn on/off
    the relay.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向API引擎添加适当的MQTT客户端代码；接下来，更新Web、桌面和移动应用程序，以添加一个切换开关来打开/关闭继电器。
- en: We are going to create a new topic named `socket` on, which we would send either
    `1` or `0` to turn on/off the relay, thus turning the load on the other end of
    the relay on/off.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`socket`上创建一个名为`socket`的新主题，我们将发送`1`或`0`来打开/关闭继电器，从而打开/关闭继电器另一端的负载。
- en: Do remember that we are exploring the various solutions that can be built with
    IoT and we are not building the final product itself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在探索可以使用物联网构建的各种解决方案，而不是构建最终产品本身。
- en: Setting up relay with Raspberry Pi
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树莓派设置继电器
- en: As of now, Raspberry Pi has the smart weather station sensors attached to it.
    Now, we are going to add a relay to the setup.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，树莓派已连接智能气象站传感器。现在，我们将向设置添加一个继电器。
- en: A relay is an electrical switch that is driven by an electronic signal. That
    is, triggering the relay with logic high `1` will turn on the relay and logic
    low `0` will turn off the relay.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器是由电子信号驱动的电气开关。也就是说，用逻辑高`1`触发继电器会打开继电器，逻辑低`0`会关闭继电器。
- en: Some relays work the other way around, depending on the component. To know more
    about types of relay and how they work, refer to, [https://www.phidgets.com/docs/Mechanical_Relay_Primer](https://www.phidgets.com/docs/Mechanical_Relay_Primer).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些继电器的工作方式相反，这取决于组件。要了解更多关于继电器类型和工作原理的信息，请参考[https://www.phidgets.com/docs/Mechanical_Relay_Primer](https://www.phidgets.com/docs/Mechanical_Relay_Primer)。
- en: 'You can purchase a simple 5V driven relay from Amazon: ([https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3](https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3)).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从亚马逊购买一个简单的5V继电器：([https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3](https://www.amazon.com/DAOKI%C2%AE-Arduino-Indicator-Channel-Official/dp/B00XT0OSUQ/ref=sr_1_3))。
- en: Relays deal with AC current, and in our examples, we are not going to connect
    any AC power supply to the relay. We are going to power it using a 5V DC supply
    from Raspberry Pi and using the LED indicator on the relay identify if the relay
    has been turned on or off. In case you want to connect it to an actual power supply,
    please take adequate precaution before doing so. The results might be shocking
    if proper care is not taken.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器处理交流电流，在我们的示例中，我们不会将任何交流电源连接到继电器。我们将使用来自树莓派的5V直流电源来供电，并使用继电器上的LED指示灯来识别继电器是否已打开或关闭。如果您想将其连接到实际电源，请在这样做之前采取适当的预防措施。如果不注意，结果可能会令人震惊。
- en: Along with the weather station, we are going to connect the relay as well to
    the Raspberry Pi 3\. Connect the relay, as shown in the following figure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了气象站，我们还将把继电器连接到树莓派3\. 将继电器连接如下图所示。
- en: 'Connection of Raspberry Pi with the smart weather station:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派与智能气象站的连接：
- en: '![](../images/00066.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: 'Connection of Raspberry Pi with a `relay` (module):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派与`继电器`（模块）的连接：
- en: '![](../images/00067.jpeg)If you purchased a standalone relay, you need to set
    up the circuit, as shown previously. And, if you have purchased the relay module,
    you need to connect pin 18/GPIO24 to the trigger pin, after powering the relay.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00067.jpeg)如果您购买了独立的继电器，您需要按照之前显示的电路进行设置。如果您购买了继电器模块，您需要在给继电器供电后，将引脚18/GPIO24连接到触发引脚。'
- en: 'To reiterate the previous connection, please see the tables shown, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重申之前的连接，请参见下表所示的表格：
- en: 'Raspberry Pi and MCP3208:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派和MCP3208：
- en: '| **Raspberry Pi number - Pin name** | **MCP 3208 pin number - Pin name** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派编号 - 引脚名称** | **MCP 3208引脚编号 - 引脚名称** |'
- en: '| 1 - 3.3V | 16 - VDD |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 3.3V | 16 - VDD |'
- en: '| 1 - 3.3V | 15 - AREF |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 3.3V | 15 - AREF |'
- en: '| 6 - GND | 14 - AGND |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 6 - GND | 14 - AGND |'
- en: '| 23 - GPIO11, SPI0_SCLK | 13 - CLK |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 23 - GPIO11, SPI0_SCLK | 13 - CLK |'
- en: '| 21 - GPIO09, SPI0_MISO | 12 - DOUT |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 21 - GPIO09, SPI0_MISO | 12 - DOUT |'
- en: '| 19 - GPIO10, SPI0_MOSI | 11 - DIN |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 19 - GPIO10, SPI0_MOSI | 11 - DIN |'
- en: '| 24 - GPIO08, CEO | 10 - CS |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 24 - GPIO08, CEO | 10 - CS |'
- en: '| 6 - GND | 9 - DGND |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 6 - GND | 9 - DGND |'
- en: 'Moisture sensor and MCP3208:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 湿度传感器和MCP3208：
- en: '| **MCP 3208 pin number - Pin name** | **Sensor pin** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **MCP 3208引脚编号 - 引脚名称** | **传感器引脚** |'
- en: '| 1 - A0 | Rain sensor - A0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1 - A0 | 雨传感器 - A0 |'
- en: '| 1 - A1 | Moisture sensor - A0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 - A1 | 湿度传感器 - A0 |'
- en: 'Raspberry Pi and DHT11:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派和DHT11：
- en: '| **Raspberry Pi number - Pin name** | **Sensor pin** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派编号 - 引脚名称** | **传感器引脚** |'
- en: '| 3 - GPIO2 | DHT11 - data |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 3 - GPIO2 | DHT11 - 数据 |'
- en: 'Raspberry Pi and relay:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派和继电器：
- en: '| **Raspberry Pi number - Pin name** | **Sensor pin** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派编号 - 引脚名称** | **传感器引脚** |'
- en: '| 12 - GPIO18 | Relay - trigger pin |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 12 - GPIO18 | 继电器 - 触发引脚 |'
- en: All grounds and all 3.3V pins are connected to a common point. All the relay
    needs is a 5V power supply from the Raspberry Pi, which is pin 2.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有地线和所有3.3V引脚都连接到一个公共点。继电器所需的只是来自树莓派的5V电源，即引脚2。
- en: Once we have connected the sensors as shown previously, we will write the required
    code needed to interface with the sensors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按照之前所示连接了传感器，我们将编写所需的代码来与传感器进行接口。
- en: 'Head towards the `pi-client` folder inside `Raspberry Pi 3`, open `pi-client/index.js`,
    and update it as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`Raspberry Pi 3`内的`pi-client`文件夹，打开`pi-client/index.js`，并进行如下更新：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To the `Weather Station` code, we have added the `rpio` module and using the
    `rpio.open()`, we have made pin 12 as an output pin. We are also listening to
    the topic named socket. And, when we get a response from the broker on this topic,
    we set pin 12 to high or low based on the data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Weather Station`代码，我们已经添加了`rpio`模块，并使用`rpio.open()`，我们已经将引脚12设置为输出引脚。我们还在名为socket的主题上进行监听。当我们从代理在此主题上收到响应时，我们根据数据将引脚12设置为高电平或低电平。
- en: 'Now, we will install the `rpio` module inside the Raspberry Pi `pi-client`
    folder, and run the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在树莓派`pi-client`文件夹内安装`rpio`模块，并运行以下命令：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save all, the files. Now, we will start the Mosca broker from our desktop/machine:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件。现在，我们将从我们的桌面/机器上启动Mosca代理：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you have started Mosca server, do check the IP address of the server on
    which Mosca is running. Update the same IP in your Raspberry Pi `config.js` file
    or else Raspberry Pi cannot post data to the broker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启动了Mosca服务器，请检查Mosca正在运行的服务器的IP地址。在树莓派`config.js`文件中更新相同的IP，否则树莓派无法将数据发布到代理。
- en: 'Once Mosca has started successfully and we have validated the IP on the Raspberry
    Pi, run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Mosca成功启动并且我们已经验证了树莓派上的IP地址，请运行：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will start the server and keep sending the weather information to the broker.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动服务器并继续向代理发送天气信息。
- en: In the next section, we are going to write the required logic needed for the
    API engine to process the relay.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写API引擎处理继电器所需的逻辑。
- en: Managing relay in an API engine
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在API引擎中管理继电器
- en: 'Now that the relay is connected to the Raspberry Pi, we will write the logic
    that will send the on/off command to the socket topic. Open `api-engine/server/mqtt/index.js`
    and update it, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继电器已连接到树莓派，我们将编写逻辑，将打开/关闭命令发送到socket主题。打开`api-engine/server/mqtt/index.js`并进行如下更新：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have added a method named `sendSocketData` and exported it. We are going
    to call this method in the `api-engine/server/api/data/data.controller.jscreate`
    method, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`sendSocketData`的方法并导出它。我们将在`api-engine/server/api/data/data.controller.jscreate`方法中调用此方法，如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save all, the files and run:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件并运行：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following on your screen:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到以下内容：
- en: '![](../images/00068.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00068.jpeg)'
- en: Do note, the last value in the data string printed in the console; `s`, we are
    sending the status of the relay as well to display in the UI, if the relay is
    on/off.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，控制台中打印的数据字符串中的最后一个值; `s`，我们还发送继电器的状态以在UI中显示，如果继电器打开/关闭。
- en: With this, we are done with the code needed to develop the API engine. In the
    next section, we are going to work on the web app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了开发API引擎所需的代码。在下一节中，我们将继续处理Web应用程序。
- en: Updating the web app template
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Web应用程序模板
- en: In this section, we are going to update the web app template to have a toggle
    button, quite similar to what we had in [Chapter 2](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - I*, and [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*. Using the toggle button, we are going to turn on/off the relay
    manually. In the later sections, we are going to automate them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新Web应用程序模板，以便拥有一个切换按钮，与我们在[第2章](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee)中所拥有的非常相似，*IoTFW.js
    - I*，以及[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)，*IoTFW.js
    - II*。使用切换按钮，我们将手动打开/关闭继电器。在后面的部分中，我们将对其进行自动化。
- en: 'Open, `web-app/src/app/device/device.component.html` and update it, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`web-app/src/app/device/device.component.html`并进行如下更新：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All we have done is added a new row that shows a toggle button, and using this,
    we turn on/off the socket. Next, the required logic to manage the toggle button,
    open `web-app/src/app/device/device.component.ts` and update it, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是添加了一个显示切换按钮的新行，通过使用它，我们可以打开/关闭插座。接下来，打开`web-app/src/app/device/device.component.ts`并进行如下更新，以管理切换按钮所需的逻辑：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All we have done here is manage the toggle button state. Save all the files
    and run the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的一切就是管理切换按钮的状态。保存所有文件并运行以下命令：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Navigate to `http://localhost:4200` and then navigate to the device page. Now,
    using the toggle button on the page, we can turn the relay on/off, as shown in
    the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:4200`，然后导航到设备页面。现在，通过页面上的切换按钮，我们可以打开/关闭继电器，如下面的截图所示：
- en: '![](../images/00069.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00069.jpeg)'
- en: 'If everything is set up correctly, you should see the relay LED turn on/off
    on the relay, as shown in the following photograph:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您应该看到继电器上的LED在继电器上打开/关闭，如下照片所示：
- en: '![](../images/00070.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.jpeg)'
- en: Wires! Duh!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 电线！嘿！
- en: With this, we are done with the web app. In the next section, we are going to
    build the same web app and deploy it inside our desktop app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了Web应用程序。在下一节中，我们将构建相同的Web应用程序并将其部署到我们的桌面应用程序中。
- en: Updating the desktop app
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新桌面应用程序
- en: Now that the web app is done, we are going to build the same and deploy it inside
    our desktop app.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Web应用程序已完成，我们将构建相同的Web应用程序并将其部署到我们的桌面应用程序中。
- en: 'To get started, head back to the terminal/prompt of the `web-app` folder and
    run:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请返回到`web-app`文件夹的终端/提示符，并运行：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will create a new folder inside the `web-app` folder named `dist`. The
    contents of the `dist` folder should be on the lines of:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`web-app`文件夹内创建一个名为`dist`的新文件夹。`dist`文件夹的内容应该如下所示：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All, the code we have written is finally bundled into the preceding files.
    We will grab all of the files (not the `dist` folder) present inside the `dist`
    folder and then paste it inside the `desktop-app/app` folder. The final structure
    of the `desktop-app` after the previous changes will be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的所有代码最终都打包到了前面的文件中。我们将获取`dist`文件夹中的所有文件（而不是`dist`文件夹），然后将其粘贴到`desktop-app/app`文件夹中。在之前的更改后，`desktop-app`的最终结构将如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To test drive, run the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，请运行以下命令：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, when we navigate to the VIEW DEVICE page, we should see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们导航到“查看设备”页面时，我们应该看到以下内容：
- en: '![](../images/00071.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: Using the toggle button, we should be able to turn the relay on/off.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切换按钮，我们应该能够打开/关闭继电器。
- en: With this, we are done with the development of the desktop app. In the next
    section, we will update the mobile app.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了桌面应用的开发。在下一节中，我们将更新移动应用。
- en: Updating the mobile app template
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新移动应用模板
- en: In the last section, we have updated the desktop app. In this section, we are
    going to update the mobile app template with the toggle switch component. So,
    using this toggle switch, we can turn the smart socket on/off.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经更新了桌面应用。在本节中，我们将使用切换开关组件更新移动应用模板。因此，使用此切换开关，我们可以打开/关闭智能插座。
- en: 'First, we are going to update the view-device template. Update `mobile-app/src/pages/view-device/view-device.html`,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要更新“查看设备”模板。更新`mobile-app/src/pages/view-device/view-device.html`，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we are going to add the required logic to manage the toggle button. Update
    `mobile-app/src/pages/view-device/view-device.ts`, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加所需的逻辑来管理切换按钮。更新`mobile-app/src/pages/view-device/view-device.ts`，如下所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have added the required logic to manage the toggle button. Save all,
    the files and run:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经添加了所需的逻辑来管理切换按钮。保存所有文件并运行：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, you can deploy the same to your device as well, by running:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以将其部署到您的设备上，方法是运行：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the app is launched, and when we navigate to VIEW DEVICE page, we should
    see the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，当我们导航到“查看设备”页面时，我们应该看到以下内容：
- en: '![](../images/00072.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: We should be able to control the socket using the toggle button on the mobile
    app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够使用移动应用上的切换按钮来控制插座。
- en: With this, we are done with the set up of smart motor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了智能电机的设置。
- en: In the next section, we are going to build a new skill for Amazon Alexa.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为亚马逊Alexa构建一个新的技能。
- en: Developing Alexa skill
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Alexa技能
- en: In the last section, we have seen how to build a smart socket and integrate
    it with our existing smart weather station. In this section, we are going to build
    a new skill for interfacing our smart devices with Amazon Alexa.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经看到了如何构建智能插座并将其与我们现有的智能气象站集成。在本节中，我们将为与亚马逊Alexa接口的智能设备构建一个新的技能。
- en: 'We are going to create a new skill named smarty app and then add two voice
    models to it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为smarty app的新技能，然后向其添加两个语音模型：
- en: To get the latest weather status
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取最新的天气状态
- en: To turn on/off the socket
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开/关闭插座
- en: 'If you are new to Alexa and its skill development, I would recommend watching
    the following series before you continue: Developing Alexa skills: [https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ](https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Alexa及其技能开发的新手，我建议您在继续之前观看以下系列视频：开发Alexa技能：[https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ](https://www.youtube.com/playlist?list=PL2KJmkHeYQTO6ci5KF08mvHYdAZu2jgkJ)
- en: 'To give a quick overview of our skill creation, we are going to follow these
    steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速概述我们的技能创建，我们将按照以下步骤进行：
- en: Log in to the Amazon developer portal and create and set up a new skill
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到亚马逊开发者门户并创建和设置一个新技能
- en: Train the voice model
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练语音模型
- en: Write the required business logic in AWS lambda service
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS Lambda服务中编写所需的业务逻辑
- en: Deploy and test the setup
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署和测试设置
- en: So, let's get started.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Creating skill
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建技能
- en: 'The first thing we are going to do is log in to [https://developer.amazon.com](https://developer.amazon.com).
    Once we are logged in, click on Alexa on the top section of the page. You should
    land on a page that should look as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是登录到[https://developer.amazon.com](https://developer.amazon.com)。一旦登录，点击页面顶部的Alexa。您应该会登陆到一个页面，应该如下所示：
- en: '![](../images/00073.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: Click on Get Started > below Alexa Skills Kit and you should be redirected to
    a page where you can view your existing skill sets or create a new one. Click
    on the golden button on the top right-hand corner named Add a new skill.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“开始”>下面的Alexa技能套件，您应该被重定向到一个页面，您可以查看您现有的技能集或创建一个新的。点击右上角的金色按钮，名为“添加新技能”。
- en: 'You should be redirected to a page, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该被重定向到一个页面，如下所示：
- en: '![](../images/00074.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: 'I have given the preceding information. You can configure it as you please.
    Click Save and then click on Interaction Model on the left menu, and you should
    be redirected to the Interactive Model settings, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提供了前面的信息。您可以根据需要进行配置。点击保存，然后点击左侧菜单上的“交互模型”，您应该被重定向到交互模型设置，如下所示：
- en: '![](../images/00075.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.jpeg)'
- en: We are going to use the skill builder, which is still in beta at the time of
    writing. Skill builder is an easy interface to train our voice model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用技能构建器，这在撰写时仍处于测试阶段。技能构建器是一个简单的界面，用于训练我们的语音模型。
- en: Click on the Launch Skill Builder button.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“启动技能构建器”按钮。
- en: Training the voice model
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练语音模型
- en: 'Once we are inside the skill builder, we are going to start training the models.
    In our application, we are going to have two intents:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入技能构建器，我们将开始训练模型。在我们的应用程序中，我们将有两个意图：
- en: '`WeatherStatusIntent`: To get the values of all four sensors'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeatherStatusIntent`：获取所有四个传感器的值'
- en: '`ControlMotorIntent`: To turn the motor on/off'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlMotorIntent`：打开/关闭电机'
- en: Apart from this, you can also add other intents based on your requirements.
    You can add a moisture sensor only intent to get the values of moisture sensor
    only or rain sensor intent for only rain sensor values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还可以根据自己的需求添加其他意图。你可以添加一个仅湿度传感器意图，以仅获取湿度传感器的值，或者添加一个仅雨传感器意图，以仅获取雨传感器的值。
- en: Now, we will go ahead and set up these intents and create slots.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置这些意图并创建槽。
- en: 'Once you are inside the skill builder, you should see something similar to
    the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入了技能构建器，你应该看到类似以下的东西：
- en: '![](../images/00076.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: 'Now, using Add + next to the intents on the left-hand side, create a new custom
    intent and name it `WeatherStatusIntent`, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在左侧的意图旁边使用Add +，创建一个新的自定义意图并命名为`WeatherStatusIntent`，如下所示：
- en: '![](../images/00077.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00077.jpeg)'
- en: Now, we are going to train the voice model. Once the intent has been created,
    click on the intent name on the left menu. Now, we should see a section named
    Sample Utterances. We are going to feed the sample utterances of how the user
    is going to invoke our service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要训练语音模型。一旦意图被创建，点击左侧菜单上的意图名。现在，我们应该看到一个名为示例话语的部分。我们要提供用户如何调用我们服务的示例话语。
- en: 'To keep things simple, I have added only three samples:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我只添加了三个示例：
- en: 'Alexa, ask smarty app:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Alexa，问smarty app：
- en: The weather report
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气报告
- en: The weather status
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气状况
- en: The field conditions
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段条件
- en: 'You can see this in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中看到这一点：
- en: '![](../images/00078.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00078.jpeg)'
- en: Next, we are going to create another intent named `ControlMotorIntent` using
    the same process. Click on ControlMotorIntent on the left-hand side menu and we
    should see the sample utterances section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用相同的过程创建另一个名为`ControlMotorIntent`的意图。点击左侧菜单上的ControlMotorIntent，我们应该看到示例话语部分。
- en: For this intent, we are going to do something different; we are going to create
    something called **slots**. We are going to take the sample utterance that the
    user would utter and extract a piece of it as a variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个意图，我们要做一些不同的事情；我们要创建一些叫做**槽**的东西。我们要取用户可能说出的示例话语，并提取其中的一部分作为变量。
- en: For example, if the user says, *Alexa, ask smarty app to turn on the motor,*
    or *Alexa, ask smarty app to turn off the motor*, everything is the same except
    for turn on or turn off, so we want to convert these to variables and handle each
    instruction differently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户说*Alexa，问smarty app打开电机*或*Alexa，问smarty app关闭电机*，除了打开或关闭之外，一切都是相同的，所以我们想将这些转换为变量，并分别处理每个指令。
- en: If the slot is turned on, we turn on the motor and if the slot is turned off,
    we are going to turn off the motor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果槽被打开，我们就打开电机，如果槽被关闭，我们就关闭电机。
- en: 'So, once you have entered the sample utterance such as to turn on the motor,
    select the text `turn on`, as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦你输入了示例话语，比如打开电机，选择文本`打开`，如下截图所示：
- en: '![](../images/00079.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00079.jpeg)'
- en: Once you have selected the text, enter a custom intent slot name motorAction
    and click on the *plus* icon.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了文本，输入一个自定义意图槽名motorAction并点击*加号*图标。
- en: We will have only one utterance for this intent. Next, we need to configure
    the motorAction intent slot.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个意图，我们只会有一个话语。接下来，我们需要配置motorAction意图槽。
- en: On the right-hand side of the page, you should see the newly created intent
    slot. Check the checkbox under the REQ column. This means that this value is required
    for the intent to be called. Next, click on Choose a slot type below the slot
    name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的右侧，你应该看到新创建的意图槽。勾选REQ列下的复选框。这意味着这个值是意图调用所必需的。接下来，点击槽名下面的选择槽类型。
- en: 'Here, we have to define a custom intent slot type. Add `motorActionIntentSlot`,
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要定义一个自定义意图槽类型。添加`motorActionIntentSlot`，如下所示：
- en: '![](../images/00080.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00080.jpeg)'
- en: 'Next, we have to set up the values. Click on `motorActionIntentSlot` from the
    left-hand side menu and add two values; turn on and turn off, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置值。从左侧菜单中点击`motorActionIntentSlot`，然后添加两个值；turn on和turn off，如下所示：
- en: '![](../images/00081.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00081.jpeg)'
- en: 'Once this is done, we need to set up the prompt that will be spoken when the
    user doesn''t utter the two slot values we have defined. Click on {motorAction}
    under ControlMotorIntent and below Dialog Model, and enter a prompt such as `Do
    you want me to turn on or turn off the motor?`, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们需要设置当用户没有说出我们定义的两个槽值时将会说的提示。点击ControlMotorIntent下的{motorAction}和对话模型下方，输入提示，比如`你想让我打开还是关闭电机？`，如下所示：
- en: '![](../images/00082.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00082.jpeg)'
- en: With this, we are done with defining our voice model.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经定义了我们的语音模型。
- en: 'Now, we need to ask the Alexa skill engine to build our voice model and add
    it to its skill engine. Using the Save Model button at the top of the page, save
    the model and then Build Model:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要要求Alexa技能引擎构建我们的语音模型，并将其添加到其技能引擎中。使用页面顶部的保存模型按钮保存模型，然后构建模型：
- en: '![](../images/00083.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00083.jpeg)'
- en: The build generally takes five minutes or less to complete.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常构建过程只需要五分钟或更短的时间。
- en: ngrok the API engine
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngrok API引擎
- en: Before we go ahead and start working on the lambda service, we need to first
    expose our API engine to be available with a public URL, as in [http://iotfwjs.com/api](http://iotjs.com/api),
    so when the user asks the Alexa skill service a question or issues a command,
    the Alexa skill service can contact us via the lambda service.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行lambda服务之前，我们需要首先将API引擎暴露出来，以便通过公共URL可用，比如[http://iotfwjs.com/api](http://iotjs.com/api)，这样当用户询问Alexa技能服务问题或发布命令时，Alexa技能服务可以通过lambda服务联系我们。
- en: So far, we have been using a local IP-based configuration to interact with the
    API engine, broker, web app, or Raspberry Pi. But, that doesn't work when we want,
    Alexa skill service to find us.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用基于本地IP的配置来与API引擎、代理、Web应用程序或树莓派进行交互。但是，当我们希望Alexa技能服务找到我们时，这种方法就行不通了。
- en: Hence, we are going to use a service named `ngrok` ([https://ngrok.com/](https://ngrok.com/))
    to temporarily host our local code with a public URL that Amazon Alexa service
    can use to find us via lambda service.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用一个名为`ngrok`的服务（[https://ngrok.com/](https://ngrok.com/)）来临时托管我们的本地代码，并提供一个公共URL，Amazon
    Alexa服务可以通过lambda服务找到我们。
- en: 'To set up `ngrok`, please follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`ngrok`，请按照以下步骤进行：
- en: 'Download the `ngrok` installer from here: [https://ngrok.com/download](https://ngrok.com/download)
    for your OS, which is running the API engine'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里下载`ngrok`安装程序：[https://ngrok.com/download](https://ngrok.com/download)适用于运行API引擎的操作系统
- en: Unzip and copy the contents of the `ngrok` downloaded ZIP file at the root of
    the `api-engine` folder
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压并复制`ngrok`下载的ZIP文件的内容到`api-engine`文件夹的根目录
- en: 'Start Mosca from the root of the `broker` folder, by running the following
    command:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令从`broker`文件夹的根目录启动Mosca：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Start the API engine from the root of `api-engine` folder, by running:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令从`api-engine`文件夹的根目录启动API引擎：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start tunneling with `ngrok` now. From the root of the `api-engine` folder,
    where we have copied the `ngrok` executable, run:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始使用`ngrok`进行隧道。从我们已经复制了`ngrok`可执行文件的`api-engine`文件夹的根目录运行：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running `./ngrok http 9000` will start a new tunnel between the local host
    and a public instance of `ngrok` server, and we should see the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`./ngrok http 9000`将在本地主机和`ngrok`服务器的公共实例之间启动一个新的隧道，我们应该看到以下内容：
- en: '![](../images/00084.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00084.jpeg)'
- en: 'The forwarding URL changes every time you kill and restart `ngrok`. In the
    preceding case, the public URL of ngrok: `http://add7231d.ngrok.io` is mapped
    to my local server: `http://localhost:9000`. Isn''t this easy?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 转发URL每次杀死和重新启动`ngrok`时都会更改。在前面的情况下，ngrok的公共URL：`http://add7231d.ngrok.io`映射到我的本地服务器：`http://localhost:9000`。这不是很容易吗？
- en: 'To quickly test the public URL, open `web-app/src/app/app.global.ts` and update
    it, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速测试公共URL，请打开`web-app/src/app/app.global.ts`并更新如下：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you can launch your web app from anywhere and it will talk to the API engine
    using the public URL.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从任何地方启动您的web应用程序，并且它将使用公共URL与API引擎进行通信。
- en: Do read the terms of service ([https://ngrok.com/tos](https://ngrok.com/tos))
    and privacy policy ([https://ngrok.com/privacy](https://ngrok.com/privacy)) of
    `ngrok` before proceeding further.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请阅读`ngrok`的服务条款（[https://ngrok.com/tos](https://ngrok.com/tos)）和隐私政策（[https://ngrok.com/privacy](https://ngrok.com/privacy)）。
- en: Defining the lambda function
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义lambda函数
- en: Now that the voice model is trained and we have a public URL to access the API
    engine, we are going to write the required service to respond to the user's interactions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在语音模型已经训练好，并且我们有一个可以访问API引擎的公共URL，我们将编写所需的服务来响应用户的交互。
- en: When a user goes, *Alexa, ask smarty app the weather report*, Alexa will make
    a request to the AWS lambda function and the lambda function will call the API
    engine for appropriate activity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户说“Alexa，请问smarty app天气报告”时，Alexa将向AWS lambda函数发出请求，lambda函数将调用API引擎进行适当的活动。
- en: 'Quoting from AWS: [https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 引用AWS：[https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/)
- en: The AWS Lambda is a serverless compute service that runs your code in response
    to events and automatically manages the underlying compute resources for you.
    You can use AWS Lambda to extend other AWS services with custom logic, or create
    your own back-end services that operate at AWS scale, performance, and security.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda是一种无服务器计算服务，它根据事件运行您的代码，并自动管理底层计算资源。您可以使用AWS Lambda来扩展其他AWS服务的自定义逻辑，或者创建自己的后端服务，以在AWS规模、性能和安全性上运行。
- en: 'To know more about AWS lambda, refer to: [https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关AWS lambda的更多信息，请参阅：[https://aws.amazon.com/lambda/details/](https://aws.amazon.com/lambda/details/)。
- en: 'To get started, head to AWS console: [https://console.aws.amazon.com/](https://console.aws.amazon.com/)
    and select the region as North Virginia. As of today, AWS lambda services hosted
    in North America and Europe are only allowed to be linked with the Alexa Skill.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请转到AWS控制台：[https://console.aws.amazon.com/](https://console.aws.amazon.com/)并选择北弗吉尼亚地区。截至今天，只允许在北美和欧洲托管的AWS
    lambda服务与Alexa技能进行关联。
- en: 'Next, from the Service menu on top, select Lambda under the Compute section.
    This will take us to the Functions screen of the lambda service. Click on Create
    a Lambda function and we will be asked to select a blueprint. Select Blank Function.
    Next, you will be asked to select a trigger; select Alexa Skill Set, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从顶部的服务菜单中，在计算部分下选择Lambda。这将带我们到lambda服务的函数屏幕。单击创建Lambda函数，然后我们将被要求选择一个蓝图。选择空白函数。接下来，您将被要求选择一个触发器；选择Alexa技能集，如下：
- en: '![](../images/00085.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00085.jpeg)'
- en: 'Click on Next. Now, we need to configure the function. Update it, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。现在，我们需要配置函数。更新如下：
- en: '![](../images/00086.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00086.jpeg)'
- en: 'For Lambda function code, enter the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Lambda函数代码，请输入以下代码：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is a lot going on in the code. `exports.handler()` is the default function
    that we need to set up for lambda to work. Inside that, we have defined the type
    of incoming request. And, if the incoming is an `IntentRequest`, we call `onIntent()`.
    Inside `onIntent()`, we fetch the `intentName` and invoke the appropriate logic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有很多内容。`exports.handler()`是我们需要为lambda设置的默认函数。在其中，我们定义了传入请求的类型。如果传入的是`IntentRequest`，我们调用`onIntent()`。在`onIntent()`中，我们获取`intentName`并调用适当的逻辑。
- en: If the `intentName` is `WeatherStatusIntent`, we invoke `handleWSIRequest()`,
    or else if the intentName is `ControlMotorIntent`, we call `handleCMIRequest()`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`intentName`是`WeatherStatusIntent`，我们调用`handleWSIRequest()`，否则如果intentName是`ControlMotorIntent`，我们调用`handleCMIRequest()`。
- en: Inside `handleWSIRequest()` we invoke the `getData()`, which will make a HTTP
    `GET` request to our `ngrok` URL. Once the data arrives, we construct a response
    and return it to the skill service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleWSIRequest()`内，我们调用`getData()`，它将向我们的`ngrok` URL发出HTTP `GET`请求。一旦数据到达，我们构造一个响应并将其返回给技能服务。
- en: And, `handleCMIRequest()` does the same, except it first gets the `motorAction`
    slot value and then calls `setData()`, which will call or either turn the motor
    on/off.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，`handleCMIRequest()`也是一样，只是它首先获取`motorAction`槽值，然后调用`setData()`，这将调用或者打开/关闭电机。
- en: 'Once the code has been copied, you should find additional configuration at
    the bottom. We are going to leave the handler as-is. For the role, click on Create
    a custom role, and set it up, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码被复制，您应该在底部找到额外的配置。我们将保持处理程序不变。对于角色，点击创建自定义角色，并进行如下设置：
- en: '![](../images/00087.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00087.jpeg)'
- en: 'And click on Allow. This will create a new role that will get populated in
    Existing role*, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击允许。这将创建一个新的角色，该角色将在*现有角色*中填充，如下所示：
- en: '![](../images/00088.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00088.jpeg)'
- en: Once this is done, click on Next. Verify the summary and click on Create function
    at the bottom of the page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击下一步。验证摘要，然后点击页面底部的创建函数。
- en: 'If everything goes well, you should see the following screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到以下屏幕：
- en: '![](../images/00089.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00089.jpeg)'
- en: Do notice the ARN in the top right corner. This is the **Amazon Resource Name**
    (**ARN**) for our lambda function. We need to provide this as an input to the
    Alexa Skills Kit.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意右上角的ARN。这是我们lambda函数的**Amazon资源名称**（**ARN**）。我们需要将其作为输入提供给Alexa Skills Kit。
- en: Deploying and testing
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试
- en: 'Now that we have all the pieces, we will configure the ARN in the Alexa skill
    we have created. Head back to Alexa skill and click on Configuration, and update
    the configuration as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了所有的部件，我们将在我们创建的Alexa技能中配置ARN。返回Alexa技能，点击配置，然后按照以下方式更新配置：
- en: '![](../images/00090.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.jpeg)'
- en: Click Next. If everything is set up correctly, we can test the setup.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。如果一切设置正确，我们可以测试设置。
- en: 'Towards the bottom of the Test page, we should see a section named `Service
    Emulator`. You can test it, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试页面的底部，我们应该看到一个名为`服务仿真器`的部分。您可以按照以下方式进行测试：
- en: '![](../images/00091.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00091.jpeg)'
- en: 'The following screenshot shows the request received by lambda from Alexa:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了lambda从Alexa接收到的请求：
- en: '![](../images/00092.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00092.jpeg)'
- en: With this, we are done with integrating Alexa with our IoT.js framework.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了将Alexa与我们的IoT.js框架集成。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored how to integrate a voice AI service such as
    Alexa with the IoTFW.js framework we have developed. We continued with the same
    example from [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee),
    *Smart Agriculture*, and started off this chapter by setting up the relay that
    can turn the motor on/off. Next, we have understood how Alexa works. We have created
    a new custom skill and then set up the required voice model. After that, we have
    written the required business logic in AWS lambda, which will get the latest weather
    status as well as control the motor.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将Alexa等语音AI服务与我们开发的IoTFW.js框架集成。我们继续使用[第4章](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee)，*智能农业*中的相同示例，并通过设置可以打开/关闭电机的继电器开始了本章。接下来，我们了解了Alexa的工作原理。我们创建了一个新的自定义技能，然后设置了所需的语音模型。之后，我们在AWS
    lambda中编写了所需的业务逻辑，该逻辑将获取最新的天气状况并控制电机。
- en: We have finally tested everything using the reverb app and also validated everything.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终使用reverb应用程序测试了一切，并且也验证了一切。
- en: In [Chapter 6](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee), *Smart
    Wearable*, we are going to look at IoT and healthcare.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee)，*智能可穿戴*中，我们将研究物联网和医疗保健。
