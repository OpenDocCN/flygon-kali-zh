- en: Chapter 3. Developing a JavaFX Desktop and Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。开发JavaFX桌面和Web应用程序
- en: This chapter will cover how to develop compelling desktop and web applications
    that take advantage of the multicore, hardware-accelerated GPU to deliver high-performance
    UI-based applications that have an amazing look and feel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何开发引人注目的桌面和Web应用程序，利用多核、硬件加速的GPU来提供高性能的基于UI的应用程序，具有惊人的外观和感觉。
- en: As JavaFX is totally written from the ground up in Java, some Java SE 8 built-in
    core libraries will be used to power our application. In addition, we will learn
    how to package our application as a standalone application to be launched and
    distributed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaFX完全是用Java从头开始编写的，一些Java SE 8内置的核心库将被用于支持我们的应用程序。此外，我们将学习如何将我们的应用程序打包为一个独立的应用程序进行启动和分发。
- en: Also, we will cover the essential core web APIs in any web application levered
    by JavaFX 8, such as `javafx.scene.web.WebEngine`, `java.net.HttpURLConnection`
    and `javafx.scene.web.WebView`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将涵盖JavaFX 8中任何Web应用程序中的基本核心Web API，如`javafx.scene.web.WebEngine`、`java.net.HttpURLConnection`和`javafx.scene.web.WebView`。
- en: We will discuss the relationship between JavaFX and HTML5, which is important
    because JavaFX's APIs and the features of HTML5 complement one another. HTML5
    is a platform for rich web content to create a user experience that resembles
    a **RIA** (**Rich Internet Application**) web application with the characteristics
    of native desktop software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论JavaFX和HTML5之间的关系，这很重要，因为JavaFX的API和HTML5的特性互补。HTML5是一个用于创建类似于本机桌面软件特性的用户体验的丰富Web内容平台。
- en: More importantly, we will go through the development of a desktop version of
    the *Note-taking Application* and then run it on the Web.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们将通过开发*笔记应用程序*的桌面版本，然后在Web上运行。
- en: Additionally, we will cover all the required knowledge and skills to deploy
    the *Note-taking as a web application* on the desktop and the Web.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将涵盖部署*笔记作为Web应用程序*所需的所有知识和技能，包括桌面和Web。
- en: 'Here are the skills that will be learned during this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中将学到以下技能：
- en: Developing and running desktop and web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和运行桌面和Web应用程序
- en: Controlling application UIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制应用程序UI
- en: How to package a JavaFX 8 desktop application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何打包JavaFX 8桌面应用程序
- en: Loading HTML5 content inside a JavaFX application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaFX应用程序中加载HTML5内容
- en: Sending data from JavaFX to JavaScript and vice versa
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JavaFX发送数据到JavaScript，反之亦然
- en: Deploying a JavaFX web application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署JavaFX Web应用程序
- en: Developing a note-taking application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个笔记应用程序
- en: Building an application for one platform just isn't good enough anymore. Desktop,
    Web, mobile, and embedded support are all required for a successful product, but
    learning the different environments is difficult. Here comes into play the power
    of JavaFX to write an application that will run on different platforms with simple
    tweaks, as we will see in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为一个平台构建应用程序已经不够了。桌面、Web、移动和嵌入式支持对于成功的产品都是必需的，但学习不同的环境是困难的。这就是JavaFX的力量发挥作用的地方，它可以编写一个可以在不同平台上运行的应用程序，只需简单的调整，我们将在本章中看到。
- en: Here, we are going to build a *note-taking* application for desktop and the
    Web as well. In this project, I'll show you how to create a complete JavaFX application
    from scratch using the JavaFX 8 SDK and the Java programming language using our
    previously installed developer tools (refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with JavaFX 8"), *Getting Started with JavaFX 8*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为桌面和Web构建一个*笔记*应用程序。在这个项目中，我将向您展示如何使用先前安装的开发工具（参见[第1章](ch01.html "第1章。开始使用JavaFX
    8")，*开始使用JavaFX 8*）从头开始使用JavaFX 8 SDK和Java编程语言创建完整的JavaFX应用程序。
- en: I'll then show you how to create the application's two screen layouts and create
    the Java classes that control them. I'll create buttons that control navigation
    between different scenes, saves data, and then gets your UI controls updated dynamically
    with the power of property bindings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将向您展示如何创建应用程序的两个屏幕布局并创建控制它们的Java类。我将创建控制不同场景之间导航、保存数据的按钮，并使用属性绑定的功能动态更新您的UI控件。
- en: 'The final project will look like the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最终项目将看起来像以下屏幕截图：
- en: '![Developing a note-taking application](img/B03998_03_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![开发一个笔记应用程序](img/B03998_03_01.jpg)'
- en: P'Note-Taking Application
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: P'Note-Taking应用程序
- en: 'This figure shows the add and edit screen opened from the main screen new note
    button to add new note, or edit button to edit one of listed notes as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了从主屏幕新建笔记按钮打开的添加和编辑屏幕，以添加新笔记或编辑列表中的一个笔记如下：
- en: '![Developing a note-taking application](img/B03998_03_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![开发一个笔记应用程序](img/B03998_03_02.jpg)'
- en: So, what are you waiting for? Let's go!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您还在等什么呢？让我们开始吧！
- en: Building the UI prototype
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建UI原型
- en: The first step in building any successful application with **complex UI** (even
    simple ones) is prototyping your layout, screens relationship, their state, and
    their navigation. Sketch it on a piece of paper and then get feedback from your
    team and manager. Rework it and, once approved, start building a real interactive
    prototype for your customers, in order to get their feedback for final production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何成功的应用程序的第一步（甚至是简单的应用程序）是原型化您的布局、屏幕关系、它们的状态和导航。在一张纸上草绘，然后从您的团队和经理那里获得反馈。重新修改，一旦获得批准，开始为您的客户构建一个真正的交互式原型，以便获得他们的反馈，以进行最终生产。
- en: This is what we are going to do now, and our application has been laid out on
    piece of paper on any easy to use UI sketcher tools as in the following image.
    We will then develop it with the Scene Builder tool as a complete prototype.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在要做的事情，我们的应用程序已经在易于使用的UI草图工具上布置在一张纸上，如下图所示。然后，我们将使用Scene Builder工具开发它作为一个完整的原型。
- en: In addition, we are going to see the interoperability between NetBeans and the
    Scene builder tool.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将看到NetBeans和Scene Builder工具之间的互操作性。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it is easier to sketch your layout by drawing it on paper first, as
    it is a very quick way to edit, enhance, and figure out the final application
    layout before interacting with the tools to develop it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最好先在纸上画出布局草图，这是在与工具交互之前编辑、增强和找出最终应用程序布局的一种非常快速的方法。
- en: Now, as we have sketched our application, we are ready to build our application's
    real prototype.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经绘制了我们的应用程序，准备构建应用程序的真正原型。
- en: The best way to get the most out of the tools is to create your application
    skeleton (*controller classes and FXML base page definitions*) inside the NetBeans
    IDE, and then create and develop FXML pages inside the Scene builder tool. Here
    comes the powerful interoperability between the two tools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最大限度地利用工具的最佳方法是在NetBeans IDE中创建应用程序骨架（*控制器类和FXML基本页面定义*），然后在Scene Builder工具中创建和开发FXML页面。这就是两个工具之间强大的互操作性。
- en: '![Building the UI prototype](img/B03998_03_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![构建UI原型](img/B03998_03_03.jpg)'
- en: 'Here are the steps to start with JavaFX FXML application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开始使用JavaFX FXML应用程序的步骤：
- en: Open up the NetBeans IDE, and from the main menu, choose **File**, and then
    **New Project** a **New Project** dialog will open. From **Categories**, choose
    **JavaFX**, and then under **Projects**, choose JavaFX FXML Application. Then,
    click on the **Next** button:![Building the UI prototype](img/B03998_03_04.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开NetBeans IDE，从主菜单中选择**文件**，然后选择**新建项目**，将打开一个**新项目**对话框。从**类别**中选择**JavaFX**，然后在**项目**下选择JavaFX
    FXML应用程序。然后，点击**下一步**按钮：![构建UI原型](img/B03998_03_04.jpg)
- en: A new JavaFX FXML application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的JavaFX FXML应用程序
- en: In the **JavaFX FXML application** dialog, add the relevant information. From
    **Project name**, add the location and **FXML name** (in my case, `ListNotesUI`).
    In **Create Application class**, I have added `packt.taman.jfx8.ch3.NoteTakingApp`,
    as shown in the following figure. Hit **Finish**.![Building the UI prototype](img/B03998_03_05.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**JavaFX FXML应用程序**对话框中，添加相关信息。从**项目名称**中，添加位置和**FXML名称**（在我的案例中为`ListNotesUI`）。在**创建应用程序类**中，我已添加`packt.taman.jfx8.ch3.NoteTakingApp`，如下图所示。点击**完成**。![构建UI原型](img/B03998_03_05.jpg)
- en: Now we have a project with the first FXML UI document (`ListNotesUI.fxml`),
    and we need to add the second FXML UI document (`AddEditUI.fxml`) alongside its
    controller.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个带有第一个FXML UI文档（`ListNotesUI.fxml`）的项目，我们需要添加第二个FXML UI文档（`AddEditUI.fxml`）以及其控制器。
- en: To do that from the file, choose **New File**; then, under the **Categories**
    list, choose **JavaFX**, and from the **File Types** list, choose Empty FXML,
    and finally, click on **Next**, as shown in the following figure.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，从文件中选择**新建文件**；然后，在**类别**列表下，选择**JavaFX**，从**文件类型**列表中选择空的FXML，最后，点击**下一步**，如下图所示。
- en: In the **New Empty FXML and Location** dialog, edit the **FXML Name** field
    to be `AddEditUI`, and then click on **Next**.![Building the UI prototype](img/B03998_03_06.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建空的FXML和位置**对话框中，将**FXML名称**字段编辑为`AddEditUI`，然后点击**下一步**。![构建UI原型](img/B03998_03_06.jpg)
- en: Adding a new empty FXML document
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的空的FXML文档
- en: In the Controller Class dialog as in the following screen, tick the **Use Java
    Controller** checkbox. Make sure that **Create New Controller** has been selected,
    with the **Controller Name** as `AddEditUIController`. Then, click on **Next**,
    skip the **Cascading Style Sheet** dialog, and finally, click on **Finish**:![Building
    the UI prototype](img/B03998_03_07.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器类对话框中，勾选**使用Java控制器**复选框。确保已选择**创建新控制器**，并将**控制器名称**设置为`AddEditUIController`。然后，点击**下一步**，跳过**级联样式表**对话框，最后，点击**完成**：![构建UI原型](img/B03998_03_07.jpg)
- en: Adding a new controller to the FXML document
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 向FXML文档添加新控制器
- en: 'As we have built our project structure, it''s time to add our controls into
    our pages UI using Scene Builder, similar to what we sketched on paper. To do
    so is easy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建了项目结构后，就可以使用Scene Builder将控件添加到页面UI中，就像我们在纸上画的那样。这样做很容易：
- en: From NetBeans, right-click on `ListNotesUI.fxml` and select Open or just double-click
    on it. **Scene Builder** will open with your FXML document in design mode.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从NetBeans中，右键单击`ListNotesUI.fxml`并选择打开，或者直接双击它。**Scene Builder**将以设计模式打开您的FXML文档。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: It works only if Scene Builder is installed on your machine.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：仅当Scene Builder安装在您的计算机上时才有效。
- en: Design the page as per the following screenshot. Most importantly, don't forget
    to save your changes before returning back to NetBeans or closing **Scene Builder**
    for logic implementation.![Building the UI prototype](img/B03998_03_08.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下截图设计页面。最重要的是，在返回NetBeans或关闭**Scene Builder**进行逻辑实现之前，不要忘记保存您的更改。![构建UI原型](img/B03998_03_08.jpg)
- en: Complete ListNotesUI.fxml document design
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完成ListNotesUI.fxml文档设计
- en: Perform the same steps for `AddEditUI.fxml`, and your design should end up like
    this:![Building the UI prototype](img/B03998_03_09.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`AddEditUI.fxml`执行相同的步骤，您的设计应该最终如下所示：![构建UI原型](img/B03998_03_09.jpg)
- en: Complete AddEditUI.fxml document design
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 完成AddEditUI.fxml文档设计
- en: You need to check the FXML document to see how we nested many containers and
    UI controls to achieve the desired UI we had sketched earlier, in addition to
    using their properties to control the spacing, alignment, font, and coloring.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要检查FXML文档，看看我们如何嵌套许多容器和UI控件，以实现我们之前在纸上草图中所期望的UI，另外还要使用它们的属性来控制间距、对齐、字体和颜色。
- en: Congratulations! You have converted your sketched layout to something vivid
    that could be presented as a project without logic to your team leaders and managers
    to get their feedback regarding colors, theming, and the final layout. Moreover,
    once it gets approved, you can proceed for the final customer feedback before
    diving deeper into the business logic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经将草图布局转换为可以呈现给团队领导和经理的项目，以获得有关颜色、主题和最终布局的反馈，而不需要逻辑。此外，一旦获得批准，您可以继续进行最终客户反馈，然后再深入业务逻辑。
- en: Bringing your application to life – adding interactions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让您的应用程序生动起来-添加交互
- en: After designing your application, you need to bring it to life by making it
    more interactive and responsive to the functionality it is supposed to perform
    and act on the customer's proposed functional requirement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序后，您需要通过使其更具交互性和响应性来使其更具生命力，以执行和响应客户提出的功能要求。
- en: The first thing I always do is to add the navigation handler from page to page,
    and I have done that in each FXML document controller class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是首先在每个FXML文档控制器中添加页面导航处理程序，我已经在每个FXML文档控制器类中完成了这一点。
- en: To eliminate redundancy and be modular, I have created a base navigation method
    in the `BaseController.java` class, which will be extended by all controllers
    in the system. This class will be useful for adding any common functionality and
    shared attributes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除冗余并实现模块化，我在`BaseController.java`类中创建了一个基本导航方法，该方法将被系统中的所有控制器扩展。这个类将用于添加任何常见功能和共享属性。
- en: 'The following method, `navigate(Event event, URL fxmlDocName)`, is one of the
    most important pieces of code that will be used in all of our system navigation
    (the comments illustrate the working mechanism):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法`navigate(Event event, URL fxmlDocName)`是我们系统中所有导航中最重要的代码之一（注释说明了工作机制）：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method will be called from the action handler of the **New Note** and edit
    button in the `ListNotesUI.fxml` page at `ListNotesUIController.java` and the
    **List Notes**, save, and **Cancel** buttons in the `AddEditUI.fxml` page at `AddEditUIController.java`
    as the following respectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将分别从`ListNotesUI.fxml`页面的**New Note**和编辑按钮的操作处理程序中调用`ListNotesUIController.java`，以及从`AddEditUI.fxml`页面的**List
    Notes**、保存和**Cancel**按钮的操作处理程序中调用`AddEditUIController.java`。
- en: 'Pay attention to the relationship between buttons defined in the FXML document
    and the controller. The `@FXML` annotation comes into play here to bind FXML attributes
    (*using #)* with the defined actions in the controller:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意FXML文档中定义的按钮与控制器之间的关系。`@FXML`注解在这里起作用，将FXML属性（*使用#*）与控制器中定义的操作绑定起来：
- en: 'The **New Note** button definition in the `ListNotesUI.fxml` file is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListNotesUI.fxml`文件中的**New Note**按钮定义如下：'
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **New Note** action is defined in `ListNotesUIController.java`, bound to
    the preceding button using `onAction="#newNote"`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**New Note**操作在`ListNotesUIController.java`中定义，使用`onAction="#newNote"`绑定到前面的按钮：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **Back** button definition in the `AddEditUI.fxml` file is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEditUI.fxml`文件中的**Back**按钮定义如下：'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The **Back** action is defined in `AddEditUIController.java`, bound to the
    preceding button using `onAction="#back"`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Back**操作在`AddEditUIController.java`中定义，使用`onAction="#back"`绑定到前面的按钮：'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may be wondering what the `FXMLPage.java` class does. It is an enum (for
    more about enums, visit [https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)).
    I have created enums to define all our FXML document names and their locations,
    in addition to any utility methods relevant to those FXML document, helping to
    ease coding in our system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道`FXMLPage.java`类做什么。它是一个枚举（有关枚举的更多信息，请访问[https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)）。我已经创建了枚举来定义所有我们的FXML文档名称及其位置，以及与这些FXML文档相关的任何实用方法，以帮助简化我们系统中的编码。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This concept of maintainability helps in large systems to maintain constant
    properties and functionality in one place for future ease of refactoring, and
    allows us to change names in one place instead of roaming all over the system
    to change just one name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可维护性的概念有助于在大型系统中保持常量属性和功能在一个地方进行未来的重构，使我们能够在一个地方更改名称，而不是在整个系统中漫游以更改一个名称。
- en: If you check system controllers, you will find all the logic for handling other
    button's actions – deleting, editing, clearing, and saving notes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查系统控制器，您会发现处理其他按钮操作的所有逻辑 - 删除、编辑、清除和保存笔记。
- en: Power application change synchronization with properties
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用属性实现应用程序更改同步
- en: Properties are wrapper objects for JavaFX-based object attributes such as String
    or Integer. Properties allow you to add listener code to respond when the wrapped
    value of an object has changed or is flagged as invalid. In addition, property
    objects can be bound to one another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是JavaFX基于对象属性的包装对象，例如String或Integer。属性允许您添加监听器代码，以在对象的包装值发生更改或被标记为无效时做出响应。此外，属性对象可以相互绑定。
- en: Binding behavior allows properties to update or synchronize their values based
    on a changed value from another property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定行为允许属性根据另一个属性的更改值更新或同步它们的值。
- en: Properties are wrapper objects that have the ability to make values accessible
    as read/writable or read-only.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是包装对象，具有使值可读/可写或只读的能力。
- en: In short, JavaFX's properties are wrapper objects holding actual values while
    providing change support, invalidation support, and binding capabilities. I will
    address binding later, but for now, let's examine the commonly used property classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JavaFX的属性是包装对象，保存实际值的同时提供更改支持、无效支持和绑定功能。我将在以后讨论绑定，但现在让我们来看看常用的属性类。
- en: All wrapper property classes are located in the `javafx.beans.property.* package`
    namespace. Listed here are the commonly used property classes. To see all of the
    property classes, refer to the documentation in Javadoc ([https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html](https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包装属性类都位于`javafx.beans.property.* package`命名空间中。以下是常用的属性类。要查看所有属性类，请参考Javadoc中的文档（[https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html](https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html)）。
- en: '`javafx.beans.property.SimpleBooleanProperty`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.SimpleBooleanProperty`'
- en: '`javafx.beans.property.ReadOnlyBooleanWrapper`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.ReadOnlyBooleanWrapper`'
- en: '`javafx.beans.property.SimpleIntegerProperty`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.SimpleIntegerProperty`'
- en: '`javafx.beans.property.ReadOnlyIntegerWrapper`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.ReadOnlyIntegerWrapper`'
- en: '`javafx.beans.property.SimpleDoubleProperty`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.SimpleDoubleProperty`'
- en: '`javafx.beans.property.ReadOnlyDoubleWrapper`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.ReadOnlyDoubleWrapper`'
- en: '`javafx.beans.property.SimpleStringProperty`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.SimpleStringProperty`'
- en: '`javafx.beans.property.ReadOnlyStringWrapper`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.beans.property.ReadOnlyStringWrapper`'
- en: The properties that have a prefix of `Simple` and a suffix of `Property` are
    the *read/writable property* classes, and the classes with a prefix of ReadOnly
    and a suffix of Wrapper are the read-only properties. Later, you will see how
    to create a JavaFX bean using these commonly used properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`Simple`前缀和`Property`后缀的属性是*可读/可写属性*类，而具有`ReadOnly`前缀和`Wrapper`后缀的类是只读属性。稍后，您将看到如何使用这些常用属性创建JavaFX
    bean。
- en: Let's fast-forward to JavaFX's Properties API to see how it handles the common
    issues. You may notice that the `TableView` control has been added to the main
    page to list the currently loaded notes and any new added notes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快进到JavaFX的Properties API，看看它如何处理常见问题。您可能会注意到`TableView`控件已经添加到主页面，列出了当前加载的笔记和任何新添加的笔记。
- en: 'In order to populate `TableView` correctly with data, we should have a data
    model to represent the notes data, and this is the first place I used the Properties
    API in the JavaFX JavaBean-style Note class, which is defined as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地填充`TableView`的数据，我们应该有一个数据模型来表示笔记数据，这是我在JavaFX的JavaBean风格的Note类中首次使用Properties
    API的地方，它定义如下：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to populate the `TableView` class with data already stored in the application
    database, for example (our database here is transient using `ObservableList<Note>`
    of the note object called data), we have to pass a collection of this data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用应用程序数据库中已存储的数据填充`TableView`类，例如（我们这里的数据库是使用`ObservableList<Note>`来存储笔记对象的临时数据库），我们必须传递这些数据的集合。
- en: We need to remove the burden of updating the UI control (in our case, the `TableView`
    control) manually each time the notes data collection get updated. Therefore,
    we need a solution to automatically synchronize the changes between the table
    view and notes data collection model, for example, adding, updating, or deleting
    data, without any further modification to the UI controls from the code. Only
    the data model collection gets updated – the UI should be synchronized automatically.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要摆脱手动更新UI控件（在我们的情况下是`TableView`控件）的负担，每当笔记数据集合被更新时。因此，我们需要一个解决方案来自动同步表格视图和笔记数据集合模型之间的更改，例如添加、更新或删除数据，而不需要从代码中对UI控件进行任何进一步的修改。只有数据模型集合被更新
    - UI应该自动同步。
- en: This feature is already an integral part of JavaFX collections. We will use
    JavaFX's `ObservableList` class. The `ObservableList` class is a collection that
    is capable of notifying UI controls when objects are added, updated, or removed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性已经是JavaFX集合的一个组成部分。我们将使用JavaFX的`ObservableList`类。`ObservableList`类是一个集合，能够在对象被添加、更新或移除时通知UI控件。
- en: JavaFX's `ObservableList` class is typically used in list UI controls, such
    as `ListView` and `TableView`. Let's look at how we will use the `ObservableList`
    collection class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX的`ObservableList`类通常用于列表UI控件，比如`ListView`和`TableView`。让我们看看我们将如何使用`ObservableList`集合类。
- en: 'In `BaseController`, I have created static data as `ObservableList<Note>` to
    be shared between all controllers, to be able to add, update, and remove notes
    from it. Also, it is initialized with some data as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BaseController`中，我已经创建了静态数据作为`ObservableList<Note>`，以便在所有控制器之间共享，以便能够向其中添加、更新和删除笔记。同时，它初始化了一些数据，如下所示：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `ListNotesUIController.java` class, inside the `initialize()` method,
    I have created an instance of the `javafx.collections.transformation.FilteredList`
    class that will be used as the filtering class when we search in the table contents.
    It will pass the `data` object of type `ObservableList<Note>` as the source data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListNotesUIController.java`类的`initialize()`方法中，我创建了一个`javafx.collections.transformation.FilteredList`类的实例，当我们在表格内容中搜索时，它将被用作过滤类。它将`ObservableList<Note>`类型的`data`对象作为源数据传递：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second argument of `FilteredList` is the predicate used to filter data;
    here, it returns `true`, meaning no filtration, and we will add the filtration
    predicate later on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilteredList`的第二个参数是用于过滤数据的谓词；在这里，它返回`true`，表示没有过滤，我们将在以后添加过滤谓词。'
- en: 'The created data list of type `ObservableList<Note>` should be passed to our
    `TableView` data in order for the table view to monitor the current data collection
    manipulations, such as addition, deletion, editing, and filtering, as the following
    in the `initialize()` method of the `ListNotesUIController.java` class, but instead
    we have passed the `filteredData` wrapper instance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`ObservableList<Note>`类型的数据列表应该传递给我们的`TableView`数据，以便表格视图监视当前数据集合的操作，比如添加、删除、编辑和过滤，就像在`ListNotesUIController.java`类的`initialize()`方法中所示的那样，但是我们传递了`filteredData`包装实例：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final step is to acknowledge our `notesListTable` columns, of type `TableColumn`,
    and to which property of Note class to render and take care of. We use the `setCellValueFactory()`
    method to do the trick, as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是确认我们的`notesListTable`列，类型为`TableColumn`，以及要呈现和处理Note类的哪个属性。我们使用`setCellValueFactory()`方法来完成，如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `title` and `description` are the instance variable names of the `Note`
    class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`title`和`description`是`Note`类的实例变量名称。
- en: Check the final project code for the full implementation. Then, run the application
    from the NetBeans main menu, choose Run, and then click on **Run Main Project**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查最终项目代码以获取完整的实现。然后，从NetBeans主菜单中运行应用程序，选择运行，然后点击**运行主项目**。
- en: Try to add a new note and watch the table view for your newly added note. Try
    to select and delete the note or update an existing note. You will notice the
    change immediately.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加一个新的笔记，观察表格视图中您新添加的笔记。尝试选择和删除笔记或更新现有的笔记。您会立即注意到变化。
- en: By checking the application code, you will see that all we have done is manipulated
    the data list and all the other synchronization work efforts are carried out with
    the help of the `ObservableList` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查应用程序代码，您会发现我们所做的一切都是操纵数据列表，所有其他的同步工作都是通过`ObservableList`类来完成的。
- en: Filtering the TableView data list
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤TableView数据列表
- en: We will get in touch here with two of the most powerful Java SE 8 and JavaFX
    8 features `Predicate` and `FilteredList`. Let's state the problem we have at
    hand and how we are going to solve it with the `stream` feature.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里接触到两个最强大的Java SE 8和JavaFX 8功能`Predicate`和`FilteredList`。让我们阐明我们手头的问题以及我们将如何使用`stream`功能来解决它。
- en: In our `ListNotesUI.fxml` page, you may notice the text field located above
    the notes table; its purpose here is to filter the current table data to narrow
    the result to get a specific note. Also, we need to maintain the current list
    being careful not to remove any data from it or query the database for each search
    hit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ListNotesUI.fxml`页面中，您可能会注意到位于笔记表格上方的文本字段；它在这里的目的是过滤当前表格数据，以缩小结果以获取特定的笔记。此外，我们需要维护当前的列表，小心不要从中删除任何数据或为每个搜索命中查询数据库。
- en: 'We already have the notes data list and we are going to use the text field
    to filter this list for any note title or description containing this character
    or a combination of characters, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了笔记数据列表，我们将使用文本字段来过滤此列表中包含此字符或字符组合的任何笔记标题或描述，如下所示：
- en: '![Filtering the TableView data list](img/B03998_03_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![过滤TableView数据列表](img/B03998_03_10.jpg)'
- en: Table populated with data
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 填充了数据的表格
- en: Now, after typing in `d`, `de`, `dev`, or `developing`, `JavaFX`, a table will
    be filtered, as seen in the following screenshot. Also, try to remove all the
    text; you will find that the data comes back again. Next, we will discover how
    we did that.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在输入`d`、`de`、`dev`或`developing`、`JavaFX`之后，表格将被过滤，如下截图所示。另外，尝试删除所有文本；您会发现数据会再次出现。接下来，我们将发现我们是如何做到的。
- en: '![Filtering the TableView data list](img/B03998_03_11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![过滤TableView数据列表](img/B03998_03_11.jpg)'
- en: Table data filtered with text in the search field
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用搜索字段中的文本过滤表格数据
- en: 'The following is the magical piece of code that did that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成此操作的神奇代码：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `searchNotes` is a reference to the text field we are using to filter the
    notes data. We have registered it with a `setOnKeyReleased(EventHandler<? super
    KeyEvent> value)` method that gets our text to filter once any character is typed
    in. Also, note that we used the Lambda expression here to make the code more concise
    and clean.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchNotes`是我们用来过滤笔记数据的文本字段的引用。我们已经使用`setOnKeyReleased(EventHandler<? super
    KeyEvent> value)`方法注册了它，一旦输入任何字符，就会获取我们的文本进行过滤。另外，请注意我们在这里使用了Lambda表达式，使代码更加简洁和清晰。'
- en: Inside the definition of the action method, `filteredData` is a `FilteredList<Note>`
    class, we have passed a predicate `test()` method implementation to `setPredicate(Predicate<?
    super E> predicate)` filter only the notes title or a description matching the
    `searchNotes` text input.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作方法的定义内部，`filteredData`是一个`FilteredList<Note>`类，我们已经传递了一个`test()`方法实现给`setPredicate(Predicate<?
    super E> predicate)`，只过滤与`searchNotes`文本输入匹配的笔记标题或描述。
- en: The filtered data is automatically updated to the table UI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤后的数据会自动更新到表格UI中。
- en: For more information about the Predicate API, visit [http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html](http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Predicate API的更多信息，请访问[http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html](http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)。
- en: Note-taking as a desktop application
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为桌面应用程序的笔记
- en: Once you have finished the application, it will be more professional to not
    distribute the final jar and instead ask the user to install the JRE environment
    to be able to run your application, especially if you targeting a large audience.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了应用程序，最好不要分发最终的jar文件，而是要求用户安装JRE环境以便能够运行您的应用程序，特别是如果您的目标是大众。
- en: It's more professional to prepare your native installer packages as `.exe`,
    `.msi`, `.dmg`. or `.img`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 准备您的本机安装程序包作为`.exe`、`.msi`、`.dmg`或`.img`更加专业。
- en: Every installer manages the application requirements from the required assets
    and runtime environments. This ensures that your application will run on multiple
    platforms too.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安装程序都会管理应用程序的要求，从所需的资产和运行时环境。这确保了您的应用程序也可以在多个平台上运行。
- en: Deploying the application for desktop distribution
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为桌面分发部署应用程序
- en: 'One of the advanced NetBeans features is to allow you to bundle your application
    for different platforms via its deployment handler, which gives you the following
    main features:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans的一个高级功能是通过其部署处理程序为不同的平台打包您的应用程序，它提供以下主要功能：
- en: Deploy your application through native installers
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过本机安装程序部署您的应用程序
- en: Manage application assets as application icons, splash screens, and native installer
    icons
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序资产，如应用程序图标、启动画面和本机安装程序图标
- en: Accept the certificate for the final signing of your application when preparing
    the final package
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在准备最终包时，接受应用程序的最终签名证书
- en: Manage the required JavaFX runtime version
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理所需的JavaFX运行时版本
- en: Adding desktop shortcuts of the Start menu when using Windows
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上使用开始菜单添加桌面快捷方式
- en: Handling the Java Web Start technology requirements and customizations
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Java Web Start技术的要求和自定义
- en: 'Let''s see the configuration of NetBeans deployment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看NetBeans部署的配置：
- en: '![Deploying the application for desktop distribution](img/B03998_03_12.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![为桌面分发部署应用程序](img/B03998_03_12.jpg)'
- en: NetBeans deployment configurations
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans部署配置
- en: 'To know how to package your application into the native installer for each
    platform you are targeting, visit the following URL, which provides you with all
    the required steps and software to complete the task:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何将您的应用程序打包成针对每个目标平台的本机安装程序，请访问以下网址，该网址提供了完成任务所需的所有步骤和软件：
- en: '[https://netbeans.org/kb/docs/java/native_pkg.html](https://netbeans.org/kb/docs/java/native_pkg.html)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://netbeans.org/kb/docs/java/native_pkg.html](https://netbeans.org/kb/docs/java/native_pkg.html)'
- en: JavaFX on the Web
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX在Web上
- en: In this section, we will learn about JavaFX on the Web and how to deploy our
    note-taking application there.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习有关JavaFX在Web上的知识，以及如何在那里部署我们的笔记应用程序。
- en: WebEngine
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebEngine
- en: JavaFX provides a non-GUI component capable of loading HTML5 content, called
    the **WebEngine** API (`javafx.scene.web.WebEngine`). This API is basically an
    object instance of the `WebEngine` class to be used to load a file containing
    HTML5 content. The HTML5 file could be loaded from a local file system, a web
    server, or from inside a JAR file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了一个能够加载HTML5内容的非GUI组件，称为**WebEngine** API (`javafx.scene.web.WebEngine`)。这个API基本上是`WebEngine`类的对象实例，用于加载包含HTML5内容的文件。HTML5文件可以从本地文件系统、Web服务器或JAR文件中加载。
- en: When a file is loaded using a web engine object, a background thread is used
    to load the file content to not block the *JavaFX application thread*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web引擎对象加载文件时，会使用后台线程加载文件内容，以免阻塞*JavaFX应用程序线程*。
- en: 'The following are two `WebEngine` methods for loading HTML5 content:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个用于加载HTML5内容的`WebEngine`方法：
- en: load(String URL)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: load(String URL)
- en: loadContent(String HTML)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: loadContent(String HTML)
- en: WebView
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebView
- en: JavaFX provides a GUI `WebView` (`javafx.scene.web.WebView`) node that can render
    HTML5 content onto the Scene graph. A `WebView` node is basically a mini-browser
    that is capable of responding to web events and allows a developer to interact
    with the HTML5 content.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了一个GUI `WebView` (`javafx.scene.web.WebView`)节点，可以将HTML5内容呈现到场景图上。`WebView`节点基本上是一个迷你浏览器，能够响应Web事件，并允许开发人员与HTML5内容进行交互。
- en: Because of the close relationship between loading web content and the ability
    to display web content, the `WebView` node object also contains a `WebEngine`
    instance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加载Web内容和显示Web内容的能力之间的密切关系，`WebView`节点对象还包含一个`WebEngine`实例。
- en: 'The JavaFX 8 `WebView` class implementation provides support for the following
    HTML5 features:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 8的`WebView`类实现支持以下HTML5功能：
- en: Canvas and SVG
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas和SVG
- en: Media playback
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体播放
- en: Form controls
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单控件
- en: History maintenance
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史维护
- en: Interactive element tags
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互元素标签
- en: DOM
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM
- en: Web workers
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web workers
- en: Web sockets
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web sockets
- en: Web fonts
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web字体
- en: WebView and engine in action
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebView和引擎的操作
- en: 'We are going to have a simple example of how to load an HTML5 web document
    that contains Google Maps integrated with JavaFX as the scene control using `WebView`.
    We then use `WebEngine` to get the longitude and latitude from the JavaFX `TextField`
    controls to execute a JavaScript method that passes those parameters to position
    the map to be centered to the newly passed position with the marker indication,
    as shown in the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示一个简单的示例，演示如何使用`WebView`将包含Google地图的HTML5网页文档集成到JavaFX中作为场景控件。然后，我们使用`WebEngine`从JavaFX
    `TextField`控件中获取经度和纬度，执行一个JavaScript方法，将这些参数传递给地图，使地图居中显示在新传递的位置，并显示标记，如下图所示：
- en: '![WebView and engine in action](img/B03998_03_13.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![WebView and engine in action](img/B03998_03_13.jpg)'
- en: The Google Maps viewer from the JavaFX 8 application
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 8应用程序中的Google地图查看器
- en: For the sake of clarity, I will show and explain only the important parts of
    the code, which demonstrates the concept mentioned in the preceding paragraph.
    For the complete code in this chapter, check the `web` package code `GoogleMapViewerFX.java`
    class and `map.html` file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我将只展示和解释代码中的重要部分，这演示了前面段落中提到的概念。有关本章中的完整代码，请查看`web`包代码`GoogleMapViewerFX.java`类和`map.html`文件。
- en: 'To view Google Maps inside the JavaFX application, we need to first create
    an HTML file to load and integrate with the Maps API, and this is defined in the
    `map.html` file. As seen in the preceding picture, the location is centered on
    Cairo, Egypt, my city, and this is set as the longitude and latitude values passed
    to the map when we create it, as in the following code snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaFX应用程序中查看Google地图，我们需要首先创建一个HTML文件，加载并集成Maps API，这在`map.html`文件中定义。如前面的图片所示，位置居中于埃及开罗，我的城市，这是在创建地图时传递给地图的经度和纬度值，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we have to notice the JavaScript `goToLocation(lng, lat)` method; this
    will be called from the JavaFX application using the `webEngine` instance to position
    the map based on the passed longitude and latitude from the JavaFX controls.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要注意JavaScript `goToLocation(lng, lat)`方法；这将从JavaFX应用程序中使用`webEngine`实例调用，根据从JavaFX控件中传递的经度和纬度来定位地图。
- en: 'Inside `GoogleMapViewerFX.java`, we have created four controls to compose our
    UI – two `TextField` classes for the longitude and latitude, one update button,
    and a `WebView` object to view the `map.html` document:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GoogleMapViewerFX.java`中，我们创建了四个控件来组成我们的UI - 两个用于经度和纬度的`TextField`类，一个更新按钮，以及一个用于查看`map.html`文档的`WebView`对象：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that I have created text controls with the initial longitude and latitude,
    which is different from the original map position. This position is my home position,
    and you can change it to yours and hit update to view the new position.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经创建了带有初始经度和纬度的文本控件，这与原始地图位置不同。这个位置是我的家庭位置，你可以将它改为你的位置，然后点击更新以查看新位置。
- en: To load the `map.html` file, we have to pass it to the `WebEngine` class that
    we created from the `WebView` class we have created already, as seen in the previous
    code snippet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`map.html`文件，我们必须将其传递给我们已经创建的`WebView`类中创建的`WebEngine`类，如前面的代码片段所示。
- en: 'Implement the button''s `onAction()` method to allow integration between JavaFX
    controls and JavaScript using the `webEngine` `executeScript()` method, as in
    the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现按钮的`onAction()`方法，允许JavaFX控件和JavaScript之间的集成，使用`webEngine`的`executeScript()`方法，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the application and you should see the previous figure positioned to Cairo
    city! Hit update and you should reach my home, as seen in the following figure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该看到前面的图像定位在开罗城！点击更新，你应该到达我的家，如下图所示。
- en: Try getting your position longitude and latitude; then go to your home too!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试获取您的位置经度和纬度；然后也回到您的家！
- en: Powerful, isn't it? It is very easy to integrate HTML5 content and interact
    with already developed web applications to add more rich content from the Web
    to your existing JavaFX application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很强大，不是吗？很容易集成HTML5内容，并与已经开发的Web应用程序进行交互，以在现有的JavaFX应用程序中添加更丰富的Web内容。
- en: '![WebView and engine in action](img/B03998_03_14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![WebView和engine在操作中](img/B03998_03_14.jpg)'
- en: Change the Google Map position in the JavaFX 8 application
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX 8应用程序中更改Google地图位置
- en: Note-taking as a web application
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为Web应用程序的笔记
- en: Once your application is tested, as we have discussed before, you can distribute
    your application to multiple platforms and environments. We did that already for
    desktops with native installers using the distributed in this chapter, `.jar`
    file under the project's `dist` folder.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序经过测试，就像我们之前讨论的那样，您可以将您的应用程序分发到多个平台和环境。我们已经在本章中使用分发的方式为桌面应用程序做了这样的操作，使用项目的`dist`文件夹下的`.jar`文件。
- en: The same `.jar` file will be used for web deployment, and the application could
    be deployed as a web application in many ways, as we will see next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`.jar`文件将用于Web部署，并且应用程序可以以多种方式部署为Web应用程序，我们将在接下来看到。
- en: Running the application for the Web
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Web运行应用程序
- en: 'There are three ways to run your JavaFX application on the Web:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式可以在Web上运行您的JavaFX应用程序：
- en: Using **Java Web Start** to download and start your application once; then,
    you can use it offline from your machine
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Java Web Start**下载和启动应用程序一次；然后，您可以在离线状态下从您的计算机上使用它
- en: Embed your JAR into your HTML file to run from an enterprise environment
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的JAR嵌入到HTML文件中，以便在企业环境中运行
- en: Load your HTML content from the `WebEngine` class and view it from the `WebView`
    class, as discussed previously
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`WebEngine`类加载HTML内容，并从`WebView`类中查看它，如前所述
- en: Java Web Start
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Java Web Start
- en: The Java Web Start software provides the power to launch full-featured applications
    with a single click. Users can download and launch applications, such as a complete
    spreadsheet program or an Internet chat client, without going through lengthy
    installation procedures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Java Web Start软件提供了通过单击启动功能齐全的应用程序的能力。用户可以下载和启动应用程序，例如完整的电子表格程序或互联网聊天客户端，而无需经过冗长的安装过程。
- en: With Java Web Start, users can launch a Java application by clicking on a link
    on a web page. The link points to a **JNLP** (**Java Network Launch Protocol**)
    file, which instructs Java Web Start to download, cache, and run the application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java Web Start，用户可以通过单击Web页面上的链接来启动Java应用程序。该链接指向一个**JNLP**（Java网络启动协议）文件，该文件指示Java
    Web Start下载、缓存和运行应用程序。
- en: 'Java Web Start provides Java developers and users with many deployment advantages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Java Web Start为Java开发人员和用户提供了许多部署优势：
- en: With Java Web Start, you can place a single Java application on a web server
    for deployment to a wide variety of platforms, including Windows, Linux, and Solaris.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java Web Start，您可以将单个Java应用程序放在Web服务器上，以便部署到包括Windows、Linux和Solaris在内的各种平台上。
- en: It supports multiple simultaneous versions of the Java platform. An application
    can request a specific version of the Java Runtime Environment (JRE) software
    without conflicting with the needs of other applications.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持Java平台的多个同时版本。应用程序可以请求特定版本的Java Runtime Environment（JRE）软件，而不会与其他应用程序的需求发生冲突。
- en: Users can create a desktop shortcut to launch a Java Web Start application outside
    a browser.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以创建一个桌面快捷方式来启动Java Web Start应用程序，而不需要浏览器。
- en: Java Web Start takes advantage of the inherent security of the Java platform.
    By default, applications have restricted access to local disk and network resources.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Web Start利用了Java平台固有的安全性。默认情况下，应用程序对本地磁盘和网络资源的访问受到限制。
- en: Applications launched with Java Web Start are cached locally for improved performance.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java Web Start启动的应用程序会在本地缓存，以提高性能。
- en: Updates to a Java Web Start application are automatically downloaded when the
    application is run standalone from the user's desktop.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Java Web Start应用程序的更新在应用程序从用户的桌面独立运行时会自动下载。
- en: Java Web Start is installed as part of the JRE software. Users do not have to
    install Java Web Start separately or perform additional tasks to use Java Web
    Start applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Java Web Start作为JRE软件的一部分安装。用户不需要单独安装Java Web Start或执行其他任务来使用Java Web Start应用程序。
- en: 'For more information about **Java Web Start**, see the following links:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**Java Web Start**的更多信息，请参阅以下链接：
- en: Java Web Start Guide ([http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html](http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html))
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Web Start指南（[http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html](http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html)）
- en: The `javax.jnlp` API Documentation ([http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html](http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html))
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.jnlp` API文档（[http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html](http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html)）'
- en: The Java Web Start Developers Site ([http://www.oracle.com/technetwork/java/javase/javawebstart/index.html](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html))
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Web Start开发者网站（[http://www.oracle.com/technetwork/java/javase/javawebstart/index.html](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)）
- en: Deploying the application for a web distribution
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Web分发应用程序
- en: To deploy your JavaFX applications on to the Web, there is a very simple way
    using NetBeans.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的JavaFX应用程序部署到Web上，可以使用NetBeans的一种非常简单的方法。
- en: 'NetBeans already provides three deployment types for your JavaFX application
    – desktop, Java Web Start, and Web-as seen in the following figure:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans已经为您的JavaFX应用程序提供了三种部署类型 - 桌面、Java Web Start和Web，如下图所示：
- en: '![Deploying the application for a web distribution](img/B03998_03_15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![为Web分发应用程序](img/B03998_03_15.jpg)'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So far, we have been learning how to develop JavaFX enterprise applications
    for both desktops and the Web.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在学习如何为桌面和Web开发JavaFX企业应用程序。
- en: In this chapter, we gained the skills to develop any application, starting with
    sketching a layout on a piece of paper; next, we translated it into an actual
    interactive, colorful UI prototype. We saw how to nest our containers and controls
    to achieve the desired layout. Once we got the approvals for final development,
    we brought the application to life by making it respond to customer actions and
    by delivering the functional requirements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们掌握了开发任何应用程序的技能，从在纸上草绘布局开始；接下来，我们将其转化为实际的交互式、丰富多彩的UI原型。我们看到了如何嵌套容器和控件以实现所需的布局。一旦我们获得了最终开发的批准，我们通过使其响应客户操作并提供功能要求，使应用程序栩栩如生。
- en: We made our code more powerful, clean, and concise with the power of Java SE
    8 features and JavaFX bindings. Finally, we learned how to deploy our application
    either to the target desktop customers or Web users for different platforms and
    environments.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用Java SE 8功能和JavaFX绑定使我们的代码更加强大、干净和简洁。最后，我们学会了如何将我们的应用程序部署到目标桌面客户端或Web用户，以适应不同的平台和环境。
- en: In the next chapter, we are going to learn how to develop a JavaFX application
    for Android-based smart phones. Additionally, we will learn the required skills
    to download and install Android SDK tools and interact with loggers, emulators,
    and other tools that will help you in any future mobile development you need to
    do that isn't related to JavaFX.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为基于Android的智能手机开发JavaFX应用程序。此外，我们还将学习下载和安装Android SDK工具以及与记录器、模拟器和其他工具进行交互的必要技能，这些工具将帮助您进行任何与JavaFX无关的未来移动开发。
