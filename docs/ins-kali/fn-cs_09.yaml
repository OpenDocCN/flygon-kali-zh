- en: Chapter 9. Working with Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用模式匹配
- en: 'In the previous chapter, we discussed optimizing code to develop efficient
    code. Now, we are going to discuss the pattern that will make our code flow in
    a regular order so that it will be easier to maintain and understand the flow
    of the program. The main topics we are going to discuss in this chapter are pattern
    matching and Monad as a design pattern. Pattern matching will match the condition
    using a mathematical approach so that we will get a functional taste of things.
    And Monad is an inseparable part of the functional programming since it''s a design
    pattern for complex problems in software design. Using Monad, we can give more
    power to existing data types by amplifying their behavior. This chapter will look
    further into pattern matching and `Monad` , and we will discuss the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了优化代码以开发高效的代码。现在，我们将讨论使我们的代码流程按照规则进行的模式，以便更容易维护和理解程序的流程。我们将在本章中讨论的主要主题是模式匹配和Monad作为一种设计模式。模式匹配将使用数学方法匹配条件，以便我们能够从中获得功能性的体验。而Monad是函数式编程中不可分割的一部分，因为它是软件设计中复杂问题的设计模式。使用Monad，我们可以通过放大它们的行为来为现有的数据类型提供更多的功能。本章将进一步探讨模式匹配和`Monad`，我们将讨论以下主题：
- en: Understanding pattern matching in functional programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数式编程中的模式匹配
- en: Transforming data and switching decisions using pattern matching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式匹配转换数据和切换决策
- en: Simplifying pattern matching in order to make it more functional
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化模式匹配以使其更加功能化
- en: Testing pattering matching feature in C# 7
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C# 7中测试模式匹配功能
- en: Finding out which C# types implement Monad naturally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出哪些C#类型自然实现了Monad
- en: Generating monadic types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成单子类型
- en: Understanding the rules of Monad
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Monad的规则
- en: Dissecting pattern matching in functional programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖函数式编程中的模式匹配
- en: 'In functional programming, pattern matching is a form of dispatch to choose
    the correct variant of the functions to be called. It''s actually inspired by
    a standard mathematical notation with the syntax to express conditional execution.
    We can start our discussion on matching pattern by borrowing the code from [Chapter
    1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in C#") , *Tasting
    Functional Style in C#* , when we talked about recursion. The following is the
    `GetFactorial()` functional we used to retrieve a factorial value:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，模式匹配是一种分派形式，用于选择要调用的函数的正确变体。它实际上是受标准数学符号的启发，具有表达条件执行的语法。我们可以从[第1章](text00016.html#ch01
    "第1章。在C#中品尝函数式风格")中借用代码，*在C#中品尝函数式风格*，当我们谈论递归时开始我们的模式匹配讨论。以下是我们用来检索阶乘值的`GetFactorial()`函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see in the preceding code, it gives us two definitions. In this case,
    the dispatcher is chosen based on whether the actual `intNumber` parameter pattern
    matches 0 or not. The use of the pattern matching are closer to this `if` conditional
    expression since we have to decide which section will be selected by providing
    a specific input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，它给了我们两个定义。在这种情况下，调度程序是根据实际的`intNumber`参数模式是否匹配0来选择的。模式匹配的使用更接近于这个`if`条件表达式，因为我们必须决定通过提供特定的输入来选择哪个部分。
- en: Transforming data using pattern matching
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模式匹配转换数据
- en: 'Pattern matching is somehow transforming data. Let''s borrow another function
    from the previous chapter to continue the discussion. As we might remember, we
    had a function in the extension method called `IsPrime()` to check whether or
    not it is a prime number. We will use it again to demonstrate pattern matching
    to transform data. For those who have forgotten the implementation of the `IsPrime()`
    function, here is the code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配在某种程度上是在转换数据。让我们从上一章借用另一个函数继续讨论。也许我们还记得，在扩展方法中有一个名为`IsPrime()`的函数，用于检查一个数是否是质数。我们将再次使用它来演示模式匹配来转换数据。对于那些忘记了`IsPrime()`函数实现的人，这里是代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, we use pattern matching to determine whether the number is a prime number,
    composite number, or neither. However, now we will transform the `int` number
    into text, as we can see in the following `NumberFactorType()` function, which
    we can find in the `MatchingPattern.csproj` project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用模式匹配来确定数字是质数、合数还是其他。然而，现在我们将把`int`数字转换为文本，正如我们在`MatchingPattern.csproj`项目中找到的`NumberFactorType()`函数中所看到的：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we can see in the preceding code, we use the `if...else` conditional statement
    to match the condition instead of the `if` conditional statement we used in the
    previous example. Now, let''s call the `NumberFactorType()` function to match
    the int number we give and transform it into text using the following `TransformIntIntoText()`
    function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`if...else`条件语句来匹配条件，而不是在前面的示例中使用的`if`条件语句。现在，让我们调用`NumberFactorType()`函数来匹配我们给定的整数，并使用以下的`TransformIntIntoText()`函数将其转换为文本：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We pass the number 0 to 9 into the `NumberFactorType()` function to get a matching
    result. And if we run the `TransformIntIntoText()` function, we get the following
    output on the console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数字0到9传递给`NumberFactorType()`函数以获得匹配的结果。如果我们运行`TransformIntIntoText()`函数，我们将在控制台上得到以下输出：
- en: '![Transforming data using pattern matching](img/Image00106.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用模式匹配转换数据](img/Image00106.jpg)'
- en: As you can see from the preceding screenshot, we have successfully used pattern
    matching to transform `int` into text.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，我们已经成功地使用模式匹配将`int`转换为文本。
- en: Switching for pattern matching
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于模式匹配的切换。
- en: 'We know that pattern matching can transform data into another form. This is
    actually similar to the `Select()` method in LINQ and conceptually similar to
    the switch case statement. Now let''s take a look at the following `HexCharToByte()`
    function to convert a hexadecimal character into `byte` :'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道模式匹配可以将数据转换为另一种形式。这实际上类似于LINQ中的`Select()`方法，并在概念上类似于switch case语句。现在让我们看一下以下的`HexCharToByte()`函数，将十六进制字符转换为`byte`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we add a wrapper to convert the hexadecimal in string into `int` , as
    shown in the following `HexStringToInt()` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个包装器将字符串中的十六进制转换为`int`，如下面的`HexStringToInt()`函数所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the preceding code, we can see that we call the `HexCharToByte()` function
    to get each `int` value for each hexadecimal character. Then, we use the power
    of 16 to get all the hexadecimal values. Suppose we have the following `GetIntFromHexString()`
    function to convert several hexadecimal digits in a string into `int` :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到，我们调用`HexCharToByte()`函数为每个十六进制字符获取每个`int`值。然后，我们使用16的幂来获取所有十六进制值。假设我们有以下`GetIntFromHexString()`函数来将字符串中的多个十六进制数字转换为`int`：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the `GetIntFromHexString()` function, we get the following output
    on the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`GetIntFromHexString()`函数，我们将在控制台上得到以下输出：
- en: '![Switching for pattern matching](img/Image00107.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![用于模式匹配的切换](img/Image00107.jpg)'
- en: As you can see in the preceding screenshot, each hexadecimal character in the
    string is converted into the `int` value and then it sums up all the results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，字符串中的每个十六进制字符都被转换为`int`值，然后将所有结果相加。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To convert a hexadecimal character into a byte, we can use the `Parse` and `TryParse`
    methods or format it using the `String.Format` . `HexCharToByte()` function we
    discussed earlier, which is for sample purposes only.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十六进制字符转换为字节，我们可以使用`Parse`和`TryParse`方法，或者使用`String.Format`进行格式化。`HexCharToByte()`函数仅用于示例目的。
- en: Simplifying pattern matching
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化模式匹配
- en: 'We have successfully used the `switch` statement to implement pattern matching.
    However, the example doesn''t apply a functional approach since the `res` variable
    in the `HexCharToByte()` function is mutated during execution. Now, we are going
    to refactor the `HexCharToByte()` function in order to apply a functional approach.
    Let''s take a look at the following `HexCharToByteFunctional()` function, which
    can be found in the `SimplifyingPatternMatching.csproj` project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功使用`switch`语句来实现模式匹配。但是，该示例并未应用函数式方法，因为`HexCharToByte()`函数中的`res`变量在执行过程中被改变。现在，我们将重构`HexCharToByte()`函数以应用函数式方法。让我们来看看`SimplifyingPatternMatching.csproj`项目中的`HexCharToByteFunctional()`函数：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding `HexCharToByteFunctional()` function is refactored from the `HexCharToByte()`
    function and now implements the functional approach. As you can see, we have four
    methods similar to the `switch` statement or the `if...else` condition statement: `Match()`
    , `With()` , `Else()` , and `Do()` . Let''s take a look at the following `Match()`
    function used by the preceding `HexCharToByteFunctional()` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`HexCharToByteFunctional()`函数是从`HexCharToByte()`函数重构而来，现在实现了函数式方法。正如您所看到的，我们有四种类似于`switch`语句或`if...else`条件语句的方法：`Match()`，`With()`，`Else()`和`Do()`。让我们来看看前面的`HexCharToByteFunctional()`函数使用的`Match()`函数：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the `Match()` function returns the new `PatternMatchContext`
    data type. The `PatternMatchContext` class implementation is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Match()`函数返回新的`PatternMatchContext`数据类型。`PatternMatchContext`类的实现如下：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the `Match()` function generates a new instance of `PatternMatchContext`
    , its constructor stores the value passed as an argument to the `_value` private
    variable, as shown in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Match()`函数生成`PatternMatchContext`的新实例时，其构造函数将传递的值存储到`_value`私有变量中，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this `PatternMatchContext` class, there is also a method called `With()`
    , which we can compare with the `_value` value. The method will invoke the `With()`
    method inside the `PatternMatchOnValue` class, the implementation of which is
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`PatternMatchContext`类中，还有一个名为`With()`的方法，我们可以将其与`_value`值进行比较。该方法将调用`PatternMatchOnValue`类中的`With()`方法，其实现如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see from the preceding code, when the `With()` method, which is
    a member of the `PatternMatchContext` class, returns a new instance of `PatternMatchOnValue`
    , its constructor also stores the value to the `_value` private variable, as shown
    in the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的代码中所看到的，当`With()`方法（它是`PatternMatchContext`类的成员）返回`PatternMatchOnValue`的新实例时，其构造函数也将值存储到`_value`私有变量中，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It then calls the `With()` method, which is passed an anonymous method as `condition`
    and an expected value as `result` , as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`With()`方法，该方法将匿名方法作为`condition`和预期值作为`result`传递，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `With()` method then calls another `With()` method, which passes `Predicate<T>`
    and `Func<T1, T2>` as shown in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`With()`方法然后调用另一个`With()`方法，该方法传递`Predicate<T>`和`Func<T1, T2>`，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `With()` method collects all cases and stores them in the `_cases` list
    typed as `PatternMatchCase` , the implementation of which is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`With()`方法收集所有情况，并将它们存储在`_cases`列表中，类型为`PatternMatchCase`，其实现如下所示：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we have provided all the conditions, we call the `Else()` method, which
    contains the default result. The implementation of the `Else()` method is as shown
    in the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提供了所有条件，我们调用`Else()`方法，其中包含默认结果。`Else()`方法的实现如下所示：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then invoke another `Else()` method passing `Func<T1, T2>` , as shown in
    the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用另一个`Else()`方法，传递`Func<T1, T2>`，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After we collect all `_cases` and `_elseCase` variables, we have to invoke
    the `Do()` method to compare all cases. The implementation of the `Do()` method
    can be seen in the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集所有`_cases`和`_elseCase`变量之后，我们必须调用`Do()`方法来比较所有情况。`Do()`方法的实现如下所示：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the `Do(` ) method will assign the `_elseCase` variable, if
    any, to the `_cases` list using the `With()` method, as shown in the following
    code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Do()`方法将使用`With()`方法将`_elseCase`变量（如果有的话）分配给`_cases`列表，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It then compares all `_cases` list members using the `foreach` loop to find
    the correct _`value` value using the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码片段比较所有`_cases`列表成员，以找到正确的`_value`值：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Although invoking the `Else()` method is optional, it''s mandatory to match
    one of all the `With()` method invocations. If not, the `Do()` method will throw
    an `IncompletePatternMatchException` exception, as shown in the following code
    snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调用`Else()`方法是可选的，但必须匹配所有`With()`方法的调用之一。如果不匹配，`Do()`方法将抛出`IncompletePatternMatchException`异常，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For now, we don''t need to implement anything in the `IncompletePatternMatchException`
    exception, so we just need to create a new class implementation `Exception` class,
    as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要在`IncompletePatternMatchException`异常中实现任何内容，所以我们只需要创建一个新的类实现`Exception`类，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Until here, we have successfully refactored the `HexCharToByte()` function
    into the `HexCharToByteFunctional()` function. We can modify the `HexStringToInt()`
    function to invoke the `HexCharToByteFunctional()` function, as shown in the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功地将`HexCharToByte()`函数重构为`HexCharToByteFunctional()`函数。我们可以修改`HexStringToInt()`函数以调用`HexCharToByteFunctional()`函数，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, the `HexStringToInt()` function does not implement the functional
    approach. We can refactor it to the `HexStringToIntFunctional()` function, as
    shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`HexStringToInt()`函数并没有实现功能性方法。我们可以将其重构为`HexStringToIntFunctional()`函数，如下所示：
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the preceding `HexStringToIntFunctional()` function, we can see that,
    first, we convert the strings into a list of characters by reversing the order
    of the list. This is because we need to assign the least significant byte with
    the lowest index. We then select each member of the list and create a new class
    that contains the character itself and the index. Afterwards, we sum them up based
    on their index and value. Now, we have the following `GetIntFromHexStringFunctional()`
    function, and it invokes the `HexStringToIntFunctional()` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`HexStringToIntFunctional()`函数中，我们可以看到，首先，我们将字符串转换为字符列表，通过颠倒列表的顺序。这是因为我们需要将最低有效字节分配给最低索引。然后，我们选择列表的每个成员，并创建一个包含字符本身和索引的新类。然后，我们根据它们的索引和值对它们进行求和。现在，我们有了以下的`GetIntFromHexStringFunctional()`函数，并调用了`HexStringToIntFunctional()`函数：
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is actually similar to the `GetIntFromHexString()` function in the `MatchingPattern.csproj`
    project. If we run the `GetIntFromHexStringFunctional()` function, we will get
    the following output on the console:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上与`MatchingPattern.csproj`项目中的`GetIntFromHexString()`函数类似。如果我们运行`GetIntFromHexStringFunctional()`函数，我们将在控制台上得到以下输出：
- en: '![Simplifying pattern matching](img/Image00108.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![简化模式匹配](img/Image00108.jpg)'
- en: As you can see, we get the exact same output compared to the `GetIntFromHexString()`
    function in the `MatchingPattern.csproj` project since we have successfully refactored
    it to functional pattern matching.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，与`MatchingPattern.csproj`项目中的`GetIntFromHexString()`函数相比，我们得到了完全相同的输出，因为我们已经成功地将其重构为功能模式匹配。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a simpler method in pattern matching, we can use the `Simplicity` NuGet
    package, which we can download directly from Visual Studio using **Package Manager
    Console** and typing `Install-PackageSimplicity` .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化模式匹配的方法，我们可以使用`Simplicity` NuGet包，我们可以直接从Visual Studio使用**Package Manager
    Console**下载，并输入`Install-PackageSimplicity`。
- en: Welcoming the coming of pattern matching feature in C# 7
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎C# 7中模式匹配功能的到来
- en: 'The planned language features in C# 7 includes pattern matching which has the
    extensions to the `is` operator. We now can introduce a new variable after the
    type and this variable is assigned to the left-hand side operand of the `is` operator
    but with the type specified as the right-hand side operand. Let''s make it clear
    using the following code snippet which we can find in `MatchingPatternCSharp7.csproj`
    project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7中计划的语言特性包括模式匹配，它对`is`运算符进行了扩展。现在我们可以在类型之后引入一个新变量，并且将这个变量赋值给`is`运算符的左操作数，但类型指定为右操作数。让我们通过下面的代码片段来清楚地说明这一点，我们可以在`MatchingPatternCSharp7.csproj`项目中找到：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the `GetData()` function implementation is as follow:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetData()`函数的实现如下：'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding `IsOperatorBeforeCSharp7()` function, we should assign `s`
    variable with the value of `o` after we check the content of the `o` object variable
    in `if` statement. It is what we can do before C# 7 introduce pattern matching
    feature. Now, let''s compare the preceding code with the following `IsOperatorInCSharp7()`
    function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`IsOperatorBeforeCSharp7()`函数中，我们应该在检查`o`对象变量的内容后，将`s`变量赋值为`o`的值。这是在C# 7引入模式匹配功能之前我们可以做的。现在，让我们将前面的代码与以下`IsOperatorInCSharp7()`函数进行比较：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we now can assign `s` variable with the content of `o` variable
    but with the string data type, as we have discussed earlier. We assign the `s`
    variable inside the `if` statement when the condition is checked.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在我们可以将`s`变量赋值为`o`变量的内容，但数据类型为字符串，正如我们之前讨论的那样。我们在检查条件时在`if`语句内部为`s`变量赋值。
- en: 'Fortunately, this feature can also be applied in switch statement as we can
    see in the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个特性也可以应用在switch语句中，正如我们在下面的代码片段中所看到的：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see in the preceding `SwitchCaseInCSharp7()` function, we can assign
    `s` and `i` variable with the content of `x` variable in the `case` checking so
    we don't need to assign the variable again.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的`SwitchCaseInCSharp7()`函数中所看到的，我们可以在`case`检查中将`s`和`i`变量赋值为`x`变量的内容，因此我们不需要再次赋值变量。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about pattern matching feature in C# 7, we can find it
    in official Roslyn GitHub page on [https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md](https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关C# 7中模式匹配功能的更多信息，我们可以在官方Roslyn GitHub页面上找到：[https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md](https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md)
- en: Introducing Monad as a design pattern
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Monad作为一种设计模式
- en: 'It''s quite difficult to explain **Monad** in an **object-oriented programming**
    ( **OOP** ) language such as C#. However, in OOP, there is one useful idea to
    explain Monad: design patterns. A design pattern is a reusable solution for complex
    problems in software design. Imagine a design pattern in architecture. Many buildings
    in this world must have the same pattern: doors, windows, walls, and so on. If
    we compare design patterns in architecture with design patterns in software design,
    we''ll realize that they both have the same idea. In a design pattern for software
    design, we have functions, types, variables, and so on. These design pattern have
    been available in the C# language and will come together to build an application.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）语言如C#中很难解释Monad。然而，在OOP中，有一个有用的想法可以解释Monad：设计模式。设计模式是软件设计中复杂问题的可重用解决方案。想象一下建筑中的设计模式。世界上许多建筑都必须具有相同的模式：门、窗户、墙壁等。如果我们将建筑中的设计模式与软件设计中的设计模式进行比较，我们会意识到它们都有相同的想法。在软件设计的设计模式中，我们有函数、类型、变量等。这些设计模式已经在C#语言中可用，并将一起构建应用程序。
- en: Considering this design pattern definition, we now have a definition of Monad
    itself. Monad is a type that uses a Monad pattern. And the Monad pattern is a
    design pattern for types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个设计模式的定义，我们现在有了Monad本身的定义。Monad是一种使用Monad模式的类型。而Monad模式是一种用于类型的设计模式。
- en: In C#, there are some types that have actually implemented Monad naturally;
    they are `Nullable<T>` , `IEnumerable<T>` , `Func<T>` , `Lazy<T>` , and `Task<T>`
    . Some of these types had been discussed in the previous chapter. However, we
    will discuss them again in correlation with an explanation of Monad.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有一些类型实际上自然实现了Monad；它们是`Nullable<T>`、`IEnumerable<T>`、`Func<T>`、`Lazy<T>`和`Task<T>`。其中一些类型在前一章中已经讨论过。然而，我们将再次讨论它们，并与Monad的解释相关联。
- en: These five types have several things in common; obviously, they are generic
    types that take only one parameter, `T` . They implement monad naturally since
    they have certain rules that have certain operations provided; in other words,
    they are amplifiers of types. They can take a type and turn it into a special
    type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这五种类型有一些共同点；显然，它们都是只接受一个参数`T`的泛型类型。它们自然实现了monad，因为它们有一定的规则和提供的操作；换句话说，它们是类型的放大器。它们可以接受一个类型并将其转换为特殊类型。
- en: We can say that `Nullable<T>` is an amplifier of types because it can turn,
    for instance, `int` to null, which is impossible without the use of `Nullable<T>`
    since `int` can only handle `-2,147,483,648` to `2,147,483,647` .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说`Nullable<T>`是一种类型的放大器，因为它可以将，例如，`int`转换为null，而如果没有使用`Nullable<T>`是不可能的，因为`int`只能处理`-2,147,483,648`到`2,147,483,647`。
- en: 'Let''s take a look at the following code, which we can find in the `AmplifierOfTypes.csproj`
    project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在`AmplifierOfTypes.csproj`项目中可以找到的以下代码：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will convert the number in the `string` type into the `int`
    type. However, since the `string` type is allowed to be null, the `int` type will
    not be able to handle this data type. For this purpose, we use `Nullable<int>`
    as a return type; so now, the returning value can be null, as shown in the following
    code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将把`string`类型中的数字转换为`int`类型。然而，由于`string`类型允许为null，`int`类型将无法处理这种数据类型。为此，我们使用`Nullable<int>`作为返回类型；因此，现在返回值可以为null，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can invoke the preceding `WordToNumber()` function using the following
    `PrintStringNumber()` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下`PrintStringNumber()`函数调用前面的`WordToNumber()`函数：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can return `null` to the `int` data type since it has become a `Nullable`
    type, as shown in the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`int`数据类型返回`null`，因为它已经成为了`Nullable`类型，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code snippet will handle the null string input that is passed
    to the `WordToNumber()` function. And now we can invoke the preceding `PrintStringNumber()`
    function using the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将处理传递给`WordToNumber()`函数的空字符串输入。现在我们可以使用以下代码调用前面的`PrintStringNumber()`函数：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we run the `PrintIntContainingNull()` function, we will get the following
    output on the console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`PrintIntContainingNull()`函数，将在控制台上得到以下输出：
- en: '![Introducing Monad as a design pattern](img/Image00109.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![将Monad引入为一种设计模式](img/Image00109.jpg)'
- en: From the preceding screenshot, you can see that we now can give the `int` data
    types' `null` value since it has implemented monad naturally and has been amplified
    using the amplifier of types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，您可以看到我们现在可以给`int`数据类型的`null`值，因为它已经自然实现了monad，并且已经使用类型的放大器进行了放大。
- en: '`IEnumerable<T>` also implements monad because it can amplify the type of `T`
    we pass to `IEnumerable<T>` . Suppose we want to amplify the string type using
    `IEnumerable<T>` in order for it to be enumerated and sorted; we can use the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`也实现了monad，因为它可以放大我们传递给`IEnumerable<T>`的`T`类型。假设我们想要使用`IEnumerable<T>`来放大字符串类型，以便对其进行枚举和排序；我们可以使用以下代码：'
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `AmplifyString()` function, we are going to show that we can leverage
    the `string` type to store multiple values and represent the enumeration and sorting,
    as shown in the following code snippet, to initialize the enumerable string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AmplifyString()`函数中，我们将展示如何利用`string`类型来存储多个值，并表示枚举和排序，如下面的代码片段所示，用于初始化可枚举字符串：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use the following code snippet to sort the enumerable string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段对可枚举字符串进行排序：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the `YieldNames()` function we use to initialize the
    enumerable string is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来初始化可枚举字符串的`YieldNames()`函数的实现如下：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the implementation of the `SortAscending()` function that we use to sort
    the enumerable string will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来对可枚举字符串进行排序的`SortAscending()`函数的实现如下：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, in the `YieldNames()` function implementation, the function
    will yield five people-name-typed strings. These people names will be kept in
    the `stringEnumerable` variable typed `IEnumerable<string>` . It becomes obvious
    that `stringEnumerable` has now been leveraged so that it can handle multiple
    values. And in the `SortAscending()` function, we can see that `stringEnumerable`
    has been leveraged so that it can be sorted and ordered. If we run the preceding
    `AmplifyString()` function, we will get the following output on the console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在`YieldNames()`函数的实现中，函数将产生五个以人名命名的字符串。这些人名将被保存在类型为`IEnumerable<string>`的`stringEnumerable`变量中。很明显，`stringEnumerable`现在已经被利用，以便它可以处理多个值。在`SortAscending()`函数中，我们可以看到`stringEnumerable`已经被利用，以便它可以被排序和排序。如果我们运行上述的`AmplifyString()`函数，我们将在控制台上得到以下输出：
- en: '![Introducing Monad as a design pattern](img/Image00110.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![将Monad作为设计模式介绍](img/Image00110.jpg)'
- en: From the preceding screenshot, we can see that we have successfully amplified
    the `string` type so it can now enumerate multiple `string` values and can sort
    their values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述的截图中，我们可以看到我们已经成功地放大了`string`类型，使其现在可以枚举多个`string`值并对它们进行排序。
- en: 'As we have discussed in many ways in the previous chapter, `Func<T>` is an
    encapsulate method that returns a value of the type specified by the `T` parameter
    with no need to pass any parameter. For this purpose, we will create the following
    `Func<T>` method in our `AmplifiedFuncType.csproj` project:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的许多方式，`Func<T>`是一个封装方法，它返回由`T`参数指定的类型的值，而不需要传递任何参数。为此，我们将在我们的`AmplifiedFuncType.csproj`项目中创建以下的`Func<T>`方法：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`MultipliedFunc` is a delegate that will take care of a function that returns
    the `int` value with no passing argument. Now, the following code will explain
    that `Func<T>` also implements monad naturally. However, before we go through
    with the `Func<T>` explanation, we are going to create a wrapper using the `Nullable`
    type we discussed earlier. Let''s take a look at the following `MultipliedByTwo()`
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultipliedFunc`是一个委托，将负责处理返回`int`值的不需要传递参数的函数。现在，以下代码将解释`Func<T>`也自然实现了monad。然而，在我们进行`Func<T>`解释之前，我们将使用我们之前讨论过的`Nullable`类型创建一个包装器。让我们来看看以下的`MultipliedByTwo()`函数：'
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `GetNullableFromInt()` function in the `MultipliedByTwo()` function has
    the following implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNullableFromInt()`函数在`MultipliedByTwo()`函数中有以下实现：'
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `MultipliedByTwo()` function is simple. Obviously, it will wrap the unwrapped
    value after we perform the multiplication operator on that unwrapped value. Suppose
    we have the following `RunMultipliedByTwo()` function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultipliedByTwo()`函数很简单。显然，在我们对未包装的值执行乘法运算后，它将包装未包装的值。假设我们有以下的`RunMultipliedByTwo()`函数：'
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we run the preceding `RunMultipliedByTwo()` function, we will have the following
    output on the console:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述的`RunMultipliedByTwo()`函数，我们将在控制台上得到以下输出：
- en: '![Introducing Monad as a design pattern](img/Image00111.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![将Monad作为设计模式介绍](img/Image00111.jpg)'
- en: From the preceding screenshot, you can see that there's a general pattern provided
    by the function. The unwrapped 1, 2, 3, 4, 5 will be multiplied by two and will
    be wrapped into 2, 4, 6, 8, 10.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述的截图中，您可以看到函数提供了一个通用模式。未包装的1、2、3、4、5将被乘以2，并被包装成2、4、6、8、10。
- en: 'Now, we are going to explain `Func<T>` . Let''s create the following `GetFuncFromInt()`
    function, which will return the value typed `Func<int>` :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释`Func<T>`。让我们创建以下的`GetFuncFromInt()`函数，它将返回类型为`Func<int>`的值：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding `GetFuncFromInt()` function will generate a brand new `Func<T>`
    method from the `int` value. Again, we will create the `MultipliedByTwo()` function
    but with a different signature, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`GetFuncFromInt()`函数将从`int`值生成一个全新的`Func<T>`方法。同样，我们将创建`MultipliedByTwo()`函数，但具有不同的签名，如下：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding will successfully compile. However, suppose we have the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将成功编译。但是，假设我们有以下代码：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we run the preceding `RunMultipliedByTwoFunc()` function, we will get the
    fixed result `4` rather that the formula `(1 + 1) * 4` . To solve this problem,
    we can create new code as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述的`RunMultipliedByTwoFunc()`函数，我们将得到固定的结果`4`，而不是公式`(1 + 1) * 4`。为了解决这个问题，我们可以创建如下的新代码：
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the preceding `MultipliedByTwoFunction()` function, the original function
    delegate value is kept every time the new value is requested. And now we can conclude
    that our previous code will use the unwrapped value and then perform some operation
    on it. There are differences between using the `Nullable<int>` operation and the
    `Func<int>` operation, such as how the wrapped type result is created. Using the
    `Nullable` monad, we can directly use the unwrapped value , perform a computation,
    and then produce the wrapped value. Using `Func` Monad, however, we have to be
    smarter since, as we discussed earlier, we have to produce a delegate in order
    to keep the previous `Func` Monad.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述的`MultipliedByTwoFunction()`函数，每次请求新值时都会保留原始函数委托值。现在我们可以得出结论，我们之前的代码将使用未包装的值，然后对其进行一些操作。使用`Nullable<int>`操作和`Func<int>`操作之间存在差异，例如如何创建包装类型的结果。使用`Nullable`
    monad，我们可以直接使用未包装的值，执行计算，然后产生包装的值。然而，使用`Func` Monad，我们必须更加聪明，因为正如我们之前讨论的，我们必须产生一个委托以保留先前的`Func`
    Monad。
- en: And in Monad, we can see that by multiplying two into the wrapped `int` , the
    function can produce another wrapped `int` so that we can call it *amplification*
    .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Monad中，我们可以看到通过将2乘以包装的`int`，函数可以产生另一个包装的`int`，以便我们可以称之为*放大*。
- en: Creating the Monadic M<T> type
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Monadic M<T>类型
- en: 'Now, we are going to implement higher-order programming in monad by refactoring
    our previous code. Let''s take a look at the following `MultipliedByTwoFunction()`
    function, which we can find in the `GeneratingMonadInCSharp.csproj` project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过重构我们之前的代码来实现monad中的高阶编程。让我们来看看`GeneratingMonadInCSharp.csproj`项目中可以找到的以下`MultipliedByTwoFunction()`函数：
- en: '[PRE48]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From the preceding `MultipliedByTwoFunction()` function, you can see that we
    now use `Func<int, int>` , which passes an integer argument to produce an integer
    result. We also get the `Nullable<int>` parameter directly from the argument now.
    And we can have the following `MultipliedByTwo()` function get the value of multiplying
    by two:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`MultipliedByTwoFunction()`函数中可以看出，我们现在使用`Func<int, int>`，它传递一个整数参数来产生一个整数结果。我们现在也直接从参数中获取`Nullable<int>`参数。我们可以让以下的`MultipliedByTwo()`函数得到乘以二的值：
- en: '[PRE49]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding `MultipliedByTwo()` function, we see that we define the `iNullable`
    value and the anonymous method, as shown in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`MultipliedByTwo()`函数中，我们看到我们定义了`iNullable`值和匿名方法，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And suppose we have the following `RunMultipliedByTwo()` function to call the
    `MultipliedByTwo()` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下的`RunMultipliedByTwo()`函数来调用`MultipliedByTwo()`函数：
- en: '[PRE51]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we run the preceding `RunMultipliedByTwo()` function, we will get the following
    output on the console screen:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`RunMultipliedByTwo()`函数，我们将在控制台屏幕上得到以下输出：
- en: '![Creating the Monadic M<T> type](img/Image00112.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![创建Monadic M<T>类型](img/Image00112.jpg)'
- en: As you can see from the preceding screen shot, we have successfully refactored
    our `MultipliedByTwo()` function in the `AmplifiedFuncType.csproj` project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看出，我们已成功重构了`AmplifiedFuncType.csproj`项目中的`MultipliedByTwo()`函数。
- en: Implementing the generic data type to Monad
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通用数据类型实现到Monad
- en: 'We can also make our previous `MultipliedByTwo()` function more general by
    implementing generics, as shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过实现泛型使我们之前的`MultipliedByTwo()`函数更加通用，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And if for some reason we need to have a function that passes an integer value
    but results in a double-for instance, and we want to divide an integer number,
    we can amplify that function so that it can modify the value from `int` to `double`
    , as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们需要一个传递整数值但结果为双精度的函数-例如，我们想要除以一个整数，我们可以放大该函数，以便它可以将值从`int`修改为`double`，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And since `Nullable` is a amplification of type in the preceding `MultipliedByTwoFunction()`
    method, we can modify it to any other types, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Nullable`是在前面的`MultipliedByTwoFunction()`方法中的类型放大，我们可以将它修改为任何其他类型，如下所示：
- en: '[PRE54]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As we discussed earlier, `MultipliedByTwoFunction()` has a monad pattern since
    it passes a value of a particular type and turns it into a value of the amplified
    type. In other words, we have a function that has a pattern to turn a function
    from `V` to `R` into a function from `M<V>` to `M<R>` , where `M<R>` is an amplified
    type. This is so that we can write a method that has a Monad pattern like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，`MultipliedByTwoFunction()`具有单子模式，因为它传递特定类型的值并将其转换为放大类型的值。换句话说，我们有一个函数，它有一个模式，可以将从`V`到`R`的函数转换为从`M<V>`到`M<R>`的函数，其中`M<R>`是一个放大的类型。这样我们就可以编写一个具有单子模式的方法，如下所示：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we have a monadic `M<T>` type, which is to be used if we need to implement
    a Monad pattern in our function. However, if we take a look at our previous `MultipliedByTwoFunction<V,
    R>()` method, we can see that there is something we can improve in it, as shown
    in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个单子`M<T>`类型，如果我们需要在函数中实现单子模式，就可以使用它。然而，如果我们看一下我们之前的`MultipliedByTwoFunction<V,
    R>()`方法，我们会发现有一些可以改进的地方，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have modified the second parameter from `Func<V, R>` to `Func<V, Nullable<R>>`
    . This is done to prevent an inappropriate result, such as `Nullable<Nullable<double>>`
    , if we expect the return type `Nullable<double>` . We can also implement it to
    another type, such as `Func<T>` , as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将第二个参数从`Func<V, R>`修改为`Func<V, Nullable<R>>`。这样做是为了防止出现不合适的结果，比如`Nullable<Nullable<double>>`，如果我们期望的返回类型是`Nullable<double>`。我们还可以实现到另一个类型，比如`Func<T>`，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Implementing Monad to Lazy<T> and Task<T>
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Monad实现到Lazy<T>和Task<T>
- en: 'Besides type `Func<T>` , we can also implement Monad to `Lazy<T>` and `Task<T>`
    , as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型`Func<T>`，我们还可以将单子实现到`Lazy<T>`和`Task<T>`，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Also, we can implement it for `IEnumerable<T>` . The code will be as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以为`IEnumerable<T>`实现它。代码如下：
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After we dissect the `MultipliedByTwoFunctionSpecial()` function for various
    data types, such as `Nullable` , `Func` , `Lazy` , `Task` , and `IEnumerable`
    , we can see that a monadic type has flattened `M<M<R>>` into `M<R>` . We can
    see that, when using the `Nullable` type, we have to avoid making `Nullable<Nullable<R>>`
    by checking whether the passing `Nullable` type''s argument has a value. If not,
    just return a null `Nullable<R>` type, as shown in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对各种数据类型进行了`MultipliedByTwoFunctionSpecial()`函数的解剖之后，比如`Nullable`，`Func`，`Lazy`，`Task`和`IEnumerable`，我们可以看到单子类型已经将`M<M<R>>`扁平化为`M<R>`。我们可以看到，当使用`Nullable`类型时，我们必须避免创建`Nullable<Nullable<R>>`，通过检查传递的`Nullable`类型的参数是否有值。如果没有，就返回一个空的`Nullable<R>`类型，如下面的代码片段所示：
- en: '[PRE60]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we use task, we also have to await the outer task and then await the inner
    task to avoid creating a `<Task<R>>` task, as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用任务时，我们还必须等待外部任务，然后等待内部任务，以避免创建`<Task<R>>`任务，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The other monadic types have the same pattern.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其他单子类型也有相同的模式。
- en: Rules of the Monad pattern
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子模式的规则
- en: 'We have discussed that the Monad pattern will always wrap up a value typed
    `T` into an instance of `M<T>` , as shown in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，单子模式将始终将类型为`T`的值包装到`M<T>`的实例中，如下面的代码片段所示：
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Also, in the monad pattern, we can transform the instance of `M<V>` to an instance
    of `M<R>` if we have a function from `V` to `R` , as shown in the following code
    snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在单子模式中，如果我们有一个从`V`到`R`的函数，我们可以将`M<V>`的实例转换为`M<R>`的实例，如下面的代码片段所示：
- en: '[PRE63]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another rule the Monad pattern has is that we can transform the type of `V`
    to an instance of `M<R>` and then apply it to an instance of `M<V>` if we have
    a function from `V` to `M<R>` , as shown in the following code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 单子模式的另一个规则是，如果我们有一个从`V`到`M<R>`的函数，我们可以把`V`的类型转换为`M<R>`的实例，然后应用到`M<V>`的实例上，就像下面的代码片段所示：
- en: '[PRE64]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Pattern matching is a form of dispatch to choose the correct variant of functions
    to be called. In other words, its concept is close to the `if` conditional expression
    because we have to decide the correct selection by providing specific input. The
    matching process can be simplified to make it implement a functional approach.
    We discussed the `switch` case and then refactored it using LINQ so it became
    functional.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种选择正确的函数变体的分发形式。换句话说，它的概念接近于`if`条件表达式，因为我们必须通过提供特定的输入来决定正确的选择。匹配过程可以简化为实现函数式方法。我们讨论了`switch`情况，然后使用LINQ进行了重构，使其变得函数式。
- en: 'We learned the definition of monad itself: a type that uses the Monad pattern,
    which is a design pattern for types. In C#, there are some types that have implemented
    Monad naturally; they are `Nullable<T>` , `IEnumerable<T>` , `Func<T>` , `Lazy<T>`
    , and `Task<T>` .'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了单子本身的定义：一种使用单子模式的类型，单子模式是一种类型的设计模式。在C#中，有一些类型自然地实现了单子模式；它们是`Nullable<T>`，`IEnumerable<T>`，`Func<T>`，`Lazy<T>`和`Task<T>`。
- en: For now, we have enough knowledge about functional programming in C#. In the
    next chapter, we will use everything you learned in this and previous chapters
    to develop an application that implements a functional approach. In the upcoming
    chapter, we will transform imperative code into functional code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对C#中的函数式编程有足够的了解。在下一章中，我们将运用你在本章和之前章节学到的知识来开发一个实现函数式方法的应用程序。在即将到来的章节中，我们将把命令式代码转换为函数式代码。
