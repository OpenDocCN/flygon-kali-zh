- en: Chapter 1. Kubernetes and Container Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Kubernetes和容器操作
- en: This chapter will give a brief overview of containers and how they work as well
    as why management and orchestration is important to your business and/or project
    team. The chapter will also give a brief overview of how **Kubernetes** orchestration
    can enhance our container management strategy and how we can get a basic Kubernetes
    cluster up, running, and ready for container deployments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要概述容器的工作原理，以及为什么管理和编排对您的业务和/或项目团队至关重要。本章还将简要概述Kubernetes编排如何增强我们的容器管理策略，以及如何启动、运行和准备容器部署的基本Kubernetes集群。
- en: 'This chapter will include the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括以下主题：
- en: Introducing container operations and management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍容器操作和管理
- en: Why container management is important
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么容器管理很重要
- en: Advantages of Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes的优势
- en: Downloading the latest Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载最新的Kubernetes
- en: Installing and starting up a new Kubernetes cluster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和启动新的Kubernetes集群
- en: A brief overview of containers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的简要概述
- en: Over the past two years, **containers** have grown in popularity like wildfire.
    You would be hard-pressed to attend an IT conference without finding popular sessions
    on Docker or containers in general.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两年里，**容器**像野火一样风靡。在IT会议上，你很难找到没有关于Docker或容器的热门会议。
- en: Docker lies at the heart of the mass adoption and the excitement in the container
    space. As Malcom Mclean revolutionized the physical shipping world in 1957 by
    creating a standardized shipping container, which is used today for everything
    from ice cube trays to automobiles¹, Linux containers are revolutionizing the
    software development world by making application environments portable and consistent
    across the infrastructure landscape. As an organization, Docker has taken the
    existing container technology to a new level by making it easy to implement and
    replicate across environments and providers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是容器领域大规模采用和激动人心的核心。正如Malcom Mclean在1957年通过创建标准化的集装箱彻底改变了物理航运世界一样，这种集装箱今天被用于从冰盒到汽车等各种物品¹，Linux容器正在通过使应用环境在基础设施领域中可移植和一致，彻底改变软件开发世界。作为一个组织，Docker通过使容器技术易于在各种环境和提供商中实施和复制，将现有的容器技术提升到了一个新的水平。
- en: What is a container?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: At the core of container technology are cGroups and namespaces. Additionally,
    Docker uses union file systems for added benefits to the container development
    process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术的核心是cGroups和命名空间。此外，Docker还使用联合文件系统来增强容器开发过程的好处。
- en: '**Control groups** (**cGroups**) work by allowing the host to share and also
    limit the resources each process or container can consume. This is important for
    both, resource utilization and security, as it prevents **denial-of-service attacks**
    on the host''s hardware resources. Several containers can share CPU and memory
    while staying within the predefined constraints.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制组**（**cGroups**）通过允许主机共享和限制每个进程或容器可以消耗的资源来工作。这对资源利用和安全性都很重要，因为它可以防止对主机硬件资源的**拒绝服务攻击**。多个容器可以共享CPU和内存，同时保持在预定义的约束范围内。'
- en: '**Namespaces** offer another form of isolation in the way of processes. Processes
    are limited to see only the process ID in the same namespace. Namespaces from
    other system processes would not be accessible from a container process. For example,
    a network namespace would isolate access to the network interfaces and configuration,
    which allows the separation of network interfaces, routes, and firewall rules.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**提供了另一种进程隔离的形式。进程只能看到同一命名空间中的进程ID。来自其他系统进程的命名空间对容器进程是不可访问的。例如，网络命名空间会隔离对网络接口和配置的访问，从而实现对网络接口、路由和防火墙规则的分离。'
- en: '![What is a container?](../images/00002.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![什么是容器？](../images/00002.jpeg)'
- en: Figure 1.1\. Composition of a container
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1。容器的组成
- en: '**Union file systems** are also a key advantage to using Docker containers.
    The easiest way to understand union file systems is to think of them like a layer
    cake with each layer baked independently. The Linux kernel is our base layer;
    then, we might add an OS like **Red Hat Linux** or **Ubuntu**. Next, we might
    add an application like **Nginx** or **Apache**. Every change creates a new layer.
    Finally, as you make changes and new layers are added, you''ll always have a top
    layer (think frosting) that is a writable layer.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合文件系统**也是使用Docker容器的一个关键优势。理解联合文件系统最简单的方法是将它们想象成一个分层蛋糕，每一层都是独立烘烤的。Linux内核是我们的基础层；然后，我们可能添加一个像**Red
    Hat Linux**或**Ubuntu**的操作系统。接下来，我们可能添加一个像**Nginx**或**Apache**的应用程序。每次更改都会创建一个新的层。最后，随着您进行更改并添加新的层，您将始终有一个顶层（想象成糖霜）作为可写层。'
- en: '![What is a container?](../images/00003.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![什么是容器？](../images/00003.jpeg)'
- en: Figure 1.2\. Layered file system
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2。分层文件系统
- en: What makes this truly efficient is that Docker caches the layers the first time
    we build them. So, let's say that we have an image with Ubuntu and then add Apache
    and build the image. Next, we build MySQL with Ubuntu as the base. The second
    build will be much faster because the Ubuntu layer is already cached. Essentially,
    our chocolate and vanilla layers, from Figure 1.2, are already baked. We simply
    need to bake the pistachio (MySQL) layer, assemble, and add the icing (writable
    layer).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使这真正高效的是Docker在第一次构建层时缓存了这些层。所以，假设我们有一个包含Ubuntu的镜像，然后添加Apache并构建镜像。接下来，我们使用Ubuntu作为基础构建MySQL。第二次构建将会快得多，因为Ubuntu层已经被缓存。基本上，我们的巧克力和香草层，来自图1.2，已经烘烤好了。我们只需要烘烤开心果（MySQL）层，组装并添加糖衣（可写层）。
- en: Why are containers so cool?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么容器如此酷？
- en: Containers on their own are not a new technology and have in fact been around
    for many years. What truly sets Docker apart is the tooling and ease of use they
    have brought to community.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器本身并不是一项新技术，实际上已经存在多年。Docker真正突出的是他们为社区带来的工具和易用性。
- en: Advantages to Continuous Integration/Continuous Deployment
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成/持续部署的优势
- en: Wikipedia defines **Continuous Integration** as "the practice, in software engineering,
    of merging all developer working copies to a shared mainline several times a day."
    By having a continuous process of building and deploying code organizations are
    able to instill quality control and testing as part of the everyday work cycle.
    The result is that updates and bug fixes happen much faster and overall quality
    improves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科将**持续集成**定义为“在软件工程中，一天内多次将所有开发人员的工作副本合并到共享主干的实践。”通过持续构建和部署代码的过程，组织能够将质量控制和测试融入日常工作周期。结果是更新和错误修复发生得更快，整体质量得到提高。
- en: However, there has always been a challenge in setting development environments
    to match that of testing and production. Often inconsistencies in these environments
    make it difficult to gain the full advantage of continuous delivery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一直以来，设置开发环境以匹配测试和生产环境一直是一个挑战。这些环境的不一致经常使得难以充分利用持续交付的优势。
- en: Using Docker, developers are now able to have truly portable deployments. Containers
    that are deployed on a developer's laptop are easily deployed on an in-house staging
    server. They are then easily transferred to the production server running in the
    cloud. This is because Docker builds containers up with build files that specify
    parent layers. One advantage of this is that it becomes very easy to ensure OS,
    package, and application versions are the same across development, staging, and
    production environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，开发人员现在能够拥有真正可移植的部署。在开发人员的笔记本电脑上部署的容器可以轻松地部署在内部的暂存服务器上。然后它们可以轻松地转移到在云中运行的生产服务器上。这是因为Docker使用构建文件构建容器，这些文件指定了父层。其中一个优点是，这样可以非常容易地确保开发、暂存和生产环境中的操作系统、软件包和应用程序版本是相同的。
- en: Because all the dependencies are packaged into the layer, the same host server
    can have multiple containers running a variety of OS or package versions. Further,
    we can have various languages and frameworks on the same host server without the
    typical dependency clashes we would get in a **Virtual Machine** (**VM**) with
    a single operating system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有的依赖都打包到层中，所以同一台主机服务器可以运行多个容器，运行各种不同的操作系统或软件包版本。此外，我们可以在同一台主机服务器上拥有各种语言和框架，而不会像在单一操作系统的虚拟机中那样出现典型的依赖冲突。
- en: Resource utilization
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源利用
- en: The well-defined isolation and layer filesystem also make containers ideal for
    running systems with a very small footprint and domain-specific purposes. A streamlined
    deployment and release process means we can deploy quickly and often. As such,
    many companies have reduced their deployment time from weeks or months to days
    and hours in some cases. This development life cycle lends itself extremely well
    to small, targeted teams working on small chunks of a larger application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义的隔离和层文件系统也使容器非常适合运行具有非常小的占用空间和特定领域目的的系统。简化的部署和发布流程意味着我们可以快速而频繁地部署。因此，许多公司已经将部署时间从几周或几个月缩短到几天甚至几小时。这种开发生命周期非常适合小型、有针对性的团队在大型应用程序的小块上工作。
- en: Microservices and orchestration
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和编排
- en: As we break down an application into very specific domains, we need a uniform
    way to communicate between all the various pieces and domains. Web services have
    served this purpose for years, but the added isolation and granular focus that
    containers bring have paved a way for what is being named **microservices**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序分解为非常具体的领域时，我们需要一种统一的方式来在所有不同的部分和领域之间进行通信。多年来，Web服务一直在发挥这种作用，但容器带来的额外隔离和粒度聚焦为所谓的“微服务”铺平了道路。
- en: 'The definition for microservices can be a bit nebulous, but a definition from
    Martin Fowler, a respected author and speaker on software development, says²:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务的定义可能有些模糊，但软件开发领域的知名作者和演讲者Martin Fowler的定义是：
- en: '*"In short, the microservice architectural style is an approach to developing
    a single application as a suite of small services, each running in its own process
    and communicating with lightweight mechanisms, often an HTTP resource API. These
    services are built around business capabilities and independently deployable by
    fully automated deployment machinery. There is a bare minimum of centralized management
    of these services, which may be written in different programming languages and
    use different data storage technologies."*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个服务在自己的进程中运行，并使用轻量级机制进行通信，通常是HTTP资源API。这些服务围绕业务能力构建，并且可以通过完全自动化的部署机制独立部署。这些服务的集中管理最少，可以使用不同的编程语言编写，并使用不同的数据存储技术。”
- en: As the pivot to containerization and microservices evolves in an organization,
    they will soon need a strategy to maintain many containers and microservices.
    Some organizations will have hundreds or even thousands of containers running
    in the years ahead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组织向容器化和微服务的转变，他们很快将需要一种策略来维护许多容器和微服务。一些组织在未来几年将有数百甚至数千个容器在运行。
- en: Future challenges
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来的挑战
- en: Life cycle processes alone are an important piece of operations and management.
    How will we automatically recover when a container fails? Which upstream services
    are affected by such an outage? How will we patch our applications with minimal
    downtime? How will we scale up our containers and services as our traffic grows?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期流程本身也是运营和管理的重要组成部分。当容器失败时，我们将如何自动恢复？哪些上游服务会受到这样的中断影响？我们将如何在最小化停机时间的情况下对我们的应用程序进行修补？随着流量的增长，我们将如何扩展我们的容器和服务？
- en: Networking and processing are also important concerns. Some processes are part
    of the same service and may benefit from proximity on the network. Databases,
    for example, may send large amounts of data to a particular microservice for processing.
    How will we place containers *near* each other in our cluster? Is there common
    data that needs to be accessed? How will new services be discovered and made available
    to other systems?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和处理也是重要的关注点。一些进程是同一服务的一部分，并且可能受益于在网络上的接近。例如，数据库可能会向特定的微服务发送大量数据进行处理。我们将如何在我们的集群中将容器*靠近*彼此？是否有需要访问的共同数据？新服务将如何被发现并提供给其他系统使用？
- en: Resource utilization is also a key. The small footprint of containers means
    that we can optimize our infrastructure for greater utilization. Extending the
    savings started in the elastic cloud world even further towards minimizing wasted
    hardware. How will we schedule workloads most efficiently? How will we ensure
    that our important applications always have the resources? How can we run less
    important workloads on spare capacity?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 资源利用率也是一个关键因素。容器的小占地面积意味着我们可以优化基础设施，实现更大的利用率。进一步延伸弹性云世界中开始的节约，以最小化浪费的硬件。我们将如何最有效地安排工作负载？我们将如何确保我们重要的应用程序始终拥有资源？我们如何在备用容量上运行不太重要的工作负载？
- en: Finally, portability is a key factor in moving many organizations to containerization.
    Docker makes it very easy to deploy a standard container across various operating
    systems, cloud providers, and on-premise hardware, or even developer laptops.
    However, we still need tooling to move containers around. How will we move containers
    between different nodes on our cluster? How will we roll out updates with minimal
    disruption? What process do we use to perform blue-green deployments or canary
    releases?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可移植性是让许多组织转向容器化的关键因素。Docker使得在各种操作系统、云提供商和本地硬件，甚至开发人员的笔记本电脑上部署标准容器变得非常容易。然而，我们仍然需要工具来移动容器。我们将如何在集群的不同节点之间移动容器？我们将如何在最小干扰下推出更新？我们使用什么流程来执行蓝绿部署或金丝雀发布？
- en: Whether you are starting to build out individual microservices and separating
    concerns into isolated containers or if you simply want to take full advantage
    of the portability and immutability in your application development, the need
    for management and orchestration becomes clear.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是开始构建单独的微服务并将关注点分离到隔离的容器中，还是只是想充分利用应用程序开发中的可移植性和不变性，对管理和编排的需求都变得清晰起来。
- en: Advantages of Kubernetes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的优势
- en: This is where orchestration tools such as Kubernetes offer the biggest value.
    **Kubernetes** (**K8s**) is an open source project that was released by Google
    in June, 2014\. Google released the project as part of an effort to share their
    own infrastructure and technology advantage with the community at large.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编排工具如Kubernetes提供最大价值的地方。**Kubernetes**（**K8s**）是一个开源项目，由Google于2014年6月发布。Google发布该项目是为了与社区分享他们自己的基础设施和技术优势。
- en: Google launches 2 billion containers a week in their infrastructure and has
    been using container technology for over a decade. Originally they were building
    a system named **Borg**, and now **Omega**, to schedule their vast quantities
    of workloads across their ever-expanding data center footprint. They took many
    of the lessons they learned over the years and rewrote their existing data center
    management tool for wide adoption by the rest of the world. The result was the
    Kubernetes open source project³.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Google每周在他们的基础设施中启动20亿个容器，并且已经使用容器技术超过十年。最初，他们正在构建一个名为**Borg**的系统，现在是**Omega**，用于在不断扩大的数据中心中调度大量的工作负载。他们吸取了多年来学到的许多经验教训，并重新编写了他们现有的数据中心管理工具，以便被世界其他地方广泛采用。结果就是Kubernetes开源项目³。
- en: Since its initial release in 2014, K8s has undergone rapid development with
    contributions all across the open source community, including Red Hat, VMware,
    and Canonical. The 1.0 release of Kubernetes went live in July, 2015\. We'll be
    covering version 1.0 throughout the book. K8s gives organizations a tool to deal
    with some of the major operations and management concerns. We will explore how
    Kubernetes helps deal with resource utilization, high availability, updates, patching,
    networking, service discovery, monitoring, and logging.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自2014年首次发布以来，K8s已经经历了快速发展，得到了整个开源社区的贡献，包括Red Hat、VMware和Canonical。Kubernetes
    1.0版本于2015年7月发布。本书将涵盖1.0版本。K8s为组织提供了一种处理一些主要运营和管理问题的工具。我们将探讨Kubernetes如何帮助处理资源利用、高可用性、更新、打补丁、网络、服务发现、监控和日志记录。
- en: Our first cluster
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个集群
- en: Kubernetes is supported on a variety of platforms and OSes. For the examples
    in this book, I used an Ubuntu 14.04 Linux VirtualBox for my client and **Google
    Compute Engine** (**GCE**) with Debian for the cluster itself. We will also take
    a brief look at a cluster running on **Amazon Web Services** (**AWS**) with Ubuntu.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持各种平台和操作系统。在本书的示例中，我使用了Ubuntu 14.04 Linux VirtualBox作为客户端，**Google
    Compute Engine**（**GCE**）上使用了Debian作为集群本身。我们还将简要介绍在**Amazon Web Services**（**AWS**）上运行的集群，使用的是Ubuntu。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Most of the concepts and examples in this book should work on any installation
    of a Kubernetes cluster. To get more information on other platform setups, check
    the Kubernetes getting started page on the following GitHub link:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分概念和示例应该适用于任何Kubernetes集群的安装。要获取有关其他平台设置的更多信息，请查看以下GitHub链接上的Kubernetes入门页面：
- en: '[https://github.com/GoogleCloudPlatform/kubernetes/blob/v1.0.0/docs/getting-started-guides/README.md](https://github.com/GoogleCloudPlatform/kubernetes/blob/v1.0.0/docs/getting-started-guides/README.md)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/GoogleCloudPlatform/kubernetes/blob/v1.0.0/docs/getting-started-guides/README.md](https://github.com/GoogleCloudPlatform/kubernetes/blob/v1.0.0/docs/getting-started-guides/README.md)'
- en: First, let's make sure that our environment is properly set up before we install
    Kubernetes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在安装Kubernetes之前，让我们确保我们的环境设置正确。
- en: 'Start by updating packages:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从更新软件包开始：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install Python and curl if they are not present:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，请安装Python和curl：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install the **gcloud** SDK:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装**gcloud** SDK：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will need to start a new shell before `gcloud` is on our path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gcloud`出现在我们的路径之前，我们需要启动一个新的shell。
- en: 'Configure your **Google Cloud Platform** (**GCP**) account information. This
    should automatically open a browser where we can log in to our Google Cloud account
    and authorize the SDK:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置您的**Google Cloud Platform**（**GCP**）帐户信息。这应该会自动打开一个浏览器，我们可以在其中登录到我们的Google
    Cloud帐户并授权SDK：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have problems with login or want to use another browser, you can optionally
    use the `--no-launch-browser` command. Copy and paste the URL to the machine and/or
    browser of your choice. Log in with your Google Cloud credentials and click on
    **Allow** on the permissions page. Finally, you should receive an authorization
    code that you can copy and paste back into the shell where the prompt is waiting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您登录时遇到问题或想要使用其他浏览器，可以选择使用`--no-launch-browser`命令。将URL复制并粘贴到您选择的机器和/或浏览器中。使用您的Google
    Cloud凭据登录，并在权限页面上单击**允许**。最后，您应该收到一个授权代码，可以将其复制并粘贴回等待提示的shell中。
- en: 'A default project should be set, but we can check this with the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 应该设置一个默认项目，但我们可以使用以下命令进行检查：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can modify this and set a new default project with this command. Make sure
    to use *project ID* and not *project name*, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此命令修改并设置一个新的默认项目。请确保使用*项目ID*而不是*项目名称*，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We can find our project ID in the console at:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台中找到我们的项目ID：
- en: '[https://console.developers.google.com/project](https://console.developers.google.com/project)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://console.developers.google.com/project](https://console.developers.google.com/project)'
- en: 'Alternatively, we can list active projects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以列出活动项目：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have our environment set up, installing the latest Kubernetes version
    is done in a single step as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经设置好，安装最新的Kubernetes版本只需一步即可完成：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It may take a minute or two to download Kubernetes depending on your connection
    speed. After this, it will automatically call the `kube-up.sh` script and start
    building our cluster. By default, it will use the Google Cloud and GCE.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的连接速度，下载Kubernetes可能需要一两分钟的时间。之后，它将自动调用`kube-up.sh`脚本并开始构建我们的集群。默认情况下，它将使用Google
    Cloud和GCE。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If something fails during the cluster setup and you need to start again, you
    can simply run the `kube-up.sh` script. Go to the folder where you ran the previous
    `curl` command. Then, you can kick off the cluster build with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在集群设置过程中出现故障，并且您需要重新开始，只需运行`kube-up.sh`脚本。转到您运行先前`curl`命令的文件夹。然后，您可以使用以下命令启动集群构建：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After Kubernetes is downloaded and the `kube-up.sh` script has started, we will
    see quite a few lines roll past. Let's take a look at them one section at a time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes下载并且`kube-up.sh`脚本已经启动后，我们将看到许多行滚过。让我们一次看一部分。
- en: '![Our first cluster](../images/00004.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00004.jpeg)'
- en: Figure 1.3\. GCE prerequisite check
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 GCE先决条件检查
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If your `gcloud` components are not up to date, you may be prompted to update.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`gcloud`组件不是最新的，可能会提示您进行更新。
- en: The preceding section (Figure 1.3) shows the checks for prerequisites as well
    as makes sure that all components are up to date. This is specific to each provider.
    In the case of GCE, it will check that the SDK is installed and that all components
    are up to date. If not, you will see a prompt at this point to install or update.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分（图1.3）显示了先决条件的检查，以确保所有组件都是最新的。这是针对每个提供商的。在GCE的情况下，它将检查SDK是否已安装以及所有组件是否是最新的。如果不是，您将在此时看到提示进行安装或更新。
- en: '![Our first cluster](../images/00005.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00005.jpeg)'
- en: Figure 1.4\. Upload cluster packages
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 上传集群包
- en: Now the script is turning up the cluster. Again, this is specific to the provider.
    For GCE, it first checks to make sure that the SDK is configured for a default
    **project** and **zone**. If they are set, you'll see those in the output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本正在启动集群。再次强调，这是特定于提供程序的。对于GCE，它首先检查SDK是否配置为默认的**project**和**zone**。如果设置了，你会在输出中看到它们。
- en: Next, it uploads the server binaries to Google Cloud storage, as seen in the
    **Creating gs:\\...** lines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将服务器二进制文件上传到Google云存储，如**创建gs:\\...**行所示。
- en: '![Our first cluster](../images/00006.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00006.jpeg)'
- en: Figure 1.5\. Master creation
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5。主节点创建
- en: It then checks for any pieces of a cluster already running. Then, we finally
    start creating the cluster. In the output in Figure 1.5, we see it creating the
    **master** server, IP address, and appropriate firewall configurations for the
    cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它检查是否已经有任何部分的集群在运行。然后，我们最终开始创建集群。在图1.5的输出中，我们看到它创建了**master**服务器、IP地址以及集群的适当防火墙配置。
- en: '![Our first cluster](../images/00007.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00007.jpeg)'
- en: Figure 1.6\. Minion creation
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6。Minion创建
- en: Finally, it creates the **minions** or **nodes** for our cluster. This is where
    our container workloads will actually run. It will continually loop and wait while
    all the minions start up. By default, the cluster will have four node (minions),
    but K8s supports having upwards of 100 (and soon beyond 1000). We will come back
    to scaling the nodes later on in the book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它创建我们集群的**minions**或**nodes**。这是我们的容器工作负载实际运行的地方。它将不断循环并等待，直到所有minions启动。默认情况下，集群将有四个节点（minions），但K8s支持最多100个（很快会超过1000个）。我们将在书中稍后回到扩展节点的问题。
- en: '![Our first cluster](../images/00008.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00008.jpeg)'
- en: Figure 1.7\. Cluster completion
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7。集群完成
- en: Now that everything is created, the cluster is initialized and started. Assuming
    that everything goes well, we will get an IP address for the master. Also, note
    that configuration along with the cluster management credentials are stored in
    `home/`**`<Username>`**`/.kube/config`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都创建好了，集群已经初始化并启动。假设一切顺利，我们将获得主节点的IP地址。还要注意，配置以及集群管理凭据存储在`home/`**`<Username>`**`/.kube/config`中。
- en: '![Our first cluster](../images/00009.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00009.jpeg)'
- en: Figure 1.8\. Cluster validation
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8。集群验证
- en: Then, the script will validate the cluster. At this point, we are no longer
    running provider-specific code. The validation script will query the cluster via
    the `kubectl.sh` script. This is the central script for managing our cluster.
    In this case, it checks the number of minions found, registered, and in a ready
    state. It loops through giving the cluster up to 10 minutes to finish initialization.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本将验证集群。在这一点上，我们不再运行特定于提供程序的代码。验证脚本将通过`kubectl.sh`脚本查询集群。这是管理我们的集群的中央脚本。在这种情况下，它检查找到的、注册的和处于就绪状态的minions的数量。它循环执行，给集群最多10分钟的时间来完成初始化。
- en: 'After a successful startup, a summary of the minions and the cluster component
    health is printed to the screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动后，将在屏幕上打印minions和集群组件健康状况的摘要：
- en: '![Our first cluster](../images/00010.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个集群](../images/00010.jpeg)'
- en: Figure 1.9\. Cluster summary
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9。集群摘要
- en: Finally, a `kubectl cluster-info` command is run, which outputs the URL for
    the master services as well as DNS, UI, and monitoring. Let's take a look at some
    of these components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`kubectl cluster-info`命令，输出主服务的URL以及DNS、UI和监控。让我们来看看其中的一些组件。
- en: Kubernetes UI
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes UI
- en: 'Open a browser and try the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并尝试以下代码：
- en: '`https://`**`<your master ip>`**`/api/v1/proxy/namespaces/kube-system/services/kube-ui`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://`**`<your master ip>`**`/api/v1/proxy/namespaces/kube-system/services/kube-ui`'
- en: 'The certificate is self-signed by default, so you''ll need to ignore the warnings
    in your browser before proceeding. After this, we will see a login dialog. This
    is where we use the credentials listed during the K8s installation. We can find
    them at any time by simply using the `config` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 证书默认是自签名的，所以在继续之前，您需要忽略浏览器中的警告。之后，我们会看到一个登录对话框。这是我们在K8s安装期间使用的凭据。我们可以随时通过简单地使用`config`命令来找到它们：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have credentials for login, use those, and we should see a dashboard
    like the following image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了登录凭据，使用它们，我们应该看到一个类似以下图像的仪表板：
- en: '![Kubernetes UI](../images/00011.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes UI](../images/00011.jpeg)'
- en: Figure 1.10\. Kubernetes UI dashboard
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 Kubernetes UI 仪表板
- en: The main dashboard page gives us a summary of the minions (or slave nodes).
    We can also see the CPU, memory, and used disk space on each minion as well the
    IP address.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 主仪表板页面为我们提供了关于从属节点的摘要。我们还可以看到每个从属节点上的CPU、内存和已使用磁盘空间以及IP地址。
- en: The UI has a number of built-in views listed under the **Views** dropdown menu
    on the top right of the screen. However, most of them will be empty by default.
    Once workloads and services are spun up, these views will become a lot more interesting.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: UI在屏幕右上角的**Views**下拉菜单中列出了许多内置视图。然而，大多数默认情况下都是空的。一旦工作负载和服务启动，这些视图将变得更加有趣。
- en: Grafana
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grafana
- en: 'Another service installed by default is **Grafana**. This tool will give us
    a dashboard to view metrics on the cluster nodes. We can access it by using the
    following syntax in a browser:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个默认安装的服务是**Grafana**。这个工具将为我们提供一个仪表板，以查看集群节点上的指标。我们可以通过在浏览器中使用以下语法来访问它：
- en: '`https://`**`<your master ip>`**`/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://`**`<您的主节点IP>`**`/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana`'
- en: '![Grafana](../images/00012.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Grafana](../images/00012.jpeg)'
- en: Figure 1.11\. Kubernetes Grafana dashboard
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 Kubernetes Grafana 仪表板
- en: Here, Kubernetes is actually running a number of services. **Heapster** is used
    to collect resource usage on the **pods** and **nodes** and stores the information
    in **InfluxDB**. The results, like CPU and memory usage, are what we see in the
    Grafana UI. We will explore this in depth in [Chapter 6](part0046_split_000.html#1BRPS1-22fbdd9ef660435ca6bcc0309f05b1b7
    "Chapter 6. Monitoring and Logging"), *Monitoring and Logging*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Kubernetes实际上正在运行许多服务。**Heapster**用于收集**pods**和**nodes**上的资源使用情况，并将信息存储在**InfluxDB**中。结果，如CPU和内存使用情况，就是我们在Grafana
    UI中看到的。我们将在[第6章](part0046_split_000.html#1BRPS1-22fbdd9ef660435ca6bcc0309f05b1b7
    "第6章。监控和日志记录")*监控和日志记录*中深入探讨这一点。
- en: Swagger
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger
- en: '**Swagger** ([http://swagger.io/](http://swagger.io/)) is a tool to add a higher
    level of interaction and easy discovery to an API.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger** ([http://swagger.io/](http://swagger.io/))是一个工具，可以为API添加更高级别的交互和易于发现。'
- en: Kubernetes has built a Swagger-enabled API, which can be accessed by using `https://`**`<your
    master ip>`**`/swagger-ui/`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已经构建了一个启用Swagger的API，可以通过使用`https://`**`<您的主节点IP>`**`/swagger-ui/`来访问。
- en: '![Swagger](../images/00013.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger](../images/00013.jpeg)'
- en: Figure 1.12\. Kubernetes Swagger dashboard
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 Kubernetes Swagger 仪表板
- en: Through this interface, you can learn a lot about the Kubernetes RESTful API.
    The bulk of the interesting endpoints are listed under `v1`. If we look at `/api/v1/nodes`,
    we can see the structure of the JSON response as well as details of possible parameters
    for the request. In this case, we see that the first parameter is `pretty`, which
    toggles whether the JSON is returned with pretty indentation for easier reading.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个界面，您可以了解很多关于Kubernetes RESTful API的信息。大部分有趣的端点都列在`v1`下。如果我们查看`/api/v1/nodes`，我们可以看到JSON响应的结构以及请求的可能参数的详细信息。在这种情况下，我们看到第一个参数是`pretty`，它切换是否返回带有漂亮缩进的JSON以便更容易阅读。
- en: We can try this out by using `https://`**`<your master ip>`**`/api/v1/nodes/`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`https://`**`<your master ip>`**`/api/v1/nodes/`来尝试这一点。
- en: By default, we'll see a JSON response with pretty indentation enabled. The response
    should have a list of all the nodes currently in our cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将看到一个启用了漂亮缩进的JSON响应。响应应该包含当前在我们集群中的所有节点的列表。
- en: Now, let's try tweaking the `pretty` request parameter you just learned about.
    Use `https://`**`<your master ip>`**`/api/v1/nodes/?pretty=false`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试调整您刚学到的`pretty`请求参数。使用`https://`**`<your master ip>`**`/api/v1/nodes/?pretty=false`。
- en: Now we have the same response output, but with no indentation. This is a great
    resource for exploring the API and learning how to use various function calls
    to get more information and interact with your cluster programmatically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了相同的响应输出，但没有缩进。这是一个探索API并学习如何使用各种函数调用以获取更多信息并以编程方式与您的集群交互的好资源。
- en: Command line
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行
- en: 'The `kubectl.sh` script has commands to explore our cluster and the workloads
    running on it. We will be using this command throughout the book, so let''s take
    a second to set up our environment. We can do so by making the script executable
    and putting it on our `PATH`, in the following manner:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl.sh`脚本有命令来探索我们的集群和运行在上面的工作负载。我们将在整本书中使用这个命令，所以让我们花一点时间来设置我们的环境。我们可以通过使脚本可执行并将其放在我们的`PATH`中来这样做，方式如下：'
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may choose to download the `kubernetes` folder outside your home folder,
    so modify the preceding commands as appropriate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择将`kubernetes`文件夹下载到您的主文件夹之外，然后根据需要修改上述命令。
- en: It is also a good idea to make the changes permanent by adding the `export`
    command to the end of your `.bashrc` file in your home directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`export`命令添加到您的主目录中的`.bashrc`文件的末尾，也是一个很好的主意，使更改永久化。
- en: Now that we have `kubectl` on our path, we can start working with it. It has
    quite a few commands. Since we have not spun up any applications yet, most of
    these commands will not be very interesting. However, we can explore with two
    commands right away.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在路径上有了`kubectl`，我们可以开始使用它了。它有相当多的命令。由于我们还没有启动任何应用程序，大多数这些命令都不会很有趣。但是，我们可以立即用两个命令来探索。
- en: 'First, we have already seen the `cluster-info` command during initialization,
    but we can run it again at any time with the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在初始化期间已经看到了`cluster-info`命令，但我们随时可以再次运行它，方法如下：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another useful command is `get`. The `get` command can be used to see currently
    running **services**, **pods**, **replication controllers**, and a lot more. Here
    are the three examples that are useful right out of the gate:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令是`get`。`get`命令可用于查看当前运行的**服务**、**pod**、**复制控制器**等等。以下是三个立即有用的示例：
- en: 'Listing the nodes in our cluster:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我们集群中的节点：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'List cluster events:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出集群事件：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can see any services that are running in the cluster as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以按如下方式查看在集群中运行的任何服务：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To start with, we will only see one service, named `kubernetes`. This service
    is the core API server, monitoring and logging services for the pods and cluster.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只会看到一个名为`kubernetes`的服务。这个服务是核心API服务器，监控和日志服务为pod和集群。
- en: Services running on the master
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行在主节点上的服务
- en: 'Let''s dig a little bit deeper into our new cluster and its core services.
    By default, machines are named with the `kubernetes-` prefix. We can modify this
    using `$KUBE_GCE_INSTANCE_PREFIX` before a cluster is spun up. For the cluster
    we just started, the master should be named `kubernetes-master`. We can use the
    `gcloud` command-line utility to SSH into the machine. The following command will
    start an SSH session with the master node. Be sure to substitute your project
    ID and zone to match your environment. Also, note that you can launch SSH from
    the Google Cloud console using the following syntax:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下我们的新集群及其核心服务。默认情况下，机器以`kubernetes-`前缀命名。我们可以在启动集群之前使用`$KUBE_GCE_INSTANCE_PREFIX`来修改这个前缀。对于我们刚刚启动的集群，主节点应该被命名为`kubernetes-master`。我们可以使用`gcloud`命令行实用程序来SSH到机器上。以下命令将在主节点上启动一个SSH会话。请确保替换您的项目ID和区域以匹配您的环境。还要注意，您可以使用以下语法从Google
    Cloud控制台启动SSH：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we are logged in, we should get a standard shell prompt. Let's run the
    familiar `sudo docker ps` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们应该得到一个标准的shell提示符。让我们运行熟悉的`sudo docker ps`命令。
- en: '![Services running on the master](../images/00014.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![主节点上运行的服务](../images/00014.jpeg)'
- en: Figure 1.13\. Master container listing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13. 主容器列表
- en: 'Even though we have not deployed any applications on Kubernetes yet, we note
    that there are several containers already running. The following is a brief description
    of each container:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尚未在Kubernetes上部署任何应用程序，但我们注意到已经有几个容器在运行。以下是对每个容器的简要描述：
- en: '`fluentd-gcp`: This container collects and sends the cluster logs file to the
    Google Cloud Logging service.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fluentd-gcp`：这个容器收集并将集群日志文件发送到谷歌云日志服务。'
- en: '`kube-ui`: This is the UI that we saw earlier.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-ui`：这是我们之前看到的UI。'
- en: '`kube-controller-manager`: The controller manager controls a variety of cluster
    functions. Ensuring accurate and up-to-date replication is one of its vital roles.
    Additionally, it monitors, manages, and discovers new nodes. Finally, it manages
    and updates service endpoints.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`：控制器管理器控制各种集群功能。确保准确和最新的复制是它的重要角色之一。此外，它监视、管理和发现新节点。最后，它管理和更新服务端点。'
- en: '`kube-apiserver`: This container runs the API server. As we explored in the
    Swagger interface, this RESTful API allows us to create, query, update, and remove
    various components of our Kubernetes cluster.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`：这个容器运行API服务器。正如我们在Swagger界面中探索的那样，这个RESTful API允许我们创建、查询、更新和删除Kubernetes集群的各种组件。'
- en: '`kube-scheduler`: The scheduler takes unscheduled pods and binds them to nodes
    based on the current scheduling algorithm.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler`：调度器根据当前的调度算法接收未调度的pod并将它们绑定到节点上。'
- en: '`etcd`: This runs the **etcd** software built by CoreOS. `etcd` is a distributed
    and consistent key-value store. This is where the Kubernetes cluster state is
    stored, updated, and retrieved by various components of K8s.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：这个容器运行由CoreOS构建的**etcd**软件。`etcd`是一个分布式和一致的键值存储。这是Kubernetes集群状态被存储、更新和被K8s的各种组件检索的地方。'
- en: '`pause`: The `Pause` container is often referred to as the pod infrastructure
    container and is used to set up and hold the networking namespace and resource
    limits for each pod.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：`Pause`容器通常被称为pod基础设施容器，用于设置和保持每个pod的网络命名空间和资源限制。'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: Figure 2.1 in the next chapter will also show how a few of these services work
    together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章的图2.1也将展示这些服务如何一起工作。
- en: To exit the SSH session, simply type `exit` at the prompt.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出SSH会话，只需在提示符处键入`exit`。
- en: Services running on the minions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在minions上运行的服务
- en: 'We could SSH to one of the minions, but since Kubernetes schedules workloads
    across the cluster, we would not see all the containers on a single minion. However,
    we can look at the pods running on all the minions using the `kubectl` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以SSH到其中一个从属节点，但由于Kubernetes在整个集群上调度工作负载，我们不会在单个从属节点上看到所有容器。但是，我们可以使用`kubectl`命令查看所有从属节点上运行的pod：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we have not started any applications on the cluster yet, we don''t see
    any pods. However, there are actually several system pods running pieces of the
    Kubernetes infrastructure. We can see these pods by specifying the `kube-system`
    namespace. We will explore namespaces and their significance later, but for now,
    the `--namespace=kube-system` command can be used to look at these K8s system
    resources as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未在集群上启动任何应用程序，因此我们看不到任何pod。但是，实际上有几个系统pod运行着Kubernetes基础设施的各个部分。我们可以通过指定`kube-system`命名空间来查看这些pod。稍后我们将探讨命名空间及其重要性，但目前可以使用`--namespace=kube-system`命令来查看这些K8s系统资源，如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should see something similar to the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似以下的内容：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first six should look familiar. These are additional pieces of the services
    we saw running on the master. The final three are services we have not seen yet.
    `kube-dns` provides the DNS and service discovery plumbing. `monitoring-heapster`
    is the system used to monitor resource usage across the cluster. `monitoring-influx-grafana`
    provides the database and user interface we saw earlier for monitoring the infrastructure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前六个应该看起来很熟悉。这些是我们在主节点上看到的服务的附加部分。最后三个是我们尚未看到的服务。`kube-dns`提供DNS和服务发现管道。`monitoring-heapster`是用于监视集群中资源使用的系统。`monitoring-influx-grafana`提供了我们之前用于监视基础设施的数据库和用户界面。
- en: 'If we did SSH into a random minion, we would see several containers that run
    across a few of these pods. A sample might look like the image here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们SSH到一个随机的从属节点，我们会看到一些跨越这些pod的容器。一个示例可能看起来像这里的图片：
- en: '![Services running on the minions](../images/00015.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![在从属节点上运行的服务](../images/00015.jpeg)'
- en: Figure 1.14\. Minion container listing
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14。从属容器列表
- en: 'Again, we saw a similar line up of services on the master. The services we
    did not see on the master include the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在主节点上看到了类似的服务。我们在主节点上没有看到的服务包括以下内容：
- en: '`skydns`: This uses DNS to provide a distributed service discovery utility
    that works with `etcd`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skydns`：这使用DNS提供了一个与`etcd`配合工作的分布式服务发现实用程序。'
- en: '`kube2Sky`: This is the connector between `skydns` and `kubernetes`. Services
    in the API are monitored for changes and updated in `skydns` appropriately.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube2Sky`：这是`skydns`和`kubernetes`之间的连接器。API中的服务会被监视更改，并在`skydns`中相应地更新。'
- en: '`heapster`: This does resource usage and monitoring.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heapster`：这是资源使用和监控。'
- en: '`exechealthz`: This performs health checks on the pods.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exechealthz`：这对pod执行健康检查。'
- en: Tear down cluster
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆除集群
- en: 'OK, this is our first cluster on GCE, but let''s explore some other providers.
    To keep things simple, we need to remove the one we just created on GCE. We can
    tear down the cluster with one simple command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我们在GCE上的第一个集群，但让我们探索一些其他提供程序。为了保持简单，我们需要删除刚刚在GCE上创建的集群。我们可以使用一个简单的命令拆除集群：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Working with other providers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他提供程序
- en: 'By default, Kubernetes uses the GCE provider for Google Cloud. We can override
    this default by setting the `KUBERNETES_PROVIDER` environment variable. The following
    providers are supported with values listed in Table 1.1:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes使用Google Cloud的GCE提供程序。我们可以通过设置`KUBERNETES_PROVIDER`环境变量来覆盖此默认值。以下提供程序支持列在表1.1中的值：
- en: '| Provider | KUBERNETES_PROVIDER value | Type |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 提供程序 | KUBERNETES_PROVIDER值 | 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Google Compute Engine** | gce | Public cloud |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **Google Compute Engine** | gce | 公共云 |'
- en: '| **Google Container Engine** | gke | Public cloud |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: 谷歌容器引擎 | gke | 公共云 |
- en: '| **Amazon Web Services** | aws | Public cloud |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: 亚马逊网络服务 | aws | 公共云 |
- en: '| **Microsoft Azure** | azure | Public cloud |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: 微软Azure | azure | 公共云 |
- en: '| **Hashicorp Vagrant** | vagrant | Virtual development environment |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: Hashicorp Vagrant | vagrant | 虚拟开发环境 |
- en: '| **VMware vSphere** | vsphere | Private cloud / on-premise virtualization
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: VMware vSphere | vsphere | 私有云/本地虚拟化 |
- en: '| **Libvirt running CoreOS** | libvirt-coreos | Virtualization management tool
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: Libvirt运行CoreOS | libvirt-coreos | 虚拟化管理工具 |
- en: '| **Canonical Juju (folks behind Ubuntu)** | juju | OS service orchestration
    tool |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: Canonical Juju（Ubuntu背后的人） | juju | 操作系统服务编排工具 |
- en: '*Table 1.1\. Kubernetes providers*'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*表1.1. Kubernetes提供商*'
- en: 'Let''s try setting up the cluster on AWS. As a prerequisite, we need to have
    the AWS **Command Line Interface** (**CLI**) installed and configured for our
    account. AWS CLI Installation and configuration documentation can be found here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在AWS上设置集群。作为先决条件，我们需要安装并配置AWS **命令行界面**（**CLI**）以供我们的帐户使用。AWS CLI安装和配置文档可以在这里找到：
- en: 'Installation documentation: [http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os](http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装文档：[http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os](http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os)
- en: 'Configuration documentation: [http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文档：[http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)
- en: 'Then, it is a simple environment variable setting as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置一个简单的环境变量如下：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, we can use the `kube-up.sh` command to spin up the cluster as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`kube-up.sh`命令来启动集群，如下所示：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with GCE, the setup activity will take a few minutes. It will stage files
    in **S3**, create the appropriate instances, **Virtual Private Cloud** (**VPC**),
    security groups, and so on in our AWS account. Then, the Kubernetes cluster will
    be set up and started. Once everything is finished and started, we should see
    the cluster validation at the end of the output.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与GCE一样，设置活动将需要几分钟。它将在我们的AWS帐户中的**S3**中分阶段文件，创建适当的实例，**虚拟私有云**（**VPC**），安全组等等。然后，Kubernetes集群将被设置并启动。一旦一切都完成并启动，我们应该在输出的最后看到集群验证。
- en: '![Working with other providers](../images/00016.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![与其他提供商合作](../images/00016.jpeg)'
- en: Figure 1.15\. AWS cluster validation
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15. AWS集群验证
- en: 'Once again, we will SSH into master. This time, we can use the native SSH client.
    We''ll find the key files in `/home/`**`<username>`**`/.ssh`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将SSH到master。这次，我们可以使用本机SSH客户端。我们将在`/home/`**`<username>`**`/.ssh`中找到密钥文件：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll use `sudo docker ps` to explore the running containers. We should see
    something like the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`sudo docker ps`来探索正在运行的容器。我们应该看到类似以下的内容：
- en: '![Working with other providers](../images/00017.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![与其他提供商合作](../images/00017.jpeg)'
- en: Figure 1.16\. Master container listing (AWS)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16. 主容器列表（AWS）
- en: For the most part, we see the same containers as our GCE cluster had. However,
    instead of `fluentd-gcp` service, we see `fluentd-elasticsearch`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们看到与我们的GCE集群相同的容器。但是，我们看到的是`fluentd-elasticsearch`而不是`fluentd-gcp`服务。
- en: 'On the AWS provider, **Elasticsearch** and **Kibana** are set up for us. We
    can find the Kibana UI by using the following syntax as URL:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS提供商上，**Elasticsearch**和**Kibana**已经为我们设置好。我们可以通过以下语法找到Kibana UI的URL：
- en: '`https://`**`<your master ip>`**`/api/v1/proxy/namespaces/kube-system/services/kibana-logging/#/discover`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://`**`<your master ip>`**`/api/v1/proxy/namespaces/kube-system/services/kibana-logging/#/discover`'
- en: '![Working with other providers](../images/00018.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![与其他提供商合作](../images/00018.jpeg)'
- en: Figure 1.17\. Kubernetes Kibana dashboard
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 Kubernetes Kibana 仪表板
- en: Resetting the cluster
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置集群
- en: That is a little taste of running the cluster on AWS. For the remainder of the
    book, I will be basing my examples on a GCE cluster. For the best experience following
    along, you can get back to a GCE cluster easily.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在AWS上运行集群的一点体验。在本书的其余部分，我将以GCE集群为例。为了更好地跟进体验，您可以轻松地回到GCE集群。
- en: 'Simply tear down the AWS cluster as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地按照以下步骤拆除AWS集群：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, create a GCE cluster again using following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次使用以下方法创建GCE集群：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We took a very brief look at how containers work and how they lend themselves
    to the new architecture patterns in microservices. You should now have a better
    understanding of how these two forces will require a variety of operations and
    management tasks and how Kubernetes offers strong features to address these challenges.
    Finally, we created two different clusters on both GCE and AWS and explored the
    startup script as well as some of the built-in features of Kubernetes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地了解了容器的工作原理以及它们如何适用于微服务中的新架构模式。现在，您应该更好地了解这两种力量将需要各种运营和管理任务，以及Kubernetes如何提供强大的功能来解决这些挑战。最后，我们在GCE和AWS上创建了两个不同的集群，并探索了启动脚本以及Kubernetes的一些内置功能。
- en: In the next chapter, we will explore the core concept and abstractions K8s provides
    to manage containers and full application stacks. We will also look at basic scheduling,
    service discovery, and health checking.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨K8s提供的核心概念和抽象，以管理容器和完整的应用程序堆栈。我们还将研究基本的调度、服务发现和健康检查。
- en: Footnotes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚注
- en: '¹Malcom McLean entry on Wikipedia: [https://en.wikipedia.org/wiki/Malcom_McLean](https://en.wikipedia.org/wiki/Malcom_McLean)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ¹Malcom McLean 在维基百科上的条目：[https://en.wikipedia.org/wiki/Malcom_McLean](https://en.wikipedia.org/wiki/Malcom_McLean)
- en: '²Martin Fowler on microservices: [http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ²Martin Fowler 关于微服务的观点：[http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html)
- en: '³Kubernetes GitHub project page: [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ³Kubernetes GitHub 项目页面：[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)
- en: References
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration)'
- en: '[https://docs.docker.com/](https://docs.docker.com/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/](https://docs.docker.com/)'
- en: '[https://github.com/GoogleCloudPlatform/kubernetes/](https://github.com/GoogleCloudPlatform/kubernetes/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/GoogleCloudPlatform/kubernetes/](https://github.com/GoogleCloudPlatform/kubernetes/)'
