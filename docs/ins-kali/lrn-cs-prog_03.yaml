- en: '*Chapter 3*: Control Statements and Exceptions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：控制语句和异常'
- en: In the previous chapter, we discussed data types and operators in C#. In this
    chapter, we will explore control statements in C#. Control statements allow us
    to implement conditional execution paths in our code. We will also learn how to
    implement exception handling, which will help us to handle errors that might occur
    while executing our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了C#中的数据类型和运算符。在本章中，我们将探讨C#中的控制语句。控制语句允许我们在代码中实现条件执行路径。我们还将学习如何实现异常处理，这将帮助我们处理在执行应用程序时可能发生的错误。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下概念：
- en: Control statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制语句
- en: Exception handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: By the end of this chapter, we will have seen how to implement these statements
    and clauses practically. Let's look at each of these topics in detail using examples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将看到如何实际实现这些语句和子句。让我们使用示例详细讨论每个主题。
- en: Understanding control statements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解控制语句
- en: 'Control statements allow us to control the flow of execution of a program.
    They also allow us to execute a particular block of code based on a certain condition.
    C# defines three categories of control statements, as mentioned here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句允许我们控制程序的执行流程。它们还允许我们根据特定条件执行特定的代码块。C#定义了三种控制语句的类别，如下所述：
- en: '`if` and `switch`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 和 `switch`'
- en: '`for`, `while`, `do-while`, and `foreach`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`, `while`, `do-while`, 和 `foreach`'
- en: '`break`, `continue`, `goto`, `return`, and `yield`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`, `continue`, `goto`, `return`, 和 `yield`'
- en: We will explore each of these statements in detail in the following sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细探讨这些语句。
- en: Selection statements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'Selection statements allow us to change the execution flow based on whether
    a condition is true or not. C# provides us with two types of selection statements:
    `if` and `switch`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句允许我们根据条件是否为真来改变执行流程。C#为我们提供了两种类型的选择语句：`if`和`switch`。
- en: The if statement
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if语句
- en: 'The following snippet shows the syntax of an `if` statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`if`语句的语法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If `condition1` evaluates to `true`, then `statement1` will be executed. Else,
    if `condition2` evaluates to `true`, then `statement2` will be executed. Otherwise,
    `statement3` will be executed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`condition1`评估为`true`，那么将执行`statement1`。否则，如果`condition2`评估为`true`，那么将执行`statement2`。否则，将执行`statement3`。
- en: The `else-if` and `else` clauses are *optional* and either of them, or both,
    can be *omitted*. On the other hand, you can have as many `else-if` clauses as
    you'd like.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`else-if`和`else`子句是*可选的*，可以*省略*其中任何一个，或者两者都可以*省略*。另一方面，您可以有尽可能多的`else-if`子句。'
- en: 'In this example, we have only one statement to be executed for both the `if`
    and `else` clauses. If we have to execute a series of statements, we need to add
    curly braces (`{}`) to make it a block. This is optional for single statements,
    although it is often a good way to make the code clearer or less prone to errors.
    In this case, the syntax will change as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只有一个语句要执行`if`和`else`子句。如果我们需要执行一系列语句，我们需要添加大括号（`{}`）使其成为一个代码块。对于单个语句来说，这是可选的，尽管这通常是使代码更清晰或更不容易出错的好方法。在这种情况下，语法将如下改变：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If `condition` evaluates to `true`, then both `statement1` and `statement2`
    will be executed. Otherwise, `statement3` and `statement4` will be executed. Let''s
    try to understand the `if-else` statement with the help of the following code
    snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`condition`评估为`true`，那么`statement1`和`statement2`都将被执行。否则，将执行`statement3`和`statement4`。让我们尝试通过以下代码片段来理解`if-else`语句。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding program checks if a positive integer is even or odd. We are reading
    an integer from the console as input. As the value entered on the console is considered
    a string, we need to convert it to an integer. We will then find the remainder
    of division by `2` by applying the modulus (`%`) operator. If the remainder is
    `0` then the number is *even*, if not, the number is *odd*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序检查正整数是偶数还是奇数。我们从控制台读取一个整数作为输入。由于控制台上输入的值被视为字符串，我们需要将其转换为整数。然后，我们将通过应用模运算符（`%`）找到除以`2`的余数。如果余数是`0`，那么数字是*偶数*，如果不是，那么数字是*奇数*。
- en: 'The `if` statements can be nested. We can put an `if` statement inside another
    `if` or an `else` statement. The following syntax shows an example of nested `if`
    statements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可以嵌套。我们可以在另一个`if`语句或`else`语句中放置一个`if`语句。以下语法显示了嵌套`if`语句的示例：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, if `condition1` evaluates to `true`, then the control will
    enter into the `if` block and execute the statement based on the evaluation of
    the nested `if` statements. If `condition1` is `false`, then the nested `if` statements
    inside the `else` clauses will be executed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`condition1`评估为`true`，那么控制将进入`if`块并根据嵌套`if`语句的评估执行语句。如果`condition1`是`false`，那么将执行`else`子句内的嵌套`if`语句。
- en: 'In a nested `if` statement, each `else` clause belongs to the last `if` statement
    that doesn''t have a corresponding `else` statement. To avoid confusion and errors,
    it is recommended that you use curly braces when nesting `if` statements to pair
    `if` and `else` clauses correctly. Take, for instance, the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的`if`语句中，每个`else`子句都属于最后一个没有相应`else`语句的`if`语句。为了避免混淆和错误，建议在嵌套`if`语句时使用大括号正确配对`if`和`else`子句。例如，以下示例：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example is not the same as the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与以下内容不同：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first example, the `else` clause belonged to the second, inner `if` clause.
    On the other hand, in the second example, the `else` clause belonged to the first,
    outer `if` clause.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`else`子句属于第二个内部`if`子句。另一方面，在第二个例子中，`else`子句属于第一个外部`if`子句。
- en: The switch statement
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch语句
- en: The `switch` statement provides us with a way to execute a set of instructions
    from several available alternatives. It will match the value of an expression
    against a list of available values. If a match is found, the code associated with
    that value is executed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句为我们提供了一种执行多个可用替代方案的方法。它将表达式的值与可用值列表进行匹配。如果找到匹配项，则执行与该值相关联的代码。'
- en: The `switch` statement is an alternative to the cascading `if-else-if` statements.
    If there is a small number of matches, an `if` statement may be preferred. However,
    if the number of matching conditions is larger, a `switch` statement is preferred
    to an `if` statement for its better readability and maintainability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句是级联`if-else-if`语句的替代方案。如果匹配的数量很少，可能更喜欢使用`if`语句。但是，如果匹配条件的数量较大，则更喜欢使用`switch`语句而不是`if`语句，因为它更易读和易维护。'
- en: 'The syntax of a `switch` statement is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的语法如下：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `switch` statement contains one or more sections and each section has one
    or more `case` labels. Each `case` label can have one or more statements. Each
    `case` label specifies a value that will be matched with the `switch` expression.
    If a match is found, the control will be transferred to the matching `case` label.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句包含一个或多个部分，每个部分都有一个或多个`case`标签。每个`case`标签可以有一个或多个语句。每个`case`标签指定一个将与`switch`表达式匹配的值。如果找到匹配项，控制将转移到匹配的`case`标签。'
- en: The statements present in the `case` label will be executed until a `break`
    statement is encountered. If no match is found, the control will go to the `default`
    case. After the execution of a particular `case` label, the control will exit
    the switch. The `default` case is optional. If no `default` case is present and
    no match is found for any case labels, the control will fall outside of the `switch`
    statement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`标签中的语句将执行，直到遇到`break`语句。如果找不到匹配项，控制将转到`default`情况。在执行特定`case`标签后，控制将退出switch。`default`情况是可选的。如果没有`default`情况，并且没有找到任何case标签的匹配项，控制将跳出`switch`语句。'
- en: Note that we have not used curly braces `({})` inside the case labels. The `default`
    case can appear anywhere on the list. It is always evaluated last after all the
    `case` labels have been evaluated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在case标签内没有使用大括号`({})`。`default`情况可以出现在列表的任何位置。在评估所有`case`标签之后，它始终最后进行评估。
- en: You can place multiple case labels in the same switch section; in this case,
    the matching of any of the case labels will trigger the execution of the switch
    section. In a `switch` statement, only one switch section may execute. It is not
    possible to fall through from one section to another. Each `switch` statement
    must be followed by a `break`, `goto`, or `return` statement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在同一个switch部分中放置多个case标签；在这种情况下，任何一个case标签的匹配都将触发switch部分的执行。在`switch`语句中，只能执行一个switch部分。不可能从一个部分跳转到另一个部分。每个`switch`语句必须跟随一个`break`，`goto`或`return`语句。
- en: 'The following example shows a `switch` statement with multiple switch sections,
    some of them with multiple `case` labels. The `default` case is placed at the
    end, as you would usually do. Each section is exited with a `break` statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个带有多个switch部分的`switch`语句，其中一些带有多个`case`标签。`default`情况放在最后，通常会这样做。每个部分都用`break`语句退出：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `switch` statement supports various forms of pattern matching. However,
    this is a more advanced topic that will be detailed in [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154),
    *Advanced Topics*, and in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句支持各种形式的模式匹配。但这是一个更高级的主题，将在[*第8章*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154)中详细介绍，*高级主题*，以及[*第15章*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271)中介绍，*C#
    8的新特性*。'
- en: Iteration statements
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: 'Iteration statements allow us to execute a set of code in a loop as long as
    a certain condition is satisfied. C# provides us with four different kinds of
    loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句允许我们在循环中执行一组代码，只要满足某个条件。C#为我们提供了四种不同类型的循环：
- en: '`for`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`do-while`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while`'
- en: '`foreach`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach`'
- en: Let's explore them in detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨一下。
- en: The for loop
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loop allows us to execute a code block as long as a Boolean expression
    evaluates to `true`. The following snippet shows the general syntax of a `for`
    loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环允许我们执行代码块，只要布尔表达式评估为`true`。以下代码段显示了`for`循环的一般语法：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `initializer` section consists of one or more initialization statements
    intended to initialize the counter to control the loop. This will be executed
    only once before entering the loop for the first time. If there are multiple statements
    in the `initializer` section, they must be separated by a comma. However, the
    `initializer` section is *optional and can be left empty*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializer`部分由一个或多个初始化语句组成，用于初始化控制循环的计数器。这将在第一次进入循环之前执行一次。如果`initializer`部分中有多个语句，它们必须用逗号分隔。但是，`initializer`部分是*可选的，可以留空*。'
- en: The loop controlling counter is also known as the loop control variable. This
    variable is local to the loop and cannot be accessed outside the scope of the
    `for` loop.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制计数器也称为循环控制变量。此变量局限于循环范围内，不能在`for`循环范围外访问。
- en: '`condition` is a Boolean expression that will determine if the loop will execute
    or not. It will be evaluated for every iteration of the loop. If it evaluates
    to `true`, the loop will be executed. Once the Boolean condition evaluates to
    `false`, the loop will terminate, and the program control will fall out of the
    loop. This statement is optional and can be left empty.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`是一个布尔表达式，将确定循环是否执行。它将在每次循环迭代时进行评估。如果评估为`true`，则执行循环。一旦布尔条件评估为`false`，循环将终止，并且程序控制将跳出循环。此语句是可选的，可以留空。'
- en: '`iterator` is an expression to change (increment/decrement) the loop control
    variable after each iteration of the loop. It can have multiple statements separated
    by a comma. This statement is also *optional and can be left empty*. In fact,
    all three of these statements (`initializer`, `condition`, and `iterator`) can
    be omitted, in which case we have an infinite loop, as in the following snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator`是一个表达式，用于在循环的每次迭代后更改（增加/减少）循环控制变量。它可以有多个用逗号分隔的语句。这个语句也是*可选的，可以留空*。实际上，这三个语句（`initializer`、`condition`和`iterator`）都可以被省略，这样我们就有了一个无限循环，就像下面的片段一样：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `for` loop is an entry controlled loop, which means the Boolean condition
    will be evaluated before entering into the loop. If the condition evaluates to
    `false` in the first iteration, then the code block inside the loop will not be
    executed at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是一个入口控制循环，这意味着在进入循环之前将评估布尔条件。如果条件在第一次迭代中评估为`false`，那么循环内部的代码块将根本不会被执行。'
- en: 'Let''s understand the `for` loop with the help of the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段来理解`for`循环：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are running a `for` loop to check which integers between `0` and `10`
    are even or odd. When you execute this code, you will see the following output
    screen:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行一个`for`循环来检查`0`到`10`之间的哪些整数是偶数或奇数。当您执行此代码时，您将看到以下输出屏幕：
- en: '![Figure 3.1 – A screenshot of the console showing the output of the preceding
    snippet'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 控制台截图显示前面片段的输出'
- en: '](img/Figure_3.1_B12346.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B12346.jpg)'
- en: Figure 3.1 – A screenshot of the console showing the output of the preceding
    snippet
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 控制台截图显示前面片段的输出
- en: 'We can also put a `for` loop inside another `for` loop. In this case, the inner
    loop will execute completely for each iteration of the outer loop. Look at the
    following code snippet. Here, all of the values of the `j` variable (that is,
    `1` and `2`) will be printed against each value of the `i` variable (that is,
    `1`, `2`, `3`, and `4`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在另一个`for`循环中放置一个`for`循环。在这种情况下，内部循环将完全执行每次外部循环的迭代。看看以下代码片段。在这里，`j`变量的所有值（即`1`和`2`）将被打印到`i`变量的每个值（即`1`、`2`、`3`和`4`）：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon execution, you can see the following output of the program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，您可以看到程序的以下输出：
- en: '![Figure 3.2 – The console output from the execution of the preceding snippet'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 前面片段执行的控制台输出'
- en: '](img/Figure_3.2_B12346.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B12346.jpg)'
- en: Figure 3.2 – The console output from the execution of the preceding snippet
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 控制台截图显示前面片段的输出
- en: 'A typical example of nested `for` loops is multi-dimensional array traversal.
    In the following example, we have an array of integers with three rows and two
    columns initialized during its declaration. The nested `for` loops are used to
    print the value of its elements to the console:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套`for`循环的典型示例是多维数组遍历。在下面的示例中，我们有一个整数数组，有三行两列，在声明时进行了初始化。嵌套`for`循环用于将其元素的值打印到控制台：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we used the `GetUpperBound()` method to retrieve the index of the
    last element of the specified dimension to avoid hard-coded values for the size
    of the array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`GetUpperBound()`方法来检索指定维度的最后一个元素的索引，以避免为数组大小硬编码数值。
- en: You can exit a loop iteration while the condition is still `true` using a `break`,
    `goto`, `return`, or `throw` statement. You can skip the execution of the loop
    block for the current iteration with a `continue` statement. This is also true
    for the other loops—`while`, `do`, and `foreach`. The `jump` statements will be
    explored in detail later on in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在条件仍为`true`时退出循环迭代，使用`break`、`goto`、`return`或`throw`语句。您可以使用`continue`语句跳过当前迭代的循环块的执行。对于其他循环（`while`、`do`和`foreach`）也是如此。`jump`语句将在本章后面详细探讨。
- en: The while loop
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'The `while` loop is an *entry controlled loop*. It executes a block of statements
    as long as a specified Boolean expression evaluates to `true`. The syntax of a
    `while` loop is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是一个*入口控制循环*。只要指定的布尔表达式评估为`true`，它就会执行一系列语句的块。`while`循环的语法如下：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `condition` is a Boolean expression and it controls the loop. The code
    block inside the loop will be executed while `condition` evaluates to `true`.
    When `condition` becomes `false`, the program control will fall outside of the
    loop. Because `condition` is evaluated first, the `while` loop may not execute
    at all if `condition` is initially `false`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`condition`是一个布尔表达式，它控制着循环。当`condition`评估为`true`时，循环内部的代码块将被执行。当`condition`变为`false`时，程序控制将跳出循环。因为`condition`首先被评估，如果`condition`最初为`false`，`while`循环可能根本不会执行。
- en: 'A `while` loop is very similar to a `for` loop. In fact, you can rewrite any
    `while` loop as a `for` loop and vice versa. You can see in the following snippet
    how we can re-rewrite the syntax of a `for` loop using a `while` loop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环与`for`循环非常相似。实际上，您可以将任何`while`循环重写为`for`循环，反之亦然。您可以在以下代码片段中看到如何使用`while`循环重新编写`for`循环的语法：'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following code snippet, we have rewritten the example from the previous
    session that prints even and odd numbers to the console with the help of a `while`
    loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们已经使用`while`循环重新编写了上一节中打印偶数和奇数到控制台的示例：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of the execution of the program is unchanged. In fact, there is yet
    another way to achieve the same result, and that is through using a `do` statement.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的执行结果没有改变。实际上，还有另一种方法可以实现相同的结果，那就是使用`do`语句。
- en: The do-while loop
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`do-while`循环'
- en: The `do-while` loop is an *exit-controlled loop*. This means the Boolean condition
    will be checked at the end of the loop. This ensures that the `do-while` loop
    will always be executed at least once, even if the condition evaluates to `false`
    in the first iteration. That is the key difference between a `while` and a `do-while`
    loop; the former may not execute at all, but the latter is always executed at
    least once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`循环是一个*退出控制循环*。这意味着布尔条件将在循环结束时被检查。这确保了`do-while`循环至少会被执行一次，即使条件在第一次迭代中求值为`false`。这是`while`和`do-while`循环之间的关键区别；前者可能根本不执行，但后者至少会执行一次。'
- en: 'The syntax of a `do-while` loop is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`循环的语法如下：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following code snippet, we are printing all the numbers between `0`
    and `10` using a `do-while` loop, specifying which is odd and which is even. This
    code will have the same output as the example shown for the `while` loop:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们使用`do-while`循环打印出`0`到`10`之间的所有数字，并指定哪些是奇数，哪些是偶数。这段代码将产生与`while`循环示例中所示的相同输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The loops we have learned about so far allow us to execute one or more statements
    repeatedly, such as iterating through the elements of a collection based on an
    index. Another sort of loop statement, such as `foreach`, simplifies this iterating
    in all cases where we are interested in the element but not the index. Let's take
    a look at `foreach` next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习的循环允许我们重复执行一个或多个语句，比如根据索引迭代集合的元素。另一种循环语句，比如`foreach`，简化了在我们只关心元素而不关心索引的所有情况下的迭代。让我们接下来看一下`foreach`。
- en: The foreach loop
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach循环
- en: The `foreach` loop allows us to iterate through the items of a collection that
    implements the `System.Collections.IEnumerable` or `System.Collections.Generic.IEnumerable<T>`
    interface. Collections are discussed in detail in [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环允许我们迭代实现了`System.Collections.IEnumerable`或`System.Collections.Generic.IEnumerable<T>`接口的集合的项。集合在[*第7章*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134)
    *Collections*中有详细讨论。'
- en: 'The syntax of the `foreach` loop is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环的语法如下：'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `datatype` denotes a valid type in C# and it must be the same data type
    as the collection, or a type for which an implicit conversion exists. You can
    also use `var` instead of an actual type name, in which case the compiler will
    infer the type of the `iterator` variable from the type of the collection elements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`datatype`表示C#中的一个有效类型，它必须与集合的数据类型相同，或者存在隐式转换的类型。你也可以使用`var`代替实际的类型名，这样编译器将从集合元素的类型推断出`iterator`变量的类型。
- en: The `iterator` variable is a loop iteration variable. The loop iteration variable
    in a `foreach` loop is read-only. This means we cannot change its value inside
    the body of the loop. In each iteration of the loop, the iterator is assigned
    a value from the collection. When all of the elements of the collection have been
    iterated, the loop exits. Exiting the loop can also be done with a `break`, `goto`,
    `return`, or `throw` statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator`变量是一个循环迭代变量。在`foreach`循环中，循环迭代变量是只读的。这意味着我们不能在循环体内改变它的值。在循环的每次迭代中，迭代器被赋予集合中的一个值。当集合的所有元素都被迭代完时，循环退出。退出循环也可以通过`break`、`goto`、`return`或`throw`语句来实现。'
- en: 'Let''s take a look at the `foreach` loop with the help of the following code
    snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段来看一下`foreach`循环：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we have defined a string array that contains a list of programming
    languages. We are using a `foreach` loop to iterate through it and print each
    element of the array on the console. The output for this code is as in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个包含编程语言列表的字符串数组。我们使用`foreach`循环来迭代它，并在控制台上打印数组的每个元素。这段代码的输出如下截图所示：
- en: '![Figure 3.3 – The output of printing to the console the content of an array
    of strings using a foreach statement'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 使用foreach语句将字符串数组的内容打印到控制台的输出'
- en: '](img/Figure_3.3_B12346.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B12346.jpg)'
- en: Figure 3.3 – The output of printing to the console the content of an array of
    strings using a foreach statement
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 使用foreach语句将字符串数组的内容打印到控制台的输出
- en: 'The preceding `foreach` statement is semantically equivalent to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`foreach`语句在语义上等同于以下内容：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The collection type may not necessarily implement the `IEnumerable` or `IEnumerable<T>`
    interfaces, but it must have a public method called `GetEnumerator()`, that takes
    no parameters and returns a class, struct, or interface, and has a return type
    that contains a public property called `Current` and a public parameterless method
    called `MoveNext()` that returns `bool`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型可能并不一定实现`IEnumerable`或`IEnumerable<T>`接口，但它必须有一个名为`GetEnumerator()`的公共方法，不带参数并返回一个类、结构或接口，具有包含名为`Current`的公共属性和一个返回`bool`的公共无参数方法`MoveNext()`。
- en: 'If the `Current` property of the enumerator type returns a reference return
    value (which is made possible with C# 7.3), then you can declare the iteration
    variable with the `ref` or `ref only` modifier. An example of this is shown in
    this snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果枚举器类型的`Current`属性返回一个引用返回值（这是在C# 7.3中实现的），那么你可以用`ref`或`ref only`修饰符声明迭代变量。这个片段中展示了一个例子：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `arr` variable is `System.Span<int>`. The return type of its `GetEnumerator()`
    method, which is `Span<T>.Enumerator`, satisfies the condition mentioned earlier.
    The first `foreach` loop iterates through the elements of the array (a `stackalloc`
    array is allocated on the stack and disposed of as the function call returns)
    and doubles the initial value of each element. The second `foreach` loop iterates
    again through the elements but in a read-only fashion. An attempt to change the
    value of the iterator variable in a read-only loop would result in a compiler
    error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`arr`变量是`System.Span<int>`。其`GetEnumerator()`方法的返回类型`Span<T>.Enumerator`满足前面提到的条件。第一个`foreach`循环遍历数组的元素（`stackalloc`数组在堆栈上分配并在函数调用返回时被释放），并将每个元素的初始值加倍。第二个`foreach`循环再次以只读方式遍历元素。在只读循环中尝试更改迭代变量的值将导致编译器错误。
- en: The jump statements
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转语句
- en: 'Jump statements allow us to immediately transfer the control from one point
    in the application to another. C# provides us with five different jump statements:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转语句允许我们立即将控制从应用程序中的一个点转移到另一个点。C#为我们提供了五种不同的跳转语句：
- en: '`break`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`continue`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`goto`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto`'
- en: '`return`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`yield`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`'
- en: We will explore them in detail in the following sections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细探讨它们。
- en: The break statement
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: We already saw how to use `break` to exit out of a `switch` case. We can also
    terminate the execution of a loop using the `break` statement. Once the program
    control encounters a `break` statement inside a loop, the loop terminates immediately,
    and the control falls out of the loop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`break`来退出`switch` case。我们还可以使用`break`语句终止循环的执行。一旦程序控制在循环中遇到`break`语句，循环立即终止，控制流出循环。
- en: 'Take a look at the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are iterating from `0` to `10` and writing the current value to the
    console. If the value of the loop control variable becomes `5`, the loop will
    break, and no further element will be printed to the console. Although the loop
    is expected to run 10 times, the `break` statement makes it terminate immediately
    as the value of the iterator becomes `5`. Upon execution, you can see the following
    output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`0`到`10`进行迭代，并将当前值写入控制台。如果循环控制变量的值变为`5`，循环将中断，不会再将任何元素打印到控制台。尽管循环预计会运行10次，但`break`语句使其立即终止，因为迭代器的值变为`5`。执行后，您可以看到以下输出：
- en: '![Figure 3.4 – A screenshot of the console showing the output of the preceding
    snippet'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 控制台截图显示前面片段的输出'
- en: '](img/Figure_3.4_B12346.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B12346.jpg)'
- en: Figure 3.4 – A screenshot of the console showing the output of the preceding
    snippet
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 控制台截图显示前面片段的输出
- en: The `break` statement is not the only statement that can control the execution
    of a loop. Another one is `continue`, which we will look at in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句不是唯一可以控制循环执行的语句。另一个是`continue`，我们将在下一节中看到。'
- en: The continue statement
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`continue`语句'
- en: The `continue` statement passes control to the next iteration of an enclosing
    loop, be it `for`, `while`, `do`, or `foreach`. It is used to terminate the execution
    of the loop body in the current iteration and skip to the next one. The `continue`
    statement does not determine the return from the loop statement, but only aborts
    the execution of the current iteration and moves the control to the evaluation
    of the loop condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句将控制传递到封闭循环的下一次迭代，无论是`for`、`while`、`do`还是`foreach`。它用于终止当前迭代中循环体的执行并跳到下一个迭代。`continue`语句不确定循环语句的返回，而只是中止当前迭代的执行并将控制移动到循环条件的评估。'
- en: 'Take a look at the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we iterate from `0` to `10`; if the value is an even number,
    then we skip the current iteration loop and continue to the next one. This code
    will print only the odd numbers between `0` and `10`. The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从`0`到`10`进行迭代；如果值是偶数，则跳过当前迭代循环，继续下一个。这段代码将只打印出`0`到`10`之间的奇数。输出如下：
- en: '![Figure 3.5 – The output of the previous snippet that prints to the console
    the odd numbers smaller than 10'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 打印到控制台的前一个片段的输出，小于10的奇数'
- en: '](img/Figure_3.5_B12346.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B12346.jpg)'
- en: Figure 3.5 – The output of the previous snippet that prints to the console the
    odd numbers smaller than 10
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 打印到控制台的前一个片段的输出，小于10的奇数
- en: The `break` and `continue` statements control the execution of loops. The next
    statement is used to end the execution of functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句控制循环的执行。下一个语句用于结束函数的执行。'
- en: The return statement
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回语句
- en: The `return` statement terminates the current execution flow and returns the
    control to the calling method. Optionally, we can also return a value to the calling
    method. If the method has a return type defined, we need to return a value. Otherwise,
    when the return type is void, we can return without specifying any value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句终止当前执行流并将控制返回到调用方法。可选地，我们还可以向调用方法返回一个值。如果方法有定义返回类型，我们需要返回一个值。否则，当返回类型为void时，我们可以返回而不指定任何值。'
- en: 'The following example shows a possible implementation of a function that returns
    the nth Fibonacci number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个可能的实现，该函数返回第n个斐波那契数：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `return` statement triggers the stopping of the current function execution
    and the return of the control to the calling function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句触发当前函数执行的停止，并将控制返回到调用函数。'
- en: The goto statement
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转语句
- en: The `goto` statement is an unconditional jump statement. When the program control
    encounters a `goto` statement, it will jump to the location specified by it. The
    target for `goto` is specified using a *label*, which is an identifier followed
    by a colon (`:`). We can also use `goto` to exit from a loop. In this case, it
    will behave similarly to a `break` statement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句是一个无条件跳转语句。当程序控制遇到`goto`语句时，它将跳转到指定的位置。`goto`的目标使用*标签*指定，标签是一个标识符后跟一个冒号（`:`）。我们也可以使用`goto`来退出循环。在这种情况下，它的行为类似于`break`语句。'
- en: 'Consider the following code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we are iterating from `0` to `10`. If the value of the iterator
    becomes `5`, we will use a `goto` statement to jump out of the loop. The output
    for this code snippet is shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从`0`到`10`进行迭代。如果迭代器的值变为`5`，我们将使用`goto`语句跳出循环。这段代码的输出如下所示：
- en: '![Figure 3.6 – The console output from the preceding code snippet'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 前述代码片段的控制台输出'
- en: '](img/Figure_3.6_B12346.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B12346.jpg)'
- en: Figure 3.6 – The console output from the preceding code snippet
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 前述代码片段的控制台输出
- en: The use of a `goto` statement is generally avoided as a good programming practice
    because it can lead to code that is unstructured and hard to maintain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免使用`goto`语句作为良好的编程实践，因为它可能导致代码结构混乱且难以维护。
- en: The yield statement
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: yield语句
- en: '`yield` is a contextual keyword (that is, a word that provides a specific meaning
    in code without being a reserved word). It indicates that the method, operator,
    or `get` accessor, where it appears preceding a `return` or `break` statement,
    is an iterator. The sequence returned from an iterator method can be consumed
    using a `foreach` statement. The `yield` statement makes it possible to return
    values as they are produced and consume them as they are available, which is especially
    useful in an asynchronous context.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`是一个上下文关键字（即，在代码中提供特定含义而不是保留字的单词）。它表示在出现在`return`或`break`语句之前的方法、运算符或`get`访问器中，它是一个迭代器。从迭代器方法返回的序列可以使用`foreach`语句进行消耗。`yield`语句使得可以在生成时返回值并在可用时进行消耗，这在异步环境中特别有用。'
- en: 'To better understand the use of `yield`, let''s consider the following example.
    We have a function, let''s call it `GetNumbers()`, that returns a collection with
    all the numbers from `1` to `100`. A possible implementation is shown in the following
    snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`yield`的用法，让我们考虑以下例子。我们有一个函数，让我们称之为`GetNumbers()`，它返回从`1`到`100`的所有数字的集合。可能的实现如下所示：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The problem with this implementation is that we cannot consume the numbers before
    all of them are produced. On one hand, in a real example, this could be time consuming
    and we might want to consume the numbers as they are produced. On the other hand,
    we might be only interested in some of the numbers, but not all of them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的问题在于我们无法在所有数字都生成之前消耗这些数字。一方面，在实际例子中，这可能是耗时的，我们可能希望在生成数字时消耗这些数字。另一方面，我们可能只对其中一些数字感兴趣，而不是所有数字。
- en: 'With this implementation, we have to first produce all of them before using
    those that we need. In the following example, we only print the first five numbers
    to the console:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现方式，我们必须先生成所有需要的数字，然后再使用我们需要的数字。在下面的例子中，我们只将前五个数字打印到控制台上：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A `yield return` statement returns an item as soon as it is available. It is
    shorthand for creating an iterator, something that would make the code more laborious.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield return`语句会在项目可用时立即返回该项目。这是创建迭代器的一种简写，这样会使代码变得更加费力。'
- en: 'The implementation of `GetNumbers()` would change to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNumbers()`的实现将改为以下内容：'
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We return each number as it is available and do this only as long as we iterated
    through the enumerator, such as with a `foreach` statement. The preceding example,
    which prints the first five numbers to the console, remains unchanged. However,
    the execution is different because only five iterations in the `for` loop will
    be executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在项目可用时返回每个数字，并且只有在我们通过枚举器进行迭代时才这样做，比如使用`foreach`语句。前面的例子，将前五个数字打印到控制台上的例子，保持不变。但是，执行方式不同，因为`for`循环只会执行五次迭代。
- en: 'To understand this better, let''s change the example a bit so that a message
    is displayed to the console before every item is produced and consumed respectively:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们稍微改变一下例子，以便在生成和消耗每个项目之前分别在控制台上显示一条消息：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A call to `Thread.Sleep()` is used to simulate a one-second delay in producing
    the next number. The result of the execution of this code is shown in the following
    image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Thread.Sleep()`用于模拟产生下一个数字时的一秒延迟。这段代码的执行结果如下图所示：
- en: '![Figure 3.7 – The result of the execution of the preceding code'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 - 前述代码执行的结果'
- en: '](img/Figure_3.7_B12346.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B12346.jpg)'
- en: Figure 3.7 – The result of the execution of the preceding code
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - 前述代码的执行结果
- en: Now that we've seen how we can return from the normal execution of the code,
    let's take a quick look at how we can handle abnormal situations when unexpected
    errors occur during the execution of the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何从代码的正常执行中返回，让我们快速看一下在代码执行过程中发生意外错误时如何处理异常情况。
- en: Exception handling
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: There are scenarios where our code produces an error. The error might occur
    because of a logical issue in the code, such as trying to divide by zero or access
    an element in an array beyond the bounds of the array. For example, trying to
    access the fourth element in an array of size three. Errors can also occur because
    of external factors, such as trying to read a file that does not exist on a disk.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下我们的代码会产生错误。错误可能是由于代码中的逻辑问题引起的，比如试图除以零或访问数组中超出数组边界的元素。例如，试图访问一个大小为三的数组中的第四个元素。错误也可能是由外部因素引起的，比如试图读取磁盘上不存在的文件。
- en: 'C# provides us with a built-in exception-handling mechanism to handle these
    types of errors at the code level. The syntax for exception handling is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C#为我们提供了一个内置的异常处理机制，以处理代码级别的这些类型的错误。异常处理的语法如下：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `try` block can contain one or more statements. The `catch` block contains
    the error handling code. The `finally` block contains the code that will execute
    after the `try` section. This happens regardless of whether the execution resumed
    normally, or the control left the `try` block because of a `break`, `continue`,
    `goto`, or `return` statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块可以包含一个或多个语句。`catch`块包含错误处理代码。`finally`块包含在`try`部分之后将执行的代码。这无论执行是否恢复正常，或者控制是否因`break`、`continue`、`goto`或`return`语句而离开`try`块。'
- en: If an exception occurred and a `catch` block exists, the `finally` block is
    also guaranteed to execute. If the exception is unhandled, the execution of the
    `finally` block depends on how the exception unwind operation is triggered, which
    depends on how the running machine is set up. The `finally` block is optional.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常并且存在`catch`块，则`finally`块也一定会执行。如果异常未被处理，`finally`块的执行取决于异常展开操作是如何触发的，这取决于运行机器的设置。`finally`块是可选的。
- en: Upon execution, the program control will execute the code inside the `try` block.
    If no error occurs in the `try` block, the execution continues normally and control
    transfers to the `finally` block, if it exists. When an exception occurs inside
    the `try` block, program control will transfer to a `catch` block, if one exists.
    After the execution of a `catch` block, the program control will transfer to the
    `finally` block, if it exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，程序控制将执行`try`块内的代码。如果`try`块中没有发生错误，执行将继续正常进行，并且控制转移到`finally`块（如果存在）。当`try`块内发生异常时，程序控制将转移到`catch`块（如果存在）。在执行`catch`块后，程序控制将转移到`finally`块（如果存在）。
- en: Multiple `catch` clauses may exist for the same `try` block. The order they
    are listed in is important because they are evaluated in that given order. This
    means more specific exceptions should be caught before more general ones. It is
    possible to specify a `catch` clause without an exception type in order to catch
    all exceptions. However, this is considered rather a bad practice because you
    should only catch exceptions that you know how to handle and recover from.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个`try`块可能存在多个`catch`子句。它们列出的顺序很重要，因为它们按照给定的顺序进行评估。这意味着更具体的异常应该在更一般的异常之前捕获。可以指定一个没有异常类型的`catch`子句，以捕获所有异常。但是，这被认为是一个不好的做法，因为您应该只捕获您知道如何处理和恢复的异常。
- en: When an exception occurs, the `catch` block to handle it in the method that
    is currently executing. If one does not exist, it looks in the method that called
    the current method, and so on up the call stack. If no matching `catch` block
    is found, an unhandled exception message is displayed, and the execution of the
    program is aborted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，`catch`块处理当前执行的方法。如果不存在`catch`块，则会查找调用当前方法的方法，依此类推。如果找不到匹配的`catch`块，则会显示未处理的异常消息，并且程序的执行将被中止。
- en: 'Let''s try to understand exception handling with the help of the following
    code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过以下代码片段来理解异常处理：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are trying to simulate a *division by zero error*. When an error occurs
    inside the `try` block, it will create an instance of the `Exception` class and
    throw the exception. In the `catch` block, we are specifying an argument of the
    `Exception` type. The exception provides us with an error message but also with
    information about where the error occurred (filename and path) as well as the
    call stack.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图模拟*除零错误*。当在`try`块内发生错误时，它将创建`Exception`类的一个实例并抛出异常。在`catch`块中，我们指定了`Exception`类型的参数。异常提供了错误消息，还提供了关于错误发生位置（文件名和路径）以及调用堆栈的信息。
- en: 'If we only want the message associated with the exception, we can use the `Message`
    property of the `Exception` class. The output of this code snippet is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想要与异常相关联的消息，我们可以使用`Exception`类的`Message`属性。此代码片段的输出如下：
- en: '![Figure 3.8 – The console showing the message of a division by zero exception'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - 控制台显示除零异常的消息'
- en: '](img/Figure_3.8_B12346.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B12346.jpg)'
- en: Figure 3.8 – The console showing the message of a division by zero exception
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 控制台显示除零异常的消息
- en: Exceptions are thrown with the `throw` statement. You must specify an instance
    of the `System.Exception` class or a class derived from it. Classes will be discussed
    in *Chapter 4*, *Understanding the Various User-Defined Types*, and inheritance
    in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103), *Object-Oriented
    Programming in C#*, but for the time being keep in mind that there are many exception
    types and they are all based on `System.Exception`. The `throw` statement can
    be used in a `catch` block without any argument to re-throw the exception, preserving
    the call stack. This is useful when you want to do something in the case of an
    exception, such as logging, but also want to pass the exception forward to be
    fully handled in a different place.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是使用`throw`语句抛出的。您必须指定`System.Exception`类的一个实例或从它派生的类。类将在*第4章*，*理解各种用户定义类型*中讨论，继承在[*第5章*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103)，*C#面向对象编程*中讨论，但目前请记住，有许多异常类型，它们都基于`System.Exception`。`throw`语句可以在`catch`块中使用，而不带任何参数来重新抛出异常，保留调用堆栈。当您想在发生异常时执行某些操作（如记录），但也希望将异常传递到另一个地方进行完全处理时，这是有用的。
- en: 'In the following example, a function called `FunctionThatThrows()` does something,
    but not before checking its input argument. If the `object` argument is `null`,
    it throws an exception of the `ArgumentNullException` type. However, if the argument
    is not null but of a type other than `string`, it throws an exception of the `ArgumentException`
    type. This is the base class for `ArgumentNullException`. When invoking the method,
    we catch multiple exception types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，一个名为`FunctionThatThrows()`的函数做一些事情，但在检查其输入参数之前。如果`object`参数为`null`，它会抛出`ArgumentNullException`类型的异常。然而，如果参数不为null，但类型不是`string`，它会抛出`ArgumentException`类型的异常。这是`ArgumentNullException`的基类。在调用该方法时，我们捕获多个异常类型：
- en: '`ArgumentNullException`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArgumentNullException`'
- en: '`ArgumentException`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArgumentException`'
- en: '`Exception`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`'
- en: 'The order is important because it starts with the most-derived class and ends
    with the base class of all exceptions. A `finally` block is used to display a
    message at the end of the execution:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要，因为它从最派生的类开始，以所有异常的基类结束。`finally`块用于在执行结束时显示消息：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the execution of this program is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的执行输出如下：
- en: '![Figure 3.9 – The console output from the execution of the previous snippet'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 从前面片段执行的控制台输出'
- en: '](img/Figure_3.9_B12346.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B12346.jpg)'
- en: Figure 3.9 – The console output from the execution of the previous snippet
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 从前面片段执行的控制台输出
- en: The topic of exception handling will be discussed in greater detail in [*Chapter
    14*](B12346_14_Final_JC_ePub.xhtml#_idTextAnchor253), *Error Handling*. If you
    want to learn more about exceptions at this point, you can go ahead and read this
    chapter before continuing with the next one.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的主题将在[*第14章*](B12346_14_Final_JC_ePub.xhtml#_idTextAnchor253)中进行更详细的讨论，*错误处理*。如果你想在这一点上了解更多关于异常的知识，你可以继续阅读这一章，然后再继续下一章。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored control statements in C#. We learned how the different
    types of loops and jump statements work with the help of examples. We also looked
    briefly at how to throw and catch exceptions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C#中的控制语句。我们通过示例学习了不同类型的循环和跳转语句的工作原理。我们还简要介绍了如何抛出和捕获异常。
- en: In the next chapter, we will look at user-defined types and explore what fields,
    properties, methods, indexers, and constructors are in a class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看用户定义的类型，并探索类中的字段、属性、方法、索引器和构造函数。
- en: Test what you learned
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到的东西
- en: What are the selection statements available in the C# language?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#语言中有哪些选择语句可用？
- en: Where can the default case of a `switch` statement appear and when it is evaluated?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句的默认情况可以出现在哪里，何时进行评估？'
- en: What is the difference between a `for` and a `foreach` statement?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`和`foreach`语句有什么区别？'
- en: What is the difference between a `while` and a `do-while` statement?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`和`do-while`语句有什么区别？'
- en: What statements can you use to return from a function?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些语句来从函数返回？
- en: Where can you use a `break` statement and how does it work?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在哪里使用`break`语句，它是如何工作的？
- en: What does the `yield` statement do and in which scenarios is it used?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`yield`语句是做什么的，它在哪些场景中使用？'
- en: How do you catch all the exceptions from a function call?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何捕获函数调用中的所有异常？
- en: What does the `finally` block do?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`块是做什么的？'
- en: What is the base class for all exceptions in .NET?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中所有异常的基类是什么？
