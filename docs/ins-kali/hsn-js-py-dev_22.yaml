- en: Node.js and MongoDB
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和MongoDB
- en: 'You may have heard of the **MEAN** stack: MongoDB, Express, Angular, and Node.js,
    or the **MERN** stack: MongoDB, Express, React, and Node.js. The missing piece
    that we have yet to discuss is MongoDB. Let’s explore how this NoSQL database
    can be used directly from Express. We''ll be constructing the next iteration of
    our starship game that we started in [Chapter 13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml), *Using
    Express*, except this time using MongoDB and incorporating a bit of testing!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过**MEAN**堆栈：MongoDB、Express、Angular和Node.js，或者**MERN**堆栈：MongoDB、Express、React和Node.js。我们尚未讨论的缺失部分是MongoDB。让我们探讨一下这个NoSQL数据库如何可以直接从Express中使用。我们将构建我们在[第13章](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml)中开始的星际飞船游戏的下一个迭代，*使用Express*，只是这次使用MongoDB并且加入了一些测试！
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Using MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB
- en: Testing with Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest进行测试
- en: Storing and retrieving data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和检索数据
- en: Wiring your API together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API连接在一起
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Be prepared to work with the code provided in the `chapter-18` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18).
    As we''ll be working with command-line tools, also make sure to have your Terminal
    or command-line shell available. We''ll need a modern browser and a local code
    editor.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好使用存储库的`chapter-18`目录中提供的代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18)。由于我们将使用命令行工具，还要确保您的终端或命令行
    shell 可用。我们需要一个现代浏览器和一个本地代码编辑器。
- en: Using MongoDB
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB
- en: 'The base premise behind MongoDB that makes it different from other types of
    structured key/value pair databases is that it''s *schemaless*: you can insert
    arbitrary **documents** of unstructured data without concern for what another
    entry in the database looks like. A document in NoSQL parlance is something already
    familiar to us: a JavaScript object!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的基本前提是，它与其他类型的结构化键/值对数据库不同的地方在于它是*无模式*的：您可以插入无结构数据的任意**文档**，而不必担心数据库中的另一个条目是什么样子。在NoSQL术语中，文档对我们来说已经很熟悉了：一个JavaScript对象！
- en: 'Here''s a document:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can see that it''s a basic JavaScript object; more specifically, it''s JSON,
    which means it can also support nested data. Here''s an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它是一个基本的JavaScript对象；更具体地说，它是JSON，这意味着它也可以支持嵌套数据。这是一个例子：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So how does this differ from MySQL? Consider this MySQL schema:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这与MySQL有什么不同呢？考虑一下这个MySQL模式：
- en: '![](assets/078e1d97-f520-4a0e-bcfb-bd3bbbc984f9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/078e1d97-f520-4a0e-bcfb-bd3bbbc984f9.png)'
- en: Figure 18.1 – An example of a MySQL database table structure
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 - 一个MySQL数据库表结构的示例
- en: If you're familiar with SQL databases, you know that each field type in a database
    table must be specifically typed. When retrieving from a SQL-type database, we
    use **S****tructured Query Language** (**SQL**). Just as our tables are structured,
    so are our queries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉SQL数据库，您会知道数据库表中的每个字段类型必须是特定类型的。在从SQL类型数据库检索时，我们使用**结构化查询语言**（**SQL**）。正如我们的表结构化一样，我们的查询也是结构化的。
- en: 'We need to create our database tables before using them, and in SQL it''s advised
    not to change their structure once created without doing some additional cleanup
    work. Here''s how we would create our preceding table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据库表之前，我们需要创建数据库表，在SQL中，建议不要在创建后更改其结构，而不进行一些额外的清理工作。以下是我们将创建我们之前的表的方法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, for MongoDB, we *won't* be constructing tables with predefined datatypes
    and lengths. Instead, we will insert JSON blobs into our database as **documents**.
    The idea behind MongoDB is very similar to when we used Firebase in [Chapter 17](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml),
    *Security and Keys,* inserting JSON and querying it, even with multiple nested
    JSON objects versus storing, cross-joining, and querying multiple tables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于MongoDB，我们*不会*构建具有预定义数据类型和长度的表。相反，我们将将JSON块插入到我们的数据库中作为**文档**。MongoDB的理念与我们在[第17章](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml)中使用Firebase时非常相似，*安全和密钥*，插入JSON并对其进行查询，即使有多个嵌套的JSON对象，而不是存储、交叉连接和查询多个表。
- en: 'Imagine that we have the following two documents:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下两个文档：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How do we insert them into our database? This would be with MySQL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将它们插入到我们的数据库中？这将使用MySQL：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The answer with MongoDB is actually much easier than SQL, because we can place
    arrays easily and not have to worry about datatypes or ordering the data! We can
    just shove in the document without worrying about anything else, which is more
    likely to be how we receive it from the frontend:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB的答案实际上比SQL要容易得多，因为我们可以轻松地放置数组，而不必担心数据类型或数据排序！我们可以只是把文档塞进去，而不必担心其他任何事情，这更有可能是我们从前端接收到的方式：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, for example, to get all active administrators from the preceding `admins` table, we
    would write something like this in MySQL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从前述的`admins`表中获取所有活动管理员，我们在MySQL中会写出类似于这样的内容：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `first_name` and `last_name` fields are pre-defined as type `VARCHAR` (variable
    characters) with a maximum length of 50 characters. `admin_role` and `status`
    are `ENUM` (enumerated types) with predefined possible values (like a dropdown
    selection list on a site). However, here''s how we would construct our query in
    MongoDB:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`first_name`和`last_name`字段被预定义为`VARCHAR`类型（可变字符），最大长度为50个字符。`admin_role`和`status`是`ENUM`（枚举类型），具有预定义的可能值（就像站点上的下拉选择列表）。然而，这是我们如何在MongoDB中构造我们的查询：'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We won't go *too* deep into MongoDB syntax here as it's a bit out of scope for
    this book and we'll only be using simple queries. With that being said, we should
    understand a bit more before we get started.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会深入研究MongoDB的语法，因为这有点超出了本书的范围，我们只会使用简单的查询。话虽如此，在我们开始之前，我们应该了解更多。
- en: 'Here is the list of mongo commands we''ll use while making our game:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在制作游戏时将使用的mongo命令列表：
- en: '`find`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`'
- en: '`findOne`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一个
- en: '`insertOne`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertOne`'
- en: '`updateOne`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateOne`'
- en: '`updateMany`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateMany`'
- en: 'Fairly manageable, right? We can break down many MongoDB commands into the
    following general syntactical structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 相当容易管理，对吧？我们可以将许多 MongoDB 命令分解为以下一般的句法结构：
- en: '`<dbHandle>.<collectionName>.<method>(query, projection)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dbHandle>.<collectionName>.<method>(query, projection)`'
- en: 'Here, `query` and `projection` are objects that dictate our usage of MongoDB.
    For example, in our preceding statement, `{ status: ''active'', admin_role: ''admin''
    }` is our query to specify that we want those fields to equal those values. The
    projection in this example specifies what we want to return.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`query` 和 `projection` 是指导我们使用 MongoDB 的对象。例如，在我们前面的语句中，`{ status: ''active'',
    admin_role: ''admin'' }` 是我们的查询，指定我们希望这些字段等于这些值。这个例子中的 projection 指定了我们想要返回的内容。'
- en: Let's dive into our project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入我们的项目。
- en: Getting started
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'The first thing we can do is download MongoDB Community Server from [https://MongoDBdb.com](https://mongodb.com).
    When you have it installed, navigate to the `chapter-18/starships` directory from
    our GitHub repository and let''s try to get it started:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是从 [https://MongoDBdb.com](https://mongodb.com) 下载 MongoDB Community
    Server。当你安装好后，从我们的 GitHub 仓库中导航到 `chapter-18/starships` 目录，让我们尝试启动它：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have everything installed correctly, you should see a flurry of notification
    messages, ending with one that says something similar to `[initandlisten] waiting
    for connections on port 27017`. If all does *not* go as planned, spend some time
    to ensure your installation is working properly. A useful tool is MongoDB Compass,
    a GUI tool for connecting to MongoDB. Be sure to check permissions and that the
    appropriate ports are open, as we'll use port `27017` (MongoDB's default port)
    for connections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切安装正确，你应该会看到一大堆通知消息，最后一条消息类似于 `[initandlisten] waiting for connections on
    port 27017`。如果一切不如预期，花些时间确保你的安装工作正常。一个有用的工具是 MongoDB Compass，一个连接到 MongoDB 的 GUI
    工具。确保检查权限，并且适当的端口是打开的，因为我们将使用端口 `27017`（MongoDB 的默认端口）进行连接。
- en: 'This chapter will be a lab exercise to take our starship game to the next level.
    Here''s what we''ll be building:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个实验，将我们的星际飞船游戏提升到一个新的水平。这是我们将要构建的内容：
- en: '![](assets/d1e3f192-dd3e-4e85-bfab-0aa9736880b6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d1e3f192-dd3e-4e85-bfab-0aa9736880b6.png)'
- en: Figure 18.2 – Creating our fleet
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2 – 创建我们的舰队
- en: 'Then, we''re going to wire it to MongoDB and actually execute gameplay in this
    interface:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把它连接到 MongoDB，并在这个界面上实际执行游戏：
- en: '![](assets/a8cc72ad-3d1c-4b9a-8413-94d1bd2be86b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8cc72ad-3d1c-4b9a-8413-94d1bd2be86b.png)'
- en: Figure 18.3 – Attack the enemy!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3 – 攻击敌人！
- en: We'll be using a simplified version of MERN and using vanilla JavaScript instead
    of React, relying on Express to render our HTML in a less controlled manner than
    React. Maybe *JEMN stack* would be a good name?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简化版本的 MERN，使用原生 JavaScript 而不是 React，依赖于 Express 以一种比 React 更少受控的方式呈现我们的
    HTML。也许 *JEMN stack* 是一个好的名字？
- en: Before we get to writing actual code, let's examine the setup of the project
    and get started with testing!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写实际代码之前，让我们检查项目的设置并开始测试！
- en: Testing with Jest
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jest 进行测试
- en: In the `starships` directory, you'll find the completed game. Let's dissect
    it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `starships` 目录中，你会找到完成的游戏。让我们来剖析一下。
- en: 'Here''s the directory listing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目录列表：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're going to take a little bit of a different approach here than our other
    projects and implement a very light cycle of **Test-Driven Development** (**TDD**).
    TDD is the practice of writing tests that *fail*, before writing your code that
    works. While we're not implementing true TDD, the idea of guiding our thought
    process using testing is what we'll be doing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取一种与我们其他项目有些不同的方法，在这里实现一个非常轻量级的**测试驱动开发**（**TDD**）循环。TDD 是在编写能够工作的代码之前编写失败的测试的实践。虽然我们没有实现真正的
    TDD，但使用测试来引导我们的思维过程是我们将要做的事情。
- en: 'We''ll be using Jest as our testing framework. Let''s look at the steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jest 作为我们的测试框架。让我们来看一下步骤：
- en: 'Inside the `tests` directory, create a new file named `test.test.js`. The first
    `test` is the name for our test suite, and the convention of ending files in `.test.js` indicates
    to the testing framework that this is a test suite to execute. Inside the file,
    create this test script:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests` 目录中，创建一个名为 `test.test.js` 的新文件。第一个 `test` 是我们测试套件的名称，以 `.test.js`
    结尾的约定表示这是一个要执行的测试套件。在文件中，创建这个测试脚本：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the test with `node_modules/.bin/jest test.test.js` (be sure you''ve already
    run `npm install`!). You''ll get output from the test suite similar to the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `node_modules/.bin/jest test.test.js` 运行测试（确保你已经运行了 `npm install`！）。你将会得到类似以下的测试套件输出：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've just written our first test suite! It simply says "I expect 1 to equal
    1\. If it does, pass the test. If not, fail the test." Pretty powerful for five
    lines of code, right? OK, maybe not, but this will provide us with the scaffolding
    for all of our other tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了我们的第一个测试套件！它简单地说“我期望 1 等于 1。如果是，通过测试。如果不是，测试失败。”对于五行代码来说，相当强大，对吧？好吧，也许不是，但这将为我们的所有其他测试提供支架。
- en: 'Let''s look at the MongoDB model: `models/mongo.js`*:*'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们来看一下 MongoDB 模型：`models/mongo.js`*:* '
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So far, we''re just setting up our MongoDB connection. Make sure you still
    have your MongoDB connection running now:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在设置我们的 MongoDB 连接。确保你现在仍然有你的 MongoDB 连接运行着：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As with all good database connection code, we''re executing our code in a *try/catch*
    block to be sure that our connection is made correctly:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有良好的数据库连接代码一样，我们在一个 *try/catch* 块中执行我们的代码，以确保我们的连接正确建立：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sneak peek: we''re going to be using this `MongoDB.js` file from our tests
    and models. The `module.exports` line specifies which functions are exported from
    this file and exposed to other parts of our program. We''ll be using this export
    directive consistently throughout our program: when we want to expose a method,
    we''ll use an export.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 预览：我们将在测试和模型中使用这个 `MongoDB.js` 文件。`module.exports` 行指定了从这个文件导出并暴露给我们程序的其他部分的函数。我们将在整个程序中一贯使用这个导出指令：当我们想要暴露一个方法时，我们会使用一个导出。
- en: 'Return to `test.test.js` and include our MongoDB model at the beginning of
    the file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `test.test.js` 并在文件开头包含我们的 MongoDB 模型：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s get a little fancier with our test suite. Augment the suite with
    the following code *inside* our `describe` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的测试套件中变得更加花哨一点。在我们的`describe`方法*内*增加以下代码：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And add the following case after our simple test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们简单的测试之后添加以下情况：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then run it with the same command as before: `node_modules/.bin/jest test.test.js`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用与之前相同的命令运行它：`node_modules/.bin/jest test.test.js`。
- en: What's happening here? First of all, before every individual test in our test
    suite, we're specifying to connect to the database as per the method we wrote
    in our MongoDB model. After everything is done, tear down the database and disconnect.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，在我们的测试套件中的每个单独的测试之前，我们正在指定按照我们在MongoDB模型中编写的方法连接到数据库。在一切都完成之后，拆除数据库并断开连接。
- en: And what happens when we run it? An epic failure!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时会发生什么？一个史诗般的失败！
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We should be expecting an error because we haven''t yet *inserted* any information
    into a collection named `names` (or any other data!). Welcome to TDD: we wrote
    a test that fails before we wrote the code to make it pass.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该期望出现错误，因为我们还没有向名为`names`（或任何其他数据）的集合中*插入*任何信息！欢迎来到TDD：我们编写了一个在编写代码之前就失败的测试。
- en: Obviously, our next step in the process is to actually insert some data! Let's
    do that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在这个过程中的下一步是实际插入一些数据！让我们这样做。
- en: Storing and retrieving data
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和检索数据
- en: 'Let''s work with a test suite that I wrote to help make sure that our MongoDB
    connection is a bit more robust and includes inserting data into the database
    and then testing to be sure it exists:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我编写的一个测试套件来确保我们的MongoDB连接更加健壮，并包括将数据插入数据库，然后测试以确保它存在：
- en: 'Examine `test/setup.model.test.js`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`test/setup.model.test.js`：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run `node_modules/.bin/jest setup`, we''ll see success because the `insertRandomNames()`
    method exists from our setup model. So let''s take a look at our setup model (`models/setups.js`)
    and see what it''s doing to populate the database:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行`node_modules/.bin/jest setup`，我们会看到成功，因为我们的设置模型中存在`insertRandomNames()`方法。所以让我们来看看我们的设置模型（`models/setups.js`）并看看它是如何填充数据库的：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Not too bad! We have one exported method that inserts names into the database
    based on a JSON file of "random" starship names that I''ve provided. The file
    is read and then put into the database as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还不错！我们有一个导出的方法，根据我提供的“随机”星际飞船名称的JSON文件将名称插入到数据库中。文件被读取，然后按以下方式放入数据库中：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since we're not getting too far into the guts of MongoDB itself, suffice to
    say that this line translates to "in the `names` collection (even if it doesn't
    yet exist), set the `names` key to equal the JSON. Update or insert as necessary".
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并没有深入了解MongoDB本身的细节，可以说这行代码的意思是“在`names`集合中（即使它还不存在），将`names`键设置为相等的JSON。根据需要更新或插入”。
- en: We can now populate our database with ship names that we'll use from here on
    out. Execute `npm run install-data`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用我提供的“随机”星际飞船名称的JSON文件来填充我们的数据库。执行`npm run install-data`。
- en: So far, so good! There are many files in this project, so we won't walk through
    *all* of them; let's examine a representational sample.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好！在这个项目中有很多文件，所以我们不会遍历*所有*文件；让我们检查一个代表性的样本。
- en: Models, views, and controllers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型，视图和控制器
- en: The **Model-View-Controller** (**MVC**) paradigm is what we're using here within
    Express. While not really necessary in Express, I find the logical separation
    of concerns is useful and easier to work with than monolithic types of undifferentiated
    files. Before we go too far, I will mention that MVC could be considered an outdated
    pattern, as it does create some additional dependencies between layers. With that
    being said, the ideas behind an architectural paradigm that separates logic into
    discrete actors are sound in MVC. You may hear **MV*** used instead, which basically
    should be read as "model, view, and whatever that binds them together." MV* is
    more popularly used these days in certain frameworks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）范式是我们在Express中使用的。虽然在Express中并不是真正必要的，但我发现逻辑上的关注点分离比单一类型的不可区分的文件更有用且更容易使用。在我们走得太远之前，我会提到MVC可能被认为是一种过时的模式，因为它确实在层之间创建了一些额外的依赖关系。话虽如此，将逻辑分离为离散的角色的架构范式背后的思想在MVC中是合理的。你可能会听到**MV***的使用，这基本上应该被理解为“模型，视图和将它们绑定在一起的任何东西”。在某些框架中，这些天MV*更受欢迎。'
- en: 'The MVC construction separates the logic of the program into three parts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: MVC结构将程序的逻辑分为三个部分：
- en: '**Models** deal with data interaction.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型**处理数据交互。'
- en: '**Views** handle the presentation layer.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图**处理表示层。'
- en: '**Controllers** handle data manipulation and serve as the glue between the
    models and the views.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制器**处理数据操作，并充当模型和视图之间的粘合剂。'
- en: 'Here''s a visual representation of the design pattern:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设计模式的一个可视化表示：
- en: '![](assets/6dc14b9e-b9c3-44da-bcc4-8f344c7fdb12.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6dc14b9e-b9c3-44da-bcc4-8f344c7fdb12.png)'
- en: Figure 18.4 – The MVC paradigm's lifecycle
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 - MVC范例的生命周期
- en: One of the more important parts to understand about this separation of concerns
    is that the View layer and the Controller layer are *never* supposed to interact
    directly with the Datastore; that honor is reserved for the models.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种关注点分离的更重要的部分之一是，视图层和控制器层*永远*不应直接与数据存储交互；这一荣誉是为模型保留的。
- en: 'Now let''s look at a view:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个视图：
- en: '*views/index.hbs*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*views/index.hbs*'
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Express is controlling our views, and we''re using Handlebars to handle our
    templating logic and loops. While simple in syntax, Handlebars is powerful and
    can greatly simplify our lives. In this case, we''re testing for and looping over
    the `ships` variable in order to create a table of the `ships` we have or to send
    a message that the fleet is empty. How does our view get `ships`? It''s given
    to the view from our **controller** by way of our **route**. Here''s what that
    looks like for this portion:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Express控制我们的视图，我们使用Handlebars来处理我们的模板逻辑和循环。虽然语法简单，但Handlebars功能强大，可以极大地简化我们的生活。在这种情况下，我们正在测试并循环遍历`ships`变量，以创建我们拥有的`ships`的表格，或者发送一条消息说舰队是空的。我们的视图如何获得`ships`？它是通过我们的**控制器**通过我们的**路由**提供给视图的。对于这部分，它看起来是这样的：
- en: '*routes/index.js*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*routes/index.js*'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Why are we using `var` here instead of `const` or `let`? And why the semicolons?
    The answer is this: at the time of writing, the Express scaffolding tool still
    uses `var` and semicolons. It''s always a best practice to standardize, but in
    this example I wanted to call attention to this fact. Feel free to standardize
    on the newer syntax as we work forward.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这里使用`var`而不是`const`或`let`？为什么要使用分号？答案是：在撰写本文时，Express脚手架工具仍然使用`var`和分号。标准化始终是最佳实践，但在这个例子中，我想引起注意。随时根据新的语法进行标准化。
- en: 'And now for the `getFleet` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`getFleet`方法：
- en: '*controllers/ships.js*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*controllers/ships.js*'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because this is a simple example, our controller doesn''t do much besides getting
    information from the model, which queries MongoDB. Let''s take a look at that:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个简单的例子，我们的控制器除了从模型获取信息外并没有做太多事情，模型查询MongoDB。让我们来看看：
- en: '*models/ships.js*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*models/ships.js*'
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The setup function dictates the connection to MongoDB (note the async/await
    setup!) and our fleet is either from the enemy or our fleet collection. The `return`
    line contains a convenience to sort the fleet by alphabetical order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数规定了与MongoDB的连接（注意异步/等待设置！），我们的舰队要么来自敌人，要么来自我们的舰队集合。`return`行包含了一个方便的方法，按字母顺序对舰队进行排序。
- en: In this example, we're going to keep the controllers fairly simple and rely
    on the model to do the heavy lifting. This is a stylistic decision, though it's
    good to pick one side of the application to do the majority of your work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将保持控制器相当简单，并依靠模型来完成大部分工作。这是一个风格上的决定，尽管选择应用程序的一边来完成大部分工作是很好的。
- en: It's time to look at the program from end to end.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从头到尾查看程序了。
- en: Wiring your API together
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将API连接在一起
- en: 'To further understand the gameplay, we''ll walk through the steps involved
    in firing a torpedo from a ship:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解游戏玩法，我们将逐步介绍从船只发射鱼雷的步骤：
- en: 'Locate the frontend JavaScript in `public/javascripts/play.js`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`public/javascripts/play.js`中找到前端JavaScript：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we''ve made a click handler on the `fire` buttons in our interface and
    identified our weapon and target ship:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的界面上为`fire`按钮创建了一个点击处理程序，并确定了我们的武器和目标船只：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This line might take a bit of unpacking. We''re making an AJAX call to our
    Node application from our JavaScript with certain query string parameters: `attacker`,
    `target`, and `weapon`. We''re also expecting JSON to be returned from our application.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行可能需要一些解释。我们正在从我们的JavaScript向我们的Node应用程序进行AJAX调用，带有特定的查询字符串参数：`attacker`，`target`和`weapon`。我们也期望从我们的应用程序返回JSON。
- en: 'Remember that our backticks allow us to *compose* a string with variables in `${
    }`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，我们的反引号允许我们*组合*一个带有`${ }`中变量的字符串：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're using **object destructuring** to extract each piece of the information
    contained within `data.target`. This is a bit more efficient than defining them
    one by one or even with a loop, right?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用**对象解构**从`data.target`中提取每个信息片段。这比逐个定义它们或甚至使用循环更有效，对吧？
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our target ship has been destroyed if `scuttled` is `true`, so let''s communicate
    that to the user. We''re going to edit the values of our ship in either case:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`scuttled`为`true`，我们的目标船只已被摧毁，因此让我们向用户传达这一点。无论哪种情况，我们都将编辑我们船只的值：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So that''s the frontend code. If we look at our `app.js` file, we can see that
    our AJAX call to `/play` goes to the `playRouter` from an `app.use` statement.
    Therefore, our next stop is the router:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前端代码。如果我们查看我们的`app.js`文件，我们可以看到我们对`/play`的AJAX调用转到`playRouter`，从`app.use`语句。因此，我们的下一站是路由器：
- en: '*routes/play.js*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*routes/play.js*'
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since our URL was constructed from `/play/fire`, we know that the second `router.get`
    statement is the one handling our request. Onward to the controller and its `fire`
    method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的URL是从`/play/fire`构建的，我们知道第二个`router.get`语句处理我们的请求。继续到控制器及其`fire`方法：
- en: '*controllers/ships.js*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*controllers/ships.js*'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we see the glue between the controller and the model.
    First of all, we''re getting the target and source ships. Why do you think I decided
    to use `let` for the target and `const` for the source? If you reasoned that the
    target will need to be mutable, you''re right: when we use the `registerDamage`
    method on our target, it''ll be more efficient to rewrite the variable instead
    of creating a new one.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了控制器和模型之间的粘合剂。首先，我们获取目标和源船只。你为什么认为我决定在目标上使用`let`，在源上使用`const`？如果你认为目标需要是可变的，你是对的：当我们在目标上使用`registerDamage`方法时，重写变量会比创建新变量更有效。
- en: Before we look at our model's `registerDamage` method, acknowledge that the
    return path so far is that the controller will return to the route that returns
    to our frontend script.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们的模型的`registerDamage`方法之前，请注意到迄今为止的返回路径是控制器将返回到返回到我们前端脚本的路由。
- en: Onward!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进！
- en: '*models/ships.js*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*models/ships.js*'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now *here* is where we're actually communicating with our database. We can see
    that we're retrieving our target, registering damage to its shields and possibly
    its hull, setting those values in MongoDB, and eventually returning the target
    ship's information back through the controller to eventually arrive at our frontend
    JavaScript.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在*这里*是我们实际与我们的数据库通信的地方。我们可以看到我们正在检索我们的目标，注册对其护盾和可能对其船体的损坏，将这些值设置在MongoDB中，并最终通过控制器将目标船的信息返回到我们的前端JavaScript。
- en: 'Let''s take a look at this line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这一行：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We're going to update one item in the collection to state whether it's an enemy
    ship or in our fleet, and set the shield strength and hull damage.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新集合中的一个项目，以说明它是敌船还是我们的舰队，并设置护盾强度和船体损坏。
- en: Exporting functions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出函数
- en: By now you may have noticed that some of the model methods, such as `registerDamage`,
    are prefaced with `exports` while others, such as `eliminateExistingShips`, are
    not. One aspect of good design in complex JavaScript applications is encapsulating
    the functions that are not designed to be used outside of a certain context. When
    prefaced with `exports`, a function can be invoked from a different context, such
    as from our controller. If it's not designed to be exposed to the rest of the
    application; in essence, it's a private function. The concept of exporting a variable
    is similar to the concept of scope in that we're making sure to keep our application
    clean and expose only the useful bits of the program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到一些模型方法，比如`registerDamage`，是以`exports`为前缀的，而其他一些方法，比如`eliminateExistingShips`，则没有。在复杂的JavaScript应用程序中，良好的设计方面之一是封装那些不打算在特定上下文之外使用的函数。当以`exports`为前缀时，可以从不同的上下文中调用函数，比如从我们的控制器中。如果它不打算暴露给应用程序的其他部分；本质上，它是一个私有函数。导出变量的概念类似于作用域的概念，我们确保保持应用程序的整洁，并且只公开程序的有用部分。
- en: 'If we take a look at `eliminateExistingShips`, we can see it''s just a helper
    function used by `createRandom` to make sure we''re not assigning the same ship
    registry number or name to two different ships. We can see this usage here in
    `createRandom`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`eliminateExistingShips`，我们可以看到它只是一个辅助函数，由`createRandom`使用，以确保我们不会将相同的船只注册编号或名称分配给两艘不同的船只。我们可以在`createRandom`中看到这种用法：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*more code... then:*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*更多代码...然后：*'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To make sure that our ship's registry number is unique to our fleet, we'll use
    a `while` loop to keep updating the ship's registry number until it's not one
    that already exists. Using the `eliminateExistingShips` helper function, we return
    and destructure the names and registries that already exist in our fleet so that
    we do not create duplicate registries.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们船只的注册编号在我们的舰队中是唯一的，我们将使用`while`循环来不断更新船只的注册编号，直到它不是已经存在的编号。使用`eliminateExistingShips`辅助函数，我们返回并解构已经存在于我们舰队中的名称和注册，以便我们不会创建重复的注册。
- en: 'We haven''t used `while` loops often, as they are often blocking points in
    a program and can be easily misused. With that being said, this is a good use
    case for a `while` loop: it ensures that our program cannot continue unless the
    ship''s registry is unique. With a randomization multiplier of 10,000, it''s unlikely
    that a duplicate random registry will be generated twice in a row, or more, so
    a `while` loop is appropriate.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不经常使用`while`循环，因为它们经常是程序中的阻塞点，并且很容易被滥用。话虽如此，这是`while`循环的一个很好的用例：它确保我们的程序在船只注册是唯一的情况下才能继续。通过一个随机化乘数为10,000，很少会出现连续两次或更多次生成重复的随机注册，因此`while`循环是合适的。
- en: So, to export or not to export, that is the question. The answer depends on
    whether we need to use the function outside of its immediate scope. If there's
    no use for the function in another part of the program, then we shouldn't export
    it. In this case, our need to identify whether a ship's details already exist
    in the fleet is really only useful in our `ships` model, so we'll refrain from
    exporting it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，导出还是不导出，这是个问题。答案取决于我们是否需要在其直接范围之外使用该函数。如果在程序的其他部分中没有使用该函数，则不应该导出它。在这种情况下，我们需要确定船只的详细信息是否已经存在于舰队中，这在我们的`ships`模型中确实只有用，因此我们将不导出它。
- en: Improving our program
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进我们的程序
- en: 'As you read through the `ships` model and controller, I''m sure you can find
    areas for improvement. For example, the way I''ve written the switches for understanding
    whether the ship was in our fleet or the enemy fleet is a bit rigid: it wouldn''t
    be able to accommodate three separate fleets in one battle. Every programmer creates
    **technical debt**, or small errors or inefficiencies in code. This then necessitates
    **refactoring**, the practice of altering code to make it better. Don''t be fooled
    into thinking you''ve ever written *The Perfect Program*—such a thing does not
    exist. Improvement and continual iteration are part of the programming process.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读`ships`模型和控制器时，我相信您可以找到改进的地方。例如，我为了了解船只是在我们的舰队还是敌方舰队而编写的开关方式有点死板：它无法容纳在一场战斗中有三个单独的舰队。每个程序员都会创造**技术债务**，或者代码中的小错误或低效。这就需要**重构**，即改变代码使其更好。不要被愚弄以为您曾经写过*完美的程序*——这样的东西是不存在的。改进和持续迭代是编程过程的一部分。
- en: There is a major caveat to refactoring, however, and that's something often
    called a **contract**. When designing a backend designed to be used by the frontend,
    and when different parties are writing different parts of a system, it's important
    to be in sync with each other and the premise and needs of the program as a whole.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重构有一个重要的警告，那就是通常所谓的**合同**。当设计一个由前端使用的后端，并且不同的团体正在编写系统的不同部分时，重要的是要与彼此和整个程序的前提和需求保持同步。
- en: 'Let''s take, for example, our frontend JavaScript code. If we enumerate the
    endpoints it''s using, we''ll see four endpoints being used:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前端JavaScript代码为例。如果我们枚举它正在使用的端点，我们将看到正在使用四个端点：
- en: '`/ships`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ships`'
- en: '``/ships/${e.currentTarget.closest(''tr'').dataset.ship}``'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``/ships/${e.currentTarget.closest(''tr'').dataset.ship}``'
- en: '``/ships/random``'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ships/random`'
- en: '`/play/fire?attacker=${e.target.closest(''td'').dataset.attacker}&target=${target}&weapon=${weapon}``'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/play/fire?attacker=${e.target.closest(''td'').dataset.attacker}&target=${target}&weapon=${weapon}``'
- en: At a minimum, when we refactor our backend code, we should assume a contractual
    obligation to change neither the path of these endpoints nor the expectation of
    datatype(s) to be received.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，在重构后端代码时，我们应该假定有一个合同义务，即不更改这些端点的路径，也不更改要接收的数据类型的期望。
- en: One way we can help make our code more future-proof is *inline documentation*
    using a loose standard called JSDoc. The creation of documentation from code comments
    is a long-standing practice and comment structures exist for many languages in
    order to facilitate a standard. In cases such as APIs, often a helper program
    is run against the source code to generate standalone documentation, often as
    a small HTML/CSS microsite. You may have encountered unrelated programs with similarly
    styled online documentation. There's a good possibility those unrelated documentation
    sites were generated from code by the same mechanism.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以帮助我们的代码更具未来性，使用一种名为JSDoc的松散标准进行*内联文档*。从代码注释创建文档是一种长期以来的做法，为了促进标准，许多语言都存在注释结构。在API等情况下，通常会运行一个辅助程序来针对源代码生成独立的文档，通常作为一个小型的HTML/CSS微型网站。您可能已经遇到了与类似风格的在线文档无关的程序。有很大的可能性，这些无关的文档站点是通过相同的机制从代码生成的。
- en: 'Why is this important in a chapter about MongoDB? Well, documentation isn''t
    only a need for database usage; rather, it is important when creating any type
    of program that has multiple moving parts. Consider the last endpoint in the preceding
    list: `/play/fire?attacker=${e.target.closest(''td'').dataset.attacker}&target=${target}&weapon=${weapon}``.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在关于MongoDB的章节中这很重要？嗯，文档不仅仅是数据库使用的需要；相反，当创建任何具有多个移动部分的程序时，它是重要的。考虑前面列表中的最后一个端点：`/play/fire?attacker=${e.target.closest('td').dataset.attacker}&target=${target}&weapon=${weapon}`。
- en: 'The fire endpoint takes three parameters: `attacker`, `target`, and `weapon`.
    But what are those parameters? What do they look like—are they objects? Strings?
    Booleans? Arrays? Additionally, if we''re going to accept user-generated data,
    we need to be a bit more careful than we have been, because of **GIGO**: **Garbage
    In, Garbage Out**. If we populate our database with bad data, the best we can
    expect is a broken program. In fact, the worst we can expect is a security **compromise**:
    the leaking of database or server credentials or malicious code execution. Let''s
    talk about security.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: fire端点接受三个参数：`attacker`、`target`和`weapon`。但这些参数是什么？它们是什么样子的——是对象？字符串？布尔值？数组？此外，如果我们要接受用户生成的数据，我们需要比以前更加小心，因为**GIGO**：**垃圾进，垃圾出**。如果我们用坏数据填充我们的数据库，我们最好能期望的是一个破碎的程序。事实上，我们最坏的期望是安全**妥协**：数据库或服务器凭据泄露或恶意代码执行。让我们谈谈安全。
- en: Security
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: 'If you''re familiar with SQL, you may be familiar with a security vulnerability
    known as **SQL Injection**. Good information on web application security best
    practices can be found at [owasp.org](http://owasp.org). The **Open Web Application
    Security Project** (**OWASP**) is a community-driven initiative to catalog and
    educate users on the security vulnerabilities present in web applications in order
    that we can more effectively combat against malicious hackers. If you''ve ever
    had your email, social account, or website hacked, you know the pain that ensues—digital
    identity theft. OWASP''s listing for SQL injection is here: [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉SQL，您可能熟悉一种称为**SQL注入**的安全漏洞。关于Web应用程序安全最佳实践的良好信息可以在[owasp.org](http://owasp.org)找到。**开放Web应用程序安全项目**（**OWASP**）是一个社区驱动的倡议，旨在记录和教育用户有关Web应用程序中存在的安全漏洞，以便我们可以更有效地对抗恶意黑客。如果您的电子邮件、社交帐户或网站曾被黑客入侵，您就会知道随之而来的痛苦——数字身份盗窃。OWASP关于SQL注入的列表在这里：[https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection)。
- en: So why are we talking about SQL if we're using a NoSQL database in the form
    of MongoDB? Because *SQL injection doesn't exist in MongoDB*. "GREAT!", you might
    say, "My security woes are solved!" This, unfortunately, is not the case. Coupled
    with the idea of refactoring to improve efficiency of an application, refactoring
    to mitigate security intrusion vectors is an important part of being responsible
    for a web application. I've worked at a company that was hacked—and it was because
    of less than five characters placed into a URL. This enabled a hacker to break
    the operation of the web application and perform arbitrary SQL commands. Sanitizing
    and refactoring for security all user-generated content is an essential part of
    web security. Now, we haven't done that for this application because I trust you're
    not going to hack your own machine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们使用的是MongoDB这种NoSQL数据库，为什么要谈论SQL呢？因为*MongoDB中不存在SQL注入*。"太好了！"你可能会说，"我的安全问题解决了！"不幸的是，情况并非如此。重构以提高应用程序效率的想法，重构以减轻安全入侵向量是负责任地管理Web应用程序的重要部分。我曾在一家公司工作，那家公司被黑客入侵了——原因是因为在URL中插入了不到五个字符。这使得黑客能够破坏Web应用程序的操作并执行任意的SQL命令。对所有用户生成的内容进行消毒和重构是Web安全的重要部分。现在，我们还没有为这个应用程序做到这一点，因为我相信你不会黑自己的机器。
- en: 'Wait. Didn''t I just say that SQL injection doesn''t exist with MongoDB? Yes,
    and NoSQL databases have their equivalent method of attack: **code and command
    injection**. Because we haven''t sanitized, or verified the integrity of, our
    user input, it''s possible for our application to store and use arbitrary code
    that''s been submitted and stored in our database. While a full primer on JavaScript
    security is not within scope of this book, do keep it in mind. The long story
    short is to sanitize, or verify the validity of, your user-generated input.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我刚刚不是说MongoDB中不存在SQL注入吗？是的，NoSQL数据库有它们等效的攻击方法：**代码和命令注入**。因为我们没有对用户输入进行消毒或验证完整性，所以我们的应用程序可能会存储和使用已提交并存储在我们的数据库中的任意代码。虽然本书不涵盖JavaScript安全的完整介绍，但请记住这一点。长话短说就是要消毒或验证您的用户生成的输入的有效性。
- en: And with that, let's wrap up this chapter. Just remember to stay safe when writing
    MongoDB applications in the wild!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，让我们结束这一章。只要记住，在野外编写MongoDB应用程序时要注意安全！
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript doesn't exist in isolation! MongoDB is a great companion to JavaScript
    as it is designed to be object-oriented and relies on a JavaScript-friendly querying
    syntax. We've learned the principles behind TDD, worked with the MVC paradigm,
    and expanded our game a bit more.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并不孤立存在！MongoDB是JavaScript的绝佳伴侣，因为它设计为面向对象，并依赖于友好的JavaScript查询语法。我们已经学习了TDD的原则，使用了MVC范式，并且扩展了我们的游戏。
- en: 'As with all coding exercises, be sure to consider the use cases when using
    a database such as MongoDB: while MongoDB''s syntax isn''t vulnerable to SQL injections,
    it is still vulnerable to other types of injections that can compromise your application.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行编码练习时，一定要考虑使用诸如MongoDB这样的数据库时的用例：虽然MongoDB的语法不容易受到SQL注入的影响，但仍然容易受到其他类型的注入攻击，这可能会危及您的应用程序。
- en: Hopefully, our starship game is interesting enough for you to keep developing
    it. Our next (and final) chapter wraps together our principles of JavaScript development
    and polishes our game.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们的星际飞船游戏足够有趣，让您继续开发它。我们的下一个（也是最后一个）章节将汇集JavaScript开发原则，并完善我们的游戏。
