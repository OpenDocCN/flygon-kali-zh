- en: Chapter 6. Test Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 测试驱动开发
- en: Over the past few years, the popularity of the **Model View Controller** (**MVC**),
    **Model View Presenter** (**MVP**), and **Model View ViewModel** (**MVVM**) patterns
    has given rise to a range of third-party JavaScript libraries, each implementing
    their own version of these patterns. Backbone, for example, could be described
    as an MVP implementation, where the view acts as a presenter. ExtJS 4 introduced
    an MVC pattern to their framework, and Angular could be described as more of an
    MVVM framework. When discussing this group of patterns together, they have been
    described by some as **Model View Whatever** (**MVW**), or **Model View Something**
    (**MV***).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，**模型视图控制器**（**MVC**）、**模型视图呈现器**（**MVP**）和**模型视图视图模型**（**MVVM**）模式的流行使得出现了一系列第三方JavaScript库，每个库都实现了自己的这些模式的版本。例如，Backbone可以被描述为MVP实现，其中视图充当呈现器。ExtJS
    4引入了MVC模式到他们的框架中，而Angular可以被描述为更多的MVVM框架。当一起讨论这组模式时，有些人将它们描述为**模型视图任何**（**MVW**）或**模型视图某物**（**MV***）。
- en: Some of the benefits of this MV* style of writing applications include modularity
    and separation of concerns. This MV* style of building applications also brings
    with it a huge advantage—the ability to write testable JavaScript. Using MV* allows
    us to unit test, integration test, and function test almost all of our beautifully
    hand-crafted JavaScript. This means that we can test our rendering functions to
    ensure that DOM elements are correctly shown on the page. We can also simulate
    button clicks, drop-down selections, and animations. We can also extend these
    tests to page transitions, including login pages and home pages. By building a
    large set of tests for our application, we will gain confidence that our code
    works as expected, and it will allow us to refactor our code at any time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编写应用程序的MV*风格的一些好处包括模块化和关注点分离。构建应用程序的MV*风格还带来了一个巨大的优势——能够编写可测试的JavaScript。使用MV*允许我们对我们精心编写的JavaScript进行单元测试、集成测试和功能测试。这意味着我们可以测试我们的渲染函数，以确保DOM元素在页面上正确显示。我们还可以模拟按钮点击、下拉选择和动画。我们还可以将这些测试扩展到页面转换，包括登录页面和主页。通过为我们的应用程序构建大量的测试，我们将获得对我们的代码按预期工作的信心，并且它将允许我们随时重构我们的代码。
- en: In this chapter, we will look at Test Driven Development in relation to TypeScript.
    We will discuss some of the more popular testing frameworks, write some unit tests,
    and then discuss test runners and continuous integration techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与TypeScript相关的测试驱动开发。我们将讨论一些更受欢迎的测试框架，编写一些单元测试，然后讨论测试运行器和持续集成技术。
- en: Test Driven Development
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test Driven Development** (**TDD**) is a development process, or a development
    paradigm, that starts with tests and drives the momentum of a piece of production
    code through these tests. Test Driven Development means asking the question "how
    do I know that I have solved the problem?" instead of just "how do I solve the
    problem?"'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一个开发过程，或者说是一个开发范式，它从测试开始，并通过这些测试推动生产代码的动力。测试驱动开发意味着提出问题“我如何知道我已经解决了问题？”而不仅仅是“我如何解决这个问题？”'
- en: 'The basic steps of a test driven approach are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动方法的基本步骤如下：
- en: Write a test that fails
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个失败的测试
- en: Run the test to ensure that it fails
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以确保它失败
- en: Write the code to make the test pass
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码使测试通过
- en: Run the test to see that it passes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以查看它是否通过
- en: Run all tests to see that the new code does not break any others
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行所有测试以确保新代码不会破坏其他任何测试
- en: Repeat the process
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复这个过程
- en: Using Test Driven Development practices is really a mindset. Some developers
    follow this approach and write tests first, while others write their code first
    and their tests afterwards. Then there are some that don't write tests at all.
    If you fall into the last category, then hopefully, the techniques you learn in
    this chapter will help you to get started in the right direction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试驱动开发实践实际上是一种心态。一些开发人员遵循这种方法，首先编写测试，而其他人先编写他们的代码，然后再编写测试。然后还有一些人根本不写测试。如果你属于最后一类人，那么希望你在本章学到的技术将帮助你朝正确的方向迈出第一步。
- en: There are so many excuses out there for not writing unit tests. Some typical
    excuses include phrases like "the test framework was not in our original quote",
    or "it will add 20 percent to the development time", or "the tests are outdated
    so we don't run them anymore". The truth is, though, that in this day and age,
    we cannot afford not to write tests. Applications grow in size and complexity,
    and requirements change over time. An application that has a good suite of tests
    can be modified far more quickly, and will be much more resilient to future requirement
    changes than one that does not have tests. This is when the real cost savings
    of unit testing become apparent. By writing unit tests for your application, you
    are future-proofing it, and ensuring that any change to the code base does not
    break existing functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多借口可以用来不写单元测试。一些典型的借口包括诸如“测试框架不在我们最初的报价中”，或者“它将增加20%的开发时间”，或者“测试已经过时，所以我们不再运行它们”。然而，事实是，在当今这个时代，我们不能不写测试。应用程序的规模和复杂性不断增长，需求随时间变化。一个拥有良好测试套件的应用程序可以比没有测试的应用程序更快地进行修改，并且对未来的需求变化更具有弹性。这时，单元测试的真正成本节约才显现出来。通过为应用程序编写单元测试，您正在未来保护它，并确保对代码库的任何更改不会破坏现有功能。
- en: TDD in the JavaScript space adds another layer to our code coverage. Quite often,
    development teams will write tests that target only the server-side logic of an
    application. As an example, in the Visual Studio space, these tests are often
    written to only target the MVC framework of controllers, views, and underlying
    business logic. It has always been fairly difficult to test the client-side logic
    of an application—in other words, the actual rendered HTML and user-based interactions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript领域的TDD为我们的代码覆盖率增加了另一层。开发团队经常只编写针对应用程序的服务器端逻辑的测试。例如，在Visual Studio空间中，这些测试通常只针对控制器、视图和基础业务逻辑的MVC框架。测试应用程序的客户端逻辑一直是相当困难的——换句话说，就是实际呈现的HTML和基于用户的交互。
- en: JavaScript testing frameworks provide us with tools to fill this gap. We can
    now start to unit test our rendered HTML, as well as simulate user interactions
    such as filling in forms and clicking on buttons. This extra layer of testing,
    combined with server-side testing, means that we have a way to unit testing each
    layer of our application—from server-side business logic, through server-side
    page rendering, right through to rendering and user interactions. The ability
    to unit test frontend user interactions is one of the greatest strengths of any
    JavaScript MV* framework. In fact, it could even influence the architectural decisions
    you make when choosing a technology stack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript测试框架为我们提供了填补这一空白的工具。现在我们可以开始对呈现的HTML进行单元测试，以及模拟用户交互，比如填写表单和点击按钮。这种额外的测试层，结合服务器端测试，意味着我们有一种方法来对应用程序的每一层进行单元测试——从服务器端业务逻辑，通过服务器端页面呈现，直到呈现和用户交互。对前端用户交互进行单元测试是任何JavaScript
    MV*框架的最大优势之一。事实上，它甚至可能影响您在选择技术栈时所做的架构决策。
- en: Unit, integration and acceptance tests
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试、集成测试和验收测试
- en: Automated tests can be broken up into three general areas, or types of tests—unit
    tests, integration tests, and acceptance tests. We can also describe these tests
    as either black box or white box tests. White box tests are tests where the internal
    logic or structure of the code under test is known to the tester. Black box tests,
    on the other hand, are tests where the internal design and or logic are not known
    to the tester.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试可以分为三个一般领域，或测试类型——单元测试、集成测试和验收测试。我们也可以将这些测试描述为黑盒测试或白盒测试。白盒测试是测试者知道被测试代码的内部逻辑或结构的测试。另一方面，黑盒测试是测试者不知道被测试代码的内部设计或逻辑的测试。
- en: Unit tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: A unit test is typically a white box test where all of the external interfaces
    to a block of code are mocked or stubbed out. If we are testing some code that
    does an asynchronous call to load a block of JSON for example, unit testing this
    code would require mocking out the returned JSON. This technique ensures that
    the object under test is always given a known set of data. When new requirements
    come along, this known set of data can grow and expand, of course. Objects under
    test should be designed to interact with interfaces so that those interfaces can
    be easily mocked or stubbed out in a unit test scenario.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常是一种白盒测试，其中代码块的所有外部接口都被模拟或存根化。例如，如果我们正在测试一些进行异步调用以加载一块JSON的代码，单元测试这段代码将需要模拟返回的JSON。这种技术确保被测试对象始终获得已知的数据集。当出现新的需求时，这个已知的数据集当然可以增长和扩展。被测试对象应该被设计为与接口交互，以便这些接口可以在单元测试场景中轻松地被模拟或存根化。
- en: Integration tests
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are another form of white box tests that allow the object
    under test to run in an environment close to how it would in real code. In our
    preceding example, where some code does an asynchronous call to load a block of
    JSON, an integration test would need to actually call the **Representational State
    Transfer** (**REST**) services that generate the JSON. If this REST service relied
    upon data from a database, then the integration test would need data in the database
    that matched the integration test scenario. If we were to describe a unit test
    as having a boundary around the object under test, then an integration test is
    simply an expansion of this boundary to include dependent objects or services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是另一种白盒测试的形式，允许被测试的对象在接近真实代码的环境中运行。在我们之前的例子中，一些代码进行异步调用以加载一块JSON，集成测试需要实际调用生成JSON的**表述性状态转移**（**REST**）服务。如果这个REST服务依赖于来自数据库的数据，那么集成测试就需要数据库中与集成测试场景匹配的数据。如果我们将单元测试描述为在被测试对象周围有一个边界，那么集成测试就是简单地扩展这个边界，以包括依赖对象或服务。
- en: Building automated integration tests for your applications will improve the
    quality of your application immensely. Consider the case in the scenario that
    we have been using—where a block of code calls a REST service for some JSON data.
    Someone could easily change the structure of the JSON data that the REST service
    returns. Our unit tests will still pass, as they are not actually calling the
    REST server-side code, but our application will be broken because the returned
    JSON is not what we are expecting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序构建自动化集成测试将极大地提高应用程序的质量。考虑我们一直在使用的场景——一段代码调用REST服务获取一些JSON数据。有人很容易改变REST服务返回的JSON数据的结构。我们的单元测试仍然会通过，因为它们实际上并没有调用REST服务器端代码，但我们的应用程序会出现问题，因为返回的JSON不是我们期望的。
- en: Without integration tests, these types of errors will only be picked up in later
    stages of manual testing. Thinking about integration tests, implementing specific
    data sets for integration tests, and building them into your test suite will eliminate
    these sorts of bugs early.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有集成测试，这些类型的错误只能在手动测试的后期阶段被发现。考虑集成测试，实现特定的数据集用于集成测试，并将其构建到测试套件中，将能够及早消除这些类型的错误。
- en: Acceptance tests
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试
- en: Acceptance tests are black box tests, and are generally scenario-based. They
    may incorporate multiple user screens or user interactions in order to pass. These
    tests are also generally carried out by the testing team, as it may require logging
    in to the application, searching for a particular set of data, updating the data,
    and so on. With some planning, we can also automate parts of these acceptance
    tests into an integration suite, as we have the ability in JavaScript to find
    and click buttons, insert data into required fields, or select drop-down items.
    The more acceptance tests a project has, the more robust it will be.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是黑盒测试，通常基于场景。它们可能包含多个用户屏幕或用户交互以通过。这些测试通常也由测试团队执行，因为可能需要登录到应用程序，搜索特定的数据，更新数据等。通过一些规划，我们还可以将这些验收测试的部分自动化为集成套件，因为我们在JavaScript中有能力查找并单击按钮，将数据插入所需字段，或选择下拉项。项目拥有的验收测试越多，它就会越健壮。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Test Driven Development methodology, every bug that is picked up by a
    manual testing team must result in the creation of new unit, integration, or acceptance
    tests. This methodology will help to ensure that once a bug is found and fixed,
    it never reappears again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动开发方法论中，手动测试团队发现的每个错误都必须导致新的单元测试、集成测试或验收测试的创建。这种方法将有助于确保一旦发现并修复错误，它就不会再次出现。
- en: Using continuous integration
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用持续集成
- en: When writing unit tests for any application, it quickly becomes important to
    set up a build server and run your tests as part of each source control check
    in. When your development team grows beyond a single developer, using a **Continuous
    Integration** (**CI**) build server becomes imperative. This build server will
    ensure that any code committed to the source control server passes all known unit
    tests, integration tests, and automated acceptance tests. The build server is
    also responsible for labeling a build and generating any deployment artifacts
    that need to be used during deployment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当为任何应用程序编写单元测试时，很快就会变得重要，设置一个构建服务器，并将您的测试作为每个源代码控制检入的一部分运行。当您的开发团队超出单个开发人员时，使用**持续集成**（**CI**）构建服务器变得至关重要。这个构建服务器将确保提交到源代码控制服务器的任何代码都通过所有已知的单元测试、集成测试和自动验收测试。构建服务器还负责标记构建并生成在部署过程中需要使用的任何部署工件。
- en: 'The basic steps of a build server would be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器的基本步骤如下：
- en: Check out the latest version of the source code, and increase the build number
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检出最新版本的源代码，并增加构建编号
- en: Compile the application on the build server
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建服务器上编译应用程序
- en: Run any server-side unit tests
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行任何服务器端单元测试
- en: Package the application for deployment
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为部署打包应用程序
- en: Deploy the package to a build environment
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将软件包部署到构建环境
- en: Run any server-side integration tests
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行任何服务器端集成测试
- en: Run any JavaScript unit, integration, and acceptance tests
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行任何JavaScript单元测试、集成测试和验收测试
- en: Mark the change set and build number as passed or failed
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记更改集和构建编号为通过或失败
- en: If the build failed, notify those responsible for breaking it
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构建失败，请通知责任人
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The build server should fail if any one of the preceding steps fail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的任何步骤失败，构建服务器应该失败。
- en: Benefits of continuous integration
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成的好处
- en: Using a build server to run through the preceding steps brings huge benefits
    to any development team. Firstly, the application is compiled on the build server—which
    means that any tools or external libraries used, will need to be installed on
    the build server. This gives your development team the opportunity to document
    exactly what software needs to be installed on a new machine in order to compile
    or run your application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建服务器运行前面的步骤对任何开发团队都带来巨大的好处。首先，应用程序在构建服务器上编译，这意味着任何使用的工具或外部库都需要安装在构建服务器上。这为您的开发团队提供了在新机器上安装软件的机会，以便编译或运行应用程序。
- en: Secondly, a standard set of server-side unit tests can be run before the packaging
    step is attempted. In a Visual Studio project, these would be C# unit tests built
    with any of the popular .NET testing frameworks, such as MSTest, NUnit, or xUnit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在尝试打包之前，可以运行一组标准的服务器端单元测试。在Visual Studio项目中，这些测试将是使用任何流行的.NET测试框架构建的C#单元测试，例如MSTest、NUnit或xUnit。
- en: Next, the entire application's packaging step is run. Let's assume for a moment
    that a developer has included a new JavaScript library within the project, but
    forgotten to add it to the Visual Studio solution. In this case, all of the tests
    will run on their local computer, but will break the build because of a missing
    library file. If we were to deploy the site at this stage, running the application
    would result in a 404 error – file not found. By running a packaging step, these
    sort of errors are quickly found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行整个应用程序的打包步骤。假设一名开发人员在项目中包含了一个新的JavaScript库，但忘记将其添加到Visual Studio解决方案中。在这种情况下，所有测试将在他们的本地计算机上运行，但由于缺少库文件，构建将失败。如果我们在这个阶段部署站点，运行应用程序将导致404错误-文件未找到。通过运行打包步骤，这类错误可以很快被发现。
- en: Once a successful packaging step has been completed, the build server should
    deploy the site to a specially marked build environment. This build environment
    is only used for CI builds, and must therefore have its own database instances,
    web service references, and so on, set up specifically for CI builds. Again, actually
    doing a deployment to a target environment tests the deployment artifacts, as
    well as the deployment process. By setting up a build environment for automated
    package deployment, your team is again able to document the requirements and process
    for deployment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功完成了打包步骤，构建服务器应该将站点部署到一个特别标记的构建环境中。这个构建环境仅用于CI构建，因此必须具有自己的数据库实例、Web服务引用等，专门为CI构建设置。再次，实际上部署到目标环境测试了部署工件以及部署过程。通过为自动打包部署设置构建环境，您的团队再次能够记录部署的要求和过程。
- en: At this stage, we have a full instance of our website up and running on an isolated
    build environment. We can then easily target specific web pages that will run
    our JavaScript tests, and also run integration or automated acceptance tests—directly
    on the full version of the website. In this way, we can write tests that target
    the real-life website REST services, without having to mock out these integration
    points. So in effect, we are testing the application from the ground up. Obviously,
    we may need to ensure that our build environment has a specific set of data that
    can be used for integration testing, or a way of generating the required data
    sets that our integration tests will need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们在一个独立的构建环境上完整地运行了我们的网站实例。然后，我们可以轻松地针对特定的网页运行我们的JavaScript测试，并直接在完整版本的网站上运行集成或自动接受测试。这样，我们可以编写针对真实网站REST服务的测试，而无需模拟这些集成点。因此，实际上，我们是从头开始测试应用程序。显然，我们可能需要确保我们的构建环境具有一组特定的数据，可以用于集成测试，或者一种生成所需数据集的方法，我们的集成测试将需要。
- en: Selecting a build server
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择构建服务器
- en: There are a number of continuous integration build servers out there, including
    TeamCity, Jenkins, and **Team Foundation Server** (**TFS**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多持续集成构建服务器，包括TeamCity、Jenkins和Team Foundation Server（TFS）。
- en: Team Foundation Server
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Team Foundation Server
- en: TFS needs a specific configuration on its build agents to be able to run instances
    of a web browser. With larger projects, actually running the JavaScript tests
    within a specific browser makes sense, and soon becomes a required step. You may
    need to support more than one browser, and want to run your tests within Firefox,
    Chrome, IE, Safari, or others. TFS also uses **Windows Workflow Foundation** (**WF**)
    to configure build steps, which takes a fair amount of experience and knowledge
    to modify.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: TFS需要在其构建代理上进行特定配置，以便能够运行Web浏览器的实例。对于较大的项目，实际在特定浏览器中运行JavaScript测试是有意义的，并很快就成为必需的步骤。您可能需要支持多个浏览器，并希望在Firefox、Chrome、IE、Safari或其他浏览器中运行您的测试。TFS还使用Windows
    Workflow Foundation（WF）来配置构建步骤，这需要相当多的经验和知识来修改。
- en: Jenkins
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins is an open source, free-to-use CI build server. It has wide community
    usage, and many plugins. Installation and configuration of Jenkins is fairly straightforward,
    and Jenkins will allow processes to run browser instances, making it compatible
    with browser-based JavaScript unit tests. Jenkins build steps are command-line-based,
    and it sometimes takes a little nous to configure build steps correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个开源的免费使用的CI构建服务器。它有广泛的社区使用和许多插件。Jenkins的安装和配置相当简单，Jenkins将允许进程运行浏览器实例，使其与基于浏览器的JavaScript单元测试兼容。Jenkins的构建步骤是基于命令行的，有时需要一些技巧来正确配置构建步骤。
- en: TeamCity
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TeamCity
- en: A very popular, and very powerful, build server that is free to set up is TeamCity.
    TeamCity allows free installation if you have a small number of developers (<
    20), and a small number of projects (< 20). A full commercial license is only
    around $1,500.00, which makes it affordable for most organizations. Configuring
    build steps in TeamCity is much easier than in Jenkins or TFS, as it uses a wizard
    style of configuration depending on the type of build step you are creating. TeamCity
    also has a rich set of functionality around unit tests, with the ability to show
    graphs per unit test, and is therefore considered best of breed for build servers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常受欢迎且功能强大的免费设置的构建服务器是TeamCity。如果您有少量开发人员（<20）和少量项目（<20），TeamCity允许免费安装。完整的商业许可证只需约1500美元，这使得大多数组织都能负担得起。在TeamCity中配置构建步骤比在Jenkins或TFS中要容易得多，因为它使用向导样式的配置，具体取决于您正在创建的构建步骤的类型。TeamCity还具有丰富的围绕单元测试的功能，能够显示每个单元测试的图表，因此被认为是构建服务器的最佳选择。
- en: Unit testing frameworks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: There are many JavaScript unit testing frameworks available, and also a few
    that have been written in TypeScript. Two of the most popular JavaScript frameworks
    are Jasmine ([http://jasmine.github.io/](http://jasmine.github.io/)) and QUnit
    ([http://qunitjs.com/](http://qunitjs.com/)). If you are writing Node TypeScript
    code, then you might want to have a look at mocha ([https://github.com/mochajs/mocha/wiki](https://github.com/mochajs/mocha/wiki)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的JavaScript单元测试框架，也有一些用TypeScript编写的框架。最受欢迎的两个JavaScript框架是Jasmine（[http://jasmine.github.io/](http://jasmine.github.io/)）和QUnit（[http://qunitjs.com/](http://qunitjs.com/)）。如果您正在编写Node
    TypeScript代码，那么您可能想看看mocha（[https://github.com/mochajs/mocha/wiki](https://github.com/mochajs/mocha/wiki)）。
- en: Two of the TypeScript-based testing frameworks are MaxUnit ([https://github.com/KnowledgeLakegithub/MaxUnit](https://github.com/KnowledgeLakegithub/MaxUnit))
    and tsUnit ([https://github.com/Steve-Fenton/tsUnit](https://github.com/Steve-Fenton/tsUnit)).
    Unfortunately, both MaxUnit and tsUnit are newcomers in this space, and therefore
    may not have the features that are inherent in the older, more popular frameworks.
    MaxUnit, for example, did not have any documentation at the time of writing, and
    tsUnit does not have a test reporting framework compatible with CI build servers.
    Over time, these TypeScript frameworks may grow, but seeing how easy it is to
    work with third-party libraries and use DefinitelyTyped declaration files, writing
    unit tests for either QUnit or Jasmine becomes a very simple process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 两个基于TypeScript的测试框架是MaxUnit（[https://github.com/KnowledgeLakegithub/MaxUnit](https://github.com/KnowledgeLakegithub/MaxUnit)）和tsUnit（[https://github.com/Steve-Fenton/tsUnit](https://github.com/Steve-Fenton/tsUnit)）。不幸的是，MaxUnit和tsUnit都是这个领域的新手，因此可能没有老一辈更流行的框架所固有的功能。例如，MaxUnit在撰写时没有任何文档，而tsUnit没有与CI构建服务器兼容的测试报告框架。随着时间的推移，这些TypeScript框架可能会成长，但是看到使用第三方库和使用DefinitelyTyped声明文件编写QUnit或Jasmine的单元测试是非常简单的。
- en: For the rest of this chapter, we will be using Jasmine 2.0 as our testing framework.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用Jasmine 2.0作为我们的测试框架。
- en: Jasmine
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine
- en: For this section of the chapter, we will create a new Visual Studio project
    that is based on the MVC framework project type. For now, we can just use the
    empty MVC template.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将创建一个基于MVC框架项目类型的新的Visual Studio项目。现在，我们可以使用空的MVC模板。
- en: 'Jasmine can be installed into our new TypeScript project with the following
    two NuGet packages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine可以通过以下两个NuGet包安装到我们的新TypeScript项目中：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With these two packages in place, we have the required JavaScript libraries
    and TypeScript definition files in place to begin writing Jasmine tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个包，我们就有了所需的JavaScript库和TypeScript定义文件，可以开始编写Jasmine测试。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default installation from NuGet for `JasmineTest` uses the ASP.NET MVC framework,
    and creates a `JasmineController` in the `Controllers` directory. If you are not
    using the MVC framework, or are installing this package in a Node environment,
    then this `JasmineController` should be deleted, as it will cause compilation
    errors. Later in this chapter, we will show how to run integration tests against
    this `JasmineController`, so it's best to leave it in place for the time being.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过NuGet默认安装`JasmineTest`使用了ASP.NET MVC框架，并在`Controllers`目录中创建了一个`JasmineController`。如果您没有使用MVC框架，或者在Node环境中安装了这个包，那么这个`JasmineController`应该被删除，因为它会导致编译错误。在本章的后面，我们将展示如何对这个`JasmineController`运行集成测试，所以最好暂时保留它。
- en: A simple Jasmine test
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的Jasmine测试
- en: 'Jasmine uses a simple format for writing tests. Consider the following TypeScript
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine使用一种简单的格式来编写测试。考虑以下TypeScript代码：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This snippet starts with a Jasmine function called `describe`, which takes two
    arguments. The first argument is the name of the test suite, and the second is
    an anonymous function that contains our test suite. The next line uses the Jasmine
    function named `it`, which also takes two arguments. The first argument is the
    test name, and the second argument is an anonymous function that contains our
    test; in other words, whatever is within the `it` anonymous function is our actual
    test. This test starts by defining a variable, named `undefinedValue`, but does
    not actually set its value. Next, we use the Jasmine function `expect`. Just by
    reading the code of this `expect` statement, we can quickly understand what the
    unit test is doing. It is expecting that the value of the `undefinedValue` variable
    should be defined, that is, not `undefined`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段以一个名为`describe`的Jasmine函数开始，它接受两个参数。第一个参数是测试套件的名称，第二个是包含我们的测试套件的匿名函数。接下来的一行使用了名为`it`的Jasmine函数，它也接受两个参数。第一个参数是测试名称，第二个参数是包含我们的测试的匿名函数；换句话说，`it`匿名函数中的内容就是我们的实际测试。这个测试首先定义了一个名为`undefinedValue`的变量，但实际上并没有设置它的值。接下来，我们使用了Jasmine函数`expect`。仅仅通过阅读这个`expect`语句的代码，我们就可以快速理解这个单元测试在做什么。它期望`undefinedValue`变量的值应该被定义，也就是不是`undefined`。
- en: The `expect` function takes a single argument, and returns a Jasmine matcher.
    We can then call any of the Jasmine matcher functions to assess the value passed
    into `expect` against the matcher function. The `expect` keyword is similar to
    the `Assert` keyword in other testing libraries. The format of the `expect` statements
    are human-readable, making Jasmine expectations relatively simple to understand.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`函数接受一个参数，并返回一个Jasmine匹配器。然后我们可以调用任何Jasmine匹配器函数来评估传入`expect`的值与匹配器函数的关系。`expect`关键字类似于其他测试库中的`Assert`关键字。`expect`语句的格式是人类可读的，使得Jasmine的期望相对简单易懂。'
- en: Jasmine SpecRunner.html file
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine SpecRunner.html文件
- en: 'In order to run this test, we will need an HTML page that includes all the
    relevant Jasmine third-party libraries, as well as our test JavaScript file. We
    can create a `SpecRunner.html` file with the following HTML within it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个测试，我们需要一个包含所有相关Jasmine第三方库以及我们的测试JavaScript文件的HTML页面。我们可以创建一个`SpecRunner.html`文件，其中包含以下HTML：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This HTML page is simply including the required Jasmine files, `jasmine.css`,
    `jasmine.js`, `jasmine-html.js`, and `boot.js`. The last line includes the compiled
    JavaScript file from our TypeScript test file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML页面只是包含了所需的Jasmine文件，`jasmine.css`、`jasmine.js`、`jasmine-html.js`和`boot.js`。最后一行包含了从我们的TypeScript测试文件编译出的JavaScript文件。
- en: 'If we set this page as our startup page within Visual Studio and run it, we
    should see one failing unit test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个页面设置为在Visual Studio中的启动页面并运行它，我们应该会看到一个失败的单元测试：
- en: '![Jasmine SpecRunner.html file](img/image_9665OS_06_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine SpecRunner.html文件](img/image_9665OS_06_01.jpg)'
- en: SpecRunner.html page showing Jasmine output
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显示Jasmine输出的SpecRunner.html页面
- en: 'Excellent! We are following the test-driven development process by firstly
    creating a failing unit test. The results are exactly what we expect. Our variable
    named `undefinedVariable` has not yet had a value assigned to it, and therefore
    will be `undefined`. If we follow the next step of the TDD process, we should
    write the code that makes the test pass. Updating our test as follows will ensure
    that the test will pass:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们正在遵循测试驱动开发的过程，首先创建一个失败的单元测试。结果正是我们所期望的。我们的名为`undefinedVariable`的变量还没有被赋值，因此将是`undefined`。如果我们遵循TDD过程的下一步，我们应该编写使测试通过的代码。更新我们的测试如下将确保测试通过：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we have updated our test name to describe what the test is trying
    to accomplish. To make the test pass, we are simply assigning the value `"test"`
    to our `undefinedValue` variable. Running the `SpecRunner.html` page now will
    show a passing test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经更新了我们的测试名称以描述测试的目标。为了使测试通过，我们只需将值`"test"`赋给我们的`undefinedValue`变量。现在运行`SpecRunner.html`页面将显示一个通过的测试。
- en: Matchers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配器
- en: 'Jasmine has a wide range of matchers that can be used within tests, and also
    allows us to write and include custom matchers. The syntax of Jasmine matchers
    is pretty self-explanatory, as can be seen from the following TypeScript code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine有各种各样的匹配器可以在测试中使用，并且还允许我们编写和包含自定义匹配器。从以下TypeScript代码中可以看出，Jasmine匹配器的语法非常直观：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are using the `.not.` matcher syntax to check that the variable `undefValue`
    is indeed `undefined`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`.not.`匹配器语法来检查变量`undefValue`是否确实是`undefined`。
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `expect` statement uses the `not.toBe` matcher to ensure that the `definedValue`
    variable is not `null`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`expect`语句使用`not.toBe`匹配器来确保`definedValue`变量不是`null`。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are using the `.toBe` matcher to check that the `definedValue` is in
    fact a number with the value of two.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`.toBe`匹配器来检查`definedValue`实际上是一个值为2的数字。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `expect` statement is using the `toEqual` matcher to ensure that the `toString`
    function will return the string value of `"2"`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`expect`语句使用`toEqual`匹配器来确保`toString`函数将返回字符串值`"2"`。
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are testing for `boolean` values, using the `toBeTruthy` and `toBeFalsy`
    matchers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`toBeTruthy`和`toBeFalsy`匹配器来测试`boolean`值。
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we can also use the `toContain` matcher to parse a string, and test
    whether it contains another string—or use the `.not.` matcher with `toContain`
    for the reverse test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用`toContain`匹配器来解析一个字符串，并测试它是否包含另一个字符串，或者使用`.not.`匹配器与`toContain`进行相反的测试。
- en: Be sure to head over to the Jasmine website for a full list of matchers, as
    well as details on writing your own custom matchers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要前往Jasmine网站查看匹配器的完整列表，以及编写自定义匹配器的详细信息。
- en: Test startup and teardown
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试启动和拆卸
- en: 'As in other testing frameworks, Jasmine provides a mechanism to define functions
    that will run before and after each test, or as a test startup and teardown mechanism.
    In Jasmine, the `beforeEach` and `afterEach` functions act as test startup and
    teardown functions, as can be seen from the following TypeScript code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试框架一样，Jasmine提供了一种定义函数的机制，这些函数将在每个测试之前和之后运行，或作为测试启动和拆卸机制。在Jasmine中，`beforeEach`和`afterEach`函数充当测试启动和拆卸函数，如下面的TypeScript代码所示：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this test, we define a variable named `myString`, at the start of the anonymous
    function. As we know from JavaScript lexical scoping rules, this `myString` variable
    will then be available for use within each of the following `beforeEach`, `afterEach`,
    and `it` functions. Within the `beforeEach` function, this variable is set to
    a string value. Within the `afterEach` function, the variable is tested to see
    that it has been reset to `undefined`. Our expectation within our test checks
    is that this variable has been set via the `beforeEach` function. At the end of
    our test, we then reset the variable to be `undefined`. Note that the `afterEach`
    function is also calling an `expect`—in this case to ensure that the test has
    reset the variable back to `undefined`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们在匿名函数的开头定义了一个名为`myString`的变量。根据JavaScript的词法作用域规则，这个`myString`变量将在接下来的`beforeEach`、`afterEach`和`it`函数中可用。在`beforeEach`函数中，这个变量被设置为一个字符串值。在`afterEach`函数中，测试这个变量是否已被重置为`undefined`。我们在测试中的期望是，这个变量已经通过`beforeEach`函数设置。在测试结束时，我们将变量重置为`undefined`。请注意，`afterEach`函数也调用了一个`expect`，在这种情况下是为了确保测试已将变量重置为`undefined`。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Jasmine 2.1 version introduces a second version of setup and teardown, called
    `beforeAll` and `afterAll`. At the time of writing this book, though, the versions
    of both the `jasmine.js` and `jasmine.d.ts` files available from NuGet had not
    been updated to v2.1.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 2.1版本引入了第二个版本的设置和拆卸，称为`beforeAll`和`afterAll`。在撰写本书时，`jasmine.js`和`jasmine.d.ts`文件的版本都还没有更新到v2.1。
- en: Data-driven tests
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据驱动测试
- en: 'To show how extensible the Jasmine testing library is, JP Castro wrote a very
    short but powerful utility to provide data-driven tests within Jasmine. His blog
    on this topic can be found here ([http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/](http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/)),
    and the GitHub repository can be found here ([https://github.com/jphpsf/jasmine-data-provider](https://github.com/jphpsf/jasmine-data-provider)).
    This simple extension allows us to write intuitive Jasmine tests that take a parameter
    as part of each test, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Jasmine测试库的可扩展性，JP Castro编写了一个非常简短但功能强大的实用程序，以在Jasmine中提供数据驱动测试。他关于这个主题的博客可以在这里找到（[http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/](http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/)），GitHub存储库可以在这里找到（[https://github.com/jphpsf/jasmine-data-provider](https://github.com/jphpsf/jasmine-data-provider)）。这个简单的扩展允许我们编写直观的Jasmine测试，每个测试都带有一个参数，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are wrapping our `it` test function within another function called
    `using`. This `using` function takes three parameters: a string description of
    the value set, an array of values, and a function definition. This last function
    definition uses the variable `value`, and will invoke our test using this value.
    Note also in the call to our test, we are changing the test name on the fly, to
    include the `value` parameter that is passed in. This is necessary in order for
    each test to have a unique test name.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`it`测试函数包裹在另一个名为`using`的函数中。这个`using`函数接受三个参数：值集的字符串描述，值的数组，以及一个函数定义。这个最后的函数定义使用变量`value`，并将使用这个值来调用我们的测试。还要注意，在调用我们的测试时，我们正在动态更改测试名称，以包含传入的`value`参数。这是为了确保每个测试都有一个唯一的测试名称。
- en: 'The preceding solution just needs JP Castro''s Jasmine extension, shown in
    the following JavaScript code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案只需要JP Castro的Jasmine扩展，如下面的JavaScript代码所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a very simple function named `using`, that takes the three parameters
    that we mentioned earlier. The function does a simple loop through the array values,
    and passes in each array value to our test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的名为`using`的函数，它接受我们之前提到的三个参数。该函数通过数组值进行简单的循环，并将每个数组值传递给我们的测试。
- en: 'The last item that we will need is a TypeScript definition file for the preceding
    `using` function. This is a very simple function declaration as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一样东西是一个用于前面`using`函数的TypeScript定义文件。这是一个非常简单的函数声明，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This TypeScript declaration uses the generic syntax `<T>` to ensure that the
    same type is used for both the second and third arguments. With this declaration
    in place, and the JavaScript `using` function, our code will compile correctly,
    and the tests will run through once for each value in the data array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个TypeScript声明使用了泛型语法`<T>`，以确保第二个和第三个参数使用相同的类型。有了这个声明，以及JavaScript的`using`函数，我们的代码将正确编译，并且测试将针对数据数组中的每个值运行一次：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using spies
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用间谍
- en: Jasmine also has a very powerful feature that allows your tests to see if a
    particular function was called, and what parameters it was called with. It can
    also be used to create mocks and stubs. All of this functionality is rolled into
    what Jasmine calls spies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine还有一个非常强大的功能，可以让你的测试看到特定的函数是否被调用，以及它被调用时使用的参数。它还可以用来创建模拟和存根。所有这些功能都包含在Jasmine所称的间谍中。
- en: 'Consider the following test:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start with a simple class named `MySpiedClass`, that has a single function
    `testFunction`. This function takes a single argument, and logs the argument to
    the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`MySpiedClass`的简单类开始，它有一个名为`testFunction`的函数。这个函数接受一个参数，并将参数记录到控制台上。
- en: Our test starts by creating a new instance of the `MySpiedClass`, and assigns
    it to a variable named `classIntance`. We then create a Jasmine spy on the function
    `testFunction` of the `classInstance` variable. Once we have a spy created, we
    can call the function. Our expectation then checks whether the function was called.
    This is the essence of a spy. Jasmine will "watch" the `testFunction` function
    of the instance of `MySpiedClass` to see whether or not it was called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试从创建一个`MySpiedClass`的新实例开始，并将其赋值给一个名为`classInstance`的变量。然后我们在`classInstance`变量的`testFunction`函数上创建了一个Jasmine间谍。一旦我们创建了一个间谍，就可以调用这个函数。我们的期望是检查这个函数是否被调用。这就是间谍的本质。Jasmine将“监视”`MySpiedClass`实例的`testFunction`函数，以查看它是否被调用。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Jasmine spies, by default, block the call to the underlying function. In other
    words, they replace the function you are trying to call with a Jasmine delegate.
    If you need to spy on a function, but still need the body of the function to execute,
    you must specify this behavior using the `.and.callThrough()` fluent syntax.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Jasmine间谍会阻止对底层函数的调用。换句话说，它们会用Jasmine代理替换你试图调用的函数。如果你需要对一个函数进行间谍，但仍然需要执行函数体，你必须使用`.and.callThrough()`流畅语法来指定这种行为。
- en: While this is a very trivial example, spies become very powerful in a number
    of different testing scenarios. Classes or functions that take callback parameters,
    for example, would need a spy to ensure that the callback function was in fact
    invoked.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个非常简单的例子，但在许多不同的测试场景中，间谍变得非常强大。例如，需要回调参数的类或函数需要一个间谍来确保回调函数实际上被调用。
- en: 'Let''s see how we can test that a callback function was invoked correctly.
    Consider the following TypeScript code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何测试回调函数是否被正确调用。考虑以下TypeScript代码：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code snippet, we define a class named `CallbackClass` that has a single
    function `doCallback`. This `doCallback` function takes an `id` argument of type
    `number`, and also a `callback` function. The `callback` function takes a `string`
    as an argument, and returns `void`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们定义了一个名为`CallbackClass`的类，它有一个名为`doCallback`的函数。这个`doCallback`函数接受一个`number`类型的`id`参数，还有一个`callback`函数。`callback`函数接受一个`string`作为参数，并返回`void`。
- en: 'The second class that we have defined has a single function named `logValue`.
    This function signature matches the callback function signature required on the
    `doCallback` function. Using Jasmine spies, we can test the logic of the `doCallBack`
    function. This logic creates a string based on the `id` argument that was passed
    in, and then invokes the `callback` function with this string. Our test will need
    to ensure that this string is formatted correctly. Our Jasmine test, then, for
    this can be written as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的第二个类有一个名为`logValue`的函数。这个函数的签名与`doCallback`函数上所需的回调函数签名相匹配。使用Jasmine间谍，我们可以测试`doCallBack`函数的逻辑。这个逻辑根据传入的`id`参数创建一个字符串，然后用这个字符串调用`callback`函数。我们的测试需要确保这个字符串格式正确。因此，我们的Jasmine测试可以写成如下形式：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test code firstly creates an instance of the class `CallbackClass`, and
    also an instance of the class `DoCallBack`. We then create a spy on the `logValue`
    function of the `DoCallBack` class. We then call the `doCallback` function, passing
    in a value of `1` as the first argument, and the `logValue` function as the second
    argument. Our `expect` statements on the last two lines check that the callback
    function `logValue` was actually called, and also what parameters it was called
    with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代码首先创建了一个`CallbackClass`类的实例，也创建了一个`DoCallBack`类的实例。然后我们在`DoCallBack`类的`logValue`函数上创建了一个间谍。接着我们调用`doCallback`函数，将`1`作为第一个参数传入，并将`logValue`函数作为第二个参数传入。我们在最后两行的`expect`语句中检查回调函数`logValue`是否被实际调用，以及它被调用时使用的参数。
- en: Using spies as fakes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用间谍作为伪装
- en: 'Another benefit of Jasmine spies is that they can act as fakes. In other words,
    instead of calling a real function, the call is delegated to the Jasmine spy.
    Jasmine also allows spies to return values—which can be useful when generating
    small mocking frameworks. Consider the following tests:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine间谍的另一个好处是它们可以充当伪装。换句话说，它们代替了对真实函数的调用，而是委托给了Jasmine间谍。Jasmine还允许间谍返回值——这在生成小型模拟框架时非常有用。考虑以下测试：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start with a class named `ClassToFake` that has a single function `getValue`,
    which returns `2`. Our test then creates an instance of this class. We then call
    the Jasmine `spyOn` function to create a spy on the `getValue` function, and then
    use the `.and.callFake` syntax to attach an anonymous function as a fake function.
    This fake function will return `5` instead of the original `getValue` function
    that would have returned `2`. The test then checks to see that when we call the
    `getValue` function on the `ClassToFake` instance, Jasmine will substitute our
    new fake function for the original `getValue` function, and return `5` instead
    of `2`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`ClassToFake`的类开始，它有一个名为`getValue`的单一函数，返回`2`。我们的测试然后创建了这个类的一个实例。然后我们调用Jasmine的`spyOn`函数来创建一个对`getValue`函数的间谍，然后使用`.and.callFake`语法将一个匿名函数附加为一个伪造函数。这个伪造函数将返回`5`而不是原来会返回`2`的`getValue`函数。测试然后检查当我们在`ClassToFake`实例上调用`getValue`函数时，Jasmine会用我们的新伪造函数替换原来的`getValue`函数，并返回`5`而不是`2`。
- en: There are a number of variants of the Jasmine fake syntax, including methods
    to throw errors, or return values—again, please consult the Jasmine documentation
    for a full list of its faking capabilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine的伪造语法有许多变体，包括抛出错误或返回值的方法，请参考Jasmine文档以获取其伪造能力的完整列表。
- en: Asynchronous tests
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步测试
- en: 'The asynchronous nature of JavaScript—made popular by AJAX and jQuery has always
    been one of the drawcards of the language, and is the principle architecture behind
    Node based applications. Let''s have a quick look at an asynchronous class, and
    then describe how we should go about testing it. Consider the following TypeScript
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的异步特性——由AJAX和jQuery广泛使用，一直是这门语言的吸引点之一，也是Node.js应用程序的主要架构原理。让我们快速看一下一个异步类，然后描述我们应该如何测试它。考虑以下TypeScript代码：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `MockAsyncClass` has a single function named `executeSlowFunction`, which
    takes a function callback named `success`. Within the `executeSlowFunction` code,
    we are simulating an asynchronous call by using the `setTimeout` function, and
    only calling the success callback after `1000` milliseconds (1 second). This behavior
    is simulating a standard AJAX call (which would use both a `success` and an `error`
    callback), which could take a number of seconds to return—depending on the speed
    of the backend server, or the size of the data packet.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockAsyncClass`有一个名为`executeSlowFunction`的单一函数，它接受一个名为`success`的函数回调。在`executeSlowFunction`的代码中，我们通过使用`setTimeout`函数模拟了一个异步调用，并且只在`1000`毫秒（1秒）后调用成功回调。这种行为模拟了标准的AJAX调用（它会使用`success`和`error`回调），这可能需要几秒钟才能返回，取决于后端服务器的速度或数据包的大小。'
- en: 'Our test for this `executeSlowFunction` may look as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`executeSlowFunction`的测试可能如下所示：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Firstly, we instantiate an instance of the `MockAsyncClass`, and define a variable
    named `returnedValue`. We then call the `executeSlowFunction` with an anonymous
    function for the `success` callback function. This anonymous function sets the
    value of `returnedValue` to whatever value was passed in from the `MockAsyncClass`.
    Our expectation is that the `returnedValue` should equal `"success"`. If we run
    this test now, however, our test will fail with the following error message:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化了`MockAsyncClass`的一个实例，并定义了一个名为`returnedValue`的变量。然后我们用一个匿名函数调用`executeSlowFunction`作为`success`回调函数。这个匿名函数将`returnedValue`的值设置为从`MockAsyncClass`传入的任何值。我们的期望是`returnedValue`应该等于`"success"`。然而，如果我们现在运行这个测试，我们的测试将失败，并显示以下错误消息：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What is happening here, is that because the `executeSlowFunction` is asynchronous,
    JavaScript will not wait until the callback function is called, before executing
    the next line of code. This means that the expectation is being called before
    the `executeSlowFunction` has had a chance to call our anonymous callback function
    (setting the value of `returnedValue`). If you put a breakpoint on the `expect(returnValue).toEqual("success")`
    line, and another breakpoint on the `returnedValue = value` line, you will see
    that the expect line is called first, and the `returnedValue` line is only called
    after a second. This timing issue is what is causing this test to fail. We need
    to somehow have our test wait until the `executeSlowFunction` has invoked the
    callback, before we execute our expectations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，因为`executeSlowFunction`是异步的，JavaScript不会等到回调函数被调用之后再执行下一行代码。这意味着期望被调用之前`executeSlowFunction`还没有机会调用我们的匿名回调函数（设置`returnedValue`的值）。如果你在`expect(returnValue).toEqual("success")`行上设置一个断点，并在`returnedValue
    = value`行上设置另一个断点，你会看到期望行先被调用，而`returnedValue`行只在一秒后才被调用。这个时间问题导致了这个测试的失败。我们需要以某种方式让我们的测试等到`executeSlowFunction`调用回调之后再执行我们的期望。
- en: Using the done() function
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`done()`函数
- en: 'Jasmine version 2.0 has introduced a new syntax to help us with these sort
    of asynchronous tests. In any `beforeEach`, `afterEach`, or `it` function, we
    pass an argument named `done`, which is a function, and then invoke it at the
    end of our asynchronous code. Consider the following test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 2.0版本引入了一种新的语法来帮助我们处理这种异步测试。在任何`beforeEach`、`afterEach`或`it`函数中，我们传递一个名为`done`的参数，它是一个函数，然后在我们的异步代码的末尾调用它。考虑以下测试：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Firstly, we have moved the `returnedValue` variable outside of our test, and
    have included a `beforeEach` function to run before our actual test. This `beforeEach`
    function firstly resets the value of `returnValue`, and then sets up the `MockAsyncClass`
    instance. Finally it calls the `executeSlowFunction` on this instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们已经将`returnedValue`变量移出了我们的测试，并包含了一个`beforeEach`函数，在我们实际的测试之前运行。这个`beforeEach`函数首先重置了`returnValue`的值，然后设置了`MockAsyncClass`的实例。最后调用了这个实例上的`executeSlowFunction`。
- en: Note how the `beforeEach` function takes a parameter named `done`, and then
    calls this `done` function after the `returnedValue = value` line has been called.
    Notice too, that the second parameter to the `it` function now also takes a `done`
    parameter, and invokes this `done` function when the test is finished.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`beforeEach`函数接受一个名为`done`的参数，然后在调用`returnedValue = value`行之后调用此`done`函数。还要注意，`it`函数的第二个参数现在也接受一个`done`参数，并在测试完成时调用此`done`函数。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'From the Jasmine documentation: The spec will not start until the `done` function
    is invoked in the call to `beforeEach`, and the spec will not complete until the
    `done` function is called. By default, Jasmine will wait for 5 seconds before
    causing a timeout failure. This can be overridden using the `jasmine.DEFAULT_TIMEOUT_INTERVAL`
    variable.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Jasmine文档：在调用`beforeEach`时，`done`函数被调用之前，规范不会开始，并且在调用`done`函数之前，规范不会完成。默认情况下，Jasmine将等待5秒钟，然后导致超时失败。可以使用`jasmine.DEFAULT_TIMEOUT_INTERVAL`变量进行覆盖。
- en: Jasmine fixtures
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine fixtures
- en: Many times, our code is responsible for either reading in, or in most cases
    manipulating DOM elements from JavaScript. This means that any running code that
    relies on a DOM element could fail, if the underlying HTML does not contain the
    correct element or group of elements. Another Jasmine extension library named
    `jasmine-jquery` allows us to inject HTML elements into the DOM before our tests
    execute, and will remove them from the DOM after the test is run.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们的代码要么负责从JavaScript中读取DOM元素，要么在大多数情况下操纵DOM元素。这意味着任何依赖于DOM元素的运行代码，如果底层HTML不包含正确的元素或一组元素，可能会失败。另一个名为`jasmine-jquery`的Jasmine扩展库允许我们在测试执行之前将HTML元素注入到DOM中，并在测试运行后从DOM中删除它们。
- en: 'At the time of writing this book, this library was not available on NuGet,
    so we will need to download the `jasmine-jquery.js` file the old-fashioned way,
    and include it in our project. The TypeScript definition file is, however, available
    on NuGet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，此库尚未在NuGet上可用，因此我们需要以传统方式下载`jasmine-jquery.js`文件，并将其包含在我们的项目中。但是，TypeScript定义文件在NuGet上是可用的：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will need to also update the `.html` file to include both `jquery.js` and
    `jasmine-jquery.js` files in the header script section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`.html`文件，在头部脚本部分包含`jquery.js`和`jasmine-jquery.js`文件。
- en: 'Let''s have a look at a test that injects DOM elements by using the `jasmine-jquery`
    library. Firstly, a class that manipulates a specific DOM element:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`jasmine-jquery`库注入DOM元素的测试。首先，一个操纵特定DOM元素的类：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This `ModifyDomElement` class has a single function, named `setHtml` that is
    using jQuery to find a DOM element with the id of `my_div`. The HTML of this div
    is then set to a simple `"Hello world"` paragraph. Now for our Jasmine test:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ModifyDomElement`类有一个名为`setHtml`的单个函数，它使用jQuery查找id为`my_div`的DOM元素。然后，这个div的HTML被设置为一个简单的`"Hello
    world"`段落。现在是我们的Jasmine测试：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The test starts by calling the `jasmine-jquery` function `setFixtures`. This
    function will inject the HTML provided as the first string argument directly into
    the DOM. We then create an instance of the `ModifyDomElement` class, and call
    the `setHtml` function to modify the `my_div` element. We are then setting the
    variable `modifiedElement` to the result of a jQuery search in the DOM. If jQuery
    has found the element, then its `length` property will be `> 0`, and we can then
    check to see if, in fact, the HTML was modified.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从调用`jasmine-jquery`函数`setFixtures`开始。此函数将提供的HTML作为第一个字符串参数直接注入到DOM中。然后，我们创建`ModifyDomElement`类的一个实例，并调用`setHtml`函数来修改`my_div`元素。然后，我们将变量`modifiedElement`设置为DOM中jQuery搜索的结果。如果jQuery找到了元素，则其`length`属性将为`>
    0`，然后我们可以检查HTML是否确实被修改。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fixture methods provided by `jasmine-jquery` also allow loading raw HTML
    files off disk, instead of having to write out lengthy string representations
    of HTML. This is also particularly useful if your MV* framework uses HTML file
    snippets. The `jasmine-jquery` library also has utilities for loading JSON from
    disk, and purpose build matchers that work with jQuery. Be sure to check out the
    documentation at ([https://github.com/velesin/jasmine-jquery](https://github.com/velesin/jasmine-jquery)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`jasmine-jquery`提供的fixture方法还允许从磁盘加载原始HTML文件，而不必编写HTML的冗长字符串表示。如果您的MV*框架使用HTML文件片段，这也特别有用。`jasmine-jquery`库还具有从磁盘加载JSON的实用程序，并且可以与jQuery一起使用的特定构建匹配器。请务必查看文档（[https://github.com/velesin/jasmine-jquery](https://github.com/velesin/jasmine-jquery)）。'
- en: DOM events
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件
- en: 'The `jasmine-jquery` library also adds some Jasmine spies to help with DOM
    events. If we were creating a button, either within TypeScript code or within
    HTML, we can ensure that our code correctly responds to DOM events such as `click`.
    Consider the following code and test:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`jasmine-jquery`库还添加了一些Jasmine间谍，以帮助处理DOM事件。如果我们正在创建一个按钮，无论是在TypeScript代码中还是在HTML中，我们都可以确保我们的代码正确响应DOM事件，比如`click`。考虑以下代码和测试：'
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Firstly, we are defining a dummy function named `handle_my_click_div_clicked`,
    which is used within the fixture HTML. Having a closer look at the HTML used in
    the `setFixtures` function call, we are creating a button with an id of `my_click_div`,
    and an `onclick` DOM event that will call our dummy function. We then create a
    spy on this click event for the `my_click_div` div, and on the next line actually
    invoke the click event. Our expectation is using the `jasmine-jquery` matcher
    `toHaveBeenTriggered` to test whether the `onclick` handler was invoked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`handle_my_click_div_clicked`的虚拟函数，该函数在fixture HTML中使用。仔细查看`setFixtures`函数调用中使用的HTML，我们创建了一个带有id为`my_click_div`的按钮，并且具有一个`onclick`
    DOM事件，将调用我们的虚拟函数。然后，我们在`my_click_div` div上创建一个点击事件的间谍，然后在下一行实际调用点击事件。我们的期望是使用`jasmine-jquery`匹配器`toHaveBeenTriggered`来测试`onclick`处理程序是否被调用。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jQuery and DOM manipulation provide us with a way of filling in forms, clicking
    on **Submit**, **Cancel**, **OK** buttons, and generally simulating user interaction
    with our application. We can easily write full acceptance or user acceptance tests
    within Jasmine using these techniques—further solidifying our application against
    errors and change.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery和DOM操作为我们提供了一种填写表单、单击**提交**、**取消**、**确定**按钮，并一般模拟用户与我们的应用程序的交互的方法。我们可以使用这些技术在Jasmine中轻松编写完整的验收或用户验收测试，进一步巩固我们的应用程序，防止错误和变更。
- en: Jasmine runners
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 茉莉花运行器
- en: There are a number of ways to run Jasmine tests outside of an actual web page,
    as we have been doing up until this point. Bear in mind, though, that Visual Studio
    does not support debugging TypeScript outside of directly running a web page with
    Internet Explorer. In these cases, you would need to revert to the existing developer
    tools available within your target browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以在实际网页之外运行Jasmine测试，就像我们一直在做的那样。但请记住，Visual Studio不支持在直接运行Internet Explorer的网页之外调试TypeScript。在这些情况下，您需要回到目标浏览器中现有的开发人员工具。
- en: Most test runners rely on a simple static HTML page to contain all tests, and
    will fire up a small instance of a web server in order to serve this HTML page
    to the test runner. Some test runners use a configuration file for this purpose,
    and construct a testing environment without the need for HTML at all. This may
    be all well and good for unit tests—where the integration points of your code
    are mocked or stubbed—but this approach does not work well for integration or
    acceptance tests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试运行器依赖于一个简单的静态HTML页面来包含所有测试，并将启动一个小型的Web服务器实例，以便将此HTML页面提供给测试运行器。一些测试运行器使用配置文件来实现这一目的，并构建一个无需HTML的测试环境。这对于单元测试可能很好，其中代码的集成点被模拟或存根，但这种方法对于集成或验收测试效果不佳。
- en: Many real-world web applications, for example, run through some server-side
    business logic to generate HTML for each web request. Authentication logic, for
    example, may redirect the user to a login page, and then use a forms-based auth
    cookie on subsequent page requests or RESTful data requests. In these circumstances,
    running a simple HTML page outside of the actual web application will not work.
    You need to run your tests within a page that is actually hosted along with the
    rest of the web application. Also, if you are trying to add a JavaScript test
    suite to an existing web project, this logic may not be easy to set aside.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多现实世界的Web应用程序通过一些服务器端业务逻辑来生成每个Web请求的HTML。例如，身份验证逻辑可能会将用户重定向到登录页面，然后在后续页面请求或RESTful数据请求中使用基于表单的身份验证cookie。在这些情况下，在实际Web应用程序之外运行简单的HTML页面将不起作用。您需要在实际与Web应用程序的其余部分一起托管的页面中运行您的测试。此外，如果您尝试将JavaScript测试套件添加到现有的Web项目中，这种逻辑可能不容易放在一边。
- en: For these reasons, we have focused on using a standard HTML page within our
    web application to run our tests. In an MVC application, for example, we would
    set up a Jasmine controller, with a `Run` function that returned a `SpecRunner.cshtml`
    view page. In fact, the default installation of the NuGet package `JasmineTest`
    will set up these controllers and views as standard templates for us on installation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们专注于在我们的Web应用程序中使用标准HTML页面来运行我们的测试。例如，在MVC应用程序中，我们将设置一个Jasmine控制器，其中包含一个返回`SpecRunner.cshtml`视图页面的`Run`函数。实际上，NuGet包`JasmineTest`的默认安装将在安装时为我们设置这些控制器和视图作为标准模板。
- en: Testem
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Testem
- en: Testem is a Node based command-line utility that will continuously run test
    suites against connected browsers when it detects that JavaScript files have been
    modified. Testem is useful for very quick feedback on a number of browsers, and
    also has a continuous integration flag that can be used on build servers. Testem
    is suitable for unit testing. More info can be found at the GitHub repository
    ([https://github.com/airportyh/testem](https://github.com/airportyh/testem)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Testem是一个基于Node的命令行实用程序，当它检测到JavaScript文件已被修改时，将连续运行测试套件以针对连接的浏览器。Testem非常适用于在多个浏览器上快速获得反馈，还具有可以在构建服务器上使用的持续集成标志。Testem适用于单元测试。更多信息可以在GitHub存储库中找到（[https://github.com/airportyh/testem](https://github.com/airportyh/testem)）。
- en: 'Testem can be installed via Node with the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令在Node上安装Testem：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To run `testem`, simply navigate to the root folder of your test suite in a
    command-line window, and type `testem`. Testem will fire up, start a web server,
    and invite you to connect to it via a browser. In following the screenshots, Testem
    was running at `http://localhost:7357`. You can connect a number of different
    browsers to this URL—and Testem will run the specs it finds against each browser.
    By default, Testem will search the current directory for JavaScript files that
    contain tests, build an HTML page containing these tests and execute them. If
    you already have an HTML page that has your tests included, then this page can
    be specified to Testem via a `testem.yml` config file as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`testem`，只需在命令行窗口中导航到测试套件的根文件夹，并输入`testem`。Testem将启动，启动一个Web服务器，并邀请您通过浏览器连接到它。按照屏幕截图，Testem在`http://localhost:7357`上运行。您可以将多个不同的浏览器连接到此URL，并且Testem将针对每个浏览器运行它找到的规范。默认情况下，Testem将在当前目录中搜索包含测试的JavaScript文件，构建包含这些测试的HTML页面并执行它们。如果您已经有一个包含您的测试的HTML页面，那么可以通过`testem.yml`配置文件将此页面指定给Testem，如下所示：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This HTML page will also need to include the testem.js file to enable communication
    with the Testem server.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此HTML页面还需要包含testem.js文件，以便与Testem服务器进行通信。
- en: '![Testem](img/image_9665OS_06_02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Testem](img/image_9665OS_06_02.jpg)'
- en: Testem output showing three connected browsers
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Testem输出显示三个连接的浏览器
- en: Testem has a number of powerful configuration options that can be specified
    in the configuration file. Be sure to head over to the GitHub repository for more
    information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Testem有许多强大的配置选项，可以在配置文件中指定。请务必前往GitHub存储库获取更多信息。
- en: Note that Testem will not work with ASP.NET MVC controller routes—making it
    unsuitable for integration testing on ASP.NET MVC sites. If you are using an MVC
    controller and view to generate your test suite, such that the URL to your running
    test page is `/Jasmine/Run`, for example—Testem will not work.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Testem将无法与ASP.NET MVC控制器路由一起工作，因此不适用于ASP.NET MVC站点的集成测试。如果您正在使用MVC控制器和视图来生成您的测试套件，例如，您正在运行测试页面的URL是`/Jasmine/Run`，Testem将无法工作。
- en: Karma
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Karma
- en: 'Karma is a test runner built by the Angular team, and features heavily in the
    Angular tutorials. It is a unit testing framework only, and the Angular team recommends
    end-to-end or integration tests to be built and run via Protractor. Karma, like
    Testem, runs its own instance of a web server in order to serve pages and artifacts
    required by the test suite, and has a large set of configuration options. It can
    also be used for unit tests that do not target Angular. To install Karma to work
    with Jasmine 2.0, we will need to install a few packages using `npm`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Karma是由Angular团队构建的测试运行器，并在Angular教程中大量使用。它只是一个单元测试框架，Angular团队建议使用Protractor构建和运行端到端或集成测试。Karma，像Testem一样，运行自己的Web服务器实例，以便为测试套件提供所需的页面和工件，并具有大量的配置选项。它也可以用于不针对Angular的单元测试。要安装Karma以与Jasmine
    2.0一起使用，我们需要使用`npm`安装一些软件包：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To run Karma, we will firstly need a config file. By convention, this is generally
    called `karma.conf.js`. A sample `karma` config file is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Karma，我们首先需要一个配置文件。按照惯例，这通常称为`karma.conf.js`。示例`karma`配置文件如下：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All config to Karma must be passed in via the `module.exports` and `config.set`
    convention, as seen in the first two lines. The `basePath` parameter specifies
    what the root path is of the web project, and is relevant to the directory that
    the `karma.config.js` file resides in. The `files` array contains list of files
    to be included in the generated HTML file, and can use the `\**\*.js` matching
    algorithms to load an entire directory and sub-directory of JavaScript files.
    The `autoWatch` parameter keeps karma running in the background, watching files
    for changes, in a similar manner to Testem. Karma also allows for a variety of
    browsers to be specified—each with their own launcher plugins. Finally, the `junitReporter`
    is being used in this example to report tests back to a Jenkins CI server. Once
    this config file is in place, simply run karma start as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Karma的配置都必须通过`module.exports`和`config.set`约定传递，如前两行所示。`basePath`参数指定Web项目的根路径，并与`karma.config.js`文件所在的目录相关。`files`数组包含要包含在生成的HTML文件中的文件列表，并且可以使用`\**\*.js`匹配算法来加载整个目录和子目录的JavaScript文件。`autoWatch`参数使Karma在后台运行，监视文件的更改，类似于Testem。Karma还允许指定各种浏览器，每个浏览器都有自己的启动器插件。最后，本示例中使用`junitReporter`将测试报告回报给Jenkins
    CI服务器。一旦配置文件就位，只需运行以下命令启动karma：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Karma](img/image_9665OS_06_03.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Karma](img/image_9665OS_06_03.jpg)'
- en: Karma output from a simple test
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Karma从一个简单的测试中输出
- en: Protractor
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protractor
- en: 'Protractor is a Node based test runner that tackles end-to-end testing. It
    was originally designed for Angular apps, but can be used with any website. Unlike
    Testem and Karma, Protractor is able to browse to a specific page and then interact
    with the page from JavaScript—making it suitable for integration testing. It can
    check metadata properties such as the page title, or fill in forms and click on
    buttons, and allow the backend server to redirect to different pages. Protractor
    documentation can be found here ([https://github.com/angular/protractor](https://github.com/angular/protractor)),
    and can be installed with `npm`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是一个基于Node的测试运行器，用于端到端测试。它最初是为Angular应用程序设计的，但可以与任何网站一起使用。与Testem和Karma不同，Protractor能够浏览到特定页面，然后从JavaScript与页面交互，适用于集成测试。它可以检查页面标题等元数据属性，或填写表单和点击按钮，并允许后端服务器重定向到不同的页面。Protractor文档可以在这里找到（[https://github.com/angular/protractor](https://github.com/angular/protractor)），并可以使用`npm`安装：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will get to running Protractor a little later, but first, let's discuss the
    engine that Protractor uses in order to automate web pages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将运行Protractor，但首先让我们讨论Protractor用于自动化网页的引擎。
- en: Using Selenium
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Selenium
- en: 'Selenium is a driver for web browsers. It allows programmatic remote control
    of web browsers, and can be used to create automated tests in Java, C#, Python,
    Ruby, PHP, Perl, and even JavaScript. Protractor uses Selenium under the covers
    to control web browser instances. To install the Selenium server for use with
    Protractor, run the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个用于Web浏览器的驱动程序。它允许对Web浏览器进行编程远程控制，并可用于在Java、C#、Python、Ruby、PHP、Perl甚至JavaScript中创建自动化测试。Protractor在底层使用Selenium来控制Web浏览器实例。要安装用于Protractor的Selenium服务器，请运行以下命令：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To start the Selenium server, run the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Selenium服务器，请运行以下命令：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If all goes well, Selenium will report that the server has started, and will
    detail the address of the Selenium server. Check your output for a line similar
    to the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，Selenium将报告服务器已启动，并详细说明Selenium服务器的地址。检查您的输出是否有类似以下行：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need Java to be installed on your machine in order to run the Selenium
    server, as the webdriver-manager script uses Java to start the Selenium server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装Java才能运行Selenium服务器，因为webdriver-manager脚本使用Java启动Selenium服务器。
- en: 'Once the server is running, we will need a configuration file for Protractor
    (named `protractor.conf.js`) that includes some settings. At this stage, all we
    need is the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器运行，我们将需要一个Protractor的配置文件（名为`protractor.conf.js`），其中包含一些设置。在这个阶段，我们只需要以下内容：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These protractor settings simply set the `seleniumAddress` to the address of
    the Selenium server, as reported earlier. We also have a `specs` property, which
    is set to look for any `.js` file within the same directory as the `protractor.conf.js`,
    and treat them as test specs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些protractor设置只是将`seleniumAddress`设置为之前报告的Selenium服务器的地址。我们还有一个`specs`属性，它被设置为在与`protractor.conf.js`相同目录中查找任何`.js`文件，并将它们视为测试规范。
- en: 'Now for the simplest of tests:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最简单的测试：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our test starts by opening the page at `/Jasmine/Run`. Note that this is an
    ASP.NET MVC path that uses the default Jasmine controller, and returns `Views/Jasmine/SpecRunner.cshtml`.
    This controller and view was included with the Jasmine NuGet package that we installed
    earlier. Make sure that you can navigate to this page in your browser before trying
    to execute the Protractor tests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试从在`/Jasmine/Run`打开页面开始。请注意，这是一个使用默认Jasmine控制器的ASP.NET MVC路径，并返回`Views/Jasmine/SpecRunner.cshtml`。这个控制器和视图是之前安装的Jasmine
    NuGet包中包含的。在尝试执行Protractor测试之前，请确保您可以在浏览器中导航到此页面。
- en: 'Running Protractor with the configuration file will now execute our previous
    test:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件运行Protractor现在将执行我们之前的测试：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And will produce the desired result:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将产生期望的结果：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two things that must be running here in order for this test to work:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里必须有两件事情在运行，以便这个测试能够工作：
- en: The Selenium server must be running in a command prompt, such that `localhost:4444/wd/hub`
    is a valid address, and does not return 404 errors
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium服务器必须在命令提示符中运行，以便`localhost:4444/wd/hub`是有效地址，并且不返回404错误
- en: The developer ASP.NET website must be up and running so that `localhost:64277/Jasmine/Run`
    hits our Visual Studio Jasmine controller, and renders an HTML page
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员ASP.NET网站必须正常运行，以便`localhost:64277/Jasmine/Run`访问我们的Visual Studio Jasmine控制器，并呈现HTML页面
- en: Integration tests
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Let's assume that we are conducting integration tests in a test page that is
    rendered using ASP.NET MVC routes. We want to use the standard MVC controller,
    action, view method of generating an HTML page, as we may need to execute some
    server-side logic to setup pre-requisites before the integration tests can start.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在进行集成测试，测试页面是使用ASP.NET MVC路由渲染的。我们希望使用标准的MVC控制器、操作、视图方法来生成HTML页面，因为我们可能需要执行一些服务器端逻辑来设置集成测试开始之前的前提条件。
- en: Note that in a real-world application, it is often necessary to run server-side
    logic or use server-side HTML rendering for integration tests. For instance, most
    applications will require some sort of authentication before allowing calls to
    REST services via JavaScript. Implementing an [Authorize] attribute to your RESTful
    API controllers is the logical solution. Unfortunately, calling any of these REST
    controllers from a normal HTML page will return 401 (Unauthorized) errors. One
    way around this is to use an MVC controller to serve the test HTML page, and then
    to set up a dummy forms authentication ticket in the server-side code. Once this
    is in place, any calls to RESTful services from this page will already be authenticated
    with a dummy user profile. This technique can also be used to run integration
    tests where users have different roles and different permissions based on their
    authentication credentials.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在现实世界的应用程序中，通常需要运行服务器端逻辑或使用服务器端HTML渲染进行集成测试。例如，大多数应用程序在允许通过JavaScript调用REST服务之前，都需要某种形式的身份验证。向RESTful
    API控制器实现[Authorize]属性是合乎逻辑的解决方案。不幸的是，从普通HTML页面调用这些REST控制器将返回401（未经授权）错误。解决这个问题的一种方法是使用MVC控制器来提供测试HTML页面，然后在服务器端代码中设置虚拟表单身份验证票证。一旦这个设置完成，从此页面对RESTful服务的任何调用都将使用虚拟用户配置文件进行身份验证。这种技术也可以用于运行具有不同角色和不同权限的用户的集成测试，这些角色和权限基于他们的身份验证凭据。
- en: Simulating integration tests
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟集成测试
- en: To simulate this sort of integration test page, let's reuse the `JasmineController`
    that was installed with the Jasmine NuGet package. As mentioned earlier, an integration
    test will need to hit the backend server-side logic (in this case the Jasmine
    MVC controller), and then render a server-side-generated HTML page to the browser
    (in this case the `SpecRunner.cshtml` view). This simulation means that we are
    relying on the server-side MVC framework to resolve the `/Jasmine/Run` URL, generate
    an HTML page on the fly, and return this generated HTML page to the browser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种集成测试页面，让我们重用之前安装的Jasmine NuGet包中的`JasmineController`。如前所述，集成测试将需要访问后端服务器端逻辑（在这种情况下是Jasmine
    MVC控制器），然后将服务器端生成的HTML页面呈现到浏览器（在这种情况下是`SpecRunner.cshtml`视图）。这种模拟意味着我们依赖服务器端MVC框架来解析`/Jasmine/Run`
    URL，动态生成HTML页面，并将生成的HTML页面返回给浏览器。
- en: 'This `SpecRunner.cshtml` file (the MVC template for generating the HTML) is
    very simple:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SpecRunner.cshtml`文件（用于生成HTML的MVC模板）非常简单：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This ASP.NET MVC view page is using Razor syntax, and is not based on a master
    page—as the `Layout` parameter at the top of the file is set to `null`. The page
    includes a number of links in the `head` element, including `jasmine.css`, `jasmine.js`,
    `jasmine-html.js`, and `boot.js`. These are the required Jasmine files that we
    have seen before. After this, we have just included the `SpecHelper.js`, `PlayerSpec.js`,
    `Player.js`, and `Song.js` files from the `jasmine-samples` directory. Running
    this page by navigating to the `/Jasmine/Run` URL will run the sample tests included
    with Jasmine:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ASP.NET MVC视图页面使用Razor语法，不是基于主页面，因为文件顶部的`Layout`参数设置为`null`。页面在`head`元素中包含了一些链接，包括`jasmine.css`、`jasmine.js`、`jasmine-html.js`和`boot.js`。这些是我们之前看到的必需的Jasmine文件。之后，我们只包括了`jasmine-samples`目录中的`SpecHelper.js`、`PlayerSpec.js`、`Player.js`和`Song.js`文件。通过导航到`/Jasmine/Run`
    URL运行此页面将运行Jasmine附带的示例测试。
- en: '![Simulating integration tests](img/image_9665OS_06_04.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![模拟集成测试](img/image_9665OS_06_04.jpg)'
- en: Output of the default/Jasmine/Run web page
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认/Jasmine/Run网页的输出
- en: Our simulated integration test page in this sample just runs a couple of standard
    Jasmine tests. Using a server-side generated HTML page now allows us to use dummy
    authentication, if needed. With dummy authentication in place, we can start to
    write Jasmine tests to target secure RESTful data services.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们模拟的集成测试页面只运行了一些标准的Jasmine测试。现在使用服务器端生成的HTML页面可以允许我们使用虚拟身份验证，如果需要的话。有了虚拟身份验证，我们可以开始编写Jasmine测试来针对安全的RESTful数据服务。
- en: In our next chapter, we will have a look at building and testing some Backbone
    models and collections, and will work through further examples of integration
    tests that actually request data from the server. For the time being, though,
    we have a sample page that is generated server-side, and that can be used as the
    base for further integration tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下构建和测试一些Backbone模型和集合，并将通过更多的集成测试示例来实际请求服务器上的数据。不过，目前我们有一个由服务器端生成的示例页面，可以作为进一步集成测试的基础。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Test pages like these should never be packaged in **User Acceptance Testing**
    (**UAT**) or release configurations. In ASP.NET, we can simply use a compiler
    directive such as the `#if DEBUG … #endif` around our controller classes to exclude
    them from any other build configuration.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '这样的测试页面不应该被打包在用户验收测试（UAT）或发布配置中。在ASP.NET中，我们可以简单地在我们的控制器类周围使用编译指令，比如`#if DEBUG
    … #endif`，来排除它们从任何其他构建配置中。'
- en: Detailed test results
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细的测试结果
- en: So we now have the beginnings of an integration test page that shows us the
    results of our Jasmine test run. This HTML page is good for a quick overview,
    but we would now like some more detailed information on each test so that we can
    report back to our build server; how long each test took, and its `success` /
    `fail` state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们有了一个集成测试页面的开端，它显示了我们的Jasmine测试运行的结果。这个HTML页面对于快速概览很好，但我们现在希望一些更详细的关于每个测试的信息，以便我们可以报告给我们的构建服务器；每个测试花费的时间，以及它的`success`
    / `fail`状态。
- en: For these reporting purposes, Jasmine includes the ability to use custom test
    reporters, over and above the standard `HtmlReporter` that is the Jasmine default.
    The GitHub project, jasmine-reporters ([https://github.com/larrymyers/jasmine-reporters](https://github.com/larrymyers/jasmine-reporters)),
    has a number of prebuilt test reporters that cater for the most popular build
    servers. Unfortunately, this project does not have a corresponding NuGet package,
    so we will need to install the `.js` files within our project manually.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了报告这些目的，Jasmine包括使用自定义测试报告者的能力，超出了Jasmine默认的`HtmlReporter`。GitHub项目jasmine-reporters（[https://github.com/larrymyers/jasmine-reporters](https://github.com/larrymyers/jasmine-reporters)）有许多预构建的测试报告者，适用于最流行的构建服务器。不幸的是，这个项目没有相应的NuGet包，所以我们需要手动在我们的项目中安装`.js`文件。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative method of managing JavaScript libraries is the **Bower** package
    manager. Bower is a Node based command-line utility that is similar to NuGet,
    but deals only with JavaScript libraries and frameworks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 管理JavaScript库的另一种方法是使用**Bower**包管理器。Bower是一个基于Node的命令行实用程序，类似于NuGet，但只处理JavaScript库和框架。
- en: 'Let''s now modify our HTML page to include the TeamCity reporter. Firstly,
    modify the `SpecRunner.cshtml` file to include a `script` tag for the `teamcity_reporter.js`
    file as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的HTML页面来包含TeamCity报告者。首先，修改`SpecRunner.cshtml`文件，包含`teamcity_reporter.js`文件的`script`标签如下：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we need to create a simple script within the `body` tag to register this
    reporter with Jasmine:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`body`标签内创建一个简单的脚本来注册这个报告者到Jasmine：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This script simply creates an instance of the `TeamCityReporter` class, and
    assigns it to a variable named `tcapi` on the `window` object. The second line
    of this script adds this reporter to the Jasmine environment. Running our page
    now will produce TeamCity results logged to the console:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本只是创建了一个`TeamCityReporter`类的实例，并将其分配给`window`对象上的一个名为`tcapi`的变量。这个脚本的第二行将这个报告者添加到Jasmine环境中。现在运行我们的页面将会产生记录在控制台的TeamCity结果：
- en: '![Detailed test results](img/image_9665OS_06_05.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![详细的测试结果](img/image_9665OS_06_05.jpg)'
- en: Jasmine output with TeamCity messages logged to the console
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine输出与记录在控制台的TeamCity消息
- en: Logging test results
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录测试结果
- en: We now need to access this output, and find a way to report it back to the Protractor
    instance. Unfortunately, accessing the console's log through Selenium will only
    report critical errors, so the preceding TeamCity reporter output will be unavailable.
    A quick look around the `teamcity_reporter.js` code reveals that all `console.log`
    output messages use the `tclog` function to build a string, and then call `console.log`
    with this string. As we have an instance of our `TeamCityReporter` available to
    us, we can easily store these logged messages into an array, and then read through
    them once the test suite has finished running. Some quick modifications to the
    JavaScript file `teamcity_reporter.js` are as follows.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要访问这个输出，并找到一种方法将其报告给Protractor实例。不幸的是，通过Selenium访问控制台的日志只会报告关键错误，因此前面的TeamCity报告输出将不可用。快速查看`teamcity_reporter.js`代码，发现所有的`console.log`输出消息都使用`tclog`函数来构建一个字符串，然后调用`console.log`输出这个字符串。由于我们有一个可用的`TeamCityReporter`实例，我们可以很容易地将这些记录的消息存储到一个数组中，然后在测试套件运行结束后读取它们。对JavaScript文件`teamcity_reporter.js`进行一些快速修改如下。
- en: 'Just under the constructor function for the `TeamCityReporter` class, create
    an array:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TeamCityReporter`类的构造函数下方，创建一个数组：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can modify the `tclog` function to return the string that is it building:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`tclog`函数来返回它构建的字符串：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, each call to `tclog` can push the returned string to this array:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次调用`tclog`都可以将返回的字符串推送到这个数组中：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that the `TeamCityReporter` has a `logItems` array, we will need some method
    of finding out when the test suite has finished, and we can then loop through
    the array of `logItems`, and attach them to the DOM. Once it is in the DOM, our
    Protractor instance can use Selenium to read these values and report back to the
    command line.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`TeamCityReporter`有一个`logItems`数组，我们需要一些方法来找出测试套件何时完成，然后我们可以循环遍历`logItems`数组，并将它们附加到DOM上。一旦它在DOM中，我们的Protractor实例就可以使用Selenium来读取这些值并报告给命令行。
- en: 'Let''s build a small class named `JasmineApiListener` that accepts an instance
    of the `TeamCityReporter` class to do all this work for us:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个名为`JasmineApiListener`的小类，它接受`TeamCityReporter`类的一个实例来为我们做所有这些工作：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our `JasmineApiListener` class has two private variables. The `_outputComplete`
    variable is a boolean flag indicating that the test suite has completed, and that
    the results have been written to the DOM. The `_tcReporter` variable holds an
    instance of the `TeamCityReporter` class, which is passed through in the `constructor`.
    The `constructor` simply sets the flag `_outputComplete` to `false`, creates a
    variable named `self`, and sets up a simple timer on a three-second interval.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`JasmineApiListener`类有两个私有变量。`_outputComplete`变量是一个布尔标志，指示测试套件已完成，并且结果已经写入DOM。`_tcReporter`变量保存了`TeamCityReporter`类的一个实例，它通过`constructor`传递。`constructor`简单地将标志`_outputComplete`设置为`false`，创建一个名为`self`的变量，并在三秒间隔上设置一个简单的定时器。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `self` variable is a necessary scoping step in order to access the correct
    instance of `this` inside the anonymous function that is passed to `setInterval`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`变量是必要的作用域步骤，以便在传递给`setInterval`的匿名函数内访问`this`的正确实例。'
- en: The body of our anonymous function is where all the goodness takes place. Firstly,
    we are checking the `_tcReporter.finished` property on the `TeamCityReporter`
    instance to tell whether or not the suite has completed. If it has, and we have
    not yet appended our results to the DOM `(!self._outputComplete)`, then we can
    access the `logItems` array and create DOM elements for each of these entries.
    These elements are attached as `<div class="logentry">…</div>` elements, as children
    of the parent `<div id="teamCityReporterLog">` element.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们匿名函数的主体是所有好东西发生的地方。首先，我们检查`TeamCityReporter`实例上的`_tcReporter.finished`属性，以判断套件是否已完成。如果是，并且我们还没有将结果附加到DOM
    `(!self._outputComplete)`，那么我们可以访问`logItems`数组，并为每个条目创建DOM元素。这些元素作为`<div class="logentry">…</div>`元素附加到父级`<div
    id="teamCityReporterLog">`元素。
- en: Note that the preceding code is using the native `document.getElementById` and
    `appendChild` syntax for DOM manipulation, and not a jQuery-style syntax to avoid
    having a dependency on jQuery.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码使用了原生的`document.getElementById`和`appendChild`语法进行DOM操作，而不是jQuery风格的语法，以避免对jQuery的依赖。
- en: 'We can now modify the script within the `SpecRunner.cshtml` view as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`SpecRunner.cshtml`视图中修改脚本如下：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first script is the updated version of what we have been using previously,
    which now creates an instance of our `JasmineApiListener` class, and passes the
    instance of the `TeamCityReporter` class within the constructor. We have also
    added two `<div>` tags. The first one, `teamCityResultsDone`, is a flag to indicate
    that we have completed writing the TeamCity results to the DOM, and the second
    `teamCityReporterLog` is the parent `div` to hold all of the child `logentry`
    elements.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本是我们之前使用的更新版本，现在它创建了我们的`JasmineApiListener`类的一个实例，并在构造函数中传递了`TeamCityReporter`类的实例。我们还添加了两个`<div>`标签。第一个`teamCityResultsDone`是一个标志，表示我们已经完成了将TeamCity结果写入DOM，第二个`teamCityReporterLog`是父`div`，用于容纳所有子`logentry`元素。
- en: 'If we fire up this page now, we should see our tests run through, and then
    three seconds later, the DOM will be updated with the results that we have read
    from the `TeamCityReporter` array, as shown in the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开这个页面，我们应该能看到我们的测试运行，然后三秒后，DOM将被更新，显示我们从`TeamCityReporter`数组中读取的结果，如下面的截图所示：
- en: '![Logging test results](img/image_9665OS_06_07.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![记录测试结果](img/image_9665OS_06_07.jpg)'
- en: Jasmine output being logged to the DOM
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine输出被记录到DOM
- en: Now that we have a way of logging the results of our tests to the DOM, we can
    update our Protractor based Selenium tests to relate these results to our build
    server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种将测试结果记录到DOM的方法，我们可以更新基于Protractor的Selenium测试，将这些结果与构建服务器相关联。
- en: Finding page elements
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找页面元素
- en: As mentioned previously, Protractor can be used to run integration tests, as
    well as automated acceptance tests. A Protractor test can browse to a login page,
    find the login username textbox, send a value such as "`testuser1"` to this textbox,
    and then repeat the process for a password. The same test code can then be used
    to click on the **Login** button, which will submit the form to our server login
    controller. Our test can then ensure that the server responds with the correct
    redirect to our main page. This main page may contain multiple buttons, grids,
    images, side panels and navigation elements. Ideally, we would want to write acceptance
    tests for each of these page elements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Protractor可以用于运行集成测试，以及自动接受测试。Protractor测试可以浏览到登录页面，找到登录用户名文本框，向该文本框发送值，例如"`testuser1"`，然后重复该过程以输入密码。然后可以使用相同的测试代码单击**登录**按钮，这将提交表单到我们的服务器登录控制器。然后我们的测试可以确保服务器以正确的重定向响应到我们的主页。这个主页可能包含多个按钮、网格、图片、侧边栏和导航元素。理想情况下，我们希望为每个这些页面元素编写接受测试。
- en: Protractor uses locators to find these elements within our DOM. These elements
    can be found by their CSS selectors, by `id`, or, if using Angular, by model or
    binding. Building the correct strings for use in these selectors can sometimes
    be difficult.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor使用定位器在DOM中查找这些元素。这些元素可以通过它们的CSS选择器、`id`来找到，或者如果使用Angular，则可以通过模型或绑定来找到。构建这些选择器的正确字符串有时可能很困难。
- en: Selenium provides us with a useful Firefox extension to help when writing Selenium
    based tests - the Selenium IDE ([http://docs.seleniumhq.org/projects/ide/](http://docs.seleniumhq.org/projects/ide/)).
    With this extension installed within Firefox, we can use the IDE to help find
    elements on the page.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium为我们提供了一个有用的Firefox扩展，用于编写基于Selenium的测试 - Selenium IDE ([http://docs.seleniumhq.org/projects/ide/](http://docs.seleniumhq.org/projects/ide/))。安装了这个扩展后，我们可以使用IDE来帮助找到页面上的元素。
- en: As an example of how to use this extension, let's continue with our work on
    the Jasmine reporter that we have writing, and find the `teamCityResultsDone`
    DOM element that we have been using to flag a completed test suite. The code and
    process we use to find this DOM element is the same code and process that we would
    use to find other page elements on a login page, for example, or any other page
    that we were driving through Selenium.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何使用这个扩展的示例，让我们继续我们正在编写的Jasmine报告器的工作，并找到我们一直在使用来标记完成测试套件的`teamCityResultsDone`DOM元素。我们用来找到这个DOM元素的代码和过程与我们在登录页面上找到其他页面元素的代码和过程相同，例如，或者我们通过Selenium驱动的任何其他页面。
- en: 'If we fire up our `/Jasmine/Run` page using Firefox, we can now click on the
    Selenium IDE button on the top right of the browser to launch the Selenium IDE.
    This IDE uses commands to record interactions against a web page, and shows this
    list of commands in the main window. Right-click on the command window, and select
    **Insert new command**. In the command name text box give the new command a name—something
    like `find done element`. Once a command has a name, the two buttons next to the
    target input box become enabled, and we can click on **Select**. We can then drag
    our mouse over the web page, and click on the text **done** at the top of the
    page. Notice how the command has automatically filled in the **Target** element
    in the Selenium IDE. The **Target** input box has now become a drop-down list,
    and we can use this list to show the Selenium selector syntax for our `teamCityResultsDone`
    `div`, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Firefox中启动我们的`/Jasmine/Run`页面，现在我们可以点击浏览器右上角的Selenium IDE按钮来启动Selenium
    IDE。这个IDE使用命令来记录对网页的交互，并在主窗口中显示这些命令列表。右键单击命令窗口，然后选择**插入新命令**。在命令名称文本框中给新命令一个名称，比如`find
    done element`。一旦命令有了名称，目标输入框旁边的两个按钮就变成了启用状态，我们可以点击**选择**。然后我们可以在网页上拖动鼠标，并点击页面顶部的**done**文本。注意命令已经自动填写了Selenium
    IDE中的**目标**元素。**目标**输入框现在变成了一个下拉列表，我们可以使用这个列表来显示我们`teamCityResultsDone`的`div`的Selenium选择器语法，如下面的截图所示：
- en: '![Finding page elements](img/image_9665OS_06_08.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![查找页面元素](img/image_9665OS_06_08.jpg)'
- en: FireFox Selenium IDE
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: FireFox Selenium IDE
- en: Working with page elements in Jasmine
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Jasmine中使用页面元素
- en: Now that we know how to find an HTML page element using the Selenium IDE, we
    can start writing Selenium commands to query the page elements of our Jasmine
    tests. Remember that there are two elements we need to find.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用Selenium IDE来找到HTML页面元素，我们可以开始编写Selenium命令来查询我们Jasmine测试的页面元素。记住我们需要找到两个元素。
- en: Firstly, we need to find the `teamCityResultsDone` `div`, and wait for the text
    of this element to be updated. This div is only updated when our Jasmine test
    suite is complete, and our tests results have been included in the DOM. Once our
    test suite has been flagged as complete, we then need to loop through each of
    the `logentry` `divs` that are child elements of the `teamCityReporterLog` `div`.
    These `logentry` `divs` will contain the detailed results each of our tests.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到`teamCityResultsDone`的`div`，并等待该元素的文本被更新。这个`div`只有在我们的Jasmine测试套件完成时才会被更新，并且我们的测试结果已经包含在DOM中。一旦我们的测试套件被标记为完成，我们就需要循环遍历`teamCityReporterLog`的子元素`logentry`的每一个`div`。这些`logentry`的`div`将包含我们每个测试的详细结果。
- en: 'The changes needed in our protractor tests are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在protractor测试中需要的更改如下：
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our test begins by browsing to the `/Jasmine/Run` page, and expects this page
    title to contain `"Jasmine"`, as we have seen previously. We are then using the
    `findElement` function from Selenium to find an element on the page. This function
    is passed a JavaScript object with the `id` set to `teamCityResultsDone`—and is
    using the select syntax that we saw earlier in the Selenium IDE.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试从浏览到`/Jasmine/Run`页面开始，并期望该页面的标题包含`"Jasmine"`，就像我们之前看到的那样。然后，我们使用来自Selenium的`findElement`函数在页面上找到一个元素。这个函数传递了一个JavaScript对象，其中`id`设置为`teamCityResultsDone`，并且使用了我们之前在Selenium
    IDE中看到的选择语法。
- en: We are then calling the `wait` function to wait for the text of the `teamCityResultsDone`
    element to be updated (that is, its `length` is `> 0` ), and set a 60-second timeout
    for this `wait` function. Remember that our `JasmineApiListener` code will set
    the text value of this div to `"done"` when we have finished updating the DOM,
    which will effectively then trigger the `wait` function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`wait`函数等待`teamCityResultsDone`元素的文本被更新（即其`length`为`> 0`），并为这个`wait`函数设置了60秒的超时。记住我们的`JasmineApiListener`代码将在我们完成更新DOM时将这个`div`的文本值设置为`"done"`，这将有效地触发`wait`函数。
- en: We are then using the `afterEach` function to loop through the `logentry` `divs`.
    Instead of finding the parent element, we are now using the `findElements` Selenium
    function to find multiple elements on the page.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`afterEach`函数循环遍历`logentry`的`divs`。我们现在不是找到父元素，而是使用`findElements` Selenium函数在页面上找到多个元素。
- en: 'Note the Selenium selector syntax that we are using for these `divs`: `by.css("#teamCityReporterLog
    > div.logentry")`. This `by.css` function is using CSS selector syntax to find
    our elements, and the input string corresponds to the CSS selector that the Selenium
    IDE shows. We can therefore use the Selenium IDE to help us find the correct CSS
    selector syntax.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们用于这些`div`的Selenium选择器语法：`by.css("#teamCityReporterLog > div.logentry")`。这个`by.css`函数使用CSS选择器语法来找到我们的元素，输入字符串对应于Selenium
    IDE显示的CSS选择器。因此，我们可以使用Selenium IDE来帮助我们找到正确的CSS选择器语法。
- en: Selenium uses a fluent syntax for most of its API functions. The call to the
    `findElements`, therefore, is followed by a `.then` function, which will pass
    the elements it has found in an array to the anonymous function. We use this anonymous
    function with the `.then( (elements) => { .. })` syntax. Within this function,
    we are looping through each element of the elements array, and calling the `.getText`
    Selenium function. Again, this `getText` function provides a fluent syntax, which
    allows us to write another anonymous function to use the text value returned,
    as seen in the line `elements[i].getText().then( (textValue ) => { … });`. This
    function is simply logging the `textValue` to the protractor console.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 对其大多数 API 函数使用流畅的语法。因此，对 `findElements` 的调用后面跟着一个 `.then` 函数，它将在数组中找到的元素传递给匿名函数。我们使用这个匿名函数与
    `.then( (elements) => { .. })` 语法。在这个函数中，我们循环遍历元素数组的每个元素，并调用 `.getText` Selenium
    函数。同样，这个 `getText` 函数提供了流畅的语法，允许我们编写另一个匿名函数来使用返回的文本值，就像在 `elements[i].getText().then(
    (textValue ) => { … });` 中看到的那样。这个函数只是将 `textValue` 记录到 protractor 控制台中。
- en: 'Running our Protractor test will now report our test results to the command
    line as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的 Protractor 测试将会将测试结果报告到命令行，如下所示：
- en: '![Working with page elements in Jasmine](img/image_9665OS_06_09.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![在 Jasmine 中使用页面元素](img/image_9665OS_06_09.jpg)'
- en: Protractor logging test results to the console
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 将测试结果记录到控制台
- en: Mission accomplished. We are now using Protractor to browse to a server-generated
    HTML page that runs a set of Jasmine tests. We are then using Selenium to find
    elements on the page, waiting for DOM updates, and then loop through an array
    of elements in order to log our Jasmine test results to the protractor console.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成。我们现在正在使用 Protractor 浏览到一个由服务器生成的 HTML 页面，运行一组 Jasmine 测试。然后我们使用 Selenium
    在页面上查找元素，等待 DOM 更新，然后循环遍历元素数组，以便将我们的 Jasmine 测试结果记录到 protractor 控制台中。
- en: These Selenium functions, such as `browser.driver.get`, `findElements`, and
    `wait` are all part of the rich set of functionality that Selenium provides to
    work with DOM elements. Be sure to head over to the Selenium documentation for
    more information.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Selenium 函数，如 `browser.driver.get`、`findElements` 和 `wait`，都是 Selenium 提供的丰富功能集的一部分，用于处理
    DOM 元素。请务必查阅 Selenium 文档以获取更多信息。
- en: We now have a mechanism to fire up an integration test page, run a Jasmine test
    suite, report these test results to the DOM, and then read these results and log
    them to the Protractor console. It is then a simple matter to set up a build step
    within a TeamCity build server to execute protractor, and record these test results
    during the build process.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种机制，可以启动集成测试页面，运行 Jasmine 测试套件，将这些测试结果报告给 DOM，然后读取这些结果并将其记录到 Protractor
    控制台中。然后在 TeamCity 构建服务器中设置一个构建步骤来执行 protractor，并在构建过程中记录这些测试结果。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored Test Driven Development from the ground up.
    We have discussed the theory of TDD, explored the differences between unit, integration,
    and acceptance tests, and had a look at what a CI build server process would look
    like. We then explored Jasmine as a testing framework, learned how to write tests,
    use expectations and matchers, and also explored Jasmine extensions to help with
    data-driven tests and DOM manipulation through fixtures. Finally, we had a look
    at test runners, and built a Protractor based test framework to drive web pages
    through Selenium, and report the results back to a build server. In the next chapter,
    we will explore the TypeScript module syntax, in order to use both CommonJS and
    AMD JavaScript modules.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始探讨了测试驱动开发。我们讨论了 TDD 的理论，探讨了单元测试、集成测试和验收测试之间的区别，并看了一下 CI 构建服务器流程会是什么样子。然后我们探讨了
    Jasmine 作为一个测试框架，学习了如何编写测试，使用期望和匹配器，还探讨了 Jasmine 扩展，以帮助进行数据驱动测试和通过固定装置进行 DOM 操作。最后，我们看了测试运行器，并构建了一个基于
    Protractor 的测试框架，通过 Selenium 驱动网页，并将结果报告给构建服务器。在下一章中，我们将探讨 TypeScript 模块语法，以便同时使用
    CommonJS 和 AMD JavaScript 模块。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Bentham Chang 准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online, LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用都需要版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
