["```py\nimport inspect\nimport time\nfrom datetime import datetime\n\ndef timer(*args, operation, n):\n \"\"\"\n Returns average time spent \n for given operation and arguments.\n\n Parameters\n ----------\n *args: list (of numpy.ndarray, numpy.matrixlib.defmatrix.matrix or both)\n one or more numpy vectors or matrices\n operation: function\n numpy or scipy operation to be applied to given arguments\n n: int \n number of iterations to apply given operation\n Returns\n -------\n avg_time_spent: double\n Average time spent to apply given operation\n std_time_spent: double\n Standard deviation of time spent to apply given operation\n\n Examples\n --------\n\n >>> import numpy as np\n >>> vec1 = np.array(np.random.rand(1000))\n >>> vec2 = np.array(np.random.rand(1000))\n >>> args = (vec1, vec2)\n\n >>> timer(*args, operation=np.dot, n=1000000)\n 8.942582607269287e-07\n \"\"\"\n\n # Following list will hold the\n # time spent value for each iteration\n time_spent = []\n\n # Configuration info\n print(\"\"\"\n -------------------------------------------\n\n ### {} Operation ###\n\n Arguments Info\n --------------\n args[0] Dimension: {},\n args[0] Shape: {},\n args[0] Length: {}\n \"\"\".format(operation.__name__,\n args[0].ndim,\n args[0].shape,\n len(args[0])))\n\n # If *args length is greater than 1, \n # print out the info for second argument\n args_len = 0\n for i, arg in enumerate(args):\n     args_len += 1\n\n if args_len > 1:\n     print(\"\"\"\n     args[1] Dimension: {},\n     args[1] Shape: {},\n     args[1] Length: {}\n     \"\"\".format(args[1].ndim,\n         args[1].shape,\n         len(args[1])))\n\n print(\"\"\"\n Operation Info\n --------------\n Name: {},\n Docstring: {}\n\n Iterations Info\n ---------------\n # of iterations: {}\"\"\".format(\n operation.__name__,\n operation.__doc__[:100] + \n \"... For more info type 'operation?'\",\n n))\n\n print(\"\"\"\n -> Starting {} of iterations at: {}\"\"\".format(n, datetime.now()))\n\n if args_len > 1:\n     for i in range(n):\n         start = time.time()\n         operation(args[0], args[1])\n         time_spent.append(time.time()-start)\n else:\n     for i in range(n):\n         start = time.time()\n         operation(args[0])\n         time_spent.append(time.time()-start)\n\n avg_time_spent = np.sum(time_spent) / n\n print(\"\"\"\n -> Average time spent: {} seconds,\n -------------------------------------------\n \"\"\".format(avg_time_spent))\n\n return avg_time_spent\n```", "```py\nprint(timer.__doc__)\n```", "```py\n    Returns average time spent \n    for given operation and arguments.\n\n    Parameters\n    ----------\n        *args: list (of numpy.ndarray, numpy.matrixlib.defmatrix.matrix or both)\n            one or more numpy vectors or matrices\n        operation: function\n            numpy or scipy operation to be applied to given arguments\n        n: int \n            number of iterations to apply given operation\n\n    Returns\n    -------\n        avg_time_spent: double\n            Average time spent to apply given operation\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> vec1 = np.array(np.random.rand(1000))\n    >>> vec2 = np.array(np.random.rand(1000))\n\n    >>> args = [vec1, vec2]\n\n    >>> timer(*args, operation=np.dot, n=1000000)\n    8.942582607269287e-07\n```", "```py\nimport numpy as np\nvec1 = np.array(np.random.rand(1000))\nvec2 = np.array(np.random.rand(1000))\nargs = [vec1, vec2]\n```", "```py\ntimer(*args, operation=np.dot, n=1000000)\n    -------------------------------------------\n    ### dot Operation ###\n    Arguments Info\n    --------------\n    args[0] Dimension: 1,\n    args[0] Shape: (1000,),\n    args[0] Length: 1000\n    args[1] Dimension: 1,\n    args[1] Shape: (1000,),\n    args[1] Length: 1000\n    Operation Info\n    --------------\n    Name: dot,\n    Docstring: dot(a, b, out=None)\n    Dot product of two arrays. Specifically,\n    - If both `a` and `b` are 1-D... For more info type 'operation?'\n    Iterations Info\n    ---------------\n    # of iterations: 1000000\n    -> Starting 1000000 of iterations at: 2018-06-09 21:02:51.711211 \n    -> Average time spent: 1.0054986476898194e-06 seconds,\n    -------------------------------------------\n1.0054986476898194e-06\n```", "```py\navg_time_spent = np.sum(time_spent) / n\nstd_time_spent = np.std(time_spent)\nprint(\"\"\"\n-> Average time spent: {} seconds,\n-> Std. deviation time spent: {} seconds\n\"\"\".format(avg_time_spent, std_time_spent))\nreturn avg_time_spent, std_time_spent\n```", "```py\nReturns\n-------\navg_time_spent: double\nAverage time spent to apply given operation\nstd_time_spent: double\nStandard deviation of time spent to apply given operation.\n```", "```py\ntimer(*args, operation=np.dot, n=1000000)\n```", "```py\n-> Starting {} of iterations at: {}\".format(n, datetime.now())\n-> Average time spent: 1.0006928443908692e-06 seconds,\n-> Std. deviation time spent: 1.2182541822530471e-06 seconds\n(1.0006928443908692e-06, 1.2182541822530471e-06)\n```", "```py\nmat1 = np.random.rand(1000,1000)\nargs = [vec1, mat1]\ntimer(*args, operation=np.dot, n=1000000)\n```", "```py\n    Arguments Info\n    --------------\n    args[0] Dimension: 1,\n    args[0] Shape: (1000,),\n    args[0] Length: 1000\n    args[1] Dimension: 2,\n    args[1] Shape: (1000, 1000),\n    args[1] Length: 1000\n    Operation Info\n    --------------\n    Name: dot,\n    Docstring: dot(a, b, out=None)\n    Dot product of two arrays. Specifically,\n    - If both `a` and `b` are 1-D... For more info type 'operation?'\n    Iterations Info\n    ---------------\n    # of iterations: 1000000\n    -> Starting 1000000 of iterations at: 2018-06-09 19:13:07.013949\n    -> Average time spent: 0.00020063393139839174 seconds,\n    -> Std. deviation time spent: 9.579314466482879e-05 seconds\n (0.00020063393139839174, 9.579314466482879e-05)\n```", "```py\nmat1 = np.random.rand(100,100)\nmat2 = np.random.rand(100,100)\nargs = [mat1, mat2]\ntimer(*args, operation=np.dot, n=1000000)\n```", "```py\n## Seed for reproducibility\nnp.random.seed(8053)\ndim = 100\nn = 10000\nv1, v2 = np.array(rand(dim)), np.array(rand(dim))\nm1, m2 = rand(dim, dim), rand(dim, dim)\n## Vector - Vector Product\nargs = [v1, v2]\ntimer(*args, operation=np.dot, n=n)\n## Vector - Matrix Product\nargs = [v1, m1]\ntimer(*args, operation=np.dot, n=n)\n## Matrix - Matrix Product\nargs = [m1, m2]\ntimer(*args, operation=np.dot, n=n)\n## Singular-value Decomposition\nargs = [m1]\ntimer(*args, operation=np.linalg.svd, n=n)\n## LU Decomposition\nargs = [m1]\ntimer(*args, operation=lu, n=n)\n## QR Decomposition\nargs = [m1]\ntimer(*args, operation=qr, n=n)\n## Cholesky Decomposition\nM = np.array([[1, 3, 4],\n[2, 13, 15],\n[5, 31, 33]])\nargs = [M]\ntimer(*args, operation=cholesky, n=n)\n## Eigenvalue Decomposition\nargs = [m1]\ntimer(*args, operation=eig, n=n)\nprint(\"\"\"\nNumPy Configuration:\n--------------------\n\"\"\")\nnp.__config__.show()\n```"]