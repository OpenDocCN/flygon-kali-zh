- en: What’s New In JUnit 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5的新功能
- en: Those who can imagine anything, can create the impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 那些能够想象任何事情的人，可以创造不可能的事情。
- en: '*- Alan Turing*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 艾伦·图灵*'
- en: 'JUnit is the most important testing framework for the JVM and one of the most
    influential in software engineering in general. JUnit 5 is the next generation
    of JUnit, and its first **General Availability** (**GA**) version (5.0.0) was
    released on September 10, 2017. As we will discover, JUnit 5 supposes a small
    revolution with respect to JUnit 4, providing a completely new architecture, programming,
    and extension model. This chapter covers the following content:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是JVM中最重要的测试框架，也是软件工程中最有影响力的框架之一。JUnit 5是JUnit的下一代，其第一个**正式版本**（5.0.0）于2017年9月10日发布。正如我们将了解的那样，JUnit
    5相对于JUnit 4来说是一次小革命，提供了全新的架构、编程和扩展模型。本章内容包括以下内容：
- en: '**Road to JUnit 5**: In the first section, we will discover the motivation
    to create a new major version of JUnit (that is, the limitations of JUnit 4),
    the design principles guiding the development of JUnit 5, and finally the details
    of the JUnit 5 open source community.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通往JUnit 5**：在第一节中，我们将了解创建JUnit的新主要版本的动机（即JUnit 4的限制），指导JUnit 5开发的设计原则，以及JUnit
    5开源社区的详细信息。'
- en: '**JUnit 5 architecture**: JUnit 5 is a modular framework composed of three
    major components, named Platform, Jupiter, and Vintage.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit 5架构**：JUnit 5是一个由三个主要组件组成的模块化框架，分别是Platform、Jupiter和Vintage。'
- en: '**Running tests in JUnit 5**: We will discover how to run JUnit 5 tests using
    popular build tools, such as Maven or Gradle, and also with IDEs such as IntelliJ
    or Eclipse.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在JUnit 5中运行测试**：我们将了解如何使用流行的构建工具（如Maven或Gradle）以及IDE（如IntelliJ或Eclipse）运行JUnit
    5测试。'
- en: '**The extension model of JUnit 5**: The extension model allows for third-party
    libraries and frameworks to extend the JUnit 5 programming model with their own
    additions.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit 5的扩展模型**：扩展模型允许第三方库和框架通过它们自己的添加来扩展JUnit 5的编程模型。'
- en: Road to JUnit 5
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通往JUnit 5
- en: Software testing has changed a lot since the first release of JUnit 4 in 2006\.
    Since then, not only have Java and the JVM has evolved, but also our testing needs
    matured. We are not writing just unit tests anymore. Instead, in addition to verifying
    a single piece of code, software engineers and testers demand other kinds of tests,
    such as integration and end-to-end tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自2006年JUnit 4首次发布以来，软件测试发生了很大变化。自那时起，不仅Java和JVM发生了变化，我们的测试需求也变得更加成熟。我们不再只编写单元测试。除了验证单个代码片段外，软件工程师和测试人员还要求其他类型的测试，如集成测试和端到端测试。
- en: In addition, our expectations about testing frameworks have grown. Nowadays,
    we demand advanced capabilities for these frameworks, such as extensibility or
    modularity, to name a few. In this section, we discover the main limitations of
    JUnit 4, the vision of JUnit 5, and the community supporting its development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们对测试框架的期望已经增长。如今，我们要求这些框架具有高级功能，比如可扩展性或模块化等。在本节中，我们将了解JUnit 4的主要限制，JUnit
    5的愿景以及支持其开发的社区。
- en: JUnit 5 motivation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5的动机
- en: According to several studies, JUnit 4 is the most used library for Java projects.
    For instance, *The Top 100 Java libraries on GitHub* is a well-known report published
    by OverOps ([@overopshq](https://twitter.com/overopshq)), a software analytics
    company focused on large-scale Java and Scala code bases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据多项研究，JUnit 4是Java项目中使用最多的库。例如，《GitHub上排名前100的Java库》是OverOps（@overopshq）发布的一份知名报告，OverOps是一家专注于大规模Java和Scala代码库的软件分析公司。
- en: 'In its edition of 2017, this report analyzed the import statements of unique
    Java libraries that are used by the top 1,000 Java projects on GitHub (by stars).
    In the light of the results, JUnit 4 is the undisputed king of Java Libraries:
    the imports of the packages `org.junit` and `org.junit.runner` appear in the first
    and second position, respectively:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年的报告中，分析了GitHub上排名前1000的Java项目（按星级）使用的独特Java库的导入语句。根据结果，JUnit 4是Java库的无可争议的王者：`org.junit`和`org.junit.runner`包的导入分别位列第一和第二。
- en: '![](img/00018.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: The Top 20 Java libraries on GitHub
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上排名前20的Java库
- en: Despite this fact, JUnit 4 is a framework created more than a decade ago, and
    there are important several limitations that impose a complete redesign of the
    framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管事实如此，JUnit 4是十多年前创建的一个框架，存在着一些重要的限制，这些限制要求对框架进行完全重新设计。
- en: Modularity
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: First of all, JUnit 4 is not modular. As depicted in the following picture,
    the architecture of JUnit 4 is completely monolithic. All the capabilities of
    JUnit 4 are provided by the `junit.jar` dependency. As a result, different test
    mechanisms, such as test discovery and execution, are tightly coupled in JUnit
    4.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JUnit 4不是模块化的。如下图所示，JUnit 4的架构完全是单片的。JUnit 4的所有功能都由`junit.jar`依赖提供。因此，JUnit
    4中的不同测试机制，如测试发现和执行，在JUnit 4中是紧密耦合的。
- en: '![](img/00019.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: The JUnit 4 Architecture
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4的架构
- en: 'Johannes Link, one of the JUnit 5 core team members, summarizes this problem
    in an interview for Jax magazine on August 13, 2015 (during the inception of JUnit
    5):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰内斯·林克（Johannes Link）是JUnit 5核心团队成员之一，他在2015年8月13日接受Jax杂志采访时总结了这个问题（在JUnit
    5开始时）：
- en: The success of JUnit as a platform prevents the development of JUnit as a test
    tool. The basic problem we want to solve is executing test cases by separating
    a sufficiently powerful and stable API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit作为一个平台的成功阻碍了它作为测试工具的发展。我们要解决的基本问题是通过分离足够强大和稳定的API来执行测试用例。
- en: JUnit 4 runners
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4运行器
- en: 'The JUnit 4''s runner API also has an important deterrent. As described in
    [chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb), *Retrospective
    on software quality and Java testing*, in JUnit 4 a runner is a Java class used
    to manage a test''s life cycle. The runner API in JUnit 4 is quite powerful, nevertheless,
    it has an important drawback: runners are not composable, that is, we can only
    use a single runner at a time.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4的运行器API也有一个重要的威慑作用。正如在[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)中所描述的，“关于软件质量和Java测试的回顾”，在JUnit
    4中，运行器是用于管理测试生命周期的Java类。JUnit 4中的运行器API非常强大，但是有一个重要的缺点：运行器不可组合，也就是说，我们一次只能使用一个运行器。
- en: 'For example, a parameterized test cannot be combined with the Spring test support,
    due to the fact that both tests would use their own runner implementation. Thinking
    in Java (see the snippets given follow), each test case uses its own unique `@RunWith`
    annotation. The first one uses the `Parameterized` runner:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参数化测试无法与Spring测试支持结合使用，因为两个测试都会使用自己的运行器实现。在Java中，每个测试用例都使用自己独特的`@RunWith`注解。第一个使用`Parameterized`运行器。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this second example is using the `SpringJUnit4ClassRunner` runner,  it
    would not be combined with the previous one due to a limitation on JUnit 4 (runners
    are not composable):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个第二个例子使用了`SpringJUnit4ClassRunner`运行器，但由于JUnit 4的限制（运行器不可组合），它不能与前一个例子结合使用：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JUnit 4 rules
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4规则
- en: 'Due to the strict limitation of uniqueness of a JUnit 4 runner within the same
    test class, version 4.7 of JUnit introduced the concept of method-level rules,
    which are annotated fields in a test class with `@Rule`. These rules allow for
    addition or redefinition of test behavior by executing some code before and after
    the execution of the test. JUnit 4.9 also incorporates the concept of class-level
    rules, which are rules that are executed before and after all tests within the
    class. These rules are identified by annotating static fields with `@ClassRule`,
    as shown in the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JUnit 4中对同一测试类中JUnit 4运行器的唯一性的严格限制，JUnit的4.7版本引入了方法级规则的概念，这些规则是测试类中带有`@Rule`注解的字段。这些规则允许通过在执行测试之前和之后执行一些代码来添加或重新定义测试行为。JUnit
    4.9还包括类级别规则的概念，这些规则是在类中的所有测试之前和之后执行的规则。通过使用`@ClassRule`注解静态字段来标识这些规则，如下例所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While rules are simpler and mostly compostable, they have other drawbacks. The
    main inconvenience when using JUnit 4 rules for complex tests is that we are not
    able to use a single rule entity for method-level and class-level. At the end
    of the day, this imposes limitations to customize the life cycle management (the
    before/after behavior).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然规则更简单且大多可组合，但它们也有其他缺点。在使用JUnit 4规则进行复杂测试时的主要不便之处在于，我们无法使用单个规则实体来进行方法级和类级的测试。归根结底，这对自定义生命周期管理（在之前/之后的行为）施加了限制。
- en: JUnit 5 inception
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5的开始
- en: 'Even though JUnit 4 was the default testing framework for millions of Java
    developers worldwide, none of the active JUnit maintainers were paid by their
    employer to do that work. For that reason, and in order to overcome the drawbacks
    of JUnit 4, in July 2015 Johannes Link and Marc Philipp started the JUnit Lambda
    crowdfunding campaign ([http://junit.org/junit4/junit-lambda-campaign.html](http://junit.org/junit4/junit-lambda-campaign.html))
    on Indiegogo (an international crowdfunding website):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JUnit 4是全球数百万Java开发人员的默认测试框架，但没有一位活跃的JUnit维护者受雇于其雇主从事这项工作。因此，为了克服JUnit 4的缺点，Johannes
    Link和Marc Philipp于2015年7月在Indiegogo（国际众筹网站）上启动了JUnit Lambda众筹活动（[http://junit.org/junit4/junit-lambda-campaign.html](http://junit.org/junit4/junit-lambda-campaign.html)）：
- en: '![](img/00020.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: JUnit Lambda Crowdfunding Campaign
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Lambda众筹活动
- en: 'JUnit Lambda was the name given to the project, which was the seed of the current
    JUnit 5 framework. The inclusion of the word lambda in the project name enforces
    the idea of using Java 8 from the very beginning of the project. Quoting the JUnit
    Lambda project site:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Lambda是该项目的名称，它是当前JUnit 5框架的种子。在项目名称中加入lambda一词强调了从项目一开始就使用Java 8的想法。引用JUnit
    Lambda项目网站：
- en: The goal is to create an up-to-date foundation for developer-side testing on
    the JVM. This includes focusing on Java 8 and above, as well as enabling many
    different styles of testing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是在JVM上为开发人员测试创建一个最新的基础。这包括专注于Java 8及以上，以及启用许多不同的测试风格。
- en: The JUnit Lambda Crowdfunding Campaign ran from July to October 2015\. It was
    a success, raising 53,937 euros from 474 individuals and companies worldwide.
    From this point, the JUnit 5 kick-off team was created, joining people from Eclipse,
    Gradle, IntelliJ, or Spring.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Lambda众筹活动从2015年7月持续到10月。这是一个成功的活动，从全球474个个人和公司筹集了53,937欧元。从这一点开始，JUnit
    5的启动团队成立了，加入了来自Eclipse、Gradle、IntelliJ或Spring的人员。
- en: 'The JUnit Lambda project became JUnit 5, and the design principles guiding
    the development process were the follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Lambda项目成为JUnit 5，并且指导开发过程的设计原则如下：
- en: 'Modularization: As introduced before, JUnit 4 was not modular, and this causes
    some problems. From its inception, JUnit 5 architecture is much completely modular,
    allowing developers to use the specific parts of the framework they require.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化：如前所述，JUnit 4不是模块化的，这会导致一些问题。从一开始，JUnit 5的架构就是完全模块化的，允许开发人员使用他们需要的框架的特定部分。
- en: 'Powerful extension model with focus on composability: Extensibility is a must
    for modern testing frameworks. Therefore, JUnit 5 should provide seamless integration
    with third-party frameworks, such as Spring or Mockito, to name a few.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有重点在可组合性上的强大扩展模型：可扩展性对于现代测试框架是必不可少的。因此，JUnit 5应该提供与第三方框架（如Spring或Mockito等）的无缝集成。
- en: 'API segregation: Decouple test discovery and execution from test definition.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API分离：将测试发现和执行与测试定义分离。
- en: 'Compatibility with older releases: Supporting the execution of legacy Java
    3 and Java 4 in the new JUnit 5 platform.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与旧版本的兼容性：支持在新的JUnit 5平台中执行旧版Java 3和Java 4。
- en: 'Modern programming model for writing tests (Java 8): Nowadays, more and more
    developers write code with Java 8 new features, such as lambda expressions. JUnit
    4 was built on Java 5, but JUnit 5 has been created from scratch using Java 8.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写测试的现代编程模型（Java 8）：如今，越来越多的开发人员使用Java 8的新功能编写代码，如lambda表达式。JUnit 4是基于Java
    5构建的，但JUnit 5是使用Java 8从头开始创建的。
- en: JUnit 5 community
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5社区
- en: The source code of JUnit 5 is hosted on GitHub ([https://github.com/junit-team/junit5](https://github.com/junit-team/junit5)).
    All modules of the JUnit 5 framework have been released under the terms of the
    open source license EPL v1.0\. There is one exception to this rule, since the
    module called `junit-platform-surefire-provider` (described later) has been released
    using Apache License v2.0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的源代码托管在GitHub上（[https://github.com/junit-team/junit5](https://github.com/junit-team/junit5)）。JUnit
    5框架的所有模块都已根据开源许可证EPL v1.0发布。有一个例外，即名为`junit-platform-surefire-provider`的模块（稍后描述）已使用Apache
    License v2.0发布。
- en: 'The roadmap of the JUnit development ([https://github.com/junit-team/junit5/wiki/Roadmap](https://github.com/junit-team/junit5/wiki/Roadmap))
    and the definition and status of the different releases and milestones ([https://github.com/junit-team/junit5/milestones/](https://github.com/junit-team/junit5/milestones/))
    are public on GitHub. The following table summarizes this roadmap:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit开发路线图（[https://github.com/junit-team/junit5/wiki/Roadmap](https://github.com/junit-team/junit5/wiki/Roadmap)）以及不同发布和里程碑的定义和状态（[https://github.com/junit-team/junit5/milestones/](https://github.com/junit-team/junit5/milestones/)）在GitHub上是公开的。以下表格总结了这个路线图：
- en: '| Phase | Date | Release |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 日期 | 发布 |'
- en: '| 0\. Crowdfunding | From July 2015 to October 2015 | - |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 0. 众筹 | 2015年7月至2015年10月| - |'
- en: '| 1\. Kick off | From October 20 to 22, 2015 | - |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 1. 启动 | 2015年10月20日至22日| - |'
- en: '| 2\. First prototype | From October 23, 2015 to the end of November 2015 |
    - |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 2. 第一个原型 | 2015年10月23日至2015年11月底| - |'
- en: '| 3\. Alpha version | February 1, 2016 | 5.0 Alpha |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 3. Alpha版本 | 2016年2月1日| 5.0 Alpha |'
- en: '| 4. First milestone | July 9, 2016 | 5.0 M1: Stable, documented IDE-facing
    APIs (Launcher API and Engine SPI), dynamic tests |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 4. **第一个里程碑** | 2016年7月9日| 5.0 M1：稳定的、有文档的面向IDE的API（启动器API和引擎SPI），动态测试 |'
- en: '| 5. Additional milestones | July 23, 2016 (5.0 M2)November 30, 2016 (5.0 M3)April
    1, 2017 (5.0 M4)July 5, 2017 (5.0 M5)July 16, 2017 (5.0 M6) | 5.0 M2: Bugfix and
    minor improvement release5.0 M3: JUnit 4 interoperability, additional discovery
    selectors5.0 M4: Test templates, repeated tests, and parameterized tests5.0 M5:
    Dynamic containers and minor API changes5.0 M6: Java 9 compatibility, scenario
    tests, additional extension APIs for JUnit Jupiter |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 5. **额外的里程碑** | 2016年7月23日（5.0 M2）2016年11月30日（5.0 M3）2017年4月1日（5.0 M4）2017年7月5日（5.0
    M5）2017年7月16日（5.0 M6）| 5.0 M2：错误修复和小的改进发布5.0 M3：JUnit 4互操作性，额外的发现选择器5.0 M4：测试模板，重复测试和参数化测试5.0
    M5：动态容器和小的API更改5.0 M6：Java 9兼容性，场景测试，JUnit Jupiter的额外扩展API |'
- en: '| 6. **Release candidate** (**RC**) | July 30, 2017July 30, 2017August 23, 2017
    | 5.0 RC1: Final bug fixes and documentation improvements5.0 RC2: Fix Gradle consumption
    of *junit-jupiter-engine*5.0 RC3: Configuration parameters and bug fixes |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 6. **发布候选**（**RC**）| 2017年7月30日2017年7月30日2017年8月23日| 5.0 RC1：最终错误修复和文档改进5.0
    RC2：修复Gradle对*junit-jupiter-engine*的使用5.0 RC3：配置参数和错误修复 |'
- en: '| 7. **General availability** (**GA**) | September 10, 2017 | 5.0 GA: First
    stable release |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 7. **正式发布**（**GA**）| 2017年9月10日| 5.0 GA：第一个稳定版本发布|'
- en: 'The JUnit 5 contributors are more than just developers. Contributors are also
    testers, maintainers, and communicators. At the time of writing, the top JUnit
    5 contributors on GitHub are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的贡献者不仅仅是开发人员。贡献者还是测试人员、维护者和沟通者。在撰写本文时，GitHub上最多的JUnit 5贡献者是：
- en: 'Sam Brannen ([@sam_brannen](https://twitter.com/sam_brannen)): Core Spring
    Framework and JUnit 5 committer. Enterprise Java Consultant at Swiftmind. Spring
    & JUnit trainer. Conference speaker.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sam Brannen（[@sam_brannen](https://twitter.com/sam_brannen)）：Spring Framework和JUnit
    5的核心贡献者。Swiftmind的企业Java顾问。Spring和JUnit培训师。会议发言人。
- en: 'Marc Philipp ([@marcphilipp](https://twitter.com/marcphilipp)): Senior Software
    Engineer on LogMeIn, active contributor to open source projects such as JUnit
    or Usus. Conference speaker.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Marc Philipp（[@marcphilipp](https://twitter.com/marcphilipp)）：LogMeIn的高级软件工程师，JUnit或Usus等开源项目的活跃贡献者。会议发言人。
- en: 'Johannes Link ([@johanneslink](https://twitter.com/johanneslink)): Programmer
    and software therapist. JUnit 5 supporter.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Johannes Link（[@johanneslink](https://twitter.com/johanneslink)）：程序员和软件治疗师。JUnit
    5支持者。
- en: 'Matthias Merdes: Lead Developer at Heidelberg Mobil GmbH, Germany.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matthias Merdes：德国海德堡移动有限公司的首席开发人员。
- en: '![](img/00021.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: Top JUnit 5 contributors on GitHub
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上最多的JUnit 5贡献者
- en: 'The following list provides a collection of online JUnit 5 resources:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了一些在线JUnit 5资源：
- en: Official website ([http://junit.org/junit5/](https://twitter.com/hashtag/JUnit5)).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方网站（[http://junit.org/junit5/](https://twitter.com/hashtag/JUnit5)）。
- en: Source code ([https://github.com/junit-team/junit5/](https://github.com/junit-team/junit5/)).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码（[https://github.com/junit-team/junit5/](https://github.com/junit-team/junit5/)）。
- en: JUnit 5 developer guide ([http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)).
    Reference documentation.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5开发者指南（[http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)）。参考文档。
- en: Twitter of the JUnit team ([https://twitter.com/junitteam](https://twitter.com/junitteam)).
    Usually, the tweets about JUnit 5 are tagged with `#JUnit5` ([https://twitter.com/hashtag/JUnit5](https://twitter.com/hashtag/JUnit5)).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit团队的Twitter（[https://twitter.com/junitteam](https://twitter.com/junitteam)）。通常，关于JUnit
    5的推文都标有`#JUnit5`（[https://twitter.com/hashtag/JUnit5](https://twitter.com/hashtag/JUnit5)）。
- en: Issues ([https://github.com/junit-team/junit5/issues](https://github.com/junit-team/junit5/issues)).
    Problems or suggestions for additional functionality on GitHub.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题（[https://github.com/junit-team/junit5/issues](https://github.com/junit-team/junit5/issues)）。GitHub上的问题或对额外功能的建议。
- en: Questions on Stack Overflow ([https://stackoverflow.com/questions/tagged/junit5](https://stackoverflow.com/questions/tagged/junit5)).
    Stack Overflow is a popular question-and-answer website for computer programming.
    The tag `junit5` should be used to ask questions about JUnit 5.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stack Overflow上的问题（[https://stackoverflow.com/questions/tagged/junit5](https://stackoverflow.com/questions/tagged/junit5)）。Stack
    Overflow是一个流行的计算机编程问答网站。标签`junit5`应该用于询问关于JUnit 5的问题。
- en: JUnit 5 JavaDoc ([http://junit.org/junit5/docs/current/api/](http://junit.org/junit5/docs/current/api/)).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5 JavaDoc（[http://junit.org/junit5/docs/current/api/](http://junit.org/junit5/docs/current/api/)）。
- en: JUnit 5 Gitter ([https://gitter.im/junit-team/junit5](https://gitter.im/junit-team/junit5)),
    an instant messaging and chat room system used to discuss directly with the JUnit
    5 team members and other practitioners.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5 Gitter（[https://gitter.im/junit-team/junit5](https://gitter.im/junit-team/junit5)），这是一个即时通讯和聊天室系统，用于与JUnit
    5团队成员和其他从业者直接讨论。
- en: Open Test Alliance for the JVM ([https://github.com/ota4j-team/opentest4j](https://github.com/ota4j-team/opentest4j)). It
    is an initiative started by the JUnit 5 team, and its objective is to provide
    a minimal common foundation for testing libraries (JUnit, TestNG, Spock, and so
    on) and third-party assertion libraries (Hamcrest, AssertJ, and so on) on the
    JVM. The idea is to use a common set of exceptions that IDEs and build tools can
    support in a consistent manner across all testing scenarios (so far there is no
    standard for testing on the JVM, and the only common building block is the Java
    exception `java.lang.AssertionError`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM的开放测试联盟（[https://github.com/ota4j-team/opentest4j](https://github.com/ota4j-team/opentest4j)）。这是JUnit
    5团队发起的一个倡议，其目标是为JVM上的测试库（JUnit、TestNG、Spock等）和第三方断言库（Hamcrest、AssertJ等）提供一个最小的共同基础。其想法是使用一组通用的异常，以便IDE和构建工具可以在所有测试场景中以一致的方式支持（到目前为止，JVM上还没有测试的标准，唯一的共同构建块是Java异常`java.lang.AssertionError`）。
- en: JUnit 5 architecture
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5架构
- en: The JUnit 5 framework has been designed to be consumed by different programmatic
    clients. The first group of clients are Java tests. These tests can be based on
    JUnit 4 (tests which use the test legacy programming model), JUnit 5 (tests which
    use the brand new programming model), and even other kinds of Java tests (third
    party). The second group of clients are build tools (such as Maven or Gradle)
    and IDEs (such as IntelliJ or Eclipse).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5框架已经被设计为可以被不同的编程客户端消费。第一组客户端是Java测试。这些测试可以基于JUnit 4（使用旧的测试编程模型的测试）、JUnit
    5（使用全新的编程模型的测试）甚至其他类型的Java测试（第三方）。第二组客户端是构建工具（如Maven或Gradle）和IDE（如IntelliJ或Eclipse）。
- en: 'In order to achieve the integration of all these pieces in a loosely coupled
    manner, JUnit 5 was designed to be modular. As depicted in the following picture,
    the JUnit 5 framework is composed of three major components, called Platform,
    Jupiter*,* and Vintage:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以松散耦合的方式实现所有这些部分的集成，JUnit 5被设计为模块化的。如下图所示，JUnit 5框架由三个主要组件组成，称为Platform、Jupiter和Vintage：
- en: '![](img/00022.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'JUnit 5 Architecture: high-level component'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5架构：高级组件
- en: 'The high-level components of the JUnit 5 architecture are enumerated as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5架构的高级组件列举如下：
- en: The first high-level component is called *Jupiter*. It provides the brand-new
    programming and extension model of the JUnit 5 framework.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个高级组件称为*Jupiter*。它提供了JUnit 5框架全新的编程和扩展模型。
- en: In the core of JUnit 5, we find the JUnit *Platform*. This component is aimed
    to become the foundation for any testing framework executed in the JVM. In other
    words, it provides mechanisms to run Jupiter tests, legacy JUnit 4, and also third-party
    tests (for example, Spock, FitNesse, and so on).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JUnit 5的核心中，我们找到了JUnit *Platform*。这个组件旨在成为JVM中执行任何测试框架的基础。换句话说，它提供了运行Jupiter测试、传统的JUnit
    4以及第三方测试（例如Spock、FitNesse等）的机制。
- en: The last high-level component of the JUnit 5 architecture is called *Vintage*.
    This component allows running legacy JUnit tests on the JUnit Platform out of
    the box.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5架构的最后一个高级组件称为*Vintage*。该组件允许在JUnit平台上直接运行传统的JUnit测试。
- en: 'Let''s take a closer look at the details of each component to find out their
    internal modules:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地查看每个组件的细节，以了解它们的内部模块：
- en: '![](img/00023.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'JUnit 5 Architecture: modules'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5架构：模块
- en: 'As can be seen in the picture preceding, there are three types of module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有三种类型的模块：
- en: '**Test APIs**: These are the modules facing users (that is, software engineer
    and testers). These modules provide the programming model for a particular Test
    Engine (for example, `junit-jupiter-api` for JUnit 5 tests and `junit` for JUnit
    4 tests).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试API**：这些是面向用户（即软件工程师和测试人员）的模块。这些模块为特定的测试引擎提供了编程模型（例如，`junit-jupiter-api`用于JUnit
    5测试，`junit`用于JUnit 4测试）。'
- en: '**Test Engines**: These modules allow to execute a kind of test (Jupiter tests,
    legacy JUnit 4, or other Java tests) within the JUnit Platform. They are created
    by extending the general *Platform Engine* (`junit-platform-engine`).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试引擎**：这些模块允许在JUnit平台内执行一种测试（Jupiter测试、传统的JUnit 4或其他Java测试）。它们是通过扩展通用的*Platform
    Engine*（`junit-platform-engine`）创建的。'
- en: '**Test Launcher**:These modules provide the ability of test discovery inside
    the JUnit platform for external build tools and IDEs. This API is consumed by
    tools such as Maven, Gradle, IntelliJ, and so on, using the `junit-platform-launcher`
    module.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试启动器**：这些模块为外部构建工具和IDE提供了在JUnit平台内进行测试发现的能力。这个API被工具如Maven、Gradle、IntelliJ等所使用，使用`junit-platform-launcher`模块。'
- en: 'As a result of this modular architecture, the JUnit framework exposes a set
    of interfaces:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模块化架构，JUnit框架暴露了一组接口：
- en: An **API** (**Application Programming Interface**) to write tests, the *Jupiter
    API*. The detailed description of this API is what it is known as the Jupiter
    programming model and it is described in detail in chapters 3, *JUnit 5 Standard
    Tests* and [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb),
    *Simplifying Testing With Advanced JUnit Features* of this book.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**（**应用程序编程接口**）用于编写测试，*Jupiter API*。这个API的详细描述就是所谓的Jupiter编程模型，它在本书的第3章*JUnit
    5标准测试*和[第4章](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb)*使用高级JUnit功能简化测试*中有详细描述。'
- en: An **SPI** (**Service Provider Interface**) to discover and execute tests, the
    *Engine SPI*. This SPI is typically extended by test engines, which in the end
    provide the programming models to write tests.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SPI**（**服务提供者接口**）用于发现和执行测试，*Engine SPI*。这个SPI通常由测试引擎扩展，最终提供编写测试的编程模型。'
- en: An API for test discovery and execution, the *Launcher API*. This API is typically
    consumed by programmatic clients, that are IDEs and build tools.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试发现和执行的API，*Launcher API*。这个API通常由编程客户端（IDE和构建工具）消耗。
- en: API and SPI are both a sets of assets (typically classes and interfaces) used
    by software engineers for a given purpose. The difference is that API is *called*
    while SPI is *extended*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: API和SPI都是软件工程师用于特定目的的一组资产（通常是类和接口）。不同之处在于API是*调用*，而SPI是*扩展*。
- en: Test Engine SPI
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试引擎SPI
- en: 'The Test Engine SPI allows for creating test executors on top of the JVM. In
    the JUnit 5 framework, there are two Test Engine implementations out of the box:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试引擎SPI允许在JVM之上创建测试执行器。在JUnit 5框架中，有两个测试引擎实现：
- en: 'The `junit-vintage-engine`: This allows running JUnit 3 and 4 tests in the
    JUnit platform.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-vintage-engine`：这允许在JUnit平台中运行JUnit 3和4的测试。'
- en: 'The `junit-jupiter-engine`: This allows running JUnit 5 tests in the JUnit
    platform.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-jupiter-engine`：这允许在JUnit平台中运行JUnit 5的测试。'
- en: 'Moreover, third-party test libraries (for example, Spock, TestNG, and so on)
    can plug into the JUnit Platform by providing a custom Test Engine. To do that, these
    frameworks should create its own Test Engine by extending the JUnit 5 interface `org.junit.platform.engine.TestEngine`.
    In order to extend this interface, three mandatory methods must be overridden:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第三方测试库（例如Spock、TestNG等）可以通过提供自定义测试引擎来插入JUnit平台。为此，这些框架应该通过扩展JUnit 5接口`org.junit.platform.engine.TestEngine`来创建自己的测试引擎。为了扩展这个接口，必须重写三个强制性方法：
- en: '`getId`: The unique identifier for the test engine.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId`：测试引擎的唯一标识符。'
- en: '`discover`: The logic to find and filter the test(s).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discover`：查找和过滤测试的逻辑。'
- en: '`execute`: The logic to run the previously found test(s).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`：运行先前找到的测试的逻辑。'
- en: 'The following example provides the skeleton for a custom Test Engine:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了自定义测试引擎的框架：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A list of existing Test Engines (for example, Specsy, Spek, and others) is maintained
    by the community in the wiki located in the GitHub site of the JUnit 5 team: [https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 社区在JUnit 5团队的GitHub网站上的维基中维护了一份现有测试引擎的列表（例如Specsy、Spek等）：[https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions)。
- en: Test Launcher API
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试启动器API
- en: One of the goals of JUnit 5 is to make the interface between JUnit and its programmatic
    clients (build tools and IDEs) more powerful and stable. To that aim, the Test
    Launcher API has been implemented. This API is used by IDEs and build tools for
    discovering, filtering, and executing tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的目标之一是使JUnit与其编程客户端（构建工具和IDE）之间的接口更加强大和稳定。为此目的，已经实现了测试启动器API。这个API被IDE和构建工具用于发现、过滤和执行测试。
- en: 'Looking closer at the details of this API, we find the class `LauncherDiscoveryRequest`,
    which exposes a fluent API to select the location of tests (for example classes,
    methods, or packages). This group of tests can be filtered, for example, using
    a match pattern:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看此API的细节，我们会发现`LauncherDiscoveryRequest`类，它公开了一个流畅的API，用于选择测试的位置（例如类、方法或包）。这组测试可以进行过滤，例如使用匹配模式：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, the resulting test suite can be executed using the class `TestExecutionListener`.
    This class can be also used to get feedback and receive events:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以使用`TestExecutionListener`类执行生成的测试套件。这个类也可以用于获取反馈和接收事件：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running tests in JUnit 5
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JUnit 5中运行测试
- en: 'At the time of writing, Jupiter tests can be executed in several ways:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jupiter测试可以通过多种方式执行：
- en: '**Using a build tool**: Maven (implemented in the module `junit-plaform-surefire-provider`)
    or Gradle (implemented in the module `junit-platform-gradle-plugin`).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用构建工具**：Maven（在模块`junit-plaform-surefire-provider`中实现）或Gradle（在模块`junit-platform-gradle-plugin`中实现）。'
- en: '**Using the Console Launcher**: A command-line Java application that allows
    to launch the JUnit Platform from the console.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用控制台启动器**：一个命令行Java应用程序，允许从控制台启动JUnit平台。'
- en: '**Using an IDE**: IntelliJ (since version 2016.2) and Eclipse (since version
    4.7, Oxygen).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用IDE**：IntelliJ（自2016.2版）和Eclipse（自4.7版，Oxygen）。'
- en: 'As we are going to discover, and due to the modular architecture of JUnit 5,
    we need to include three dependencies in our projects: one for the Test API (to
    implement tests), an other for the Test Engine (to run tests), and the last one
    of the Test Launcher (to discover tests).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要发现，并且由于JUnit 5的模块化架构，我们需要在我们的项目中包含三个依赖项：一个用于测试API（实现测试），另一个用于测试引擎（运行测试），最后一个用于测试启动器（发现测试）。
- en: Jupiter tests with Maven
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven进行Jupiter测试
- en: 'In order to run Jupiter tests within a Maven project, we need to configure
    the `pom.xml` file properly. First of all, we need to include the `junit-jupiter-api`
    module as a dependency. This is needed to write our test, and typically with test
    scope:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Maven项目中运行Jupiter测试，我们需要正确配置`pom.xml`文件。首先，我们需要将`junit-jupiter-api`模块作为依赖项包含进去。这是为了编写我们的测试，通常使用测试范围：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, it is recommended to use the latest version of the dependencies.
    In order to check what it that version, we can check it on Maven Central ([http://search.maven.org/](http://search.maven.org/))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，建议使用最新版本的依赖项。为了检查该版本，我们可以在Maven中央仓库（[http://search.maven.org/](http://search.maven.org/)）上进行检查。
- en: 'Then, the `maven-surefire-plugin` has to be declared. Internally, this plugin
    needs two dependencies: the Test Launcher (`junit-platform-surefire-provider`)
    and the Test Engine (`junit-jupiter-engine`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须声明`maven-surefire-plugin`。在内部，此插件需要两个依赖项：测试启动器（`junit-platform-surefire-provider`）和测试引擎（`junit-jupiter-engine`）：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All the source code of this book is publicly available on the GitHub repository
    at [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有源代码都可以在GitHub存储库[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)上公开获取。
- en: 'Last but not least, we need to create a Jupiter test case. So far, we have
    not learned how to implement Jupiter tests (this part is covered in [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb),
    JUnit 5 Standard Tests). Nevertheless, the test we execute here is the simplest
    test to demonstrate the execution of the JUnit 5 framework. A Jupiter test, in
    its minimal expression, is just a Java class in which one (or more) of its methods
    are annotated with `@Test` (package `org.junit.jupiter.api`). The following snippet
    provides an example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要创建一个Jupiter测试用例。到目前为止，我们还没有学习如何实现Jupiter测试（这部分在[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)中有介绍，JUnit
    5标准测试）。然而，我们在这里执行的测试是演示JUnit 5框架执行的最简单的测试。Jupiter测试在其最小表达形式中只是一个Java类，其中的一个（或多个）方法被注释为`@Test`（包`org.junit.jupiter.api`）。以下代码段提供了一个示例：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JUnit requires Java 8 (or higher) at runtime. However, we can still test code
    that has been compiled with previous versions of Java.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit在运行时需要Java 8（或更高版本）。但是，我们仍然可以测试使用先前版本的Java编译的代码。
- en: 'As shown in the following picture, this test can be executed using the command
    `mvn test`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，可以使用命令`mvn test`执行此测试：
- en: '![](img/00024.gif)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00024.gif)
- en: Running Jupiter tests with Maven
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven运行Jupiter测试
- en: Jupiter tests with Gradle
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle运行Jupiter测试
- en: 'Now, we are going to study the same example, but this time executed with Gradle.
    Therefore, we need to configure the `build.gradle` file. In this file, we need
    to define:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将研究相同的示例，但这次使用Gradle执行。因此，我们需要配置`build.gradle`文件。在此文件中，我们需要定义：
- en: The dependency for the Jupiter API (`junit-jupiter-api`).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupiter API的依赖项（`junit-jupiter-api`）。
- en: The dependency for the Test Engine (`junit-jupiter-engine`).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试引擎的依赖项（`junit-jupiter-engine`）。
- en: The plugin for the Test Launcher (`junit-platform-gradle-plugin`).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试启动器的插件（`junit-platform-gradle-plugin`）。
- en: 'The complete source of `build.gradle` is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.gradle`的完整源代码如下：'
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the command `gradle test` to run our Jupiter test from the command line
    with Gradle:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令`gradle test`来从命令行使用Gradle运行我们的Jupiter测试：
- en: '![](img/00025.gif)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00025.gif)
- en: Running Jupiter tests with Gradle
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle运行Jupiter测试
- en: Legacy tests with Maven
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven运行传统测试
- en: 'The following is the image we want to run the  legacy test (JUnit 4 in this
    case) inside the JUnit Plaform:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们想要在JUnit平台内运行传统测试（在本例中为JUnit 4）的图像：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To that aim, in Maven, we first need to include the old JUnit 4 dependency
    in our `pom.xml`, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在Maven中，我们首先需要在`pom.xml`中包含旧的JUnit 4依赖项，如下所示：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we need to include `maven-surefire-plugin`, using the following dependencies
    for the plugin: the Test Engine (`junit-vintage-engine`) and the Test Launcher
    (`junit-platform-surefire-provider`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要包含`maven-surefire-plugin`，使用以下插件的依赖项：测试引擎（`junit-vintage-engine`）和测试启动器（`junit-platform-surefire-provider`）：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The execution from the command line will also be using the command `mvn test`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行也将使用命令`mvn test`：
- en: '![](img/00026.gif)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00026.gif)
- en: Running Legacy tests with Maven
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven运行传统测试
- en: Legacy tests wih Gradle
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle运行传统测试
- en: 'If we want to execute the same test presented in the example before (`io.github.bonigarcia.LegacyJUnit4Test`),
    but this time using Gradle, we need to include the following in our `build.gradle`
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要执行之前示例中提到的相同测试（`io.github.bonigarcia.LegacyJUnit4Test`），但这次使用Gradle，我们需要在`build.gradle`文件中包含以下内容：
- en: The dependency for JUnit 4.12.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 4.12的依赖项。
- en: The dependency for the Test Engine (`junit-vintage-engine`).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试引擎的依赖项（`junit-vintage-engine`）。
- en: The plugin for the Test Launcher (`junit-platform-gradle-plugin`).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试启动器的插件（`junit-platform-gradle-plugin`）。
- en: 'Thus, the complete source of `build.gradle` would be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“build.gradle”的完整源代码如下：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The execution from the command line would be as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行如下：
- en: '![](img/00027.gif)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.gif)'
- en: Running Legacy tests with Gradle
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle运行传统测试
- en: The ConsoleLauncher
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台启动器
- en: The `ConsoleLauncher` is a command-line Java application that allows launching
    the JUnit Platform from the console. For example, it can be used to run Vintage
    and Jupiter tests from the command line.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleLauncher`是一个命令行Java应用程序，允许从控制台启动JUnit平台。例如，它可以用于从命令行运行Vintage和Jupiter测试。'
- en: 'An executable JAR with all dependencies included is published in the central
    Maven repository under the `junit-platform-console-standalone` artifact. The standalone
    Console Launcher can be executed as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有依赖项的可执行JAR已发布在中央Maven仓库的`junit-platform-console-standalone`工件下。独立的控制台启动器可以如下执行：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example GitHub repository [*junit5-console-launcher*](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-console-launcher) contains
    a simple example for the use of the Console Launcher. As depicted in the following
    picture, a run configuration entry has been created in Eclipse, running the main
    class, `org.junit.platform.console.ConsoleLauncher`. Then, the test class name
    is passed as an argument using the option `--select-class` and the qualified class
    name (in this example, `io.github.bonigarcia.EmptyTest`). After that, we can run
    the application, obtaining the test result in the integrated console of Eclipse:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例GitHub存储库[*junit5-console-launcher*](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-console-launcher)包含了Console
    Launcher的简单示例。如下图所示，在Eclipse中创建了一个运行配置项，运行主类`org.junit.platform.console.ConsoleLauncher`。然后，使用选项`--select-class`和限定类名（在本例中为`io.github.bonigarcia.EmptyTest`）作为参数传递测试类名。之后，我们可以运行应用程序，在Eclipse的集成控制台中获取测试结果：
- en: '![](img/00028.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: Example of ConsoleLauncher in Eclipse
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中使用ConsoleLauncher的示例
- en: Jupiter tests in JUnit 4
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JUnit 4中的Jupiter测试
- en: JUnit 5 has been designed to be forward and backward compatible. On the one
    hand, the Vintage component supports running legacy code on JUnit 3 and 4\. On
    the other hand, JUnit 5 provides a JUnit 4 runner that allows to run JUnit 5 in
    IDEs and build systems that support JUnit 4, but does not yet support the new
    JUnit Platform 5 directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5被设计为向前和向后兼容。一方面，Vintage组件支持在JUnit 3和4上运行旧代码。另一方面，JUnit 5提供了一个JUnit 4运行器，允许在支持JUnit
    4但尚未直接支持新的JUnit Platform 5的IDE和构建系统中运行JUnit 5。
- en: 'Let''s see one example. Imagine we want to run a Jupiter test in an IDE does
    not support JUnit 5, for example, an old version of Eclipse. In this case, we
    need to annotate our Jupiter test with `@RunWith(JUnitPlatform.class)`. The `JUnitPlatform`
    runner is a JUnit 4-based runner, which enables to run any test whose programming
    model is supported on the JUnit Platform in a JUnit 4 environment. Therefore,
    our test would result as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设我们想在不支持JUnit 5的IDE中运行Jupiter测试，例如，一个旧版本的Eclipse。在这种情况下，我们需要用`@RunWith(JUnitPlatform.class)`注解我们的Jupiter测试。`JUnitPlatform`运行器是一个基于JUnit
    4的运行器，它可以在JUnit 4环境中运行任何编程模型受支持的测试。因此，我们的测试结果如下：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If this test is contained in a Maven project, our `pom.xml` should contain
    the following dependencies:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个测试包含在一个Maven项目中，我们的`pom.xml`应该包含以下依赖项：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the other hand, for a Gradle project, our `build.gradle` is the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于Gradle项目，我们的`build.gradle`如下：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: IntelliJ
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntelliJ
- en: 'IntelliJ 2016.2+ has been the first IDE which supports the execution of Jupiter
    tests natively. As shown in the following screenshot, any Jupiter test can be
    executed using the integrated functions of the IDE:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 2016.2+是第一个原生支持执行Jupiter测试的IDE。如下图所示，可以使用IDE的集成功能执行任何Jupiter测试：
- en: '![](img/00029.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Running a Jupiter test in IntelliJ 2016.2+
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ 2016.2+中运行Jupiter测试
- en: Eclipse
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse
- en: 'Eclipse 4.7 (*Oxygen*) has beta support for JUnit 5\. Thanks to this, Eclipse
    provides the ability of running Jupiter tests directly in Eclipse, as shown in
    the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 4.7（*Oxygen*）支持JUnit 5的beta版本。由于这个原因，Eclipse提供了直接在Eclipse中运行Jupiter测试的能力，如下面的截图所示：
- en: '![](img/00030.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Running a Jupiter test in Eclipse 4.7+
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse 4.7+中运行Jupiter测试
- en: 'Moreover, Eclipse 4.7 (*Oxygen*) provides a wizard to create Jupiter tests
    in a simple way, as shown in the following pictures:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Eclipse 4.7（*Oxygen*）提供了一个向导，可以简单地创建Jupiter测试，如下面的图片所示：
- en: '![](img/00031.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: Eclipse wizard to create Jupiter tests
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中创建Jupiter测试的向导
- en: The extension model of JUnit 5
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5的扩展模型
- en: As introduced before, Jupiter is the name given to the new programming model
    of JUnit 5, described in detail in [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit
    5 standard tests* and [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb),
    *Simplifying testing with advanced JUnit features*, together with the extension
    model. The extension model allows to extend the Jupiter programming model with
    custom additions. Thanks to this, third-party frameworks (such as Spring or Mockito,
    to name a few) can achieve interoperability with JUnit 5 in a seamless way. The
    extensions provided by these frameworks will be studied in [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb), *Integration
    of JUnit 5 with external frameworks*. In the current section, we analyze the general
    performance of the extension model and also the extensions provided out of the
    box in JUnit 5.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Jupiter是JUnit 5的新编程模型的名称，详细描述在[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)中，*JUnit
    5标准测试*和[第4章](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb)，*使用高级JUnit功能简化测试*，以及扩展模型。扩展模型允许使用自定义添加扩展Jupiter编程模型。由于这一点，第三方框架（如Spring或Mockito等）可以无缝地与JUnit
    5实现互操作性。这些框架提供的扩展将在[第5章](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)中进行研究，*JUnit
    5与外部框架的集成*。在当前部分，我们分析扩展模型的一般性能以及JUnit 5中提供的扩展。
- en: 'In contrast to former extension points in JUnit 4 (that is, test runners and
    rules), the JUnit 5 extension model consists of a single, coherent concept: the
    **Extension API**. This API allows to extend the core functionality of JUnit 5
    by any third party (tool vendor, developers, and so on). The first thing we need
    to understand about extensions in Jupiter is that each new extension implements
    an interface called `Extension`. This interface is a *marker* interface, that
    is, a Java interface with no field or methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与JUnit 4中以前的扩展点相比（即测试运行器和规则），JUnit 5的扩展模型由一个单一的、连贯的概念组成：**扩展API**。这个API允许任何第三方（工具供应商、开发人员等）扩展JUnit
    5的核心功能。我们需要了解的第一件事是，Jupiter中的每个新扩展都实现了一个名为`Extension`的接口。这个接口是一个*标记*接口，也就是说，它是一个没有字段或方法的Java接口：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to make ease the creation of Jupiter extensions, JUnit 5 provides
    a set of extensions points which allows to execute custom code in different parts
    of the test life cycle. The following table contains a summary of the extension
    points in Jupiter, and its details are presented in the next sections:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Jupiter 扩展的创建，JUnit 5 提供了一组扩展点，允许在测试生命周期的不同部分执行自定义代码。下表包含了 Jupiter 中的扩展点摘要，其详细信息将在下一节中介绍：
- en: '| **Extension point** | **Implemented by extensions which want to…** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **扩展点** | **由想要实现的扩展** |'
- en: '| `TestInstancePostProcessor` | Provide additional behavior just after the
    test instantiation |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `TestInstancePostProcessor` | 在测试实例化后提供额外行为 |'
- en: '| `BeforeAllCallback` | Provide additional behavior before all tests are invoked
    in a test container |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `BeforeAllCallback` | 在测试容器中所有测试被调用之前提供额外行为 |'
- en: '| `BeforeEachCallback` | Provide additional behavior to tests before each test
    is invoked |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `BeforeEachCallback` | 在每个测试被调用前为测试提供额外行为 |'
- en: '| `BeforeTestExecutionCallback` | Provide additional behavior to tests immediately
    before each test is executed |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `BeforeTestExecutionCallback` | 在每个测试执行前立即为测试提供额外行为 |'
- en: '| `TestExecutionExceptionHandler` | Handle exceptions thrown during test execution
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `TestExecutionExceptionHandler` | 处理测试执行期间抛出的异常 |'
- en: '| `AfterAllCallback` | Provide additional behavior to test containers after
    all tests have been invoked |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `AfterAllCallback` | 在所有测试被调用后，为测试容器提供额外行为 |'
- en: '| `AfterEachCallback` | Provide additional behavior to tests after each test
    has been invoked |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `AfterEachCallback` | 在每个测试被调用后为测试提供额外行为 |'
- en: '| `AfterTestExecutionCallback` | Provide additional behavior to tests immediately
    after each test has been executed |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `AfterTestExecutionCallback` | 在每个测试执行后立即为测试提供额外行为 |'
- en: '| `ExecutionCondition` | Conditionate the test execution at runtime |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `ExecutionCondition` | 在运行时条件化测试执行 |'
- en: '| `ParameterResolver` | Resolve parameters at runtime |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `ParameterResolver` | 在运行时解析参数 |'
- en: 'Once we created an extension, in order to use it, we need to use the annotation
    `ExtendWith`. This annotation can be used to register one or more extensions.
    It can be declared on interfaces, classes, methods, fields, and even in other
    annotations:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个扩展，为了使用它，我们需要使用注解 `ExtendWith`。这个注解可以用来注册一个或多个扩展。它可以声明在接口、类、方法、字段，甚至其他注解中：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Test lifecycle
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试生命周期
- en: 'There are a set of extension points aimed at controlling the life cycle of
    tests. First of all, the `TestInstancePostProcessor` can be used to execute some
    logic after the test instantiation. After that, there are different extensions
    which control the pre-test stage:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组旨在控制测试生命周期的扩展点。首先，`TestInstancePostProcessor` 可以用于在测试实例化后执行一些逻辑。之后，有不同的扩展来控制测试前阶段：
- en: The `BeforeAllCallback` defines the logic executed before all tests.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeAllCallback` 在所有测试之前定义要执行的逻辑。'
- en: The `BeforeEachCallback` defines the logic executed before a test method.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeEachCallback` 在测试方法之前定义要执行的逻辑。'
- en: The `BeforeTestExecutionCallback` defines the logic executed immediately before
    a test method.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeTestExecutionCallback` 在测试方法之前定义要执行的逻辑。'
- en: 'Similarly, there are extensions to control the post-test phases:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有控制测试后阶段的扩展：
- en: The `AfterAllCallback` defines the logic executed after all tests.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterAllCallback` 在所有测试之后定义要执行的逻辑。'
- en: The `AfterEachCallback` defines the logic executed after a test method.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterEachCallback` 在测试方法之后定义要执行的逻辑。'
- en: The `AfterTestExecutionCallback` defines the logic executed immediately after
    a test method.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterTestExecutionCallback` 在测试方法之后定义要执行的逻辑。'
- en: 'In between the `Before*` and `After*` callbacks, there is an extension that
    provides a way for collecting exceptions: the `TestExecutionExceptionHandler`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Before*` 和 `After*` 回调之间，有一个提供收集异常的扩展：`TestExecutionExceptionHandler`。
- en: 'All these callbacks, and their order in the test life cycl are depicted in
    the following picture:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些回调及其在测试生命周期中的顺序如下图所示：
- en: '![](img/00032.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: Lifecycle of extension callbacks
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展回调的生命周期
- en: 'Let''s see an example. We created an extension called `IgnoreIOExceptionExtension`,
    which implements `TestExecutionExceptionHandler`. In this example, the extension
    checks whether or not the exception is `IOException`. If so, the exception is
    discarded:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们创建了一个名为 `IgnoreIOExceptionExtension` 的扩展，它实现了 `TestExecutionExceptionHandler`。在这个例子中，扩展检查异常是否是
    `IOException`。如果是，异常就被丢弃：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Consider the following test class, which contains two tests (`@Test`). The
    first one is annotated with `@ExtendWith` and our custom extension (`IgnoreIOExceptionExtension`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试类，其中包含两个测试（`@Test`）。第一个用 `@ExtendWith` 和我们自定义的扩展（`IgnoreIOExceptionExtension`）进行了注释：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When executing this test class, the first test is succeeded due to the fact
    that the `IOException` has been internally handled by our extension. On the other
    hand, the second will fail since that exception is not handled.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这个测试类时，第一个测试成功了，因为 `IOException` 已经被我们的扩展内部处理了。另一方面，第二个测试会失败，因为异常没有被处理。
- en: 'The execution of this test class in the console can be seen in the next screenshot.
    Note that we select the test to be executed using the Maven command `mvn test
    -Dtest=ExceptionTest`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在控制台中看到这个测试类的执行结果。请注意，我们使用 Maven 命令 `mvn test -Dtest=ExceptionTest` 选择要执行的测试：
- en: '![](img/00033.gif)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.gif)'
- en: Output of ignore exception example
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略异常示例的输出
- en: Conditional extension points
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件扩展点
- en: 'In order to create extensions that activate or deactivate tests depending on
    a given condition, JUnit 5 provides one conditional extension point callled `ExecutionCondition`.
    The following snippet shows the declaration of this extension point:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建根据给定条件激活或停用测试的扩展，JUnit 5 提供了一个条件扩展点，称为 `ExecutionCondition`。下面的代码片段显示了这个扩展点的声明：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The extension can be used to deactivate either all tests in a container (likely
    a class) or individual tests (likely a test method). Examples of this extension
    are provided in the section C*onditional Test Execution* of [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit
    5 Standard Tests*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展可以用于停用容器中的所有测试（可能是一个类）或单个测试（可能是一个测试方法）。该扩展的示例在[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)的*C条件测试执行*部分中提供，*JUnit
    5标准测试*。
- en: Dependency injection
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'The `ParameterResolver` extension provides dependency injection at method level.
    In this example, we can see how an argument is injected in the test method with
    a custom implementation of `ParameterResolver` called `MyParameterResolver`. Following
    the code, we can see that this resolver will simply inject hard-coded String parameters
    with the value `my parameter`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParameterResolver`扩展提供了方法级别的依赖注入。在这个例子中，我们可以看到如何使用名为`MyParameterResolver`的`ParameterResolver`的自定义实现来在测试方法中注入参数。在代码后面，我们可以看到这个解析器将简单地注入硬编码的字符串参数，值为`my
    parameter`：'
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, this parameter resolver can be used in a test, declaring it as usual
    using the annotation `@ExtendWith`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个参数解析器可以像往常一样在测试中使用，声明为`@ExtendWith`注解：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, if we execute this test (for example using Maven and the command line),
    we can see how the injected parameter is logged in the standard output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们执行这个测试（例如使用Maven和命令行），我们可以看到注入的参数被记录在标准输出中：
- en: '![](img/00034.gif)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.gif)'
- en: Output of dependency injection extension example
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入扩展示例的输出
- en: Third-party extensions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方扩展
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A list of existing JUnit 5 extensions (for example, Spring, Selenium, Docker,
    and others) is maintained by the community in the wiki located in the GitHub site
    of the JUnit 5 team: [https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions).
    Some of them are also detailed in [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb),
    *Integration of JUnit 5 with external frameworks*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的现有扩展列表（例如Spring，Selenium，Docker等）由社区在JUnit 5团队的GitHub网站的wiki中维护：[https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions)。其中一些也在[第5章](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)中有详细介绍，*JUnit
    5与外部框架的集成*。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provides an overview of the JUnit 5 testing framework. Due to the
    limitations of JUnit 4 (monolithic architecture, impossibility of compose test
    runners, and limitations of test rules), a new major version of the framework
    was needed. In order to carry out the implementations, the JUnit Lambda project
    started a crowdfunding campaign in 2015\. As a result, the JUnit 5 development
    team was born, and the GA release of the framework was released on September 10,
    2017.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了JUnit 5测试框架。由于JUnit 4的限制（单片架构，无法组合测试运行器，以及测试规则的限制），需要一个新的主要版本的框架。为了进行实现，JUnit
    Lambda项目在2015年发起了一场众筹活动。结果，JUnit 5开发团队诞生了，并于2017年9月10日发布了该框架的GA版本。
- en: 'JUnit 5 was designed to be modern (that is, using Java 8 and Java 9 compliant
    from the very beginning) and modular. The three major components within JUnit
    5 are: Jupiter (new programming an extension model), Platform (foundation for
    any testing framework executed in the JVM), and Vintage (integration with legacy
    JUnit 3 and 4 tests). At the time of this writing, JUnit 5 tests can be executed
    using build tools (Maven or Gradle) and also with IDEs (IntelliJ 2016.2+ or Eclipse
    4.7+).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5被设计为现代化（即从一开始就使用Java 8和Java 9兼容），并且是模块化的。JUnit 5内的三个主要组件是：Jupiter（新的编程和扩展模型），Platform（在JVM中执行任何测试框架的基础），以及Vintage（与传统的JUnit
    3和4测试集成）。在撰写本文时，JUnit 5测试可以使用构建工具（Maven或Gradle）以及IDE（IntelliJ 2016.2+或Eclipse
    4.7+）来执行。
- en: The extension model of JUnit 5 allows to extend the core functionality of JUnit
    5 by any third party. In order to create JUnit 5 extensions, we need to implement
    one or several JUnit extension points (such as `BeforeAllCallback`, `ParameterResolver`,
    or `ExecutionCondition`, among others), and then register the extension in our
    tests using the annotation `@ExtendWith`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5的扩展模型允许任何第三方扩展其核心功能。为了创建JUnit 5扩展，我们需要实现一个或多个JUnit扩展点（如`BeforeAllCallback`，`ParameterResolver`或`ExecutionCondition`等），然后使用`@ExtendWith`注解在我们的测试中注册扩展。
- en: In the next [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb),
    *JUnit 5 Standard Tests*, we are going to learn the basics of the Jupiter programming
    model. In other words, we are going to learn how to create standard JUnit 5 tests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)中，*JUnit 5标准测试*，我们将学习Jupiter编程模型的基础知识。换句话说，我们将学习如何创建标准的JUnit
    5测试。
