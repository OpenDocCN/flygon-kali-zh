["```java\napply plugin: 'java'\n\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\nrepositories {\n  mavenCentral()\n}\n\ndependencies {\n  testCompile group: 'junit', name: 'junit', version: '4.12'\n  testCompile group: 'org.assertj', name: 'assertj-core', version: '3.9.0'\n}\n```", "```java\nif (name != null) {\n  // do something with name\n}\n```", "```java\npublic class Student {\n  public final String name;\n  public final int age;\n\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n```", "```java\npublic class StudentRepositoryTest {\n\n  private List<Student> studentList = Arrays.asList(\n    new Student(\"Jane\", 23),\n    new Student(\"John\", 21),\n    new Student(\"Tom\", 25) \n  );\n\n  private StudentRepository studentRepository = \n    new StudentRepository(studentList);\n\n  @Test\n  public void whenStudentIsNotFoundThenReturnEmpty() {\n    assertThat(studentRepository.findByName(\"Samantha\"))\n      .isNotPresent();\n  }\n\n  @Test\n  public void whenStudentIsFoundThenReturnStudent() {\n    assertThat(studentRepository.findByName(\"John\"))\n      .isPresent();\n  }\n}\n```", "```java\n@Test\npublic void whenStudentIsFoundThenReturnStudent() {\n  assertThat(studentRepository.findByName(\"John\"))\n    .hasValueSatisfying(s -> {\n      assertThat(s.name).isEqualTo(\"John\");\n      assertThat(s.age).isEqualTo(21);\n    });\n}\n```", "```java\npublic class StudentRepository {\n  StudentRepository(Collection<Student> students) { }\n\n  public Optional<Student> findByName(String name) {\n    return Optional.empty();\n  }\n}\n```", "```java\njava.lang.AssertionError: \nExpecting Optional to contain a value but was empty.\n```", "```java\npublic class StudentRepository {\n  private final Set<Student> studentSet;\n\n  StudentRepository(Collection<Student> students) {\n    studentSet = new HashSet<>(students);\n  }\n\n  public Optional<Student> findByName(String name) {\n    for (Student student : this.studentSet) {\n      if (student.name.equals(name))\n        return Optional.of(student);\n    }\n    return Optional.empty();\n  }\n}\n```", "```java\npublic Integer add(Integer a, Integer b) {\n  return a + b;\n}\n```", "```java\npublic final BinaryOperator<Integer> add =\n  new BinaryOperator<Integer>() {\n\n    @Override\n    public Integer apply(Integer a, Integer b) {\n      return a + b;\n    }\n  };\n```", "```java\npublic final BinaryOperator<Integer> addLambda = (a, b) -> a + b;\n```", "```java\n3 + 4\n```", "```java\n3 4 +\n```", "```java\npublic class ReversePolishNotation {\n  int compute(String expression) {\n    return 0;\n  }\n}\n\npublic class NotReversePolishNotationError extends RuntimeException {\n  public NotReversePolishNotationError() {\n    super(\"Not a Reverse Polish Notation\");\n  }\n}\n```", "```java\npublic class ReversePolishNotationTest {\n  private ReversePolishNotation reversePolishNotation =\n    new ReversePolishNotation();\n\n  @Test(expected = NotReversePolishNotationError.class)\n  public void emptyInputThrowsError() {\n    reversePolishNotation.compute(\"\");\n  }\n\n  @Test(expected = NotReversePolishNotationError.class)\n  public void notANumberThrowsError() {\n    reversePolishNotation.compute(\"a\");\n  }\n\n  @Test\n  public void oneDigitReturnsNumber() {\n    assertThat(reversePolishNotation.compute(\"7\")).isEqualTo(7);\n  }\n\n  @Test\n  public void moreThanOneDigitReturnsNumber() {\n    assertThat(reversePolishNotation.compute(\"120\")).isEqualTo(120);\n  }\n}\n```", "```java\npublic class ReversePolishNotation {\n  int compute(String expression) {\n    try {\n      return (Integer.parseInt(expression));\n    } catch (NumberFormatException e) {\n      throw new NotReversePolishNotationError();\n    }\n  }\n}\n```", "```java\n@Test\npublic void addOperationReturnsCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"1 2 +\")).isEqualTo(3);\n}\n\n@Test\npublic void subtractOperationReturnsCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"2 1 -\")).isEqualTo(1);\n}\n\n@Test\npublic void multiplyOperationReturnsCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"2 1 *\")).isEqualTo(2);\n}\n\n@Test\npublic void divideOperationReturnsCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"2 2 /\")).isEqualTo(1);\n}\n```", "```java\nint compute(String expression) {\n  String[] elems = expression.trim().split(\" \");\n  if (elems.length != 1 && elems.length != 3)\n    throw new NotReversePolishNotationError();\n  if (elems.length == 1) {\n    return parseInt(elems[0]);\n  } else {\n    if (\"+\".equals(elems[2]))\n      return parseInt(elems[0]) + parseInt(elems[1]);\n    else if (\"-\".equals(elems[2]))\n      return parseInt(elems[0]) - parseInt(elems[1]);\n    else if (\"*\".equals(elems[2]))\n      return parseInt(elems[0]) * parseInt(elems[1]);\n    else if (\"/\".equals(elems[2]))\n      return parseInt(elems[0]) / parseInt(elems[1]);\n    else\n      throw new NotReversePolishNotationError();\n  }\n}\n```", "```java\nprivate int parseInt(String number) {\n  try {\n    return Integer.parseInt(number);\n  } catch (NumberFormatException e) {\n    throw new NotReversePolishNotationError();\n  }\n}\n```", "```java\n@Test\npublic void multipleAddOperationsReturnCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"1 2 5 + +\"))\n    .isEqualTo(8);\n}\n\n@Test\npublic void multipleDifferentOperationsReturnCorrectValue() {\n  assertThat(reversePolishNotation.compute(\"5 12 + 3 -\"))\n    .isEqualTo(14);\n}\n\n@Test\npublic void aComplexTest() {\n  assertThat(reversePolishNotation.compute(\"5 1 2 + 4 * + 3 -\"))\n    .isEqualTo(14);\n}\n```", "```java\nprivate static void applyOperation(\n    Stack<Integer> stack,\n    BinaryOperator<Integer> operation\n) {\n  int b = stack.pop(), a = stack.pop();\n  stack.push(operation.apply(a, b));\n}\n```", "```java\nstatic BinaryOperator<Integer> ADD = (a, b) -> a + b;\nstatic BinaryOperator<Integer> SUBTRACT = (a, b) -> a - b;\nstatic BinaryOperator<Integer> MULTIPLY = (a, b) -> a * b;\nstatic BinaryOperator<Integer> DIVIDE = (a, b) -> a / b;\n```", "```java\nint compute(String expression) {\n  Stack<Integer> stack = new Stack<>();\n  for (String elem : expression.trim().split(\" \")) {\n    if (\"+\".equals(elem))\n      applyOperation(stack, ADD);\n    else if (\"-\".equals(elem))\n      applyOperation(stack, SUBTRACT);\n    else if (\"*\".equals(elem))\n      applyOperation(stack, MULTIPLY);\n    else if (\"/\".equals(elem))\n      applyOperation(stack, DIVIDE);\n    else {\n      stack.push(parseInt(elem));\n    }\n  }\n  if (stack.size() == 1) return stack.pop();\n  else throw new NotReversePolishNotationError();\n}\n```", "```java\n@Test\npublic void filterByNameReturnsCollectionFiltered() {\n  List<String> names = Arrays.asList(\"Alex\", \"Paul\", \"Viktor\",\n         \"Kobe\", \"Tom\", \"Andrea\");\n  List<String> filteredNames = Collections.emptyList();\n\n  assertThat(filteredNames)\n      .hasSize(2)\n      .containsExactlyInAnyOrder(\"Alex\", \"Andrea\");\n}\n```", "```java\nList<String> filteredNames = names.stream()\n      .filter(name -> name.startsWith(\"A\"))\n      .collect(Collectors.toList());\n```", "```java\n@Test\npublic void mapToUppercaseTransformsAllElementsToUppercase() {\n  List<String> names = Arrays.asList(\"Alex\", \"Paul\", \"Viktor\");\n  List<String> namesUppercase = Collections.emptyList();\n\n  assertThat(namesUppercase)\n      .hasSize(3)\n      .containsExactly(\"ALEX\", \"PAUL\", \"VIKTOR\");\n}\n```", "```java\nList<String> namesUppercase = names.stream()\n  .map(String::toUpperCase)\n  .collect(Collectors.toList());\n```", "```java\n@Test\npublic void gettingLettersUsedInNames() {\n  List<String> names = Arrays.asList(\"Alex\", \"Paul\", \"Viktor\");\n  List<String> lettersUsed = Collections.emptyList();\n\n  assertThat(lettersUsed)\n    .hasSize(12)\n    .containsExactly(\"a\",\"l\",\"e\",\"x\",\"p\",\"u\",\"v\",\"i\",\"k\",\"t\",\"o\",\"r\");\n}\n```", "```java\nList<String> lettersUsed = names.stream()\n  .map(String::toLowerCase)\n  .flatMap(name -> Stream.of(name.split(\"\")))\n  .distinct()\n  .collect(Collectors.toList());\n```", "```java\n@Test\npublic void countingLettersUsedInNames() {\n  List<String> names = Arrays.asList(\"Alex\", \"Paul\", \"Viktor\");\n  long count = 0;\n\n  assertThat(count).isEqualTo(12);\n}\n```", "```java\nlong count = names.stream()\n  .map(String::toLowerCase)\n  .flatMap(name -> Stream.of(name.split(\"\")))\n  .distinct()\n  .mapToLong(l -> 1L)\n  .reduce(0L, (v1, v2) -> v1 + v2);\n```", "```java\nlong count = names.stream()\n  .map(String::toLowerCase)\n  .flatMap(name -> Stream.of(name.split(\"\")))\n  .distinct()\n  .count();\n```"]