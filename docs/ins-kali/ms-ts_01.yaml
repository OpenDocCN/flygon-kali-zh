- en: Chapter 1. TypeScript – Tools and Framework Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 TypeScript - 工具和框架选项
- en: JavaScript is a truly ubiquitous language. Just about every website that you
    visit in the modern world will have some sort of JavaScript component embedded
    in it, in order to make the site more responsive, more readable, or more attractive
    to use. Think about the most impressive website that you have visited over the
    past few months. Was it visually appealing? Did it have some sort of clever presentation?
    Did it engage you as a user, by giving you a completely new way of discovering
    car-insurance, or image-sharing, or news articles?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种真正无处不在的语言。现代世界中您访问的几乎每个网站都会嵌入某种JavaScript组件，以使网站更具响应性、更易读，或者更具吸引力。想想您在过去几个月中访问过的最令人印象深刻的网站。它外观吸引人吗？它有某种巧妙的呈现方式吗？它是否通过为您提供全新的发现汽车保险、图片分享或新闻文章的方式来吸引您作为用户？
- en: This is the power of JavaScript. JavaScript is the icing on the cake of the
    internet experience, that makes millions of people around the world go "wow. That's
    cool". And it generates revenue. Two websites may offer the same product, at the
    same price, but the one that engages the client – and makes them enjoy the web
    experience – is the site that will attract the most followers and be the most
    successful. If this website can also be seamlessly reproduced on desktops, mobiles
    or tablets, then the target audience – and the target revenue – can be increased
    exponentially.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JavaScript的力量。JavaScript是互联网体验的点睛之笔，让全世界数百万人感到“哇，太酷了”。它也带来了收入。两个网站可能以相同的价格提供相同的产品，但是能够吸引客户并让他们享受网络体验的网站将吸引最多的追随者并获得最大的成功。如果这个网站还可以在台式机、手机或平板电脑上无缝重现，那么目标受众和目标收入可以成倍增加。
- en: On the flip-side, though, JavaScript is also responsible for the annoying side
    of the Internet. Those annoying advertisements, where you have to wait for 5 seconds
    before clicking on the **skip** button. Or websites that do not quite work on
    older browsers, or don't render correctly on tablets and mobile phones. It can
    be argued that many websites would be better off without JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript也是互联网上讨厌的一面的原因。那些令人讨厌的广告，您必须等待5秒钟才能点击“跳过”按钮。或者在旧版浏览器上无法正常工作，或者在平板电脑和手机上无法正确渲染的网站。可以说，许多网站如果没有JavaScript会更好。
- en: An engaging web experience can also make the difference in corporate web applications.
    A clunky, difficult to use, and slow web application will turn otherwise keen
    corporate users completely against your application. Remember that your typical
    corporate user is comparing their work experience to their daily web experience
    – of well designed, responsive, intuitive interfaces. After all, they are generally
    users of the most popular websites out there, and come to expect the same responsiveness
    at work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个引人入胜的网络体验也可以在企业网络应用中产生巨大差异。笨重、难以使用和缓慢的网络应用会完全让企业用户对您的应用产生反感。请记住，您的典型企业用户正在将他们的工作体验与他们的日常网络体验进行比较
    - 他们期望得到精心设计、响应迅速、直观的界面。毕竟，他们通常是最受欢迎的网站的用户，并期望在工作中得到同样的响应。
- en: Most of this enhanced user experience comes from the effective use of JavaScript.
    Asynchronous JavaScript requests allow your web page to render content to the
    user faster – while waiting for backend processes to do the heavy, time consuming
    data crunching tasks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分这种增强的用户体验来自于JavaScript的有效使用。异步JavaScript请求允许您的网页在等待后端进程进行繁重、耗时的数据处理任务时更快地向用户呈现内容。
- en: The JavaScript language is not a difficult language to learn, but it does present
    challenges when writing large, complex programs. Being an interpreted language,
    JavaScript has no compilation step, and so is executed on the fly. For programmers
    that are used to writing code in a more formal environment – using compilers,
    strong typing and well established programming patterns – JavaScript can be a
    completely foreign environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言并不难学，但在编写大型、复杂程序时会带来挑战。作为一种解释性语言，JavaScript没有编译步骤，因此是即时执行的。对于习惯于在更正式的环境中编写代码
    - 使用编译器、强类型和成熟的编程模式的程序员来说，JavaScript可能是一个完全陌生的环境。
- en: TypeScript bridges this gap. It is a strongly typed, object-oriented, compiled
    language that allows you as a programmer, to re-use the concepts and ideas of
    well-established object-oriented languages – in JavaScript. The TypeScript compiler
    generates JavaScript that adheres to these strongly typed, object-oriented principles
    – but at the same time is just pure JavaScript. As such, it will run successfully
    wherever JavaScript can run – in the browser, on the server, or on modern mobile
    devices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript弥合了这一差距。它是一种强类型、面向对象、编译语言，允许您作为程序员在JavaScript中重复使用成熟的面向对象语言的概念和思想。TypeScript编译器生成的JavaScript遵循这些强类型、面向对象的原则
    - 但同时又是纯粹的JavaScript。因此，它将在JavaScript可以运行的任何地方成功运行 - 在浏览器、服务器或现代移动设备上。
- en: This chapter is divided into two main sections. The first section is a quick
    overview of some of the benefits that TypeScript brings to the JavaScript development
    experience. The second section of this chapter deals with setting up a TypeScript
    development environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个主要部分。第一部分是对TypeScript为JavaScript开发体验带来的一些好处的快速概述。本章的第二部分涉及设置TypeScript开发环境。
- en: If you are an experienced TypeScript programmer, and you already have a development
    environment set up, then you might want to skip this chapter. If you have never
    worked with TypeScript before, and have picked up this book because you want to
    understand what TypeScript can do for you, then read on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一名有经验的TypeScript程序员，并且已经设置好了开发环境，那么您可能想跳过本章。如果您以前从未使用过TypeScript，并且因为想了解TypeScript能为您做什么而拿起了这本书，那么请继续阅读。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The benefits of TypeScript
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的好处
- en: Compilation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译
- en: Strong Typing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型
- en: Integration with popular JavaScript libraries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流行的JavaScript库集成
- en: Encapsulation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Private and public member variables
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有和公共成员变量
- en: Setting up a development environment
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Visual Studio
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: WebStorm
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebStorm
- en: Brackets and Grunt
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号和Grunt
- en: What is TypeScript?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是TypeScript？
- en: TypeScript is both a language and a set of tools to generate JavaScript. It
    was designed by Anders Hejlsberg at Microsoft (the designer of C#), as an open-source
    project, to help developers write enterprise scale JavaScript. JavaScript has
    become widely adopted by programmers around the world – as it can run in any browser
    on any operating system. With the creation of Node, JavaScript can now also run
    on the server, desktop or mobile.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript既是一种语言，也是一套生成JavaScript的工具。它是由微软的Anders Hejlsberg（C#的设计者）设计的，作为一个开源项目，帮助开发人员编写企业规模的JavaScript。JavaScript已经被世界各地的程序员广泛采用，因为它可以在任何操作系统上的任何浏览器上运行。随着Node的创建，JavaScript现在也可以在服务器、桌面或移动设备上运行。
- en: TypeScript generates JavaScript – it's as simple as that. Instead of requiring
    a completely new runtime environment, TypeScript generated JavaScript can re-use
    all of the existing JavaScript tools, frameworks, and wealth of libraries that
    are available for JavaScript. The TypeScript language and compiler, however, brings
    the development of JavaScript closer to a more traditional object-oriented experience.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript生成JavaScript——就是这么简单。TypeScript生成的JavaScript可以重用所有现有的JavaScript工具、框架和丰富的库，而不需要完全新的运行时环境。然而，TypeScript语言和编译器将JavaScript的开发更接近于更传统的面向对象的体验。
- en: EcmaScript
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EcmaScript
- en: JavaScript as a language has been around for a long time, and is also governed
    by a language feature standard. The language defined in this standard is called
    ECMAScript, and each browser must deliver functions and features that conform
    to this standard. The definition of this standard helped the growth of JavaScript
    and the web in general, and allowed websites to render correctly on many different
    browsers on many different operating systems. The ECMAScript standard was published
    in 1999 and is known as ECMA-262, third edition.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript作为一种语言已经存在很长时间，并且也受到语言特性标准的约束。在这个标准中定义的语言称为ECMAScript，每个浏览器必须提供符合这个标准的功能和特性。这个标准的定义帮助了JavaScript和网络的增长，并允许网站在许多不同的操作系统上的许多不同的浏览器上正确呈现。ECMAScript标准于1999年发布，被称为ECMA-262第三版。
- en: With the popularity of the language, and the explosive growth of internet applications,
    the ECMAScript standard needed to be revised and updated. This process resulted
    in a draft specification for ECMAScript, called the fourth edition. Unfortunately,
    this draft suggested a complete overhaul of the language, and was not well received.
    Eventually, leaders from Yahoo, Google and Microsoft tabled an alternate proposal
    which they called ECMAScript 3.1\. This proposal was numbered 3.1, as it was a
    smaller feature set of the third edition, and sat "between" edition 3 and 4 of
    the standard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着语言的流行和互联网应用的爆炸性增长，ECMAScript标准需要进行修订和更新。这个过程导致了ECMAScript的草案规范，称为第四版。不幸的是，这个草案提出了对语言的彻底改革，但并未受到良好的反响。最终，来自雅虎、谷歌和微软的领导人提出了一个另类提案，他们称之为ECMAScript
    3.1。这个提案被编号为3.1，因为它是第三版的一个较小的功能集，并且位于标准的第3版和第4版之间。
- en: This proposal was eventually adopted as the fifth edition of the standard, and
    was called ECMAScript 5\. The ECMAScript fourth edition was never published, but
    it was decided to merge the best features of both the fourth edition and the 3.1
    feature set – into a sixth edition named ECMAScript Harmony.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提案最终被采纳为标准的第五版，并被称为ECMAScript 5。ECMAScript第四版从未出版，但决定将第四版和3.1功能集的最佳特性合并为第六版，命名为ECMAScript
    Harmony。
- en: The TypeScript compiler has a parameter that can be modified to target different
    versions of the ECMAScript standard. TypeScript currently supports ECMAScript
    3, ECMAScript 5 and ECMAScript 6\. When the compiler runs over your TypeScript,
    it will generate compile errors if the code you are attempting to compile is not
    valid for that particular standard. The team at Microsoft has also committed to
    follow the ECMAScript standards in any new versions of the TypeScript compiler,
    so as and when new editions are adopted, the TypeScript language and compiler
    will follow suit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器有一个参数，可以修改以针对不同版本的ECMAScript标准。TypeScript目前支持ECMAScript 3、ECMAScript
    5和ECMAScript 6。当编译器运行在您的TypeScript上时，如果您尝试编译的代码不符合特定标准，它将生成编译错误。微软团队还承诺在TypeScript编译器的任何新版本中遵循ECMAScript标准，因此一旦采用新版本，TypeScript语言和编译器也会跟进。
- en: An understanding of the finer details of what is included in each release of
    the ECMAScript standard is outside of the scope of this book, but it is important
    to know that there are differences. Some browser versions do not support ES5 (IE8
    is an example), but most do. When selecting a version of ECMAScript to target
    for your projects, you will need to consider which browser versions you will be
    supporting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript标准的每个版本包含的细节超出了本书的范围，但重要的是要知道存在差异。一些浏览器版本不支持ES5（IE8就是一个例子），但大多数浏览器支持。在选择要为项目定位的ECMAScript版本时，您需要考虑要支持的浏览器版本。
- en: The benefits of TypeScript
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript的好处
- en: 'To give you a flavor of the benefits of TypeScript (and this is by no means
    the full list), let''s take a very quick look at some of the things that TypeScript
    brings to the table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解TypeScript的好处（这绝不是完整列表），让我们快速看一下TypeScript带来的一些东西：
- en: A compilation step
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译步骤
- en: Strong or static typing
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型或静态类型
- en: Type definitions for popular JavaScript libraries
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行JavaScript库的类型定义
- en: Encapsulation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Private and public member variable decorators
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有和公共成员变量装饰器
- en: Compiling
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译
- en: One of the most frustrating things about JavaScript development is the lack
    of a compilation step. JavaScript is an interpreted language, and therefore needs
    to be run in order to test that it is valid. Every JavaScript developer will tell
    horror stories of hours spent trying to find bugs in their code, only to find
    that they have missed a stray closing brace `{` , or a simple comma `,` - or even
    a double quote `"` where there should have been a single quote `'`. Even worse,
    the real headaches arrive when you misspell a property name, or unwittingly re-assign
    a global variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发最令人沮丧的事情之一是缺乏编译步骤。JavaScript是一种解释性语言，因此需要运行才能测试其有效性。每个JavaScript开发人员都会讲述关于花费数小时来查找代码中的错误的可怕故事，只是发现他们错过了一个多余的闭括号`{`，或者一个简单的逗号`,`
    - 或者甚至是一个双引号`"`，而应该是单引号`'`。更糟糕的是，当你拼错属性名称或者无意中重新分配全局变量时，真正的头痛就来了。
- en: TypeScript will compile your code, and generate compilation errors where it
    finds these sort of syntax errors. This is obviously very useful, and can help
    to highlight errors before the JavaScript is run. In large projects, programmers
    will often need to do large code merges – and with today's tools doing automatic
    merges – it is surprising how often the compiler will pick up these types of errors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript将编译你的代码，并在发现这种类型的语法错误时生成编译错误。这显然非常有用，并且可以帮助在JavaScript运行之前突出显示错误。在大型项目中，程序员通常需要进行大规模的代码合并
    - 而今天的工具可以自动合并 - 令人惊讶的是编译器经常会发现这些类型的错误。
- en: While tools to do this sort of syntax checking – like JSLint – have been around
    for years, it is obviously beneficial to have these tools integrated into your
    IDE. Using TypeScript in a continuous integration environment will also fail a
    build completely when compilation errors are found – further protecting your programmers
    against these types of bugs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像JSLint这样的语法检查工具已经存在多年，但将这些工具集成到你的IDE中显然是有益的。在持续集成环境中使用TypeScript也将在发现编译错误时完全失败构建
    - 进一步保护程序员免受这些类型的错误。
- en: Strong Typing
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强类型
- en: 'JavaScript is not strongly typed. It is a language that is very dynamic, as
    it allows objects to change their properties and behavior on the fly. As an example
    of this, consider the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不是强类型的。它是一种非常动态的语言，因为它允许对象在运行时改变其属性和行为。举个例子，考虑以下代码：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the first line of this code snippet, the variable `test` is bound to a string.
    It is then assigned a number, and finally is redefined to be a function that expects
    two parameters. Traditional object oriented languages, however, will not allow
    the type of a variable to change – hence they are called strongly typed languages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段的第一行，变量`test`绑定到一个字符串。然后它被赋一个数字，最后被重新定义为一个期望两个参数的函数。然而，传统的面向对象语言不允许变量的类型改变
    - 因此它们被称为强类型语言。
- en: While all of the preceding code is valid JavaScript - and could be justified
    - it is quite easy to see how this could cause runtime errors during execution.
    Imagine that you were responsible for writing a library function to add two numbers,
    and then another developer inadvertently re-assigned your function to instead
    subtract these numbers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的所有代码都是有效的JavaScript - 并且可以被证明是合理的 - 但很容易看出这可能在执行过程中导致运行时错误。想象一下，你负责编写一个库函数来添加两个数字，然后另一个开发人员无意中重新将你的函数重新分配为减去这些数字。
- en: These types of errors may be easy to spot in a few lines of code, but it becomes
    increasingly difficult to find and fix these as your code base, and your development
    team grows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的错误可能在几行代码中很容易发现，但随着你的代码库和开发团队的增长，找到并修复这些错误变得越来越困难。
- en: Another feature of strong typing is that the IDE you are working in can understand
    what type of variable you are working with, and can bring better autocomplete
    or Intellisense options to the fore.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型的另一个特性是，你正在使用的IDE可以理解你正在处理的变量类型，并且可以提供更好的自动完成或智能提示选项。
- en: TypeScript's "syntactic sugar"
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TypeScript的“语法糖”
- en: 'TypeScript introduces a very simple syntax to check the type of an object at
    compile time. This syntax has been referred to as "syntactic sugar", or more formally,
    type annotations. Consider the following TypeScript code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript引入了一种非常简单的语法来在编译时检查对象的类型。这种语法被称为“语法糖”，或者更正式地说，类型注解。考虑以下TypeScript代码：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note on the first line of this code snippet, we have introduced a colon `:`
    and a `string` keyword between our variable and it''s assignment. This type annotation
    syntax means that we are setting the type of our variable to be of type `string`,
    and that any code that does not use it as a string will generate a compile error.
    Running the preceding code through the TypeScript compiler will generate two errors:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段的第一行上，我们介绍了一个冒号`:`和一个`string`关键字，将我们的变量和它的赋值之间。这种类型注解语法意味着我们正在设置变量的类型为`string`类型，并且任何不将其用作字符串的代码都将生成一个编译错误。通过TypeScript编译器运行前面的代码将生成两个错误：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first error is fairly obvious. We have specified that the variable `test`
    is a `string`, and therefore attempting to assign a number to it will generate
    a compile error. The second error is similar to the first, and is in essence saying
    that we cannot assign a function to a string.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误非常明显。我们已经指定变量`test`是一个`string`，因此尝试将一个数字赋给它将生成一个编译错误。第二个错误与第一个类似，本质上是在说我们不能将一个函数赋给一个字符串。
- en: In this way, the TypeScript compiler introduces strong, or static typing to
    your JavaScript code, giving you all of the benefits of a strongly typed language.
    TypeScript is therefore described as a "superset" of JavaScript. We will explore
    typing in more detail in the next chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TypeScript编译器，你的JavaScript代码引入了强大的静态类型，给你所有强类型语言的好处。因此，TypeScript被描述为JavaScript的“超集”。我们将在下一章更详细地探讨类型。
- en: Type definitions for popular JavaScript libraries
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流行JavaScript库的类型定义
- en: 'As we have seen, TypeScript has the ability to "annotate" JavaScript, and bring
    strong typing to the JavaScript development experience. But how do we strongly
    type existing JavaScript libraries? The answer is surprisingly simple: by creating
    a definition file. TypeScript uses files with a `.d.ts` extension as a sort of
    "header" file, similar to languages such as C++, to superimpose strongly typing
    on existing JavaScript libraries. These definition files hold information that
    describes each available function and variable of the library, along with their
    associated type annotations.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，TypeScript有能力“注释”JavaScript，并为JavaScript开发体验带来强类型。但是我们如何为现有的JavaScript库提供强类型？答案出奇的简单：通过创建一个定义文件。TypeScript使用扩展名为`.d.ts`的文件作为一种“头”文件，类似于C++等语言，以在现有的JavaScript库上叠加强类型。这些定义文件包含描述库中每个可用函数和变量以及它们相关类型注释的信息。
- en: 'Let''s take a quick look at what a definition would look like. As an example,
    consider a function from the popular Jasmine unit testing framework called `describe`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下定义会是什么样子。举个例子，考虑一个来自流行的Jasmine单元测试框架的函数`describe`：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function has two parameters, `description` and `specDefinitions`. Just
    reading this JavaScript, however, does not tell us what sort of parameters these
    are meant to be. Is the `specDefinitions` argument a string, or an array of strings,
    a function or something else? In order to figure this out, we would need to have
    a look through the Jasmine documentation found at [http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html).
    This documentation provides us with a helpful sample of how to use this function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数，`description`和`specDefinitions`。然而，仅仅阅读这个JavaScript并不能告诉我们这些参数应该是什么类型。`specDefinitions`参数是一个字符串，还是一个字符串数组，一个函数或者其他什么？为了弄清楚这一点，我们需要查看Jasmine文档，可以在[http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html)找到。这个文档为我们提供了如何使用这个函数的有用示例：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the documentation, then, we can easily see that the first parameter is
    a `string`, and the second parameter is a `function`. There is nothing in the
    JavaScript language, however, that forces us to conform to this API. As mentioned
    before, we could easily call this function with two numbers – or inadvertently
    switch the parameters around, sending a function first, and a string second. We
    will obviously start getting runtime errors if we do this, but TypeScript – using
    a definition file – can generate compile time errors before we even attempt to
    run this code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '从文档中，我们可以很容易地看出第一个参数是一个`string`，第二个参数是一个`function`。然而，在JavaScript语言中，并没有强制我们遵循这个API。正如之前提到的，我们可以轻松地用两个数字调用这个函数，或者无意中交换参数，先发送一个函数，然后发送一个字符串。如果我们这样做，显然会开始出现运行时错误，但是TypeScript可以在我们尝试运行这段代码之前生成编译时错误，使用定义文件。 '
- en: 'Let''s take a look at a piece of the `jasmine.d.ts` definition file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`jasmine.d.ts`定义文件的一部分：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the TypeScript definition for the describe function. Firstly, `declare
    function describe` tells us that we can use a function called `describe`, but
    that the implementation of this function will be provided at runtime.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述函数的TypeScript定义。首先，`declare function describe`告诉我们可以使用一个名为`describe`的函数，但是这个函数的实现将在运行时提供。
- en: Clearly, the `description` parameter is strongly typed to be of type `string`,
    and the `specDefinitions` parameter is strongly typed to be a `function` that
    returns `void`. TypeScript uses the double braces `()` syntax to declare functions,
    and the fat arrow syntax to show the return type of the function. So `() => void`
    is a function that does not return anything. Finally, the describe function itself
    will return `void`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`description`参数被强类型为`string`类型，`specDefinitions`参数被强类型为返回`void`的`function`。TypeScript使用双括号`()`语法声明函数，并使用箭头语法显示函数的返回类型。所以`()
    => void`是一个不返回任何东西的函数。最后，`describe`函数本身将返回`void`。
- en: 'If our code were to try and pass in a function as the first parameter, and
    a string as the second parameter (clearly breaking the definition of this function)
    as shown in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码尝试将一个函数作为第一个参数传递，将一个字符串作为第二个参数传递（显然违反了这个函数的定义），如下例所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The TypeScript compiler will immediately generate the following errors:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将立即生成以下错误：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This error is telling us that we are attempting to call the `describe` function
    with invalid parameters. We will look at definition files in more detail in later
    chapters, but this example clearly shows that TypeScript will generate errors
    if we attempt to use external JavaScript libraries incorrectly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，我们试图使用无效的参数调用`describe`函数。我们将在后面的章节中更详细地看定义文件，但是这个例子清楚地显示了如果我们尝试不正确地使用外部JavaScript库，TypeScript将生成错误。
- en: Definitely Typed
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Definitely Typed
- en: Soon after TypeScript was released, Boris Yankov started a GitHub repository
    to house definition files, at DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped)).
    This repository has now become the first port of call for integrating external
    libraries into TypeScript, and currently holds definitions for over 500 JavaScript
    Libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript发布后不久，Boris Yankov开始在DefinitelyTyped（[https://github.com/borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped)）上创建了一个GitHub存储库，用于存放定义文件。这个存储库现在已经成为将外部库集成到TypeScript中的首选方法，并且目前保存了超过500个JavaScript库的定义。
- en: Encapsulation
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: 'One of the fundamental principles of object-oriented programming is encapsulation:
    The ability to define data, as well as a set of functions that can operate on
    that data, into a single component. Most programming languages have the concept
    of a class for this purpose – providing a way to define a template for data and
    related functions.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个基本原则是封装：将数据定义以及一组可以操作该数据的函数封装到一个单一的组件中。大多数编程语言都有类的概念，提供了一种定义数据和相关函数模板的方式。
- en: 'Let''s first take a look at a simple TypeScript class definition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下一个简单的TypeScript类定义：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is pretty simple to read and understand. We have created a `class`,
    named `MyClass`, with a single function named `add`. To use this class, we simply
    create an instance of it, and call the `add` function with two arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单易懂。我们创建了一个名为`MyClass`的`class`，其中包含一个名为`add`的函数。要使用这个类，我们只需创建一个实例，并使用两个参数调用`add`函数。
- en: JavaScript, unfortunately, does not have a `class` keyword, but instead uses
    functions to reproduce the functionality of classes. Encapsulation through classes
    is accomplished by either using the prototype pattern, or by using the closure
    pattern. Understanding prototypes and the closure pattern, and using them correctly,
    is considered a fundamental skill when writing enterprise-scale JavaScript.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript没有`class`关键字，而是使用函数来复制类的功能。通过类实现封装可以通过使用原型模式或者使用闭包模式来完成。理解原型和闭包模式，并正确使用它们，被认为是编写企业级JavaScript时的基本技能。
- en: 'A closure is essentially a function that refers to independent variables. This
    means that variables defined within a closure function ''remember'' the environment
    in which they were created. This provides JavaScript with a way to define local
    variables, and provide encapsulation. Writing the `MyClass` definition in the
    preceding code, using a closure in JavaScript would look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包本质上是指引用独立变量的函数。这意味着在闭包函数内定义的变量会“记住”它们被创建的环境。这为JavaScript提供了一种定义局部变量和提供封装的方式。在前面的代码中使用JavaScript的闭包来编写`MyClass`定义会看起来像这样：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start with a variable called `MyClass`, and assign it to a function that
    is executed immediately – note the `})();` syntax near the bottom of the code
    snippet. This syntax is a common way to write JavaScript in order to avoid leaking
    variables into the global namespace. We then define a new function named `MyClass`,
    and return this new function to the outer calling function. We then use the `prototype`
    keyword to inject a new function into the `MyClass` definition. This function
    is named `add` and takes two parameters, returning their sum.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`MyClass`的变量开始，并将其分配给一个立即执行的函数——请注意代码片段底部附近的`})();`语法。这种语法是为了避免将变量泄漏到全局命名空间而常用的JavaScript编写方式。然后我们定义一个名为`MyClass`的新函数，并将这个新函数返回给外部调用函数。然后我们使用`prototype`关键字将一个新函数注入到`MyClass`定义中。这个函数名为`add`，接受两个参数，返回它们的和。
- en: 'The last two lines of the code show how to use this closure in JavaScript.
    Create an instance of the closure type, and then execute the add function. Running
    this in the browser will log **result: 3** to the console, as expected.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '代码的最后两行展示了如何在JavaScript中使用这个闭包。创建一个闭包类型的实例，然后执行add函数。在浏览器中运行这个代码将会在控制台上记录**result:
    3**，这是预期的结果。'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support
    ) and register to have the files e-mailed directly to you.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，这适用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support
    )并注册以直接通过电子邮件接收文件。
- en: 'Looking at the JavaScript code versus the TypeScript code, we can easily see
    how simple TypeScript looks, compared to the equivalent JavaScript. Remember how
    we mentioned that JavaScript programmers can easily misplace a brace `{`, or a
    bracket `(`? Take a look at the last line in the closure definition: `})();` Getting
    one of these brackets or braces wrong can take hours of debugging to find.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较JavaScript代码和TypeScript代码，我们可以很容易地看出TypeScript相对于等效的JavaScript来说是多么简单。还记得我们提到过JavaScript程序员很容易错放大括号`{`或者括号`(`吗？看一下闭包定义的最后一行：`})();`。弄错其中一个大括号或者括号可能需要花费数小时来调试。
- en: TypeScript classes generate closures
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TypeScript类生成闭包
- en: The JavaScript closure as shown in the preceding code snippet, is actually the
    output of the TypeScript class definition. So TypeScript actually generates closures
    for you.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，TypeScript类定义的实际输出是JavaScript闭包。因此TypeScript实际上为您生成了闭包。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding the concept of classes to the JavaScript language has been talked about
    for years, and is currently a part of the ECMAScript sixth Edition (Harmony) standard
    – but this is still a work in progress. Microsoft has committed to follow the
    ECMAScript standard in the TypeScript compiler, as and when these standards are
    published.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，向JavaScript语言添加类的概念一直是人们讨论的话题，目前已经成为ECMAScript第六版（Harmony）标准的一部分，但这仍然是一个正在进行中的工作。微软已经承诺在TypeScript编译器中遵循ECMAScript标准，一旦这些标准发布，就会实现这些标准。
- en: Public and private accessors
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共和私有访问器
- en: A further object-oriented principle that is used in encapsulation is the concept
    of data hiding – the ability to have public and private variables. Private variables
    are meant to be hidden to the user of a particular class – as these variables
    should only be used by the class itself. Inadvertently exposing these variables
    outside of a class can easily cause runtime errors.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 封装中使用的另一个面向对象原则是数据隐藏的概念——即具有公共和私有变量的能力。私有变量应该对特定类的用户隐藏——因为这些变量只应该被类本身使用。意外地将这些变量暴露到类外部可能很容易导致运行时错误。
- en: 'Unfortunately, JavaScript does not have a native way of declaring variables
    private. While this functionality can be emulated using closures, a lot of JavaScript
    programmers simply use the underscore character `_` to denote a private variable.
    At runtime though, if you know the name of a private variable – you can easily
    assign a value to it. Consider the following JavaScript code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript没有声明变量为私有的本地方法。虽然可以使用闭包来模拟这种功能，但很多JavaScript程序员简单地使用下划线字符`_`来表示私有变量。然而，在运行时，如果您知道私有变量的名称，您可以很容易地为它赋值。考虑以下JavaScript代码：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `MyClass` variable is actually a closure – with a constructor function,
    a `countUp` function and a `getCountUp` function. The variable `_count` is supposed
    to be a private member variable, one that is used only within the scope of the
    closure. Using the underscore naming convention gives the user of this class some
    indication that the variable is private, but JavaScript will still allow you to
    manipulate the variable `_count`. Take a look at the second last line of the code
    snippet. We are explicitly setting the value of the supposed private variable
    `_count` to 17 – which is allowed by JavaScript, but not desired by the original
    creator of the class. The output of this code would be **countUp: 17**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass`变量实际上是一个闭包 - 具有构造函数、`countUp`函数和`getCountUp`函数。变量`_count`应该是一个私有成员变量，只在闭包范围内使用。使用下划线命名约定可以让这个类的用户知道这个变量是私有的，但是JavaScript仍然允许您操作变量`_count`。看一下代码片段的倒数第二行。我们明确地将假定的私有变量`_count`的值设置为17
    - 这是JavaScript允许的，但不是类的原始创建者所期望的。这段代码的输出将是**countUp: 17**。'
- en: 'TypeScript, however, introduces the `public` and `private` keywords that can
    be used on class member variables. Trying to access a class member variable that
    has been marked as `private` will generate a compile time error. As an example
    of this, the JavaScript code above can be written in TypeScript as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TypeScript引入了`public`和`private`关键字，可以用于类成员变量。尝试访问被标记为`private`的类成员变量将生成一个编译时错误。例如，上面的JavaScript代码可以在TypeScript中写成如下形式：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the second line of our code snippet, we have declared a `private` member
    variable named `_count`. Again, we have a constructor, a `countUp` and a `getCount`
    function. If we compile this TypeScript code, the compiler will generate an error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码片段的第二行，我们声明了一个名为`_count`的`private`成员变量。同样，我们有一个构造函数、一个`countUp`和一个`getCount`函数。如果我们编译这个TypeScript代码，编译器将生成一个错误：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This error is generated because we are trying to access the private variable
    `_count` in the last line of the code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为我们试图在代码的最后一行访问私有变量`_count`。
- en: The TypeScript compiler, therefore, is helping us to adhere to public and private
    accessors – by generating a compile error when we inadvertently break this rule.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript编译器帮助我们遵守公共和私有访问者 - 当我们无意中违反这个规则时，它会生成一个编译错误。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, though, that these accessors are a compile-time feature only, and
    will not affect the generated JavaScript. You will need to bear this in mind if
    you are writing JavaScript libraries that will be consumed by third parties. The
    TypeScript compiler will also still generate the JavaScript output file, even
    if there are compile errors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，请记住，这些访问者只是编译时的特性，不会影响生成的JavaScript。如果您正在编写将被第三方使用的JavaScript库，您需要牢记这一点。即使存在编译错误，TypeScript编译器仍会生成JavaScript输出文件。
- en: TypeScript IDEs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript IDEs
- en: The purpose of this section is to get you up and running with a TypeScript environment
    so that you can edit, compile, run and debug your TypeScript code. TypeScript
    has been released as open-source, and includes both a Windows variant, and a Node
    variant. This means that the compiler will run on Windows, Linux, OS X, and any
    other operating system that supports Node.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是让您快速上手使用TypeScript环境，以便您可以编辑、编译、运行和调试您的TypeScript代码。TypeScript已经作为开源发布，并包括Windows版本和Node版本。这意味着编译器将在Windows、Linux、OS
    X和任何支持Node的其他操作系统上运行。
- en: On Windows environments, we can either install Visual Studio – which will register
    the `tsc.exe` (TypeScript Compiler) in our `C:\Program Files` directory, or we
    can use Node. On Linux and OS X environments, we will need to use Node. Either
    way, firing up a command prompt and typing `tsc –v` should display the current
    version of the compiler that we are using. Which at the time of writing, is version
    1.4.2.0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows环境中，我们可以安装Visual Studio - 这将在我们的`C:\Program Files`目录中注册`tsc.exe`（TypeScript编译器），或者我们可以使用Node。在Linux和OS
    X环境中，我们将需要使用Node。无论哪种方式，启动命令提示符并输入`tsc –v`应该显示我们正在使用的编译器的当前版本。在撰写本文时，这个版本是1.4.2.0。
- en: 'In this section, we will be looking at the following IDEs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下以下IDE：
- en: Visual Studio 2013
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2013
- en: WebStorm
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebStorm
- en: Brackets
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号
- en: Visual Studio 2013
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 2013
- en: First up, let's look at Microsoft's Visual Studio 2013\. This is Microsoft's
    primary IDE, and comes in a variety of pricing combinations. At the top end is
    Ultimate, then Premium, then Professional, and finally Express. Ultimate, Premium
    and Professional all require paid licenses which range (at the time of writing)
    from $13,000 through to $1,199\. The good news is that Microsoft has recently
    announced a Community Edition, which can be used in non-enterprise environments
    for both free and non-paid products. The TypeScript compiler is included in all
    of these editions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下微软的Visual Studio 2013。这是微软的主要IDE，有各种定价组合。最高端是Ultimate，然后是Premium，然后是Professional，最后是Express。Ultimate、Premium和Professional都需要付费许可证，价格范围（撰写本文时）从13000美元到1199美元不等。好消息是，微软最近宣布了社区版，可以在非企业环境中免费使用。TypeScript编译器包含在所有这些版本中。
- en: Visual Studio can be downloaded as either a web-installer, or an .ISO CD image.
    Note that the web installer will require an internet connection during installation,
    as it downloads the required packages during the installation step. Visual Studio
    will also require Internet Explorer 10 or later, but will prompt you during installation,
    if you have not upgraded your browser as yet. If you are using the .ISO installer,
    just bear in mind that you may be required to download and install additional
    operating system patches if you have not updated your system with Windows Update
    in a while.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio可以下载为Web安装程序或.ISO CD映像。请注意，Web安装程序在安装过程中需要互联网连接，因为它在安装步骤中下载所需的软件包。Visual
    Studio还需要Internet Explorer 10或更高版本，但如果您尚未升级浏览器，它将在安装过程中提示您。如果您使用.ISO安装程序，请记住，如果您已经有一段时间没有通过Windows
    Update更新系统，可能需要下载并安装额外的操作系统补丁。
- en: Creating a Visual Studio Project
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Visual Studio项目
- en: 'Once Visual Studio is installed, fire it up and create a new project (**File**
    | **New Project**). Under the **Templates** section on the left hand side, you
    will see a TypeScript option. When this option is selected, you will be able to
    use a project template named **Html Application with TypeScript**. Enter a name
    and location for your project, and then click **OK** to generate a TypeScript
    project:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Visual Studio后，启动它并创建一个新项目（**File** | **New Project**）。在左侧的**Templates**部分下，您将看到一个TypeScript选项。选择此选项后，您将能够使用一个名为**Html
    Application with TypeScript**的项目模板。输入项目的名称和位置，然后单击**OK**生成一个TypeScript项目：
- en: '![Creating a Visual Studio Project](img/9665OS_01_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![创建Visual Studio项目](img/9665OS_01_01.jpg)'
- en: Visual Studio – selecting the TypeScript project type
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio - 选择TypeScript项目类型
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not the only project template that works with TypeScript. Any of the
    ASP.NET project types support TypeScript out of the box. If you are planning to
    use the Web API to provide RESTful data controllers, then you may consider creating
    an MVC Web Application from the start. Then, by simply including a TypeScript
    file, and specifying a `.ts` file extension within the project, Visual Studio
    will automatically start compiling your TypeScript files as part of the new project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是唯一支持TypeScript的项目模板。任何ASP.NET项目类型都支持TypeScript。如果您计划使用Web API提供RESTful数据控制器，那么您可能考虑从头开始创建一个MVC
    Web应用程序。然后，只需包含一个TypeScript文件，并在项目中指定`.ts`文件扩展名，Visual Studio将自动开始编译您的TypeScript文件作为新项目的一部分。
- en: Default project settings
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认项目设置
- en: 'Once a new TypeScript project is created, notice that the project template
    generates a few files for us automatically:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的TypeScript项目后，注意项目模板会自动生成一些文件：
- en: '`app.css`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.css`'
- en: '`app.ts`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.ts`'
- en: '`index.html`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '`web.config`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.config`'
- en: 'If we were to compile and then run this project now, we would have a complete,
    running TypeScript application right off the bat:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译然后运行这个项目，我们将立即拥有一个完整的、运行中的TypeScript应用程序：
- en: '![Default project settings](img/9665OS_01_02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![默认项目设置](img/9665OS_01_02.jpg)'
- en: Visual Studio index.html running in Internet Explorer
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Internet Explorer中运行的Visual Studio index.html
- en: 'Let''s take a quick look at the generated index.html file and what it contains:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下生成的index.html文件及其内容：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a very simple HTML file, which includes the `app.css` style sheet, as
    well as a JavaScript file named `app.js`. This `app.js` file is the JavaScript
    file that is generated from `app.ts` TypeScript file, when the project is compiled.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的HTML文件，包括`app.css`样式表，以及一个名为`app.js`的JavaScript文件。这个`app.js`文件是从`app.ts`
    TypeScript文件生成的JavaScript文件，当项目被编译时。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `app.js` file is not included in the **Solution Explorer** – only the `app.ts`
    TypeScript file is included. This is by design. If you wish to see the generated
    JavaScript file, simply click on the **Show All Files** button in the **Solution
    Explorer** toolbar.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`文件不包括在**Solution Explorer**中 - 只有`app.ts` TypeScript文件包括在内。这是有意设计的。如果您希望看到生成的JavaScript文件，只需点击**Solution
    Explorer**工具栏中的**Show All Files**按钮。'
- en: Debugging in Visual Studio
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试
- en: One of the best features of Visual Studio is that it is truly an integrated
    environment. Debugging TypeScript in Visual Studio is exactly the same as debugging
    C# – or any other language in Visual Studio – and includes the usual **Immediate**,
    **Locals**, **Watch** and **Call stack** windows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio最好的功能之一是它真正是一个集成环境。在Visual Studio中调试TypeScript与调试C#或Visual Studio中的任何其他语言完全相同，并包括通常的**Immediate**、**Locals**、**Watch**和**Call
    stack**窗口。
- en: To debug TypeScript in Visual Studio, simply put a breakpoint on the line you
    wish to break on in your TypeScript file (Move your mouse into the breakpoint
    area next to the source code line, and click). In the image below, we have placed
    a breakpoint within the `window.onload` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio中调试TypeScript，只需在TypeScript文件中希望中断的行上设置断点（将鼠标移动到源代码行旁边的断点区域，然后单击）。在下面的图像中，我们在`window.onload`函数内设置了一个断点。
- en: To start debugging, simply hit *F5*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，只需按下*F5*。
- en: '![Debugging in Visual Studio](img/9665OS_01_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![在Visual Studio中调试](img/9665OS_01_03.jpg)'
- en: Visual Studio TypeScript editor with a breakpoint set in the code
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中设置断点的TypeScript编辑器
- en: When the source code line is highlighted in yellow, simply hover your mouse
    over any of the variables in your source, or use the **Immediate**, **Watch**,
    **Locals** or **Call stack** windows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当源代码行被黄色高亮显示时，只需将鼠标悬停在源代码中的任何变量上，或使用**Immediate**、**Watch**、**Locals**或**Call
    stack**窗口。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Studio only supports debugging in Internet Explorer. If you have multiple
    browsers installed on your machine, make sure that you select Internet Explorer
    in your **Debug** toolbar, as shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio只支持在Internet Explorer中调试。如果您的计算机上安装了多个浏览器，请确保在**Debug**工具栏中选择Internet
    Explorer，如下面的截图所示：
- en: '![Debugging in Visual Studio](img/9665OS_01_04.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![在Visual Studio中调试](img/9665OS_01_04.jpg)'
- en: Visual Studio debug toolbar showing browser options
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试工具栏显示浏览器选项
- en: WebStorm
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebStorm
- en: WebStorm is a popular IDE by JetBrains ([http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)),
    and will run on Windows, Mac OS X and Linux. Prices range from $49 for a single
    developer to $99 for a commercial license. JetBrains also offers a 30 day trial
    version.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm是JetBrains（[http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)）的一款流行的IDE，可在Windows、Mac
    OS X和Linux上运行。价格从单个开发者的49美元到商业许可证的99美元不等。JetBrains还提供30天的试用版本。
- en: WebStorm has a couple of great features, including live-edit and code suggestions,
    or Intellisense. The live-edit feature allows you to keep a browser window open,
    which WebStorm will automatically update based on changes to CSS, HTML and JavaScript
    as you type it. Code suggestions – which are also available with another popular
    JetBrains product named Resharper – will highlight code that you have written,
    and suggest better ways of implementing it. WebStorm also has a large number of
    project templates. These templates will automatically download and include the
    relevant JavaScript or CSS files needed by the template, such as Twitter Bootstrap,
    or HTML5 boilerplate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm有一些很棒的功能，包括实时编辑和代码建议，或者智能感知。实时编辑功能允许您保持浏览器窗口打开，WebStorm将根据您的输入自动更新CSS、HTML和JavaScript的更改。代码建议
    - 这也是另一款流行的JetBrains产品Resharper提供的 - 将突出显示您编写的代码，并建议更好的实现方式。WebStorm还有大量的项目模板。这些模板将自动下载并包含模板所需的相关JavaScript或CSS文件，例如Twitter
    Bootstrap或HTML5样板。
- en: Setting up WebStorm is as simple as downloading the package from the website,
    and running the installer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置WebStorm就像从网站下载软件包并运行安装程序一样简单。
- en: Creating a WebStorm project
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建WebStorm项目
- en: 'To create a new WebStorm project, simply fire it up, and hit **File** | **New
    Project**. Select a **Name**, **Location** and **Project type**. For this project,
    we have chosen `Twitter Bootstrap` as the project type, as shown in the following
    screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的WebStorm项目，只需启动它，然后点击**文件** | **新建项目**。选择**名称**、**位置**和**项目类型**。对于这个项目，我们选择了`Twitter
    Bootstrap`作为项目类型，如下面的屏幕截图所示：
- en: '![Creating a WebStorm project](img/9665OS_01_05.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![创建WebStorm项目](img/9665OS_01_05.jpg)'
- en: WebStorm Create New Project dialog box
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm创建新项目对话框
- en: WebStorm will then ask you to select the version of Twitter Boostrap that you
    intend developing for. In this example, we have chosen version `v3.2.0`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm随后会要求您选择要开发的Twitter Boostrap版本。在本例中，我们选择了版本`v3.2.0`。
- en: '![Creating a WebStorm project](img/9665OS_01_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![创建WebStorm项目](img/9665OS_01_06.jpg)'
- en: WebStorm Select Twitter Boostrap version dialog box
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm选择Twitter Boostrap版本对话框
- en: Default files
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认文件
- en: WebStorm has conveniently created a `css`, `fonts` and `js` directory as part
    of the new project – and downloaded and included the relevant CSS, font files
    and JavaScript files for us, in order to start building a new Bootstrap based
    website. Note that it has not created an `index.html` file for us, nor has it
    created any TypeScript files – as Visual Studio did. After a while working with
    TypeScript, most developers will delete these generic files anyway. So lets create
    an `index.html` file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm方便地创建了一个`css`、`fonts`和`js`目录作为新项目的一部分 - 并为我们下载并包含了相关的CSS、字体文件和JavaScript文件，以便开始构建基于Bootstrap的新网站。请注意，它没有为我们创建`index.html`文件，也没有创建任何TypeScript文件
    - 就像Visual Studio一样。在使用TypeScript一段时间后，大多数开发人员都会删除这些通用文件。所以让我们创建一个`index.html`文件。
- en: Simply click on **File** | **New**, select HTML file, enter `index` as a name,
    and click **OK**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 只需点击**文件** | **新建**，选择HTML文件，输入`index`作为名称，然后点击**确定**。
- en: 'Next, let''s create a TypeScript file in a similar manner. We will call this
    file `app` (or `app.ts`), to be the same as in the Visual Studio default project
    example. As we click inside the new `app.ts` file, WebStorm will pop up a green
    bar at the top of our edit window, with a suggestion reading **File watcher ''TypeScript''
    is available for this file**, as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以类似的方式创建一个TypeScript文件。我们将把这个文件命名为`app`（或`app.ts`），与Visual Studio默认项目示例中的相同。当我们点击新的`app.ts`文件时，WebStorm会在编辑窗口顶部弹出一个绿色栏，建议读取**文件监视器'TypeScript'可用于此文件**，如下面的屏幕截图所示：
- en: '![Default files](img/9665OS_01_07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![默认文件](img/9665OS_01_07.jpg)'
- en: WebStorm editing a TypeScript file for the first time showing the File Watcher
    bar
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm首次编辑TypeScript文件，显示文件监视器栏
- en: A WebStorm "file watcher" is a background process that will execute as soon
    as you have saved the file. This is equivalent to Visual Studio's **Compile on
    save** TypeScript option. As WebStorm suggests, now would be a good time to activate
    this file watcher for TypeScript. Click on the **Add watcher** link in the green
    bar, and fill in the details on the next screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm的“文件监视器”是一个后台进程，将在您保存文件后立即执行。这相当于Visual Studio的**保存时编译**TypeScript选项。正如WebStorm建议的那样，现在是激活TypeScript文件监视器的好时机。点击绿色栏中的**添加监视器**链接，并在下一个屏幕上填写详细信息。
- en: 'We can leave the defaults on the next screen as they are for the time being,
    except for the **Program** setting:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以暂时保持下一个屏幕上的默认设置不变，除了**程序**设置：
- en: 'If you are running on Windows, and already have Visual Studio installed, then
    this should be set to the full path of the `tsc.exe` executable, i.e. `C:\Program
    Files (x86)\Microsoft SDKs\TypeScript\1.0\tsc.exe`, as shown in the following
    screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上运行，并且已经安装了Visual Studio，则应将其设置为`tsc.exe`可执行文件的完整路径，即`C:\Program
    Files (x86)\Microsoft SDKs\TypeScript\1.0\tsc.exe`，如下面的屏幕截图所示：
- en: If you are running on a non-windows box, or have installed TypeScript via Node,
    then this would just be set to `tsc`, with no path.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在非Windows系统上运行，或者通过Node安装了TypeScript，那么这个设置将只是`tsc`，没有路径。
- en: '![Default files](img/9665OS_01_08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![默认文件](img/9665OS_01_08.jpg)'
- en: WebStorm new file watcher options screen
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm新文件监视器选项屏幕
- en: Now that we have a file watcher created for our TypeScript files, lets create
    a simple TypeScript class, which will modify the `innerText` of an HTML `div`.
    While you are typing, you will notice WebStorm's autocompletion or Intellisense
    feature helping you with available keywords, parameters, naming conventions and
    a host of other language specific information. This is one of the most powerful
    features of WebStorm, and is similar to the enhanced Intellisense seen in JetBrain's
    Resharper tool for Visual Studio. Go ahead and type the following TypeScript code,
    during which you will get a good feeling of WebStorm's available autocompletion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的TypeScript文件创建了一个文件监视器，让我们创建一个简单的TypeScript类，它将修改HTML的`div`的`innerText`。当您输入时，您会注意到WebStorm的自动完成或Intellisense功能，帮助您使用可用的关键字、参数、命名约定和其他语言特定信息。这是WebStorm最强大的功能之一，类似于JetBrain的Resharper工具中看到的增强Intellisense。继续输入以下TypeScript代码，您将体验到WebStorm提供的自动完成功能。
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start off with the `MyClass` class definition, which simply has a function
    called `render`. This `render` function takes a DOM element name, and a text string
    as parameters. It then simply finds the DOM element, and sets the `innerText`
    property. Note the use of strong typing on the variable `el` – we have explicitly
    typed this to be of the `HTMLElement` type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了`MyClass`类，它简单地有一个名为`render`的函数。这个`render`函数接受一个DOM元素名称和一个文本字符串作为参数。然后它简单地找到DOM元素，并设置`innerText`属性。请注意变量`el`的强类型使用-我们明确将其类型为`HTMLElement`类型。
- en: We are also assigning a function to the `window.onload` event, which will execute
    once the page has been loaded, similar to the Visual Studio sample. Within this
    function, we are simply creating an instance of `MyClass`, and calling the `render`
    function with two string arguments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将一个函数分配给`window.onload`事件，这个函数将在页面加载后执行，类似于Visual Studio示例。在这个函数中，我们只是创建了`MyClass`的一个实例，并调用`render`函数，传入两个字符串参数。
- en: If you have any errors in your TypeScript file, these will automatically show
    up in the output window, giving you instant feedback while you type. With this
    TypeScript file created, we can now include it in our `index.html` file, and try
    some debugging.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的TypeScript文件中有任何错误，这些错误将自动显示在输出窗口中，让您在输入时立即得到反馈。创建了这个TypeScript文件后，我们现在可以将其包含在我们的`index.html`文件中，并尝试一些调试。
- en: Open the `index.html` file, and add a `script` tag to include the `app.js` JavaScript
    file, along with a `div` with an `id` of `"content"`. Just as we saw with TypeScript
    editing, you will find that WebStorm has powerful Intellisense features when editing
    HTML as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`index.html`文件，并添加一个`script`标签来包含`app.js` JavaScript文件，以及一个`id`为`"content"`的`div`。就像我们在TypeScript编辑中看到的一样，您会发现WebStorm在编辑HTML时也具有强大的Intellisense功能。
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a couple of points to note in the preceding code. We are including
    a script tag for the `app.js` JavaScript file, as this is the output file that
    the TypeScript compiler will generate. We have also created an HTML `<div>` with
    an id of `content` that the instance of the `MyClass` class will use to render
    our text.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中有几点要注意。我们正在包括一个`app.js` JavaScript文件的脚本标签，因为这是TypeScript编译器将生成的输出文件。我们还创建了一个带有`content`
    id的HTML `<div>`，`MyClass`类的实例将使用它来渲染我们的文本。
- en: Running the web page in Chrome
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Chrome中运行网页
- en: When viewing or editing HTML files in WebStorm, you will notice a small set
    of browser icons popping up on the top right corner of the editing window. Clicking
    on any one of the icons will launch your current HTML page using the selected
    browser.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebStorm中查看或编辑HTML文件时，您会注意到编辑窗口右上角会弹出一组小的浏览器图标。单击其中任何一个图标将使用所选的浏览器启动当前的HTML页面。
- en: '![Running the web page in Chrome](img/9665OS_01_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![在Chrome中运行网页](img/9665OS_01_09.jpg)'
- en: WebStorm editing an HTML file showing the popup browser launching icons
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm编辑HTML文件显示弹出式浏览器启动图标
- en: Debugging in Chrome
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Chrome中调试
- en: As we saw in Visual Studio, debugging in WebStorm is simply a matter of marking
    a breakpoint, and then hitting *Alt* + *F5*. WebStorm uses a Chrome Plugin to
    enable debugging in Chrome. If you do not have this plugin installed, WebStorm
    will prompt you the first time you start debugging, to download and enable the
    JetBrains IDE Support Chrome Plugin. With this plugin enabled, WebStorm has a
    very powerful set of tools to inspect JavaScript code, add watchers, view the
    console and many more, right inside the IDE.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Visual Studio中看到的那样，在WebStorm中进行调试只是标记断点，然后按下*Alt* + *F5*。WebStorm使用Chrome插件来启用在Chrome中进行调试。如果您没有安装这个插件，WebStorm将在您第一次开始调试时提示您下载并启用JetBrains
    IDE Support Chrome插件。启用了这个插件后，WebStorm有一套非常强大的工具来检查JavaScript代码，添加监视器，查看控制台等，都可以在IDE内部完成。
- en: '![Debugging in Chrome](img/9665OS_01_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![在Chrome中调试](img/9665OS_01_10.jpg)'
- en: WebStorm debugging session showing debugger panels
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm调试会话显示调试器面板
- en: Brackets
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Brackets
- en: The last IDE that we will look at in this chapter is not really an IDE for TypeScript,
    it is more of an IDE for web designers that has TypeScript editing capability.
    Brackets is an open-source code editor, and is really good at helping design and
    style webpages. Similar to WebStorm, it has a live editing mode where you can
    see changes to HTML or CSS on the running web page as you type. In our development
    teams, Brackets has become a very popular editor for rapid prototyping of HTML
    web pages and CSS styling.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的最后一个IDE实际上不是一个TypeScript的IDE，它更像是一个具有TypeScript编辑功能的网页设计师IDE。Brackets是一个开源的代码编辑器，非常擅长帮助设计和样式网页。与WebStorm类似，它有一个实时编辑模式，您可以在输入时看到HTML或CSS在运行的网页上的更改。在我们的开发团队中，Brackets已经成为快速原型设计HTML网页和CSS样式的非常受欢迎的编辑器。
- en: There are a couple of reasons to include Brackets in this chapter. Firstly,
    it is completely open-source and therefore completely free – and it runs on Windows,
    Linux and Mac OS X. Secondly, using a Brackets environment shows what a bare-bones
    TypeScript environment would look like, with just a text editor and the command
    line. Lastly, Brackets shows that the syntax highlighting and code-completion
    capability of open-source projects can be just as good – if not faster than commercial
    IDEs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中包括Brackets有几个原因。首先，它是完全开源的，因此完全免费 - 并且可以在Windows、Linux和Mac OS X上运行。其次，使用Brackets环境可以展示一个多么简单的TypeScript环境会是什么样子，只需一个文本编辑器和命令行。最后，Brackets显示了开源项目的语法高亮和代码补全能力可以和商业IDE一样好
    - 如果不是更快。
- en: Installing Brackets
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装括号
- en: Brackets can be downloaded with the preferred installers from [http://brackets.io](http://brackets.io).
    Once installed, we will need to install some extensions. Brackets has a really
    slick and simple extension manager, which is easy to use, and which allows us
    to easily find and install available extensions. Any time an update to either
    Brackets, or one of your installed extensions is available, Brackets will automatically
    notify you.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[http://brackets.io](http://brackets.io)下载Brackets首选安装程序。安装完成后，我们需要安装一些扩展。Brackets有一个非常简洁和简单的扩展管理器，易于使用，可以让我们轻松找到和安装可用的扩展。每当Brackets或已安装的扩展之一有更新时，Brackets都会自动通知您。
- en: To install an extension, fire up Brackets, and either click on **File** | **Extension
    Manager**, or click on the lego-block icon on the right-hand side vertical sidebar.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装扩展，启动Brackets，然后单击**文件** | **扩展管理器**，或单击右侧垂直侧边栏上的乐高图标。
- en: To start with, we will need to install the TypeScript extension. In the search
    bar, type `brackets typescript`, and install the **Brackets TypeScript** extension
    from **Francois de Campredon**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装TypeScript扩展。在搜索栏中，键入`brackets typescript`，然后从**Francois de Campredon**那里安装**Brackets
    TypeScript**扩展。
- en: As can be seen from the following screenshot, each extension has a **More info…**
    link – which will take you to the extension home page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，每个扩展都有一个**更多信息…**链接 - 这将带您到扩展主页。
- en: '![Installing Brackets](img/9665OS_01_11.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![安装括号](img/9665OS_01_11.jpg)'
- en: Brackets Extension manager interface
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 括号扩展管理器界面
- en: As well as the **Brackets TypeScript** extension, another useful extension is
    **Code Folding** by **Patrick Oladimeji**. This will allow you to collapse or
    expand sections of code in any file that you are editing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**Brackets TypeScript**扩展之外，另一个有用的扩展是**Patrick Oladimeji**的**Code Folding**。这将允许您折叠或展开您正在编辑的任何文件中的代码部分。
- en: Another great time-saver is **Emmet** by **Sergey Chikujonok**. Emmet (previously
    known as Zen Coding) uses a CSS-like short-hand, instead of traditional code snippets,
    to generate HTML. In this section, we will quickly show how Emmet can be used
    to generate HTML, just as a teaser. So go ahead and install the Emmet extension.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的时间节省者是**Sergey Chikujonok**的**Emmet**。 Emmet（以前称为Zen Coding）使用类似于CSS的简写，而不是传统的代码片段，来生成HTML。在本节中，我们将快速展示Emmet如何用于生成HTML，就像一个预告片一样。所以继续安装Emmet扩展。
- en: Creating a Brackets project
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个括号项目
- en: 'Brackets does not have the concept of a project per se, but instead just works
    off a root folder. Create a directory on your filesystem, and then open that folder
    in Brackets: **File** | **Open Folder**.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 括号本身并没有项目的概念，而是直接在根文件夹上工作。在文件系统上创建一个目录，然后在Brackets中打开该文件夹：**文件** | **打开文件夹**。
- en: 'Let''s now create a simple HTML page using Brackets. **Select File** | **New**,
    or *Ctrl* + *N*. With a blank file in front of us, we will use Emmet to generate
    our HTML. Type in the following Emmet string:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Brackets创建一个简单的HTML页面。选择**文件** | **新建**，或按*Ctrl* + *N*。在我们面前有一个空白文件时，我们将使用Emmet来生成我们的HTML。输入以下Emmet字符串：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now hit *Ctrl* + *Alt* + *Enter*, or from the **File menu**, select **Emmet**
    | **Expand Abbreviation**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下*Ctrl* + *Alt* + *Enter*，或从**文件菜单**中，选择**Emmet** | **展开缩写**。
- en: 'Voila! Emmet has generated the following HTML code in a millisecond - not bad
    for one line of source code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！Emmet在一毫秒内生成了以下HTML代码 - 对于一行源代码来说还不错。
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hit *Ctrl* + *S* to save the file, and enter `index.html`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *S*保存文件，并输入`index.html`。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only once we have saved a file, does Brackets start to do syntax highlighting
    based on the file extension. This is true of any Brackets file, so once you have
    created a file – TypeScript, CSS or HTML, save it to disk as soon as you can.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们保存了文件之后，括号才会根据文件扩展名进行语法高亮。这对于任何括号文件都是真实的，所以一旦你创建了一个文件 - TypeScript，CSS或HTML，尽快将其保存到磁盘上。
- en: Back to Emmet.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Emmet。
- en: Emmet uses the `>` character to create a child, and the `+` character to denote
    a sibling. If you specify curly braces `{ }` next to an element, this will be
    used as the text content.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Emmet使用`>`字符来创建子元素，使用`+`字符来表示兄弟元素。如果在元素旁边指定花括号`{ }`，这将被用作文本内容。
- en: 'The Emmet string that we entered previously basically said: "create an `html`
    tag with a child `head` tag. Then create another child tag of `html` named `body`,
    create a child `h3` tag with the text `"index.html"`, and then create a sibling
    `div` tag as a child of `body` with the `id` of `content`." Definitely head over
    to [http://emmet.io](http://emmet.io) for further documentation, and remember
    to keep the cheat-sheet handy ([http://docs.emmet.io/cheat-sheet](http://docs.emmet.io/cheat-sheet)),
    when you are learning Emmet string shortcuts.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前输入的Emmet字符串基本上是这样说的：“创建一个带有子`head`标签的`html`标签。然后创建另一个名为`body`的`html`标签的子标签，创建一个带有文本`"index.html"`的子`h3`标签，然后创建一个兄弟`div`标签作为`body`的子标签，其`id`为`content`。”一定要前往[http://emmet.io](http://emmet.io)获取更多文档，并记得在学习Emmet字符串快捷方式时保持速查表方便（[http://docs.emmet.io/cheat-sheet](http://docs.emmet.io/cheat-sheet)）。
- en: 'Now lets finish off our `index.html` with an `app.js` script to load our TypeScript
    generated JavaScript file. Move your cursor in-between the `<head></head>` tags,
    and type another Emmet string:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个`app.js`脚本来完成我们的`index.html`，以加载我们生成的TypeScript JavaScript文件。将光标移动到`<head></head>`标签之间，然后输入另一个Emmet字符串：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now hit *Ctrl* + *Alt* + *Enter*, to have Emmet generate a `<script src="img/code>
    tag, and conveniently place your cursor between the quotes ready for you to simply
    fill in the blanks. Now type the JavaScript filename, `app.js`.`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下*Ctrl* + *Alt* + *Enter*，让Emmet生成一个`<script src="img/code>`标签，并方便地将光标放在引号之间，准备让您简单地填写空白。现在键入JavaScript文件名`app.js`。
- en: '`Your completed index.html file should now look as follows:`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的index.html文件现在应该如下所示：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`This is all we need for our sample HTML page.`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们样本HTML页面所需要的全部内容。
- en: '`Using Brackets live preview`'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Brackets实时预览
- en: '`Within Brackets, click on the **live preview** icon on the far right of the
    screen – it''s the electric zig zag one – just above the lego-block packages icon.
    This will launch Chrome and render our `index.html` in live preview mode. Just
    to show how Brackets can be used for live preview, keep this Chrome window visible,
    and navigate back to Brackets. You should be able to see both windows at the same
    time.`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，点击屏幕右侧的**实时预览**图标 - 它是电动的，就在乐高积木包图标的上方。这将启动Chrome并以实时预览模式渲染我们的`index.html`。为了展示Brackets可以用于实时预览，保持这个Chrome窗口可见，并导航回Brackets。您应该能够同时看到两个窗口。
- en: '`Now edit the `index.html` file, and type the following Emmet shorthand under
    your `<div id="content"></div>` element:`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑`index.html`文件，在`<div id="content"></div>`元素下键入以下Emmet快捷方式：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Again, hit *Ctrl* + *Alt* + *Enter*, and note how the generated `<ul>` and
    `<li>` tags (5 of them) are automatically displayed in your Chrome browser. As
    you move your caret up or down in the source code, notice how the blue outline
    in Chrome shows the element in the web page.`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次按下*Ctrl* + *Alt* + *Enter*，注意生成的`<ul>`和`<li>`标签（共5个）如何自动显示在Chrome浏览器中。当您在源代码中上下移动光标时，注意Chrome中的蓝色轮廓如何显示网页中的元素。
- en: '`![Using Brackets live preview](img/9665OS_01_12.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用Brackets实时预览](img/9665OS_01_12.jpg)'
- en: Brackets running Chrome in live preview mode, showing highlighted elements`
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Brackets在实时预览模式下运行Chrome，显示突出显示的元素
- en: '`We won''t be needing these `<ul> <li>` tags for our application, so simply
    *Ctrl* + *Z*, *Ctrl* + *Z* to undo our changes, or delete the tags.`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要这些`<ul> <li>`标签用于我们的应用程序，所以简单地按下*Ctrl* + *Z*，*Ctrl* + *Z*来撤消我们的更改，或者删除这些标签。
- en: '`Creating a TypeScript file`'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个TypeScript文件
- en: '`To create our very simple TypeScript application, hit *Ctrl* + *N* (new file),
    *Ctrl* + *S* (save file) and use `app.ts` as your file name. Start typing the
    following code, and notice how Brackets also does autocompletion, or Intellisense
    on the fly, similar to Visual Studio and WebStorm:`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们非常简单的TypeScript应用程序，按下*Ctrl* + *N*（新建文件），*Ctrl* + *S*（保存文件），并使用`app.ts`作为文件名。开始输入以下代码，并注意Brackets也会实时自动完成，或者类似于Visual
    Studio和WebStorm的智能感知功能：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`This is the same code that we used previously, and simply creates a TypeScript
    class named `MyClass` that has a single `render` function. This `render` function
    gets a DOM element, and modifies it''s `innerHTML` property. The `window.onload`
    function creates an instance of this class, then calls the `render` function with
    the appropriate parameters.`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前使用的相同代码，简单地创建了一个名为`MyClass`的TypeScript类，该类有一个`render`函数。这个`render`函数获取一个DOM元素，并修改它的`innerHTML`属性。`window.onload`函数创建了这个类的一个实例，然后使用适当的参数调用`render`函数。
- en: '`If you save the file by hitting *Ctrl* + *S* at any stage, Brackets will invoke
    the TypeScript language engine to verify our TypeScript, and render any errors
    in the bottom window pane. In the following screenshot, we can clearly see that
    we are missing a closing brace `}`.`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何阶段按下*Ctrl* + *S*保存文件，Brackets将调用TypeScript语言引擎来验证我们的TypeScript，并在底部窗格中呈现任何错误。在下面的截图中，我们可以清楚地看到我们缺少一个闭合大括号`}`。
- en: '`![Creating a TypeScript file](img/9665OS_01_13.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建一个TypeScript文件](img/9665OS_01_13.jpg)'
- en: Brackets editing a TypeScript file and showing compile errors`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Brackets编辑一个TypeScript文件并显示编译错误
- en: '`Brackets will not invoke the TypeScript compiler to generate an `app.js` file
    – it just parses the TypeScript code at this stage, and highlights any errors.
    Double-clicking on the error in the **TypeScript Problem** pane will jump to the
    line in question.`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Brackets不会调用TypeScript编译器来生成`app.js`文件 - 它只是在这个阶段解析TypeScript代码，并突出显示任何错误。在**TypeScript问题**窗格中双击错误将跳转到相关行。
- en: '`Compiling our TypeScript`'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译我们的TypeScript
- en: '`Before we are able to run our application, we will need to compile the `app.ts`
    file into an `app.js` file by invoking the TypeScript compiler. Open up a Command
    Prompt, change to your source directory, and simply type:`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够运行应用程序之前，我们需要通过调用TypeScript编译器将`app.ts`文件编译成一个`app.js`文件。打开命令提示符，切换到您的源目录，然后简单地输入：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`This command will invoke the `tsc` command line compiler, and create an `app.js`
    file from our `app.ts` file.`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将调用`tsc`命令行编译器，并从我们的`app.ts`文件创建一个`app.js`文件。
- en: '`Now that we have an `app.js` file in this directory, we can invoke the **live
    preview** button again, and now see that our TypeScript application has indeed
    rendered the **Hello world!** text as the `innerHTML` of the content `div`:`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这个目录中有一个`app.js`文件，我们可以再次调用**实时预览**按钮，现在可以看到我们的TypeScript应用程序确实将**Hello
    world!**文本呈现为内容`div`的`innerHTML`：
- en: '`![Compiling our TypeScript](img/9665OS_01_14.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![编译我们的TypeScript](img/9665OS_01_14.jpg)'
- en: Brackets live preview running our TypeScript application`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Brackets实时预览运行我们的TypeScript应用程序
- en: '`Using Grunt`'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Grunt
- en: '`Obviously, it is going to be very tedious to have to switch to the Command
    Prompt and manually compile each TypeScript file every time we have made a change.
    Grunt is an automated task runner ([http://gruntjs.com](http://gruntjs.com)) that
    can automate many tedious compile, build, and testing tasks. In this section,
    we will use Grunt to watch TypeScript files, and invoke the `tsc` compiler when
    a file is saved. This is very similar to WebStorm''s file watch functionality
    that we used earlier.`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每次我们进行更改时都必须切换到命令提示符并手动编译每个TypeScript文件将会非常乏味。Grunt是一个自动化任务运行器（[http://gruntjs.com](http://gruntjs.com)），可以自动化许多乏味的编译、构建和测试任务。在本节中，我们将使用Grunt来监视TypeScript文件，并在保存文件时调用`tsc`编译器。这与我们之前使用的WebStorm文件监视功能非常相似。
- en: '`Grunt runs in a Node environment. Node is an open-source, cross platform runtime
    environment, whose programs are written in JavaScript. To run Grunt, we will therefore
    need to install Node. Installers for Windows, Linux and OS X can be found from
    the Node website ([http://nodejs.org/](http://nodejs.org/)). Once Node is installed,
    we can use **npm** (**Node package manager**) to install Grunt and the Grunt command
    line interface.`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt在Node环境中运行。Node是一个开源的跨平台运行时环境，其程序是用JavaScript编写的。因此，要运行Grunt，我们需要安装Node。Windows、Linux和OS
    X的安装程序可以在Node网站([http://nodejs.org/](http://nodejs.org/))上找到。安装Node后，我们可以使用**npm**（**Node包管理器**）来安装Grunt和Grunt命令行界面。
- en: '`Grunt needs to be installed as an npm dependency of your project. It cannot
    be installed globally, the way most npm packages can. In order to do this, we
    will need to create a `packages.json` file in the root project. Open up a Command
    Prompt, and navigate to the root directory of your Brackets project. Then simply
    type:`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt需要作为项目的npm依赖项安装。它不能像大多数npm包那样全局安装。为了做到这一点，我们需要在项目的根目录中创建一个`packages.json`文件。打开命令提示符，并导航到Brackets项目的根目录。然后简单地输入：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`And follow the prompts. You can pretty much leave all of the options as their
    default, and always go back to edit the `packages.json` file that is created from
    this step, should you need to tweak any changes. With the package initialization
    step complete, we can now install Grunt as follows:`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照提示操作。您几乎可以将所有选项保留为默认设置，并始终返回编辑从此步骤创建的`packages.json`文件，以便在需要调整任何更改时进行编辑。完成包初始化步骤后，我们现在可以按照以下方式安装Grunt：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`The `-save-dev` option will install a local version of Grunt in the project
    directory. This is done so that multiple projects on your machine can use different
    versions of Grunt. We will also need the `grunt-typescript` package, as well as
    the `grunt-contrib-watch` package. These can be installed with the following npm
    commands:`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: -save-dev选项将在项目目录中安装Grunt的本地版本。这样做是为了确保您的计算机上的多个项目可以使用不同版本的Grunt。我们还需要安装`grunt-typescript`包，以及`grunt-contrib-watch`包。这些可以使用以下npm命令安装：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Lastly, we will need a `GruntFile.js` as the entry point for Grunt. Using
    Brackets, create a new file, save it as `GruntFile.js`, and enter the following
    JavaScript. Note that we are creating a JavaScript file here, not a TypeScript
    file. You can find a copy of this file in the sample source code that accompanies
    this chapter.`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`GruntFile.js`作为Grunt的入口点。使用Brackets，创建一个新文件，保存为`GruntFile.js`，并输入以下JavaScript。请注意，这里我们创建的是JavaScript文件，而不是TypeScript文件。您可以在本章附带的示例源代码中找到此文件的副本。
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`This `GruntFile.js` is necessary to setup all of the Grunt tasks. It is a
    simple function that Grunt uses to initialize the Grunt environment, and specify
    the Grunt commands. The first two lines of the function are loading `grunt-typescript`
    and `grunt-contrib-watch` tasks, and then runs the `grunt.initConfig` function
    with a configuration section. This configuration section has a `pkg` property,
    a `typescript` property and a `watch` property. The `pkg` property is set by reading
    the `package.json` file that we created earlier as part of the npm init step.`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`GruntFile.js`是设置所有Grunt任务所必需的。它是一个简单的函数，Grunt用它来初始化Grunt环境，并指定Grunt命令。函数的前两行加载了`grunt-typescript`和`grunt-contrib-watch`任务，然后运行了带有配置部分的`grunt.initConfig`函数。这个配置部分有一个`pkg`属性，一个`typescript`属性和一个`watch`属性。`pkg`属性是通过读取我们之前创建的`package.json`文件来设置的，这是npm
    init步骤的一部分。
- en: '`The `typescript` property has a `base` property, in which we are specifying
    that the source should be `''**/*.ts''` – in other words, all `.ts` files in any
    subdirectory. We are also specifying some TypeScript options – using `''commonjs''`
    modules instead of `''amd''` modules, and generating sourcemaps.`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`typescript`属性有一个`base`属性，在其中我们指定源代码应该是`''**/*.ts''` - 换句话说，任何子目录中的所有`.ts`文件。我们还指定了一些TypeScript选项
    - 使用`''commonjs''`模块而不是`''amd''`模块，并生成sourcemaps。'
- en: '`The `watch` property has two sub-properties. The `files` property specifies
    to watch for any `.ts` files in our source tree, and the `tasks` array specifies
    that we should kick off the TypeScript command once a file has been changed. Finally
    we call `grunt.registerTask`, specifying that the default task is to watch for
    file changes. Grunt will run in the background watching for saved files, and if
    found, will execute the TypeScript task.`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`属性有两个子属性。`files`属性指定要监视源树中的任何`.ts`文件，`tasks`数组指定一旦文件发生更改，我们应该启动TypeScript命令。最后，我们调用`grunt.registerTask`，指定默认任务是监视文件更改。Grunt将在后台运行，监视保存的文件，如果找到，将执行TypeScript任务。'
- en: '`We can now run Grunt from the command line. Make sure that you are in the
    Brackets project base directory, and fire up Grunt:`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从命令行运行Grunt。确保您在Brackets项目的基本目录中，并启动Grunt：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Open up your `app.ts` file, make a small change (add a space or something),
    and then hit *Ctrl* + *S* to save. Now check back on the output from the Grunt
    command line. You should see something like this:`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`app.ts`文件，进行一些小改动（添加一个空格或其他内容），然后按下*Ctrl* + *S*进行保存。现在检查Grunt命令行的输出。您应该会看到类似以下的内容：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`This command line output is confirmation that the Grunt watch task has identified
    `app.ts` has having changed, run the TypeScript task, created two files, and is
    now waiting for the next file to change. Flicking back to Brackets, we should
    now see the `app.js` file created by Grunt in the Brackets file pane.`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行输出证实了Grunt watch任务已经确认`app.ts`文件已经发生了变化，运行了TypeScript任务，创建了两个文件，现在正在等待下一个文件的变化。回到Brackets，我们现在应该在Brackets文件窗格中看到Grunt创建的`app.js`文件。
- en: '`Debugging in Chrome`'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Chrome中调试
- en: '`Since Brackets is just being used as an editor, we will need to debug our
    applications using the standard Chrome development tools. One option that we specified
    in our `GruntFile.js` for TypeScript was to turn on sourcemaps (`options { sourceMap
    : true }`). With this option, Chrome – and other browsers – can map the running
    JavaScript back to the source TypeScript file. This means that you can set the
    debugger breakpoints in your TypeScript file, and walk through your TypeScript
    file while debugging.`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '由于Brackets只是作为编辑器使用，我们需要使用标准的Chrome开发工具来调试我们的应用程序。我们在`GruntFile.js`中指定的一个选项是打开sourcemap（`options
    { sourceMap : true }`）。有了这个选项，Chrome - 和其他浏览器 - 可以将运行的JavaScript映射回源TypeScript文件。这意味着您可以在TypeScript文件中设置调试器断点，并在调试时遍历TypeScript文件。'
- en: '`To debug our sample app, firstly get the `index.html` page running in **Live
    Preview** mode, and hit *F12* to bring up the development tools. Chrome has a
    number of tools available for developers, including Network, Console, and Elements
    to inspect the DOM. Click on the **Sources** tab and hit *Ctrl* + *P* to open
    a file. Scroll down to `app.ts`, and hit *Enter*. Put a breakpoint on line 9 (
    `var myClass = new MyClass()`), and then re-load the page.`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试我们的示例应用程序，首先在**实时预览**模式下运行`index.html`页面，然后按下*F12*以打开开发工具。Chrome为开发人员提供了许多工具，包括Network、Console和Elements来检查DOM。点击**Sources**选项卡，按下*Ctrl*
    + *P*打开文件。滚动到`app.ts`，然后按下*Enter*。在第9行（`var myClass = new MyClass()`）设置断点，然后重新加载页面。
- en: '`Chrome should pause the page in debugger mode as follows:`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome应该在调试器模式下暂停页面，方法如下：
- en: '`![Debugging in Chrome](img/9665OS_01_15.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Chrome中调试](img/9665OS_01_15.jpg)'
- en: Brackets debugging TypeScript using Chrome development tools.`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 括号调试TypeScript使用Chrome开发工具。
- en: '`You can now use all of the Chrome debugging tools to your heart''s content.`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '现在您可以尽情使用所有Chrome调试工具。 '
- en: '`# Summary'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '# 总结'
- en: In this chapter we have had a quick look at what TypeScript is, and what benefits
    it can bring to the JavaScript development experience. We also looked at setting
    up a development environment using two popular commercial IDEs, and one open-source
    development environment. Now that we have a development environment setup, we
    can start looking at the TypeScript language itself in a bit more detail. We will
    start with types, move on to variables, and then discuss functions in the next
    chapter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速了解了TypeScript是什么，以及它可以为JavaScript开发体验带来什么好处。我们还看了如何使用两种流行的商业IDE和一个开源开发环境来设置开发环境。现在我们已经设置好了开发环境，可以开始更详细地了解TypeScript语言。我们将从类型开始，然后转向变量，然后在下一章讨论函数。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
