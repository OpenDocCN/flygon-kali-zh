- en: 12\. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 最佳实践
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn some of the best practices to use when working
    with Docker and your container images. This will enable you to monitor and manage
    the resources used by your container and limit their effect on your host system.
    You will analyze Docker's best practices and learn why it's important to only
    be running one service per container, ensuring that your containers are scalable
    and immutable and making sure that your underlying applications start in a short
    amount of time. This chapter will help you to enforce these best practices by
    linting your `Dockerfiles` and `docker-compose.yml` files before your applications
    and containers are running with the help of `hadolint's` `FROM:latest` command
    and `dcvalidator`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习一些在使用 Docker 和容器镜像时的最佳实践，这将使您能够监视和管理容器使用的资源，并限制其对主机系统的影响。您将分析 Docker
    的最佳实践，并了解为什么重要的是只在一个容器中运行一个服务，确保您的容器是可扩展的和不可变的，并确保您的基础应用程序在短时间内启动。本章将通过使用 `hadolint`
    的 `FROM:latest` 命令和 `dcvalidator` 在应用程序和容器运行之前对您的 `Dockerfiles` 和 `docker-compose.yml`
    文件进行检查，以帮助您强制执行这些最佳实践。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The previous chapter on security covered some best practices for Docker images
    and services that have adhered to these best practices. We made sure that our
    images and services were secure and that they limited what could be achieved if
    an attacker was able to access the image. This chapter will not only take you
    through the best practices in creating and running our Docker images, but will
    also focus on container performance, configuring our services, and ensuring that
    the services running on them are running as efficiently as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的前一章涵盖了一些 Docker 镜像和服务的最佳实践，这些实践已经遵循了这些最佳实践。我们确保我们的镜像和服务是安全的，并且限制了如果攻击者能够访问镜像时可以实现的内容。本章不仅将带您了解创建和运行
    Docker 镜像的最佳实践，还将关注容器性能、配置我们的服务，并确保运行在其中的服务尽可能高效地运行。
- en: We will start this chapter with an in-depth look at how you can both monitor
    and configure the resources being used by your services, such as memory and CPU
    usage. We will then take you through some important practices that you can implement
    in your projects, looking at how you create your Docker images and the applications
    that are running on them. Lastly, this chapter will give you some practical tools
    to use to test your `Dockerfiles` and `docker-compose.yml` files, which will serve
    as a way to ensure that you are following the mentioned practices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从深入了解如何监视和配置服务使用的资源开始，比如内存和 CPU 使用情况。然后，我们将带您了解一些您可以在项目中实施的重要实践，看看您如何创建 Docker
    镜像以及在其上运行的应用程序。最后，本章将为您提供一些实用工具，用于测试您的 `Dockerfiles` 和 `docker-compose.yml` 文件，这将作为一种确保您遵循所述实践的方式。
- en: This chapter shows how you can ensure that you optimize your services and containers
    as much as possible to make sure that they run without issues from your development
    environment through to production. The goal of this chapter is to make sure that
    your services are starting up as quickly as possible and are processing as efficiently
    as they can. The practices mentioned in this chapter also ensure reusability (that
    is, they make sure that anyone who wants to reuse your images or code can do so
    and can understand specifically what is happening at all times). To begin with,
    the following section discusses how to work with container resources.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何确保尽可能优化您的服务和容器，以确保它们从开发环境到生产环境都能无故障地运行。本章的目标是确保您的服务尽快启动，并尽可能高效地处理。本章提到的实践还确保了可重用性（也就是说，他们确保任何想要重用您的镜像或代码的人都可以这样做，并且可以随时了解具体发生了什么）。首先，以下部分讨论了如何使用容器资源。
- en: Working with Container Resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器资源
- en: One of the main benefits of moving to Docker from a traditional server environment
    is that it enables us to heavily reduce the footprint of our services and applications,
    even when moving to production. This doesn't mean we can simply run anything on
    our container, expecting all the processes to simply complete their execution,
    however. Just as we would need resources with a service running on a standalone
    server, we need to ensure that the resources (such as CPU, memory, and disk input
    and output) that are being used by our containers do not cause our production
    environments or any other containers to crash. By monitoring the resources used
    in our development system, we can help optimize processes and ensure that the
    end-user is experiencing seamless operation when we move it into production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统服务器环境迁移到Docker的主要好处之一是，即使在转移到生产环境时，它使我们能够大大减少服务和应用程序的占用空间。然而，这并不意味着我们可以简单地在容器上运行任何东西，期望所有进程都能顺利完成执行。就像在独立服务器上运行服务时一样，我们需要确保我们的容器使用的资源（如CPU、内存和磁盘输入输出）不会导致我们的生产环境或任何其他容器崩溃。通过监控开发系统中使用的资源，我们可以帮助优化流程，并确保最终用户在将其移入生产环境时体验到无缝操作。
- en: By testing our services and monitoring resource usage, we will be able to understand
    the resources required by the running applications and ensure that the hosts running
    our Docker images have adequate resources to run our service. Lastly, as you will
    see in the upcoming sections, we can also limit the amount of CPU and memory resources
    the container can have access to. When developing our services running on Docker,
    we need to be testing these services on our development system to know exactly
    what will happen when they are moved into test and production environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试我们的服务并监控资源使用情况，我们将能够了解运行应用程序所需的资源，并确保运行我们Docker镜像的主机具有足够的资源来运行我们的服务。最后，正如您将在接下来的章节中看到的，我们还可以限制容器可以访问的CPU和内存资源的数量。在开发运行在Docker上的服务时，我们需要在开发系统上测试这些服务，以确切了解它们在移入测试和生产环境时会发生什么。
- en: When we bring a number of different services (such as a database, web server,
    and API gateway) together to create an application, some services are more important
    than others, and in some circumstances, these services may need to have more resources
    allocated to them. However, in Docker, the running container does not have a real
    limit on the resources it can use by default.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将多种不同的服务（如数据库、Web服务器和API网关）组合在一起创建一个应用程序时，有些服务比其他服务更重要，在某些情况下，这些服务可能需要分配更多资源。然而，在Docker中，运行的容器默认情况下并没有真正的资源限制。
- en: In previous chapters, we learned about orchestration using Swarm and Kubernetes,
    which helps in distributing resources across your system, but this part of the
    chapter will teach you about some basic tools to test and monitor your resources
    with. We will also look at the ways in which you can configure your containers
    to no longer use the default resources available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了使用Swarm和Kubernetes进行编排，这有助于在系统中分配资源，但本章的这一部分将教您一些基本工具来测试和监视您的资源。我们还将看看您可以如何配置您的容器，以不再使用默认可用的资源。
- en: To help us in this part of the chapter, we are going to create a new image that
    will only serve the purpose of demonstrating resource usage in our system. In
    the first part of this section, we will create an image that will add an application
    called stress. The main function of the stress application is to impose a heavy
    load on our system. The image will allow us to view the resources being used on
    our host system and then allow us to use different options when running the Docker
    image to limit the resources being used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们在本章的这一部分，我们将创建一个新的镜像，该镜像将仅用于演示我们系统中的资源使用情况。在本节的第一部分中，我们将创建一个将添加一个名为stress的应用程序的镜像。stress应用程序的主要功能是对我们的系统施加重负载。该镜像将允许我们查看在我们的主机系统上使用的资源，然后允许我们在运行Docker镜像时使用不同的选项来限制使用的资源。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section of the chapter will give you some brief guidelines on monitoring
    the resources of our running Docker containers. This chapter will only cover some
    simple concepts as we are going to be dedicating an entire chapter of this book
    to providing in-depth details on monitoring your container metrics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分将为您提供有关监视我们正在运行的Docker容器资源的简要指南。本章将仅涵盖一些简单的概念，因为我们将在本书的另一章节中专门提供有关监视容器指标的深入细节。
- en: 'To help us view the resources being consumed by our running containers, Docker
    provides the `stats` command as a live stream of resources being consumed by our
    running containers. If you wish to limit the data presented by the stream, especially
    if you have a large number of containers running, you can specify to only provide
    certain containers by specifying the name of the container or its ID:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们查看正在运行的容器消耗的资源，Docker提供了`stats`命令，作为我们正在运行的容器消耗资源的实时流。如果您希望限制流所呈现的数据，特别是如果您有大量正在运行的容器，您可以通过指定容器的名称或其ID来指定只提供某些容器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The default output of the `docker` `stats` command will provide you with the
    name and ID of the container, the percentage of host CPU and memory that the container
    is using, the data that the container is sending and receiving, and the amount
    of data both read and written from the host''s storage:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` `stats`命令的默认输出将为您提供容器的名称和ID，容器正在使用的主机CPU和内存的百分比，容器正在发送和接收的数据，以及从主机存储中读取和写入的数据量：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following section will highlight how we can use the `docker stats` command
    to monitor our resources. We will also provide format controls to the `stats`
    command to provide only the information we need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将重点介绍如何使用`docker stats`命令来监视我们的资源。我们还将向`stats`命令提供格式控制，以提供我们需要的信息。
- en: Managing Container CPU Resources
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器CPU资源
- en: This section of the chapter will show you how to set limits on the amount of
    CPU being used by the container, as a container running without limits can use
    up all the available CPU resources on a host server. We will be looking at optimizing
    our running Docker container, but the actual issue with a large amount of CPU
    being used usually lies with the underlying infrastructure or the applications
    running on the container.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分将向您展示如何设置容器使用的CPU数量限制，因为没有限制的容器可能会占用主机服务器上所有可用的CPU资源。我们将着眼于优化我们正在运行的Docker容器，但实际上大量使用CPU的问题通常出现在基础设施或容器中运行的应用程序上。
- en: When we discuss CPU resources, we usually refer to a single physical computer
    chip. These days, a CPU will most likely have more than one core, with more cores
    meaning more processes. But this doesn't mean we have unlimited resources. When
    we display the CPU percentage being used, unless you have a system that only has
    one CPU with one core, you will most likely see more than 100% of the CPU being
    used. For example, if you have four cores in the CPU of your system, and your
    container is utilizing all of the CPU, you will see a value of 400%
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论CPU资源时，通常是指单个物理计算机芯片。如今，CPU很可能有多个核心，更多的核心意味着更多的进程。但这并不意味着我们拥有无限的资源。当我们显示正在使用的CPU百分比时，除非您的系统只有一个CPU和一个核心，否则您很可能会看到超过100%的CPU使用率。例如，如果您的系统的CPU中有四个核心，而您的容器正在利用所有的CPU，您将看到400%的值。
- en: 'We can modify the `docker stats` command running on our system to only provide
    the CPU usage details by providing the `--format` option. This option allows us
    to specify the output format we require, as we may only require one or two of
    the metrics provided by the `stats` command. The following example configures
    the output of the `stats` command to be displayed in a `table` format, only presenting
    the container''s name, its ID, and the percentage of CPU being used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改在我们的系统上运行的`docker stats`命令，通过提供`--format`选项来仅提供CPU使用情况的详细信息。这个选项允许我们指定我们需要的输出格式，因为我们可能只需要`stats`命令提供的一两个指标。以下示例配置了`stats`命令的输出以以`table`格式显示，只呈现容器的名称、ID和正在使用的CPU百分比：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command, if we have no Docker images running, will provide a table with
    the following three columns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有运行Docker镜像，这个命令将提供一个包含以下三列的表格：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To control the number of cores being used on the CPU by our running container,
    we can use the `--cpus` option with our `docker run` command. The following syntax
    shows us running the image, but limiting the number of cores the image will have
    access to by using the `--cpus` option:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们正在运行的容器使用的CPU核心数量，我们可以在`docker run`命令中使用`--cpus`选项。以下语法向我们展示了运行镜像，但通过使用`--cpus`选项限制了镜像可以访问的核心数量：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A better option is not to set the number of cores a container can use, but instead
    how much of the total it can share. Docker provides the `--cpushares`, or `-c`,
    option to set a priority to how much of the processing power a container can use.
    By using this option, it means we don't need to know how many cores the host machine
    has before running the container. It also means that we can transfer the running
    container to different host systems without needing to change the command the
    image is run with.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择不是设置容器可以使用的核心数量，而是设置它可以共享的总量。Docker提供了`--cpushares`或`-c`选项来设置容器可以使用的处理能力的优先级。通过使用这个选项，这意味着在运行容器之前我们不需要知道主机机器有多少个核心。这也意味着我们可以将正在运行的容器转移到不同的主机系统，而不需要更改运行镜像的命令。
- en: 'By default, Docker will allocate 1,024 shares to every running container. If
    you set the `--cpushares` value to `256`, it would have a quarter of the processing
    shares of other running containers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker将为每个运行的容器分配1,024份份额。如果您将`--cpushares`值设置为`256`，它将拥有其他运行容器的四分之一的处理份额：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If no other containers are running on your system, even if you have set the
    `--cpushares` value to `256`, the container will then be allowed to use up the
    remaining processing power.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上没有运行其他容器，即使您已将`--cpushares`值设置为`256`，容器也将被允许使用剩余的处理能力。
- en: Even though your application may be running fine, it's always good practice
    to see how it will work when you reduce the amount of CPU it has available to
    it, as well as seeing how much it will consume while it is running normally.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的应用程序可能正在正常运行，查看减少其可用CPU量以及在正常运行时消耗多少的做法总是一个好习惯。
- en: In the next exercise, we will use the `stress` application to monitor the resource
    usage on the system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`stress`应用程序来监视系统上的资源使用情况。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`touch`命令创建文件，并使用`vim`命令使用vim编辑器处理文件。
- en: 'Exercise 12.01: Understanding CPU Resources on Your Docker Image'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：了解Docker镜像上的CPU资源
- en: 'In this exercise, you will first create a new Docker image that will help you
    generate some resources on your system. We will demonstrate how to use the `stress`
    application installed on the image. The application will allow you to start monitoring
    resource usage on your system, as well as allowing you to change the number of
    CPU resources being used by the image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将首先创建一个新的Docker镜像，这将帮助您在系统上生成一些资源。我们将演示如何在镜像上使用已安装的`stress`应用程序。该应用程序将允许您开始监视系统上的资源使用情况，以及允许您更改镜像使用的CPU资源数量：
- en: 'Create a new `Dockerfile` and open your favorite text editor to enter the following
    details. You will be creating the image using Ubuntu as a base because the `stress`
    application is not yet provided as a package to be easily installed on an Alpine
    base image:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Dockerfile`并打开您喜欢的文本编辑器输入以下细节。您将使用Ubuntu作为基础来创建镜像，因为`stress`应用程序尚未作为易于在Alpine基础镜像上安装的软件包提供：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build the new image and tag it as `docker-stress` using the `-t` option of
    the `docker build` command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`命令的`-t`选项构建新镜像并将其标记为`docker-stress`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Stop and remove all the other containers first before running the new `docker-stress`
    image to make sure that the results are not confused by other containers running
    on our system:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行新的`docker-stress`镜像之前，请先停止并删除所有其他容器，以确保结果不会被系统上运行的其他容器混淆：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On *line 3* of the `Dockerfile`, you''ll notice that the `CMD` instruction
    is running the stress application following the `$var` variable. This will allow
    you to add command-line options directly to the stress application running on
    the container via environment variables, without having to build a new image every
    time you want to change the functionality. Test this out by running your image
    and using the `-e` option to add environment variables. Add `var="--cpu 4 --timeout
    20"` as a command-line option to the `stress` command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dockerfile`的*第3行*上，您会注意到`CMD`指令正在运行stress应用程序，后面跟着`$var`变量。这将允许您通过环境变量直接向容器上运行的stress应用程序添加命令行选项，而无需每次想要更改功能时都构建新镜像。通过运行您的镜像并使用`-e`选项添加环境变量来测试这一点。将`var="--cpu
    4 --timeout 20"`作为`stress`命令的命令行选项添加：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `docker run` command has added the `var="--cpu 4 --timeout 20"` variable,
    which will specifically run the `stress` command with these command-line options.
    The `--cpu` option is stating that four CPUs or cores of the system will be used,
    and the `--timeout` option will allow the stress test to run for the designated
    number of seconds specified – in this case, `20`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令已添加了`var="--cpu 4 --timeout 20"`变量，这将特别使用这些命令行选项运行`stress`命令。`--cpu`选项表示将使用系统的四个CPU或核心，`--timeout`选项将允许压力测试运行指定的秒数
    - 在本例中为`20`：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we need to run the `stress` command continuously without stopping, we will
    simply not include the `--timeout` option. Our examples all include the `timeout`
    option as we don't want to forget and continuously use resources on a running
    host system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要连续运行`stress`命令而不停止，我们将简单地不包括`--timeout`选项。我们的示例都包括`timeout`选项，因为我们不想忘记并持续使用运行主机系统的资源。
- en: 'Run the `docker stats` command to see what effect this has on your host system.
    Limit the output provided to only give CPU usage by using the `--format` option:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker stats`命令，查看这对主机系统的影响。使用`--format`选项限制所提供的输出，只提供CPU使用情况：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unless you have a container running on your system, you should only see the
    table headings, similar to the output provided here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的系统上运行着一个容器，否则您应该只看到表头，类似于此处提供的输出：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the `stats` command is running, move into a new terminal window and run
    the `docker-stress` container again, as in *step 4* of this exercise. Use the
    `--name` option to make sure you are viewing the correct image when using the
    `docker stress` command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行`stats`命令的同时，进入一个新的终端窗口，并再次运行`docker-stress`容器，就像本练习的*步骤4*中一样。使用`--name`选项确保在使用`docker
    stress`命令时查看正确的镜像：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Move back to the terminal running `docker stats`. You should now see some output
    presented on your table. Your output will be different from the following as you
    may have a different number of cores running on your system. The following output
    is showing that 400% of our CPU percentage is being used. The system on which
    the command is run has six cores. It shows that the stress application is using
    100% of four of the cores available:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端。现在您应该看到一些输出呈现在您的表上。您的输出将与以下内容不同，因为您的系统上可能运行着不同数量的核心。以下输出显示我们的CPU百分比使用了400%。运行该命令的系统有六个核心。它显示stress应用程序正在使用四个可用核心中的100%：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, run the `docker-stress` container, this time with `8` set for the
    `--cpu` option:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`docker-stress`容器，这次将`--cpu`选项设置为`8`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see in the following stats output, we have hit the limit where your
    Docker container is using almost 100% of all six cores on our system, leaving
    a small amount for processing power for minor processes on our system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下统计输出中所见，我们已经达到了Docker容器几乎使用系统上所有六个核心的极限，为我们的系统上的次要进程留下了一小部分处理能力：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Manage the number of cores that your `docker-stress` image can have access
    to by using the `--cpus` option and specifying the number of cores you want to
    allow the image to use. In the following command, `2` is set as the number of
    cores our container is allowed to use:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`--cpus`选项并指定要允许镜像使用的核心数量，来管理您的`docker-stress`镜像可以访问的核心数量。在以下命令中，将`2`设置为我们的容器被允许使用的核心数量：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Move back to the terminal running `docker stats`. You will see that the CPU
    percentage being used does not exceed much more than 200%, showing that Docker
    is restricting resource usage to only two of the cores available on our system:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端。您将看到正在使用的CPU百分比不会超过200%，显示Docker将资源使用限制在我们系统上仅有的两个核心：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So far, you have only been running one container on our system at a time. The
    next section of this exercise will allow you to run two containers in detached
    mode. Here, you will test using the `--cpu-shares` option on one of your running
    containers to limit the number of cores it can use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只能一次在我们的系统上运行一个容器。这个练习的下一部分将允许您以分离模式运行两个容器。在这里，您将测试在运行的一个容器上使用`--cpu-shares`选项来限制它可以使用的核心数量。
- en: 'If you don''t have `docker stats` running in a terminal window, do so by starting
    it up as you have done previously to allow us to monitor the processes that are
    running:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有在终端窗口中运行`docker stats`，请像之前一样启动它，以便我们监视正在运行的进程：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Access another terminal window and start up two `docker-stress` containers
    – `docker-stress1` and `docker-stress2`. The first will use a `--timeout` value
    of `60` to have the stress application running for 60 seconds, but here, limit
    the `--cpu-shares` value to `512`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问另一个终端窗口，并启动两个`docker-stress`容器 - `docker-stress1`和`docker-stress2`。第一个将使用`--timeout`值为`60`，让压力应用程序运行60秒，但在这里，将`--cpu-shares`值限制为`512`：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The container''s ID will be returned as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的ID将返回如下：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second container will not be limited but will have a `--timeout` value
    of only `30`, so it should complete first:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器将不受限制，但`--timeout`值只有`30`，所以它应该先完成：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The container''s ID will be returned as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的ID将返回如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Move back to our terminal running `docker stats`. You''ll see two containers
    running. In the following output, we can see the containers named `docker-stress1`
    and `docker-stress2`. The `docker-stress1` container has been set to have only
    `512` CPU shares while other containers are running. It can also be observed that
    it is only using half the amount of CPU resources as our second container named
    `docker-stress2`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到运行`docker stats`的终端。您会看到两个容器正在运行。在以下输出中，我们可以看到名为`docker-stress1`和`docker-stress2`的容器。`docker-stress1`容器被设置为只有`512`
    CPU份额，而其他容器正在运行。还可以观察到它只使用了第二个名为`docker-stress2`的容器的一半CPU资源：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When your second container completes the CPU percentage for the `docker-stress1`
    container, it is then allowed to move up to using almost all six cores available
    on the running system:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第二个容器完成后，`docker-stress1`容器的CPU百分比将被允许使用运行系统上几乎所有六个可用的核心：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: CPU resources play an important part in making sure that your applications are
    running at their best. This exercise has shown you how easy it is to monitor and
    configure your container's processing power while it is still on your system before
    deploying it into a production environment. The next section will move on to performing
    similar monitoring and configuration changes on our container's memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CPU资源在确保应用程序以最佳状态运行方面起着重要作用。这个练习向您展示了在将容器部署到生产环境之前，监视和配置容器的处理能力有多么容易。接下来的部分将继续对容器的内存执行类似的监视和配置更改。
- en: Managing Container Memory Resources
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器内存资源
- en: Just as we can monitor and control the CPU resources our container is using
    on our system, we can also do the same with the memory being used. As with CPU,
    the running container is able to use all of the host's memory with the default
    settings provided by Docker, and in some cases can cause the system to become
    unstable if it is not limited. If the host systems kernel detects that there is
    not enough memory available, it will show an **out-of-memory exception** and start
    to kill off the processes on the system to help free up memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以监视和控制容器在系统上使用的CPU资源一样，我们也可以对内存的使用情况进行相同的操作。与CPU一样，默认情况下，运行的容器可以使用主机的所有内存，并且在某些情况下，如果没有限制，可能会导致系统变得不稳定。如果主机系统内核检测到没有足够的内存可用，它将显示**内存不足异常**并开始终止系统上的进程以释放内存。
- en: The good news is that the Docker daemon has a high priority on your system,
    so the kernel will first kill off running containers before it stops the Docker
    daemon from running. This means that your system should be able to recover if
    the high memory usage is being caused by a container application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Docker守护程序在您的系统上具有高优先级，因此内核将首先终止运行的容器，然后才会停止Docker守护程序的运行。这意味着如果高内存使用是由容器应用程序引起的，您的系统应该能够恢复。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your running containers are being shut down, you will also need to make sure
    you have tested your application to ensure that you are limiting the impact it
    is having on your running processes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的运行容器正在被关闭，您还需要确保已经测试了您的应用程序，以确保它对正在运行的进程的影响是有限的。
- en: 'Once again, the `docker stats` command gives us quite a bit of information
    on memory usage. It will output the percentage of the memory the container is
    using as well as the current memory being used compared with the total amount
    of memory it is able to use. As we did previously, we can restrict the output
    presented with the `--format` option. In the following command, we are reducing
    the output provided by only displaying the container name and ID, as well as the
    memory percentage and memory usage, via the `.Name`, `.Container`, `.MemPerc`,
    and `.MemUsage` attributes, respectively:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`docker stats`命令为我们提供了关于内存使用情况的大量信息。它将输出容器正在使用的内存百分比，以及当前内存使用量与其能够使用的总内存量的比较。与之前一样，我们可以通过`--format`选项限制所呈现的输出。在以下命令中，我们通过`.Name`、`.Container`、`.MemPerc`和`.MemUsage`属性，仅显示容器名称和ID，以及内存百分比和内存使用量：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With no containers running, the preceding command will show the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有运行的容器，上述命令将显示以下输出：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to limit or control the amount of memory being used by our running
    container, there are a few options available to us. One of the options available
    is the `--memory`, or `-m`, option, which will set a limit for the amount of memory
    a running container can use. In the following example, we have used a syntax of
    `--memory 512MB` to limit the amount of memory available to the image to `512MB`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制或控制运行容器使用的内存量，我们有一些选项可供选择。其中一个可用的选项是`--memory`或`-m`选项，它将设置运行容器可以使用的内存量的限制。在以下示例中，我们使用了`--memory
    512MB`的语法来限制可用于镜像的内存量为`512MB`：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the host system that the container is running on is also using swap space
    as part of its available memory, you can also assign memory from that container
    to be run as swap. This is simply done by using the `--memory-swap` option. This
    can only be used in conjunction with the `--memory` option, as we have demonstrated
    in the following example. We have set the `--memory-swap` option as `1024MB`,
    which is the total amount of memory available to the container of both memory
    and swap memory. So, in our example, there will be a further `512MB` available
    in the swap:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器正在运行的主机系统也在使用交换空间作为可用内存的一部分，您还可以将内存从该容器分配为交换空间。这只需使用`--memory-swap`选项即可。这只能与`--memory`选项一起使用，正如我们在以下示例中所演示的。我们已将`--memory-swap`选项设置为`1024MB`，这是容器可用内存的总量，包括内存和交换内存。因此，在我们的示例中，交换空间中将有额外的`512MB`可用：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You need to remember, though, that swap memory will be assigned to disk, so
    as a consequence, it will be slower and less responsive than RAM.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但需要记住，交换内存将被分配到磁盘，因此会比RAM更慢、响应更慢。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `--memory-swap` option needs to be set to a number higher than the `--memory`
    option. If it is set to the same number, you will not be able to assign any memory
    from that running container to swap.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`--memory-swap`选项需要设置为高于`--memory`选项的数字。如果设置为相同的数字，您将无法为运行的容器分配任何内存到交换空间。'
- en: 'Another option available, and only to be used if you need to ensure the availability
    of the running container at all times, is the `--oom-kill-disable` option. This
    option stops the kernel from killing the running container if the host system
    runs too low on memory. This should only be used together with the `--memory`
    option to ensure that you set a limit to the memory available to the container.
    Without a limit, the `--oom-kill-disable` option could easily use all the memory
    on the host system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用的选项，只有在需要确保运行容器始终可用时才能使用的是`--oom-kill-disable`选项。此选项会阻止内核在主机系统内存过低时杀死运行的容器。这应该只与`--memory`选项一起使用，以确保您设置了容器可用内存的限制。如果没有限制，`--oom-kill-disable`选项很容易使用主机系统上的所有内存：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though your applications will be well designed, the preceding configurations
    give you some options to control the amount of memory being used by your running containers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您的应用程序设计良好，但前面的配置为您提供了一些选项来控制运行容器使用的内存量。
- en: The next section will provide you with hands-on experience in analyzing the
    memory resources on your Docker image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将为您提供在分析Docker镜像上的内存资源方面的实践经验。
- en: 'Exercise 12.02: Analyzing Memory Resources on Your Docker Image'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：分析Docker镜像上的内存资源
- en: 'This exercise will help you analyze how memory is used by your active containers
    while running on your host system. Once again, you will be using the `docker-stress`
    image created earlier, but this time with options to only use memory on the running
    container. This command will allow us to implement some of the memory-limiting
    options available to ensure our running containers do not bring down our running
    host system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习将帮助您分析在主机系统上运行时活动容器如何使用内存。再次使用之前创建的`docker-stress`镜像，但这次使用选项仅在运行容器上使用内存。这个命令将允许我们实现一些可用的内存限制选项，以确保我们运行的容器不会使主机系统崩溃：
- en: 'Run the `docker stats` command to display the relevant information you need
    for the percentage memory and memory usage values:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker stats`命令以显示所需的百分比内存和内存使用值的相关信息：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command will provide an output like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将提供以下类似的输出：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open a new terminal window to run the `stress` command again. Your `docker-stress`
    image will only utilize CPU when you use the `--cpu` option. Use the `--vm` option
    in the following command to start up the number of workers you wish to spawn to
    consume memory. By default, each of them will consume `256MB`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口再次运行`stress`命令。你的`docker-stress`镜像只有在使用`--cpu`选项时才会利用CPU。使用以下命令中的`--vm`选项来启动你希望产生的工作进程数量以消耗内存。默认情况下，每个工作进程将消耗`256MB`：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you move back to monitor the running container, the memory used only reached
    about 20% of the limit. This may be different for different systems. As only two
    workers are running to consume 256 MB each, you should only see it reach around
    500 MB of memory usage:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你返回监视正在运行的容器时，内存使用量只达到了限制的20%左右。这可能因不同系统而异。由于只有两个工作进程在运行，每个消耗256MB，你应该只会看到内存使用量达到大约500MB：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The stress application also has the `--vm-bytes` option to control the number
    of bytes that each worker being spawned up will consume. Enter the following command,
    which has set each worker to `128MB`. It should show a lower usage when you monitor
    it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压力应用程序还有`--vm-bytes`选项来控制每个被产生的工作进程将消耗的字节数。输入以下命令，将每个工作进程设置为`128MB`。当你监视它时，它应该显示较低的使用量：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the stress application struggles to push the memory usage up
    very far at all. If you wanted to use all 8 GB of RAM you have available on your
    system, you could use `--vm 8 --vm-bytes` of 1,024 MB:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，压力应用程序在推动内存使用量时并没有取得很大的进展。如果你想要使用系统上可用的全部8GB RAM，你可以使用`--vm 8 --vm-bytes`
    1,024 MB：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Reduce the amount of memory available to the `docker-stress` image with the
    `--memory` option. In the following command, you will see that we have set the
    available memory of the running container to be limited to `512MB`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--memory`选项减少`docker-stress`镜像可用的内存。在以下命令中，你会看到我们将正在运行的容器的可用内存限制为`512MB`：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Move back to the terminal running `docker stats`, and you will see that the
    percentage of memory used spikes to almost 100%. This isn''t a bad thing as it
    is only a small percentage of the memory allocated to your running container.
    In this instance, it is 512 MB, which is only a quarter of what it was previously:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端，你会看到内存使用率飙升到了接近100%。这并不是一件坏事，因为它只是你正在运行的容器分配的一小部分内存。在这种情况下，它是512MB，仅为之前的四分之一：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run more than one container at a time and see how our `stats` command responds.
    Use the `-d` option as part of the `docker run` commands to run the container
    as a daemon in the background of your host system. Both of the `docker-stress`
    containers are now going to use six workers each, but our first image, which we
    will name `docker-stress1`, is limited to `512MB` of memory, while our second
    image, named `docker-stress2`, which is only running for 20 seconds, will have
    an unlimited amount of memory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时运行多个容器，看看我们的`stats`命令如何响应。在`docker run`命令中使用`-d`选项将容器作为守护进程在主机系统的后台运行。现在，两个`docker-stress`容器都将使用六个工作进程，但我们的第一个镜像，我们将其命名为`docker-stress1`，被限制在`512MB`的内存上，而我们的第二个镜像，名为`docker-stress2`，只运行20秒，将拥有无限的内存：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Move back to the terminal running `docker stats`. You can see that only one
    container, the `docker-stress1` container, is limited to 512 MB, while the `docker-stress2`
    image is allowed to run on a lot more memory:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端。你会看到只有一个容器，即`docker-stress1`容器，被限制在512MB，而`docker-stress2`镜像被允许在更多的内存上运行：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you wait a few moments, the `docker-stress1` image will be left to run on
    its own:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待一会儿，`docker-stress1`镜像将被留下来独自运行：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One option we haven't covered here is the `--memory-reservation` option. This
    is also used with the `--memory` option and needs to be set lower than the memory
    option. It is a soft limit that is activated when the memory on the host system
    is running low, but it is not guaranteed that the limit will be enforced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有涵盖的一个选项是`--memory-reservation`选项。这也与`--memory`选项一起使用，并且需要设置为低于内存选项。这是一个软限制，当主机系统的内存不足时激活，但不能保证限制将被执行。
- en: This part of the chapter has helped to identify how you can run your containers
    and monitor usage so that when they are moved into production, they are not stopping
    the host system by using up all the available memory. You should now be able to
    identify how much memory your image is using and also limit the amount available
    if there are issues with long-running or memory-intensive processes. In the next
    section, we will look at how our container consumes the device's read and write
    resources on our host system disks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分帮助我们确定如何运行容器并监视使用情况，以便在将它们投入生产时，它们不会通过使用所有可用内存来停止主机系统。现在，您应该能够确定您的镜像正在使用多少内存，并在长时间运行或内存密集型进程出现问题时限制可用内存量。在下一节中，我们将看看我们的容器如何在主机系统磁盘上消耗设备的读写资源。
- en: Managing the Container Disk's Read and Write Resources
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器磁盘的读写资源
- en: The CPU and memory consumed by a running container are usually the biggest culprits
    for an environment running poorly, but there could also be an issue with your
    running containers trying to read or write too much to the host's disk drive.
    This would most likely have less impact than CPU or memory issues, but if there
    was a large amount of data being transferred to the host system's drives, it could
    still cause contention and slow your services down.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器消耗的CPU和内存通常是环境运行不佳的最大罪魁祸首，但您的运行容器也可能存在问题，尝试读取或写入主机的磁盘驱动器过多。这很可能对CPU或内存问题影响较小，但如果大量数据被传输到主机系统的驱动器上，仍可能引起争用并减慢服务速度。
- en: Fortunately, Docker also provides us with a way to control the amount of reading
    and writing that our running containers can perform. Just as we've seen previously,
    we can use a number of options with our `docker run` command to limit the amount
    of data we are either reading or writing to our device disks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker还为我们提供了一种控制运行容器执行读取和写入操作的方法。就像我们之前看到的那样，我们可以在`docker run`命令中使用多个选项来限制我们要读取或写入设备磁盘的数据量。
- en: 'The `docker stats` command also allows us to see the data being transferred
    to and from our running container. It has a dedicated column that can be added
    to our table using the `BlockIO` value in our `docker stats` command, which represents
    the read and writes to our host disk drive or directories:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker stats`命令还允许我们查看传输到和从我们的运行容器的数据。它有一个专用列，可以使用`docker stats`命令中的`BlockIO`值将其添加到我们的表中，该值代表对我们的主机磁盘驱动器或目录的读写操作：'
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we don''t have any running containers on our system, the preceding command
    should provide us with the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的系统上没有任何运行的容器，上述命令应该为我们提供以下输出：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we ever need to limit the amount of data that a running container can move
    to our host system''s disk storage, we can start by using the `--blkio-weight`
    option with our `docker run` command. This option stands for **Block Input Output
    Weight** and allows us to set a relative weight for the container to be between
    `10` and `1000` and is relative to all the other containers running on your system.
    All containers will be set with the same proportion of bandwidth, which is 500\.
    If a value of 0 is provided to any container, this option will be switched off:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要限制正在运行的容器可以移动到主机系统磁盘存储的数据量，我们可以从使用`--blkio-weight`选项开始，该选项与我们的`docker
    run`命令一起使用。此选项代表**块输入输出权重**，允许我们为容器设置一个相对权重，介于`10`和`1000`之间，并且相对于系统上运行的所有其他容器。所有容器将被设置为相同比例的带宽，即500。如果为任何容器提供值0，则此选项将被关闭。
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next option we have available to use is `--device-write-bps`, which will
    limit the specific write bandwidth available to the device specified with a bytes-per-second
    value. The specific device is relative to the device the container is using on
    the host system. This option also has an `iops (Input/Output) per seconds` option
    that can also be used. The following syntax provides the basic usage of the option
    where the limit value is a numeric value set as MB:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的下一个选项是`--device-write-bps`，它将限制指定的设备可用的特定写入带宽，以字节每秒的值为单位。特定设备是相对于容器在主机系统上使用的设备。此选项还有一个“每秒输入/输出（IOPS）”选项，也可以使用。以下语法提供了该选项的基本用法，其中限制值设置为MB的数值：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Just as there is a way to limit write processes to the host system''s disk,
    there is also an option to limit the read throughput available. Once again, it
    also has an `iops (Input/Output) per seconds` option that can be used and will
    limit the amount of data that can be read from your running container. The following
    example uses the `--device-read-bps` option as part of the `docker run` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有一种方法可以限制写入进程到主机系统的磁盘一样，也有一种选项可以限制可用的读取吞吐量。同样，它还有一个“每秒输入/输出（IOPS）”选项，可以用来限制可以从正在运行的容器中读取的数据量。以下示例使用`--device-read-bps`选项作为`docker
    run`命令的一部分：
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you're adhering to container best practices, overconsumption of disk input
    or output should not be too much of an issue. There is no reason to assume that
    this will not cause you any problems, though. Just as you have worked with both
    CPU and memory, your disk input and output should be tested on your running containers
    before your services are implemented in production.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵守容器最佳实践，磁盘输入或输出的过度消耗不应该是太大的问题。尽管如此，没有理由认为这不会给您造成任何问题。就像您已经处理过CPU和内存一样，您的磁盘输入和输出应该在将服务实施到生产环境之前在运行的容器上进行测试。
- en: 'Exercise 12.03: Understanding Disk Read and Write'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：理解磁盘读写
- en: 'This exercise will allow you to become familiar with viewing the disk read
    and write of your running container. It will allow you to start running your containers
    by configuring limits for the disk usage speeds with the options available at
    runtime:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将使您熟悉查看正在运行的容器的磁盘读写。它将允许您通过在运行时使用可用的选项来配置磁盘使用速度的限制来开始运行您的容器：
- en: 'Open a new terminal window and run the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并运行以下命令：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `docker stats` command with the `BlockIO` option helps us monitor the levels
    of input and output moving from our container to the host system's disk.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker stats`命令与`BlockIO`选项帮助我们监视从我们的容器到主机系统磁盘的输入和输出级别。'
- en: 'Start the container to access it from the bash command line. Perform some tests
    directly on a running `docker-stress` image. The stress application does give
    you some options to manipulate the disk utilization on your container and the
    host system, but it is limited to the only disk writes:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动容器以从bash命令行访问它。在运行的`docker-stress`镜像上直接执行一些测试。stress应用程序确实为您提供了一些选项，以操纵容器和主机系统上的磁盘利用率，但它仅限于磁盘写入：
- en: '[PRE48]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Unlike the CPU and memory usage, the block input and output show the total
    amount used by the container, so it will not be dynamic and change as the running
    container performs more changes. Move back to your terminal running `docker stats`.
    You should see `0B` for both input and output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与CPU和内存使用情况不同，块输入和输出显示容器使用的总量，因此它不会随着运行容器执行更多更改而动态变化。回到运行`docker stats`的终端。您应该看到输入和输出都为`0B`：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will be using the bash shell in this instance as it gives access to the
    `time` command to see how long each of these processes take. Use the `dd` command,
    which is a Unix command used to make copies of filesystems and backups. In the
    following option, create a copy of our `/dev/zero` directory, using the `if` (input
    file) option, and output it to the `disk.out` file with the `of` (output file)
    option. The `bs` option is the block size or the amount of data it should read
    at a time and `count` is the total amount of blocks to read. Finally, set the
    `oflag` value to `direct`, which means the copy will avoid the buffer cache, so
    you are seeing a true value of disk reads and writes:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，您将使用bash shell，因为它可以访问`time`命令以查看每个进程需要多长时间。使用`dd`命令，这是一个用于复制文件系统和备份的Unix命令。在以下选项中，使用`if`（输入文件）选项创建我们的`/dev/zero`目录的副本，并使用`of`（输出文件）选项将其输出到`disk.out`文件。`bs`选项是块大小或应该一次读取的数据量，`count`是要读取的总块数。最后，将`oflag`值设置为`direct`，这意味着复制将避免缓冲区缓存，因此您将看到磁盘读取和写入的真实值：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Move back into the terminal running your `docker stats` command. You will see
    just over 10 MB of data sent to the host system''s disk. Unlike CPU and memory,
    you do not see this data value go down after the transfer has occurred:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到运行`docker stats`命令的终端。您将看到超过10MB的数据发送到主机系统的磁盘。与CPU和内存不同，传输完成后，您不会看到此数据值下降：
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You'll also notice that the command in *step 4* was almost instantly completed,
    with the `time` command showing it took only `0.01s` in real-time to complete.
    You will see what happens if you restrict the amount of data that can be written
    to disk, but first, exit out of the running container so that it no longer exists
    on our system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到*步骤4*中的命令几乎立即完成，`time`命令显示实际只需`0.01s`即可完成。您将看到如果限制可以写入磁盘的数据量会发生什么，但首先退出运行的容器，以便它不再存在于我们的系统中。
- en: 'To start our `docker-stress` container up again, set the `--device-write-bps`
    option to `1MB` per second on the `/dev/sda` device drive:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要再次启动我们的`docker-stress`容器，请将`--device-write-bps`选项设置为每秒`1MB`在`/dev/sda`设备驱动器上：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the `dd` command again, preceded by the `time` command, to test how long
    it takes. You should see that the command takes a lot longer than what it did
    in *step 4*. The `dd` command is once again set to copy `1MB` blocks, `10` times:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`dd`命令，之前加上`time`命令，以测试需要多长时间。您会看到该命令花费的时间比*步骤4*中的时间长得多。`dd`命令再次设置为复制`1MB`块，`10`次：
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Because the container is limited to only write 1 MB per second, this command
    takes 10 seconds, as displayed in the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器限制为每秒只能写入1MB，所以该命令需要10秒，如下面的输出所示：
- en: '[PRE54]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've been able to easily see how our running container can affect the underlying
    host system, specifically when using disk read and write. We have also been able
    to see how we can easily limit the amount of data that can be written to our device,
    so there is less contention between running containers. In the next section, we
    are going to quickly answer the question of what you need to do if you are using
    `docker-compose` and look at limiting the number of resources being used by your
    containers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够很容易地看到我们的运行容器如何影响底层主机系统，特别是在使用磁盘读写时。我们还能够看到我们如何轻松地限制可以写入设备的数据量，以便在运行容器之间减少争用。在下一节中，我们将快速回答一个问题，即如果您正在使用`docker-compose`，您需要做什么，并且限制容器使用的资源数量。
- en: Container Resources and Docker Compose
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器资源和Docker Compose
- en: Orchestrators such as Kubernetes and Swarm go a long way in controlling and
    running your resources and spinning up new hosts if there are extra resources
    needed. But what do you do if you are running `docker-compose` in your system
    or a test environment? Fortunately, the previously mentioned resource configurations
    work nicely with `docker-compose` as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Kubernetes和Swarm之类的编排器在控制和运行资源以及在需要额外资源时启动新主机方面发挥了重要作用。但是，如果您在系统或测试环境中运行`docker-compose`，您该怎么办呢？幸运的是，前面提到的资源配置也适用于`docker-compose`。
- en: Within our `docker-compose.yml` file, under our service, we can use the `resources`
    option under the `deploy` configurations and specify our resource limits for our
    service. Just as we have been using options such as `--cpus`, `--cpu_shares`,
    and `--memory`, we would use the same options in our `docker-compose.yml` file
    as `cpus`, `cpu_shares`, and `memory`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`docker-compose.yml`文件中，在我们的服务下，我们可以在`deploy`配置下使用`resources`选项，并为我们的服务指定资源限制。就像我们一直在使用`--cpus`、`--cpu_shares`和`--memory`等选项一样，我们在我们的`docker-compose.yml`文件中也会使用相同的选项，如`cpus`、`cpu_shares`和`memory`。
- en: 'The example `compose` file in the following code block is deploying the `docker-stress`
    image we have been using in this chapter. If we look at *line 8*, we can see the
    `deploy` statement, followed by the `resources` statement. This is where we can
    set our limits for our container. Just as we have in the previous section, we
    have set `cpus` to `2` on *line 11* and `memory` to `256MB` on *line 12*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码块中的示例`compose`文件部署了我们在本章中一直在使用的`docker-stress`镜像。如果我们看*第8行*，我们可以看到`deploy`语句，后面是`resources`语句。这是我们可以为我们的容器设置限制的地方。就像我们在前面的部分中所做的那样，我们在*第11行*上将`cpus`设置为`2`，在*第12行*上将`memory`设置为`256MB`。 '
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Even though we have only just touched on this subject, the previous sections
    covering resource usage should guide you on how you should be allocating resources
    in your `docker-compose.yml` files. This brings us to the end of this section
    on resource usage of our Docker containers. From here, we will move on to look
    at the best practices for creating our `Dockerfiles` and how we can start to use
    different applications to ensure that we are adhering to these best practices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只是简单地涉及了这个主题，但前面涵盖资源使用的部分应该指导您如何在`docker-compose.yml`文件中分配资源。这就是我们关于Docker容器资源使用的部分的结束。从这里开始，我们将继续研究创建我们的`Dockerfiles`的最佳实践，以及如何开始使用不同的应用程序来确保我们遵守这些最佳实践。
- en: Best Practices in Docker
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker最佳实践
- en: As our containers and services grow in size and complexity, it is important
    to make sure we are keeping true to the best practices when creating our Docker
    images. This is also true for the applications we run on our Docker images. Later
    in this chapter, we will look to lint our `Dockerfiles` and `docker-compose.yml`
    files, which will analyze our files for errors and best practices, and this will
    give you a clearer understanding. In the meantime, let's look into some of the
    more important best practices to keep in mind when you are creating your Docker
    images and how your applications should be working with them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的容器和服务规模和复杂性的增长，重要的是要确保在创建Docker镜像时我们遵循最佳实践。对于我们在Docker镜像上运行的应用程序也是如此。在本章的后面，我们将查看我们的`Dockerfiles`和`docker-compose.yml`文件，这将分析我们的文件中的错误和最佳实践，从而让您更清楚地了解。与此同时，让我们来看看在创建Docker镜像和应用程序与之配合工作时需要牢记的一些更重要的最佳实践。
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter may cover some points from previous chapters, but we will be able
    to give you more information and clarity on why we are using these practices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能涵盖了一些之前章节的内容，但我们将能够为您提供更多信息和清晰解释为什么我们要使用这些实践。
- en: In the following section, we will run through some of the more common best practices
    you should be following when creating your services and containers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将介绍一些在创建服务和容器时应该遵循的常见最佳实践。
- en: Running One Service per Container
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个容器只运行一个服务
- en: In modern microservice architecture, we need to remember that only one service
    should be installed in each container. The container's main process is set by
    the `ENTRYPOINT` or `CMD` instruction at the end of the `Dockerfile`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代微服务架构中，我们需要记住每个容器只应安装一个服务。容器的主要进程由`Dockerfile`末尾的`ENTRYPOINT`或`CMD`指令设置。
- en: The service you have installed in your container could quite easily run multiple
    processes of itself, but to get the full benefit of Docker and microservices,
    you should only be running one service per container. To break this down further,
    your container should only have a single responsibility, and if it is responsible
    for doing more than one thing, then it should be broken out into different services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您在容器中安装的服务很容易运行多个进程，但为了充分利用Docker和微服务的优势，您应该每个容器只运行一个服务。更进一步地说，您的容器应该只负责一个单一的功能，如果它负责的事情超过一个，那么它应该拆分成不同的服务。
- en: By limiting what each container can do, we effectively reduce the resources
    being used by the image and potentially reduce the size of the image. As we saw
    in the previous chapter, this will also reduce the chances of an attacker being
    able to perform anything they shouldn't if they gain access to a running container.
    It also means that if the container stops working for some reason, there is a
    limited effect on the rest of the applications running on the environment and
    the service will have an easier time recovering.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制每个容器的功能，我们有效地减少了镜像使用的资源，并可能减小了镜像的大小。正如我们在上一章中看到的，这也将减少攻击者在获得运行中的容器访问权限时能够执行任何不应该执行的操作的机会。这也意味着，如果容器因某种原因停止工作，对环境中运行的其他应用程序的影响有限，服务将更容易恢复。
- en: Base Images
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础镜像
- en: When we start with a base image for our container, one of the first things we
    need to do is to make sure we are starting with an up-to-date image. Do a little
    research as well to make sure you are not using an image that has a lot of extra
    applications installed that are not needed. You may find that a base image supported
    by a specific language that your application uses or a specific focus will limit
    the size of the image needed, limiting what you need to install when you are creating
    your image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的容器选择基础镜像时，我们需要做的第一件事之一是确保我们使用的是最新的镜像。还要做一些研究，确保您不使用安装了许多不需要的额外应用程序的镜像。您可能会发现，受特定语言支持的基础镜像或特定焦点将限制所需的镜像大小，从而限制您在创建镜像时需要安装的内容。
- en: This is why we are using a PostgreSQL-supported Docker image instead of installing
    the application on the image during build time. The PostgreSQL-supported image
    ensures that it is secure and running at the latest version and makes sure we
    are not running applications on the image that are not needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们使用受PostgreSQL支持的Docker镜像，而不是在构建时在镜像上安装应用程序。受PostgreSQL支持的镜像确保它是安全的，并且运行在最新版本，并确保我们不在镜像上运行不需要的应用程序。
- en: When specifying our base image for our `Dockerfile`, we need to make sure we
    are also specifying a specific version and not letting Docker simply use the `latest`
    image. Also, make sure you are not pulling an image from a repository or registry
    that is not from a reputable or trusted provider.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的`Dockerfile`指定基础镜像时，我们需要确保还指定了特定版本，而不是让Docker简单地使用`latest`镜像。另外，确保您不是从不是来自值得信赖的提供者的存储库或注册表中拉取镜像。
- en: 'If you''ve been working with Docker for a little while, you may have come across
    the `MAINTAINER` instruction where you specify the author of the generated image.
    This has now been deprecated, but you can still provide these details using a
    `LABEL` directive instead, as we have in the following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用Docker一段时间，可能已经遇到了`MAINTAINER`指令，您可以在其中指定生成图像的作者。现在这已经被弃用，但您仍然可以使用`LABEL`指令来提供这些细节，就像我们在以下语法中所做的那样：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Installing Applications and Languages
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装应用程序和语言
- en: When you are installing applications on your images, always remember that there
    is no need to be performing `apt-get update` or `dist-upgrade`. You should be
    looking at a different image if you need to be upgrading the image version this
    way. If you are installing applications using `apt-get` or `apk`, make sure you
    are specifying the specific version you need as you don't want to install a version
    that is new or untested.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在镜像上安装应用程序时，永远记住不需要执行`apt-get update`或`dist-upgrade`。如果您需要以这种方式升级镜像版本，应该考虑使用不同的镜像。如果您使用`apt-get`或`apk`安装应用程序，请确保指定您需要的特定版本，因为您不希望安装新的或未经测试的版本。
- en: When you are installing packages, make sure you are using the `-y` switch to
    make sure the build does not stop and ask for a user prompt. Alternatively, you
    should also use `--no-install-recommends` as you don't want to install a large
    group of applications that your package manager has recommended and that you won't
    need. Also, if you using a Debian-based container, make sure that you are using
    `apt-get` or `apt-cache`, as the `apt` command has been specifically made for
    user interaction and not for a scripted installation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装软件包时，确保使用`-y`开关，以确保构建不会停止并要求用户提示。另外，您还应该使用`--no-install-recommends`，因为您不希望安装大量您的软件包管理器建议的不需要的应用程序。此外，如果您使用基于Debian的容器，请确保使用`apt-get`或`apt-cache`，因为`apt`命令专门用于用户交互，而不是用于脚本化安装。
- en: If you are installing applications from other forms, such as building the application
    from code, make sure you are cleaning up the installation files to once again
    reduce the size of the image you are creating. Again, if you are using `apt-get`,
    you should also remove the lists in `/var/lib/apt/lists/` to clean up installation
    files and reduce the size of your container image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在从其他形式安装应用程序，比如从代码构建应用程序，请确保清理安装文件，以再次减小您创建的镜像的大小。同样，如果您正在使用`apt-get`，您还应该删除`/var/lib/apt/lists/`中的列表，以清理安装文件并减小容器镜像的大小。
- en: Running Commands and Performing Tasks
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行命令和执行任务
- en: As our image is being created, we usually need to perform some tasks within
    our `Dockerfile` to set up the environment ready for our services to be run. Always
    make sure you are not using the `sudo` command as this could cause some unexpected
    results. If you need to be running commands as root, your base image will most
    likely be running as the root user; just make sure you create a separate user
    to run your application and services and that the container has changed to the
    required user before it has completed building.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的镜像正在创建时，通常需要在我们的`Dockerfile`中执行一些任务，以准备好我们的服务运行的环境。始终确保您不使用`sudo`命令，因为这可能会导致一些意外的结果。如果需要以root身份运行命令，您的基础镜像很可能正在以root用户身份运行；只需确保您创建一个单独的用户来运行您的应用程序和服务，并且在构建完成之前容器已经切换到所需的用户。
- en: Make sure you are moving to different directories using `WORKDIR`, instead of
    running instructions that specify a long path, as this could be hard for users
    to read. Use `JSON` notation for the `CMD` and `ENTRYPOINT` arguments and always
    make sure you only have one `CMD` or `ENTRYPOINT` instruction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用`WORKDIR`切换到不同的目录，而不是运行指定长路径的指令，因为这可能会让用户难以阅读。对于`CMD`和`ENTRYPOINT`参数，请使用`JSON`表示法，并始终确保只有一个`CMD`或`ENTRYPOINT`指令。
- en: Containers Need to Be Immutable and Stateless
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器需要是不可变的和无状态的
- en: We need to ensure that our containers and the services running on them are immutable.
    We must not treat containers like traditional servers, especially a server where
    you would update applications on a running container. You should be able to update
    your container from code and deploy it without needing to access it at all.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的容器和运行在其中的服务是不可变的。我们不能像传统服务器那样对待容器，特别是在运行容器上更新应用程序的服务器。您应该能够从代码更新容器并部署它，而无需访问它。
- en: When we say immutable, we mean the container will not be modified at all during
    its life, with no updates, patches, or config changes being made. Any changes
    to your code or updates should be implemented by building the new image and then
    deploying it into your environment. This makes deployments safer as if you have
    any issues with your upgrade, you simply redeploy the old version of the image.
    It also means you have the same image running across all of your environments,
    making sure your environments are as identical as possible.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说不可变时，我们指的是容器在其生命周期内不会被修改，不会进行更新、补丁或配置更改。您的代码或更新的任何更改都应该通过构建新镜像然后部署到您的环境中来实现。这样做可以使部署更安全，如果升级出现任何问题，您只需重新部署旧版本的镜像。这也意味着您在所有环境中运行相同的镜像，确保您的环境尽可能相同。
- en: When we talk about a container needing to be stateless, this means that any
    data needed to run the container should be running outside of the container. File
    stores should also be outside the container, possibly on cloud storage or using
    a mounted volume. Removing data from the container means the container can be
    cleanly shut down and destroyed at any time, without fearing data loss. When a
    new container is created to replace the old one, it simply connects to the original
    data store.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论容器需要是无状态的时候，这意味着运行容器所需的任何数据都应该在容器外部运行。文件存储也应该在容器外部，可能在云存储上或者使用挂载卷。将数据从容器中移除意味着容器可以在任何时候被干净地关闭和销毁，而不必担心数据丢失。当创建一个新的容器来替换旧的容器时，它只需连接到原始数据存储。
- en: Designing Applications to Be Highly Available and Scalable
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计应用程序以实现高可用性和可扩展性
- en: Using containers in a microservices architecture is designed to allow your application
    to scale to multiple instances. So, when developing your applications on your
    Docker container, you should expect that there could be situations where many
    instances of your application could be deployed concurrently, scaling both up
    and down when needed. There should also be no issue with your services running
    and completing when there is a heavier-than-normal load on the container.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中使用容器旨在使您的应用程序能够扩展到多个实例。因此，在开发您的应用程序时，您应该预期可能会出现许多实例同时部署的情况，需要在需要时进行上下扩展。当容器负载较重时，您的服务运行和完成也不应该有问题。
- en: When your services need to scale due to increased requests, how much time your
    applications need to start becomes an important issue. Before deploying your services
    into a production environment, you need to make sure the startup time is quick
    to make sure the system will be able to scale more efficiently without causing
    any delay in service to your users. To ensure that your services adhere to the
    industry's best practices, your services should be starting in less than 10 seconds,
    but less than 20 seconds is also acceptable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的服务需要因为增加的请求而扩展时，应用程序需要启动的时间就成为一个重要问题。在将您的服务部署到生产环境之前，您需要确保启动时间很快，以确保系统能够更有效地扩展而不会给用户的服务造成任何延迟。为了确保您的服务符合行业最佳实践，您的服务应该在不到10秒内启动，但不到20秒也是可以接受的。
- en: As we saw in the previous section, improving the application startup time is
    not simply a matter of providing more CPU and memory resources. We need to make
    sure that the applications on our containers run efficiently and, once again,
    if they are taking too long to start and run specific processes, you may be performing
    too many tasks in one application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所看到的，改善应用程序的启动时间不仅仅是提供更多的CPU和内存资源的问题。我们需要确保我们容器中的应用程序能够高效运行，如果它们启动和运行特定进程的时间太长，可能是因为一个应用程序执行了太多的任务。
- en: Images and Containers Need to Be Tagged Appropriately
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像和容器需要适当地打标签
- en: We covered this topic in detail in *Chapter 3*, *Managing Your Docker Images*,
    and made it clear that we need to think about how we name and tag our images,
    especially when we start working with larger development teams. To allow all users
    the ability to understand what the image does and gain an understanding of what
    version is deployed into an environment, a relevant tagging and naming strategy
    needs to be decided and agreed upon before the bulk of the work is started by
    your team.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《第3章》《管理您的Docker镜像》中详细介绍了这个主题，并明确指出，我们需要考虑如何命名和标记我们的图像，特别是当我们开始与更大的开发团队合作时。为了让所有用户能够理解图像的功能，并了解部署到环境中的版本，需要在团队开始大部分工作之前决定并达成一致的相关标记和命名策略。
- en: Image and container names need to be relevant to the applications they are running,
    as ambiguous names can cause confusion. An agreed standard for versioning must
    also be put in place to make sure any user can identify what version is running
    in a certain environment and what version is the most recent and stable release.
    As we mentioned in *Chapter 3*, *Managing Your Docker Images*, try not to use
    `latest`, and instead opt for either a semantic versioning system or Git repository
    `commit` hash, where users can then refer to either documentation or a build environment
    to ensure that they have the most up-to-date version of their image.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和容器名称需要与它们运行的应用程序相关，因为模糊的名称可能会引起混淆。还必须制定一个版本的约定标准，以确保任何用户都可以确定在特定环境中运行的版本以及最新稳定版本是什么版本。正如我们在*第3章*中提到的*管理您的Docker镜像*中所提到的，尽量不要使用`latest`，而是选择语义版本控制系统或Git存储库`commit`哈希，用户可以参考文档或构建环境，以确保他们拥有最新版本的镜像。
- en: Configurations and Secrets
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和秘密
- en: Environment variables and secrets should never be built into your Docker image.
    By doing this, you are going against the rule of reusable images. Building images
    with your secret credentials is also a security risk because they will be stored
    in one of the image layers, and so anyone able to pull the image will be able
    to see the credentials.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量和秘密不应该内置到您的Docker镜像中。通过这样做，您违反了可重用图像的规则。使用您的秘密凭据构建图像也是一种安全风险，因为它们将存储在图像层中，因此任何能够拉取图像的人都将能够看到凭据。
- en: When setting up the configuration for your application, it may need to change
    from environment to environment, so it is important to remember that you will
    need to be able to dynamically change these configurations when needed. This could
    include specific configurations for the language your application is written in
    or even the database that the application needs to connect to. We mentioned earlier
    that if you are configuring your application as part of your `Dockerfile`, this
    will then make it difficult to change and you may need to create a specific `Dockerfile`
    for each environment you wish to deploy your image to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序设置配置时，可能需要根据环境的不同进行更改，因此重要的是要记住，当需要时，您需要能够动态更改这些配置。这可能包括应用程序所编写的语言的特定配置，甚至是应用程序需要连接到的数据库。我们之前提到过，如果您正在配置应用程序作为您的`Dockerfile`的一部分，这将使其难以更改，您可能需要为您希望部署图像的每个环境创建一个特定的`Dockerfile`。
- en: 'One way to configure your images, as we have seen with the `docker-stress`
    image, is to use an environment variable that is set on the command line when
    we run the image. The entry point or command should contain default values if
    variables have not been provided. This will mean the container will still start
    up and run even if the extra variables have not been provided:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 配置图像的一种方法，就像我们在`docker-stress`图像中看到的那样，是使用在运行图像时在命令行上设置的环境变量。如果未提供变量，则入口点或命令应包含默认值。这意味着即使未提供额外的变量，容器仍将启动和运行：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By doing this, we have made our configuration more dynamic, but this could limit
    your configuration when you have a larger or more complex configuration. The environment
    variables can easily be transferred from your `docker run` command to `docker-compose`
    to then be used in Swarm or Kubernetes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们使我们的配置更加动态，但是当您有一个更大或更复杂的配置时，这可能会限制您的配置。环境变量可以很容易地从您的`docker run`命令转移到`docker-compose`，然后在Swarm或Kubernetes中使用。
- en: For larger configurations, you may want to mount a configuration file via a
    Docker volume. This can mean you will be able to set up a configuration file and
    run it on your system to test easily, and then if you need to move to an orchestration
    system such as Kubernetes or Swarm, or an external configuration management solution,
    you will be able to easily convert this into a configuration map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的配置，您可能希望通过Docker卷挂载配置文件。这意味着您可以设置一个配置文件并在系统上轻松测试运行，然后如果需要转移到诸如Kubernetes或Swarm之类的编排系统，或者外部配置管理解决方案，您可以轻松将其转换为配置映射。
- en: 'If we wanted to implement this with the `docker-stress` image we have been
    using in this chapter, it could be modified to use a configuration file to mount
    the values we would like to run. In the following example, we have modified the
    `Dockerfile` to set up *line 3* to run a script that will instead run the `stress`
    command for us:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在本章中使用的`docker-stress`镜像中实现这一点，可以修改为使用配置文件来挂载我们想要运行的值。在以下示例中，我们修改了`Dockerfile`以设置*第3行*运行一个脚本，该脚本将代替我们运行`stress`命令：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This means we can build the Docker image and have it ready and available for
    us to use whenever we need it. We would just need a script that we would mount
    in the `/tmp` directory to be run. We could use the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以构建Docker镜像，并使其随时准备好供我们使用。我们只需要一个脚本，我们会挂载在`/tmp`目录中运行。我们可以使用以下示例：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This illustrates the idea of moving our values from environment variables to
    a file. To run both the container and the stress application, we would then perform
    the following, knowing that if we wanted to change the variables being used by
    the `stress` command, we would only need to make a minor change to the file we
    are mounting:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了将我们的值从环境变量移动到文件的想法。然后，我们将执行以下操作来运行容器和stress应用程序，知道如果我们想要更改`stress`命令使用的变量，我们只需要对我们挂载的文件进行微小的更改：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first thing you are going to think when you read through this list of best
    practices is that we have gone against a lot of this, but please remember that
    we have done this in a lot of instances to demonstrate a process or idea.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这些最佳实践清单时，你可能会认为我们违背了很多内容，但请记住，我们在很多情况下都这样做是为了演示一个流程或想法。
- en: Making Your Images Minimal and Small
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使您的镜像尽可能精简和小
- en: '*Chapter 3*, *Managing Your Docker Images*, also saw us do some work on making
    our images as small as we possibly could. We saw that by reducing the size of
    our images, the images can be built faster. They can also then be pulled faster
    and run on our systems. Any unnecessary software or applications installed on
    our containers can take up extra space and resources on our host system and could
    slow our services down as a result.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3章*，*管理您的Docker镜像*，还让我们尽可能地减小了镜像的大小。我们发现通过减小镜像的大小，可以更快地构建镜像。它们也可以更快地被拉取并在我们的系统上运行。在我们的容器上安装的任何不必要的软件或应用程序都会占用额外的空间和资源，并可能因此减慢我们的服务速度。'
- en: Using an application such as Anchore Engine as we did in *Chapter 11*, *Docker
    Security*, showed that we can audit our images to view their contents, as well
    as the applications installed on them. This is an easy way to make sure we are
    reducing the sizes of our images and making them as minimal as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第11章*，*Docker安全*中所做的那样，使用Anchore Engine这样的应用程序显示了我们可以审计我们的镜像以查看其内容，以及安装在其中的应用程序。这是一种简单的方法，可以确保我们减小镜像的大小，使其尽可能精简。
- en: You now have an idea of the best practices you should be using in your container
    images and services. The following section of this chapter will help you enforce
    some of these best practices by using applications to verify that your `Dockerfiles`
    and `docker-compose.yml` are created as they should be.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了您应该在容器镜像和服务中使用的最佳实践。本章的以下部分将帮助您通过使用应用程序来验证您的`Dockerfiles`和`docker-compose.yml`是否按照应有的方式创建来强制执行其中的一些最佳实践。
- en: Enforcing Docker Best Practices in Your Code
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的代码中强制执行Docker最佳实践
- en: Just as we look to make our coding easier when we are developing applications,
    we can use external service and tests to make sure our Docker images are adhering
    to the best practices. In the following sections of this chapter, we are going
    to use three tools to make sure that our `Dockerfiles` and `docker-compose.yml`
    files are adhering to the best practices, as well as making sure we are not introducing
    potential issues when our Docker images are built.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在开发应用程序时寻求使我们的编码更加简单一样，我们可以使用外部服务和测试来确保我们的Docker镜像遵守最佳实践。在本章的以下部分，我们将使用三种工具来确保我们的`Dockerfiles`和`docker-compose.yml`文件遵守最佳实践，并确保我们在构建Docker镜像时不会引入潜在问题。
- en: The tools included will be straightforward to use and provide powerful functionality.
    We will start by using `hadolint` to lint our `Dockerfiles` directly on our system,
    which will run as a separate Docker image that we feed our `Dockerfiles` into.
    We then take a look at `FROM:latest`, which is an online service that provides
    some basic functionality in helping us pinpoint issues with our `Dockerfiles`.
    Lastly, we then look at **Docker Compose Validator** (**DCValidator**), which
    will perform a similar function, but in this case, we will lint our `docker-compose.yml`
    files to help pinpoint potential issues.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具将使用起来非常简单，并提供强大的功能。我们将首先使用`hadolint`在我们的系统上直接对我们的`Dockerfiles`进行代码检查，它将作为一个独立的Docker镜像运行，我们将把我们的`Dockerfiles`输入到其中。然后我们将看一下`FROM:latest`，这是一个在线服务，提供一些基本功能来帮助我们找出`Dockerfiles`中的问题。最后，我们将看一下**Docker
    Compose Validator**（**DCValidator**），它将执行类似的功能，但在这种情况下，我们将对我们的`docker-compose.yml`文件进行代码检查，以帮助找出潜在问题。
- en: By using these tools before we build and deploy our images, we hope to reduce
    our build times for our Docker images, reduce the number of errors we introduce,
    potentially reduce the size of our Docker images, and help us learn more about
    and enforce Docker best practices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在构建和部署我们的镜像之前使用这些工具，我们希望减少我们的Docker镜像的构建时间，减少我们引入的错误数量，可能减少我们的Docker镜像的大小，并帮助我们更多地了解和执行Docker最佳实践。
- en: Using Docker Linter for Your Images
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker Linter检查您的镜像
- en: The GitHub repository containing all the code for this book also includes tests
    that will compare against the built Docker image. A linter, on the other hand,
    will analyze your code and look for potential errors before the image is built.
    In this section of the chapter, we are looking for potential issues with our `Dockerfiles`,
    specifically using an application called `hadolint`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 包含本书所有代码的GitHub存储库还包括将与构建的Docker镜像进行比较的测试。另一方面，代码检查器将分析您的代码，并在构建镜像之前寻找潜在错误。在本章的这一部分，我们正在寻找我们的`Dockerfiles`中的潜在问题，特别是使用一个名为`hadolint`的应用程序。
- en: The name `hadolint` is short for **Haskell Dockerfile Linter** and comes with
    its own Docker image that allows you to pull the image and then send your `Dockerfile`
    to the running image for it to be tested. Even if your `Dockerfile` is relatively
    small and builds and runs without any issues, `hadolint` will usually offer a
    lot of suggestions and point out flaws in your `Dockerfile`, as well as potential
    issues that might break in the future.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`hadolint`是**Haskell Dockerfile Linter**的缩写，并带有自己的Docker镜像，允许您拉取该镜像，然后将您的`Dockerfile`发送到正在运行的镜像以进行测试。即使您的`Dockerfile`相对较小，并且构建和运行没有任何问题，`hadolint`通常会提供许多建议，并指出`Dockerfile`中的缺陷，以及可能在将来出现问题的潜在问题。
- en: 'To run `hadolint` over your `Dockerfiles`, you need to have the `hadolint`
    Docker image on your system. As you know by now, this is simply a matter of running
    the `docker pull` command with the name and repository of the required image.
    In this instance, both the repository and image are called `hadolint`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的`Dockerfiles`上运行`hadolint`，您需要在您的系统上有`hadolint` Docker镜像。正如您现在所知，这只是运行`docker
    pull`命令并使用所需镜像的名称和存储库的问题。在这种情况下，存储库和镜像都称为`hadolint`：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To then use the application, you simply run the `hadolint` image and point
    your `Dockerfile` to it using the less than (`<`) symbol, as we''ve done in the
    following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以简单地运行`hadolint`镜像，并使用小于(`<`)符号将您的`Dockerfile`指向它，就像我们在以下示例中所做的那样：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you are lucky enough to not have any issues with your `Dockerfile`, you
    should not see any output from the preceding command. If there is ever a situation
    where you need to ignore a specific warning, you can do so by using the `--ignore`
    option, followed by the specific rule ID that has been triggering the warning:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您足够幸运，没有任何问题与您的`Dockerfile`，您不应该看到前面命令的任何输出。如果有需要忽略特定警告的情况，您可以使用`--ignore`选项，后跟触发警告的特定规则ID：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you need to have a few warnings ignored, it may get a little complicated
    trying to implement this in the command line, so `hadolint` also has the option
    to set up a configuration file. The `hadolint` configuration file is limited to
    ignoring warnings and providing a list of trusted repositories. You can also set
    up a configuration file with a list of your ignored warnings listed in the YAML
    format. `hadolint` will then need to have this file mounted on the running image
    for it to be used by the application as it will look for a `.hadolint.yml` configuration
    file location in the application''s home directory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要忽略一些警告，尝试在命令行中实现可能会有点复杂，因此`hadolint`还有设置配置文件的选项。`hadolint`配置文件仅限于忽略警告并提供受信任存储库的列表。您还可以使用YAML格式设置包含您忽略警告列表的配置文件。然后，`hadolint`将需要在运行的镜像上挂载此文件，以便应用程序使用它，因为它将在应用程序的主目录中查找`.hadolint.yml`配置文件位置：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`hadolint` is one of the better applications for linting your `Dockerfiles`
    and can easily be automated as part of a build and deployment pipelines. As an
    alternative, we are also going to look at an online application called `FROM:latest`.
    This application is a web-based service that does not provide the same functionality
    as `hadolint` but does allow you to easily copy and paste your `Dockerfile` code
    into the online editor and receive feedback on whether the `Dockerfile` adheres
    to the best practices.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`是用于清理您的`Dockerfiles`的更好的应用程序之一，并且可以轻松地作为构建和部署流水线的一部分进行自动化。作为替代方案，我们还将看一下名为`FROM:latest`的在线应用程序。这个应用程序是一个基于Web的服务，不提供与`hadolint`相同的功能，但允许您轻松地将您的`Dockerfile`代码复制粘贴到在线编辑器中，并获得有关`Dockerfile`是否符合最佳实践的反馈。'
- en: 'Exercise 12.04: Linting Your Dockerfiles'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：清理您的Dockerfile
- en: 'This exercise will help you understand how to access and run `hadolint` on
    your system to help you enforce best practices on your `Dockerfiles`. We will
    also use an online `Dockerfile` linter called `FROM:latest` to compare the warnings
    we receive:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习将帮助您了解如何在系统上访问和运行`hadolint`，以帮助您强制执行`Dockerfiles`的最佳实践。我们还将使用一个名为`FROM:latest`的在线`Dockerfile`
    linter来比较我们收到的警告：
- en: 'Pull the image from the `hadolint` repository with the following `docker pull` command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`docker pull`命令从`hadolint`存储库中拉取镜像：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You have a `Dockerfile` ready to go with the `docker-stress` image you used
    to test and manage your resources earlier in this chapter. Run the `hadolint`
    image to lint this `Dockerfile`, or any other `Dockerfile`, and send it to the
    `Dockerfile` using the less than (`<`) symbol, as in the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经准备好一个`Dockerfile`，其中包含您在本章早些时候用来测试和管理资源的`docker-stress`镜像。运行`hadolint`镜像以对此`Dockerfile`进行检查，或者对任何其他`Dockerfile`进行检查，并使用小于（`<`）符号发送到`Dockerfile`，如以下命令所示：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can see from the following output, even though our `docker-stress` image
    was relatively small, `hadolint` has given quite a few different ways where we
    can improve the performance and help our image adhere to the best practices:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，即使我们的`docker-stress`镜像相对较小，`hadolint`也提供了许多不同的方式，可以改善性能并帮助我们的镜像遵守最佳实践：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your `Dockerfile` runs successfully through `hadolint` and there are no issues
    found, there will be no output presented to the user on the command line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`Dockerfile`通过`hadolint`成功运行，并且没有发现任何问题，则在命令行上不会向用户呈现任何输出。
- en: '`hadolint` also gives you the option to suppress different checks with the
    `--ignore` option. In the following command, we have chosen to ignore the `DL3008`
    warning, where it is suggesting that you pin the applications you are installing
    to a specific version number. Execute the `docker run` command to suppress the
    `DL3008` warning. Note that you need to provide the full `hadolint` command after
    specifying the image name you are running, as well as an extra dash (`-`) before
    you provide the `Dockerfile`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hadolint`还为您提供了使用`--ignore`选项来抑制不同检查的选项。在以下命令中，我们选择忽略`DL3008`警告，该警告建议您将安装的应用程序固定到特定版本号。执行`docker
    run`命令以抑制`DL3008`警告。请注意，在指定运行的镜像名称之后，您需要提供完整的`hadolint`命令，以及在提供`Dockerfile`之前提供额外的破折号（`-`）：'
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should get output like the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得以下类似的输出：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`hadolint` also allows you to create a configuration file to add any warnings
    to be ignored, as well as specifying them on the command line. Create a file named
    `.hadolint.yml` using the `touch` command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hadolint`还允许您创建一个配置文件，以添加要忽略的任何警告，并在命令行上指定它们。使用`touch`命令创建一个名为`.hadolint.yml`的文件：'
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open the configuration file with your text editor and enter in and any of the
    warnings you wish to ignore that you have received under the `ignored` field.
    As you can see, you can also add in a `trustedRegistries` field, where you can
    list all the registries you will be pulling images from. Note that `hadolint`
    will provide an extra warning if your image is not from one of the registries
    listed in the configuration file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器打开配置文件，并在`ignored`字段下输入您希望忽略的任何警告。如您所见，您还可以添加一个`trustedRegistries`字段，在其中列出您将从中拉取镜像的所有注册表。请注意，如果您的镜像不来自配置文件中列出的注册表之一，`hadolint`将提供额外的警告：
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`hadolint` will look for your configuration file in the user''s home directory.
    As you are running `hadolint` as a Docker image, mount the file from the current
    location onto the home directory on the running image when we execute the `docker
    run` command with the `-v` option:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hadolint`将在用户的主目录中查找您的配置文件。由于您正在作为Docker镜像运行`hadolint`，因此在执行`docker run`命令时，使用`-v`选项将文件从当前位置挂载到运行镜像的主目录上：'
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The command will give an output as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将输出如下：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The source code repository for `hadolint` provides a list of all the warnings
    as well as details on how to resolve them in your `Dockerfile`. If you have not
    done so already, feel free to look through the Hadolint wiki page at [https://github.com/hadolint/hadolint/wiki](https://github.com/hadolint/hadolint/wiki).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`的源代码存储库提供了所有警告的列表，以及如何在您的`Dockerfile`中解决这些问题的详细信息。如果您还没有这样做，可以随意查看Hadolint维基页面[https://github.com/hadolint/hadolint/wiki](https://github.com/hadolint/hadolint/wiki)。'
- en: 'Finally, `hadolint` also allows you the option to output the results of your
    check in JSON format. Once again, we need to add some extra values to the command
    line. In the command line, add the extra command-line options of `hadolint -f
    json` just before you have added and parsed your `Dockerfile` across to `hadolint`.
    In the following command, you will also need to have the `jq` package installed:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`hadolint`还允许您选择以JSON格式输出检查结果。再次，我们需要在命令行中添加一些额外的值。在命令行中，在将您的`Dockerfile`添加和解析到`hadolint`之前，添加额外的命令行选项`hadolint
    -f json`。在以下命令中，您还需要安装`jq`软件包：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You should get output like the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`hadolint` can easily be integrated into your build pipelines to have your
    `Dockerfiles` linted before they are built. If you are interested in installing
    the `hadolint` application directly onto your system instead of using the Docker
    image, you can do so by cloning the following GitHub repository [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`可以轻松集成到您的构建流水线中，在构建之前对您的`Dockerfiles`进行检查。如果您有兴趣直接将`hadolint`应用程序安装到您的系统上，而不是使用Docker镜像，您可以通过克隆以下GitHub存储库来实现[https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint)。'
- en: '`hadolint` is not the only application that you can use to ensure your `Dockerfiles`
    are adhering to best practices. The next steps in this exercise will look at an
    online service named `FROM:latest` to also help enforce best practices on your
    `Dockerfiles`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`并不是您可以用来确保您的`Dockerfiles`遵守最佳实践的唯一应用程序。这个练习的下一步将介绍一个名为`FROM:latest`的在线服务，也可以帮助强制执行`Dockerfiles`的最佳实践。'
- en: 'To use `FROM:latest`, open your favorite web browser and enter the following URL:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`FROM:latest`，打开您喜欢的网络浏览器，输入以下URL：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When the web page loads, you should see a page similar to the one in the following
    screenshot. On the left-hand side of the web page, you should see a sample `Dockerfile`
    entered, and on the right-hand side of the web page, you should see a list of
    potential issues or ways to optimize your `Dockerfile`. Each of the items listed
    on the right-hand side has a dropdown to provide more details to the user:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页加载时，您应该看到类似以下截图的页面。在网页的左侧，您应该看到输入了一个示例`Dockerfile`，在网页的右侧，您应该看到一个潜在问题或优化`Dockerfile`的方法列表。右侧列出的每个项目都有一个下拉菜单，以向用户提供更多详细信息：
- en: '![Figure 12.1: A screenshot of the FROM:latest website with a sample Dockerfile
    entered'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：FROM:latest网站的截图，显示输入了一个示例Dockerfile'
- en: '](image/B15021_12_01.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_12_01.jpg)'
- en: 'Figure 12.1: A screenshot of the FROM:latest website with a sample Dockerfile
    entered'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：FROM:latest网站的截图，显示输入了一个示例Dockerfile
- en: 'As in the previous part of this exercise, we will use the `Dockerfile` from
    our `docker-stress` image. To use this with `FROM:latest`, copy the following
    lines of code into the left-hand side of the web page over the sample `Dockerfile`
    provided by the site:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习的前一部分中，我们将使用`docker-stress`镜像的`Dockerfile`。要将其与`FROM:latest`一起使用，请将以下代码行复制到网页左侧，覆盖网站提供的示例`Dockerfile`：
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As soon as you post the `Dockerfile` code into the web page, the page will
    start to analyze the commands. As you can see from the following screenshot, it
    will provide details on how to resolve potential issues and optimize the `Dockerfile`
    to have the image build quicker:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将`Dockerfile`代码发布到网页上，页面将开始分析命令。正如您从以下截图中所看到的，它将提供有关如何解决潜在问题并优化`Dockerfile`以使镜像构建更快的详细信息：
- en: '![Figure 12.2: The Dockerfile entered for our docker-stress image'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：我们的docker-stress镜像输入的Dockerfile'
- en: '](image/B15021_12_02.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_12_02.jpg)'
- en: 'Figure 12.2: The Dockerfile entered for our docker-stress image'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：我们的docker-stress镜像输入的Dockerfile
- en: Both `hadolint` and `FROM latest` provide easy-to-use options to help you make
    sure your `Dockerfiles` are adhering to best practices. The next exercise will
    look at a similar way to check your `docker-compose.yml` files to make sure that
    they will also run without issues and are not introducing any bad practices.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`和`FROM latest`都提供了易于使用的选项，以帮助您确保您的`Dockerfiles`遵守最佳实践。下一个练习将介绍一种类似的方法，用于检查您的`docker-compose.yml`文件，以确保它们也可以无故障运行，并且不会引入任何不良实践。'
- en: 'Exercise 12.05: Validating Your docker-compose.yml File'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：验证您的docker-compose.yml文件
- en: Docker already has a tool to validate your `docker-compose.yml` files, but the
    built-in validator does not pick up all issues in your `docker-compose` files,
    including typos, the same ports being assigned to different services, or duplicate
    keys. We can use `dcvalidator` to look for issues such as typos, duplicate keys,
    and ports assigned to numbers services.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已经有一个工具来验证您的`docker-compose.yml`文件，但是内置的验证器无法捕捉到`docker-compose`文件中的所有问题，包括拼写错误、相同的端口分配给不同的服务或重复的键。我们可以使用`dcvalidator`来查找诸如拼写错误、重复的键和分配给数字服务的端口等问题。
- en: 'To perform the following exercise, you will need to have both Git and a recent
    version of Python 3 installed on your system. You won''t be walked through how
    to perform the installation, but these items are required before starting:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行以下练习，您需要在系统上安装Git和最新版本的Python 3。在开始之前，您不会被引导如何执行安装，但在开始之前需要这些项目。
- en: 'To get started with the `dcvalidator`, clone the GitHub repository for the
    project. If you have not done so already, you will need to run the following command
    to clone the repository:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用`dcvalidator`，请克隆该项目的GitHub存储库。如果您还没有这样做，您需要运行以下命令来克隆存储库：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The command-line application only needs Python 3 to run, but you will need
    to make sure all the dependencies are installed first, so change to the `dcvalidator`
    directory of the repository you have just cloned:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行应用程序只需要Python 3来运行，但是您需要确保首先安装了所有的依赖项，因此请切换到您刚刚克隆的存储库的`dcvalidator`目录：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Installing the dependencies for the `dcvalidator` is easy, and your system
    will most likely have most of them installed on it already. To install the dependencies,
    run the `pip3 install` command from the `dcvalidator` directory using the `-r`
    option to use the `requirments.txt` file in the server directory:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`dcvalidator`的依赖项很容易，您的系统很可能已经安装了大部分依赖项。要安装依赖项，请在`dcvalidator`目录中使用`pip3 install`命令，并使用`-r`选项来使用服务器目录中的`requirments.txt`文件：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a `docker-compose` file from scratch that will use some of the images
    you have already created in this chapter. Create a `docker-compose.yml` file by
    using the `touch` command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始创建一个`docker-compose`文件，该文件将使用本章中已经创建的一些镜像。使用`touch`命令创建一个`docker-compose.yml`文件：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Open your favorite text editor to edit the `docker-compose` file. Make sure
    you also include the mistakes we have purposely added to the file to make sure
    the `dcvalidator` picks up these errors, and we will use the `docker-stress` image
    we created earlier in this chapter. Make sure you copy this file word for word
    as we are trying to make sure we force some errors in our `docker-compose.yml`
    file:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的文本编辑器来编辑`docker-compose`文件。确保您还包括我们故意添加到文件中的错误，以确保`dcvalidator`能够发现这些错误，并且我们将使用本章前面创建的`docker-stress`镜像。确保您逐字复制此文件，因为我们正在努力确保在我们的`docker-compose.yml`文件中强制出现一些错误：
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the `validator-cli.py` script with the `-f` option to parse the specific
    file we want to validate – in the following command line, the `docker-compose.yml`
    file. The `-fi` option then allows you to specify the filters available to validate
    over our `compose` file. In the following code, we are using all the filters available
    at this point for `validator-cli`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-f`选项运行`validator-cli.py`脚本来解析我们想要验证的特定文件——在以下命令行中，即`docker-compose.yml`文件。然后，`-fi`选项允许您指定可用于验证我们的`compose`文件的过滤器。在以下代码中，我们正在使用`validator-cli`目前可用的所有过滤器：
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should get output like the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得以下类似的输出：
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As expected, there are quite a few errors that `validator-cli.py` has been able
    to find. It has shown that you have duplicate ports assigned in your app service,
    and the DNS you have set up is also incorrect. `App2` is showing some spelling
    mistakes and suggesting we could use a different value instead.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`validator-cli.py`已经能够找到相当多的错误。它显示您在应用服务中分配了重复的端口，并且您设置的DNS也是不正确的。`App2`显示了一些拼写错误，并建议我们可以使用不同的值。
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you need to specify the filters you would like your `docker-compose.yml`
    file to be validated against, but this will change with the coming releases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您需要指定您希望您的`docker-compose.yml`文件针对哪些过滤器进行验证，但这将随着即将发布的版本而改变。
- en: 'You''ll remember that we used a `docker-compose` file to install the Anchore
    image scanner. When you have the URL location of the `compose` file, use the `-u`
    option to pass the URL for the file to be validated. In this instance, it is on
    the Packt GitHub account:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会记得，我们使用了一个`docker-compose`文件来安装Anchore镜像扫描程序。当您有`compose`文件的URL位置时，使用`-u`选项传递文件的URL以进行验证。在这种情况下，它位于Packt
    GitHub账户上：
- en: '[PRE85]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As you can see in the following code block, `dcvalidator` does not pick up
    any errors in the `docker-compose.yml` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下代码块中所见，`dcvalidator`没有在`docker-compose.yml`文件中发现任何错误：
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the Docker Compose validator is fairly basic, but it can pick
    up a few errors in our `docker-compose.yml` file that we may have missed. This
    could especially be the case if we have a larger file; there is a possibility
    that we could have missed a few minor errors before trying to deploy our environment.
    This has brought us to the end of this part of the chapter where we have been
    using some automated processes and applications to validate and lint our `Dockerfiles`
    and `docker-compose.yml` file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Docker Compose验证器相当基本，但它可以发现我们可能错过的`docker-compose.yml`文件中的一些错误。特别是在我们有一个较大的文件时，如果我们在尝试部署环境之前可能错过了一些较小的错误，这可能是可能的。这已经将我们带到了本章的这一部分的结束，我们一直在使用一些自动化流程和应用程序来验证和清理我们的`Dockerfiles`和`docker-compose.yml`文件。
- en: Now, let's move on to the activities, which will help you test your understanding
    of the chapter. In the following activity, you will view the resources used by
    one of the services running on the Panoramic Trekking App.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行活动，这将帮助您测试对本章的理解。在接下来的活动中，您将查看Panoramic Trekking App上运行的一个服务使用的资源。
- en: 'Activity 12.01: Viewing the Resources Used by the Panoramic Trekking App'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：查看Panoramic Trekking App使用的资源
- en: 'Earlier in this chapter, we looked at how our running container consumed resources
    on our host system. In this activity, you will choose one of the services running
    on the Panoramic Trekking App, run the container with its default configurations,
    and see what CPU and memory resources it uses. Then, run the container again with
    changes to the CPU and memory configurations to see how this affects the resource
    usage:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看了一下我们正在运行的容器在我们的主机系统上消耗了多少资源。在这个活动中，您将选择全景徒步应用程序上运行的服务之一，使用其默认配置运行容器，并查看它使用了什么CPU和内存资源。然后，再次运行容器，更改CPU和内存配置，以查看这如何影响资源使用情况：
- en: 'The general set of steps you''ll need to complete this activity runs as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成此活动的一般步骤如下：
- en: Decide on a service in the Panoramic Trekking App that you would like to test.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定在全景徒步应用程序中选择一个您想要测试的服务。
- en: Create a set of tests that you can use to then measure the resource usage of
    the service.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组测试，然后用它们来测量服务的资源使用情况。
- en: Start your service and monitor the resource usage using the tests you created
    in the previous step.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的服务，并使用您在上一步中创建的测试来监视资源使用情况。
- en: Stop your service from running and run it again, this time with changes to the
    CPU and memory configurations.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止您的服务运行，并再次运行它，这次更改CPU和内存配置。
- en: Monitor the resource usage again using the tests you created in *step 2* and
    compare the changes in resource usage.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用您在*步骤2*中创建的测试监视资源使用情况，并比较资源使用情况的变化。
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor350).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor350)找到。
- en: The next activity will help you use `hadolint` on your `Dockerfiles` to improve
    the best practices.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个活动将帮助您在您的`Dockerfiles`上使用`hadolint`来改进最佳实践。
- en: 'Activity 12.02: Using hadolint to Improve the Best Practices on Dockerfiles'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.02：使用hadolint改进Dockerfiles上的最佳实践
- en: '`hadolint` provides a great way to enforce best practices when you are creating
    your Docker images. In this activity, you will once again use the `Dockerfile`
    from the `docker-stress` image to see whether you can use the recommendations
    from `hadolint` to improve the `Dockerfile` so that it adheres to best practices
    as much as possible.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`hadolint`提供了一个很好的方式来强制执行最佳实践，当您创建您的Docker镜像时。在这个活动中，您将再次使用`docker-stress`镜像的`Dockerfile`，以查看您是否可以使用`hadolint`的建议来改进`Dockerfile`，使其尽可能地符合最佳实践。'
- en: 'The steps you''ll need to complete this activity are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成此活动的步骤如下：
- en: Ensure you have the `hadolint` image available and running on your system.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的系统上有`hadolint`镜像可用并正在运行。
- en: Run the `hadolint` image over the `Dockerfile` for the `docker-stress` image
    and record the results.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`docker-stress`镜像的`Dockerfile`运行`hadolint`镜像，并记录结果。
- en: Make the recommended changes to the `Dockerfile` from the previous step.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对上一步中的`Dockerfile`进行推荐的更改。
- en: Test the `Dockerfile` again.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次测试`Dockerfile`。
- en: 'You should get the following output on the successful completion of the activity:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动后，您应该获得以下输出：
- en: '![Figure 12.3: Expected output of Activity 12.02'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：活动12.02的预期输出'
- en: '](image/B15021_12_03.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_12_03.jpg)'
- en: 'Figure 12.3: Expected output of Activity 12.02'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：活动12.02的预期输出
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor351).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor351)找到。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has seen us go through a lot of theory as well as some in-depth
    work on exercises. We started the chapter by looking at how our running Docker
    containers utilize the host system's CPU, memory, and disk resources. We looked
    at the ways in which we can monitor how these resources are consumed by our containers
    and configure our running containers to reduce the number of resources used.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们深入研究了许多理论知识，以及对练习进行了深入的工作。我们从查看我们的运行Docker容器如何利用主机系统的CPU、内存和磁盘资源开始了本章。我们研究了监视这些资源如何被我们的容器消耗，并配置我们的运行容器以减少使用的资源数量。
- en: We then looked at the Docker best practices, working through a number of different
    topics, including utilizing base images, installing programs and cleanup, developing
    your underlying application for scalability, and configuring your applications
    and images. We then introduced some tools to help you enforce these best practices,
    including `hadolint` and `FROM:latest` to help you lint your `Dockerfiles`, and
    `dcvalidator` to check over your `docker-compose.yml` files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了Docker的最佳实践，涉及了许多不同的主题，包括利用基础镜像、安装程序和清理、为可扩展性开发底层应用程序，以及配置应用程序和镜像。然后，我们介绍了一些工具，帮助您执行这些最佳实践，包括`hadolint`和`FROM:latest`，帮助您对`Dockerfiles`进行代码检查，以及`dcvalidator`来检查您的`docker-compose.yml`文件。
- en: The next chapter takes our monitoring skills up another level as we introduce
    using Prometheus to monitor our container metrics and resources.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将进一步提升我们的监控技能，介绍使用Prometheus来监控我们的容器指标和资源。
