- en: Chapter 4. Using Task Parallel Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用任务并行库
- en: 'In this chapter, we will dive into a new asynchronous programming paradigm,
    Task Parallel Library. You will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究一种新的异步编程范式，任务并行库。您将学习以下内容：
- en: Creating a task
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务
- en: Performing basic operations with a task
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行任务的基本操作
- en: Combining tasks together
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务组合在一起
- en: Converting the APM pattern to tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将APM模式转换为任务
- en: Converting the EAP pattern to tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将EAP模式转换为任务
- en: Implementing a cancellation option
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: Handling exceptions in tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任务中的异常
- en: Running tasks in parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行任务
- en: Tweaking tasks execution with TaskScheduler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TaskScheduler调整任务执行
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we learned what a thread is, how to use threads, and
    why we need a thread pool. Using a thread pool allows us to save operating system
    resources at the cost of reducing a parallelism degree. We can think of thread
    pool as an **abstraction layer** that hides details of thread usage from a programmer,
    allowing us to concentrate on a program's logic rather than on threading issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了什么是线程，如何使用线程，以及为什么我们需要线程池。使用线程池允许我们节省操作系统资源，但代价是降低了并行度。我们可以将线程池视为一个**抽象层**，它将线程使用的细节隐藏起来，使我们能够集中精力在程序逻辑上，而不是线程问题上。
- en: However, using a thread pool is complicated as well. There is no easy way to
    get a result from a thread pool worker thread. We need to implement our own way
    to get a result back, and in case of exception, we have to propagate it to the
    original thread properly. Besides this, there is no easy way to create a set of
    dependent asynchronous actions, where one action runs after another finishes its
    work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用线程池也是复杂的。没有简单的方法从线程池工作线程中获取结果。我们需要实现自己的方法来获取结果，并且在发生异常时，我们必须正确地将其传播到原始线程。除此之外，没有简单的方法来创建一组依赖的异步操作，其中一个操作在另一个操作完成后运行。
- en: There were several attempts to work around those issues, which resulted in the
    creation of Asynchronous Programming Model and Event-based Asynchronous Pattern,
    mentioned in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"), *Using a
    Thread Pool*. These patterns made getting results easier, and did a good work
    with propagating exceptions, but combining asynchronous actions together still
    required a lot of work and resulted in a large amount of code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有几次尝试解决这些问题，结果产生了异步编程模型和基于事件的异步模式，这在[第3章](ch03.html "第3章。使用线程池")*使用线程池*中提到。这些模式使得获取结果更容易，并且在传播异常方面做得很好，但是将异步操作组合在一起仍然需要大量的工作，并且导致了大量的代码。
- en: To resolve all these problems, a new API for asynchronous operations was introduced
    in .Net Framework 4.0\. It is called **Task Parallel Library** (**TPL**). It was
    changed slightly in .Net Framework 4.5, and to make it clear, we will work with
    the latest version of TPL by using the 4.5 Version of .Net Framework in our projects.
    TPL can be considered as one more abstraction layer over a thread pool, hiding
    the lower-level code that will work with the thread pool from a programmer, and
    supplying a more convenient and fine-grained API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，在.Net Framework 4.0中引入了一种新的用于异步操作的API。它被称为**任务并行库**（**TPL**）。它在.Net
    Framework 4.5中略有改变，为了更清楚起见，我们将在我们的项目中使用.Net Framework 4.5版本来使用最新版本的TPL。TPL可以被视为线程池上的另一种抽象层，它隐藏了与线程池一起工作的底层代码，使程序员无需关注，并提供了更方便和细粒度的API。
- en: The core concept of TPL is a task. A task represents an asynchronous operation,
    which can be run in a variety of ways, using a separate thread or not. We will
    look through all possibilities in detail in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TPL的核心概念是任务。任务代表一个异步操作，可以以各种方式运行，使用单独的线程或不使用。我们将在本章中详细讨论所有可能性。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, a programmer is not aware how exactly the task is executing. TPL
    raises the level of abstraction by hiding the task implementation details from
    the user. Unfortunately, in some cases this could lead to mysterious errors, such
    as hanging the application while trying to get a result from the task. This chapter
    will help to understand mechanics under the hood of TPL, and how to avoid using
    it in improper ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，程序员不知道任务的执行方式。TPL通过隐藏任务的实现细节，提高了抽象级别。不幸的是，在某些情况下，这可能导致神秘的错误，比如在尝试从任务中获取结果时挂起应用程序。本章将帮助理解TPL底层的机制，以及如何避免以不当的方式使用它。
- en: A task can be combined with other tasks in different variations. For example,
    we are able to start several tasks simultaneously, wait for all of them to complete,
    and then run a task that will perform some calculations over all the previous
    tasks' results. Convenient APIs for task combination is one of the key advantages
    of TPL compared to the previous patterns.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以以不同的方式与其他任务组合。例如，我们可以同时启动几个任务，等待它们全部完成，然后运行一个任务，对所有先前任务的结果进行一些计算。与以前的模式相比，任务组合的便利API是TPL的关键优势之一。
- en: There are also several ways to deal with exceptions resulting from tasks. Since
    a task may consist of several another tasks, and they in turn have their child
    tasks as well, there is a concept of `AggregateException`. This type of exception
    is holding all exceptions from underlying tasks inside, allowing handling them
    separately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种处理任务异常的方法。由于一个任务可能由几个其他任务组成，它们又有自己的子任务，因此有一个`AggregateException`的概念。这种类型的异常包含了所有底层任务的异常，允许单独处理它们。
- en: And, last but not least, C# 5.0 has built-in support for TPL, allowing us to
    work with tasks in a very smooth and comfortable way using the new `await` and
    `async` keywords. We will discuss this topic in [Chapter 5](ch05.html "Chapter 5. Using
    C# 5.0"), *Using C# 5.0*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，C# 5.0内置了对TPL的支持，允许我们使用新的`await`和`async`关键字以非常流畅和舒适的方式处理任务。我们将在[第5章](ch05.html
    "第5章。使用C# 5.0")*使用C# 5.0*中讨论这个话题。
- en: In this chapter, we will learn to use TPL to execute asynchronous operations.
    We will learn what a task is, cover different ways to create tasks, and how to
    combine tasks together. We will also discuss how to convert legacy APM and EAP
    patterns to use tasks, how to handle exceptions properly, how to cancel tasks,
    and how to work with several tasks executing simultaneously. In addition, we will
    find out how to deal with tasks in Windows GUI applications properly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用TPL执行异步操作。我们将学习任务是什么，覆盖创建任务的不同方式，以及如何将任务组合在一起。我们还将讨论如何将传统的APM和EAP模式转换为使用任务，如何正确处理异常，如何取消任务，以及如何同时处理多个任务。此外，我们将了解如何正确处理Windows
    GUI应用程序中的任务。
- en: Creating a task
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: This recipe shows a basic concept of what a task is. You will learn how to create
    and execute tasks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了任务的基本概念。您将学习如何创建和执行任务。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need **Visual Studio 2012**. There are
    no other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter4\Recipe1`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个配方进行，您将需要**Visual Studio 2012**。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter4\Recipe1`中找到。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create and execute a task, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和执行任务，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This time, please make sure that you are using .Net Framework 4.5\. From now
    on, we will be using this version for every project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，请确保您使用的是.Net Framework 4.5。从现在开始，我们将为每个项目使用这个版本。
- en: '![How to do it...](img/7644OT_04_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/7644OT_04_01.jpg)'
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, it creates two tasks with its constructor. We pass the
    lambda expression as the `Action` delegate; this allows us to provide a string
    parameter to `TaskMethod`. Then, we run these tasks by using the `Start` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它使用构造函数创建两个任务。我们将lambda表达式作为`Action`委托传递；这允许我们向`TaskMethod`提供一个字符串参数。然后，我们使用`Start`方法运行这些任务。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that until we call the `Start` method on those tasks, they will
    not start executing. It is very easy to forget to actually start the task.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用这些任务的`Start`方法之前，它们不会开始执行。很容易忘记实际启动任务。
- en: Then, we run two more tasks using the `Task.Run` and `Task.Factory.StartNew`
    methods. The difference is that both the created tasks immediately start working,
    so we do not need to call the `Start` method on the tasks explicitly. All of the
    tasks, number `Task 1` to `Task 4`, are placed on thread pool worker threads and
    run in an unspecified order. If you run the program several times, you will find
    that the tasks' execution order is not defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Task.Run`和`Task.Factory.StartNew`方法运行另外两个任务。不同之处在于，创建的任务立即开始工作，因此我们不需要在任务上显式调用`Start`方法。所有任务，从`Task
    1`到`Task 4`，都放置在线程池工作线程上，并以未指定的顺序运行。如果多次运行程序，您会发现任务的执行顺序是不确定的。
- en: The `Task.Run` method is just a shortcut to `Task.Factory.StartNew`, but the
    latter method has additional options. In general, use the former method unless
    you need to do something special, as in case of `Task 5`. We mark this task as
    long running, and as a result, this task will be run on a separate thread not
    using a thread pool. However, this behavior could change, depending on the current
    **task scheduler** that runs the task. You will learn what a task scheduler is
    in the last recipe of this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Run`方法只是`Task.Factory.StartNew`的快捷方式，但后者有额外的选项。一般情况下，除非需要做一些特殊的事情，如`Task
    5`的情况，否则使用前者方法。我们将这个任务标记为长时间运行，结果，这个任务将在一个单独的线程上运行，而不使用线程池。然而，这种行为可能会改变，取决于当前运行任务的**任务调度程序**。您将在本章的最后一个配方中了解什么是任务调度程序。'
- en: Performing basic operations with a task
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行任务的基本操作
- en: This recipe will describe how to get the result value from a task. We will go
    through several scenarios to understand the difference between running a task
    on a thread pool or on a main thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述如何从任务中获取结果值。我们将通过几种情景来理解在线程池或主线程上运行任务的区别。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found at `BookSamples\Chapter4\Recipe2`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，您将需要Visual Studio 2012。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter4\Recipe2`中找到。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To perform basic operations with a task, perform the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行任务的基本操作，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At first, we run `TaskMethod` without wrapping it into a task. As a result,
    it is executing synchronously, providing us with the information about the main
    thread. Obviously, it is not a thread-pool thread.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行`TaskMethod`，而不将其包装成任务。结果，它是同步执行的，为我们提供了关于主线程的信息。显然，这不是一个线程池线程。
- en: Then we run `Task 1`, starting it with the `Start` method and waiting for the
    result. This task will be placed on a thread pool, and the main thread waits and
    is blocked until the task returns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行`Task 1`，使用`Start`方法启动它并等待结果。这个任务将放在线程池上，主线程会等待并被阻塞，直到任务返回。
- en: We do the same with `Task 2`, except that we run it using the `RunSynchronously()`
    method. This task will run on the main thread, and we get exactly the same output
    as in the very first case when we just called `TaskMethod` synchronously. This
    is a very useful optimization, allowing us to avoid thread pool usage for very
    short-lived operations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Task 2`做同样的操作，只是我们使用`RunSynchronously()`方法来运行它。这个任务将在主线程上运行，我们得到的输出与当我们只是同步调用`TaskMethod`时完全相同。这是一个非常有用的优化，允许我们避免对非常短暂的操作使用线程池。
- en: We run `Task 3` in the same way we did with `Task 1`, but instead of blocking
    the main thread, we just spin, printing out the task status until the task is
    completed. This shows several task statuses, which are `Created`, `Running`, and
    `RanToCompletion` respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与`Task 1`相同的方式运行`Task 3`，但是不阻塞主线程，只是旋转，打印出任务状态，直到任务完成。这显示了几个任务状态，分别是`Created`，`Running`和`RanToCompletion`。
- en: Combining tasks together
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将任务组合在一起
- en: This recipe will show how to set up tasks that are dependent on each other.
    We will learn how to create a task that will run after the parent task completes.
    In addition, we will discover a possibility to save thread usage for very short-lived
    tasks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示如何设置相互依赖的任务。我们将学习如何创建一个任务，在父任务完成后运行。此外，我们将发现一种节省线程使用的可能性，用于非常短暂的任务。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe3`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter4\Recipe3`中找到。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For combining tasks together, perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任务组合在一起，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **Console Application**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, we create two tasks, and for the first task we
    set up a **continuation** (a block of code that runs after the antecedent task
    is complete). Then we start both the tasks and wait for 4 seconds, which is enough
    for both tasks to complete. Then we run another continuation to the second task
    and try to execute it synchronously by specifying a `TaskContinuationOptions.ExecuteSynchronously`
    option. This is a useful technique when the continuation is very short-lived,
    and it will be faster to run it on the main thread than to put it on a thread
    pool. We are able to achieve this because the second task is completed by that
    moment. If we comment out the 4 seconds `Thread.Sleep` method, we will see that
    this code will be put on a thread pool because we do not have the result from
    the antecedent task yet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建两个任务，对于第一个任务，我们设置了一个**continuation**（在前一个任务完成后运行的代码块）。然后我们启动这两个任务并等待4秒，这足够让两个任务都完成。然后我们对第二个任务运行另一个continuation，并尝试通过指定`TaskContinuationOptions.ExecuteSynchronously`选项同步执行它。当continuation非常短暂时，这是一种有用的技术，它将更快地在主线程上运行而不是放在线程池中。我们能够做到这一点是因为第二个任务在那时已经完成。如果我们注释掉4秒的`Thread.Sleep`方法，我们将看到这段代码将被放在线程池中，因为我们还没有从前一个任务得到结果。
- en: Finally, we define a continuation for the previous continuation, but in a slightly
    different manner, using the new `GetAwaiter` and `OnCompleted` methods. These
    methods are intended to be used along with C# 5.0 language asynchronous mechanics.
    We will cover this topic later in [Chapter 5](ch05.html "Chapter 5. Using C# 5.0"),
    *Using C# 5.0*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以稍微不同的方式为前一个continuation定义一个continuation，使用新的`GetAwaiter`和`OnCompleted`方法。这些方法旨在与C#
    5.0语言的异步机制一起使用。我们将在[第5章](ch05.html "第5章。使用C# 5.0")中详细介绍这个主题，*使用C# 5.0*。
- en: The last part of the demo is about the parent-child task relationships. We create
    a new task, and while running this task, we run a so-called child task by providing
    a `TaskCreationOptions.AttachedToParent` option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 演示的最后部分是关于父子任务关系。我们创建一个新任务，同时运行这个任务，通过提供`TaskCreationOptions.AttachedToParent`选项来运行所谓的子任务。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The child task must be created while running a parent task to attach to the
    parent properly!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行父任务时必须创建子任务以正确附加到父任务！
- en: This means that the parent task *will not complete* until all child tasks finish
    its work. We are also able to run continuations on a child tasks providing a `TaskContinuationOptions.AttachedToParent`
    option. This continuation will affect the parent task as well, and it will not
    complete until the very last child task ends.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着父任务*不会完成*直到所有子任务完成其工作。我们还能够在子任务上运行continuations，提供`TaskContinuationOptions.AttachedToParent`选项。这个continuation也会影响父任务，并且直到最后一个子任务结束才会完成。
- en: Converting the APM pattern to tasks
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将APM模式转换为任务
- en: In this recipe, we will see how to convert an old-fashioned APM API to a task.
    There are examples of different situations that could happen in the process of
    conversion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何将老式的APM API转换为任务。有不同情况的示例可能发生在转换过程中。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe4`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter4\Recipe4`中找到。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For converting the APM pattern to tasks, perform the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将APM模式转换为任务，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **Console Application**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here we define two kinds of delegates; one of them is using the `out` parameter
    and therefore is incompatible with the standard TPL API for converting the APM
    pattern to tasks. Then we have three examples of such a conversion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两种类型的委托；其中一种使用了`out`参数，因此与将APM模式转换为任务的标准TPL API不兼容。然后我们有三个这样转换的示例。
- en: The key point for converting APM to TPL is a `Task<T>.Factory.FromAsync` method,
    where `T` is the asynchronous operation result type. There are several overloads
    of this method; in the first case, we pass `IAsyncResult` and `Func<IAsyncResult,
    string>`, which is a method that accepts `IAsyncResult` implementation and returns
    a string. Since the first delegate type provides `EndMethod` that is compatible
    with this signature, we have no problem converting this delegate asynchronous
    call to a task.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将APM转换为TPL的关键点是`Task<T>.Factory.FromAsync`方法，其中`T`是异步操作的结果类型。该方法有几种重载；在第一种情况下，我们传递`IAsyncResult`和`Func<IAsyncResult,
    string>`，这是一个接受`IAsyncResult`实现并返回一个字符串的方法。由于第一个委托类型提供了与此签名兼容的`EndMethod`，因此我们可以毫无问题地将这个委托异步调用转换为任务。
- en: In the second example, we do almost the same, but use a different `FromAsync`
    method overload, which does not allow specifying a callback that will be executed
    after the asynchronous delegate call completes. We are able to replace this with
    continuation, but if the callback is important, we can use the first example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们做了几乎相同的事情，但使用了不同的`FromAsync`方法重载，它不允许指定在异步委托调用完成后将执行的回调。我们可以用延续来替换这个，但如果回调很重要，我们可以使用第一个示例。
- en: The last example shows a little trick. This time, `EndMethod` of the `IncompatibleAsynchronousTask`
    delegate uses the `out` parameter, and is not compatible with any `FromAsync`
    method overload. However, it is very easy to wrap the `EndMethod` call into a
    lambda expression that will be suitable for the task factory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了一个小技巧。这次，`IncompatibleAsynchronousTask`委托的`EndMethod`使用了`out`参数，并且与任何`FromAsync`方法重载都不兼容。然而，很容易将`EndMethod`调用包装成适用于任务工厂的lambda表达式。
- en: To see what is going on with the underlying task, we are printing its status
    while waiting for the asynchronous operation's result. We see that the first task's
    status is `WaitingForActivation`, which means that the task was not actually started
    yet by the TPL infrastructure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看底层任务的情况，我们在等待异步操作结果时打印其状态。我们看到第一个任务的状态是`WaitingForActivation`，这意味着任务实际上还没有被TPL基础架构启动。
- en: Converting the EAP pattern to tasks
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将EAP模式转换为任务
- en: This recipe will describe how to translate event-based asynchronous operations
    to tasks. In this recipe, you will find a solid pattern that is suitable for every
    event-based asynchronous API in the .NET Framework class library.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将描述如何将基于事件的异步操作转换为任务。在本教程中，您将找到一个适用于.NET Framework类库中的每个基于事件的异步API的可靠模式。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe5`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本教程，您需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在`BookSamples\Chapter4\Recipe5`中找到。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For converting the EAP pattern to tasks, perform the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要将EAP模式转换为任务，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This is a very simple and elegant example of converting EAP patterns to tasks.
    The key point is to use the `TaskCompletionSource<T>` type, where `T` is an asynchronous
    operation result type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单而优雅的将EAP模式转换为任务的例子。关键点是使用`TaskCompletionSource<T>`类型，其中`T`是异步操作的结果类型。
- en: It is also important to not forget to wrap the `tcs.SetResult` method call into
    the `try` **-** `catch` block to guarantee that the error information is always
    set to the task completion source object. It is also possible to use the `TrySetResult`
    method instead of `SetResult` to make sure that the result has been set successfully.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是不要忘记将`tcs.SetResult`方法调用包装在`try`-`catch`块中，以确保错误信息始终设置到任务完成源对象中。也可以使用`TrySetResult`方法代替`SetResult`，以确保结果已成功设置。
- en: Implementing a cancellation option
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: This recipe is about implementing the cancellation process for task-based asynchronous
    operations. We will learn how to use the cancellation token properly for tasks,
    and how to find out whether a task is cancelled before it was actually run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程是关于为基于任务的异步操作实现取消过程。我们将学习如何正确使用取消令牌来处理任务，以及如何在任务实际运行之前找出任务是否已取消。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start with this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe6`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本教程，您需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在`BookSamples\Chapter4\Recipe6`中找到。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For implementing a cancellation option for task-based asynchronous operations,
    perform the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要为基于任务的异步操作实现取消选项，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This is another very simple example of how to implement the cancellation option
    for a TPL task, as you are already familiar with the cancellation token concept
    we discussed in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"), *Using
    a Thread Pool*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个非常简单的例子，说明如何为 TPL 任务实现取消选项，因为你已经熟悉我们在[第三章](ch03.html "第三章。使用线程池")中讨论的取消标记概念，*使用线程池*。
- en: First, let's look closely at the `longTask` creation code. We'll pass a cancellation
    token to the underlying task once and then to the task constructor the second
    time. *Why do we need to supply this token twice?*
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仔细看看 `longTask` 创建代码。我们将一次性传递一个取消标记给底层任务，然后第二次传递给任务构造函数。*为什么我们需要两次提供这个标记？*
- en: The answer is that if we cancel the task before it was actually started, its
    TPL infrastructure is responsible for dealing with the cancellation, because our
    code will not execute at all. We know that the first task was canceled by getting
    its status. If we will try to call the `Start` method on this task, we will get
    `InvalidOperationException`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，如果我们在任务实际开始之前取消了任务，它的 TPL 基础结构负责处理取消，因为我们的代码根本不会执行。我们知道第一个任务被取消了，通过获取它的状态。如果我们尝试在这个任务上调用
    `Start` 方法，我们将得到 `InvalidOperationException`。
- en: Then, we deal with the cancellation process from our own code. This means that
    we are now fully responsible for the cancellation process, and after we canceled
    the task, its status is still `RanToCompletion`, because from TPL's perspective,
    the task finished its job normally. It is very important to distinguish these
    two situations and understand the responsibility difference in each case.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从我们自己的代码中处理取消过程。这意味着我们现在完全负责取消过程，而在我们取消任务后，它的状态仍然是 `RanToCompletion`，因为从
    TPL 的角度来看，任务正常完成了它的工作。在每种情况下理解责任差异非常重要。
- en: Handling exceptions in tasks
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理任务中的异常
- en: This recipe describes the very important topic of handling exceptions in asynchronous
    tasks. We will go through different aspects of what happens to exceptions thrown
    from tasks and how to get to their information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤描述了在异步任务中处理异常的非常重要的主题。我们将讨论从任务中抛出的异常发生的不同方面以及如何获取它们的信息。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe7`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤，你需要 Visual Studio 2012。没有其他先决条件。这个步骤的源代码可以在 `BookSamples\Chapter4\Recipe7`
    中找到。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For handling exceptions in tasks, perform the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理任务中的异常，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2012。创建一个新的 C# **控制台应用程序** 项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下面添加以下代码片段：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中添加以下代码片段：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create a task and try to get the task results synchronously.
    The `Get` part of the `Result` property makes the current thread wait until the
    completion of the task and propagates the exception to the current thread. In
    this case, we easily catch the exception in catch block, but this exception is
    a wrapper exception called `AggregateException`. In this case, it holds only one
    exception inside, because only one task has thrown this exception, and it is possible
    to get the underlying exception by accessing the `InnerException` property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，我们创建一个任务，并尝试同步获取任务结果。`Result` 属性的 `Get` 部分使当前线程等待任务完成，并将异常传播到当前线程。在这种情况下，我们很容易在
    catch 块中捕获异常，但这个异常是一个名为 `AggregateException` 的包装异常。在这种情况下，它只包含一个异常，因为只有一个任务抛出了这个异常，可以通过访问
    `InnerException` 属性来获取底层异常。
- en: The second example is mostly the same, but to access the task result we use
    the `GetAwaiter` and `GetResult` methods. In this case, we do not have wrapper
    exception because it is unwrapped by the TPL infrastructure. We have an original
    exception at once, which is quite comfortable if we have only one underlying task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子大部分相同，但是为了访问任务结果，我们使用 `GetAwaiter` 和 `GetResult` 方法。在这种情况下，我们没有包装异常，因为它被
    TPL 基础结构解包了。我们一次性获得原始异常，如果只有一个底层任务，这是非常舒适的。
- en: The last example shows the situation where we have two task-throwing exceptions.
    To handle exceptions, we use now a continuation, which is executed only in case
    the antecedent task finishes with exception. This behavior is achieved by providing
    a `TaskContinuationOptions.OnlyOnFaulted` option to a continuation. As a result,
    we have `AggregateException` being printed out, and we have two inner exceptions
    from the both tasks inside it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子展示了我们有两个任务抛出异常的情况。为了处理异常，我们现在使用一个继续，只有在前置任务以异常结束时才执行。通过为继续提供 `TaskContinuationOptions.OnlyOnFaulted`
    选项来实现这种行为。结果，我们打印出 `AggregateException`，并且其中包含来自两个任务的两个内部异常。
- en: There's more…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As tasks may be connected in a very different manner, the resulting `AggregateException`
    exception might contain other aggregate exceptions inside along with the usual
    exceptions. Those inner aggregate exceptions might themselves contain other aggregate
    exceptions within them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务可能以非常不同的方式连接，因此生成的 `AggregateException` 异常可能包含其他聚合异常以及通常的异常。这些内部聚合异常本身可能包含其中的其他聚合异常。
- en: To get rid of those wrappers, we should use the root aggregate exception's `Flatten`
    method. It will return a collection of all the inner exceptions of every child
    aggregate exception in the hierarchy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了摆脱这些包装器，我们应该使用根聚合异常的 `Flatten` 方法。它将返回层次结构中每个子聚合异常的所有内部异常的集合。
- en: Running tasks in parallel
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行任务
- en: This recipe shows how to handle many asynchronous tasks running simultaneously.
    We will learn how to be notified effectively when all tasks are complete or any
    of the running tasks have to finish their work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何处理同时运行的许多异步任务。我们将学习如何在所有任务完成或任何正在运行的任务必须完成它们的工作时有效地得到通知。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe8`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter4\Recipe8`中找到。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For running tasks in parallel, perform the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行运行任务，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program starts, we create two tasks, and then with the help of the
    `Task.WhenAll` method, we create a third task, which will complete after all the
    tasks are complete. The resulting task provides us with an answers array, where
    the first element holds the first task's result, the second element holds the
    second result, and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，我们创建两个任务，然后借助`Task.WhenAll`方法创建一个第三个任务，该任务将在所有任务完成后完成。结果任务为我们提供了一个答案数组，其中第一个元素保存第一个任务的结果，第二个元素保存第二个结果，依此类推。
- en: Then, we create another list of tasks and wait for any of those tasks to complete
    with the `Task.WhenAny` method. After we have one finished task, we remove it
    from the list and continue to wait for the other tasks to complete until the list
    is empty. This method is useful to get the tasks' completion progress or to use
    timeout while running the tasks. For example, we wait for a number of tasks and
    one of those tasks is counting a timeout. If this task completes first, we just
    cancel those tasks that are not completed yet.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建另一个任务列表，并使用`Task.WhenAny`方法等待其中任何一个任务完成。在我们有一个完成的任务后，我们将其从列表中移除，并继续等待其他任务完成，直到列表为空。这种方法对于获取任务的完成进度或在运行任务时使用超时非常有用。例如，我们等待一些任务，其中一个任务正在计算超时。如果这个任务首先完成，我们就取消那些尚未完成的任务。
- en: Tweaking tasks execution with TaskScheduler
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TaskScheduler调整任务执行
- en: This recipe describes another very important aspect of dealing with tasks, which
    is a proper way to work with UI from the asynchronous code. We will learn what
    a task scheduler is, why it is so important, how it can harm our application,
    and how to use it to avoid errors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例描述了处理任务的另一个非常重要的方面，即从异步代码中正确处理UI的方法。我们将学习任务调度程序是什么，为什么它如此重要，它如何损害我们的应用程序，以及如何使用它来避免错误。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe9`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter4\Recipe9`中找到。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For tweaking tasks execution with `TaskScheduler`, perform the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`TaskScheduler`调整任务执行，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **WPF Application** project. This
    time we will need a UI thread with a message loop, which is not available in console
    applications.![How to do it...](img/7644OT_04_02.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# WPF应用程序项目。这一次，我们将需要一个带有消息循环的UI线程，这在控制台应用程序中是不可用的。
- en: 'In the `MainWindow.xaml` file, add the following markup inside a grid element
    (that is, between the `<Grid>` and `</Grid>` tags):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`文件中，在一个网格元素内添加以下标记（即在`<Grid>`和`</Grid>`标记之间）：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `MainWindow.xaml.cs` file, use the following `using` directives:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml.cs`文件中，使用以下`using`指令：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet below the `MainWindow` constructor:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数下面添加以下代码片段：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here we meet many new things. First, we created a WPF application instead of
    a console application. It is necessary because we need a user interface thread
    with a message loop to demonstrate the different options of running a task asynchronously.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了许多新的东西。首先，我们创建了一个WPF应用程序，而不是控制台应用程序。这是必要的，因为我们需要一个用户界面线程和消息循环来演示异步运行任务的不同选项。
- en: There is a very important abstraction called `TaskScheduler`. This component
    is actually responsible for how the task will be executed. The default task scheduler
    puts tasks on a thread pool worker thread. This is the most common scenario and
    there's no surprise that it is the default option in TPL. We also know how to
    run a task synchronously and how to attach them to the parent tasks to run those
    tasks together. Now let us see what else we can do with tasks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常重要的抽象叫做`TaskScheduler`。这个组件实际上负责任务的执行方式。默认的任务调度程序将任务放在线程池工作线程上。这是最常见的情况，也不奇怪它是TPL中的默认选项。我们还知道如何同步运行任务，以及如何将它们附加到父任务以一起运行。现在让我们看看我们可以用任务做什么。
- en: When the program starts, we create a window with three buttons. The first button
    invokes a synchronous task execution. The code is placed inside the `ButtonSync_Click`
    method. While the task runs, even we are not able to move the application window.
    The user interface is totally frozen while the user interface thread is busy running
    the task, and cannot respond to any message loop until the task is complete. This
    is quite a common bad practice for GUI Windows application, and we need to find
    a way to work around this issue.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，我们创建一个带有三个按钮的窗口。第一个按钮调用同步任务执行。代码放在`ButtonSync_Click`方法中。当任务运行时，即使我们无法移动应用程序窗口。用户界面在任务运行时完全冻结，直到任务完成之前，用户界面线程无法响应任何消息循环。这是GUI
    Windows应用程序的一个常见的不良实践，我们需要找到一种解决这个问题的方法。
- en: The second problem is that we try to access the UI controls from another thread.
    The graphical user interface controls have never been designed to be used from
    multiple threads, and to avoid possible errors, you are not allowed to access
    these components from a thread other than the one on which it was created. When
    we try to do that, we get an exception, and the exception message is printed on
    the main window in 5 seconds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，我们试图从另一个线程访问UI控件。图形用户界面控件从未设计为从多个线程中使用，并且为了避免可能的错误，不允许您从创建它的线程之外的线程访问这些组件。当我们尝试这样做时，我们会收到异常，并且异常消息将在5秒钟后打印在主窗口中。
- en: To resolve the first problem, we try to run the task asynchronously. This is
    what the second button does; the code for this is placed inside the `ButtonAsync_Click`
    method. If you run the task under debugger, you will see that it is placed on
    a thread pool, and in the end, we will get the same exception. However, the user
    interface remains responsive all the time while the task runs. This is a good
    thing, but we need to get rid of the exception.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们尝试异步运行任务。这就是第二个按钮的作用；其中的代码放在`ButtonAsync_Click`方法中。如果在调试器下运行任务，您将看到它被放置在线程池中，最后，我们将得到相同的异常。然而，用户界面在任务运行时始终保持响应。这是一件好事，但我们需要摆脱异常。
- en: And we already did that! To output the error message, a continuation was provided
    with the `TaskScheduler.FromCurrentSynchronizationContext` option. If this is
    not done, we would not see the error message because we would get the same exception
    that happened inside the task. This option instructs the TPL infrastructure to
    put a code inside the continuation on the UI thread and run it asynchronously
    with a help of the UI thread message loop. This resolves the problem with accessing
    UI controls from another thread, but still keeps our UI responsive.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做到了！为了输出错误消息，使用了`TaskScheduler.FromCurrentSynchronizationContext`选项提供了一个继续。如果不这样做，我们将看不到错误消息，因为我们会得到与任务内部发生的相同异常。此选项指示TPL基础结构将代码放在UI线程的继续中，并借助UI线程消息循环异步运行它。这解决了从另一个线程访问UI控件的问题，但仍然保持了我们的UI响应性。
- en: To check if it is true, we press the last button that runs the code inside the
    `ButtonAsyncOK_Click` method. All that is different is that we provide the UI
    thread task scheduler to our task. After the task completes, you will see that
    it runs on the UI thread in an asynchronous manner. The UI remains responsive,
    and it is even possible to press another button despite the wait cursor being
    active.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这是否属实，我们按下最后一个按钮，运行`ButtonAsyncOK_Click`方法中的代码。唯一不同的是，我们为我们的任务提供了UI线程任务调度程序。任务完成后，您将看到它以异步方式在UI线程上运行。UI保持响应，并且即使等待光标处于活动状态，也可以按下另一个按钮。
- en: 'However, there are some tricks for using the UI thread for running tasks. If
    we go back to the synchronous task code and uncomment the line with getting the
    result with the UI thread task scheduler provided, we will never get any result.
    This is a classical deadlock situation: we are dispatching an operation in the
    queue of the UI thread and the UI thread waits for this operation to complete,
    but as it waits, it cannot run the operation, which will never end (not even start).
    This will also happen if we call the `Wait` method on task. To avoid the deadlock,
    never use the synchronous operations on task scheduled to the UI thread; just
    use `ContinueWith`, or `async`/`await` from C# 5.0.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于在UI线程上运行任务有一些技巧。如果我们回到同步任务代码，并取消注释使用UI线程任务调度程序获取结果的行，我们将永远得不到任何结果。这是一个经典的死锁情况：我们正在将操作调度到UI线程的队列中，而UI线程等待此操作完成，但当它等待时，它无法运行操作，这将永远不会结束（甚至不会开始）。如果在任务上调用`Wait`方法，也会发生这种情况。为了避免死锁，永远不要在计划为UI线程的任务上使用同步操作；只使用`ContinueWith`，或者来自C#
    5.0的`async`/`await`。
