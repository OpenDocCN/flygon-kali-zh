- en: Managing Processes in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中管理进程
- en: With a very quick tour through some of the big new features of Java 9, as well
    as those from a couple of previous releases, let's turn our attention to applying
    some of these new APIs in a practical manner. We'll start with a simple process
    manager.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速浏览Java 9的一些重大新功能以及之前几个版本的功能，让我们将注意力转向以实际方式应用其中一些新的API。我们将从一个简单的进程管理器开始。
- en: 'While having your application or utility handle all of your user''s concerns
    internally is usually ideal, occasionally you need to run (or **shell out to**)
    an external program for a variety of reasons. From the very first days of Java,
    this was supported by the JDK via the `Runtime` class via a variety of APIs. Here
    is the simplest example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常最好让应用程序或实用程序在内部处理用户的所有问题，但偶尔您可能需要出于各种原因运行（或**外壳到**）外部程序。从Java的最早时期开始，JDK就通过`Runtime`类提供了各种API来支持这一点。以下是最简单的示例：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the process has been created, you can track its execution via the `Process`
    class, which has methods such as `getInputStream()`, `getOutputStream()`, and
    `getErrorStream()`. We have also had rudimentary control over the process via
    `destroy()` and `waitFor()`. Java 8 moved things forward by adding `destroyForcibly()`
    and `waitFor(long, TimeUnit)`. Starting with Java 9, these capabilities will be
    expanded. Quoting from the **Java Enhancement Proposal** (**JEP**), we see the
    following reasons for this new functionality:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进程创建完成，您可以通过`Process`类跟踪其执行，该类具有诸如`getInputStream()`、`getOutputStream()`和`getErrorStream()`等方法。我们还可以通过`destroy()`和`waitFor()`对进程进行基本控制。Java
    8通过添加`destroyForcibly()`和`waitFor(long, TimeUnit)`推动了事情的发展。从Java 9开始，这些功能将得到扩展。引用**Java
    Enhancement Proposal**（**JEP**）中的内容，我们可以看到为此新功能的以下原因：
- en: '*Many enterprise applications and containers involve several Java virtual machines
    and processes and have long-standing needs that include the following:*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多企业应用程序和容器涉及多个Java虚拟机和进程，并且长期以来一直需要以下功能：*'
- en: '*The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取当前Java虚拟机的pid（或等效值）以及使用现有API创建的进程的pid的能力。*'
- en: '*The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*枚举系统上的进程的能力。每个进程的信息可能包括其pid、名称、状态，以及可能的资源使用情况。*'
- en: '*The ability to deal with process trees, in particular, some means to destroy
    a process tree.*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理进程树的能力，特别是一些销毁进程树的方法。*'
- en: '*The ability to deal with hundreds of sub-processes, perhaps multiplexing the
    output or error streams to avoid creating a thread per sub-process.*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理数百个子进程的能力，可能是复用输出或错误流以避免为每个子进程创建一个线程。*'
- en: In this chapter, we'll build a simple process manager application, akin to Windows
    Task Manager or *nix's top. There is, of course, little need for a process manager
    written in Java, but this will be an excellent avenue for us to explore these
    new process handling APIs. Additionally, we'll spend some time with other language
    features and APIs, namely, JavaFX and `Optional`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个简单的进程管理器应用程序，类似于Windows任务管理器或*nix的top。当然，在Java中没有必要编写进程管理器，但这将是我们探索这些新的进程处理API的绝佳途径。此外，我们还将花一些时间研究其他语言功能和API，即JavaFX和`Optional`。
- en: 'The following topics are covered in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Creating the project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目
- en: Bootstrapping the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导应用程序
- en: Defining the user interface
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: Initializing the user interface
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化用户界面
- en: Adding menus
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加菜单
- en: Updating the process list
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新进程列表
- en: With that said, let's get started.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们开始吧。
- en: Creating a project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Typically speaking, it is much better if a build can be reproduced without
    requiring the use of a specific IDE or some other proprietary tool. Fortunately,
    NetBeans offers the ability to create a Maven-based JavaFX project. Click on File
    | New Project and select `Maven`, then JavaFX Application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如果可以在不需要特定IDE或其他专有工具的情况下重现构建，那将会更好。幸运的是，NetBeans提供了创建基于Maven的JavaFX项目的能力。点击文件
    | 新建项目，然后选择`Maven`，然后选择JavaFX应用程序：
- en: '![](img/bd100520-c6c3-4175-aac0-ab8572069fd9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd100520-c6c3-4175-aac0-ab8572069fd9.png)'
- en: 'Next, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行以下步骤：
- en: Click on Next.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步。
- en: Enter Project Name as `ProcessManager`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为`ProcessManager`。
- en: Enter Group ID as `com.steeplesoft`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Group ID输入为`com.steeplesoft`。
- en: Enter Package as `com.steeplesoft.processmanager`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包输入为`com.steeplesoft.processmanager`。
- en: Select Project Location.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目位置。
- en: Click on Finish.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'Consider the following screenshot as an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下屏幕截图作为示例：
- en: '![](img/e0950b49-e0eb-46e5-a219-efa6d4dc8467.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0950b49-e0eb-46e5-a219-efa6d4dc8467.png)'
- en: 'Once the new project has been created, we need to update the Maven `pom` to
    use Java 9:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目后，我们需要更新Maven的`pom`以使用Java 9：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, with both NetBeans and Maven configured to use Java 9, we're ready to start
    coding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NetBeans和Maven都配置为使用Java 9，我们准备开始编码。
- en: Bootstrapping the application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导应用程序
- en: 'As noted in the introduction, this will be a JavaFX-based application, so we''ll
    start by creating the skeleton for the application. This is a Java 9 application,
    and we intend to make use of the Java Module System. To do that, we need to create
    the module definition file, `module-info.java`, which resides in the root of our
    source tree. This being a Maven-based project, that would be `src/main/java`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，这将是一个基于JavaFX的应用程序，因此我们将从创建应用程序的框架开始。这是一个Java 9应用程序，我们打算利用Java模块系统。为此，我们需要创建模块定义文件`module-info.java`，该文件位于源代码树的根目录。作为基于Maven的项目，这将是`src/main/java`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This small file does a couple of different things. First, it defines a new
    `procman.app` module. Next, it tells the system that this module `requires` two
    JDK modules: `javafx.controls` and `javafx.fxml`. If we did not specify these
    two modules, then our system, which we''ll see below, would not compile, as the
    JDK would not make the required classes and packages available to our application.
    These modules are part of the standard JDK as of Java 9, so that shouldn''t be
    an issue. However, that may change in future versions of Java, and this module
    declaration will help prevent runtime failures in our application by forcing the
    host JVM to provide the module or fail to start. It is also possible to build
    custom Java runtimes via the **J-Link** tool, so missing these modules is still
    a possibility under Java 9\. With our module configured, let''s turn to the application.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小文件做了几件不同的事情。首先，它定义了一个新的`procman.app`模块。接下来，它告诉系统这个模块`requires`两个JDK模块：`javafx.controls`和`javafx.fxml`。如果我们没有指定这两个模块，那么我们的系统在编译时将无法通过，因为JDK不会将所需的类和包提供给我们的应用程序。这些模块是作为Java
    9的标准JDK的一部分，所以这不应该是一个问题。然而，在未来的Java版本中可能会发生变化，这个模块声明将有助于通过强制主机JVM提供模块或无法启动来防止我们的应用程序运行时失败。还可以通过**J-Link**工具构建自定义的Java运行时，因此在Java
    9下缺少这些模块仍然是可能的。有了我们的模块配置，让我们转向应用程序。
- en: The emerging standard directory layout seems to be something like `src/main/java/*<module1>*`,
    `src/main/java/*<module2>*`, and so on. At the time of writing this book, while
    Maven can be coaxed into such a layout, the plugins themselves, while they do
    run under Java 9, do not appear to be module-aware enough to allow us to organize
    our code in such a manner. For that reason, and for the sake of simplicity, we
    will treat one Maven module as one Java module and maintain the standard source
    layout for the projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴的标准目录布局似乎是`src/main/java/*<module1>*`，`src/main/java/*<module2>*`等。在撰写本书时，虽然Maven可以被迫采用这样的布局，但插件本身虽然可以在Java
    9下运行，但似乎不够了解模块，无法让我们以这种方式组织我们的代码。因此，出于简单起见，我们将一个Maven模块视为一个Java模块，并保持项目的标准源布局。
- en: 'The first class we will create is the `Application` descendant, which NetBeans
    created for us. It created the `Main` class, which we renamed to `ProcessManager`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个类是`Application`的子类，NetBeans为我们创建了`Main`类，我们将其重命名为`ProcessManager`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `ProcessManager` class extends the JavaFX base class, `Application`, which
    provides a variety of functionality to start and stop the application. We see
    in the `main()` method that we simply delegate to `Application.launch(String[])`,
    which does the heavy lifting for us in starting our new application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ProcessManager`类扩展了JavaFX基类`Application`，它提供了各种功能来启动和停止应用程序。我们在`main()`方法中看到，我们只是委托给`Application.launch(String[])`，它为我们在启动新应用程序时做了大部分工作。
- en: The more interesting part of this class is the `start()` method, which is where
    the JavaFX life cycle calls back into our application, giving us the opportunity
    to build the user interface, which we'll do next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的更有趣的部分是`start()`方法，这是JavaFX生命周期调用我们的应用程序的地方，让我们有机会构建用户界面，接下来我们将这样做。
- en: Defining the user interface
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: 'When building the user interface for a JavaFX application, you can do it in
    one of two ways: code or markup. To keep our code smaller and more readable, we''ll
    build the user interface using FXML--the XML-based language created specifically
    for JavaFX to express user interfaces. This presents us with another binary choice--do
    we write the XML by hand, or do we use a graphical tool? Again, the choice is
    a simple one--we''ll use a tool, **Scene Builder**, which is a WYSIWYG tool originally
    developed by Oracle and now maintained and supported by Gluon. We will, however,
    also be looking at the XML source so that we can understand what''s being done,
    so if you don''t like using a GUI tool, you won''t be left out.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建JavaFX应用程序的用户界面时，可以通过两种方式之一完成：代码或标记。为了使我们的代码更小更可读，我们将使用FXML构建用户界面--这是专门为JavaFX创建的基于XML的语言，用于表达用户界面。这给我们提供了另一个二元选择--我们是手动编写XML，还是使用图形工具？同样，选择是简单的--我们将使用一个名为**Scene
    Builder**的工具，这是一个最初由Oracle开发，现在由Gluon维护和支持的所见即所得的工具。然而，我们也将查看XML源码，以便了解正在做什么，所以如果你不喜欢使用GUI工具，你也不会被排除在外。
- en: 'Installing and using Scene Builder is, as you would expect, pretty straightforward.
    It can be downloaded from [http://gluonhq.com/labs/scene-builder/](http://gluonhq.com/labs/scene-builder/).
    Once installed, you need to tell NetBeans where to find it, which can be done
    in the Settings window, under Java | JavaFX, as you can see in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和使用Scene Builder就像你期望的那样非常简单。它可以从[http://gluonhq.com/labs/scene-builder/](http://gluonhq.com/labs/scene-builder/)下载。安装完成后，您需要告诉NetBeans在哪里找到它，这可以在设置窗口中完成，在Java
    | JavaFX下，如下截图所示：
- en: '![](img/73de633d-f536-4a29-80ea-a20329d5e939.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73de633d-f536-4a29-80ea-a20329d5e939.png)'
- en: 'We are now ready to create the FXML file. Under the `resources` directory in
    the Project View, create a new folder called `fxml`, and in that folder, create
    a file called `procman.fxml`, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建FXML文件。在项目视图中的`resources`目录下，创建一个名为`fxml`的新文件夹，在该文件夹中创建一个名为`procman.fxml`的文件，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`BorderPane` is a container that defines five regions--`top`, `bottom`, `left`,
    `right`, and `center`, giving us a fairly coarsely-grained control over where
    on the form the controls should appear. Typically, with `BorderPane`, each area
    uses a nested container to provide the finer-grained control often necessary.
    For our needs, this level of control will be perfect.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorderPane`是一个容器，定义了五个区域--`top`、`bottom`、`left`、`right`和`center`，让我们对控件在表单上的位置有了相当粗粒度的控制。通常，使用`BorderPane`，每个区域使用嵌套容器来提供通常必要的更细粒度的控制。对于我们的需求，这种控制水平将是完美的。'
- en: 'The primary concern of the user interface is the list of processes, so we''ll
    start with the controls for that. From Scene Builder, we want to click on the
    `Controls` section on the accordion on the left, then scroll down to `TableView`.
    Click on this and drag it to the `CENTER` region on the form, as shown here in
    this screenshot from Scene Builder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的主要关注点是进程列表，因此我们将从那些控件开始。从Scene Builder中，我们要点击左侧手风琴上的“控件”部分，然后向下滚动到“TableView”。单击此处并将其拖动到表单的“CENTER”区域，如Scene
    Builder中的此截图所示：
- en: '![](img/85785dae-4740-4d97-9bbb-729be9e5b767.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85785dae-4740-4d97-9bbb-729be9e5b767.png)'
- en: 'The resulting FXML should look something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的FXML应该看起来像这样：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With no components in the other areas, `TableView` will expand to fill the window's
    full area, which is what we want for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他区域没有组件的情况下，`TableView`将扩展以填充窗口的整个区域，这是我们目前想要的。
- en: Initializing the user interface
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化用户界面
- en: 'While the FXML defines the structure of the user interface, we do need some
    Java code to initialize various elements, respond to actions, and so forth. This
    class, referred to as the controller, is simply a class that extends `javafx.fxml.Initializable`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FXML定义了用户界面的结构，但我们确实需要一些Java代码来初始化各种元素，响应操作等。这个类，称为控制器，只是一个扩展`javafx.fxml.Initializable`的类：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `initialize()` method comes from the interface, and is used by the JavaFX
    runtime to initialize the controller when it is created in the call to `FXMLLoader.load()`
    from the preceding `Application` class. Note the `@FXML` annotation on the instance
    variable `processList`. When JavaFX initializes the controller, before the `initialize()`
    method is called, the system looks for FXML elements that specify an `fx:id` attribute,
    and assigns that reference to the appropriate instance variable in the controller.
    To complete this connection, we must make one more change to our FXML file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize()`方法来自接口，并且在调用`FXMLLoader.load()`时由JavaFX运行时初始化控制器。请注意`@FXML`注解在实例变量`processList`上。当JavaFX初始化控制器时，在调用`initialize()`方法之前，系统会查找指定了`fx:id`属性的FXML元素，并将该引用分配给控制器中适当的实例变量。为了完成这种连接，我们必须对我们的FXML文件进行一些更改：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The change can also be made in Scene Builder as seen in this screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更改也可以在Scene Builder中进行，如下面的截图所示：
- en: '![](img/24f9d855-7146-4363-8c83-e8a011527891.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24f9d855-7146-4363-8c83-e8a011527891.png)'
- en: The value of the fx:id attribute must match the name of an instance variable
    that has been annotated with `@FXML`. When `initialize` is called, `processList`
    will have a valid reference to `TableView` that we can manipulate in our Java
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: fx:id属性的值必须与已用`@FXML`注释注释的实例变量的名称匹配。当调用`initialize`时，`processList`将具有对我们在Java代码中可以操作的`TableView`的有效引用。
- en: The value of fx:id can be set via Scene Builder as well. To set the value, click
    on the control in the form editor, then expand the Code section in the accordion
    on the right. In the fx:id field, type in the name of the desired variable name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: fx:id的值也可以通过Scene Builder进行设置。要设置该值，请在表单编辑器中单击控件，然后在右侧手风琴中展开代码部分。在fx:id字段中，键入所需变量名称的名称。
- en: 'The final piece of the puzzle is specifying the controller for the FXML file.
    In the XML source, you can set this via the `fx:controller` attribute on the root
    element of the user interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一部分是指定FXML文件的控制器。在XML源中，您可以通过用户界面的根元素上的`fx:controller`属性来设置这一点：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This can also be set via Scene Builder. In the Document section of the accordion
    on the left, expand the Controller section and enter the desired fully-qualified
    class name in the Controller class field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过Scene Builder进行设置。在左侧手风琴上的文档部分，展开控制器部分，并在控制器类字段中输入所需的完全限定类名：
- en: '![](img/f03c7d5b-2065-47b1-8f35-ff8471dde400.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f03c7d5b-2065-47b1-8f35-ff8471dde400.png)'
- en: With those pieces in place, we can begin the work of initializing `TableView`,
    which gets us back to our primary interest, the process handling APIs. Our starting
    point is `ProcessHandles.allProcesses()`. From the Javadoc, you learn that this
    method returns **a snapshot of all processes visible to the current process**.
    From each `ProcessHandle` in the stream, we can get information about the process
    ID, its state, children, parents, and so on. Each `ProcessHandle` also has a nested
    object, `Info`, that contains a snapshot of information about the process. Since
    not all information is available across the various supported platforms and it
    is limited by the privileges of the current process, the properties on the `Info`
    object are the `Optional<T>` instances, indicating that the values may or may
    not be set. It's probably worth the time to take a quick look at what `Optional<T>`
    is.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些部分，我们可以开始初始化`TableView`的工作，这让我们回到了我们的主要兴趣，即处理API的过程。我们的起点是`ProcessHandles.allProcesses()`。从Javadoc中，您可以了解到这个方法返回**当前进程可见的所有进程的快照**。从流中的每个`ProcessHandle`中，我们可以获取有关进程ID、状态、子进程、父进程等的信息。每个`ProcessHandle`还有一个嵌套对象`Info`，其中包含有关进程的信息的快照。由于并非所有信息都可以在各种支持的平台上使用，并且受当前进程的权限限制，`Info`对象上的属性是`Optional<T>`实例，表示值可能设置或可能未设置。可能值得花点时间快速看一下`Optional<T>`是什么。
- en: 'The Javadoc describes `Optional<T>` as a **container object which may or may
    not contain a non-null value**. Inspired by Scala and Haskell, `Optional<T>` was
    introduced in Java 8 to allow API authors to provide a more null-safe interface.
    Prior to Java 8, a method on `ProcessHandle.Info` may be defined like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc将`Optional<T>`描述为**可能包含非空值的容器对象**。受Scala和Haskell的启发，`Optional<T>`在Java
    8中引入，允许API作者提供更安全的空值接口。在Java 8之前，`ProcessHandle.Info`上的方法可能定义如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To consume the API, the developer would likely write something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用API，开发人员可能会写出类似这样的代码：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the developer fails to check for null explicitly, `NullPointerException`
    is almost certain to occur at some point. By using `Optional<T>`, the API author
    signals to the user that the return value may be null and should be handled carefully.
    The updated code, then, may look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发人员未明确检查null，几乎肯定会在某个时候发生`NullPointerException`。通过使用`Optional<T>`，API作者向用户发出信号，表明返回值可能为null，应该小心处理。然后，更新后的代码可能看起来像这样：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, in one concise line, we can get the value, if it is present, or a default
    if it is not. The `ProcessHandle.Info` API makes extensive use of this construct
    as we'll see later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用一行简洁的代码来获取值，如果存在的话，或者获取默认值，如果不存在的话。正如我们将在后面看到的，`ProcessHandle.Info`
    API广泛使用了这种构造方式。
- en: 'What else does `Optional` afford us as developers? There are a number of instance
    methods that can help clarify null-handling code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，`Optional`还为我们提供了一些实例方法，可以帮助澄清处理null的代码：
- en: '`filter(Predicate<? super T> predicate)`: With this method, we filter the contents
    of `Optional`. Rather than using an `if...else` block, we can pass the `filter()`
    method a `Predicate` and do the test inline. A `Predicate` is a `@FunctionalInterface`
    that takes an input and returns a Boolean. For example, some uses of the JavaFX
    `Dialog` may return `Optional<ButtonType>`. If we wanted to do something **only**
    if the user clicked a specific button, say, OK, we could filter `Optional` like
    this:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter(Predicate<? super T> predicate)`: 使用这个方法，我们可以过滤`Optional`的内容。我们可以将`filter()`方法传递一个`Predicate`，而不是使用`if...else`块，并在内联进行测试。`Predicate`是一个接受输入并返回布尔值的`@FunctionalInterface`。例如，JavaFX的`Dialog`的一些用法可能返回`Optional<ButtonType>`。如果我们只想在用户点击了特定按钮时执行某些操作，比如OK，我们可以这样过滤`Optional`：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`map(Function<? super T,? extends U> mapper)`: The `map` function allows us
    to pass the contents of `Optional` to a function, which will perform some processing
    on it, and return it. The return from the function, though, will be wrapped in
    an `Optional`:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map(Function<? super T,? extends U> mapper)`: `map`函数允许我们将`Optional`的内容传递给一个函数，该函数将对其进行一些处理，并返回它。不过，函数的返回值将被包装在一个`Optional`中：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the double wrapping in `Optional` for `upper2`. If `Function` returns `Optional`,
    it will be wrapped in another `Optional`, giving us this odd double wrap, which
    is less than desirable. Fortunately, we have an alternative.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`upper2`中`Optional`的双重包装。如果`Function`返回`Optional`，它将被包装在另一个`Optional`中，给我们带来这种不太理想的双重包装。幸运的是，我们有一个替代方案。
- en: '`flatMap(Function<? super T,Optional<U>> mapper)`: The `flatMap` function combines
    two functional ideas--maps and flatten. If the result of `Function` is an `Optional`
    object, rather than double wrapping the value, it is flattened to a single `Optional`
    object. Revisiting the preceding example, we get this:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap(Function<? super T,Optional<U>> mapper)`: `flatMap`函数结合了两个函数式思想--映射和扁平化。如果`Function`的结果是一个`Optional`对象，而不是将值进行双重包装，它会被扁平化为一个单一的`Optional`对象。重新审视前面的例子，我们得到这样的结果：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that `upper3`, unlike `upper2`, is a single `Optional`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`upper2`不同，`upper3`是一个单一的`Optional`：
- en: '`get()`: This returns the wrapped value, if present. If there is no value,
    a `NoSuchElementException` error is thrown.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 如果存在值，则返回包装的值。如果没有值，则抛出`NoSuchElementException`错误。'
- en: '`ifPresent(Consumer<? super T> action)`: If the `Optional` object contains
    a value, it is passed to the `Consumer`. If there is no value present, nothing
    happens.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresent(Consumer<? super T> action)`: 如果`Optional`对象包含一个值，则将其传递给`Consumer`。如果没有值存在，则什么也不会发生。'
- en: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: Like `ifPresent()`,
    this will pass the value to the `Consumer` if there is one present. If no value
    is present, the `Runnable emptyAction` is executed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: 像`ifPresent()`一样，如果有值存在，它会将值传递给`Consumer`。如果没有值存在，将执行`Runnable
    emptyAction`。'
- en: '`isPresent()`: This simply returns true if the `Optional` object contains a
    value.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPresent()`: 如果`Optional`对象包含一个值，则简单地返回true。'
- en: '`or(Supplier<Optional<T>> supplier)`: If the `Optional` object has a value,
    the `Optional` is described. If there is no value present, an `Optional` object
    produced by the `Supplier` is returned.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(Supplier<Optional<T>> supplier)`: 如果`Optional`对象有一个值，则描述该`Optional`。如果没有值存在，则返回`Supplier`生成的`Optional`对象。'
- en: '`orElse(T other)`: If the `Optional` object contains a value, it is returned.
    If there is no value, `other` is returned.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse(T other)`: 如果`Optional`对象包含一个值，则返回该值。如果没有值，则返回`other`。'
- en: '`orElseGet(Supplier<? extends T> supplier)`: This works just like `orElse()`
    mentioned earlier, but, if no value is present, the result of the `Supplier` is
    returned.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet(Supplier<? extends T> supplier)`: 这与前面提到的`orElse()`类似，但是如果没有值存在，则返回`Supplier`的结果。'
- en: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`: If there is a value
    present, it is returned. If there is no value, the `Exception` provided by the
    `Supplier` is thrown.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`: 如果存在值，则返回该值。如果没有值，则抛出`Supplier`提供的`Exception`。'
- en: '`Optional` also has several static methods that facilitate the creation of
    the `Optional` instances, some of which are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`还有一些静态方法，可以方便地创建`Optional`实例，其中一些如下：'
- en: '`empty()`: This returns an empty `Optional` object.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`: 这返回一个空的`Optional`对象。'
- en: '`of(T value)`: This returns an `Optional` object describing the non-null value.
    If the value is null, a `NullPointerException` is thrown.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of(T value)`: 这返回一个描述非空值的`Optional`对象。如果该值为null，则抛出`NullPointerException`。'
- en: '`ofNullable(T value)`: This returns an `Optional` object describing the value.
    If the value is null, an empty `Optional` is returned.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofNullable(T value)`: 这返回一个描述该值的`Optional`对象。如果该值为null，则返回一个空的`Optional`。'
- en: With that very brief introduction to `Optional<T>` under our belts, let's see
    how its presence affects our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个非常简短的介绍，我们可以看到`Optional<T>`的存在是如何影响我们的应用程序的。
- en: 'Returning our attention to the `initialize()` method, then, our first step
    is to get the list of processes to display. The streams API makes this extremely
    simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的第一步是获取要显示的进程列表。流API使这变得非常简单：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `allProcesses()` method returns `Stream<ProcessHandle>`, which allows us
    to apply the new stream operations to our problem. In this case, we just want
    to create a `List` of all of the `ProcessHandle` instances, so we call `collect()`,
    which is a stream operation that takes in a `Collector`. There are a number of
    options from which we could choose, but we want a `List`, so we use `Collectors.toList()`,
    which will collect each item in the stream and eventually return a `List` when
    the stream terminates. Note that the parameterized type of `List` will match that
    of `Stream`, which is `ProcessHandle` in this case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`allProcesses()`方法返回`Stream<ProcessHandle>`，这允许我们对问题应用新的流操作。在这种情况下，我们只想创建一个包含所有`ProcessHandle`实例的`List`，所以我们调用`collect()`，这是一个接受`Collector`的流操作。我们可以选择多种选项，但我们想要一个`List`，所以我们使用`Collectors.toList()`，它将收集流中的每个项目，并在流终止时最终返回一个`List`。注意，`List`的参数化类型将与`Stream`的参数化类型匹配，这种情况下是`ProcessHandle`。'
- en: 'This one line, then, gets us a `List<ProcessHandle>` of every process on the
    system that the current process can see, but that only gets us halfway. The `TableView`
    API doesn''t accept a `List<T>`. It only supports `ObservableList<T>`, but what
    is that? Its Javadoc defines it very simply--*A list that allows listeners to
    track changes when they occur*. To put it another way, when this list changes,
    `TableView` will be told about it automatically and will redraw itself. Once we
    associate `TableView` with this list, all we have to worry about is the data,
    and the control will handle the rest. Creating `ObservableList` is pretty straightforward:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码让我们得到了系统上每个进程的`List<ProcessHandle>`，当前进程可以看到，但这只让我们完成了一半。`TableView` API不接受`List<T>`。它只支持`ObservableList<T>`，但这是什么？它的Javadoc非常简单地定义了它--*一个允许监听器在发生更改时跟踪更改的列表*。换句话说，当这个列表发生变化时，`TableView`会自动得到通知并重新绘制自己。一旦我们将`TableView`与这个列表关联起来，我们只需要担心数据，控件会处理其余的事情。创建`ObservableList`非常简单：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, the `TableView` instance is injected by the runtime (included here
    for clarity), and we create the `ObservableList` via `FXCollections.observableArrayList()`.
    In `initialize()`, we set the `ObservableList` on the `TableView` via `setItems()`,
    then populate the `ObservableList` via `setAll()`. With that, our `TableView`
    has all the data it needs to render itself. Almost. It has the **data** to render,
    but **how** does it do it? Where does each field of `ProcessHandle.Info` go? To
    answer that, we have to define the columns on the table, and tell each column
    where to get its data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`TableView`实例是由运行时注入的（这里包括是为了清晰起见），我们通过`FXCollections.observableArrayList()`创建`ObservableList`。在`initialize()`中，我们通过`setItems()`在`TableView`上设置`ObservableList`，然后通过`setAll()`填充`ObservableList`。有了这个，我们的`TableView`就有了渲染自己所需的所有数据。几乎。它有**数据**来渲染，但**如何**渲染呢？`ProcessHandle.Info`的每个字段放在哪里？为了回答这个问题，我们必须在表上定义列，并告诉每一列从哪里获取它的数据。
- en: 'To do that, we need to create several `TableColumn<S,T>` instances. The `TableColumn`
    is responsible for displaying not only its column heading (as appropriate), but
    also the value of each cell. However, you have to tell it **how** to display the
    cell. That is done via a cell value factory. Under Java 7, that API would get
    us code like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要创建几个`TableColumn<S,T>`实例。`TableColumn`不仅负责显示其列标题（如果适用），还负责每个单元格的值。然而，你必须告诉它**如何**显示单元格。这是通过一个单元格值工厂来完成的。在Java
    7下，该API会让我们得到这样的代码：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I''ll go ahead and say it for you: that''s really ugly. Fortunately, we can
    put lambdas and type inference to work for us, to make that a lot more pleasant
    to read:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我会提前说出来：这真的很丑。幸运的是，我们可以利用lambda和类型推断来让它更加愉快地阅读：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s fourteen lines of code replaced by six. Much prettier. Now, we just
    have to do that five more times, once for each column. As improved as the preceding
    code may be, there''s still quite a bit of repeated code. Again, Java 8 functional
    interfaces can help us clean the code up a bit more. For each column, we want
    to specify the header, a width, and what to extract from `ProcessHandle.Info`.
    We can encapsulate that with this method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是六行代码取代了十四行。漂亮多了。现在，我们只需要再做五次，每次为一个列。尽管前面的代码可能已经改进了，但仍然有相当多的重复代码。同样，Java 8的函数接口可以帮助我们进一步清理代码。对于每一列，我们想要指定标题、宽度以及从`ProcessHandle.Info`中提取什么。我们可以用这个方法来封装：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Function<T,R>` interface is `FunctionalInterface`, which represents a
    function that takes in one type, `T`, and returns another, `R`. In our case, we''re
    defining this method as one that takes as parameters a `String`, an `int`, and
    a function that takes in `ProcessHandle` and returns a generic type. That may
    be hard to picture, but with this method defined, we can replace the preceding
    code and the others like it with calls to this method. The same preceding code
    can now be condensed to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T,R>`接口是`FunctionalInterface`，它表示一个接受一个类型`T`并返回另一个类型`R`的函数。在我们的情况下，我们正在定义这个方法，它以一个`String`、一个`int`和一个接受`ProcessHandle`并返回一个通用类型的函数作为参数。这可能很难想象，但有了这个方法的定义，我们可以用对这个方法的调用来替换前面的代码和类似的代码。同样的前面的代码现在可以被压缩为这样：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we just need to add these columns to the control, which we can do with
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这些列添加到控件中，可以用这个方法来实现：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that every method we're using on `ProcessHandle.Info` returns the `Optional<T>`
    we looked at in the preceding code. Since it does this, we have a very nice and
    clean API to get the information we want (or a reasonable default) without the
    specter of a `NullPointerException` in production.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`ProcessHandle.Info`上使用的每种方法都返回了我们在前面的代码中看到的`Optional<T>`。由于它这样做，我们有一个非常好的和干净的API来获取我们想要的信息（或者一个合理的默认值），而不会在生产中出现`NullPointerException`的问题。
- en: 'If we run the application now, we should get something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，应该会得到类似这样的东西：
- en: '![](img/e8871d7e-c081-46c2-b354-06434888cb74.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8871d7e-c081-46c2-b354-06434888cb74.png)'
- en: It's looking good so far, but it's not quite ready yet. We want to be able to
    start new processes as well as kill existing ones. Both of those will require
    menus, so we'll add those next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看起来不错，但还不够完善。我们希望能够启动新进程以及终止现有进程。这两者都需要菜单，所以我们接下来会添加这些。
- en: Adding menus
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单
- en: 'Menus in JavaFX start with a component called `MenuBar`. We want this menu
    to be at the top of the window, of course, so we add the component to the `top`
    section of our `BorderPane`. If you use Scene Builder, you will end up with something
    like this in your FXML file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX中的菜单从一个名为`MenuBar`的组件开始。当然，我们希望这个菜单位于窗口的顶部，因此我们将该组件添加到`BorderPane`的`top`部分。如果您使用Scene
    Builder，您的FXML文件中将会出现类似于以下内容：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We won''t be needing the edit menu, so we can remove that section from the
    FXML file (or by right-clicking on the second `Menu` entry in Scene Builder and
    clicking on Delete). To create the menu items we do want, we add the appropriate
    `MenuItem` entries to the `item` element under the `File` element:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编辑菜单，因此可以从FXML文件中删除该部分（或者通过右键单击Scene Builder中的第二个`Menu`条目，然后单击删除）。要创建我们想要的菜单项，我们将适当的`MenuItem`条目添加到`File`元素下的`item`元素中：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of these `MenuItem` entries has three attributes defined:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`MenuItem`条目都有三个属性定义：
- en: '`mnemonicParsing`: This instructs JavaFX to use any letter prefixed with an
    underscore as a keyboard shortcut'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnemonicParsing`：这指示JavaFX使用带有下划线前缀的任何字母作为键盘快捷键'
- en: '`onAction`: This identifies the method on the controller that will be called
    when `MenuItem` is activated/clicked'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAction`：这标识了在激活/单击`MenuItem`时将调用控制器上的方法'
- en: '`text`: This defines the label of `MenuItem`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这定义了`MenuItem`的标签'
- en: 'The most interesting part is `onAction` and its relationship with the controller.
    JavaFX, of course, already knows that this form is backed by `com.steeplesoft.procman.
    Controller`, so it will look for a method with the following signature:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是`onAction`及其与控制器的关系。当然，JavaFX已经知道这个表单由`com.steeplesoft.procman.Controller`支持，因此它将寻找具有以下签名的方法：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ActionEvent` is a class that is used in a number of scenarios by JavaFX. In
    our case, we have methods specifically for each menu item, so the event itself
    isn''t too terribly interesting. Let''s take a look at each handler, starting
    with the simplest--`closeApplication`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionEvent`是JavaFX在许多情况下使用的一个类。在我们的情况下，我们为每个菜单项专门有方法，因此事件本身并不是太有趣。让我们看看每个处理程序，从最简单的`closeApplication`开始：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's nothing much to see here; when the menu item is clicked, we exit the
    application by calling `Platform.exit()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么可看的；当单击菜单项时，我们通过调用`Platform.exit()`退出应用程序。
- en: 'Next up, let''s see how to kill a process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何终止一个进程：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have quite a bit going on here. The first thing we do is to create an `Alert`
    box of type `CONFIRMATION`, which asks the user to confirm the request. The dialog
    has two buttons: `YES` and `NO`. Once the dialog has been created, we call `showAndWait()`,
    which does as its name implies--it shows the dialog and waits for the user''s
    response. It returns `Optional<ButtonType>`, which holds the type of the button
    that the user clicked on, which will either be `ButtonType.YES` or `ButtonType.NO`,
    given the type of `Alert` box we''ve created. With `Optional`, we can apply `filter()`
    to find only the type of button that we''re interested in, which is `ButtonType.YES`,
    the result of which is another `Optional`. If the user clicked on yes, `ifPresent()`
    will return true (thanks to our filter), and the lambda we passed in will be executed.
    Very nice and concise.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有很多事情要做。我们首先要做的是创建一个`CONFIRMATION`类型的`Alert`对话框，询问用户确认请求。对话框有两个按钮：`YES`和`NO`。一旦对话框被创建，我们调用`showAndWait()`，它会显示对话框并等待用户的响应。它返回`Optional<ButtonType>`，其中包含用户点击的按钮的类型，可能是`ButtonType.YES`或`ButtonType.NO`，根据我们创建的`Alert`对话框的类型。有了`Optional`，我们可以应用`filter()`来找到我们感兴趣的按钮类型，即`ButtonType.YES`，其结果是另一个`Optional`。如果用户点击了yes，`ifPresent()`将返回true（感谢我们的过滤器），并且我们传递的lambda将被执行。非常好而简洁。
- en: The next area of interest is that lambda. Once we've identified **that** the
    user would like to kill a process, we need to identify **which** process to kill.
    To do that, we ask `TableView` which row is selected via `TableView.getSelectionModel()
    .getSelectedItem()`. We do need to check for null (alas, there's no `Optional`
    here) in the event that the user has not actually selected a row. If it is non-null,
    we can call `destroy()` on the `ProcessHandle` the `TableView` gives us. We then
    call `processListUpdater.updateList()` to refresh the UI. We'll take a look at
    that later.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来感兴趣的是lambda。一旦我们确定用户想要终止一个进程，我们需要确定**哪个**进程要终止。为此，我们通过`TableView.getSelectionModel().getSelectedItem()`询问`TableView`选择了哪一行。我们确实需要检查是否为null（遗憾的是，这里没有`Optional`），以防用户实际上没有选择行。如果它不是null，我们可以在`TableView`给我们的`ProcessHandle`上调用`destroy()`。然后我们调用`processListUpdater.updateList()`来刷新UI。稍后我们会看看这个。
- en: 'Our final action handler has to run the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终操作处理程序必须运行以下命令：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is, in many ways, similar to the preceding `killProcessHandler()` method--we
    create a dialog, set some options, call `showAndWait()`, then process `Optional`.
    Unfortunately, the dialog doesn't support the builder pattern, meaning we don't
    have a nice, fluid API to build the dialog, so we do it in several discrete steps.
    Processing `Optional` is also similar. We call `ifPresent()` to see if the dialog
    returned a command line (that is, the user entered some text **and** pressed OK),
    and pass that to the lambda if present.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这与前面的`killProcessHandler()`方法类似——我们创建一个对话框，设置一些选项，调用`showAndWait()`，然后处理`Optional`。不幸的是，对话框不支持构建器模式，这意味着我们没有一个很好的流畅API来构建对话框，所以我们要分几个离散的步骤来做。处理`Optional`也类似。我们调用`ifPresent()`来查看对话框是否返回了命令行（也就是用户输入了一些文本**并**按下了OK），并在存在的情况下将其传递给lambda。
- en: Let's take a quick look at the lambda. This is another example of a multiline
    lambda. Whereas most lambdas we've seen so far have been simple, one-line functions,
    remember that a lambda **can** span multiple lines. All that needs to be done
    to support that is to wrap the block in curly braces as we've done, and it's business
    as usual. Care must be taken with multiline lambdas like this, as any gains in
    readability and conciseness that lambdas give us can be quickly obscured or erased
    by a lambda body that grows too large. In those instances, extracting the code
    out to a method and using a method reference might be the wise thing to do. Ultimately,
    the decision is yours, but remember the words of Uncle Bob Martin--*Clarity is
    king*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下lambda。这是多行lambda的另一个示例。到目前为止，我们看到的大多数lambda都是简单的一行函数，但请记住，lambda**可以**跨越多行。要支持这一点，需要做的就是像我们所做的那样将块包装在花括号中，然后一切照旧。对于这样的多行lambda，必须小心，因为lambda给我们带来的可读性和简洁性的任何收益都可能很快被一个过大的lambda体所掩盖或抹去。在这些情况下，将代码提取到一个方法中并使用方法引用可能是明智的做法。最终，决定权在你手中，但请记住鲍勃·马丁叔叔的话--*清晰是王道*。
- en: 'One final item on the topic of menus. To be even more useful, the application
    should provide a context menu that will allow the user to right-click on a process
    and kill it from there, as opposed to clicking on the row, moving the mouse to
    the `File` menu, and more. Adding a context menu is a simple operation. All we
    need to do is modify our `TableView` definition in FXML like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于菜单的最后一项。为了更加实用，应用程序应该提供一个上下文菜单，允许用户右键单击一个进程并从那里结束它，而不是点击行，将鼠标移动到“文件”菜单等。添加上下文菜单是一个简单的操作。我们只需要修改我们在FXML中的`TableView`定义如下：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are adding a `contextMenu` child to our `TableView`. Much like its
    sibling, `MenuBar`, `contextMenu` has an `items` child, which, in turn, has 0
    or more `MenuItem` children. In this case, the `MenuItem` for `Kill Process...`
    looks remarkably like that under `File`, with the only difference being the `mnemonicProcessing`
    information. We're even reusing the `ActionEvent` handler, so there's no extra
    coding, and the behavior for killing a process is always the same, regardless
    of which menu item you click on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`TableView`中添加了一个`contextMenu`子项。就像它的兄弟`MenuBar`一样，`contextMenu`有一个`items`子项，它又有0个或多个`MenuItem`子项。在这种情况下，“Kill
    Process...”的`MenuItem`看起来与“File”下的那个非常相似，唯一的区别是`mnemonicProcessing`信息。我们甚至重用了`ActionEvent`处理程序，因此没有额外的编码，无论您点击哪个菜单项，结束进程的行为始终相同。
- en: Updating the process list
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新进程列表
- en: If the application started and showed a list of processes, but never updated
    that list, it wouldn't be very useful at all. What we then need is a way to update
    the list periodically, and for that, we'll use a `Thread`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序启动并显示了一个进程列表，但从未更新过该列表，那将毫无用处。我们需要的是定期更新列表的方法，为此，我们将使用一个`Thread`。
- en: As you may or may not know, a `Thread` is roughly a means to run a task in the
    background (the Javadoc describes it as a *thread of execution in a program*).
    A system can be single or multithreaded, depending on the needs and runtime environment
    of the system. And multithreaded programming is hard to get right. Luckily, our
    use case here is fairly simple, but we must still exercise caution, or we'll see
    some really unexpected behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道，也可能不知道，`Thread`大致是在后台运行任务的一种方式（Javadoc将其描述为程序中的*执行线程*）。系统可以是单线程或多线程的，这取决于系统的需求和运行时环境。多线程编程很难做到。幸运的是，我们这里的用例相当简单，但我们仍然必须小心，否则我们将看到一些非常意外的行为。
- en: 'Ordinarily, the advice you would get when creating a `Thread` is to implement
    a `Runnable` interface, which you will then pass to the thread''s constructor,
    and that''s very good advice, as it makes your class hierarchy much more flexible,
    since you''re not tied to a concrete base class (`Runnable` is an `interface`).
    In our case, however, we have a relatively simple system that has little to gain
    from that approach, so we''ll extend `Thread` directly and simplify our code a
    little as well as encapsulating our desired behavior. Let''s take a look at our
    new class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建`Thread`时，您会得到的建议是实现一个`Runnable`接口，然后将其传递给线程的构造函数，这是非常好的建议，因为它使您的类层次结构更加灵活，因为您不会受到具体基类的约束（`Runnable`是一个`interface`）。然而，在我们的情况下，我们有一个相对简单的系统，从这种方法中获益不多，所以我们将直接扩展`Thread`并简化我们的代码，同时封装我们想要的行为。让我们来看看我们的新类：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have a pretty basic class, which we've given a reasonable and meaningful
    name that extends `Thread`. In the constructor, note that we call `setDaemon(true)`.
    This will allow our application to exit as expected and not block, waiting for
    the thread to terminate. We've also defined a `shutdown()` method, which we'll
    use from our application to stop the thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个非常基本的类，我们给了它一个合理而有意义的名称，它扩展了`Thread`。在构造函数中，请注意我们调用了`setDaemon(true)`。这将允许我们的应用程序按预期退出，而不会阻塞，等待线程终止。我们还定义了一个`shutdown()`方法，我们将从我们的应用程序中使用它来停止线程。
- en: The `Thread` class does have various state control methods, such as `stop()`,
    `suspend()`, `resume()`, and more, but these have all been deprecated as they
    are considered inherently unsafe. Search for the article, Why are `Thread.stop`,
    `Thread.suspend`, and `Thread.resume` deprecated? If you would like more details;
    however, the suggested best practice now is to use a control flag, like we've
    done with `running`, to signal to the `Thread` class that it needs to clean up
    and shut down.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类确实有各种状态控制方法，如`stop()`、`suspend()`、`resume()`等，但这些方法都已被弃用，因为它们被认为是不安全的。搜索文章，为什么`Thread.stop`、`Thread.suspend`和`Thread.resume`被弃用？如果您想要更多细节；然而，现在建议的最佳做法是使用一个控制标志，就像我们用`running`做的那样，向`Thread`类发出信号，表明它需要清理并关闭。'
- en: 'Finally, we have the heart of our `Thread` class, `run()`, which loops infinitely
    (or until `running` becomes false), sleeping for five seconds after performing
    its work. The actual work is done in `updateList()`, which builds the list of
    processes, updates `ObservableList` we discussed earlier, and then instructs `TableView`
    to re-sort itself, based on the user''s sort selection, if any. This is a public
    method, allowing us to call this at need, as we did in `killProcessHandler()`.
    That leaves us with the following block of code to set it up:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的`Thread`类的核心，`run()`，它会无限循环（或直到`running`变为false），在执行完工作后休眠五秒。实际工作是在`updateList()`中完成的，它构建了进程列表，更新了我们之前讨论过的`ObservableList`，然后指示`TableView`根据用户的排序选择重新排序自己，如果有的话。这是一个公共方法，允许我们在需要时调用它，就像我们在`killProcessHandler()`中所做的那样。这留下了以下的代码块来设置它：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code will shut it down, which we''ve already seen in `closeHandler()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将关闭它，我们已经在`closeHandler()`中看到了：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The eagle-eyed will notice that `updateList()` has the `synchronized` keyword
    on it. This is to prevent any sort of race condition that might be caused by calling
    this method from multiple threads. Imagine the scenario where the user decides
    to kill a process and clicks on OK on the confirmation dialog at the exact moment
    the thread wakes up (this type of thing happens more often than you might think).
    We could conceivably have two threads calling `updateList()` at the same time,
    resulting in the first thread hitting `processView.sort()` just as the second
    is hitting `processList.setAll()`. What happens when `sort()` is called while
    another thread is rebuilding the list? It's hard to say for sure, but it could
    be catastrophic, so we want to disallow that. The `synchronized` keyword instructs
    the JVM to allow only one thread to execute the method at a time, causing all
    others to queue up, waiting their turn (note that their execution order is non-deterministic,
    so you can't base any expectations on the order in which threads get to run a
    `synchronized` method). This avoids the potential for a race condition, and ensures
    that our program doesn't crash.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的人会注意到`updateList()`上有`synchronized`关键字。这是为了防止由于从多个线程调用此方法而可能引起的任何竞争条件。想象一下，用户决定终止一个进程并在线程在恢复时点击确认对话框的确切时刻（这种情况比你想象的要常见）。我们可能会有两个线程同时调用`updateList()`，导致第一个线程在第二个线程调用`processList.setAll()`时刚好调用`processView.sort()`。当在另一个线程重建列表时调用`sort()`会发生什么？很难说，但可能是灾难性的，所以我们要禁止这种情况。`synchronized`关键字指示JVM一次只允许一个线程执行该方法，导致其他线程排队等待（请注意，它们的执行顺序是不确定的，所以你不能根据线程运行`synchronized`方法的顺序来做任何期望）。这避免了竞争条件的可能性，并确保我们的程序不会崩溃。
- en: While appropriate here, care must be taken with `synchronized` methods, as acquiring
    and releasing the locks can be expensive (though much less so with modern JVMs)
    and, more importantly, it forces threads to run sequentially when they hit this
    method call, which can cause a very undesirable lag in the application, especially
    in GUI applications. Keep that in mind when writing your own multithreaded applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里是合适的，但在使用`synchronized`方法时必须小心，因为获取和释放锁可能是昂贵的（尽管在现代JVM中要少得多），更重要的是，它强制线程在调用这个方法时按顺序运行，这可能会导致应用程序出现非常不希望的延迟，特别是在GUI应用程序中。在编写自己的多线程应用程序时要记住这一点。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that in place, our application is complete. While not a terribly complex
    application, it does include several interesting technologies such as JavaFX,
    Lambdas, Streams, `ProcessHandle` plus related classes, and Threads.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的应用程序就完成了。虽然不是一个非常复杂的应用程序，但它包括了一些有趣的技术，比如JavaFX、Lambda、Streams、`ProcessHandle`以及相关的类和线程。
- en: In the next chapter, we'll build a simple command-line utility to find duplicate
    files. Through that, we'll get hands-on experience with the new File I/O APIs,
    the Java Persistence API (JPA), file hashing, and some more JavaFX.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个简单的命令行实用程序来查找重复文件。通过这样做，我们将亲身体验新的文件I/O API、Java持久化API（JPA）、文件哈希和一些更多的JavaFX。
