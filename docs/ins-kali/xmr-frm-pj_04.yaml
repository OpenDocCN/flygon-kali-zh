- en: Building a Location Tracking App Using GPS and Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPS和地图构建位置跟踪应用程序
- en: In this chapter, we will create a location tracking app that saves the location
    of the user and display it as a heat map. We will look at how to run tasks in
    the background on iOS and Android devices and how to use custom renderers to extend
    the functionality of Xamarin.Forms maps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个位置跟踪应用程序，将用户的位置保存并显示为热力图。我们将看看如何在iOS和Android设备上后台运行任务，以及如何使用自定义渲染器来扩展Xamarin.Forms地图的功能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Tracking the location of a user in the background on an iOS device
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS设备上后台跟踪用户位置
- en: Tracking the location of a user in the background on an Android device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android设备上后台跟踪用户位置
- en: How to show maps in a Xamarin.Forms app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Xamarin.Forms应用程序中显示地图
- en: How to extend the functionality of Xamarin.Forms maps with custom renderers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义渲染器扩展Xamarin.Forms地图的功能
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete the project, you need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*, for more details on how to set up your environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成项目，您需要安装Visual Studio for Mac或PC，以及Xamarin组件。有关如何设置您的环境的更多详细信息，请参阅[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)，“Xamarin简介”。
- en: Project overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Many apps could be made richer by adding a map and location services. In this
    project, we will build a location tracking app that we will call **MeTracker**.
    The app will track the position of the user and save it to an SQLite database
    so we can visualize the result in the form of a heat map. To build this app, we
    will learn how to set up processes in the background, on both iOS and Android, because
    we cannot share code between iOS and Android. For the map, we will use the `Xamarin.Forms.Maps`
    component and extend its functionality in order to build a heat map. To do this,
    we will use a custom renderer for iOS and a custom renderer for Android so that
    we can use the platform APIs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序可以通过添加地图和位置服务而变得更加丰富。在这个项目中，我们将构建一个名为**MeTracker**的位置跟踪应用程序。该应用程序将跟踪用户的位置并将其保存到SQLite数据库中，以便我们可以将结果可视化为热力图。为了构建这个应用程序，我们将学习如何在iOS和Android上设置后台进程，因为我们无法在iOS和Android之间共享代码。对于地图，我们将使用`Xamarin.Forms.Maps`组件并扩展其功能以构建热力图。为此，我们将使用iOS的自定义渲染器和Android的自定义渲染器，以便我们可以使用平台API。
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: We can use either Visual Studio 2017 on a PC or Visual Studio for Mac to do
    this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have access to a Mac at all, you can just do the
    Android part of this project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PC上的Visual Studio 2017或Mac上的Visual Studio来完成此项目。要使用Visual Studio在PC上构建iOS应用程序，您必须连接Mac。如果您根本没有访问Mac，您可以只完成此项目的Android部分。
- en: Building the MeTracker app
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建MeTracker应用程序
- en: It's time to start building the app. Create a **Mobile App (Xamarin.Forms)**.
    We will find that template under the **Cross-Platform** ta in the New Project
    dialog. We will name the project `MeTracker`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始构建应用程序了。创建一个**移动应用程序（Xamarin.Forms）**。我们将在新项目对话框的**跨平台**选项卡下找到该模板。我们将项目命名为“MeTracker”。
- en: '![](img/1f1e8d6f-a293-4877-b4b6-c3ab000085f6.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f1e8d6f-a293-4877-b4b6-c3ab000085f6.png)'
- en: Use .NET Standard as the code sharing strategy and select iOS and Android as
    the platforms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Standard作为代码共享策略，并选择iOS和Android作为平台。
- en: '![](img/aec81384-04d7-4520-a668-6571e93d02ce.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aec81384-04d7-4520-a668-6571e93d02ce.png)'
- en: Make sure that you are compiling using Android version Oreo (API level 26) or
    higher. We can set this in the project Properties under the Applicationtab.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用Android版本Oreo（API级别26）或更高版本进行编译。我们可以在项目属性的“应用程序”选项卡下设置这一点。
- en: Update the NuGet packages that was added by the template to make sure that we
    use the latest versions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板添加的NuGet包，以确保我们使用最新版本。
- en: Creating a repository to save the location of the users
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储用户位置的存储库
- en: The first thing we will do is create a repository that we can use to save the
    location of the users.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个存储库，我们可以用来保存用户的位置。
- en: Creating a model for the location data
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为位置数据创建模型
- en: 'Before we create the repository, we will create a model class that will represent
    a user location by going through the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建存储库之前，我们将通过以下步骤创建一个代表用户位置的模型类：
- en: Create a new folder that we can use for this and other models, called `Models`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，我们可以用于此和其他模型，名为“Models”。
- en: Create a class with the name `Location` in the `Models` folder and add properties
    for the `Id`, the `Latitude`, and the `Longitude`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Models”文件夹中创建一个名为“Location”的类，并为“Id”、“Latitude”和“Longitude”添加属性。
- en: 'Create two constructors, one empty and one that takes the `latitude` and `longitude`
    as arguments, using the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个构造函数，一个为空的构造函数，另一个以`latitude`和`longitude`作为参数的构造函数，使用以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the repository
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储库
- en: 'Now that we have created a model, we can move on to creating the repository.
    First, we will create an interface for the repository by going through the following
    steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模型，我们可以继续创建存储库。首先，我们将通过以下步骤为存储库创建一个接口：
- en: In the `MeTracker` project, create a new folder, called `Repositories`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“MeTracker”项目中，创建一个名为“Repositories”的新文件夹。
- en: In our new folder, we will create an interface that we will call `ILocationRepository`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新文件夹中，我们将创建一个名为“ILocationRepository”的接口。
- en: 'Write the following code in the new file that we created for the `interface`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们为`interface`创建的新文件中编写以下代码：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add a `using` directive for `MeTracker.Models` and `System.Threading.Tasks` to
    resolve the references for `Location` and `Task`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`MeTracker.Models`和`System.Threading.Tasks`添加`using`指令，以解析`Location`和`Task`的引用。
- en: 'Once we have an `interface`, we need to create an implementation of it by going
    through the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个`interface`，我们需要通过以下步骤创建其实现：
- en: In the `MeTracker` project, create a new class with the name `LocationRepository`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，创建一个名为`LocationRepository`的新类。
- en: 'Implement the `ILocationRepository` interface and add the `async` keyword to
    the `Save`method using the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ILocationRepository`接口，并在`Save`方法中添加`async`关键字，使用以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To store the data, we will use an SQLite database and the **object relational
    mapper** (**ORM**), SQLite-net, so that we can write code against a domain model
    instead of using SQL for operations against the database. This is an open source
    library created by Frank A. Krueger. Let''s set this up by going through the following
    steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储数据，我们将使用SQLite数据库和对象关系映射器（ORM）SQLite-net，以便我们可以针对领域模型编写代码，而不是使用SQL对数据库进行操作。这是由Frank
    A. Krueger创建的开源库。让我们通过以下步骤来设置这个：
- en: Install the NuGet package, `sqlite-net-pcl`, for the `MeTracker` project.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中安装NuGet包`sqlite-net-pcl`。
- en: Go to the `Location` model class and add a `PrimaryKeyAttribute` and an `AutoIncrementAttribute`
    to the `Id` property. When we add the attributes, the `Id` property will be a
    primary key in the database, and a value for it will automatically be created.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Location`模型类，并为`Id`属性添加`PrimaryKeyAttribute`和`AutoIncrementAttribute`。当我们添加这些属性时，`Id`属性将成为数据库中的主键，并将自动创建一个值。
- en: 'Write the following code in the` LocationRepository` class to create a connection
    to the SQLite database. The `if` statement is to check whether we have already
    created a connection. If this is the case, we will not create a new one; we will
    instead use the connection that we already created:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LocationRepository`类中编写以下代码，以创建与SQLite数据库的连接。`if`语句用于检查我们是否已经创建了连接。如果是这样，我们将不会创建新的连接；相反，我们将使用已经创建的连接：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, it's time to implement the `Save` method, which will take a location object
    as a parameter and store it in the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现`Save`方法了，该方法将以位置对象作为参数，并将其存储在数据库中。
- en: We will now use the `CreateConnection`method in the `Save` method so we can
    be sure that a connection is created when we try to save data to the database.
    When we know that we have an active connection, we can just use the `InsertAsync`
    method and pass the `location` parameter of the `Save` method as an argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`Save`方法中使用`CreateConnection`方法，以确保在尝试将数据保存到数据库时创建连接。当我们知道有一个活动连接时，我们可以使用`InsertAsync`方法，并将`Save`方法的`location`参数作为参数传递。
- en: 'Edit the `Save` method in the `LocationRepository` class to look like the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`LocationRepository`类中的`Save`方法，使其看起来像以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Xamarin.Essentials
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Essentials
- en: '**Xamarin.Essentials** is a library that was created by Microsoft and Xamarin
    to make it possible for developers to use platform-specific APIs from shared code. Xamarin.Essentials targets Xamarin.iOS, Xamarin.Android, and UWP.
    In this project, we will use Xamarin.Essentials for various tasks, including getting
    a location and executing code on the main thread.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xamarin.Essentials**是由Microsoft和Xamarin创建的库，使开发人员能够从共享代码中使用特定于平台的API。Xamarin.Essentials目标是Xamarin.iOS、Xamarin.Android和UWP。在这个项目中，我们将使用Xamarin.Essentials来执行各种任务，包括获取位置和在主线程上执行代码。'
- en: Installing the NuGet package
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装NuGet包
- en: At the time of writing, Xamarin.Essentials is in preview. To find the NuGet
    packages in preview, we will have to check the Include Prerelease checkbox.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Xamarin.Essentials处于预览状态。要找到预览中的NuGet包，我们需要勾选包括预览版本的复选框。
- en: Configuring Xamarin.Essentials on Android
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上配置Xamarin.Essentials
- en: 'We need to initialize Xamarin.Essentials on Android by calling an initialization
    method. We do this by going through the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过调用初始化方法在Android上初始化Xamarin.Essentials。我们通过以下步骤来实现这一点：
- en: In the Android project, open the `MainActivity.cs` file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，打开`MainActivity.cs`文件。
- en: 'Add the code in bold under the `global::Xamarin.Forms.Forms.Init` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`global::Xamarin.Forms.Forms.Init`方法下添加粗体代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it. We are all good to go.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经准备就绪。
- en: Creating a service for location tracking
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为位置跟踪创建一个服务
- en: To track a user's location, we need to write the code according to the platform.
    Xamarin.Essentials has methods for getting the location of a user in shared code,
    but it cannot be used in the background. To be able to use the code that we will
    write for each platform, we need to create an interface. For the `ILocationRepository`
    interface, there will be just one implementation that will be used on both platforms,
    whereas for the location tracking service, we will have one implementation for
    the iOS platform and one for the Android platform.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪用户的位置，我们需要根据平台编写代码。Xamarin.Essentials具有用于在共享代码中获取用户位置的方法，但不能在后台使用。为了能够使用我们将为每个平台编写的代码，我们需要创建一个接口。对于`ILocationRepository`接口，将只有一个在两个平台上使用的实现，而对于位置跟踪服务，我们将在iOS平台和Android平台分别有一个实现。
- en: 'Go through the following steps to create the `ILocationRepository` interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤创建`ILocationRepository`接口：
- en: In the `MeTracker` project, create a new folder and name it `Services`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，创建一个新的文件夹，并命名为`Services`。
- en: Create a new interface in the `Services` folder with the name `ILocationTrackingService`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中创建一个名为`ILocationTrackingService`的新接口。
- en: 'In the interface, add a method called `StartTracking` as shown in the following
    code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口中，添加一个名为`StartTracking`的方法，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the moment, we will just create an empty implementation of the interface
    in both the iOS and the Android projects by going through the following steps.
    We will come back to each implementation later in this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将在iOS和Android项目中只创建一个空的接口实现，稍后在本章中我们将回到每个实现：
- en: Create a folder named `Services `in both the iOS and Android projects.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS和Android项目中创建一个名为`Services`的文件夹。
- en: 'Create an empty implementation as shown in the following code, in a class called `LocationTrackingService`
    in the new `Service` folder in both the iOS and Android projects:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS和Android项目的新`Service`文件夹中，按照以下代码中所示创建一个名为`LocationTrackingService`的类的空实现：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting up the app logic
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用逻辑
- en: We have now created the interfaces we need to track the location of the user
    and save it locally on the device. It's time to write code to start the tracking
    of a user. We still don't have any code that actually tracks the location of the
    user, but it will be easier to write this if we have already written the code
    that starts the tracking.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了我们需要跟踪用户位置并在设备上保存位置的接口。现在是时候编写代码来开始跟踪用户了。我们仍然没有任何实际跟踪用户位置的代码，但如果我们已经编写了开始跟踪的代码，那么编写这部分代码将会更容易。
- en: Creating a view with a map
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有地图的视图
- en: 'To start with, we will create a view with a simple map that is centered on
    the position of the user. Let''s set this up by going through the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个带有简单地图的视图，该地图以用户位置为中心。让我们通过以下步骤来设置这一点：
- en: In the `MeTracker` project, create a new folder called `Views`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，创建一个名为`Views`的新文件夹。
- en: In the `Views` folder, create a XAML-based `ContentPage` and name it `MainView`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Views`文件夹中，创建一个基于XAML的`ContentPage`，并将其命名为`MainView`。
- en: '![](img/5888007b-7310-4c28-813f-7e9458ad3da0.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5888007b-7310-4c28-813f-7e9458ad3da0.png)'
- en: 'The Xamarin.Forms package has no map controls, but there is an official package
    from Microsoft and Xamarin that can be used to show maps in a Xamarin.Forms app.
    This package is called `Xamarin.Forms.Maps`, and we can install it from NuGet
    by following the steps below:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms包中没有地图控件，但是微软和Xamarin提供了一个官方包，可以在Xamarin.Forms应用中显示地图。这个包叫做`Xamarin.Forms.Maps`，我们可以通过以下步骤从NuGet安装它：
- en: Install `Xamarin.Forms.Maps` in the `MeTracker`, `MeTracker.Android`, and `MeTracker.iOS`
    projects.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`，`MeTracker.Android`和`MeTracker.iOS`项目中安装`Xamarin.Forms.Maps`。
- en: 'Add the namespace for `Xamarin.Forms.Maps` to the `MainView` using the following
    code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为`MainView`添加`Xamarin.Forms.Maps`的命名空间：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now use the map in our view. Because we want the `Map` to cover the
    whole page, we can add it to the root of the `ContentPage`. Let''s set this up
    by going through the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的视图中使用地图了。因为我们希望`Map`覆盖整个页面，所以我们可以将它添加到`ContentPage`的根部。让我们通过以下步骤来设置这一点：
- en: Add the `map` to the `ContentPage`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`map`添加到`ContentPage`。
- en: 'Give the map a name so we can access it from the code-behind. Name it `Map`,
    as shown in the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给地图命名，以便我们可以从代码后台访问它。将其命名为`Map`，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use the `map` control, we need to run code on each platform to initialize
    it by going through the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`map`控件，我们需要在每个平台上运行代码来初始化它，通过以下步骤：
- en: In the iOS project, go to `AppDelegate.cs`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS项目中，转到`AppDelegate.cs`。
- en: 'In the `FinishedLaunching` method, after the `Init` of `Xamarin.Forms`, add
    `global::Xamarin.FormsMaps.Init()` to initialize the `map` control for the iOS
    app using the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FinishedLaunching`方法中，在`Xamarin.Forms`的`Init`之后，添加`global::Xamarin.FormsMaps.Init()`来初始化iOS应用中的`map`控件，使用以下代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Continue with to initialize it for Android:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 继续为Android初始化：
- en: In the Android project, go to `MainActivity.cs`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，转到`MainActivity.cs`。
- en: In the `OnCreate` method, after the `Init` of `Xamarin.Forms`, add `global::Xamarin.FormsMaps.Init(this, savedInstanceState)`to
    initialize the `map` control for iOS.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCreate`方法中，在`Xamarin.Forms`的`Init`之后，添加`global::Xamarin.FormsMaps.Init(this,
    savedInstanceState)`来初始化iOS上的`map`控件。
- en: 'Initialize Xamarin.Essentials by using   `Xamarin.Essentials.Platform.Init(this, savedInstanceState)` as
    shown in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下代码初始化Xamarin.Essentials：`Xamarin.Essentials.Platform.Init(this, savedInstanceState)`。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For Android, we also need to decide what happens when a user has answered a
    request for permission dialog and send the result to Xamarin.Essentials. We will
    do that by adding the following code to `MainActivity.cs`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们还需要决定用户回答权限对话框后发生什么，并将结果发送给Xamarin.Essentials。我们将通过将以下代码添加到`MainActivity.cs`来实现这一点：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For Android, we will need an **API key** for Google Maps in order to get the
    maps to work. The Microsoft documentation about how to obtain an API key can be
    found at [https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key](https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key).
    Here''s how we go about obtaining the API key:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们需要一个**API密钥**来获取Google Maps的地图。有关如何获取API密钥的Microsoft文档可以在[https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key](https://docs.microsoft.com/en-us/xamarin/android/platform/maps-and-location/maps/obtaining-a-google-maps-api-key)找到。以下是获取API密钥的步骤：
- en: Open `AndroidMainfest.xml`, which is located in the `Properties` folder in the
    Android project.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidMainfest.xml`，它位于Android项目的`Properties`文件夹中。
- en: 'Insert a metadata element as a child of the application element, as shown in
    the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将元数据元素插入到应用程序元素中，如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also want the map to be centered on the position of the user. We will do
    this in the constructor of the `MainView.xaml.cs`. Because we want to run the
    fetching of the user''s location asynchronously and it needs to be executed on
    the main thread, we will wrap it in `MainThread.BeginInvokeOnMainThread`. To get
    the current location of the user, we will use Xamarin.Essentials. When we have
    the location, we can use the `MoveToRegion` method of the `Map`.  We can set this
    up by going through the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望地图以用户的位置为中心。我们将在`MainView.xaml.cs`的构造函数中实现这一点。因为我们希望异步运行获取用户位置的操作，并且它需要在主线程上执行，所以我们将使用`MainThread.BeginInvokeOnMainThread`来包装它。我们将使用Xamarin.Essentials来获取用户的当前位置。当我们有了位置信息后，我们可以使用`Map`的`MoveToRegion`方法。我们可以通过以下步骤来设置这一点：
- en: In the `MeTracker` project, open `MainView.xaml.cs`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，打开`MainView.xaml.cs`。
- en: 'Add the code in bold in the following code fragment to the constructor of the
    `MainView.xaml.cs` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粗体字中的代码添加到`MainView.xaml.cs`类的构造函数中：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a ViewModel
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个ViewModel
- en: 'Before we create an actual view model, we will create an abstract base view
    model that all view models can inherit from. The idea behind this base view model
    is that we can write common code in it. In this case, we will implement the `INotifyPropertyChanged`
    interface by going through the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实际的视图模型之前，我们将创建一个所有视图模型都可以继承的抽象基础视图模型。这个基础视图模型的想法是我们可以在其中编写通用代码。在这种情况下，我们将通过以下步骤实现`INotifyPropertyChanged`接口：
- en: Create a folder with the name `ViewModels` in the `MeTracker` project.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中创建一个名为`ViewModels`的文件夹。
- en: 'Write the following code and resolve all references:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码并解析所有引用：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next step is to create the actual view model that will use `ViewModel`
    as a base class. Let''s set this up by going through the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建实际的视图模型，它将使用`ViewModel`作为基类。通过以下步骤来设置：
- en: In the `MeTracker` project, create a new class called `MainViewModel` in the
    `ViewModels` folder.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，在`ViewModels`文件夹中创建一个名为`MainViewModel`的新类。
- en: Make the `MainViewModel` inherit the `ViewModel`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`MainViewModel`继承`ViewModel`。
- en: Add a read-only field of the `ILocationTrackingService` type and name it `locationTrackingService`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ILocationTrackingService`类型的只读字段，并命名为`locationTrackingService`。
- en: Add a read-only field of the `ILocationRepository` type and name it `locationRepository`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ILocationRepository`类型的只读字段，并命名为`locationRepository`。
- en: Create a constructor with the `ILocationTrackingService` and the `ILocationRepository`
    as parameters.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数，参数为`ILocationTrackingService`和`ILocationRepository`。
- en: 'Set the values of the fields that we created in *step* *3* and *step* *4* with
    the values from the parameters, as shown in the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数的值设置我们在*步骤*3和*步骤*4中创建的字段的值，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to make the iOS app start tracking the location of a user, we need
    to run the code that starts the tracking on the main thread by going through the
    following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使iOS应用程序开始跟踪用户的位置，我们需要通过以下步骤在主线程上运行启动跟踪的代码：
- en: In the constructor of the newly created `MainViewModel`, add an invocation to
    the main thread using `MainThread.BeginInvokeOnMainThread` from Xamarin.Essentials.
    Xamarin.Forms has a helper method for invoking code on the main thread, but if
    we use the one from Xamarin.Essentials, we can have a view model without any dependencies on
    Xamarin.Forms. If we do not have any dependencies to Xamarin.Forms in the ViewModels
    we can reuse them in apps where we not using Xamarin.Forms if we will add other
    platforms in the future.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的`MainViewModel`的构造函数中，使用Xamarin.Essentials的`MainThread.BeginInvokeOnMainThread`调用主线程。Xamarin.Forms有一个用于在主线程上调用代码的辅助方法，但如果我们使用Xamarin.Essentials的方法，我们可以在ViewModel中没有任何对Xamarin.Forms的依赖。如果在ViewModels中没有任何对Xamarin.Forms的依赖，我们可以在将来添加其他平台的应用程序中重用它们。
- en: 'Call `locationService.StartTracking` in the action that we pass to the `BeginInvokeOnMainThread`
    method, shown in the following code marked in bold:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传递给`BeginInvokeOnMainThread`方法的操作中调用`locationService.StartTracking`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we need to inject a `MainViewModel` into the constructor of the `MainView`
    and assign the `MainViewModel` instance to the binding context of the view by
    going through the following steps. This will allow the data binding to be processed,
    and the properties of `MainViewModel` will be bound to the controls in the user
    interface:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`MainViewModel`注入到`MainView`的构造函数中，并将`MainViewModel`实例分配给视图的绑定上下文，通过以下步骤进行。这将允许数据绑定被处理，并且`MainViewModel`的属性将绑定到用户界面中的控件：
- en: In the `MeTracker` project, go to the constructor of the `Views/MainView.xaml.cs`
    file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，转到`Views/MainView.xaml.cs`文件的构造函数。
- en: Add `MainViewModel` as a parameter of the constructor and call it `viewModel`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainViewModel`作为构造函数的参数，并将其命名为`viewModel`。
- en: 'Set `BindingContext`to the instance of the `MainViewModel`, as shown in the
    following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BindingContext`设置为`MainViewModel`的实例，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a resolver
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个解析器
- en: 'We will be using dependency injection in this project, for which we will use
    a library called Autofac.Autofac is an open source **inversion of control** (**IoC**)
    container. We will create a `Resolver` class in order to easily resolve types
    that we will add to the container later in this chapter. To do so, we will go
    through the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用依赖注入，我们将使用一个名为Autofac的库。Autofac是一个开源的**控制反转**（**IoC**）容器。我们将创建一个`Resolver`类，以便在本章后面将要添加到容器中的类型可以轻松地解析。为此，我们将通过以下步骤进行：
- en: Install Autofac from NuGet in the `MeTracker`, `MeTracker.Android`, and `MeTracker.iOS `projects.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`，`MeTracker.Android`和`MeTracker.iOS`项目中从NuGet安装Autofac。
- en: In the `MeTracker` project, create a new class called `Resolver` in the root
    of the project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，在项目的根目录创建一个名为`Resolver`的新类。
- en: Create a `private static IContainer` field called `container`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`container`的`private static IContainer`字段。
- en: 'Create a `static` method called `Initialized` that has an `IContainer` argument
    and set the value of the `container` field as shown in the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Initialized`的`static`方法，它具有一个`IContainer`参数，并设置`container`字段的值，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Initialize` method will be called after the configuration of Autofac is
    complete, which we will do when we create the bootstrapper. This method simply
    takes the `container` that it gets as an argument and stores it in the `static`
    container field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize`方法将在Autofac配置完成后调用，我们将在创建引导程序时进行配置。这个方法简单地获取作为参数的`container`并将其存储在`static`容器字段中。'
- en: 'Now, we need a method to access it from. Create one more `static` method, called
    `Resolve`. This method will be generic, and when we use it, we will specify its
    type as the type that will be resolved. Use the `container` field to resolve the
    type as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个方法来访问它。创建一个名为`Resolve`的静态方法。这个方法将是通用的，当我们使用它时，我们将指定它的类型作为将要解析的类型。使用`container`字段来解析类型，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Resolve<T>` method takes a type as an argument and looks in the container
    to see whether there is any information on how to construct this type. If there
    is, then we return it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve<T>`方法接受一个类型作为参数，并在容器中查找有关如何构造此类型的任何信息。如果有，我们就返回它。'
- en: So, now that we have the `Resolver` that we will use to resolve instances of
    types of objects, we need to configure it. That's the job of the bootstrapper.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有了我们将用来解析对象类型实例的`Resolver`，我们需要对其进行配置。这是引导程序的工作。
- en: Creating the bootstrapper
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建引导程序
- en: 'To configure the dependency injection and initialize the `Resolver`, we will
    create a bootstrapper. We will have one shared bootstrapper, as well as other
    bootstrappers for each platform to meet their specific configurations. The reason
    that we need them to be platform-specific is that we will have different implementations
    of the `ILocationTrackingService` on iOS and Android. To create a bootstrapper,
    we go through the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置依赖注入并初始化`Resolver`，我们将创建一个引导程序。我们将有一个共享的引导程序，以及其他针对每个平台的引导程序，以满足其特定的配置。我们需要它们是特定于平台的原因是，我们将在iOS和Android上有不同的`ILocationTrackingService`实现。要创建引导程序，我们需要按照以下步骤进行：
- en: Create a new class in the `MeTracker` project and name it `Bootstrapper`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中创建一个新类，并命名为`Bootstrapper`。
- en: 'Write the following code in the new class:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类中编写以下代码：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating the iOS bootstrapper
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建iOS引导程序
- en: 'In the iOS bootstrapper, we will have configurations that are specific to the
    iOS app. To create an iOS app, we go through the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS引导程序中，我们将有特定于iOS应用程序的配置。要创建iOS应用程序，我们需要按照以下步骤进行：
- en: In the iOS project, create a new class and name it `Bootstrapper`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS项目中，创建一个新类，并命名为`Bootstrapper`。
- en: Make the new class inherit from `MeTracker.Bootstrapper`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使新类继承自`MeTracker.Bootstrapper`。
- en: 'Write the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Go to `AppDelegate.cs` in the iOS project.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到iOS项目中的`AppDelegate.cs`。
- en: 'Before the call to `LoadApplication`, in the `FinishedLaunching` method, call
    the `Init` method of the platform-specific bootstrapper, as shown in the following
    code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FinishedLaunching`方法中的`LoadApplication`调用之前，调用平台特定引导程序的`Init`方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating the Android bootstrapper
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android引导程序
- en: 'In the Android bootstrapper, we will have configurations that are specific
    to the Android app. To create the bootstrapper in Android, we go through the following
    steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android引导程序中，我们将有特定于Android应用程序的配置。要在Android中创建引导程序，我们需要按照以下步骤进行：
- en: In the Android project, create a new class and name it `Bootstrapper`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，创建一个新类，并命名为`Bootstrapper`。
- en: Make the new class inherit from `MeTracker.Bootstrapper`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使新类继承自`MeTracker.Bootstrapper`。
- en: 'Write the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Go to the `MainActivity.cs` file in the Android project.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Android项目中的`MainActivity.cs`文件。
- en: 'Before the call to `LoadApplication`, in the `OnCreate` method, call the `Init` method
    of the platform-specific bootstrapper, as shown in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCreate`方法中的`LoadApplication`调用之前，调用平台特定引导程序的`Init`方法，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Setting the MainPage
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MainPage
- en: 'The last step before we can start the app for the first time is to set the
    `MainPage` property in the `App.xaml.cs` file by going through the following steps.
    But first, we can delete the `MainPage.xaml` file and the `MainPage.xaml.cs` file
    that we created when we started the project because we are not using them here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们首次启动应用程序之前的最后一步是通过以下步骤在`App.xaml.cs`文件中设置`MainPage`属性。但首先，我们可以删除我们启动项目时创建的`MainPage.xaml`文件和`MainPage.xaml.cs`文件，因为我们这里不使用它们：
- en: Delete the `MainPage.xaml` and the `MainPage.xaml.cs` in the `MeTracker` project,
    since we will be setting our `MainView` as the first view that the user sees.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`MeTracker`项目中的`MainPage.xaml`和`MainPage.xaml.cs`，因为我们将把`MainView`设置为用户首次看到的第一个视图。
- en: Use the `Resolver` to create an instance of the `MainView`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Resolver`来创建`MainView`的实例。
- en: 'Set the `MainPage` in the constructor to the instance of the `MainView`, as
    shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中将`MainPage`设置为`MainView`的实例，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The resolver uses Autofac to figure out all the dependencies we need in order
    to create a `MainView` instance. It looks at the constructor of the `MainView`
    and decides that it requires a `MainViewModel`. If the `MainViewModel` has further
    dependencies, then the process iterates through all those dependencies and builds
    all the instances we need.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器使用Autofac来找出我们创建`MainView`实例所需的所有依赖项。它查看`MainView`的构造函数，并决定它需要一个`MainViewModel`。如果`MainViewModel`有进一步的依赖项，那么该过程将遍历所有这些依赖项并构建我们需要的所有实例。
- en: We will now be able to run the app. It will be showing us a map centered at
    the current location of the user. We will now add code to track the location over
    time using background location tracking.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够运行该应用程序。它将显示一个以用户当前位置为中心的地图。我们现在将添加代码来使用后台位置跟踪来跟踪位置。
- en: Background location tracking on iOS
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS上的后台位置跟踪
- en: The code for location tracking is something that we need to write for each platform.
    For iOS, we will use the `CLLocationManager` from the `CoreLocation` namespace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 位置跟踪的代码是我们需要为每个平台编写的。对于iOS，我们将使用`CoreLocation`命名空间中的`CLLocationManager`。
- en: Enabling location updates in the background
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台启用位置更新
- en: 'When we want to perform tasks in the background in an iOS app, we need to declare
    what we want to do in the `info.plist` file. The following steps show how we go
    about it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在iOS应用程序中后台执行任务时，我们需要在`info.plist`文件中声明我们想要做什么。以下步骤显示了我们如何做到这一点：
- en: In the `MeTracker.iOS` project, open `info.plist`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker.iOS`项目中，打开`info.plist`。
- en: Go to the Capabilities tab.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Capabilities选项卡。
- en: 'Select Enable Background Modes and Location updates, as shown in the following
    screenshot:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择启用后台模式和位置更新，如下面的屏幕截图所示：
- en: '![](img/d435c61a-a1ae-4858-9b37-45fa9be0f004.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d435c61a-a1ae-4858-9b37-45fa9be0f004.png)'
- en: 'We can also enable background modes directly in the `info.plist` file, if we
    open it with an XML editor. In this case, we will add the following XML:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用XML编辑器直接在`info.plist`文件中打开它，我们也可以直接启用后台模式。在这种情况下，我们将添加以下XML：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Getting permissions to use the location of the user
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取使用用户位置的权限
- en: 'Before we can request permissions for using the location of the user, we need
    to add a description of what we will use the location for. Since the introduction
    of iOS 11, we are no longer allowed to just ask for permission to track the location
    of the user all the time; the user has to be able to give us permission to only
    track their location while they are using the app. We will add the description
    to the `info.plist` file by going through the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以请求使用用户位置的权限之前，我们需要添加一个描述，说明我们将使用位置。自从iOS 11推出以来，我们不再允许只请求始终跟踪用户位置的权限；用户必须能够只在使用应用时允许我们跟踪他们的位置。我们将通过以下步骤向`info.plist`文件中添加描述：
- en: Open `info.plist` with the XML (text) editor that can be found in the `MeTracker.iOS`
    project.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用XML（文本）编辑器打开`MeTracker.iOS`项目中的`info.plist`。
- en: Add the key, `NSLocationWhenInUseUsageDescription`, with a description.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加键`NSLocationWhenInUseUsageDescription`，并附上描述。
- en: 'Add the key, `NSLocationAlwaysAndWhenInUsageDescription`, with a description,
    as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加键`NSLocationAlwaysAndWhenInUsageDescription`，并附上描述，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Subscribing to location updates
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅位置更新
- en: 'Now that we have prepared the `info.plist` file for location tracking, it is
    time to write the actual code that will track the location of the user. If we
    don''t set the `CLLocationManager` to not pause location updates, location updates
    can be paused automatically by iOS when the location data is unlikely to change.
    In this app, we don''t want that to happen because we want to save the location
    multiple times so that we can establish whether a user visits a particular location
    frequently. Let''s set this up by going through the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为位置跟踪准备好了`info.plist`文件，是时候编写实际的代码来跟踪用户的位置了。如果我们不将`CLLocationManager`设置为不暂停位置更新，当位置数据不太可能改变时，iOS可能会自动暂停位置更新。在这个应用程序中，我们不希望发生这种情况，因为我们希望多次保存位置，以便我们可以确定用户是否经常访问特定位置。让我们通过以下步骤来设置这个：
- en: In the `MeTracker.iOS` project, open the `LocationTrackingService`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker.iOS`项目中打开`LocationTrackingService`。
- en: Add a private field for the `CLLocationManager`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CLLocationManager`添加一个私有字段。
- en: Create an instance of the `CLLocationMananger` in the `StartTracking` method.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartTracking`方法中创建`CLLocationMananger`的实例。
- en: Set `PausesLocationUpdatesAutomatically` to `false`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PausesLocationUpdatesAutomatically`设置为`false`。
- en: 'Set `AllowBackgroundLocationUpdates` to `true`(as shown in the following code)so
    that the location updates will continue even when the app is running in the background:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AllowBackgroundLocationUpdates`设置为`true`（如下所示的代码），以便即使应用在后台运行时，位置更新也会继续进行：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next step is to ask the user for permission to track their location. We
    will request permission to track their location all the time, but the user has
    the option of only giving us permission to track their location when they are
    using the app. Because the user also has the option of denying us permission to
    track their location, we need to check before we start to. Let''s set this up
    by going through the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是请求用户允许跟踪他们的位置。我们将请求始终跟踪他们的位置的权限，但用户可以选择只在使用应用时允许我们跟踪他们的位置。因为用户也可以选择拒绝我们跟踪他们的位置的权限，所以在开始之前我们需要进行检查。让我们通过以下步骤来设置这个：
- en: Add an event listener for when the authorization is changed by hooking up the
    `AuthorizationChanged` event on the `locationManager`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`locationManager`上连接`AuthorizationChanged`事件来添加授权更改的事件监听器。
- en: In the event listener, create an `if` statement to check whether the user allows
    us to track their location.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件监听器中，创建一个`if`语句来检查用户是否允许我们跟踪他们的位置。
- en: Call the `RequestAlwaysAuthorization` method of the instance that we recently
    created in the `CLLocationManager`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们最近在`CLLocationManager`中创建的实例的`RequestAlwaysAuthorization`方法。
- en: 'The code should be placed under the `// Add code here` comment, as shown in
    bold in the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该放在`// Add code here`注释下，如下面的粗体所示：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we start to track the location of the user, we will set the accuracy
    of the data that we want to receive from the `CLLocationManager`. We will also
    add an event handler to handle the location updates. Let''s set this up by going
    through the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始跟踪用户位置之前，我们将设置我们希望从`CLLocationManager`接收的数据的准确性。我们还将添加一个事件处理程序来处理位置更新。让我们通过以下步骤来设置这个：
- en: Set the `DesiredAccuracy` to `CLLocation.AccurracyBestForNavigation`. One of
    the constraints when running the app in the background is that the `DesiredAccuracy`
    needs to be set to either `AccurracyBest` or `AccurracyBestForNavigation`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DesiredAccuracy`设置为`CLLocation.AccurracyBestForNavigation`。在后台运行应用程序时的一个限制是，`DesiredAccuracy`需要设置为`AccurracyBest`或`AccurracyBestForNavigation`。
- en: Add an event handler for `LocationsUpdated` and, after that, call the `StartUpdatingLocation`
    method.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`LocationsUpdated`添加一个事件处理程序，然后调用`StartUpdatingLocation`方法。
- en: 'The code should be placed at the `// Next section goes here` comment, and it
    should look like the code in bold in the following fragment:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该放在`// Next section goes here`注释下，并且应该看起来像下面片段中的粗体代码：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The higher the accuracy we set, the higher the battery consumption. If we only
    want to track where the user has been and not how popular a place is, we could
    also set `AllowDeferredLocationUpdatesUntil`. This way, we can specify that the
    user has to move a specific distance before the location is updated. We can also
    specify how often we want locations to be updated using the `timeout` argument.
    The most power-efficient solution to track how long a user has been at a place
    is to use the  `StartMonitoringVisits` method of `CLLocationManager`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的精度越高，电池消耗就越高。如果我们只想跟踪用户去过哪里而不是一个地方有多受欢迎，我们还可以设置`AllowDeferredLocationUpdatesUntil`。这样，我们可以指定用户在更新位置之前必须移动特定距离。我们还可以使用`timeout`参数指定我们希望多久更新一次位置。跟踪用户在某个地方停留的最节能解决方案是使用`CLLocationManager`的`StartMonitoringVisits`方法。
- en: 'Now, it''s time to handle the `LocationsUpdated` event. Let''s go through the
    following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理`LocationsUpdated`事件了。让我们按照以下步骤进行：
- en: Add a private field with the name `locationRepository` that is of the `ILocationRepository `type.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`locationRepository`的私有字段，类型为`ILocationRepository`。
- en: Add a constructor that has `ILocationRepository` as a parameter. Set the value
    of the parameter to the `locationRepository` field.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，该构造函数以`ILocationRepository`作为参数。将参数的值设置为`locationRepository`字段。
- en: Read the latest location of the `Locations` property on  `CLLocationsUpdatedEventArgs`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CLLocationsUpdatedEventArgs`的`Locations`属性上读取最新位置。
- en: Create an instance of the `MeTracker.Models.Location` and pass the latitude
    and longitude of the latest location to it.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MeTracker.Models.Location`的实例，并将最新位置的纬度和经度传递给它。
- en: Save the location using the `Save` method of the `ILocationRepository`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ILocationRepository`的`Save`方法保存位置。
- en: 'The code should be placed at the `// Final block of code goes here` comment,
    and it should look like the code in bold in the following fragment:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应放置在`//最终的代码块放在这里`的注释处，并且应该看起来像以下片段中的粗体代码：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have completed the tracking part of the app for iOS. We will now implement
    background tracking for Android. After this, we will visualize the data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了iOS应用的跟踪部分。现在我们将为Android实现后台跟踪。之后，我们将可视化数据。
- en: Background location tracking with Android
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android进行后台位置跟踪
- en: The Android way to carry out background updates is very different from how we
    implemented this with iOS. With Android, we need to create a `JobService` and
    schedule it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中进行后台更新的方式与我们在iOS中实现的方式非常不同。使用Android，我们需要创建一个`JobService`并对其进行调度。
- en: Adding the required permissions to use the location of the user
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加所需的权限以使用用户的位置
- en: 'To track the location of the user in the background with Android, we need to
    request five permissions, as shown in the following table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要在后台跟踪用户的位置，我们需要请求五个权限，如下表所示：
- en: '| `ACCESS_COARSE_LOCATION` | To get an approximate location for the user |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `ACCESS_COARSE_LOCATION` | 获取用户的大致位置 |'
- en: '| `ACCESS_FINE_LOCATION` | To get a precise location for the user |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `ACCESS_FINE_LOCATION` | 获取用户的精确位置 |'
- en: '| `ACCESS_NETWORK_STATE` | Because the location services in Android  use information
    from a network to determine the location of the user |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `ACCESS_NETWORK_STATE` | 因为Android中的位置服务使用来自网络的信息来确定用户的位置 |'
- en: '| `ACCESS_WIFI_STATE` | Because the location services in Android use information
    from a Wi-Fi network to determine the location of the user |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `ACCESS_WIFI_STATE` | 因为Android中的位置服务使用来自Wi-Fi网络的信息来确定用户的位置 |'
- en: '| `RECEIVE_BOOT_COMPLETED` | So that the background job can start again after
    the device is rebooted |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `RECEIVE_BOOT_COMPLETED` | 以便在设备重新启动后可以重新启动后台作业 |'
- en: Permissions can be set either from the Android Manifest tab in the properties
    of the `MeTracker.Android` project or via the `AndroidManifest.xml` file in the
    `Properties` folder. When changes are made from the Android Manifest tab, the
    changes will be written to the `AndroidMainfest.xml` file as well, so it doesn't
    matter which method you prefer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以从`MeTracker.Android`项目的属性中的Android清单选项卡或`Properties`文件夹中的`AndroidManifest.xml`文件中设置。当从Android清单选项卡进行更改时，更改也将写入`AndroidMainfest.xml`文件，因此无论您喜欢哪种方法都无所谓。
- en: 'The following is a screenshot of setting the permissions in the Android Manifest
    tab in the properties of the `MeTracker.Android` project:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`MeTracker.Android`项目的属性中的Android清单选项卡中设置权限的屏幕截图：
- en: '![](img/783ecaab-f536-46f5-82ec-95ff0eefd4d8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/783ecaab-f536-46f5-82ec-95ff0eefd4d8.png)'
- en: 'The `uses-permission` elements should be added to the `manifest` element in
    the `AndroidManifest.xml`file, as shown in the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`uses-permission`元素应添加到`AndroidManifest.xml`文件中的`manifest`元素中，如下面的代码所示：'
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a background job
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建后台作业
- en: 'To track the location of users in the background, we need to create a background
    job by going through the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在后台跟踪用户的位置，我们需要通过以下步骤创建一个后台作业：
- en: In the Android project, create a new class with the name `LocationJobService`
    in the `Services` folder.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，在`Services`文件夹中创建一个名为`LocationJobService`的新类。
- en: Make the class `public` and add `Android.App.Job.JobService` as a base class.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为`public`，并将`Android.App.Job.JobService`添加为基类。
- en: 'Implement the abstract methods `OnStartJob` and `OnStopJob`, as shown in the
    following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnStartJob`和`OnStopJob`的抽象方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All services in an Android app need to be added to the `AndroidManifest.xml`
    file. We don''t have to do this manually; however, we can instead add an attribute
    to the class, which will then be generated in the `AndroidManifest.xml` file.
    We will use the `Name` and `Permission` properties to set the required information,
    as shown in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用中的所有服务都需要添加到`AndroidManifest.xml`文件中。我们不必手动执行此操作；相反，我们可以向类添加属性，然后该属性将在`AndroidManifest.xml`文件中生成。我们将使用`Name`和`Permission`属性来设置所需的信息，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Scheduling a background job
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度后台作业
- en: When we have created a job, we can schedule it. We will do this from the `LocationTrackingService`
    in the `MeTracker.Android` project. To configure the job, we will use the `JobInfo.Builder`
    class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个作业，我们可以安排它。我们将从`MeTracker.Android`项目中的`LocationTrackingService`中执行此操作。要配置作业，我们将使用`JobInfo.Builder`类。
- en: We will use the `SetPersisted` method to ensure that the job starts again after
    a reboot. This is why we added the `RECEIVE_BOOT_COMPLETED` permission earlier.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`SetPersisted`方法来确保作业在重新启动后重新启动。这就是为什么我们之前添加了`RECEIVE_BOOT_COMPLETED`权限。
- en: To schedule a job, at least one constraint is needed. In this case, we will
    use `SetOverrideDeadline`. This will specify that the job needs to run before
    the specified time (in milliseconds) has elapsed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要安排作业，至少需要一个约束。在这种情况下，我们将使用`SetOverrideDeadline`。这将指定作业需要在指定的时间（以毫秒为单位）之前运行。
- en: The `SetRequiresDeviceIdle` code phrase can be used to make sure that a job
    only runs when the device is not being used by a user. We could pass `true` to
    the method if we want to make sure that we don't slow down the device when the
    user is using it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetRequiresDeviceIdle`代码短语可用于确保作业仅在设备未被用户使用时运行。如果我们希望确保在用户使用设备时不减慢设备速度，可以将`true`传递给该方法。'
- en: The `SetRequiresBatteryNotLow` code phrase can be used to specify that a job
    should not run when the battery level is low. We recommend that this should always
    be set to `true` if you don't have a good reason to run it when the battery is
    low. This is because we don't want our applications to drain the user's battery.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetRequiresBatteryNotLow`代码短语可用于指定作业在电池电量低时不运行。如果没有充分的理由在电池电量低时运行作业，我们建议始终将其设置为`true`。这是因为我们不希望我们的应用程序耗尽用户的电池。'
- en: 'So, let''s implement the `LocationTrackingService` that is found in the Android
    project in the `Services` folder by going through the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过以下步骤实现在`Services`文件夹中的Android项目中找到的`LocationTrackingService`：
- en: Create a `JobInfo.Builder` based on an ID that we specify (we will use `1` here)
    and on the component name (which we create from the application context and the
    Java class) in the `StartTracking` method. The component name is used to specify
    which code will run during the job.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们指定的ID（这里我们将使用`1`）和组件名称（我们从应用程序上下文和Java类创建）创建`JobInfo.Builder`。组件名称用于指定哪些代码将在作业期间运行。
- en: Use the `SetOverrideDeadline` method and pass `1000` to it to make the job run
    before one second has elapsed from when the job was created.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetOverrideDeadline`方法，并将`1000`传递给它，以使作业在创建作业后不到一秒钟就运行。
- en: Use the `SetPersisted` method and pass `true` to make the job persist even after
    the device is rebooted.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetPersisted`方法并传递`true`，以确保作业在设备重新启动后仍然持续存在。
- en: Use the `SetRequiresDeviceIdle` method and pass `false` so that the job will
    run even when a user is using the device.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetRequiresDeviceIdle`方法并传递`false`，以便即使用户正在使用设备，作业也会运行。
- en: Use the `SetRequiresBatteryLow` method and pass `true` to make sure that we
    don't drain the user's battery. This method was added in Android API level 26.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetRequiresBatteryLow`方法并传递`true`，以确保我们不会耗尽用户的电池。此方法是在Android API级别26中添加的。
- en: 'The code for the `LocationTrackingService` should now look as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LocationTrackingService`的代码现在应该如下所示：'
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `JobScheduler` service is a system service. To get an instance of a system
    service, we will use the application context by going through the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler`服务是一个系统服务。要获取系统服务的实例，我们将通过以下步骤使用应用程序上下文：'
- en: Use the `GetSystemService` method on the `Application.Context` to get the `JobScheduler`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Application.Context`上的`GetSystemService`方法来获取`JobScheduler`。
- en: Cast the result to the `JobScheduler`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换为`JobScheduler`。
- en: 'Use the `Schedule` method on the `JobScheduler` class and pass the `JobInfo`
    object to schedule the job, as shown in the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`JobScheduler`类上使用`Schedule`方法，并传递`JobInfo`对象来安排作业，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Subscribing to location updates
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅位置更新
- en: Once we have scheduled the job, we can write the code to specify what the job
    should do, which is track the location of a user. To do this, we will use the `LocationManager`,
    which is a `SystemService`. With the `LocationManager`, we can either request
    a single location update or we can subscribe to location updates. In this case,
    we want to subscribe to location updates.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安排了作业，我们可以编写代码来指定作业应该做什么，即跟踪用户的位置。为此，我们将使用`LocationManager`，这是一个`SystemService`。使用`LocationManager`，我们可以请求单个位置更新，或者我们可以订阅位置更新。在这种情况下，我们希望订阅位置更新。
- en: 'We will start by creating an instance of the `ILocationRepository` interface
    that we will use to save the locations to the SQlite database. Let''s set this
    up by going through the following steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`ILocationRepository`接口的实例，用于将位置保存到SQlite数据库中。让我们通过以下步骤来设置这个：
- en: Create a constructor for the `LocationJobService`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`LocationJobService`创建一个构造函数。
- en: Create a private read-only field for the `ILocationRepository` interface with
    the name `locationRepository`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`ILocationRepository`接口创建一个私有的只读字段，名称为`locationRepository`。
- en: 'Use the `Resolver` in the constructor to create an instance of the `ILocationRepository`,
    as shown in the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中使用`Resolver`来创建`ILocationRepository`的实例，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before we subscribe to location updates, we will add a listener. To do this,
    we will use the `Android.Locations.ILocationListener`interface by going through
    the following steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅位置更新之前，我们将添加一个监听器。为此，我们将通过以下步骤使用`Android.Locations.ILocationListener`接口：
- en: Add the `Android.Locations.ILocationListener` to the `LocationJobService`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Android.Locations.ILocationListener`添加到`LocationJobService`。
- en: Implement the interface.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口。
- en: Remove all instances of `throw new NotImplementedException();`, which is added
    to the methods, if you let Visual Studio generate the implementation of the interface.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有`throw new NotImplementedException();`的实例，该实例是在让Visual Studio生成接口的实现时添加的。
- en: In the `OnLocationChanged` method, map the `Android.Locations.Location` object
    to the `Model.Location` object.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnLocationChanged`方法中，将`Android.Locations.Location`对象映射到`Model.Location`对象。
- en: 'Use the `Save` method on the `LocationRepository` class, as shown in the following
    code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`LocationRepository`类上的`Save`方法，如下所示：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we have created a listener, we can subscribe for location updates by going
    through the following steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建监听器后，我们可以通过以下步骤订阅位置更新：
- en: Go to the `StartJob` method in the `LocationJobService`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`LocationJobService`中的`StartJob`方法。
- en: Create a static field of the `LocationManager` type.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`LocationManager`类型的静态字段。
- en: Get the `LocationManager` by using the `GetSystemService` on the `ApplicationContext`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetSystemService`获取`LocationManager`在`ApplicationContext`上。
- en: 'To subscribe for location updates, use the `RequestLocationUpdates` method,
    as shown in the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要订阅位置更新，请使用`RequestLocationUpdates`方法，如下所示：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first argument that we pass to the `RequestLocationUpdates`method ensures
    that we get locations from the GPS. The second ensures that at least `1000` milliseconds will elapse
    between location updates. The third argument ensures that the user has to move
    at least `0.1` meters to get a location update. The last one specifies which listener
    we should use. Because the current class implements the `Android.Locations.ILocationListener`interface,
    we will pass `this`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`RequestLocationUpdates`方法的第一个参数确保我们从GPS获取位置。第二个确保位置更新之间至少间隔`1000`毫秒。第三个参数确保用户必须移动至少`0.1`米才能获得位置更新。最后一个指定我们应该使用哪个监听器。因为当前类实现了`Android.Locations.ILocationListener`接口，我们将传递`this`。
- en: Creating a heat map
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建热力图
- en: To visualize the data that we have collected, we will create a heat map. We
    will add lots of dots to a map and make them different colors, based on how much
    time a user spends in a particular place. The most popular places will have a
    warm color and the least popular places will have a cold color.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们收集到的数据，我们将创建一个热力图。我们将在地图上添加许多点，并根据用户在特定位置停留的时间来设置它们的不同颜色。最受欢迎的地方将有温暖的颜色，而最不受欢迎的地方将有冷色。
- en: Adding a GetAll method to the LocationRepository
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向`LocationRepository`添加一个`GetAll`方法
- en: 'In order to visualize the data, we need to write code so that is can be read
    from the database. Let''s set this up by going through the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化数据，我们需要编写代码，以便从数据库中读取数据。让我们通过以下步骤来设置这个：
- en: In the `MeTracker` project, open the `ILocationRepository.cs` file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，打开`ILocationRepository.cs`文件。
- en: 'Add a `GetAll` method, which returns a list of `Location` objects using the
    following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`GetAll`方法，使用以下代码返回`Location`对象的列表：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `MeTracker` project, open the`LocationRepository.cs` file, which implements
    the `ILocationRepository`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，打开实现`ILocationRepository`的`LocationRepository.cs`文件。
- en: 'Implement the new `GetAll` method and return all the saved locations in the
    database, as shown in the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现新的`GetAll`方法，并返回数据库中所有保存的位置，如下所示：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Preparing the data for visualization
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为可视化数据准备数据
- en: 'Before we can visualize the data on the map, we need to prepare the data. The
    first thing we will do is create a new model that we can use for the prepared
    data. Let''s set this up by going through the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在地图上可视化数据之前，我们需要准备数据。我们将首先创建一个新的模型，用于准备好的数据。让我们通过以下步骤设置这个：
- en: In the `Models` folder in the `MeTracker` project, create a new class and name
    it `Point`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目的`Models`文件夹中，创建一个新的类并命名为`Point`。
- en: 'Add properties for the `Location`, the `Count`, and the `Heat`, as shown in
    the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Location`，`Count`和`Heat`的属性，如下所示：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `MainViewModel` will store the locations that we will find later on. Let''s
    add a property for storing the `Points` by going through the following steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel`将存储我们以后会找到的位置。让我们通过以下步骤添加一个用于存储`Points`的属性：'
- en: In the `MeTracker` project, open the `MainViewModel` class.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，打开`MainViewModel`类。
- en: Add a `private` field with the name `points`, which has the `List<Point>` type.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`points`的`private`字段，它具有`List<Point>`类型。
- en: Create a property with the name `Points` that has the `List<Point>` type.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Points`的属性，它具有`List<Point>`类型。
- en: In the `get` method, return the value of the `points` field.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`get`方法中，返回`points`字段的值。
- en: In the `set` method, set the `points` field to the new value and call `RaisePropertyChanged` with
    the name of the property as an argument.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`set`方法中，将`points`字段设置为新值，并调用`RaisePropertyChanged`并将属性的名称作为参数。
- en: 'At the end of the `LoadData` method, assign the `pointList` variable to the `Points` property,
    as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LoadData`方法的末尾，将`pointList`变量分配给`Points`属性，如下所示：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that we have the storage for our points, we must add code to add locations.
    We will do this by implementing the `LoadData` method of the `MainViewModel` class
    and making sure that it is called on the main thread right after the location
    tracking has started.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储点的位置，我们必须添加代码来添加位置。我们将通过实现`MainViewModel`类的`LoadData`方法来实现这一点，并确保在位置跟踪开始后立即在主线程上调用它。
- en: 'The first thing we will do is to group the saved locations so that all locations
    within 200 meters will be handled as one point. We will track how many times we
    have logged a position within that point so we can later decide which color the
    point will be on the map. Let''s set this up using the following steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对保存的位置进行分组，以便所有在200米范围内的位置将被视为一个点。我们将跟踪我们在该点内记录位置的次数，以便稍后决定地图上该点的颜色。让我们通过以下步骤设置这个：
- en: Add an `async` method with the name LoadData, which returns a `Task` to the
    `MainViewModel`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为LoadData的`async`方法，它返回`MainViewModel`的`Task`。
- en: 'Call the `LoadData` method from the constructor after the call to the `StartTracking`
    method on the `ILocationTrackingService`, as shown in the following code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ILocationTrackingService`的`StartTracking`方法调用后，从构造函数中调用`LoadData`方法，如下所示：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first step in the `LoadData` method is to read all tracked locations from
    the SQLite database. When we have all the locations, we will loop through them
    and create the points. To calculate the distance between a location and a point,
    we will use the `CalculateDistance` method from `Xamarin.Essentials.Location`,
    as shown in the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadData`方法的第一步是从SQLite数据库中读取所有跟踪位置。当我们有了所有的位置后，我们将循环遍历它们并创建点。为了计算位置和点之间的距离，我们将使用`Xamarin.Essentials.Location`中的`CalculateDistance`方法，如下面的代码所示：'
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we have a list of points, we can calculate the heat color for each point.
    We are going to use the **hue, s****aturation, and lightness** (**HSL**) representation
    of a color, as described in the following list:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了点的列表，我们可以计算每个点的热度颜色。我们将使用颜色的**色调、饱和度和亮度**（HSL）表示，如下面的列表所述：
- en: '**Hue**:Hue is a degree on the color wheel that goes from 0 to 360, 0 being
    red and 240 being blue. Because we want our most popular places to be red (hot)
    and our least popular places to be blue (cold), we will calculate a value between
    0 and 240 for each point, based on how many times the user has been to that point.
    This means that we will only use two-thirds of the scale.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调**：色调是色轮上从0到360的度数，0是红色，240是蓝色。因为我们希望我们最受欢迎的地方是红色（热的），我们最不受欢迎的地方是蓝色（冷的），我们将根据用户到达该点的次数计算每个点的值在0到240之间。这意味着我们只会使用比例的三分之二。'
- en: '**Saturation**:Saturation is a percentage value: 0% is a shade of gray, while
    100% is full color. In our app, we will always use 100% (this will be represented
    as `1` in the code).'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**饱和度**：饱和度是一个百分比值：0%是灰色，而100%是全彩。在我们的应用程序中，我们将始终使用100%（在代码中表示为`1`）。'
- en: '**Lightness**: Lightness is a percentage value of the amount of light: 0% is
    black and 100% is white. We want it to be neutral, so we will use 50% (this will
    be represented as `0.5` in the code).'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亮度**：亮度是光的百分比值：0%是黑色，100%是白色。我们希望它是中性的，所以我们将使用50%（在代码中表示为`0.5`）。'
- en: 'The first thing that we need to do is find out how many times the user has
    been in the most popular and least popular places. We find this out by going through
    the following steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是找出用户在最受欢迎和最不受欢迎的地方分别去过多少次。我们通过以下步骤找出这一点：
- en: First, check that the list of points is not empty.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查点的列表是否为空。
- en: Get the `Min` and `Max` values for the `Count` property in the list of points.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取点列表中`Count`属性的`Min`和`Max`值。
- en: Calculate the difference between the minimum and the maximum values.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算最小值和最大值之间的差异。
- en: 'The code should be added at the `// Next section of code goes` comment at the
    bottom of  the `LoadData` method, as shown in the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应添加到`LoadData`方法底部的`// 下一段代码放在这里`注释处，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will now be able to calculate the heat for each point by going through the
    following steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够通过以下步骤计算每个点的热度：
- en: Loop through all the points.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历所有点。
- en: Use the following calculation to calculate the heat for each point.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下计算来计算每个点的热度。
- en: 'The code should be added at the `// Last section of code goes here` comment
    at the bottom of the `LoadData()` method, as shown in bold in the following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应添加到`LoadData()`方法底部的`// 最后一段代码放在这里`注释处，如下面的粗体所示：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's it for setting up location tracking in the `MeTracker` project. Let's
    turn our attention to visualizing the data we get.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在`MeTracker`项目中设置位置跟踪的全部内容。现在让我们把注意力转向可视化我们得到的数据。
- en: Creating custom renderers
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义渲染器
- en: '**Custom renderers** are a powerful way to extend Xamarin.Forms. As mentioned
    in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*,
    Xamarin.Forms is built with renderers, so for each Xamarin.Forms control there
    is a renderer that creates a native control. By overriding an existing renderer
    or creating a new one, we can extend and customize how Xamarin.Forms controls
    are rendered to native controls. We can also use renderers to create new Xamarin.Forms
    controls from scratch.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义渲染器**是扩展Xamarin.Forms的强大方式。正如在[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)中提到的，*Xamarin简介*，Xamarin.Forms是使用渲染器构建的，因此对于每个Xamarin.Forms控件，都有一个渲染器来创建本机控件。通过覆盖现有的渲染器或创建新的渲染器，我们可以扩展和自定义Xamarin.Forms控件的呈现方式。我们还可以使用渲染器从头开始创建新的Xamarin.Forms控件。'
- en: Renderers are platform specific, so when we create custom renderers, we have
    to create one for each platform that we want to change or use to extend the behavior
    of a control. To make our renderers visible for Xamarin.Forms, we will use the
    assembly attribute `ExportRenderer`. This contains information about which control
    the renderer is for and which renderer will be used.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器是特定于平台的，因此当我们创建自定义渲染器时，我们必须为要更改或使用来扩展控件行为的每个平台创建一个渲染器。为了使我们的渲染器对Xamarin.Forms可见，我们将使用`ExportRenderer`程序集属性。这包含有关渲染器所用的控件以及将使用哪个渲染器的信息。
- en: Creating a custom control for the map
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为地图创建自定义控件
- en: 'In order to show the heat map on our map, we will create a new control, for
    which we will use a custom renderer. We set this up by going through the following
    steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在地图上显示热力图，我们将创建一个新的控件，我们将使用自定义渲染器。我们通过以下步骤设置这一点：
- en: In the `MeTracker` project, create a new folder with the name `Controls`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，创建一个名为`Controls`的新文件夹。
- en: Create a new class with the name `CustomMap`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomMap`的新类。
- en: 'Add the `Xamarin.Forms.Maps.Map` as a base class to the new class, as shown
    in the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Xamarin.Forms.Maps.Map`添加为新类的基类，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we want to have properties that we want to bind data to, we need to create
    a `BindableProperty`. This should be a `public static` field in the class. We
    also need to create a *regular* property. The naming of the properties is really
    important. The name of the `BindableProperty` needs to be `{NameOfTheProperty}Property`;
    for example, the name of the `BindableProperty` that we will create in the following
    steps will be `PointsProperty`, because the name of the property is `Points`.
    A `BindableProperty` is created using the static `Create` method on the `BindableProperty`
    class. This requires at least four arguments, as shown in the following list:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要绑定数据的属性，我们需要创建一个`BindableProperty`。这应该是类中的一个`public static`字段。我们还需要创建一个*常规*属性。属性的命名非常重要。`BindableProperty`的名称需要是`{NameOfTheProperty}Property`；例如，我们将在以下步骤中创建的`BindableProperty`的名称将是`PointsProperty`，因为属性的名称是`Points`。使用`BindableProperty`类上的静态`Create`方法创建`BindableProperty`。这需要至少四个参数，如下列表所示：
- en: '`propertyName`:This is the name of the property as a string.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyName`：这是属性的名称作为字符串。'
- en: '`returnType`: This is the type that will be returned from the property.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：这是从属性返回的类型。
- en: '`declaringType`:This is the type of the class in which the `BindableProperty`
    is declared.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declaringType`：这是声明`BindableProperty`的类的类型。'
- en: '`defaultValue`:This is the default value that will be returned if no value
    is set. This is an optional argument. If it is not set, Xamarin.Forms will use
    `null` as a default value.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`：如果未设置值，将返回的默认值。这是一个可选参数。如果未设置，Xamarin.Forms将使用`null`作为默认值。'
- en: 'The `set` and `get` methods for the property will call methods in the base
    class to `set` or `get` values from the `BindableProperty`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的`set`和`get`方法将调用基类中的方法，从`BindableProperty`中`set`或`get`值：
- en: In the `MeTracker` project, create a `BindableProperty` with the name `PointsProperty`,
    as shown in the following code.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker`项目中，创建一个名为`PointsProperty`的`BindableProperty`，如下所示。
- en: 'Create a property of the `List<Models.Point>` type with the name `Points`. Remember
    to cast the result of the `GetValue` as the same type as the property, because
    the `GetValue` will return the value as the type object:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`List<Models.Point>`类型的名为`Points`的属性。记得将`GetValue`的结果转换为与属性相同的类型，因为`GetValue`将以类型对象返回值：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we have created a custom map control, we will use it to replace the `Map`
    control in the `MainView` by going through the following steps:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了自定义地图控件后，我们将通过以下步骤使用它来替换`MainView`中的`Map`控件：
- en: In the `MainView.xaml` file, declare the namespace for the custom control.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainView.xaml`文件中，声明自定义控件的命名空间。
- en: Replace the `Map` control with the new control that we have created.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们创建的新控件替换`Map`控件。
- en: 'Add a binding to the `Points` property in the `MainViewModel`, as shown in
    the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewModel`的`Points`属性中添加绑定，如下所示：
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**# Creating a custom renderer to extend the map in the iOS app'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建自定义渲染器以扩展iOS应用中的地图'
- en: 'First, we will create a custom renderer for iOS by going through the following
    steps. Because we want to extend the functionality, we will use the `MapRenderer`
    as a base class:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过以下步骤为iOS创建自定义渲染器。因为我们想要扩展功能，所以我们将使用`MapRenderer`作为基类：
- en: Create a folder with the name `Renderers` in the `MeTracker.iOS` project.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker.iOS`项目中创建一个名为`Renderers`的文件夹。
- en: Create a new class in this folder and name it `CustomMapRenderer`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建一个新类，并命名为`CustomMapRenderer`。
- en: Add `MapRenderer` as a base class.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MapRenderer`添加为基类。
- en: 'Add the `ExportRenderer` attribute, as shown in the following code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ExportRenderer`属性，如下所示：
- en: '[PRE52]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When a property changes for the control that we are writing a custom renderer
    for, the `OnElementPropertyChanged` method is called. The method is a virtual
    method, which means that we can override it. We want to listen to any changes
    to the `Points` property in our `CustomMap` control.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为自定义渲染器编写控件的属性更改时，将调用`OnElementPropertyChanged`方法。该方法是一个虚方法，这意味着我们可以重写它。我们希望监听`CustomMap`控件中`Points`属性的任何更改。
- en: 'To do this, go through the following steps:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请按以下步骤操作：
- en: Override the `OnElementPropertyChanged`method. This method will run every time
    a property value is changed in the element (the Xamarin.Forms control).
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`OnElementPropertyChanged`方法。每当元素（Xamarin.Forms控件）中的属性值更改时，此方法将运行。
- en: 'Add an `if` statement to check that it is the `Points` property that has changed,
    as shown in the following code:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`if`语句来检查更改的是否是`Points`属性，如下所示：
- en: '[PRE53]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To create the heat map, we will add circles as overlays to the map, one circle
    for each point. Before we do this, however, we need to add some code to specify
    how an overlay should be rendered. Let''s set this up by going through the following
    steps:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建热力图，我们将向地图添加圆圈作为覆盖物，每个点一个圆圈。但在此之前，我们需要添加一些代码来指定如何渲染覆盖物。让我们通过以下步骤设置这个：
- en: Create a `mapView` variable. Cast the `Control` property to `MKMapView` and
    assign it to the variable.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`mapView`变量。将`Control`属性转换为`MKMapView`并将其赋值给变量。
- en: Create a `customMap` variable. Cast the `Element` property to the `CustomMap`
    and assign it to the variable.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`customMap`变量。将`Element`属性转换为`CustomMap`并将其赋值给变量。
- en: Create an action using an expression with parameters for `MKMapView` and `IMKOverlay`and
    assign it to the `OverlayRenderer` property on the `map` view.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`MKMapView`和`IMKOverlay`参数的表达式创建一个操作，并将其分配给`map`视图上的`OverlayRenderer`属性。
- en: Cast the `overlay` parameter to `MKCircle` and assign it to a new variable called
    `circle`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`overlay`参数转换为`MKCircle`并将其分配给一个名为`circle`的新变量。
- en: Verify that the circle variable is not `null`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证圆圈变量不为`null`。
- en: Find the point object from the point list on the `CustomMap` object using coordinates.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用坐标从`CustomMap`对象的点列表中找到点对象。
- en: Create a new `MKCircleRenderer` object and pass the circle variable to the constructor.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`MKCircleRenderer`对象，并将圆圈变量传递给构造函数。
- en: Set the `FillColor` property to the heat color of the point. Convert it to `UIColor`
    using the extension method `ToUIColor`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FillColor`属性设置为点的热色。使用扩展方法`ToUIColor`将其转换为`UIColor`。
- en: Set the `Alpha` property to `1.0f` to make sure that the circle not will be
    transparent.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Alpha`属性设置为`1.0f`，以确保圆不会是透明的。
- en: Return the `circleRenderer` variable.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`circleRenderer`变量。
- en: Return `null` if the circle variable is `null`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果圆变量为`null`，则返回`null`。
- en: 'The code should look like the bold code in the following fragment:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，代码应该看起来像以下片段中的粗体代码：
- en: '[PRE54]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have implemented how we want each overlay of the map to be rendered. What
    we need to do now is to go through all the points we have gathered so far and
    create an `Overlay` for each one. Let''s set this up by going through the following
    steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了如何渲染地图的每个覆盖物。现在我们需要做的是遍历到目前为止收集到的所有点，并为每个点创建一个`Overlay`。让我们通过以下步骤来设置这一点：
- en: Loop through all the points.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历所有点。
- en: Create a circle overlay with the `static` method `Circle` on the `MKCircle`
    class, as shown in the following code. The first argument is the position of the
    `Circle` and the second one is the radius of the `Circle`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MKCircle`类上的`static`方法`Circle`创建一个圆覆盖物，如下面的代码所示。第一个参数是`Circle`的位置，第二个参数是`Circle`的半径。
- en: Add the overlay to the map using the `AddOverlay` method.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AddOverlay`方法将覆盖添加到地图上。
- en: 'The code should now look like the bold code in the following fragment:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，代码应该看起来像以下片段中的粗体代码：
- en: '[PRE55]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This concludes the section on how to extend the `Maps` control for iOS. Let's
    do the same for Android.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了如何扩展iOS上的`Maps`控件的部分。让我们为Android做同样的事情。
- en: Creating a custom renderer to extend the map in the Android app
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android应用程序中扩展地图创建一个自定义渲染器
- en: We will now create a custom renderer for Android. The structure is the same
    as the one we used for iOS. We will use the `ExportRenderer` attribute in the
    same way and we will also add the` MapRenderer` class as the base class. This,
    however, is the Android-specific `MapRenderer`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为Android创建一个自定义渲染器。结构与我们用于iOS的相同。我们将以与iOS相同的方式使用`ExportRenderer`属性，并且还将`MapRenderer`类添加为基类。但这是特定于Android的`MapRenderer`。
- en: 'We start by creating a custom renderer for our `CustomMap` control. The renderer
    will inherit from the `MapRenderer` base class so that we can extend any existing
    functionality. To do this, go through the following steps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要为我们的`CustomMap`控件创建一个自定义渲染器。渲染器将继承自`MapRenderer`基类，以便我们可以扩展任何现有的功能。为此，请按照以下步骤进行：
- en: Create a folder with the name `Renderers` in the `MeTracker.Android` project.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeTracker.Android`项目中创建一个名为`Renderers`的文件夹。
- en: Create a new class in this folder and name it `CustomMapRenderer`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建一个新类，并将其命名为`CustomMapRenderer`。
- en: Add `MapRenderer` as a base class.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`MapRenderer`作为基类。
- en: Add the `ExportRenderer` attribute.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ExportRenderer`属性。
- en: Add a constructor that has `Context` as a parameter. Pass the parameter to the
    constructor of the base class.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以`Context`为参数的构造函数。将参数传递给基类的构造函数。
- en: 'Resolve all the references, as shown in the following code:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决所有引用，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To get a map object to work with, we need to request it. We do this by overriding
    the `OnElementChanged` method that all custom renderers have. This method is called
    each time an element changes, such as when it''s set for the first time when parsing
    the XAML, or when it''s replaced in code. Let''s set this up by going through
    the following steps:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个可操作的地图对象，我们需要请求它。我们通过重写所有自定义渲染器都具有的`OnElementChanged`方法来实现这一点。每当元素发生更改时，例如在首次解析XAML时设置元素或在代码中替换元素时，都会调用此方法。让我们通过以下步骤来设置这一点：
- en: Override the `OnElementChanged` method.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnElementChanged`方法。
- en: 'If the `NewElement` property of the `ElementChangedEventArgs` is not `null`,
    request the map object with the `GetMapAsync` method on the `Control` property,
    as shown in the following code:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`ElementChangedEventArgs`的`NewElement`属性不为`null`，则使用`Control`属性上的`GetMapAsync`方法请求地图对象，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we have a map to work with, the virtual `OnMapReady` method will be called.
    To add code of our own to handle this, we override this method by going through
    the following steps:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个地图可以操作时，虚拟的`OnMapReady`方法将被调用。为了添加我们自己的代码来处理这一点，我们通过以下步骤重写这个方法：
- en: Create a private field of the `GoogleMap` type and name it `map`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GoogleMap`类型的私有字段，并将其命名为`map`。
- en: Override the `OnMapReady` method.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnMapReady`方法。
- en: 'Assign the new field with the parameter from the method body, as shown in the
    following code:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用方法体中的参数为新字段赋值，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Just as we did with the iOS renderer, we need to handle changes in the `Points`
    property of our custom map. To do this, we override the `OnElementPropertyChanged`
    method that is called each time a property on the control we are writing our renderer
    for changes. Let''s do this by going through the following steps:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在iOS渲染器中所做的一样，我们需要处理自定义地图的`Points`属性的更改。为此，我们重写`OnElementPropertyChanged`方法，每当我们正在编写渲染器的控件上的属性发生更改时，都会调用此方法。让我们通过以下步骤来做到这一点：
- en: Override the `OnElementPropertyChanged`method. This method will run every time
    a property value is changed in the `Element` (the Xamarin.Forms control).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnElementPropertyChanged`方法。每当`Element`（Xamarin.Forms控件）的属性值发生更改时，此方法都会运行。
- en: 'Add an `if` statement to check that it is the `Points` property that has changed,
    as shown in the following code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`if`语句来检查是否已更改了`Points`属性，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can now add code to handle the specific event of the `Points` property being
    set by drawing the location out on the map. To do this, go through the following
    steps:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加代码来处理`Points`属性被设置的特定事件，通过在地图上绘制位置。为此，请按照以下步骤进行：
- en: For each point, create an instance of the `CircleOptions` class.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个点，创建一个`CircleOptions`类的实例。
- en: Use the `InvokeStrokeWidth` method to set the stroke width of the circle to
    `0`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InvokeStrokeWidth`方法将圆的描边宽度设置为`0`。
- en: Use the `InvokeFillColor` method to set the color of the circle. Use the `ToAndroid `extension
    method to convert the color to an `Android.Graphics.Color`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InvokeFillColor`方法设置圆的颜色。使用`ToAndroid`扩展方法将颜色转换为`Android.Graphics.Color`。
- en: Use the `InvokeRadius` method to set the size of the circle to `200`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InvokeRadius`方法将圆的大小设置为`200`。
- en: Use the `InvokeCenter` method to set where on the map the circle should be.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InvokeCenter`方法设置圆在地图上的位置。
- en: Add the circle to the `map` using the `AddCircle` method on the `map` object.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`对象上的`AddCircle`方法将圆添加到地图中。
- en: 'The code should look the same as the bold code in the following fragment:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该与以下片段中的粗体代码相同：
- en: '[PRE60]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Refreshing the map when resuming the app
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在恢复应用程序时刷新地图
- en: 'The last thing we will do is to make sure that the map is up to date with the
    latest points when the app is resumed. The easiest way to do this is to set the
    `MainPage` property in the `App.xaml.cs` file to a new instance of `MainView`,
    in the same way as the constructor, as shown in the following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是确保在应用程序恢复时地图与最新的点保持同步。这样做的最简单方法是在`App.xaml.cs`文件中将`MainPage`属性设置为`MainView`的新实例，方式与构造函数中一样，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built an app for iOS and Android that tracked the location
    of a user. When we built the app, we learned how to use maps in Xamarin.Forms
    and how to use location tracking running in the background. We also learned how
    to extend Xamarin.Forms with custom controls and custom renderers. With this knowledge,
    we can create applications that perform other tasks in the background. We also learned
    how to extend most controls in Xamarin.Forms.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为iOS和Android构建了一个跟踪用户位置的应用程序。当我们构建应用程序时，我们学习了如何在Xamarin.Forms中使用地图以及如何在后台运行位置跟踪。我们还学会了如何使用自定义控件和自定义渲染器扩展Xamarin.Forms。有了这些知识，我们可以创建在后台执行其他任务的应用程序。我们还学会了如何扩展Xamarin.Forms中的大多数控件。
- en: The next project will be a real-time chat app. In the next chapter, we will
    set up a serverless backend based on services in Microsoft Azure. We will use
    that backend in a later chapter once we have built the app.**
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目将是一个实时聊天应用程序。在下一章中，我们将建立一个基于Microsoft Azure服务的无服务器后端。一旦我们构建了应用程序，我们将在以后的章节中使用该后端。**
