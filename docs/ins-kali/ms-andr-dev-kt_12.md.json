["```kt\n   data class Entity(val param1: String, val param2: String) \n```", "```kt\n     package com.journaler.api \n\n     data class UserLoginRequest( \n        val username: String, \n        val password: String \n     )  \n```", "```kt\n    package com.journaler.api \n    import com.google.gson.annotations.SerializedName \n\n    data class JournalerApiToken( \n        @SerializedName(\"id_token\") val token: String, \n        val expires: Long \n    ) \n```", "```kt\n    apply plugin: \"com.android.application\" \n    apply plugin: \"kotlin-android\" \n    apply plugin: \"kotlin-android-extensions\" \n    ... \n    dependencies { \n      ... \n      compile 'com.squareup.retrofit2:retrofit:2.3.0' \n      compile 'com.squareup.retrofit2:converter-gson:2.0.2' \n      compile 'com.squareup.okhttp3:okhttp:3.9.0' \n      compile 'com.squareup.okhttp3:logging-interceptor:3.9.0' \n   } \n```", "```kt\n    package com.journaler.api \n\n    import com.journaler.model.Note \n    import com.journaler.model.Todo \n    import retrofit2.Call \n    import retrofit2.http.* \n\n    interface JournalerBackendService { \n\n      @POST(\"user/authenticate\") \n      fun login( \n            @HeaderMap headers: Map<String, String>, \n            @Body payload: UserLoginRequest \n      ): Call<JournalerApiToken> \n\n      @GET(\"entity/note\") \n      fun getNotes( \n            @HeaderMap headers: Map<String, String> \n      ): Call<List<Note>> \n\n      @GET(\"entity/todo\") \n      fun getTodos( \n            @HeaderMap headers: Map<String, String> \n      ): Call<List<Todo>> \n\n      @PUT(\"entity/note\") \n      fun publishNotes( \n            @HeaderMap headers: Map<String, String>, \n            @Body payload: List<Note> \n      ): Call<Unit> \n\n      @PUT(\"entity/todo\") \n      fun publishTodos( \n            @HeaderMap headers: Map<String, String>, \n            @Body payload: List<Todo> \n      ): Call<Unit> \n\n      @DELETE(\"entity/note\") \n      fun removeNotes( \n            @HeaderMap headers: Map<String, String>, \n            @Body payload: List<Note> \n      ): Call<Unit> \n\n      @DELETE(\"entity/todo\") \n      fun removeTodos( \n            @HeaderMap headers: Map<String, String>, \n            @Body payload: List<Todo> \n      ): Call<Unit> \n\n    } \n```", "```kt\n    package com.journaler.api \n     object TokenManager { \n       var currentToken = JournalerApiToken(\"\", -1) \n     } \n```", "```kt\n    package com.journaler.api \n\n    object BackendServiceHeaderMap { \n\n     fun obtain(authorization: Boolean = false): Map<String, String> { \n        val map = mutableMapOf( \n                Pair(\"Accept\", \"*/*\"), \n                Pair(\"Content-Type\", \"application/json; charset=UTF-8\") \n        ) \n        if (authorization) { \n            map[\"Authorization\"] = \"Bearer\n             ${TokenManager.currentToken.token}\" \n        } \n        return map \n    } \n\n   } \n```", "```kt\n    package com.journaler.api \n\n    import okhttp3.OkHttpClient \n    import okhttp3.logging.HttpLoggingInterceptor \n    import retrofit2.Retrofit \n    import retrofit2.converter.gson.GsonConverterFactory \n    import java.util.concurrent.TimeUnit \n\n    object BackendServiceRetrofit { \n\n      fun obtain( \n            readTimeoutInSeconds: Long = 1, \n            connectTimeoutInSeconds: Long = 1 \n      ): Retrofit { \n        val loggingInterceptor = HttpLoggingInterceptor() \n        loggingInterceptor.level \n      = HttpLoggingInterceptor.Level.BODY \n        return Retrofit.Builder() \n                .baseUrl(\"http://127.0.0.1\") \n                .addConverterFactory(GsonConverterFactory.create()) \n                .client( \n                        OkHttpClient \n                                .Builder() \n                                .addInterceptor(loggingInterceptor) \n                                .readTimeout(readTimeoutInSeconds,\n                                TimeUnit.SECONDS) \n                                  .connectTimeout\n                                (connectTimeoutInSeconds,\n                                TimeUnit.SECONDS) \n                                .build() \n                ) \n                .build() \n     } \n\n    } \n```", "```kt\n    apply plugin: \"com.android.application\" \n    apply plugin: \"kotlin-android\" \n    apply plugin: \"kotlin-android-extensions\" \n    ... \n    dependencies { \n      ... \n      compile 'com.google.code.gson:gson:2.8.0' \n      compile 'com.github.salomonbrys.kotson:kotson:2.3.0' \n      ... \n    } \n```", "```kt\n    class DbHelper(dbName: String, val version: Int) :\n    SQLiteOpenHelper( \n      Journaler.ctx, dbName, null, version \n    ) { \n\n    companion object { \n        val ID: String = \"_id\" \n        val TABLE_TODOS = \"todos\" \n        val TABLE_NOTES = \"notes\" \n        val COLUMN_TITLE: String = \"title\" \n        val COLUMN_MESSAGE: String = \"message\" \n        val COLUMN_LOCATION: String = \"location\" \n        val COLUMN_SCHEDULED: String = \"scheduled\" \n    } \n    ... \n    private val createTableNotes =  \"\"\" \n                                    CREATE TABLE if not exists\n                                     $TABLE_NOTES \n                                    ( \n                                        $ID integer PRIMARY KEY\n                                        autoincrement, \n                                        $COLUMN_TITLE text, \n                                        $COLUMN_MESSAGE text, \n                                        $COLUMN_LOCATION text \n                                    ) \n                                    \"\"\" \n\n    private val createTableTodos =  \"\"\" \n                                    CREATE TABLE if not exists\n                                     $TABLE_TODOS \n                                    ( \n                                        $ID integer PRIMARY KEY\n                                         autoincrement, \n                                        $COLUMN_TITLE text, \n                                        $COLUMN_MESSAGE text, \n                                        $COLUMN_SCHEDULED integer, \n                                        $COLUMN_LOCATION text \n                                    ) \n                                    \"\"\" \n    ... \n   } \n```", "```kt\n    package com.journaler.database \n    ... \n    import com.google.gson.Gson \n    ... \n    import com.github.salomonbrys.kotson.* \n\n    object Db : Crud<DbModel> { \n      ... \n      private val gson = Gson() \n      ... \n      override fun insert(what: Collection<DbModel>): Boolean { \n        ... \n        what.forEach { \n            item -> \n            when (item) { \n                is Entry -> { \n                    ... \n                    values.put(DbHelper.COLUMN_LOCATION,\n                     gson.toJson(item.location)) \n                    ... \n            } \n        } \n        ... \n        return success \n    } \n    ... \n    override fun update(what: Collection<DbModel>): Boolean { \n        ... \n        what.forEach { \n            item -> \n            when (item) { \n                is Entry -> { \n                    ... \n                    values.put(DbHelper.COLUMN_LOCATION,\n                    gson.toJson(item.location)) \n                } \n       ... \n        return result \n    } \n    ... \n    override fun select(args: Pair<String, String>, clazz:  \n    KClass<DbModel>): List<DbModel> { \n        return select(listOf(args), clazz) \n    } \n\n    override fun select( \n        args: Collection<Pair<String, String>>, clazz: Kclass<DbModel> \n    ): List<DbModel> { \n        ... \n        if (clazz.simpleName == Note::class.simpleName) { \n            val result = mutableListOf<DbModel>() \n            val cursor = db.query( \n                ... \n            ) \n            while (cursor.moveToNext()) { \n                ... \n                val locationIdx =\n                cursor.getColumnIndexOrThrow(DbHelper.COLUMN_LOCATION) \n                val locationJson = cursor.getString(locationIdx) \n                val location = gson.fromJson<Location>(locationJson) \n                val note = Note(title, message, location) \n                note.id = id \n                result.add(note) \n            } \n            cursor.close() \n            return result \n        } \n        if (clazz.simpleName == Todo::class.simpleName) { \n                ... \n            ) \n            while (cursor.moveToNext()) { \n                ... \n                val locationIdx =\n                cursor.getColumnIndexOrThrow(DbHelper.COLUMN_LOCATION) \n                val locationJson = cursor.getString(locationIdx) \n                val location = gson.fromJson<Location>(locationJson) \n                ... \n                val todo = Todo(title, message, location, scheduledFor) \n                todo.id = id \n                result.add(todo) \n            } \n            cursor.close() \n            return result \n        } \n        db.close() \n        throw IllegalArgumentException(\"Unsupported entry type: \n        $clazz\") \n      } \n   }  \n```", "```kt\n        @POST(\"authenticate\") \n        // @POST(\"user/authenticate\") \n        fun login( \n            ... \n        ): Call<JournalerApiToken> \n```", "```kt\n        @GET(\"notes\") \n        // @GET(\"entity/note\") \n        fun getNotes( \n            ... \n        ): Call<List<Note>> \n```", "```kt\n        @GET(\"todos\") \n        // @GET(\"entity/todo\") \n       fun getTodos( \n            ... \n       ): Call<List<Todo>> \n```", "```kt\n    interface JournalerBackendService { \n      companion object { \n        fun obtain(): JournalerBackendService { \n            return BackendServiceRetrofit \n                    .obtain() \n                    .create(JournalerBackendService::class.java) \n        } \n     } \n      ... \n    } \n```", "```kt\n    /** \n    * Authenticates user synchronously, \n    * then executes async calls for notes and TODOs fetching. \n    * Pay attention on synchronously triggered call via execute() \n      method. \n    * Its asynchronous equivalent is: enqueue(). \n    */ \n    override fun synchronize() { \n        executor.execute { \n            Log.i(tag, \"Synchronizing data [ START ]\") \n            var headers = BackendServiceHeaderMap.obtain() \n            val service = JournalerBackendService.obtain() \n            val credentials = UserLoginRequest(\"username\", \"password\") \n            val tokenResponse = service \n                    .login(headers, credentials) \n                    .execute() \n            if (tokenResponse.isSuccessful) { \n                val token = tokenResponse.body() \n                token?.let { \n                    TokenManager.currentToken = token \n                    headers = BackendServiceHeaderMap.obtain(true) \n                    fetchNotes(service, headers) \n                    fetchTodos(service, headers) \n                } \n            } \n            Log.i(tag, \"Synchronizing data [ END ]\") \n        } \n    } \n\n    /** \n    * Fetches notes asynchronously. \n    * Pay attention on enqueue() method \n    */ \n    private fun fetchNotes( \n            service: JournalerBackendService, headers: Map<String,  \n    String> \n    ) { \n        service \n            .getNotes(headers) \n            .enqueue( \n            object : Callback<List<Note>> { \n              verride fun onResponse( \n               call: Call<List<Note>>?, response: Response<List<Note>>? \n                            ) { \n                                response?.let { \n                                    if (response.isSuccessful) { \n                                        val notes = response.body() \n                                        notes?.let { \n                                            Db.insert(notes) \n                                        } \n                                    } \n                                } \n                            } \n\n                            override fun onFailure(call: \n                            Call<List<Note>>?, t: Throwable?) { \n                                Log.e(tag, \"We couldn't fetch notes.\") \n                            } \n                        } \n                ) \n     } \n\n     /** \n     * Fetches TODOs asynchronously. \n     * Pay attention on enqueue() method \n     */ \n     private fun fetchTodos( \n            service: JournalerBackendService, headers: Map<String,  \n      String> \n     ) { \n        service \n                .getTodos(headers) \n                .enqueue( \n                        object : Callback<List<Todo>> { \n                            override fun onResponse( \n                                    call: Call<List<Todo>>?, response:\n         Response<List<Todo>>? \n                            ) { \n                                response?.let { \n                                    if (response.isSuccessful) { \n                                        val todos = response.body() \n                                        todos?.let { \n                                            Db.insert(todos) \n                                        } \n                                    } \n                                } \n                            } \n\n                            override fun onFailure(call:\n                            Call<List<Todo>>?, t: Throwable?) { \n                                Log.e(tag, \"We couldn't fetch notes.\") \n                            } \n                        } \n                 ) \n     } \n```", "```kt\n D/OkHttp: --> POST \n http://static.milosvasic.net/jsons/journaler/authenticate \n        D/OkHttp: Content-Type: application/json; charset=UTF-8 \n        D/OkHttp: Content-Length: 45 \n        D/OkHttp: Accept: */* \n        D/OkHttp: {\"password\":\"password\",\"username\":\"username\"} \n        D/OkHttp: --> END POST (45-byte body) \n```", "```kt\n D/OkHttp: <-- 200 OK \n http://static.milosvasic.net/jsons/journaler/\n authenticate/ (302ms) \n       D/OkHttp: Date: Sat, 23 Sep 2017 15:46:27 GMT \n       D/OkHttp: Server: Apache \n       D/OkHttp: Keep-Alive: timeout=5, max=99 \n       D/OkHttp: Connection: Keep-Alive \n       D/OkHttp: Transfer-Encoding: chunked \n       D/OkHttp: Content-Type: text/html \n       D/OkHttp: { \n       D/OkHttp:   \"id_token\": \"stub_token_1234567\", \n       D/OkHttp:   \"expires\": 10000 \n       D/OkHttp: } \n       D/OkHttp: <-- END HTTP (58-byte body) \n```", "```kt\n D/OkHttp: --> GET \n http://static.milosvasic.net/jsons/journaler/notes \n        D/OkHttp: Accept: */* \n        D/OkHttp: Authorization: Bearer stub_token_1234567 \n        D/OkHttp: --> END GET \n```", "```kt\n D/OkHttp: <-- 200 OK \n http://static.milosvasic.net/jsons/journaler/notes/ (95ms) \n        D/OkHttp: Date: Sat, 23 Sep 2017 15:46:28 GMT \n        D/OkHttp: Server: Apache \n        D/OkHttp: Keep-Alive: timeout=5, max=97 \n        D/OkHttp: Connection: Keep-Alive \n        D/OkHttp: Transfer-Encoding: chunked \n        D/OkHttp: Content-Type: text/html \n        D/OkHttp: [ \n        D/OkHttp:   { \n        D/OkHttp:     \"title\": \"Test note 1\", \n        D/OkHttp:     \"message\": \"Test message 1\", \n        D/OkHttp:     \"location\": { \n        D/OkHttp:       \"latitude\": 10000, \n        D/OkHttp:       \"longitude\": 10000 \n        D/OkHttp:     } \n        D/OkHttp:   }, \n        D/OkHttp:   { \n        D/OkHttp:     \"title\": \"Test note 2\", \n        D/OkHttp:     \"message\": \"Test message 2\", \n        D/OkHttp:     \"location\": { \n        D/OkHttp:       \"latitude\": 10000, \n        D/OkHttp:       \"longitude\": 10000 \n        D/OkHttp:     } \n        D/OkHttp:   }, \n        D/OkHttp:   { \n        D/OkHttp:     \"title\": \"Test note 3\", \n        D/OkHttp:     \"message\": \"Test message 3\", \n        D/OkHttp:     \"location\": { \n        D/OkHttp:       \"latitude\": 10000, \n        D/OkHttp:       \"longitude\": 10000 \n        D/OkHttp:     } \n        D/OkHttp:   } \n        D/OkHttp: ] \n        D/OkHttp: <-- END HTTP (434-byte body) \n```", "```kt\n D/OkHttp: --> GET\n http://static.milosvasic.net/jsons/journaler/todos \n        D/OkHttp: Accept: */* \n        D/OkHttp: Authorization: Bearer stub_token_1234567 \n        D/OkHttp: --> END GET \n```", "```kt\n D/OkHttp: <-- 200 OK\n http://static.milosvasic.net/jsons/journaler/todos/ (140ms) \n       D/OkHttp: Date: Sat, 23 Sep 2017 15:46:28 GMT \n       D/OkHttp: Server: Apache \n       D/OkHttp: Keep-Alive: timeout=5, max=99 \n       D/OkHttp: Connection: Keep-Alive \n       D/OkHttp: Transfer-Encoding: chunked \n       D/OkHttp: Content-Type: text/html \n       D/OkHttp: [ \n       D/OkHttp:   { \n       D/OkHttp:     \"title\": \"Test todo 1\", \n       D/OkHttp:     \"message\": \"Test message 1\", \n       D/OkHttp:     \"location\": { \n       D/OkHttp:       \"latitude\": 10000, \n       D/OkHttp:       \"longitude\": 10000 \n       D/OkHttp:     }, \n       D/OkHttp:     \"scheduledFor\": 10000 \n       D/OkHttp:   }, \n       D/OkHttp:   { \n       D/OkHttp:     \"title\": \"Test todo 2\", \n       D/OkHttp:     \"message\": \"Test message 2\", \n       D/OkHttp:     \"location\": { \n       D/OkHttp:       \"latitude\": 10000, \n       D/OkHttp:       \"longitude\": 10000 \n       D/OkHttp:     }, \n       D/OkHttp:     \"scheduledFor\": 10000 \n       D/OkHttp:   }, \n       D/OkHttp:   { \n       D/OkHttp:     \"title\": \"Test todo 3\", \n       D/OkHttp:     \"message\": \"Test message 3\", \n       D/OkHttp:     \"location\": { \n       D/OkHttp:       \"latitude\": 10000, \n       D/OkHttp:       \"longitude\": 10000 \n       D/OkHttp:     }, \n       D/OkHttp:     \"scheduledFor\": 10000 \n       D/OkHttp:   } \n       D/OkHttp: ] \n       D/OkHttp: <-- END HTTP (515-byte body) \n```", "```kt\n    package com.journaler.provider \n\n    import android.content.* \n    import android.database.Cursor \n    import android.net.Uri \n    import com.journaler.database.DbHelper \n    import android.content.ContentUris \n    import android.database.SQLException \n    import android.database.sqlite.SQLiteDatabase \n    import android.database.sqlite.SQLiteQueryBuilder \n    import android.text.TextUtils \n\n    class JournalerProvider : ContentProvider() { \n\n      private val version = 1 \n      private val name = \"journaler\" \n      private val db: SQLiteDatabase by lazy { \n        DbHelper(name, version).writableDatabase \n    } \n\n```", "```kt\n     companion object { \n        private val dataTypeNote = \"note\" \n        private val dataTypeNotes = \"notes\" \n        private val dataTypeTodo = \"todo\" \n        private val dataTypeTodos = \"todos\" \n        val AUTHORITY = \"com.journaler.provider\" \n        val URL_NOTE = \"content://$AUTHORITY/$dataTypeNote\" \n        val URL_TODO = \"content://$AUTHORITY/$dataTypeTodo\" \n        val URL_NOTES = \"content://$AUTHORITY/$dataTypeNotes\" \n        val URL_TODOS = \"content://$AUTHORITY/$dataTypeTodos\" \n        private val matcher = UriMatcher(UriMatcher.NO_MATCH) \n        private val NOTE_ALL = 1 \n        private val NOTE_ITEM = 2 \n        private val TODO_ALL = 3 \n        private val TODO_ITEM = 4 \n    } \n\n```", "```kt\n    /** \n     * We register uri paths in the following format: \n     * \n     * <prefix>://<authority>/<data_type>/<id> \n     * <prefix> - This is always set to content:// \n     * <authority> - Name for the content provider \n     * <data_type> - The type of data we provide in this Uri \n     * <id> - Record ID. \n     */ \n    init { \n        /** \n         * The calls to addURI() go here, \n         * for all of the content URI patterns that the provider should\n          recognize. \n         * \n         * First: \n         * \n         * Sets the integer value for multiple rows in notes (TODOs) to \n         1\\. \n         * Notice that no wildcard is used in the path. \n         * \n         * Second: \n         * \n         * Sets the code for a single row to 2\\. In this case, the \"#\"\n         wildcard is \n         * used. \"content://com.journaler.provider/note/3\" matches, but \n         * \"content://com.journaler.provider/note doesn't. \n         * \n         * The same applies for TODOs. \n         * \n         * addUri() params: \n         * \n         * authority    - String: the authority to match \n         * \n         * path         - String: the path to match. \n         *              * may be used as a wild card for any text, \n         *              and # may be used as a wild card for numbers. \n         * \n         * code              - int: the code that is returned when a\n        URI \n         *              is matched against the given components. \n         */ \n        matcher.addURI(AUTHORITY, dataTypeNote, NOTE_ALL) \n        matcher.addURI(AUTHORITY, \"$dataTypeNotes/#\", NOTE_ITEM) \n        matcher.addURI(AUTHORITY, dataTypeTodo, TODO_ALL) \n        matcher.addURI(AUTHORITY, \"$dataTypeTodos/#\", TODO_ITEM) \n    } \n```", "```kt\n     /** \n     * True - if the provider was successfully loaded \n     */ \n    override fun onCreate() = true \n```", "```kt\n     override fun insert(uri: Uri?, values: ContentValues?): Uri { \n        uri?.let { \n            values?.let { \n                db.beginTransaction() \n                val (url, table) = getParameters(uri) \n                if (!TextUtils.isEmpty(table)) { \n                    val inserted = db.insert(table, null, values) \n                    val success = inserted > 0 \n                    if (success) { \n                        db.setTransactionSuccessful() \n                    } \n                    db.endTransaction() \n                    if (success) { \n                        val resultUrl = ContentUris.withAppendedId\n                        (Uri.parse(url), inserted) \n                        context.contentResolver.notifyChange(resultUrl,\n                        null) \n                        return resultUrl \n                    } \n                } else { \n                    throw SQLException(\"Insert failed, no table for\n                    uri: \" + uri) \n                } \n            } \n        } \n        throw SQLException(\"Insert failed: \" + uri) \n    } \n```", "```kt\n     override fun update( \n            uri: Uri?, \n            values: ContentValues?, \n            where: String?, \n            whereArgs: Array<out String>? \n    ): Int { \n        uri?.let { \n            values?.let { \n                db.beginTransaction() \n                val (_, table) = getParameters(uri) \n                if (!TextUtils.isEmpty(table)) { \n                    val updated = db.update(table, values, where,\n                     whereArgs) \n                    val success = updated > 0 \n                    if (success) { \n                        db.setTransactionSuccessful() \n                    } \n                    db.endTransaction() \n                    if (success) { \n                        context.contentResolver.notifyChange(uri, null) \n                        return updated \n                    } \n                } else { \n                    throw SQLException(\"Update failed, no table for\n                     uri: \" + uri) \n                } \n            } \n        } \n        throw SQLException(\"Update failed: \" + uri) \n    } \n```", "```kt\n    override fun delete( \n            uri: Uri?, \n            selection: String?, \n            selectionArgs: Array<out String>? \n    ): Int { \n        uri?.let { \n            db.beginTransaction() \n            val (_, table) = getParameters(uri) \n            if (!TextUtils.isEmpty(table)) { \n                val count = db.delete(table, selection, selectionArgs) \n                val success = count > 0 \n                if (success) { \n                    db.setTransactionSuccessful() \n                } \n                db.endTransaction() \n                if (success) { \n                    context.contentResolver.notifyChange(uri, null) \n                    return count \n                } \n            } else { \n                throw SQLException(\"Delete failed, no table for uri: \"\n               + uri) \n            } \n        } \n        throw SQLException(\"Delete failed: \" + uri) \n    } \n```", "```kt\n     override fun query( \n            uri: Uri?, \n            projection: Array<out String>?, \n            selection: String?, \n            selectionArgs: Array<out String>?, \n            sortOrder: String? \n     ): Cursor { \n        uri?.let { \n            val stb = SQLiteQueryBuilder() \n            val (_, table) = getParameters(uri) \n            stb.tables = table \n            stb.setProjectionMap(mutableMapOf<String, String>()) \n            val cursor = stb.query(db, projection, selection,\n             selectionArgs, null, null, null) \n            // register to watch a content URI for changes \n            cursor.setNotificationUri(context.contentResolver, uri) \n            return cursor \n        } \n        throw SQLException(\"Query failed: \" + uri) \n    } \n\n    /** \n     * Return the MIME type corresponding to a content URI. \n     */ \n    override fun getType(p0: Uri?): String = when (matcher.match(p0)) { \n        NOTE_ALL -> { \n            \"${ContentResolver.\n            CURSOR_DIR_BASE_TYPE}/vnd.com.journaler.note.items\" \n        } \n        NOTE_ITEM -> { \n            \"${ContentResolver.\n             CURSOR_ITEM_BASE_TYPE}/vnd.com.journaler.note.item\" \n        } \n        TODO_ALL -> { \n            \"${ContentResolver.\n             CURSOR_DIR_BASE_TYPE}/vnd.com.journaler.todo.items\" \n        } \n        TODO_ITEM -> { \n            \"${ContentResolver.\n            CURSOR_ITEM_BASE_TYPE}/vnd.com.journaler.todo.item\" \n        } \n        else -> throw IllegalArgumentException\n        (\"Unsupported Uri [ $p0 ]\") \n    } \n```", "```kt\n     private fun getParameters(uri: Uri): Pair<String, String> { \n        if (uri.toString().startsWith(URL_NOTE)) { \n            return Pair(URL_NOTE, DbHelper.TABLE_NOTES) \n        } \n        if (uri.toString().startsWith(URL_NOTES)) { \n            return Pair(URL_NOTES, DbHelper.TABLE_NOTES) \n        } \n        if (uri.toString().startsWith(URL_TODO)) { \n            return Pair(URL_TODO, DbHelper.TABLE_TODOS) \n        } \n        if (uri.toString().startsWith(URL_TODOS)) { \n            return Pair(URL_TODOS, DbHelper.TABLE_TODOS) \n        } \n        return Pair(\"\", \"\") \n       } \n\n     }  \n```", "```kt\n    <manifest xmlns:android=\n    \"http://schemas.android.com/apk/res/android\" \n    package=\"com.journaler\"> \n    ... \n      <application \n        ... \n      > \n        ... \n        <provider \n            android:exported=\"true\" \n            android:name=\"com.journaler.provider.JournalerProvider\" \n            android:authorities=\"com.journaler.provider\" /> \n        ... \n     </application> \n    ... \n    </manifest> \n```", "```kt\n    companion object { \n        val BROADCAST_ACTION = \"com.journaler.broadcast.crud\" \n        val BROADCAST_EXTRAS_KEY_CRUD_OPERATION_RESULT = \"crud_result\" \n   }  \n```", "```kt\n    package com.journaler.database \n\n    import android.content.ContentValues \n    import android.location.Location \n    import android.net.Uri \n    import android.util.Log \n    import com.github.salomonbrys.kotson.fromJson \n    import com.google.gson.Gson \n    import com.journaler.Journaler \n    import com.journaler.model.* \n    import com.journaler.provider.JournalerProvider \n\n    object Content { \n\n      private val gson = Gson() \n      private val tag = \"Content\" \n\n      val NOTE = object : Crud<Note> { ... \n\n```", "```kt\n\n     ... \n     override fun insert(what: Note): Long { \n       val inserted = insert(listOf(what)) \n       if (!inserted.isEmpty()) return inserted[0] \n         return 0 \n     } \n\n     override fun insert(what: Collection<Note>): List<Long> { \n        val ids = mutableListOf<Long>() \n        what.forEach { item -> \n           val values = ContentValues() \n           values.put(DbHelper.COLUMN_TITLE, item.title) \n           values.put(DbHelper.COLUMN_MESSAGE, item.message) \n           values.put(DbHelper.COLUMN_LOCATION,\n           gson.toJson(item.location)) \n           val uri = Uri.parse(JournalerProvider.URL_NOTE) \n           val ctx = Journaler.ctx \n           ctx?.let { \n             val result = ctx.contentResolver.insert(uri, values) \n             result?.let { \n                 try { \n                      ids.add(result.lastPathSegment.toLong()) \n                  } catch (e: Exception) { \n                  Log.e(tag, \"Error: $e\") \n                } \n             } \n           } \n         } \n         return ids \n        } ... \n```", "```kt\n    .. \n    override fun update(what: Note) = update(listOf(what)) \n\n    override fun update(what: Collection<Note>): Int { \n      var count = 0 \n      what.forEach { item -> \n          val values = ContentValues() \n          values.put(DbHelper.COLUMN_TITLE, item.title) \n          values.put(DbHelper.COLUMN_MESSAGE, item.message) \n          values.put(DbHelper.COLUMN_LOCATION,\n          gson.toJson(item.location)) \n          val uri = Uri.parse(JournalerProvider.URL_NOTE) \n          val ctx = Journaler.ctx \n          ctx?.let { \n            count += ctx.contentResolver.update( \n              uri, values, \"_id = ?\", arrayOf(item.id.toString()) \n            ) \n          } \n         } \n         return count \n        } ... \n```", "```kt\n   ... \n   override fun delete(what: Note): Int = delete(listOf(what)) \n\n   override fun delete(what: Collection<Note>): Int { \n     var count = 0 \n     what.forEach { item -> \n       val uri = Uri.parse(JournalerProvider.URL_NOTE) \n       val ctx = Journaler.ctx \n       ctx?.let { \n         count += ctx.contentResolver.delete( \n         uri, \"_id = ?\", arrayOf(item.id.toString()) \n       ) \n     } \n   } \n   return count \n  } ...  \n```", "```kt\n     ...  \n     override fun select(args: Pair<String, String> \n      ): List<Note> = select(listOf(args)) \n\n     override fun select(args: Collection<Pair<String, String>>):  \n     List<Note> { \n            val items = mutableListOf<Note>() \n            val selection = StringBuilder() \n            val selectionArgs = mutableListOf<String>() \n            args.forEach { arg -> \n                selection.append(\"${arg.first} == ?\") \n                selectionArgs.add(arg.second) \n            } \n            val ctx = Journaler.ctx \n            ctx?.let { \n                val uri = Uri.parse(JournalerProvider.URL_NOTES) \n                val cursor = ctx.contentResolver.query( \n                        uri, null, selection.toString(),\n                  selectionArgs.toTypedArray(), null \n                ) \n                while (cursor.moveToNext()) { \n                    val id = cursor.getLong\n                    (cursor.getColumnIndexOrThrow(DbHelper.ID)) \n                    val titleIdx = cursor.getColumnIndexOrThrow\n                    (DbHelper.COLUMN_TITLE) \n                    val title = cursor.getString(titleIdx) \n                    val messageIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_MESSAGE) \n                    val message = cursor.getString(messageIdx) \n                    val locationIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_LOCATION) \n                    val locationJson = cursor.getString(locationIdx) \n                    val location = gson.fromJson<Location>\n                    (locationJson) \n                    val note = Note(title, message, location) \n                    note.id = id \n                    items.add(note) \n                } \n                cursor.close() \n                return items \n            } \n            return items \n        } \n\n        override fun selectAll(): List<Note> { \n            val items = mutableListOf<Note>() \n            val ctx = Journaler.ctx \n            ctx?.let { \n                val uri = Uri.parse(JournalerProvider.URL_NOTES) \n                val cursor = ctx.contentResolver.query( \n                        uri, null, null, null, null \n                ) \n                while (cursor.moveToNext()) { \n                    val id = cursor.getLong\n                    (cursor.getColumnIndexOrThrow(DbHelper.ID)) \n                    val titleIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_TITLE) \n                    val title = cursor.getString(titleIdx) \n                    val messageIdx = cursor.getColumnIndexOrThrow\n                    (DbHelper.COLUMN_MESSAGE) \n                    val message = cursor.getString(messageIdx) \n                    val locationIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_LOCATION) \n                    val locationJson = cursor.getString(locationIdx) \n                    val location = gson.fromJson<Location>\n                  (locationJson) \n                    val note = Note(title, message, location) \n                    note.id = id \n                    items.add(note) \n                } \n                cursor.close() \n            } \n            return items \n        } \n    }  \n```", "```kt\n     ... \n     val TODO = object : Crud<Todo> { \n        override fun insert(what: Todo): Long { \n            val inserted = insert(listOf(what)) \n            if (!inserted.isEmpty()) return inserted[0] \n            return 0 \n        } \n\n        override fun insert(what: Collection<Todo>): List<Long> { \n            val ids = mutableListOf<Long>() \n            what.forEach { item -> \n                val values = ContentValues() \n                values.put(DbHelper.COLUMN_TITLE, item.title) \n                values.put(DbHelper.COLUMN_MESSAGE, item.message) \n                values.put(DbHelper.COLUMN_LOCATION,\n                gson.toJson(item.location)) \n                val uri = Uri.parse(JournalerProvider.URL_TODO) \n                values.put(DbHelper.COLUMN_SCHEDULED,   \n                item.scheduledFor) \n                val ctx = Journaler.ctx \n                ctx?.let { \n                    val result = ctx.contentResolver.insert(uri, \n                    values) \n                    result?.let { \n                        try { \n                            ids.add(result.lastPathSegment.toLong()) \n                        } catch (e: Exception) { \n                            Log.e(tag, \"Error: $e\") \n                        } \n                    } \n                } \n            } \n            return ids \n        } ... \n```", "```kt\n     ... \n     override fun update(what: Todo) = update(listOf(what)) \n\n     override fun update(what: Collection<Todo>): Int { \n        var count = 0 \n        what.forEach { item -> \n                val values = ContentValues() \n                values.put(DbHelper.COLUMN_TITLE, item.title) \n                values.put(DbHelper.COLUMN_MESSAGE, item.message) \n                values.put(DbHelper.COLUMN_LOCATION,\n                gson.toJson(item.location)) \n                val uri = Uri.parse(JournalerProvider.URL_TODO) \n                values.put(DbHelper.COLUMN_SCHEDULED, \n                item.scheduledFor) \n                val ctx = Journaler.ctx \n                ctx?.let { \n                    count += ctx.contentResolver.update( \n                            uri, values, \"_id = ?\",\n                           arrayOf(item.id.toString()) \n                    ) \n                } \n            } \n            return count \n        } ... \n```", "```kt\n     ... \n     override fun delete(what: Todo): Int = delete(listOf(what)) \n\n     override fun delete(what: Collection<Todo>): Int { \n            var count = 0 \n            what.forEach { item -> \n                val uri = Uri.parse(JournalerProvider.URL_TODO) \n                val ctx = Journaler.ctx \n                ctx?.let { \n                    count += ctx.contentResolver.delete( \n                            uri, \"_id = ?\", arrayOf(item.id.toString()) \n                    ) \n                } \n            } \n            return count \n        } \n```", "```kt\n         ... \n        override fun select(args: Pair<String, String>): List<Todo> =  \n        select(listOf(args)) \n\n        override fun select(args: Collection<Pair<String, String>>):\n         List<Todo> { \n            val items = mutableListOf<Todo>() \n            val selection = StringBuilder() \n            val selectionArgs = mutableListOf<String>() \n            args.forEach { arg -> \n                selection.append(\"${arg.first} == ?\") \n                selectionArgs.add(arg.second) \n            } \n            val ctx = Journaler.ctx \n            ctx?.let { \n                val uri = Uri.parse(JournalerProvider.URL_TODOS) \n                val cursor = ctx.contentResolver.query( \n                        uri, null, selection.toString(),\n                        selectionArgs.toTypedArray(), null \n                ) \n                while (cursor.moveToNext()) { \n                    val id = cursor.getLong\n                   (cursor.getColumnIndexOrThrow(DbHelper.ID)) \n                    val titleIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_TITLE) \n                    val \n                    title = \n                    cursor.getString(titleIdx) \n                    val messageIdx = cursor.getColumnIndexOrThrow\n                    (DbHelper.COLUMN_MESSAGE) \n                    val message = cursor.getString(messageIdx) \n                    val locationIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_LOCATION) \n                    val locationJson = cursor.getString(locationIdx) \n                    val location = gson.fromJson<Location>\n                    (locationJson) \n                    val scheduledForIdx = cursor.getColumnIndexOrThrow( \n                        DbHelper.COLUMN_SCHEDULED \n                    ) \n                    val scheduledFor = cursor.getLong(scheduledForIdx) \n                    val todo = Todo(title, message, location,\n                    scheduledFor) \n                    todo.id = id \n                    items.add(todo) \n                } \n                cursor.close() \n            } \n            return items \n        } \n\n        override fun selectAll(): List<Todo> { \n            val items = mutableListOf<Todo>() \n            val ctx = Journaler.ctx \n            ctx?.let { \n                val uri = Uri.parse(JournalerProvider.URL_TODOS) \n                val cursor = ctx.contentResolver.query( \n                        uri, null, null, null, null \n                ) \n                while (cursor.moveToNext()) { \n                    val id = cursor.getLong\n                   (cursor.getColumnIndexOrThrow(DbHelper.ID)) \n                    val titleIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_TITLE) \n                    val title = cursor.getString(titleIdx) \n                    val messageIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_MESSAGE) \n                    val message = cursor.getString(messageIdx) \n                    val locationIdx = cursor.getColumnIndexOrThrow\n                   (DbHelper.COLUMN_LOCATION) \n                    val locationJson = cursor.getString(locationIdx) \n                    val location = gson.fromJson<Location>\n                    (locationJson) \n                    val scheduledForIdx = cursor.getColumnIndexOrThrow( \n                        DbHelper.COLUMN_SCHEDULED \n                    ) \n                    val scheduledFor = cursor.getLong(scheduledForIdx) \n                    val todo = Todo\n                    (title, message, location, scheduledFor) \n                    todo.id = id \n                    items.add(todo) \n                } \n                cursor.close() \n            } \n            return items \n         } \n      } \n   }  \n```", "```kt\n    package com.journaler.content_provider_client \n\n    import android.content.ContentValues \n    import android.location.Location \n    import android.net.Uri \n    import android.os.AsyncTask \n    import android.os.Bundle \n    import android.support.v7.app.AppCompatActivity \n    import android.util.Log \n    import com.github.salomonbrys.kotson.fromJson \n    import com.google.gson.Gson \n    import kotlinx.android.synthetic.main.activity_main.* \n\n   class MainActivity : AppCompatActivity() { \n\n     private val gson = Gson() \n     private val tag = \"Main activity\" \n\n     override fun onCreate(savedInstanceState: Bundle?) { \n        super.onCreate(savedInstanceState) \n        setContentView(R.layout.activity_main) \n\n        select.setOnClickListener { \n            val task = object : AsyncTask<Unit, Unit, Unit>() { \n                override fun doInBackground(vararg p0: Unit?) { \n                    val selection = StringBuilder() \n                    val selectionArgs = mutableListOf<String>() \n                    val uri = Uri.parse\n                    (\"content://com.journaler.provider/notes\") \n                    val cursor = contentResolver.query( \n                            uri, null, selection.toString(),\n                            selectionArgs.toTypedArray(), null \n                    ) \n                    while (cursor.moveToNext()) { \n                        val id = cursor.getLong\n                        (cursor.getColumnIndexOrThrow(\"_id\")) \n                        val titleIdx =  cursor.\n                        getColumnIndexOrThrow(\"title\") \n                        val title = cursor.getString(titleIdx) \n                        val messageIdx = cursor.\n                        getColumnIndexOrThrow(\"message\") \n                        val message = cursor.getString(messageIdx) \n                        val locationIdx = cursor.\n                        getColumnIndexOrThrow(\"location\") \n                        val locationJson = cursor.\n                        getString(locationIdx) \n                        val location = \n                        gson.fromJson<Location>(locationJson) \n                        Log.v( \n                                tag, \n                                \"Note retrieved via content provider [\n                                 $id, $title, $message, $location ]\" \n                        ) \n                    } \n                    cursor.close() \n                } \n            } \n            task.execute() \n        } \n\n        insert.setOnClickListener { \n            val task = object : AsyncTask<Unit, Unit, Unit>() { \n                override fun doInBackground(vararg p0: Unit?) { \n                    for (x in 0..5) { \n                        val uri = Uri.parse\n                       (\"content://com.journaler.provider/note\") \n                        val values = ContentValues() \n                        values.put(\"title\", \"Title $x\") \n                        values.put(\"message\", \"Message $x\") \n                        val location = Location(\"stub location $x\") \n                        location.latitude = x.toDouble() \n                        location.longitude = x.toDouble() \n                        values.put(\"location\", gson.toJson(location)) \n                        if (contentResolver.insert(uri, values) !=\n                        null) { \n                            Log.v( \n                                    tag, \n                                    \"Note inserted [ $x ]\" \n                            ) \n                        } else { \n                            Log.e( \n                                    tag, \n                                    \"Note not inserted [ $x ]\" \n                            ) \n                        } \n                    } \n                } \n            } \n            task.execute() \n        } \n\n        update.setOnClickListener { \n            val task = object : AsyncTask<Unit, Unit, Unit>() { \n                override fun doInBackground(vararg p0: Unit?) { \n                    val selection = StringBuilder() \n                    val selectionArgs = mutableListOf<String>() \n                    val uri =\n                    Uri.parse(\"content://com.journaler.provider/notes\") \n                    val cursor = contentResolver.query( \n                            uri, null, selection.toString(),\n                           selectionArgs.toTypedArray(), null \n                    ) \n                    while (cursor.moveToNext()) { \n                        val values = ContentValues() \n                        val id = cursor.getLong\n                        (cursor.getColumnIndexOrThrow(\"_id\")) \n                        val titleIdx =\n                        cursor.getColumnIndexOrThrow(\"title\") \n                        val title = \"${cursor.getString(titleIdx)} upd:\n                        ${System.currentTimeMillis()}\" \n                        val messageIdx =\n                       cursor.getColumnIndexOrThrow(\"message\") \n                        val message = \n                       \"${cursor.getString(messageIdx)} upd:\n                       ${System.currentTimeMillis()}\" \n                        val locationIdx = \n                       cursor.getColumnIndexOrThrow(\"location\") \n                        val locationJson =\n                       cursor.getString(locationIdx) \n                        values.put(\"_id\", id) \n                        values.put(\"title\", title) \n                        values.put(\"message\", message) \n                        values.put(\"location\", locationJson) \n\n                        val updated = contentResolver.update( \n                                uri, values, \"_id = ?\",\n                                arrayOf(id.toString()) \n                        ) \n                        if (updated > 0) { \n                            Log.v( \n                                    tag, \n                                    \"Notes updated [ $updated ]\" \n                            ) \n                        } else { \n                            Log.e( \n                                    tag, \n                                    \"Notes not updated\" \n                            ) \n                        } \n                    } \n                    cursor.close() \n                } \n            } \n            task.execute() \n        } \n\n        delete.setOnClickListener { \n            val task = object : AsyncTask<Unit, Unit, Unit>() { \n                override fun doInBackground(vararg p0: Unit?) { \n                    val selection = StringBuilder() \n                    val selectionArgs = mutableListOf<String>() \n                    val uri = Uri.parse\n                   (\"content://com.journaler.provider/notes\") \n                    val cursor = contentResolver.query( \n                            uri, null, selection.toString(),\n                            selectionArgs.toTypedArray(), null \n                    ) \n                    while (cursor.moveToNext()) { \n                        val id = cursor.getLong\n                        (cursor.getColumnIndexOrThrow(\"_id\")) \n                        val deleted = contentResolver.delete( \n                                uri, \"_id = ?\", arrayOf(id.toString()) \n                        ) \n                        if (deleted > 0) { \n                            Log.v( \n                                    tag, \n                                    \"Notes deleted [ $deleted ]\" \n                            ) \n                        } else { \n                            Log.e( \n                                    tag, \n                                    \"Notes not deleted\" \n                            ) \n                        } \n                    } \n                    cursor.close() \n                } \n\n           } \n            task.execute() \n        } \n      } \n   } \n```", "```kt\n    package com.journaler.adapter \n\n    import android.annotation.SuppressLint \n    import android.content.Context \n    import android.view.LayoutInflater \n    import android.view.View \n    import android.view.ViewGroup \n    import android.widget.BaseAdapter \n    import android.widget.TextView \n    import com.journaler.R \n    import com.journaler.model.Entry \n\n    class EntryAdapter( \n        private val ctx: Context, \n        private val items: List<Entry> \n    ) : BaseAdapter() { \n\n    @SuppressLint(\"InflateParams\", \"ViewHolder\") \n    override fun getView(p0: Int, p1: View?, p2: ViewGroup?): View { \n        p1?.let { \n            return p1 \n        } \n        val inflater = LayoutInflater.from(ctx) \n        val view = inflater.inflate(R.layout.adapter_entry, null) \n        val label = view.findViewById<TextView>(R.id.title) \n        label.text = items[p0].title \n        return view \n    } \n\n    override fun getItem(p0: Int): Entry = items[p0] \n    override fun getItemId(p0: Int): Long = items[p0].id \n    override fun getCount(): Int = items.size \n   } \n```", "```kt\n    override fun onResume() { \n        super.onResume() \n        ... \n        executor.execute { \n            val notes = Content.NOTE.selectAll() \n            val adapter = EntryAdapter(activity, notes) \n            activity.runOnUiThread { \n                view?.findViewById<ListView>(R.id.items)?.adapter =\n             adapter \n            } \n        } \n    } \n```", "```kt\n    class EntryAdapter(ctx: Context, crsr: Cursor) : CursorAdapter(ctx,\n    crsr) { \n\n    override fun newView(p0: Context?, p1: Cursor?, p2: ViewGroup?):\n    View { \n        val inflater = LayoutInflater.from(p0) \n        return inflater.inflate(R.layout.adapter_entry, null) \n    } \n\n    override fun bindView(p0: View?, p1: Context?, p2: Cursor?) { \n        p0?.let { \n            val label = p0.findViewById<TextView>(R.id.title) \n            label.text = cursor.getString( \n                cursor.getColumnIndexOrThrow(DbHelper.COLUMN_TITLE) \n            ) \n        } \n    } \n\n   } \n```", "```kt\n    class ItemsFragment : BaseFragment() { \n      ... \n      private var adapter: EntryAdapter? = null \n      ... \n      private val loaderCallback = object :\n      LoaderManager.LoaderCallbacks<Cursor> { \n        override fun onLoadFinished(loader: Loader<Cursor>?, cursor:\n        Cursor?) { \n            cursor?.let { \n                if (adapter == null) { \n                    adapter = EntryAdapter(activity, cursor) \n                    items.adapter = adapter \n                } else { \n                    adapter?.swapCursor(cursor) \n                } \n            } \n        } \n\n        override fun onLoaderReset(loader: Loader<Cursor>?) { \n            adapter?.swapCursor(null) \n        } \n\n        override fun onCreateLoader(id: Int, args: Bundle?):\n        Loader<Cursor> { \n            return CursorLoader( \n                    activity, \n                    Uri.parse(JournalerProvider.URL_NOTES), \n                    null, \n                    null, \n                    null, \n                    null \n            ) \n        } \n    } \n\n    override fun onCreate(savedInstanceState: Bundle?) { \n        super.onCreate(savedInstanceState) \n        loaderManager.initLoader( \n                0, null, loaderCallback \n        ) \n    } \n\n    override fun onResume() { \n        super.onResume() \n        loaderManager.restartLoader(0, null, loaderCallback) \n\n        val btn = view?.findViewById\n       <FloatingActionButton>(R.id.new_item) \n        btn?.let { \n            animate(btn, false) \n        } \n    } \n   }  \n```", "```kt\n     android { \n       .... \n       dataBinding { \n        enabled = true \n       } \n     } \n     ... \n     dependencies { \n      ... \n      kapt 'com.android.databinding:compiler:2.3.1' \n    } \n    ...  \n```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?> \n    <layout > \n\n    <data> \n        <variable \n            name=\"note\" \n            type=\"com.journaler.model.Note\" /> \n    </data> \n\n    <LinearLayout \n        android:layout_width=\"match_parent\" \n        android:layout_height=\"match_parent\" \n        android:orientation=\"vertical\"> \n\n        <TextView \n            android:layout_width=\"wrap_content\" \n            android:layout_height=\"wrap_content\" \n            android:text=\"@{note.title}\" /> \n\n    </LinearLayout> \n  </layout>  \n```", "```kt\n    package com.journaler.activity \n\n    import android.databinding.DataBindingUtil \n    import android.location.Location \n    import android.os.Bundle \n    import com.journaler.R \n    import com.journaler.databinding.ActivityBindingBinding \n    import com.journaler.model.Note \n\n    abstract class BindingActivity : BaseActivity() { \n\n    override fun onCreate(savedInstanceState: Bundle?) { \n        super.onCreate(savedInstanceState) \n        /** \n         * ActivityBindingBinding is auto generated class \n         * which name is derived from activity_binding.xml filename. \n         */ \n        val binding : ActivityBindingBinding =\n        DataBindingUtil.setContentView( \n            this, R.layout.activity_binding \n        ) \n        val location = Location(\"dummy\") \n        val note = Note(\"my note\", \"bla\", location) \n        binding.note = note \n      } \n\n    }  \n```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?> \n   <GridView  \n      android:id=\"@+id/my_grid\" \n      android:layout_width=\"match_parent\" \n      android:layout_height=\"match_parent\" \n      android:columnWidth=\"100dp\" \n      android:numColumns=\"3\" \n      android:verticalSpacing=\"20dp\" \n      android:horizontalSpacing=\"20dp\" \n\n      android:stretchMode=\"columnWidth\" \n      android:gravity=\"center\" \n    /> \n```", "```kt\n    view.setOnLongClickListener { \n            val data = ClipData.newPlainText(\"\", \"\") \n            val shadowBuilder = View.DragShadowBuilder(view) \n            view.startDrag(data, shadowBuilder, view, 0) \n            true \n   } \n```", "```kt\n    private val dragListener = View.OnDragListener { \n        view, event -> \n        val tag = \"Drag and drop\" \n        event?.let { \n            when (event.action) { \n                DragEvent.ACTION_DRAG_STARTED -> { \n                    Log.d(tag, \"ACTION_DRAG_STARTED\") \n                } \n                DragEvent.ACTION_DRAG_ENDED -> { \n                    Log.d(tag, \"ACTION_DRAG_ENDED\") \n                } \n                DragEvent.ACTION_DRAG_ENTERED -> { \n                    Log.d(tag, \"ACTION_DRAG_ENDED\") \n                } \n                DragEvent.ACTION_DRAG_EXITED -> { \n                    Log.d(tag, \"ACTION_DRAG_ENDED\") \n                } \n                else -> { \n                    Log.d(tag, \"ACTION_DRAG_ ELSE ...\") \n                } \n            } \n        } \n        true \n     } \n\n    target?.setOnDragListener(dragListener) \n```"]