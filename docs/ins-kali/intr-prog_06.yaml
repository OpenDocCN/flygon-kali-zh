- en: Java Language Elements and Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语言元素和类型
- en: This chapter starts a systematic introduction to Java with a definition of language
    elements—identifiers, variables, literals, keywords, separators, and comments.
    It also describes Java types—primitive types and reference types. Special attention
    is applied to the `String` class, `enum` types, and arrays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从定义语言元素-标识符、变量、文字、关键字、分隔符和注释开始系统地介绍Java。它还描述了Java类型-原始类型和引用类型。特别关注`String`类、`enum`类型和数组。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are the Java language elements?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Java语言元素？
- en: Comments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: Identifiers and variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符和变量
- en: Reserved and restricted keywords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留和受限关键字
- en: Separators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符
- en: Primitive types and literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型和文字
- en: Reference types and String
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和字符串
- en: Arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Enum types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Exercise – Variable declarations and initializations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-变量声明和初始化
- en: What are the Java language elements?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Java语言元素？
- en: As with any programming language, Java has a grammar that is applied to the
    language elements. The elements are building blocks used to compose language structures
    that allow the programmer to express intent. Elements themselves have different
    levels of complexity. Lower-level (simpler) elements enable building higher-level
    (more complex) ones. For a more detailed and systematic treatment of Java grammar
    and language elements, please see the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何编程语言一样，Java具有适用于语言元素的语法。这些元素是用于构成语言结构的构建块，允许程序员表达意图。元素本身具有不同的复杂性级别。较低级别（更简单）的元素使得构建更高级别（更复杂）的元素成为可能。有关Java语法和语言元素的更详细和系统的处理，请参阅Java规范（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。
- en: In this book, we start with input elements that belong to one of the lowest
    levels. They are called **input elements** because they serve as input to the
    Java compiler.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们从属于最低级别之一的输入元素开始。它们被称为**输入元素**，因为它们作为Java编译器的输入。
- en: Input elements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入元素
- en: 'Java input elements, according to the Java Specification, can be one of the
    following three:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Java规范，Java输入元素可以是以下三种之一：
- en: '**Whitespace**: This can be one of these ASCII characters--SP (space), HT (horizontal
    tab), or FF (form feed, also called page break)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白字符：可以是这些ASCII字符之一- SP（空格），HT（水平制表符）或FF（换页符，也称为分页符）
- en: '**Comment**: A free-formed text that is not processed by the compiler but transferred
    into the bytecode as-is, so programmers use a comment to add a human-readable
    explanation to the code as they write it. A comment can include a whitespace,
    but it is not recognized as an input element; it is processed as a part of the
    comment only. We will describe the grammar rules for a comment and show some examples in
    the *Comments* section.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释：一个自由形式的文本，不会被编译器处理，而是原样转换为字节码，因此程序员在编写代码时使用注释来添加人类可读的解释。注释可以包括空格，但不会被识别为输入元素；它只会作为注释的一部分进行处理。我们将在*注释*部分描述注释的语法规则并展示一些示例。
- en: '**Token**: This can be one of the following:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌：可以是以下之一：
- en: '**Identifier**: Will be described in the *Identifiers and variables* section.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符：将在*标识符和变量*部分描述。
- en: '**Keyword**: Will be described in the *Reserved and restricted keywords* section.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字：将在*保留和受限关键字*部分描述。
- en: '**Separator**: Will be described in the *Separators* section.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符：将在*分隔符*部分描述。
- en: '**Literal**: Will be described in the *Primitive types and literals* section.
    Some literals can include a whitespace, but it is not recognized as an input element;
    the whitespace is processed as a part of the literal only.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字：将在*原始类型和文字*部分描述。一些文字可以包括空格，但不会被识别为输入元素；空格只会作为文字的一部分进行处理。
- en: '**Operator**: Will be described in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements**. *'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符：将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中描述，*运算符、表达式和语句**。*
- en: Input elements are used to compose more complex elements, including types. Some
    of the keywords are used to denote types, and we will also discuss them in this
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入元素用于构成更复杂的元素，包括类型。一些关键字用于表示类型，我们也将在本章中讨论它们。
- en: Types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: Java is a strongly typed language, which means that any variable declaration
    must include its type. Type limits the value a variable can hold and how this
    value can be passed around.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种强类型语言，这意味着任何变量声明必须包括其类型。类型限制了变量可以保存的值以及如何传递这个值。
- en: 'All types in Java are divided into two categories:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有类型分为两类：
- en: '**Primitive types**: Described in the *Primitive types and literals* section'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型：在*原始类型和文字*部分描述
- en: '**Reference types**: Described in the *Reference types and String* section'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型：在*引用类型和字符串*部分描述
- en: 'Some of the reference types require more attention, either because of their
    complexity or other particulars that have to be explained to avoid future confusion:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些引用类型需要更多关注，要么是因为它们的复杂性，要么是因为其他细节，必须解释清楚以避免将来的混淆：
- en: '**Arrays**: Described in the *Arrays* section'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：在*数组*部分描述
- en: '**String** (the uppercase first character indicates it is the name of a class):
    Described in the *Reference types and String* section'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（大写的第一个字符表示它是一个类的名称）：在*引用类型和字符串*部分描述
- en: '**Enum types**: Described in the *Enum types* section'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型：在*枚举类型*部分描述
- en: Comments
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'The Java Specification provides the following information about comments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范提供了关于注释的以下信息：
- en: '"There are two kinds of comments:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"有两种注释：'
- en: /* text */
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: /*文本*/
- en: 'A traditional comment: all the text from the ASCII characters /* to the ASCII
    characters */ is ignored (as in C and C++).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传统注释：从ASCII字符/*到ASCII字符*/的所有文本都被忽略（与C和C++一样）。
- en: // text
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: //文本
- en: 'An end-of-line comment: all the text from the ASCII characters // to the end
    of the line is ignored (as in C++)."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾注释：从ASCII字符//到行尾的所有文本都被忽略（就像C++中一样）。
- en: 'Here is an example of comments in the `SimpleMath` class that we have written
    already:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经编写的`SimpleMath`类中注释的一个例子：
- en: '```java'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: /*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: /*
- en: This method just multiplies any integer by 2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是将任何整数乘以2
- en: and returns the result
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回结果
- en: '*/'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: public int multiplyByTwo(int i){
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: //Should we check if i is bigger than 1/2 of Integer.MAX_VALUE ?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: //我们应该检查i是否大于Integer.MAX_VALUE的1/2吗？
- en: return i * 2; // The magic happens here
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2; //魔术发生在这里
- en: '}'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The comments do not affect the code in any way. They are just programmer's notes.
    Also, don't confuse them with JavaDoc or another documentation generating system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不会以任何方式影响代码。它们只是程序员的注释。此外，不要将它们与JavaDoc或其他文档生成系统混淆。
- en: Identifiers and variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符和变量
- en: Identifiers and variables are among the most often used elements of Java. They
    are closely coupled because every variable has a name and the name of a variable
    is an identifier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符和变量是Java中最常用的元素之一。它们密切相关，因为每个变量都有一个名称，而变量的名称是一个标识符。
- en: Identifier
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符
- en: 'An identifier is the first in the list of Java tokens. It is a sequence of
    symbols, each may be a letter, a dollar sign `$`, an underscore, `_`, or any digit
    0-9. The restrictions are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是Java标记列表中的第一个。它是一系列符号，每个符号可以是字母、美元符号`$`、下划线`_`或任何数字0-9。限制如下：
- en: The first symbol of an identifier cannot be a digit
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符的第一个符号不能是数字
- en: A single-symbol identifier cannot be an underscore `_`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个符号标识符不能是下划线`_`
- en: An identifier cannot have the same spelling as a keyword (see the *Reserved
    and restricted keywords* section)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能与关键字拼写相同（请参阅*保留和受限关键字*部分）
- en: An identifier cannot be a Boolean literal `true` or `false`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能是布尔文字`true`或`false`
- en: An identifier cannot be spelled as a special type `null`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能拼写为特殊类型`null`
- en: If any of the above restrictions is violated, a compiler generates an error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果违反上述任何限制，编译器将生成错误。
- en: 'In practice, the letters used for an identifier are usually taken from the
    English alphabet – lowercase or uppercase. But it is possible to use other alphabets,
    too. You can find the formal definition of the letters that can be included in
    the identifier in section 3.8 of the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Here is the list of the examples from that section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，标识符使用的字母通常来自英文字母表-小写或大写。但也可以使用其他字母表。您可以在Java规范的第3.8节中找到可以包含在标识符中的字母的正式定义（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。以下是该部分示例的列表：
- en: '`i3`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i3`'
- en: '`αρετη`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`αρετη`'
- en: '`String`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`MAX_VALUE`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_VALUE`'
- en: '`isLetterOrDigit`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLetterOrDigit`'
- en: 'To show the variety of possibilities, we can add two more examples of legal
    identifiers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示各种可能性，我们可以再添加两个合法标识符的示例：
- en: '`$`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`'
- en: '`_1`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_1`'
- en: Variable
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A variable is a storage location, as the Java Specification puts it in the *Variables *section.
    It has a name (an identifier) and an assigned type. A variable refers to the memory
    where a value is stored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个存储位置，正如Java规范在*变量*部分所述。它有一个名称（标识符）和一个分配的类型。变量指的是存储值的内存。
- en: 'The Java Specification has provision for eight kinds of variables:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范规定了八种变量：
- en: '**Class variable**: A static class member that can be used without creating
    an object'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类变量**：可以在不创建对象的情况下使用的静态类成员'
- en: '**Instance variable**: A non-static class member that can be used only via
    an object'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例变量**：只能通过对象使用的非静态类成员'
- en: '**Array component**: An array element (see the *Arrays* section)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组成员**：数组元素（参见*数组*部分）'
- en: '**Method parameter**: An argument passed to a method'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：传递给方法的参数'
- en: '**Constructor parameter**: An argument passed to a constructor when an object
    is created'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数参数**：创建对象时传递给构造函数的参数'
- en: '**Lambda parameter**: An argument passed to a lambda expression. We will talk
    about it in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda参数**：传递给lambda表达式的参数。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论它，*Lambda表达式和函数式编程*'
- en: '**Exception parameter**: It is created when an exception is caught, we will
    talk about it in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常参数**：在捕获异常时创建，我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论它，*控制流语句*'
- en: '**Local variable**: A variable declared inside a method'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：在方法内声明的变量'
- en: 'From a practical point of view, all eight kinds of variables can be summarized
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度看，所有八种变量可以总结如下：
- en: A class member, static or not
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类成员，静态或非静态
- en: An array member (also called a component or an element)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组成员（也称为组件或元素）
- en: A parameter of a method, constructor, or lambda expression
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法、构造函数或lambda表达式的参数
- en: An exception parameter of a catch-block
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: catch块的异常参数
- en: A regular local code variable, the most common kind
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规的局部代码变量，最常见的一种
- en: Most of the time, when programmers talk about a variable, they mean the last
    kind. It can refer to a class member, class instance, parameter, exception object,
    or any other value necessary for the code you are writing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当程序员谈论变量时，他们指的是最后一种。它可以是类成员、类实例、参数、异常对象或您正在编写的代码所需的任何其他值。
- en: Variable declaration, definition, and initialization
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量声明、定义和初始化
- en: 'Let''s look at the examples first. Let''s assume we have these three lines
    of code consecutively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下例子。假设我们连续有这三行代码：
- en: '```java'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;  //declartion of variable x
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: int x; //变量x的声明
- en: x = 1;  //initialization of variable x
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1; //初始化变量x
- en: x = 2;  //assignment of variable x
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2; //变量x的赋值
- en: '```'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can guess from the preceding example, variable initialization is assigning
    the first (initial) value to a variable. All subsequent assignments cannot be
    called an initialization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，变量初始化是将第一个（初始）值赋给变量。所有后续的赋值不能称为初始化。
- en: 'A local variable cannot be used until initialized:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量在初始化之前不能使用：
- en: '```java'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: int result = x * 2;  //generates compilation error
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: int result = x * 2;  //生成编译错误
- en: '```'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The second line of the preceding code will generate a compilation error. If
    a variable is a member of a class (static or not) or a component of an array and
    not initialized explicitly, it is assigned a default value that depends on the
    variable's type (see the *Primitive types and literals* and *Reference types and
    String* sections).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第二行将生成编译错误。如果一个变量是类的成员（静态或非静态）或数组的组件，并且没有显式初始化，它将被赋予一个默认值，该默认值取决于变量的类型（参见*Primitive
    types and literals*和*Reference types and String*部分）。
- en: A declaration creates a new variable. It includes the variable type and name
    (identifier). The word **declaration** is a technical term used in the Java Specification,
    section 6.1 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    But some programmers use word definition as the synonym for declaration because
    the word definition is used in some other programming languages (C and C++, for
    example) for a type of statement that does not exist in Java. So, be aware of
    it and assume they mean declaration when you here *definition* applied to Java.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 声明创建一个新变量。它包括变量类型和名称（标识符）。单词**declaration**是Java规范中使用的一个技术术语，第6.1节（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）。但是一些程序员在Java中使用单词definition作为declaration的同义词，因为在其他一些编程语言（例如C和C++）中，单词definition用于Java中不存在的一种语句类型。因此，要注意这一点，并假设当你听到*definition*应用于Java时，它们指的是declaration。
- en: 'Most of the time, when writing Java code, programmers combine declaration and
    initialization statements in one.  For example, a variable of the `int` type can
    be declared and initialized to hold integer `1`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Java代码时，大多数情况下，程序员将声明和初始化语句结合在一起。例如，可以声明并初始化一个`int`类型的变量来保存整数`1`，如下所示：
- en: '```java'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int $ = 1;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: int $ = 1;
- en: int _1 = 1;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: int _1 = 1;
- en: int i3 = 1;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = 1;
- en: int αρετη = 1;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: int αρετη = 1;
- en: int String = 1;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: int String = 1;
- en: int MAX_VALUE = 1;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: int MAX_VALUE = 1;
- en: int isLetterOrDigit = 1;
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: int isLetterOrDigit = 1;
- en: '```'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The same identifiers can be used to declare and initialize a variable of the
    `String` type to hold `abs`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的标识符可以用来声明和初始化一个`String`类型的变量来保存`abs`：
- en: '```java'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String $ = "abc";
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: String $ = "abc";
- en: String _1 = "abc";
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: String _1 = "abc";
- en: String i3 = "abc";
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: String i3 = "abc";
- en: String αρετη = "abc";
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: String αρετη = "abc";
- en: String String = "abc";
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: String String = "abc";
- en: String MAX_VALUE = "abc";
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: String MAX_VALUE = "abc";
- en: String isLetterOrDigit = "abc";
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: String isLetterOrDigit = "abc";
- en: '```'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you may have noticed, in the preceding examples, we used the identifiers
    from the examples of the *Identifier* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，在前面的例子中，我们使用了*Identifier*部分示例中的标识符。
- en: Final variable (constant)
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: final变量（常量）
- en: 'A final variable is a variable that, once initialized, cannot be assigned to
    another value. It is denoted by the `final` keyword:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: final变量是一旦初始化就不能被赋予另一个值的变量。它由`final`关键字表示：
- en: '```java'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(){
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(){
- en: final int x = 1;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: final int x = 1;
- en: x = 2; //generates compilation error
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2; //生成编译错误
- en: //some other code
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Nevertheless, the following code will work just fine:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，以下代码将正常工作：
- en: '```java'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(){
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(){
- en: final int x;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: final int x;
- en: //Any code that does not use variable x can be added here
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: //可以在这里添加任何不使用变量x的代码
- en: x = 2;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x = 2;
- en: //some other code
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: '}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: The preceding code does not generate a compilation error because the local variable
    is not initialized to a default value automatically in a declaration statement.
    Only the class, instance variable, or array component is initialized to a default
    value if the variable is not initialized explicitly (see the *Primitive types
    and literals* and *Reference types and String* sections).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会生成编译错误，因为在声明语句中，本地变量不会自动初始化为默认值。只有在变量没有显式初始化时，类、实例变量或数组组件才会被初始化为默认值（参见*Primitive
    types and literals*和*Reference types and String*部分）。
- en: When a final variable refers to an object, it cannot be assigned to another
    object, but the state of the object assigned can be changed at any time (see the *Reference
    types and String* section). The same applies to a variable that refers an array,
    because an array is an object (see the* Arrays* section).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个final变量引用一个对象时，它不能被赋值给另一个对象，但是随时可以改变被分配的对象的状态（参见*引用类型和String*部分）。对于引用数组的变量也是一样，因为数组是一个对象（参见*数组*部分）。
- en: 'Since a final variable cannot be changed, it is a constant. It is called a
    constant variable if it has a primitive type or a type of `String`. But Java programmers
    apply the term constant usually to the class-level final static variables, and
    call the local final variable just final variable. The identifier of class-level
    constants by convention is written in capital letters. Here are a few examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于final变量不能被更改，它是一个常量。如果它具有原始类型或`String`类型，则称为常量变量。但是Java程序员通常将术语常量应用于类级别的final静态变量，并将本地final变量称为final变量。按照惯例，类级别常量的标识符以大写字母写入。以下是一些示例：
- en: '```java'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: static final String FEBRUARY = "February";
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: static final String FEBRUARY = "February";
- en: static final int DAYS_IN_DECEMBER = 31;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: static final int DAYS_IN_DECEMBER = 31;
- en: '```'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Such constants look very similar to the following constants:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量看起来与以下常量非常相似：
- en: '```java'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Month.FEBRUARY;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Month.FEBRUARY;
- en: TimeUnit.DAYS;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.DAYS;
- en: DayOfWeek.FRIDAY;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: DayOfWeek.FRIDAY;
- en: '```'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But the preceding constants are defined in a special kind of class, called `enum`,
    although for all practical purposes, all constants behave similarly in the sense
    that they cannot be changed. One just has to check the type of a constant in order
    to know what methods its class (type) provides.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面的常量是在一种特殊类型的类中定义的，称为`enum`，尽管在所有实际目的上，所有常量的行为都是相似的，因为它们不能被更改。只需检查常量的类型，就可以知道其类（类型）提供了什么方法。
- en: Reserved and restricted keywords
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留和受限关键字
- en: A keyword is the second of Java tokens listed in the *Input types* section. We
    have seen several Java keywords already—`abstract`, `class`, `final`, `implements`, `int`, `interface`, `new`,
    `package`, `private`, `public`, `return`, `static`, and `void`. Now we will present
    the full list of the reserved keywords. These keywords cannot be used as identifiers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是Java标记中列出的第二个，我们已经看到了几个Java关键字——`abstract`, `class`, `final`, `implements`, `int`, `interface`, `new`,
    `package`, `private`, `public`, `return`, `static`, 和 `void`。现在我们将列出所有保留关键字的完整列表。这些关键字不能用作标识符。
- en: Reserved keywords
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留关键字
- en: 'Here is the list of all 49 keywords of Java 9:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java 9的所有49个关键字的列表：
- en: '| abstract | class | final | implements | int |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| abstract | class | final | implements | int |'
- en: '| interface | new | package | private | public |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| interface | new | package | private | public |'
- en: '| return | static | void | if | this |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| return | static | void | if | this |'
- en: '| break | double | default | protected | throw |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| break | double | default | protected | throw |'
- en: '| byte | else  | import | synchronized | throws |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| byte | else  | import | synchronized | throws |'
- en: '| case | enum | instanceof | boolean | transient |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| case | enum | instanceof | boolean | transient |'
- en: '| catch | extends | switch | short | try |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| catch | extends | switch | short | try |'
- en: '| char | for | assert | do | finally |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| char | for | assert | do | finally |'
- en: '| continue | float | long | strictfp | volatile |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| continue | float | long | strictfp | volatile |'
- en: '| native | super | while | _ (underscore) |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| native | super | while | _ (下划线) |  |'
- en: 'The keywords are used for different Java elements and statements, and cannot
    be used as identifiers. The `goto`, `const`, and `_` (underscore) keywords are
    not used as keywords yet, but they might in the future Java releases. For now,
    they are just included in the list of the reserved keywords to prevent their use
    as an identifier. But they can be a part of an identifier among other characters,
    for example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字用于不同的Java元素和语句，不能用作标识符。`goto`，`const`和`_`（下划线）关键字尚未用作关键字，但它们可能在未来的Java版本中使用。目前，它们只是包含在保留关键字列表中，以防止它们用作标识符。但它们可以作为标识符的一部分，例如：
- en: '```java'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int _ = 3; //Error, underscore is a reserved keyword
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: int _ = 3; //错误，下划线是一个保留关键字
- en: int __ = 3; //More than 1 underscore as an identifier is OK
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: int __ = 3; //作为标识符的多个下划线是可以的
- en: int _1 = 3;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: int _1 = 3;
- en: int y_ = 3;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: int y_ = 3;
- en: int goto_x = 3;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: int goto_x = 3;
- en: int const1 = 3;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: int const1 = 3;
- en: '```'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `true` and `false` words look like keywords and cannot be used as identifiers,
    but in fact they are not Java keywords. They are Boolean literals (values). We
    will define what a literal is in the *Primitive types and literals* section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`true` 和 `false` 看起来像关键字，不能用作标识符，但实际上它们不是Java关键字。它们是布尔字面值（值）。我们将在*基本类型和字面值*部分定义字面值是什么。'
- en: And there is another word that looks like a keyword but is in fact a special
    type—`null` (see the *Reference types and String* section). It also cannot be
    used as an identifier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个看起来像关键字的词，但实际上是一种特殊类型——`null`（参见*引用类型和字符串*部分）。它也不能用作标识符。
- en: Restricted keywords
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限关键字
- en: 'There are ten words that are called restricted keywords: `open`, `module`,
    `requires`, `transitive`, `exports`, `opens`, `to`, `uses`, `provides`, and `with`.
    They are called restricted because they cannot be identifiers in the context of
    a module declaration, which we will not discuss in this book. In all other places,
    it is possible to use them as identifiers. Here is one example of such usage:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有十个词被称为受限关键字：`open`，`module`，`requires`，`transitive`，`exports`，`opens`，`to`，`uses`，`provides`和`with`。它们被称为受限，因为它们在模块声明的上下文中不能作为标识符，我们将不在本书中讨论。在所有其他地方，可以将它们用作标识符。以下是这种用法的一个例子：
- en: '```java'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int to = 1;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: int to = 1;
- en: int open = 1;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int open = 1;
- en: int uses = 1;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: int uses = 1;
- en: int with = 1;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: int with = 1;
- en: int opens =1;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: int opens =1;
- en: int module = 1;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: int module = 1;
- en: int exports =1;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: int exports =1;
- en: int provides = 1;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: int provides = 1;
- en: int requires = 1;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: int requires = 1;
- en: int transitive = 1;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: int transitive = 1;
- en: '```'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: However, it is a good practice not to use them as identifiers anywhere. There
    are plenty of other ways to name a variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好不要在任何地方将它们用作标识符。有很多其他方法来命名一个变量。
- en: Separators
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分隔符
- en: 'A separator is the third of the Java tokens listed in the *Input types* section.
    Here are all twelve of them, in no particular order:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符是Java标记中列出的第三个。以下是它们的全部十二个，没有特定的顺序：
- en: '```java'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ';  { }  ( )  [ ]  ,  .  ...  ::  @'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ';  { }  ( )  [ ]  ,  .  ...  ::  @'
- en: '```'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Semicolon ";"
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分号";"
- en: 'By now, you are quite familiar with the usage of the separator `;` (semicolon).
    Its only job in Java is to terminate a statement:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经非常熟悉分隔符`;`（分号）的用法。它在Java中的唯一作用是终止语句：
- en: '```java'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i;  //declaration statement
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: int i;  //声明语句
- en: i = 2;  //assignment statement
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: i = 2;  //赋值语句
- en: if(i == 3){    //flow control statement called if-statement
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 3){    //流程控制语句称为if语句
- en: //do something
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些事情
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for(int i = 0; i < 10; i++){
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i < 10; i++){
- en: //do something with each value of i
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: //对i的每个值执行一些操作
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Braces "{}"
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大括号“{}”
- en: 'You have seen the separators `{}` (braces) around the class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了类周围的大括号`{}`：
- en: '```java'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类SomeClass {
- en: //class body with code
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: //带有代码的类体
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You have also seen braces around method bodies:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了方法体周围的大括号：
- en: '```java'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i){
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i){
- en: //...
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: if(i == 2){
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 2){
- en: //block of code
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: //代码块
- en: '} else {'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: //another block of code
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: //另一个代码块
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The braces are also used to denote a block of code in control-flow statements
    (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号也用于表示控制流语句中的代码块（参见[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）：
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i){
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i){
- en: //...
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: if(i == 2){
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 2){
- en: //block of code
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: //代码块
- en: '} else {'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: //another block of code
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: //另一个代码块
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And they are used to initialize arrays (see the *Arrays* section):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于初始化数组（请参阅*数组*部分）：
- en: '```java'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] myArray = {2,3,5};
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: int[] myArray = {2,3,5};
- en: '```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There are also a few other rarely used constructs where braces are used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他很少使用的构造，其中使用大括号。
- en: Parentheses "()"
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号“（）”
- en: 'You have also seen the usage of separators `()` (parentheses) to keep the list
    of method parameters in the method definition and method invocation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了使用分隔符`()`（括号）在方法定义和方法调用中保持方法参数列表：
- en: '```java'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i) {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i) {
- en: //...
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = anotherMethod();
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: String s = anotherMethod();
- en: //...
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'They are also used in control-flow statements (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还用于控制流语句（请参阅[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）：
- en: '```java'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(i == 2){
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 2){
- en: //...
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'During typecasting (see the *Primitive types and literals* section), they are
    put around the type:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型转换期间（请参阅*基本类型和文字*部分），它们放在类型周围：
- en: '```java'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long v = 23;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: long v = 23;
- en: int i = (int)v;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: int i = (int)v;
- en: '```'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As for setting the precedence of an execution (see [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*), you should be familiar with it from
    basic algebra:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 至于设置执行的优先级（请参阅[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)，*运算符，表达式和语句*），您应该从基本代数中熟悉它：
- en: '```java'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: x = (y + z) * (a + b).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: x = (y + z) * (a + b).
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Brackets "[]"
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号“[]”
- en: 'The separators `[]` (brackets) are used for arrays declaration (see the *Arrays* section):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符`[]`（方括号）用于数组声明（请参阅*数组*部分）：
- en: '```java'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] a = new int[23];
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: int[] a = new int[23];
- en: '```'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Comma ","
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逗号“，”
- en: 'The comma `,` is used for the separation of method parameters, listed in parentheses:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号`,`用于括号中列出方法参数的分隔：
- en: '```java'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(int i, String s, int j) {
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(int i, String s, int j) {
- en: //...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = anotherMethod(5, 6.1, "another param");
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: String s = anotherMethod(5, 6.1, "another param");
- en: //...
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A comma can also be used to separate variables of the same type in the declaration
    statement:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号也可以用于在声明语句中分隔相同类型的变量：
- en: '```java'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i, j = 2; k;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: int i, j = 2; k;
- en: '```'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding example, all three variables, `i`, `j`, and `k`, are declared
    to be of the `int` type, but only variable `j` is initialized to `2`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`i`，`j`和`k`三个变量都声明为`int`类型，但只有变量`j`初始化为`2`。
- en: 'The use of a comma in a looping statement serves the same purpose of the declaration
    of multiple variables (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环语句中使用逗号具有与声明多个变量相同的目的（请参阅[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）：
- en: '```java'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (int i = 0; i < 10; i++){
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < 10; i++){
- en: //...
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Period "."
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句号“.”
- en: The separator `.` (period) is used to separate parts of the package name, as
    you have seen in the `com.packt.javapath` example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符`.`（句点）用于分隔包名称的各个部分，就像您在`com.packt.javapath`示例中看到的那样。
- en: 'You also have seen how the period was used to separate an object reference
    and the method of that object:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了如何使用句号来分隔对象引用和该对象的方法：
- en: '```java'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int result = simpleMath.multiplyByTwo(i);
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: int result = simpleMath.multiplyByTwo(i);
- en: '```'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Similarly, if a `simpleMath` object had a public property of `a`, it could be
    referred to as `simpleMath.a`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`simpleMath`对象具有`a`的公共属性，则可以将其称为`simpleMath.a`。
- en: Ellipsis "..."
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 省略号“...”
- en: 'The separator `...` (ellipsis) is used only for varargs:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符`...`（省略号）仅用于varargs：
- en: '```java'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int someMethod(int i, String s, int... k){
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: int someMethod(int i, String s, int... k){
- en: //k is an array with elements k[0], k[1], ...
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: //k是一个具有元素k[0]，k[1]等的数组
- en: '}'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding method can be called in any of the following ways:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以以下任何一种方式调用前面的方法：
- en: '```java'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: someMethod(42, "abc");          //array k = null
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: someMethod(42, "abc");          //数组k = null
- en: someMethod(42, "abc", 42, 43);  //k[0] = 42, k[1] = 43
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: someMethod(42, "abc", 42, 43);  //k[0] = 42, k[1] = 43
- en: int[] k = new int[2];
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: int[] k = new int[2];
- en: k[0] = 42;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: k[0] = 42;
- en: k[1] = 43;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: k[1] = 43;
- en: someMethod(42, "abc", k);       //k[0] = 42, k[1] = 43
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: someMethod(42, "abc", k);       //k[0] = 42, k[1] = 43
- en: '```'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    while talking about the `main()` method, we explained the concept of `varargs`
    (variable arguments) in Java.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中，*Java语言基础*，在讨论`main()`方法时，我们解释了Java中`varargs`（可变参数）的概念。
- en: Colons "::"
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒号"::"
- en: 'The separator `::` (colons) is used for method reference in lambda expressions
    (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a E*xpressions
    and Functional Programming*):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符`::`（冒号）用于lambda表达式中的方法引用（请参阅[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)，*Lambda表达式和函数式编程*）：
- en: '```java'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "32", "765");
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "32", "765");
- en: list.stream().mapToInt(Integer::valueOf).sum();
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToInt(Integer::valueOf).sum();
- en: '```'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: At sign "@"
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@符号“@”'
- en: 'The separator `@` (at sign) is used to denote an annotation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符`@`（@符号）用于表示注释：
- en: '```java'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: int someMethod(String s){
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: int someMethod(String s){
- en: //...
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You have seen several examples of an annotation when we created a unit test
    in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your First Java Project*.
    There are several predefined annotations in the Java standard libraries (`@Deprecated`,
    `@Override`, and `@FunctionalInterface`, to name a few). We are going to use one
    of them (`@FunctionalInterface`) in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambd*a
    E*xpressions and Functional Programming*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中创建单元测试时，您已经看到了注释的几个示例，*您的第一个Java项目*。
    Java标准库中有几个预定义的注释（`@Deprecated`，`@Override`和`@FunctionalInterface`等）。 我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中使用其中一个（`@FunctionalInterface`），*Lambda表达式和函数式编程*。
- en: The annotations are metadata. They describe classes, fields, and methods, but
    they themselves are not executed. The Java compiler and JVM read them and treat
    the described class, field, or method in a certain way depending on the annotation.
    For example, in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you saw how we used the `@Test` annotation. Adding it in
    front of a public non-static method tells JVM that it is a test method that has
    to be run. So, if you execute this class, the JVM will run only this method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是元数据。它们描述类、字段和方法，但它们本身不会被执行。Java编译器和JVM读取它们，并根据注释以某种方式处理所描述的类、字段或方法。例如，在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)，*您的第一个Java项目*中，您看到我们如何使用`@Test`注释。在公共非静态方法前面添加它会告诉JVM它是一个必须运行的测试方法。因此，如果您执行此类，JVM将仅运行此方法。
- en: Or, if you use the `@Override` annotation in front of a method, the compiler
    will check to see whether this method actually overrides a method in a parent
    class or not. If the matching signature of a non-private non-static class is not
    found in any of the class parents, the compiler will raise an error.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您在方法前面使用`@Override`注释，编译器将检查此方法是否实际覆盖了父类中的方法。如果在任何类的父类中找不到非私有非静态类的匹配签名，则编译器将引发错误。
- en: It is also possible to create new custom annotations (JUnit framework does exactly
    that), but this topic is outside the scope of this book.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以创建新的自定义注释（JUnit框架确实如此），但这个主题超出了本书的范围。
- en: Primitive types and literals
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型和文字
- en: 'Java has only two kinds of variable types: primitive types and reference types.
    A primitive type defines what kind of value the variable can hold and how big
    or small this value can be. We will discuss primitive types in this section.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Java只有两种变量类型：基本类型和引用类型。基本类型定义了变量可以保存的值的类型以及这个值可以有多大或多小。我们将在本节讨论基本类型。
- en: A reference type allows us to assign only one kind of value to the variable –
    the reference to the memory area where an object is stored. We will discuss the
    reference types in the next section, *Reference types and String*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型允许我们只向变量分配一种值 - 对存储对象的内存区域的引用。我们将在下一节*引用类型和字符串*中讨论引用类型。
- en: 'Primitive types can be divided into two groups: the Boolean type and the numeric
    types. The numeric-types group can be split further into integral types (`byte`,
    `short`, `int`, `long`, and `char`) and floating-point types (float and double).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型可以分为两组：布尔类型和数值类型。数值类型组可以进一步分为整数类型（`byte`、`short`、`int`、`long`和`char`）和浮点类型（float和double）。
- en: Each primitive type is defined by a corresponding reserved keyword, listed in the *Reserved
    and restricted keywords* section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 每种基本类型都由相应的保留关键字定义，列在*保留和受限关键字*部分中。
- en: The Boolean type
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'The Boolean type allows a variable to have one of two values: `true` or `false`.
    As we mentioned in the *Reserved keywords* section, these values are Boolean literals,
    which means they are values that represent themselves directly – without a variable.
    We will talk more about literals in the *Primitive type literals* section.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型允许变量具有两个值之一：`true`或`false`。正如我们在*保留关键字*部分中提到的那样，这些值是布尔文字，这意味着它们是直接表示自己的值
    - 而不是一个变量。我们将在*基本类型文字*部分更多地讨论文字。
- en: 'Here is an example of a `b` variable declaration and initialization to the
    value `true`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`b`变量声明和初始化为值`true`的示例：
- en: '```java'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean b = true;
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b = true;
- en: '```'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is another example of assigning a `true` value to the `b` Boolean
    variable using an expression:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例，使用表达式将`true`值分配给`b`布尔变量：
- en: '```java'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 1, y = 1;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 1, y = 1;
- en: boolean b = 2 == ( x + y );
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b = 2 == ( x + y );
- en: '```'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding example, in the first line, two variables, `x` and `y`, of
    the `int` primitive type are declared and each assigned a value of `1`. In the
    second line, a Boolean variable is declared and assigned the result of the `2
    == ( x + y )` expression. Parentheses set the precedence of execution as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在第一行中，声明了两个`int`基本类型的变量`x`和`y`，并分别赋值为`1`。在第二行，声明了一个布尔变量，并将其赋值为`2 ==
    ( x + y )`表达式的结果。括号设置了执行的优先级，如下所示：
- en: Calculate the sum of values assigned to the `x` and `y` variables
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算分配给`x`和`y`变量的值的总和
- en: Compare the result with `2`, using the `==` Boolean operator
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`==`布尔运算符将结果与`2`进行比较
- en: We will study operators and expressions in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)，*运算符、表达式和语句*中学习运算符和表达式。
- en: Variables of the Boolean are used in control-flow statements and we will see
    many examples of their usage in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量用于控制流语句，我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*中看到它们的许多用法。
- en: Integral types
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'Values of Java integral types occupy different amounts of memory:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Java整数类型的值占用不同数量的内存：
- en: 'byte: 8 bit'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: byte：8位
- en: 'char: 16 bit'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: char：16位
- en: 'short: 16 bit'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: short：16位
- en: 'int: 32 bit'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int：32位
- en: 'long: 64 bit'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: long：64位
- en: All of them, except `char`, are signed integer. The sign value (`0` for minus
    "`-`" and `1` for plus "`+`") occupies the first bit of the binary representation
    of the value. That is why a signed integer can hold, as a positive number, only
    half of the value an unsigned integer can. But it allows a signed integer to hold
    a negative number, which an unsigned integer cannot do. For example, in case of
    the `byte` type (8 bit), if it were an unsigned integer, the range of the values
    it could hold would be from 0 to 255 (including 0 and 255) because 2 to the power
    of 8 is 256\. But, as we have said, the `byte` type is a signed integer, which
    means the range of values it can hold is from -128 to 127 (including -128, 127,
    and 0).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`char`之外，所有这些都是有符号整数。符号值（负号“-”为`0`，正号“+”为`1`）占据值的二进制表示的第一位。这就是为什么有符号整数只能作为正数，只能容纳无符号整数值的一半。但它允许有符号整数容纳负数，而无符号整数则不能。例如，在`byte`类型（8位）的情况下，如果它是无符号整数，它可以容纳的值的范围将从0到255（包括0和255），因为8的2次方是256。但是，正如我们所说，`byte`类型是有符号整数，这意味着它可以容纳的值的范围是从-128到127（包括-128、127和0）。
- en: 'In the case of the `char` type, it can hold values from 0 to 65,535 inclusive because
    it is an unsigned integer. This integer (called a code point) identifies a record
    in the Unicode table ([https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)).
    Each Unicode table record has the following columns:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在`char`类型的情况下，它可以包含从0到65535的值，因为它是一个无符号整数。这个整数（称为代码点）标识Unicode表中的一个记录（[https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)）。每个Unicode表记录都有以下列：
- en: '**Code point**: A decimal value – a numeric representation of the Unicode record'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码点：** 十进制值，Unicode记录的数字表示'
- en: '**Unicode escape**: A four-digit number with the `\u` prefix'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unicode转义：** 带有`\u`前缀的四位数'
- en: '**Printable symbol**: A graphic representation of the Unicode record (not available
    for control codes)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可打印符号：** Unicode记录的图形表示（控制码不可用）'
- en: '**Description:** A human-readable description of the symbol'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述：** 符号的可读描述'
- en: 'Here are five records from the Unicode table:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Unicode表中的五个记录：
- en: '| **Code point** | **Unicode escape** | **Printable symbol** | **Description**
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **代码点** | **Unicode转义** | **可打印符号** | **描述** |'
- en: '| 8 | \u0008 |  | Backspace |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 8 | \u0008 |  | 退格 |'
- en: '| 10 | \u000A |  | Line feed |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 10 | \u000A |  | 换行 |'
- en: '| 36 | \u0024 | `$` | Dollar sign |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 36 | \u0024 | `$` | 美元符号 |'
- en: '| 51 | \u0033 | `3` | Digit three |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 51 | \u0033 | `3` | 数字三 |'
- en: '| 97 | \u0061 | `a` | Latin small letter A |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 97 | \u0061 | `a` | 拉丁小写字母a |'
- en: The first two are examples of a Unicode that represents control codes that are
    not printable. A control code is used to send a command to a device (a display
    or a printer, for example). There are only 66 such codes in the Unicode set. They
    have code points from 0 to 32 inclusive and from 127 to 159 inclusive. The rest
    of 65,535 Unicode records have a printable symbol – a character that the record
    represents.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例是代表不可打印的控制码的Unicode示例。控制码用于向设备（例如显示器或打印机）发送命令。Unicode集中只有66个这样的代码。它们的代码点从0到32和从127到159。其余的65535个Unicode记录都有一个可打印的符号，即记录所代表的字符。
- en: 'The interesting (and often confusing) aspect of the `char` type is that a Unicode
    escape and a code point can be used interchangeably, except when the variable
    of the `char` type is involved in an arithmetic operation. In such a case, the
    value of code point is used. To demonstrate it, let''s look at the following code
    snippet (in the comments, we have captured the output):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型的有趣（并且经常令人困惑）之处在于Unicode转义和代码点可以互换使用，除非`char`类型的变量参与算术运算。在这种情况下，使用代码点的值。为了证明这一点，让我们看一下以下代码片段（在注释中，我们捕获了输出）：'
- en: '```java'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: char a = '3';
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: char a = '3';
- en: System.out.println(a);         //  3
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(a);         //  3
- en: char b = '$';
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: char b = '$';
- en: System.out.println(b);         //  $
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);         //  $
- en: System.out.println(a + b);     //  87
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(a + b);     //  87
- en: System.out.println(a + 2);     //  53
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(a + 2);     //  53
- en: a = 36;
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: a = 36;
- en: System.out.println(a);         //  $
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(a);         //  $
- en: '```'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, variables `a` and `b` of the `char` type represent the `3` and
    `$` symbols and are displayed as these symbols as long as they are not involved
    in an arithmetic operation. Otherwise, only the code point values are used.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`char`类型的变量`a`和`b`代表`3`和`$`符号，并且只要它们不参与算术运算，就会显示为这些符号。否则，只使用代码点值。
- en: As you can see from the five Unicode records, the `3` character has a code point
    value of 51, while the `$` character has a code point value of 36\. That is why
    adding `a` and `b` produces 87, and adding `2` to `a` results in 53.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 从这五个Unicode记录中可以看出，`3`字符的代码点值为51，而`$`字符的代码点值为36。这就是为什么将`a`和`b`相加得到87，将`2`加到`a`上得到53的原因。
- en: In the last line of the example code, we have assigned a decimal value of 36
    to the `a` variable of the `char` type. It means we have instructed JVM to assign the
    character with a code point of 36, which is the `$` character, to the `a` variable.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码的最后一行中，我们将十进制值36分配给了`char`类型的变量`a`。这意味着我们已经指示JVM将代码点为36的字符`$`分配给变量`a`。
- en: And that is why the `char` type is included in the group of integral types of
    Java – because it acts as a numeric type in arithmetic operations.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`char`类型包含在Java的整数类型组中的原因，因为它在算术运算中充当数字类型。
- en: 'The range of values each of the primitive types can hold is as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 每种原始类型可以容纳的值的范围如下：
- en: '`byte`: From -128 to 127, inclusive'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：从-128到127，包括'
- en: '`short`: From -32,768 to 32,767, inclusive'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：从-32,768到32,767，包括'
- en: '`int`: From -2.147.483.648 to 2.147.483.647, inclusive'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：从-2.147.483.648到2.147.483.647，包括'
- en: '`long`: From -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, inclusive'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：从-9,223,372,036,854,775,808到9,223,372,036,854,775,807，包括'
- en: '`char`: From ''\u0000'' to ''\uffff'' inclusive, that is, from 0 to 65,535,
    inclusive'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：从''\u0000''到''\uffff''，即从0到65,535，包括'
- en: 'You can access the maximum and minimum values of each type any time, using
    a corresponding wrapper class of each primitive type (we will talk about wrapper
    classes in more detail in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*). Here is one way to do it (in the comments,
    we have shown the output):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用每种原始类型的相应包装类访问每种类型的最大值和最小值（我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更详细地讨论包装类，*运算符，表达式和语句*）。以下是一种方法（在注释中，我们已经显示了输出）：
- en: '```java'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte b = Byte.MIN_VALUE;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = Byte.MIN_VALUE;
- en: System.out.println(b);     //  -127
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);     //  -127
- en: b = Byte.MAX_VALUE;
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: b = Byte.MAX_VALUE;
- en: System.out.println(b);     //   128
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);     //   128
- en: short s = Short.MIN_VALUE;
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: short s = Short.MIN_VALUE;
- en: System.out.println(s);      // -32768
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);      // -32768
- en: s = Short.MAX_VALUE;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: s = Short.MAX_VALUE;
- en: System.out.println(s);      //  32767
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);      //  32767
- en: int i = Integer.MIN_VALUE;
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Integer.MIN_VALUE;
- en: System.out.println(i);      // -2147483648
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i);      // -2147483648
- en: i = Integer.MAX_VALUE;
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: i = Integer.MAX_VALUE;
- en: System.out.println(i);      //  2147483647
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i);      //  2147483647
- en: long l = Long.MIN_VALUE;
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: long l = Long.MIN_VALUE;
- en: System.out.println(l);      // -9223372036854775808
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(l);      // -9223372036854775808
- en: l = Long.MAX_VALUE;
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: l = Long.MAX_VALUE;
- en: System.out.println(l);      //  9223372036854775807
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(l);      //  9223372036854775807
- en: char c = Character.MIN_VALUE;
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: char c = Character.MIN_VALUE;
- en: System.out.println((int)c); // 0
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((int)c); // 0
- en: c = Character.MAX_VALUE;
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: c = Character.MAX_VALUE;
- en: System.out.println((int)c); // 65535
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((int)c); // 65535
- en: '```'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You may have noticed the `(int)c` construct. It is called **casting**, similar
    to what happens during a movie production when an actor is tried for a particular
    role. The value of any primitive numeric types can be converted into the value
    of another primitive numeric type, provided it is not bigger than the maximum
    value of the target type. Otherwise, an error will be generated during program
    execution (such an error is called a runtime error). We will talk more about conversion
    between primitive numeric types in Chapter 9, *Operators, Expressions, and Statements*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了`(int)c`构造。它称为**转换**，类似于电影制作期间对演员进行特定角色的尝试。任何原始数值类型的值都可以转换为另一个原始数值类型的值，前提是它不大于目标类型的最大值。否则，在程序执行期间将生成错误（此类错误称为运行时错误）。我们将在第9章*运算符，表达式和语句*中更多地讨论原始数值类型之间的转换。
- en: A casting between numeric types and the `boolean` type is not possible. A compile-time
    error will be generated if you try to do that.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型和`boolean`类型之间的转换是不可能的。如果您尝试执行此操作，将生成编译时错误。
- en: Floating-point types
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'In the Java Specification, the floating-point types (`float` and `double`)
    are defined as:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java规范中，浮点类型（`float`和`double`）的定义如下：
- en: '"The single-precision 32-bit and double-precision 64-bit format IEEE 754 values."'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '"单精度32位和双精度64位格式IEEE 754值。"'
- en: 'It means that the `float` type occupies 32 bits and the `double` type takes
    64 bits. They represent positive and negative numerical values with a fractional
    part after the dot "`.`": `1.2`, `345.56`, `10.`, `-1.34`.  By default, in Java,
    a numeric value with a dot in it is assumed to be of the `double` type. So, the
    following assignment causes a compilation error:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`float`类型占用32位，`double`类型占用64位。它们表示带有点“。”后的分数部分的正数和负数值：“1.2”，“345.56”，“10.”，“-1.34”。默认情况下，在Java中，带有点的数值被假定为`double`类型。因此，以下赋值会导致编译错误：
- en: '```java'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: float r = 23.4;
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4;
- en: '```'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To avoid the error, one has to indicate that the value has to be treated as
    a `float` type by appending the `f` or `F` character at the value, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，必须通过在值后附加`f`或`F`字符来指示该值必须被视为`float`类型，如下所示：
- en: '```java'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: float r = 23.4f;
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4f;
- en: or
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: float r = 23.4F;
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: float r = 23.4F;
- en: '```'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The values themselves (`23.4f` and `23.4F`) are called literals. We will talk
    more about them in the *Primitive type literals* section.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值（`23.4f`和`23.4F`）本身称为文字。我们将在*原始类型文字*部分中更多地讨论它们。
- en: 'The minimum and maximum value can be found the same way as we did for integral
    numbers. Just run the following snippet of code (in the comments, we have captured
    the output we got on our computer):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值可以通过与整数相同的方式找到。只需运行以下代码片段（在注释中，我们捕获了我们在计算机上得到的输出）：
- en: '```java'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Float.MIN_VALUE);  //1.4E-45
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Float.MIN_VALUE);  //1.4E-45
- en: System.out.println(Float.MAX_VALUE);  //3.4028235E38
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Float.MAX_VALUE);  //3.4028235E38
- en: System.out.println(Double.MIN_VALUE); //4.9E-324
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Double.MIN_VALUE); //4.9E-324
- en: System.out.println(Double.MAX_VALUE); //1.7976931348623157E308
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Double.MAX_VALUE); //1.7976931348623157E308
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The range of negative values is the same as the range of the positive numbers,
    only with the minus sign `-` in front of each number. Zero can be either `0.0`
    or `-0.0`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 负值的范围与正数的范围相同，只是在每个数字前面加上减号`-`。零可以是`0.0`或`-0.0`。
- en: Default values of primitive types
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型的默认值
- en: 'After a variable is declared and before it can be used, a value has to be assigned
    to it. As we have mentioned in the *Variable declaration, definition, and initialization*
    section, a local variable must be initialized or assigned a value explicitly.
    For example:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量后，在使用之前必须为其分配一个值。正如我们在*变量声明，定义和初始化*部分中提到的，必须显式初始化或分配值给局部变量。例如：
- en: '```java'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x;
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: int y = 0;
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: int y = 0;
- en: x = 1;
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1;
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But if the variable is declared as a class field (static), an instance (non-static) property,
    or an array component and is not initialized explicitly, it is initialized automatically with
    a default value. The value itself depends on the type of the variable:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果变量被声明为类字段（静态），实例（非静态）属性或数组组件，并且未显式初始化，则会自动使用默认值进行初始化。值本身取决于变量的类型：
- en: For the `byte`,  `short`, `int`, and `long` types, the default value is zero, `0`
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`byte`，`short`，`int`和`long`类型，默认值为零，`0`
- en: For the `float` and `double` types, the default value is positive zero, `0.0`
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`float`和`double`类型，默认值为正零，`0.0`
- en: For the `char` type, the default value is `\u0000` with point code zero
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`char`类型，默认值是`\u0000`，点码为零
- en: For the `boolean` type, the default value is `false`
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`boolean`类型，默认值是`false`
- en: Primitive type literals
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型文字
- en: A literal is the fourth of the Java tokens listed in the *Input types* section.
    It is the representation of a value. We will discuss literals of reference types in
    the *Reference types and String* section. And now we will talk about primitive
    type literals, only.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 文字是*输入类型*部分列出的Java标记中的第四个。它是一个值的表示。我们将在*引用类型和字符串*部分讨论引用类型的文字。现在我们只讨论原始类型的文字。
- en: To demonstrate literals of primitive types, we will use a `LiteralsDemo` program
    in the  `com.packt.javapath.ch05demo` package. You can create it by right-clicking
    on the `com.packt.javapath.ch05demo` package, then selecting New | Class, and
    typing the `LiteralsDemo` class name, as we have described in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示原始类型的文字，我们将在`com.packt.javapath.ch05demo`包中使用一个`LiteralsDemo`程序。您可以通过右键单击`com.packt.javapath.ch05demo`包，然后选择New
    | Class，并输入`LiteralsDemo`类名来创建它，就像我们在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中描述的那样，*你的第一个Java项目*。
- en: 'Among primitive types, literals of the `boolean` type are the simplest. They
    are just two: `true` and `false`. We can demonstrate it by running the following
    code:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始类型中，`boolean`类型的文字是最简单的。它们只有两个：`true`和`false`。我们可以通过运行以下代码来演示：
- en: '```java'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class LiteralsDemo {
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: public class LiteralsDemo {
- en: public static void main(String[] args){
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: 'System.out.println("boolean literal true: " + true);'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("boolean literal true: " + true);'
- en: 'System.out.println("boolean literal false: " + false);'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("boolean literal false: " + false);'
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will look as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/27cb9a73-2087-462e-865c-b651793f84e2.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27cb9a73-2087-462e-865c-b651793f84e2.png)'
- en: These are all possible Boolean literals (values).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是可能的布尔文字（值）。
- en: 'Now, let''s turn to a more complex topic of the literals of the `char` type.
    They can be as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向更复杂的`char`类型文字的话题。它们可以是以下形式：
- en: A single character, enclosed in single quotes
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单个字符，用单引号括起来
- en: An escape sequence, enclosed in single quotes
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个转义序列，用单引号括起来
- en: The single-quote, or apostrophe, is a character with Unicode escape `\u0027` (decimal
    code point 39). We have seen several examples of `char` type literals in the *Integral
    types* section when we demonstrated the `char` type behavior as a numeric type
    in arithmetic operations.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号，或者撇号，是一个具有Unicode转义`\u0027`（十进制代码点39）的字符。当我们在*整数类型*部分演示`char`类型在算术运算中作为数值类型的行为时，我们已经看到了几个`char`类型文字的例子。
- en: 'Here are some other examples of the `char` type literals as single characters:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`char`类型文字作为单个字符的其他示例：
- en: '```java'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println("char literal ''a'': " + ''a'');'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''a'': " + ''a'');'
- en: 'System.out.println("char literal ''%'': " + ''%'');'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''%'': " + ''%'');'
- en: 'System.out.println("char literal ''\u03a9'': " + ''\u03a9''); //Omega'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''\u03a9'': " + ''\u03a9''); //Ω'
- en: 'System.out.println("char literal ''™'': " + ''™''); //Trade mark sign'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("char literal ''™'': " + ''™''); //商标符号'
- en: '```'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，输出将如下所示：
- en: '![](img/58d9eba1-c21a-4754-84ef-2ee7419aee0e.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58d9eba1-c21a-4754-84ef-2ee7419aee0e.png)'
- en: 'Now, let''s talk about the second kind of `char` type literal – an escape sequence.
    It is a combination of characters that acts similarly to control codes. In fact,
    some of the escape sequences include control codes. Here is the full list:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈`char`类型文字的第二种类型 - 转义序列。它是一组类似于控制码的字符组合。实际上，一些转义序列包括控制码。以下是完整列表：
- en: '`\ b` (Backspace BS, Unicode escape `\u0008`)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`（退格BS，Unicode转义`\u0008`）'
- en: '`\ t` (Horizontal tab HT, Unicode escape `\u0009`)'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`（水平制表符HT，Unicode转义`\u0009`）'
- en: '`\ n` (Line feed LF, Unicode escape `\u000a`)'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`（换行LF，Unicode转义`\u000a`）'
- en: '`\ f` (Form feed FF, Unicode escape  `\u000c`)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\f`（换页FF，Unicode转义`\u000c`）'
- en: '`\ r` (Carriage return CR, Unicode escape  `\u000d`)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`（回车CR，Unicode转义`\u000d`）'
- en: '`\ "` (Double quote ", Unicode escape  `\u0022`)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\ "`（双引号"，Unicode转义`\u0022`）'
- en: '`\ ''` (Single quote '', Unicode escape  `\u0027`)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``（单引号''，Unicode转义`\u0027`）'
- en: '`\ \` (Backslash \, Unicode escape  `\u005c`)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`（反斜杠\，Unicode转义`\u005c`）'
- en: 'As you can see, an escape sequence always starts with a backslash (`\`). Let''s
    demonstrate some of the escape sequences usages:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，转义序列总是以反斜杠（`\`）开头。让我们演示一些转义序列的用法：
- en: '```java'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("The line breaks \nhere");
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("The line breaks \nhere");
- en: System.out.println("The tab is\there");
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("The tab is\here");
- en: System.out.println("\"");
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\"");
- en: System.out.println('\'');
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println('\'');
- en: System.out.println('\\');
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println('\\');
- en: '```'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，输出将如下所示：
- en: '![](img/a24ce129-5240-40d3-a07c-bbd43fad874b.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a24ce129-5240-40d3-a07c-bbd43fad874b.png)'
- en: As you can see, the `\n` and `\t` escape sequences act only as control codes.
    They are not printable themselves but affect the display of the text. Other escape
    sequences allow the printing of a symbol in the context that would not allow it
    to be printed otherwise. Three double or single quotes in a row would be qualified
    as a compiler error, as well as a single backslash character if being used without
    a backslash.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`\n`和`\t`转义序列只作为控制码。它们本身不可打印，但会影响文本的显示。其他转义序列允许在其他情况下无法打印的上下文中打印符号。连续三个双引号或单引号将被视为编译器错误，就像单个反斜杠字符在没有反斜杠的情况下使用时一样。
- en: 'By comparison with the `char` type literals, the float-points literals are
    much more straightforward. As we have mentioned before, by default, a `23.45` literal
    has the `double` type and there is no need to append the letter `d` or `D` to
    the literal if you would like it to be of the `double` type. But you can, if you
    prefer to be more explicit.  A `float` type literal, on the other hand, requires
    appending the letter `f` or `F` at the end. Let''s run the following example (notice
    how we use `\n` escape sequence to add a line break before the output):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 与`char`类型文字相比，浮点文字要简单得多。如前所述，默认情况下，`23.45`文字为`double`类型，如果要将其设置为`double`类型，则无需添加字母`d`或`D`。但是，如果您愿意更明确，可以这样做。另一方面，`float`类型文字需要在末尾添加字母`f`或`F`。让我们运行以下示例（请注意我们如何使用`\n`转义序列在输出之前添加换行符）：
- en: '```java'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println("\nfloat literal 123.456f: " + 123.456f);'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n浮点文字123.456f：" + 123.456f);
- en: 'System.out.println("double literal 123.456d: " + 123.456d);'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("双文字123.456d：" + 123.456d);
- en: '```'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result looks as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/f38e82d3-eb09-42d4-946d-6d2e8179e3e2.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f38e82d3-eb09-42d4-946d-6d2e8179e3e2.png)'
- en: 'The floating-point type literals can also be expressed using `e` or `E` for
    scientific notation (see [https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation)):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型文字也可以使用`e`或`E`表示科学计数法（参见[https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation)）：
- en: '```java'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println("\nfloat literal 1.234560e+02f: " + 1.234560e+02f);'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n浮点文字1.234560e+02f：" + 1.234560e+02f);
- en: 'System.out.println("double literal 1.234560e+02d: " + 1.234560e+02d);'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("双文字1.234560e+02d：" + 1.234560e+02d);
- en: '```'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result of the preceding code looks as follows:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果如下：
- en: '![](img/9719f0ac-ec78-41a5-885b-bfcdcd35cb4b.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9719f0ac-ec78-41a5-885b-bfcdcd35cb4b.png)'
- en: As you can see, the value remain the same, whether presented in a decimal format
    or a scientific one.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论以十进制格式还是科学格式呈现，值都保持不变。
- en: 'The literals of the `byte`,  `short`, `int`, and `long` integral types have
    the `int` type by default. The following assignments do not cause any compilation
    errors:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`，`short`，`int`和`long`整数类型的文字默认为`int`类型。以下赋值不会导致任何编译错误：'
- en: '```java'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte b = 10;
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = 10;
- en: short s = 10;
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: short s = 10;
- en: int i = 10;
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 10;
- en: long l = 10;
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: long l = 10;
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But each of the following lines generates an error:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下每一行都会生成错误：
- en: '```java'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte b = 128;
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = 128;
- en: short s = 32768;
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: short s = 32768;
- en: int i = 2147483648;
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2147483648;
- en: long l = 2147483648;
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: long l = 2147483648;
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is because the maximum value the `byte` type can hold is 127, the maximum
    value the `short` type can hold is 32,767, and the maximum value the `int` type
    can hold is 2,147,483,647\. Notice that, although the `long` type can a value
    as big as 9,223,372,036,854,775,807, the last assignment still fails because the 2,147,483,648
    literal has the `int` type by default but exceeds the maximum `int` type value.
    To create a literal of the `long` type, one has to append the letter `l` or `L`
    at the end, so the following assignment works just fine:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`byte`类型可以容纳的最大值为127，`short`类型可以容纳的最大值为32,767，`int`类型可以容纳的最大值为2,147,483,647。请注意，尽管`long`类型可以容纳的最大值为9,223,372,036,854,775,807，但最后一个赋值仍然失败，因为2,147,483,648文字默认为`int`类型，但超过了最大的`int`类型值。要创建`long`类型的文字，必须在末尾添加字母`l`或`L`，因此以下赋值也可以正常工作：
- en: '```java'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long l = 2147483648L;
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: long l = 2147483648L;
- en: '```'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is a good practice to use capital `L` for this purpose because lowercase
    letter `l` can be easily confused with the number `1`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大写`L`是一个好习惯，因为小写字母`l`很容易与数字`1`混淆。
- en: 'The preceding examples of integral literals are expressed in a decimal number
    system. But the literals of the `byte`,  `short`, `int`, and `long` types can
    also be expressed in the binary (base 2, digits 0-1), octal (base 8, digits 0-7),
    and hexadecimal (base 16, digits 0-9 and a-f) number systems. Here is the demonstration
    code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的整数字面值示例是用十进制数系统表示的。但是，`byte`，`short`，`int`和`long`类型的文字也可以用二进制（基数2，数字0-1），八进制（基数8，数字0-7）和十六进制（基数16，数字0-9和a-f）数系统表示。以下是演示代码：
- en: '```java'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("\nPrint literal 12:");
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n打印文字12：");
- en: 'System.out.println("- bin 0b1100: "+ 0b1100);'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 二进制0b1100：" + 0b1100);
- en: 'System.out.println("- oct    014: "+ 014);'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 八进制014：" + 014);
- en: 'System.out.println("- dec     12: "+ 12);'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 十进制12：" + 12);
- en: 'System.out.println("- hex    0xc: "+ 0xc);'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 十六进制0xc：" + 0xc);
- en: '```'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the preceding code, the output will be:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，输出将是：
- en: '![](img/239db86f-5ce2-4211-8ea6-3d63206ac0c1.png)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![](img/239db86f-5ce2-4211-8ea6-3d63206ac0c1.png)'
- en: 'As you can see, a binary literal starts with `0b` (or `0B`), followed by the
    value `12` expressed in a binary system: `1100` (=`2^0*0 + 2^1*0 + 2^2*1 + 2^3
    *1`). An octal literal starts with `0`, followed by the value `12` expressed in
    an octal system: `14` (=`8^0*4 + 8^1*1`). The decimal literal is just `12`. The
    hexadecimal literal starts with `0x` (or with `0X`), followed by value 12 expressed
    in a hexadecimal system—`c` (because in the hexadecimal system the symbols `a`
    to `f`  (or `A` to `F`) map to decimal values `10` to `15`).'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，二进制文字以`0b`（或`0B`）开头，后跟以二进制系统表示的值`12`：`1100`（=`2^0*0 + 2^1*0 + 2^2*1 + 2^3
    *1`）。八进制文字以`0`开头，后跟以八进制系统表示的值`12`：`14`（=`8^0*4 + 8^1*1`）。十进制文字就是`12`。十六进制文字以`0x`（或`0X`）开头，后跟以十六进制系统表示的值12——`c`（因为在十六进制系统中，符号`a`到`f`（或`A`到`F`）对应的是十进制值`10`到`15`）。
- en: 'Adding a minus sign (`-`) in front of a literal makes the value negative, no
    matter which numeric system is used. Here is a demonstration code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在文字前面加上减号（`-`）会使值变为负数，无论使用哪种数字系统。以下是演示代码：
- en: '```java'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("\nPrint literal -12:");
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n打印文字-12：");
- en: 'System.out.println("- bin 0b1100: "+ -0b1100);'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 二进制0b1100：" + -0b1100);
- en: 'System.out.println("- oct    014: "+ -014);'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 八进制014：" + -014);
- en: 'System.out.println("- dec     12: "+ -12);'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 十进制12：" + -12);
- en: 'System.out.println("- hex    0xc: "+ -0xc);'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("- 十六进制0xc：" + -0xc);
- en: '```'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run the preceding code, the output will be as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，输出将如下所示：
- en: '![](img/5382f549-f0de-4017-a6f5-cabe01bd18d1.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5382f549-f0de-4017-a6f5-cabe01bd18d1.png)'
- en: 'And, to complete our discussion of primitive type literals, we would like to
    mention the possible usage of the underscore (`_`) inside a primitive type literal.
    In the case of a long number, breaking it into groups helps to quickly estimate
    its magnitude. Here are a few examples:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了完成我们对原始类型文字的讨论，我们想提到原始类型文字中下划线（`_`）的可能用法。在长数字的情况下，将其分成组有助于快速估计其数量级。以下是一些示例：
- en: '```java'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int speedOfLightMilesSec = 299_792_458;
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: int speedOfLightMilesSec = 299_792_458;
- en: float meanRadiusOfEarthMiles = 3_958.8f;
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: float meanRadiusOfEarthMiles = 3_958.8f;
- en: long creditCardNumber = 1234_5678_9012_3456L;
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: long creditCardNumber = 1234_5678_9012_3456L;
- en: '```'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s see what happens when we run the following code:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行以下代码时会发生什么：
- en: '```java'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long anotherCreditCardNumber = 9876____5678_____9012____1234L;
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: long anotherCreditCardNumber = 9876____5678_____9012____1234L;
- en: System.out.println("\n" + anotherCreditCardNumber);
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n" + anotherCreditCardNumber);
- en: '```'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The output of the previous code would be as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/65d2e9fd-81b4-42f8-b3d6-6c0413218765.png)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65d2e9fd-81b4-42f8-b3d6-6c0413218765.png)'
- en: As you can see, one or many underscores are ignored if placed between digits
    inside a numeric literal. An underscore in any other location would cause a compilation
    error.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果在数字文字中的数字之间放置一个或多个下划线，这些下划线将被忽略。在任何其他位置放置下划线将导致编译错误。
- en: Reference types and String
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型和字符串
- en: When an object is assigned to a variable, this variable holds the reference
    to the memory where the object resides. From a practical standpoint, such a variable
    is handled in the code as if it is the object it represents. The type of such
    a variable can be a class, an interface, an array, or a special `null` type. If
    `null` is assigned, the reference to the object is lost and the variable does
    not represent any object. If an object is not used anymore, JVM removes it from
    the memory in the process called **garbage collection**. We will describe this
    process in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM Processes
    and Garbage Collection*.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象分配给变量时，此变量保存对对象所在内存的引用。从实际的角度来看，这样的变量在代码中被处理，就好像它是所代表的对象一样。这样的变量的类型可以是类、接口、数组或特殊的`null`类型。如果分配了`null`，则对象的引用将丢失，变量不再代表任何对象。如果对象不再使用，JVM将在称为**垃圾收集**的过程中从内存中删除它。我们将在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)中描述这个过程，*JVM进程和垃圾收集*。
- en: There is also a reference type called type variable used for the declaration
    of a type parameter of a generic class, interface, method, or constructor. It
    belongs to the area of Java generic programming that is outside of the scope of
    this book.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为类型变量的引用类型，用于声明泛型类、接口、方法或构造函数的类型参数。它属于Java泛型编程的范畴，超出了本书的范围。
- en: All objects, including arrays, inherit all the methods from the `java.lang.Object`
    class described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象，包括数组，都继承自[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中描述的`java.lang.Object`类的所有方法，*Java语言基础*。
- en: A variable that refers to an object of the `java.lang.String` class (or just
    `String`) is a reference type, too. But, in certain respects, the `String` object
    behaves as a primitive type, which might be confusing at times. That is why we
    will dedicate a section in this chapter to the `String` class.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 引用`java.lang.String`类（或只是`String`）的变量也是引用类型。但在某些方面，`String`对象的行为类似于原始类型，这有时可能会令人困惑。这就是为什么我们将在本章中专门介绍`String`类的原因。
- en: Also, the enum type (a reference type as well) requires special attention and
    we describe it at the end of this section in the *Enum types* subsection.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，枚举类型（也是引用类型）需要特别注意，我们将在本节末尾的*枚举类型*子节中进行描述。
- en: Class types
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类类型
- en: 'A variable of the class type is declared using the corresponding class name:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的类名声明类类型的变量：
- en: '```java'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <Class name> variableName;
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: <类名> variableName;
- en: '```'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class whose name is used for the declaration. If the class has a superclass
    (also called a parent class) from which it inherits (extends), the name of the
    superclass can be used for the variable declaration. It is possible because of
    Java polymorphism, described in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*. For example, if a `SomeClass` class extends `SomeBaseClass`,
    both of the following declarations and initializations are possible:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过将`null`或该类的对象（实例）进行赋值来进行初始化。如果该类有一个超类（也称为父类）从中继承（扩展），则可以使用超类的名称进行变量声明。这是由于Java多态性的存在，该多态性在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中有所描述，*Java语言基础*。例如，如果`SomeClass`类扩展`SomeBaseClass`，则以下声明和初始化都是可能的：
- en: '```java'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: SomeBaseClass someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: '```'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，由于每个类默认都扩展了`java.lang.Object`类，以下声明和初始化也是可能的：
- en: '```java'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Object someBaseClass = new SomeBaseClass();
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: Object someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: '```'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will talk more about assigning child class object to a base class reference
    in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions,
    and Statements*.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更多地讨论将子类对象分配给基类引用的情况，*运算符、表达式和语句*。
- en: Interface types
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口类型
- en: 'A variable of an interface type is declared using the corresponding interface
    name:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的接口名称声明接口类型的变量：
- en: '```java'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <Interface name> variableName;
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: <接口名称> variableName;
- en: '```'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'It can be initialized by assigning to it `null` or an object (an instance)
    of the class that implemented the interface. Here is an example:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过将`null`或实现接口的类的对象（实例）分配给它来进行初始化。这是一个例子：
- en: '```java'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface SomeInterface{
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 接口SomeInterface {
- en: void someMethod();
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）;
- en: '}'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface SomeOtherInterface{
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 接口SomeOtherInterface {
- en: void someOtherMethod();
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: void someOtherMethod（）;
- en: '}'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeClass implements SomeInterface {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass implements SomeInterface {
- en: void someMethod(){
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）{
- en: '...'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeOtherClass implements SomeOtherInterface{
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeOtherClass implements SomeOtherInterface {
- en: void someOtherMethod(){
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: void someOtherMethod（）{
- en: '...'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: SomeInterface someInterface = new SomeClass();
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: SomeInterface someInterface = new SomeClass（）;
- en: someInterface = new SomeOtherClass(); //not possible, error
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface = new SomeOtherClass（）; //不可能，错误
- en: someInterface.someMethod();         //works just fine
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface.someMethod（）; //运行正常
- en: someInterface.someOtherMethod();   //not possible, error
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: someInterface.someOtherMethod（）; //不可能，错误
- en: '```'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will talk more about assigning child type to a base type reference in [Chapter
    9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators, Expressions, and Statements*.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章]（33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml）中更多地讨论将子类型分配给基类型引用。
- en: Arrays
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array in Java is a reference type and extends (inherits from) the `Object` class,
    too. An array contains components that have the same type as the declared array
    type or the type whose values can be assigned to the array type. The number of
    components may be zero, in which case the array is an empty array.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数组是引用类型，并且也扩展（继承自）`Object`类。数组包含与声明的数组类型相同的类型的组件，或者可以将值分配给数组类型的类型。组件的数量可以为零，在这种情况下，数组为空数组。
- en: An array component has no name and is referenced by an index, which is a positive
    integer or zero.  An array with `n` components is said to have *length of n*. Once
    an array object is created, its length never changes.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 数组组件没有名称，并且由索引引用，该索引是正整数或零。说具有*n*长度的`n`个组件的数组。一旦创建数组对象，其长度就永远不会改变。
- en: 'An array declaration starts with a type name and empty brackets `[]`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明以类型名称和空括号`[]`开头：
- en: '```java'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte[] bs;
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: byte [] bs;
- en: long[][] ls;
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: long [] [] ls;
- en: Object[][] os;
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] [] os;
- en: SomeClass[][][] scs;
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass [] [] [] scs;
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The number of bracket pairs indicates the number of dimensions (or the nesting
    depth) of the array.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 括号对的数量表示数组的维数（或嵌套深度）。
- en: 'There are two ways to create and initialize an array:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建和初始化数组的方法：
- en: 'By creation expression, using the `new` keyword, type name, and brackets with
    the length of each dimension in each pair of brackets; for example:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建表达式，使用`new`关键字，类型名称和每个括号中每个维度的长度的括号;例如：
- en: '```java'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte[] bs = new byte[100];
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: byte [] bs = new byte [100];
- en: long[][] ls = new long [2][3];
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: long [] [] ls = new long [2] [3];
- en: Object[][] os = new Object[3][2];
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] [] os = new Object [3] [2];
- en: SomeClass[][][] scs = new SomeClass[3][2][1];
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass [] [] [] scs = new SomeClass [3] [2] [1];
- en: '```'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'By array initializer, using a comma-separated list of values of each dimension,
    surrounded by braces, for example:'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数组初始化程序，使用由大括号括起来的每个维度的逗号分隔值的列表，例如：
- en: '```java'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = { { 1, 2, 3 }, { 10, 20 }, { 3, 4, 5, 6 } };
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = {{1, 2, 3}, {10, 20}, {3, 4, 5, 6}};
- en: float[][] fs = { { 1.1f, 2.2f, 3 }, { 10, 20.f, 30.f } };
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: float [] [] fs = {{1.1f，2.2f，3}，{10，20.f，30.f}};
- en: Object[] oss = { new Object(), new SomeClass(), null, "abc" };
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Object [] oss = {new Object（），new SomeClass（），null，“abc”};
- en: SomeInterface[] sis = { new SomeClass(), null, new SomeClass() };
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: SomeInterface [] sis = {new SomeClass（），null，new SomeClass（）};
- en: '```'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see from these examples, a multidimensional array can contain arrays
    of different lengths (the `int[][] is` array). Also, a component type value can
    be different from the array type as long as the value can be assigned to the variable
    of the array type (the `float[][] fs`, `Object[] is`, and `SomeInterface[] sis` arrays).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中可以看出，多维数组可以包含不同长度的数组（`int [] [] is`数组）。此外，只要值可以分配给数组类型的变量（`float [] []
    fs`，`Object [] is`和`SomeInterface [] sis`数组），组件类型值可以与数组类型不同。
- en: 'Because an array is an object, its components are initialized every time an
    array is created. Let''s consider this example:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是对象，所以每次创建数组时都会初始化其组件。让我们考虑这个例子：
- en: '```java'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][3];
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [3];
- en: System.out.println("\nis.length=" + is.length);
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“\ nis.length =” + is.length）;
- en: System.out.println("is[0].length=" + is[0].length);
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] .length =” + is [0] .length）;
- en: System.out.println("is[0][0].length=" + is[0][0]);
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [0] .length =” + is [0] [0]）;
- en: System.out.println("is[0][1].length=" + is[0][1]);
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [1] .length =” + is [0] [1]）;
- en: System.out.println("is[0][2].length=" + is[0][2]);
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] [2] .length =” + is [0] [2]）;
- en: System.out.println("is[1].length=" + is[0].length);
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] .length =” + is [0] .length）;
- en: System.out.println("is[1][0].length=" + is[1][0]);
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [0] .length =” + is [1] [0]）;
- en: System.out.println("is[1][1].length=" + is[1][1]);
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [1] .length =” + is [1] [1]）;
- en: System.out.println("is[1][2].length=" + is[1][2]);
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] [2] .length =” + is [1] [2]）;
- en: '```'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the preceding code snippet, the output will be as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码片段，输出将如下所示：
- en: '![](img/a2463ad3-fe53-43ab-9e19-511714b556cf.png)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / a2463ad3-fe53-43ab-9e19-511714b556cf.png）
- en: 'It is possible to create a multidimensional array without initializing some
    of the dimensions:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不初始化某些维度的情况下创建多维数组：
- en: '```java'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][];
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [];
- en: System.out.println("\nis.length=" + is.length);
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“\ nis.length =” + is.length）;
- en: System.out.println("is[0]=" + is[0]);
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [0] =” + is [0]）;
- en: System.out.println("is[1]=" + is[1]);
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“is [1] =” + is [1]）;
- en: '```'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result of this code running is as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码运行的结果如下：
- en: '![](img/9c7279b2-2fe4-48b6-aa7e-b42fae6c43e1.png)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 9c7279b2-2fe4-48b6-aa7e-b42fae6c43e1.png）
- en: 'The missing dimension can be added later:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的维度可以稍后添加：
- en: '```java'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][] is = new int[2][];
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: int [] [] is = new int [2] [];
- en: is[0] = new int[3];
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: is [0] = new int [3];
- en: is[1] = new int[3];
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: is [1] = new int [3];
- en: '```'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The important point is that a dimension has to be initialized before it can
    be used.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，必须在使用之前初始化维度。
- en: Default value of a reference type
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型的默认值
- en: The default value of a reference type is `null`. It means that if a reference
    type is a static class member or an instance field and not assigned an initial
    value explicitly, it will be initialized automatically and assigned the value
    of `null`. Please note that, in the case of an array, this applies to the array
    itself and to its reference type components.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的默认值是`null`。这意味着如果引用类型是静态类成员或实例字段，并且没有显式分配初始值，它将自动初始化并分配`null`的值。请注意，在数组的情况下，这适用于数组本身和其引用类型组件。
- en: Reference type literals
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型字面量
- en: 'The `null` literal indicates the absence of any assignment to a reference type
    variable. Let''s look at the following code snippet:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`字面量表示没有对引用类型变量的任何赋值。让我们看下面的代码片段：'
- en: '```java'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeClass someClass = new SomeClass();
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass someClass = new SomeClass();
- en: someClass.someMethod();
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: someClass.someMethod();
- en: someClass = null;
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: someClass = null;
- en: someClass.someMethod(); // throws NullPointerException
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: someClass.someMethod(); // 抛出NullPointerException
- en: '```'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first statement declares the `someClass` variable and assigns to it a reference
    to the object of the `SomeClass` class. Then a method of this class is called
    using its reference. The next line assigns the `null` literal to the `someClass` variable.
    It removes the reference value from the variable. So, when in the next line, we
    try to call the same method again, we get back `NullPointerException`, which happens
    only when a reference used is assigned the `null` value.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句声明了`someClass`变量，并为其分配了`SomeClass`类对象的引用。然后使用其引用调用了该类的一个方法。接下来的一行将`null`字面量赋给`someClass`变量。它从变量中移除了引用值。因此，当在下一行中我们尝试再次调用相同的方法时，我们会得到`NullPointerException`，这只有在使用的引用被赋予`null`值时才会发生。
- en: The `String` type is a reference type, too. This means that the default value
    of a `String` variable is `null`. The `String` class inherits all the methods
    from the `java.lang.Object` class as any other reference type does, too.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类型也是一个引用类型。这意味着`String`变量的默认值是`null`。`String`类从`java.lang.Object`类继承了所有方法，就像其他引用类型一样。'
- en: But in some respects, objects of the `String` class behave as if they are of
    a primitive type. We will discuss one such case—when the `String` object is used
    as a method parameter—in the *Passing reference type values as method parameters* section.
    We will discuss other cases of `String` behaving like a primitive type now.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些方面，`String`类的对象的行为就像原始类型一样。我们将讨论一个这样的情况——当`String`对象用作方法参数时——在*将引用类型值作为方法参数传递*部分。我们现在将讨论`String`类像原始类型一样行为的其他情况。
- en: 'Another feature of the `String` type that makes it look like a primitive type
    is that it is the only reference type that has more literals than just `null`.
    The type `String` can also have a literal of zero or more characters enclosed
    in double quotes—`""`, `"$"`, `"abc"`, and `"12-34"`. The characters of the `String`
    literal may include escape sequences, too. Here are a few examples:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类型的另一个特性使它看起来像一个原始类型的是，它是唯一一个不仅仅只有`null`字面量的引用类型。`String`类型也可以有零个或多个字符的字面量，用双引号括起来——`""`，`"$"`，`"abc"`和`"12-34"`。`String`字面量的字符也可以包括转义序列。以下是一些例子：'
- en: '```java'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("\nFirst line.\nSecond line.");
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n第一行。\n第二行。");
- en: System.out.println("Tab space\tin the line");
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("制表符\t在行中");
- en: System.out.println("It is called a \"String literal\".");
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("它被称为\"字符串字面量\"。");
- en: 'System.out.println("Latin Capital Letter Y with diaeresis: \u0178");'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("拉丁大写字母Y与分音符：\u0178");
- en: '```'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you execute the preceding code snippet, the output will be as follows:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行上述代码片段，输出将如下所示：
- en: '![](img/c4ff739c-3cd1-4b9a-8900-8273a4536a18.png)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4ff739c-3cd1-4b9a-8900-8273a4536a18.png)'
- en: 'But, in contrast with the `char` type literals, `String` literals do not behave
    like numbers in an arithmetic operation. The only arithmetic operation applicable
    to the `String` type is an addition, and it behaves like a concatenation:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与`char`类型字面量相反，`String`字面量在算术运算中不像数字那样行为。`String`类型适用的唯一算术运算是加法，它的行为类似于连接：
- en: '```java'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("s1" + "s2");
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("s1" + "s2");
- en: String s1 = "s1";
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = "s1";
- en: System.out.println(s1 + "s2");
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1 + "s2");
- en: String s2 = "s1";
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = "s1";
- en: System.out.println(s1 + s2);
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1 + s2);
- en: '```'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the preceding code and you will see the following:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，你会看到以下内容：
- en: '![](img/7d0600b2-bac7-4769-a95f-4e7596b5f802.png)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d0600b2-bac7-4769-a95f-4e7596b5f802.png)'
- en: Another particular characteristic of `String` is that an object of the `String` type is
    immutable.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`的另一个特点是，`String`类型的对象是不可变的。'
- en: String immutability
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串的不可变性
- en: 'One cannot change the `String` type value assigned to a variable without changing
    the reference. There are several reasons why JVM authors decided to do that:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 不能改变分配给变量的`String`类型值而不改变引用。JVM作者决定这样做有几个原因：
- en: 'All `String` literals are stored in the same common memory area, called string
    pool. Before a new `String` literal is stored, the JVM checks whether such a literal
    is already stored there. If such an object exists already, a new object is not
    created and the reference to the existing object is returned as the reference
    to a new object. The following code demonstrates this situation:'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的`String`字面量都存储在同一个称为字符串池的共同内存区域中。在存储新的`String`字面量之前，JVM会检查是否已经存储了这样的字面量。如果这样的对象已经存在，就不会创建新对象，而是返回对现有对象的引用作为对新对象的引用。以下代码演示了这种情况：
- en: '```java'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("s1" == "s1");
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("s1" == "s1");
- en: System.out.println("s1" == "s2");
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("s1" == "s2");
- en: String s1 = "s1";
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = "s1";
- en: System.out.println(s1 == "s1");
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1 == "s1");
- en: System.out.println(s1 == "s2");
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1 == "s2");
- en: String s2 = "s1";
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = "s1";
- en: System.out.println(s1 == s2);
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1 == s2);
- en: '```'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code, we use the `==` relational operator, which is used to
    compare values of primitive types and references of reference types. If we run
    this code, the result will be as follows:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了`==`关系运算符，它用于比较原始类型的值和引用类型的引用。如果我们运行这段代码，结果将如下所示：
- en: '![](img/728b25a9-08ca-45aa-a329-f818a04f7801.png)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![](img/728b25a9-08ca-45aa-a329-f818a04f7801.png)'
- en: You can see that the various comparisons of literals (directly or via a variable)
    consistently yield `true` if two literals have the same spelling, and produce
    `false` if the spelling is different. This way, long `String` literals are not
    duplicated and the memory is used better.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，文字的各种比较（直接或通过变量）始终在两个文字拼写相同的情况下产生`true`，并且在拼写不同的情况下产生`false`。这样，长`String`文字不会被复制，内存使用更好。
- en: 'To avoid concurrent modification of the same literal by different methods,
    every time we attempt to change the `String` literal, a copy of the literal with
    the change is created, while the original `String` literal remains untouched.
    Here is the code that demonstrates it:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不同方法同时修改相同文字的并发修改，每次我们尝试改变`String`文字时，都会创建一个带有更改的文字副本，而原始的`String`文字保持不变。以下是演示它的代码：
- en: '```java'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s1 = "\nthe original string";
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = "\nthe original string";
- en: String s2 = s1.concat(" has been changed");
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = s1.concat(" has been changed");
- en: System.out.println(s2);
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s2);
- en: System.out.println(s1);
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s1);
- en: '```'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `concat()` method of the `String` class adds another `String` literal to
    the original value of `s1` and assigns the result to the `s1` variable. The output
    of this code is as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类的`concat()`方法将另一个`String`文字添加到`s1`的原始值，并将结果分配给`s1`变量。此代码的输出如下：'
- en: '![](img/9007f810-5f17-47ab-a3f9-2f3a8ae6112a.png)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9007f810-5f17-47ab-a3f9-2f3a8ae6112a.png)'
- en: As you can see, the original literal assigned to `s1` did not change.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，分配给`s1`的原始文字没有改变。
- en: Another reason for such a design decision is security – one of the highest-priority
    goals JVM's authors had in mind. `String` literals are widely used as username
    and passwords to access an application, database, and server. Immutability of
    the `String` value makes it less susceptible to an unauthorized modification.
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样设计的另一个原因是安全性-这是JVM作者所考虑的最高优先级目标之一。`String`文字广泛用作用户名和密码，用于访问应用程序、数据库和服务器。`String`值的不可变性使其不太容易受到未经授权的修改。
- en: Yet another reason is that there are certain calculation-intensive procedures
    (the `hashCode()` method in the `Object` parent class, for example) that could
    be quite taxing in the case of long `String` values. By making the `String` object
    immutable, such a calculation could be avoided if it was already performed on
    the value with the same spelling.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个原因是，有一些计算密集型的过程（例如`Object`父类中的`hashCode()`方法）在长`String`值的情况下可能会相当耗费资源。通过使`String`对象不可变，如果已经对具有相同拼写的值执行了这样的计算，就可以避免这样的计算。
- en: That is why all methods that modify a `String` value return the `String` type,
    which is the reference to a new `String` object that carries the result. The `concat()` method
    in the preceding code is a typical example of such a method.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么所有修改`String`值的方法都返回`String`类型的原因，它是指向携带结果的新`String`对象的引用。前面代码中的`concat()`方法就是这种方法的典型例子。
- en: 'The matter becomes a bit more complicated in the case where a `String` object
    is created not from the literal, but using the `String` constructor, `new String("some
    literal")`. In such a case, the `String` object is stored in the same area where
    all objects of all classes are stored, and every time a `new` keyword is used,
    another chunk of memory (with another reference) is allocated. Here is the code
    that demonstrates it:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在`String`对象不是从文字创建的情况下，情况变得有些复杂，而是使用`String`构造函数`new String("some literal")`。在这种情况下，`String`对象存储在存储所有类的所有对象的相同区域，并且每次使用`new`关键字时，都会分配另一块内存（具有另一个引用）。以下是演示它的代码：
- en: '```java'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s3 = new String("s");
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: String s3 = new String("s");
- en: String s4 = new String("s");
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: String s4 = new String("s");
- en: System.out.println(s3 == s4);
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s3 == s4);
- en: '```'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run it, the output will be as follows:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，输出将如下：
- en: '![](img/7d538290-5e7b-49af-a1e5-48067df41fba.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d538290-5e7b-49af-a1e5-48067df41fba.png)'
- en: 'As you can see, despite the same spelling, the objects have different memory
    references. To avoid confusion and to compare the `String` objects by their spelling
    only, always use the `equals()` method of the `String` class. Here is the code
    that demonstrates its usage:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，尽管拼写相同，但对象具有不同的内存引用。为了避免混淆并仅通过拼写比较`String`对象，始终使用`String`类的`equals()`方法。以下是演示其用法的代码：
- en: '```java'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println("s5".equals("s5"));  //true
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("s5".equals("s5"));  //true
- en: System.out.println("s5".equals("s6"));  //false
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("s5".equals("s6"));  //false
- en: String s5 = "s5";
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: String s5 = "s5";
- en: System.out.println(s5.equals("s5"));   //true
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s5.equals("s5"));   //true
- en: System.out.println(s5.equals("s6"));   //false
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s5.equals("s6"));   //false
- en: String s6 = "s6";
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: String s6 = "s6";
- en: System.out.println(s5.equals(s5));     //true
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s5.equals(s5));     //true
- en: System.out.println(s5.equals(s6));     //false
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s5.equals(s6));     //false
- en: String s7 = "s6";
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: String s7 = "s6";
- en: System.out.println(s7.equals(s6));     //true
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s7.equals(s6));     //true
- en: String s8 = new String("s6");
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: String s8 = new String("s6");
- en: System.out.println(s8.equals(s7));     //true
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s8.equals(s7));     //true
- en: String s9 = new String("s9");
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: String s9 = new String("s9");
- en: System.out.println(s8.equals(s9));     //false
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s8.equals(s9));     //false
- en: '```'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run it, the result will be:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，结果将是：
- en: '![](img/5dc62d29-e4c1-47de-99d1-6f0a32eedba6.png)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dc62d29-e4c1-47de-99d1-6f0a32eedba6.png)'
- en: We added the results as the comments to the preceding code for your convenience.
    As you can see, the `equals()` method of the `String` class returns `true` or
    `false` based only on the spelling of the value, so use it all the time when spelling
    comparison is your goal.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果添加为前面代码的注释，以方便您查看。正如你所看到的，`String`类的`equals()`方法仅基于值的拼写返回`true`或`false`，因此当拼写比较是你的目标时，始终使用它。
- en: 'By the way, you may remember that the `equals()` method is defined in the `Object` class—the
    parent class of the `String` class. The `String` class has its own `equals()` method
    that overrides the method with the same signature in the parent class as we have
    demonstrated in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*. The source code of the `equals()` method of the `String` class
    looks as follows:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可能记得`equals()`方法是在`Object`类中定义的——`String`类的父类。`String`类有它自己的`equals()`方法，它覆盖了父类中具有相同签名的方法，就像我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中展示的那样，*Java语言基础*。`String`类的`equals()`方法的源代码如下：
- en: '```java'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean equals(Object anObject) {
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object anObject) {
- en: if (this == anObject) {
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == anObject) {
- en: return true;
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (anObject instanceof String) {
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: if (anObject instanceof String) {
- en: String aString = (String)anObject;
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: String aString = (String)anObject;
- en: if (coder() == aString.coder()) {
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: if (coder() == aString.coder()) {
- en: return isLatin1() ?
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 返回是否为Latin1？
- en: StringLatin1.equals(value, aString.value)
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: StringLatin1.equals(value, aString.value)
- en: ': StringUTF16.equals(value, aString.value);'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: ': StringUTF16.equals(value, aString.value);'
- en: '}'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, it compares references first and, if they point to the same
    object, returns `true`. But, if the references are different, it compares the
    spelling of the values, which actually happens in the `equals()` method of the `StringLatin1`
    and `StringUTF16` classes.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它首先比较引用，如果它们指向相同的对象，则返回`true`。但是，如果引用不同，它会比较值的拼写，这实际上发生在`StringLatin1`和`StringUTF16`类的`equals()`方法中。
- en: The point we would like you to take away is that the `equals()` method of the `String` class
    is optimized by performing the comparison of references first and, only if not
    successful, it comparing the values themselves. Which means there is no need to
    compare references in the code. Instead, for `String` type object comparison, always
    use the `equals()` method only.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能明白`String`类的`equals()`方法通过首先执行引用比较来进行优化，只有在不成功时才比较值本身。这意味着在代码中不需要比较引用。相反，对于`String`类型的对象比较，总是只使用`equals()`方法。
- en: With that, we are moving to the last of the reference types we will discuss
    in this chapter—the `enum` type.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就进入了本章讨论的最后一个引用类型——`enum`类型。
- en: Enum types
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'Before describing the `enum` type, let''s look at one of the use cases as the
    motivation for having such a type. Let''s assume we would like to create a class
    that describes `TheBlows` family:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述`enum`类型之前，让我们看一个使用案例作为拥有这种类型的动机。假设我们想创建一个描述`TheBlows`家庭的类：
- en: '```java'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class TheBlows {
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: public class TheBlows {
- en: private String name, relation, hobby = "biking";
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, relation, hobby = "biking";
- en: private int age;
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: public TheBlows(String name, String relation, int age) {
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: public TheBlows(String name, String relation, int age) {
- en: this.name = name;
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.relation = relation;
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: this.relation = relation;
- en: this.age = age;
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: '}'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getName() { return name; }
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return name; }
- en: public String getRelation() { return relation; }
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: public String getRelation() { return relation; }
- en: public int getAge() { return age; }
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return age; }
- en: public String getHobby() { return hobby; }
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: public String getHobby() { return hobby; }
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: public void setHobby(String hobby) { this.hobby = hobby; }
- en: '}'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We have set the default hobby as `biking` and will allow to change it later,
    but other properties have to be set during object construction. That would fine,
    except we do not want to have more than four members of this family in the system,
    as we know all the members of `TheBlows` family very well.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将默认爱好设置为`骑车`，并允许稍后更改，但其他属性必须在对象构造期间设置。这很好，除了我们不想在系统中有超过四个这个家庭的成员，因为我们非常了解`TheBlows`家庭的所有成员。
- en: 'To impose these restrictions, we decided to create all possible objects of
    the `TheBlows` class up-front and make the constructor private:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强加这些限制，我们决定提前创建`TheBlows`类的所有可能对象，并将构造函数设为私有：
- en: '```java'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class TheBlows {
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: public class TheBlows {
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
- en: public static TheBlows BECKY = new TheBlows("BECKY", "mother", 37);
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BECKY = new TheBlows("BECKY", "mother", 37);
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
- en: private String name, relation, hobby = "biking";
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, relation, hobby = "biking";
- en: private int age;
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private TheBlows(String name, String relation, int age) {
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: private TheBlows(String name, String relation, int age) {
- en: this.name = name;
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.relation = relation;
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: this.relation = relation;
- en: this.age = age;
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: '}'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getName() { return name; }
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return name; }
- en: public String getRelation() { return relation; }
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: public String getRelation() { return relation; }
- en: public int getAge() { return age; }
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return age; }
- en: public String getHobby() { return hobby; }
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: public String getHobby() { return hobby; }
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: public void setHobby(String hobby) { this.hobby = hobby; }
- en: '}'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now only the four instances of the `TheBlows` class exist and no other object
    of this class can be created. Let''s see what happens if we run the following
    code:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有`TheBlows`类的四个实例存在，这个类的其他对象都不能被创建。让我们看看如果运行以下代码会发生什么：
- en: '```java'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(TheBlows.BILL.getName());
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(TheBlows.BILL.getName());
- en: System.out.println(TheBlows.BILL.getHobby());
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(TheBlows.BILL.getHobby());
- en: TheBlows.BILL.setHobby("fishing");
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: TheBlows.BILL.setHobby("fishing");
- en: System.out.println(TheBlows.BILL.getHobby());
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(TheBlows.BILL.getHobby());
- en: '```'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We will get the following output:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/c1cc72d3-55bb-46b8-901b-e202ec027a79.png)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1cc72d3-55bb-46b8-901b-e202ec027a79.png)'
- en: 'Similarly, we can create the `TheJohns` family with three family members:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以创建`TheJohns`家庭，有三个家庭成员：
- en: '```java'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class TheJohns {
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: public class TheJohns {
- en: public static TheJohns JOE = new TheJohns("Joe", "father", 42);
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheJohns JOE = new TheJohns("Joe", "father", 42);
- en: public static TheJohns JOAN = new TheJohns("Joan", "mother", 37);
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheJohns JOAN = new TheJohns("Joan", "mother", 37);
- en: public static TheJohns JILL = new TheJohns("Jill", "daughter", 5);
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheJohns JILL = new TheJohns("Jill", "daughter", 5);
- en: private String name, relation, hobby = "joggling";
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, relation, hobby = "joggling";
- en: private int age;
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private TheJohns(String name, String relation, int age) {
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: private TheJohns(String name, String relation, int age) {
- en: this.name = name;
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.relation = relation;
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: this.relation = relation;
- en: this.age = age;
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: '}'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getName() { return name; }
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return name; }
- en: public String getRelation() { return relation; }
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: public String getRelation() { return relation; }
- en: public int getAge() { return age; }
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return age; }
- en: public String getHobby() { return hobby; }
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: public String getHobby() { return hobby; }
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: public void setHobby(String hobby) { this.hobby = hobby; }
- en: '}'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'While doing that, we noticed a lot of commonalities in these two classes and
    decided to create a `Family` base class:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 'While doing that, we noticed a lot of commonalities in these two classes and
    decided to create a `Family` base class:'
- en: '```java'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Family {
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: public class Family {
- en: private String name, relation, hobby;
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, relation, hobby;
- en: private int age;
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: protected Family(String name, String relation, int age, String hobby) {
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: protected Family(String name, String relation, int age, String hobby) {
- en: this.name = name;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.relation = relation;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: this.relation = relation;
- en: this.age = age;
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: this.hobby = hobby;
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: this.hobby = hobby;
- en: '}'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getName() { return name; }
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return name; }
- en: public String getRelation() { return relation; }
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: public String getRelation() { return relation; }
- en: public int getAge() { return age; }
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return age; }
- en: public String getHobby() { return hobby; }
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: public String getHobby() { return hobby; }
- en: public void setHobby(String hobby) { this.hobby = hobby; }
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: public void setHobby(String hobby) { this.hobby = hobby; }
- en: '}'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now the `TheBlows` and `TheJohns` classes can be substantially simplified after
    extending the `Family` class. Here''s how the `TheBlows` class can now look:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now the `TheBlows` and `TheJohns` classes can be substantially simplified after
    extending the `Family` class. Here''s how the `TheBlows` class can now look:'
- en: '```java'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class TheBlows extends Family {
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: public class TheBlows extends Family {
- en: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BILL = new TheBlows("Bill", "father", 42);
- en: public static TheBlows BECKY = new TheBlows("Becky", "mother", 37);
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BECKY = new TheBlows("Becky", "mother", 37);
- en: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BEE = new TheBlows("Bee", "daughter", 5);
- en: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: public static TheBlows BOB = new TheBlows("Bob", "son", 3);
- en: private TheBlows(String name, String relation, int age) {
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: private TheBlows(String name, String relation, int age) {
- en: super(name, relation, age, "biking");
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: super(name, relation, age, "biking");
- en: '}'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: And that is the idea behind the `enum` type—to allow the creating of classes
    with a fixed number of named instances.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: And that is the idea behind the `enum` type—to allow the creating of classes
    with a fixed number of named instances.
- en: 'The `enum` reference type class extends the `java.lang.Enum` class. It defines
    the set of constants, each of them an instance of the `enum` type it belongs to.
    The declaration of such a set starts with the `enum` keyword. Here is an example:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `enum` reference type class extends the `java.lang.Enum` class. It defines
    the set of constants, each of them an instance of the `enum` type it belongs to.
    The declaration of such a set starts with the `enum` keyword. Here is an example:'
- en: '```java'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season { SPRING, SUMMER, AUTUMN, WINTER }
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: enum Season { SPRING, SUMMER, AUTUMN, WINTER }
- en: '```'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Each of the listed items—`SPRING`, `SUMMER`, `AUTUMN`, and `WINTER`—is an instance
    of `Season`. They are the only four instances of the `Season` class that can exist
    in an application. No other instance of the `Season` class can be created. And
    that is the reason for the creation of the `enum` type: it can be used for cases
    when the list of instances of a class has to be limited to the fixed set, such
    as the list of possible seasons.'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 'Each of the listed items—`SPRING`, `SUMMER`, `AUTUMN`, and `WINTER`—is an instance
    of `Season`. They are the only four instances of the `Season` class that can exist
    in an application. No other instance of the `Season` class can be created. And
    that is the reason for the creation of the `enum` type: it can be used for cases
    when the list of instances of a class has to be limited to the fixed set, such
    as the list of possible seasons.'
- en: 'The `enum` declaration can also be written in a camel-case style:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `enum` declaration can also be written in a camel-case style:'
- en: '```java'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season { Spring, Summer, Autumn, Winter }
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: enum Season { Spring, Summer, Autumn, Winter }
- en: '```'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But the all-uppercase style is used more often because, as we mentioned earlier,
    the static final constant's identifiers in Java programming are written this way
    by convention, in order to distinguish them from the non-constant variable. And
    `enum` constants are static and final implicitly.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: But the all-uppercase style is used more often because, as we mentioned earlier,
    the static final constant's identifiers in Java programming are written this way
    by convention, in order to distinguish them from the non-constant variable. And
    `enum` constants are static and final implicitly.
- en: 'Let''s review an example of the `Season` class usage. Here is a method that
    prints different messages, depending on the season:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s review an example of the `Season` class usage. Here is a method that
    prints different messages, depending on the season:'
- en: '```java'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void enumDemo(Season season){
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: void enumDemo(Season season){
- en: if(season == Season.WINTER){
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: if(season == Season.WINTER){
- en: System.out.println("Dress up warmer");
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Dress up warmer");
- en: '} else {'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("You can drees up lighter now");
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("You can drees up lighter now");
- en: '}'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s see what happens if we run the following two lines:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s see what happens if we run the following two lines:'
- en: '```java'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enumDemo(Season.WINTER);
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo(Season.WINTER);
- en: enumDemo(Season.SUMMER);
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo(Season.SUMMER);
- en: '```'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be as follows:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result will be as follows:'
- en: '![](img/8f4d8e93-b7b4-44af-9713-a1a9f6cd14ca.png)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f4d8e93-b7b4-44af-9713-a1a9f6cd14ca.png)'
- en: 'You probably have noticed that we used an `==` operator that compares references.
    That is because the `enum` instances (as all static variables) exist uniquely
    in memory. And the `equals()` method (implemented in the `java.lang.Enum` parent
    class) brings the same result. Let''s run the following code:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 'You probably have noticed that we used an `==` operator that compares references.
    That is because the `enum` instances (as all static variables) exist uniquely
    in memory. And the `equals()` method (implemented in the `java.lang.Enum` parent
    class) brings the same result. Let''s run the following code:'
- en: '```java'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Season season = Season.WINTER;
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: Season season = Season.WINTER;
- en: System.out.println(Season.WINTER == season);
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Season.WINTER == season);
- en: System.out.println(Season.WINTER.equals(season));
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Season.WINTER.equals(season));
- en: '```'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result will be:'
- en: '![](img/e650d658-2e63-40ec-8205-ff45287ac8aa.png)'
  id: totrans-937
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e650d658-2e63-40ec-8205-ff45287ac8aa.png)'
- en: 'The reason for this is that the `equals()` method of the `java.lang.Enum` class
    is implemented as follows:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`java.lang.Enum`类的`equals()`方法是这样实现的：
- en: '```java'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public final boolean equals(Object other) {
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: public final boolean equals(Object other) {
- en: return this == other;
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 返回this == other;
- en: '}'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, it does exactly the same comparison of two objects references – `this`
    (the reserved keyword that refers the current object) and the reference to another
    object. If you wonder why the parameter has the `Object` type, we would like to
    remind you that all reference types, including `enum` and `String`, extend `java.lang.Object`.
    They do it implicitly.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它确切地比较了两个对象引用-`this`（指代当前对象的保留关键字）和对另一个对象的引用。如果您想知道为什么参数具有`Object`类型，我们想提醒您，所有引用类型，包括`enum`和`String`，都扩展了`java.lang.Object`。它们是隐式的。
- en: 'Other useful methods of `java.lang.Enum` are as follows:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Enum`的其他有用方法如下：'
- en: '`name()`: Returns the enum constant''s identifier as it is spelled when declared.'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`: 返回`enum`常量的标识符，就像在声明时拼写的那样。'
- en: '`ordinal()`: Returns the integer that corresponds to the position of the enum
    constant when declared (the first in the list has an ordinal value of zero).'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordinal()`: 返回与枚举常量在声明时的位置相对应的整数（列表中的第一个枚举常量的序数值为零）。'
- en: '`valueOf()`: Returns the `enum` constant object by its name.'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valueOf()`: 根据其名称返回`enum`常量对象。'
- en: '`toString()`: Returns the same value as the `name()` method by default, but
    can be overridden to return any other `String` value.'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`: 默认情况下返回与`name()`方法相同的值，但可以被重写以返回任何其他`String`值。'
- en: '`values()`: A static method you will not find in the documentation of the `java.lang.Enum` class. In
    the Java Specification, section 8.9.3 ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    it is described as implicitly declared and the Java Tutorial ([https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html))
    states that the compiler *automatically adds some special methods when it creates
    an enum*.'
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 在`java.lang.Enum`类的文档中找不到的静态方法。在Java规范的8.9.3节（[https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)）中，它被描述为隐式声明的，而Java教程（[https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)）则指出编译器*在创建枚举时会自动添加一些特殊方法*。'
- en: Among them, a static `values()` method that returns an array containing all
    of the values of the `enum` in the order they are declared.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，一个静态的`values()`方法返回一个包含`enum`的所有值的数组，按照它们被声明的顺序。
- en: 'Let''s look at an example of their usage. Here is the `enum` class we will
    use for the demo:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个它们用法的例子。这是我们将用于演示的`enum`类：
- en: '```java'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season {
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举Season {
- en: SPRING, SUMMER, AUTUMN, WINTER;
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: SPRING, SUMMER, AUTUMN, WINTER;
- en: '}'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the following is the code that uses it:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用它的代码：
- en: '```java'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Season.SPRING.name());
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Season.SPRING.name());
- en: System.out.println(Season.SUMMER.ordinal());
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Season.SUMMER.ordinal());
- en: System.out.println(Enum.valueOf(Season.class, "AUTUMN"));
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Enum.valueOf(Season.class, "AUTUMN"));
- en: System.out.println(Season.WINTER.name());
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Season.WINTER.name());
- en: '```'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The output of the preceding snippet is as follows:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段的输出如下：
- en: '![](img/739ed513-aced-4e9c-b307-407928949fd4.png)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739ed513-aced-4e9c-b307-407928949fd4.png)'
- en: 'The first line is the output of the `name()` method. The second—is the return
    value of the `ordinal()` method: the `SUMMER` constant is the second in the list,
    so its ordinal value is 1\. The third line is the result of the `toString()` method
    applied to the `enum` constant of `AUTUMN` returned by the `valueOf()` method.
    And the last—is the result of the `toString()` method applied to the `WINTER` constant.'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是`name()`方法的输出。第二行是`ordinal()`方法的返回值：`SUMMER`常量在列表中是第二个，因此其序数值为1。第三行是应用于`valueOf()`方法返回的`AUTUMN`的`enum`常量的`toString()`方法的结果。最后一行是应用于`WINTER`常量的`toString()`方法的结果。
- en: 'The `equals()`, `name()`, and `ordinal()` methods are declared `final` in `java.lang.Enum`,
    so they cannot be overridden and are used as-is.  The `valueOf()` method is static
    and not associated with any class instance, so it cannot be overridden. The only
    method we can override is the `toString()` method:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals()`，`name()`和`ordinal()`方法在`java.lang.Enum`中被声明为`final`，因此它们不能被重写，而是按原样使用。`valueOf()`方法是静态的，不与任何类实例关联，因此不能被重写。我们唯一可以重写的方法是`toString()`方法：'
- en: '```java'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season {
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举Season {
- en: SPRING, SUMMER, AUTUMN, WINTER;
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: SPRING, SUMMER, AUTUMN, WINTER;
- en: public String toString() {
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "The best season";
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 返回“最好的季节”;
- en: '}'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the preceding code again, the result is as follows:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行前面的代码，结果如下：
- en: '![](img/19202174-e824-45da-ab53-4ed72a4ae21b.png)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19202174-e824-45da-ab53-4ed72a4ae21b.png)'
- en: 'Now, you can see that the `toString()` method returns the same result for each
    constant. If necessary, the `toString()` method can be overridden for each constant.
    Let''s look at this version of the `Season` class:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到`toString()`方法对于每个常量返回相同的结果。必要时，`toString()`方法可以为每个常量重写。让我们看一下`Season`类的这个版本：
- en: '```java'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season2 {
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举Season2 {
- en: SPRING,
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: SPRING,
- en: SUMMER,
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: SUMMER,
- en: AUTUMN,
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: AUTUMN,
- en: WINTER { public String toString() { return "Winter"; } };
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: WINTER { public String toString() { return "Winter"; } };
- en: public String toString() {
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "The best season";
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 返回“最好的季节”;
- en: '}'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have overridden the `toString()` method for the `WINTER` constant only.
    If we run the same code snippet again, the result will be as follows:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为`WINTER`常量重写了`toString()`方法。如果我们再次运行相同的代码片段，结果将如下：
- en: '![](img/dc5ddc24-87cd-450a-ab70-0505e97b4b21.png)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc5ddc24-87cd-450a-ab70-0505e97b4b21.png)'
- en: As you can see, the old version of `toString()` is used for all constants, except
    `WINTER`.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，除了“WINTER”之外，所有常量都使用了旧版本的`toString()`。
- en: 'It is also possible to add any property (and getters and setters) to `enum`
    constants and associate each of them with corresponding values. Here is one example:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以为`enum`常量添加任何属性（以及getter和setter），并将每个常量与相应的值关联起来。这是一个例子：
- en: '```java'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Season {
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举Season {
- en: SPRING("Spring", "warmer than winter", 60),
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: SPRING("Spring", "warmer than winter", 60),
- en: SUMMER("Summer", "the hottest season", 100),
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: SUMMER("Summer", "the hottest season", 100),
- en: AUTUMN("Autumn", "colder than summer", 70),
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: AUTUMN("Autumn", "colder than summer", 70),
- en: WINTER("Winter", "the coldest season", 40);
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: WINTER("Winter", "the coldest season", 40);
- en: private String feel, toString;
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: private String feel, toString;
- en: private int averageTemperature;
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: private int averageTemperature;
- en: Season(String toString, String feel, int t) {
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: Season(String toString, String feel, int t) {
- en: this.feel = feel;
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: this.feel = feel;
- en: this.toString = toString;
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: this.toString = toString;
- en: this.averageTemperature = t;
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: this.averageTemperature = t;
- en: '}'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getFeel(){ return this.feel; }
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: public String getFeel(){ return this.feel; }
- en: public int getAverageTemperature(){
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAverageTemperature(){
- en: return this.averageTemperature;
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: return this.averageTemperature;
- en: '}'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String toString() { return this.toString; }
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return this.toString; }
- en: '}'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding example, we have added three properties to the `Season` class: `feel`,
    `toString`, and `averageTemperature`. We have also created a constructor (a special method
    used to assign the initial values of an object state) that takes these three properties
    and adds getters and `toString()` methods that return values of these properties.
    Then, in parentheses after each constant, we have set the values that are going
    to be passed to the constructor when this constant is created.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: In the preceding example, we have added three properties to the `Season` class: `feel`,
    `toString`, and `averageTemperature`. We have also created a constructor (a special method
    used to assign the initial values of an object state) that takes these three properties
    and adds getters and `toString()` methods that return values of these properties.
    Then, in parentheses after each constant, we have set the values that are going
    to be passed to the constructor when this constant is created.
- en: 'Here is a demo method that we are going to use:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 'Here is a demo method that we are going to use:'
- en: '```java'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void enumDemo(Season season){
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: void enumDemo(Season season){
- en: System.out.println(season + " is " + season.getFeel());
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(season + " is " + season.getFeel());
- en: System.out.println(season + " has average temperature around "
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(season + " has average temperature around "
- en: + season.getAverageTemperature());
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: + season.getAverageTemperature());
- en: '}'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `enumDemo()` method takes the `enum Season` constant and constructs and
    displays two sentences. Let''s run the preceding code for each season, like this:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `enumDemo()` method takes the `enum Season` constant and constructs and
    displays two sentences. Let''s run the preceding code for each season, like this:'
- en: '```java'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enumDemo2(Season3.SPRING);
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo2(Season3.SPRING);
- en: enumDemo2(Season3.SUMMER);
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo2(Season3.SUMMER);
- en: enumDemo2(Season3.AUTUMN);
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo2(Season3.AUTUMN);
- en: enumDemo2(Season3.WINTER);
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: enumDemo2(Season3.WINTER);
- en: '```'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be as follows:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result will be as follows:'
- en: '![](img/90d857fd-ef52-4317-97b9-d2435ab70fb9.png)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90d857fd-ef52-4317-97b9-d2435ab70fb9.png)'
- en: 'The `enum` class is a very powerful tool that allows us to simplify the code
    and make it better protected from runtime errors because all possible values are
    predictable and can be tested in advance. For example, we can test the `SPRING`
    constant getters using the following unit test:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `enum` class is a very powerful tool that allows us to simplify the code
    and make it better protected from runtime errors because all possible values are
    predictable and can be tested in advance. For example, we can test the `SPRING`
    constant getters using the following unit test:'
- en: '```java'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@DisplayName("Enum Season tests")'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Enum Season tests")'
- en: public class EnumSeasonTest {
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: public class EnumSeasonTest {
- en: '@Test'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Test Spring getters")'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Test Spring getters")'
- en: void multiplyByTwo(){
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo(){
- en: assertEquals("Spring", Season.SPRING.toString());
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("Spring", Season.SPRING.toString());
- en: assertEquals("warmer than winter", Season.SPRING.getFeel());
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("warmer than winter", Season.SPRING.getFeel());
- en: assertEquals(60, Season.SPRING.getAverageTemperature());
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(60, Season.SPRING.getAverageTemperature());
- en: '}'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Granted, the getters don't have much code to make a mistake. But if the `enum`
    class has more complex methods or the list of the fixed values comes from some
    application requirements document, such a test will make sure we have written
    the code as required.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: Granted, the getters don't have much code to make a mistake. But if the `enum`
    class has more complex methods or the list of the fixed values comes from some
    application requirements document, such a test will make sure we have written
    the code as required.
- en: 'In the standard Java libraries, there are several `enum` classes. Here are
    a few examples of constants from those classes that can give you a hint about
    what is out there:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 'In the standard Java libraries, there are several `enum` classes. Here are
    a few examples of constants from those classes that can give you a hint about
    what is out there:'
- en: '```java'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Month.FEBRUARY;
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: Month.FEBRUARY;
- en: TimeUnit.DAYS;
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.DAYS;
- en: TimeUnit.MINUTES;
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.MINUTES;
- en: DayOfWeek.FRIDAY;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: DayOfWeek.FRIDAY;
- en: Color.GREEN;
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: Color.GREEN;
- en: Color.green;
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: Color.green;
- en: '```'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: So, before creating your own `enum`, try to check and see whether the standard
    libraries already provide a class with the values you need.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: So, before creating your own `enum`, try to check and see whether the standard
    libraries already provide a class with the values you need.
- en: Passing reference type values as method parameters
  id: totrans-1057
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passing reference type values as method parameters
- en: 'One important difference between the reference types and primitive types that
    merits special discussion is the way their values can be used in a method. Let''s
    see the difference by example. First, we create the `SomeClass` class:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 'One important difference between the reference types and primitive types that
    merits special discussion is the way their values can be used in a method. Let''s
    see the difference by example. First, we create the `SomeClass` class:'
- en: '```java'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass{
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass{
- en: private int count;
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: private int count;
- en: public int getCount() {
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: public int getCount() {
- en: return count;
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: return count;
- en: '}'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void setCount(int count) {
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: public void setCount(int count) {
- en: this.count = count;
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: this.count = count;
- en: '}'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then we create a class that uses it:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 'Then we create a class that uses it:'
- en: '```java'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ReferenceTypeDemo {
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: public class ReferenceTypeDemo {
- en: public static void main(String[] args) {
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: float f = 1.0f;
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: float f = 1.0f;
- en: SomeClass someClass = new SomeClass();
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass someClass = new SomeClass();
- en: 'System.out.println("\nBefore demoMethod(): f = " + f +'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("\nBefore demoMethod(): f = " + f +'
- en: '", count = " + someClass.getCount());'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '", count = " + someClass.getCount());'
- en: demoMethod(f, someClass);
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: demoMethod(f, someClass);
- en: 'System.out.println("After demoMethod(): f = " + f'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("After demoMethod(): f = " + f'
- en: + ", count = " + someClass.getCount());
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: + ", count = " + someClass.getCount());
- en: '}'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private static void demoMethod(float f, SomeClass someClass){
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: private static void demoMethod(float f, SomeClass someClass){
- en: //... some code can be here
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: //... some code can be here
- en: f = 42.0f;
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: f = 42.0f;
- en: someClass.setCount(42);
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: someClass.setCount(42);
- en: someClass = new SomeClass();
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: someClass = new SomeClass();
- en: someClass.setCount(1001);
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: someClass.setCount(1001);
- en: '}'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Let's look inside `demoMethod()` first. We have made it very simple for demo
    purposes, but assume it does more, and then assigns a new value to the `f` variable
    (parameter) and sets a new count value on the object of the `SomeClass` class.
    Then this method attempts to replace the passed-in reference with a new value
    that points to a new `SomeClass` object with another count value.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看`demoMethod()`内部。我们为演示目的使其非常简单，但假设它做了更多的事情，然后为`f`变量（参数）分配一个新值，并在`SomeClass`类的对象上设置一个新的计数值。然后，此方法尝试用指向具有另一个计数值的新`SomeClass`对象的新值替换传入的引用。
- en: 'In the `main()` method, we declare and initialize the `f` and `someClass` variables with
    some values and print them out, then pass them as the parameters to the `demoMethod()` method and
    print the values of the same variables again. Let''s run the `main()` method and
    see the results that should look like the following:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`方法中，我们声明并初始化`f`和`someClass`变量，并打印它们，然后将它们作为参数传递给`demoMethod()`方法，并再次打印相同变量的值。让我们运行`main()`方法并查看结果，结果应该如下所示：
- en: '![](img/3fe7f190-7bc0-4bc5-bf1b-90634245d199.png)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fe7f190-7bc0-4bc5-bf1b-90634245d199.png)'
- en: 'To understand the difference, we need to take into account these two facts:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解区别，我们需要考虑这两个事实：
- en: Values to a method are passed by copy
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法传递的值是通过副本传递的
- en: Value of a reference type is a reference to a memory where the referred object
    resides
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型的值是指向所指对象所在内存的引用
- en: That is why when the primitive value (or `String`, which is immutable as we
    have explained already) is passed in, the copy of the actual value is created,
    so the original value cannot be affected.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当传递原始值（或`String`，如我们已经解释的那样是不可变的）时，会创建实际值的副本，因此原始值不会受到影响。
- en: Similarly, if the reference to an object is passed in, only its copy is accessible
    to the code in the method, so the original reference cannot be changed. That is
    why our attempt to change the original reference value and make it refer another
    object did not succeed, either.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果传入对象的引用被传入，那么方法中的代码只能访问其副本，因此无法更改原始引用。这就是为什么我们尝试更改原始引用值并使其引用另一个对象并没有成功的原因。
- en: But the code inside the method is able to access the original object and change
    its count value using the copy of the reference value because the value still
    points to the same memory area where the original object resides. That is why
    code inside the method is able to execute any method of the original object, including
    those methods that change the object's state (values of the instance fields).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 但是方法内部的代码可以访问原始对象并使用引用值的副本更改其计数值，因为该值仍指向原始对象所在的相同内存区域。这就是为什么方法内部的代码能够执行原始对象的任何方法，包括更改对象状态（实例字段的值）的方法。
- en: 'This change of an object state, when it was passed in as a parameter, is called
    a side-effect and is sometimes used, when  the following occurs:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对象状态更改为参数传递时，称为副作用，有时会在以下情况下使用：
- en: A method has to return several values but it is not possible to do it via returned
    construct
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须返回多个值，但无法通过返回的结构来实现
- en: The programmer is not skilled enough
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员不够熟练
- en: A third-party library or a framework utilizes the side-effect as the primary
    mechanism of getting back the result
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库或框架利用副作用作为获取结果的主要机制
- en: But the best practices and design principles (the Single Responsibility Principle
    in this case, which we will discuss in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*) guide programmers to avoiding side-effects,
    if possible, because side effects often lead to a not-very-readable (for a human) code
    and subtle runtime effects that are difficult to identify and fix.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 但是最佳实践和设计原则（在这种情况下是单一责任原则，我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论*面向对象设计（OOD）原则*）指导程序员尽量避免副作用，因为副作用经常导致代码不易阅读（对于人类来说）和难以识别和修复的微妙运行时效果。
- en: One has to distinguish a side effect and a code design pattern called Delegation
    Pattern ([https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)),
    when the methods invoked on the passed-in objects are stateless. We will talk
    about design patterns in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 必须区分副作用和称为委托模式的代码设计模式（[https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)），当在传入的对象上调用的方法是无状态的。我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论设计模式，*面向对象设计（OOD）原则*。
- en: 'Similarly, a side effect is possible when an array is passed in as a parameter.
    Here is the code that demonstrates it:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当数组作为参数传入时，副作用是可能的。以下是演示它的代码：
- en: '```java'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ReferenceTypeDemo {
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: public class ReferenceTypeDemo {
- en: public static void main(String[] args) {
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: int[] someArray = {1, 2, 3};
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: int[] someArray = {1, 2, 3};
- en: 'System.out.println("\nBefore demoMethod(): someArray[0] = "'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("\nBefore demoMethod(): someArray[0] = "'
- en: + someArray[0]);
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: + someArray[0]);
- en: demoMethod(someArray);
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: demoMethod(someArray);
- en: 'System.out.println("After demoMethod(): someArray[0] = "'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("After demoMethod(): someArray[0] = "'
- en: + someArray[0]);
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: + someArray[0]);
- en: '}'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private static void demoMethod(int[] someArray){
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: private static void demoMethod(int[] someArray){
- en: someArray[0] = 42;
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: someArray[0] = 42;
- en: someArray = new int[3];
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: someArray = new int[3];
- en: someArray[0] = 43;
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: someArray[0] = 43;
- en: '}'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result of the preceding code execution is as follows:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的执行结果如下：
- en: '![](img/4431c564-3f1d-4148-87b7-126c30401e9d.png)'
  id: totrans-1125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4431c564-3f1d-4148-87b7-126c30401e9d.png)'
- en: You can see that despite the fact that, inside the method, we were able to assign
    a new array to the passed-in variable, the assignment of value `43` affected only
    the newly created array, but had no effect on the original array. Yet, the change
    of an array component using the passed-in copy of the reference value is possible
    because the copy still points to the same original array.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，尽管在方法内部，我们能够将新数组分配给传入的变量，但值`43`的分配仅影响新创建的数组，但对原始数组没有影响。然而，使用传入的引用值的副本更改数组组件是可能的，因为副本仍然指向相同的原始数组。
- en: 'And, to close the discussion about reference types as method parameters and
    possible side effects of that, we would like to demonstrate that the `String`
    type parameter—because of the `String` value immutability—behaves like a primitive
    type when passed in as a parameter. Here is the demo code:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，为了结束关于引用类型作为方法参数和可能的副作用的讨论，我们想证明`String`类型参数-由于`String`值的不可变性-在作为参数传递时的行为类似于原始类型。这是演示代码：
- en: '```java'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ReferenceTypeDemo {
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: public class ReferenceTypeDemo {
- en: public static void main(String[] args) {
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main（String[] args）{
- en: String someString = "Some string";
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: String someString =“一些字符串”;
- en: 'System.out.println("\nBefore demoMethod(): string = "'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“\n在demoMethod（）之前：string =”
- en: + someString);
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: + someString）;
- en: demoMethod(someString);
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 演示方法（someString）;
- en: 'System.out.println("After demoMethod(): string = "'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“在demoMethod（）之后：string =”
- en: + someString);
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: + someString）;
- en: '}'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private static void demoMethod(String someString){
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: private static void demoMethod（String someString）{
- en: someString = "Some other string";
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: someString =“另一些字符串”;
- en: '}'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code yields the following results:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下结果：
- en: '![](img/c29f1c82-c6e0-4f44-8f20-d3e72a10bcdb.png)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c29f1c82-c6e0-4f44-8f20-d3e72a10bcdb.png)
- en: The code inside the method was not able to change the original parameter value.
    The reason for that is not – as in the case of a primitive type – that the parameter
    value was copied before being passed into the method. The copy, in this case,
    still pointed to the same original `String` object. The actual reason is that
    changing a `String` value does not change the value, but creates another `String`
    object with the result of the change. That is the `String` value immutability
    mechanism as we have described it in the *String type and literals* section. The
    reference to this new (changed) `String` object assigned to the copy of the reference
    value passed in and has no effect on the original reference value that still points
    to the original String object.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 方法内的代码无法更改原始参数值。这样做的原因不是-与原始类型的情况一样-在将其传递到方法之前复制了参数值。在这种情况下，副本仍指向相同的原始`String`对象。实际原因是更改`String`值不会更改该值，而是创建另一个具有更改结果的`String`对象。这就是我们在*String类型和文字*部分中描述的`String`值不可变性机制。分配给传入的引用值的副本的新（更改的）`String`对象的引用，并且不会对仍然指向原始String对象的原始引用值产生影响。
- en: With that, we conclude the discussion about Java reference types and String.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们结束了关于Java引用类型和String的讨论。
- en: Exercise – Variable declarations and initializations
  id: totrans-1147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-变量声明和初始化
- en: 'Which of the following statements are correct:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些陈述是正确的：
- en: int x = 'x';
  id: totrans-1149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: int x ='x';
- en: int x1 = "x";
  id: totrans-1150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: int x1 =“x”;
- en: char x2 = "x";
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: char x2 =“x”;
- en: char x4 = 1;
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: char x4 = 1;
- en: String x3 = 1;
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: String x3 = 1;
- en: Month.MAY = 5;
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Month.MAY = 5;
- en: Month month = Month.APRIL;
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Month month = Month.APRIL;
- en: Answer
  id: totrans-1156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 1, 4, 7
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 4, 7
- en: Summary
  id: totrans-1158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The chapter provided the foundation for the discussion of more complex Java
    language constructs. Knowledge of Java elements, such as identifiers, variables,
    literals, keywords, separators, comments and types—primitive and reference—is
    indispensable for Java programming. You also had a chance to learn about several
    areas that can be sources of confusion if not understood properly, such as the
    String type immutability and possible side effects when a reference type is used
    as a method parameter. Arrays and `enum` types were also explained in detail,
    enabling the reader to use these powerful constructs and increase the quality
    of their code.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为讨论更复杂的Java语言构造奠定了基础。 Java元素的知识，例如标识符，变量，文字，关键字，分隔符，注释和类型-原始和引用-对于Java编程是必不可少的。如果不正确理解，您还有机会了解一些可能引起混淆的领域，例如String类型的不可变性和引用类型作为方法参数时可能的副作用。数组和`enum`类型也得到了详细解释，使读者能够使用这些强大的构造并提高其代码的质量。
- en: In the next chapter, the reader will be introduced the most common terms and
    coding solutions of Java programming—**Application Programming Interface** (**API**),
    object factories, method overriding, hiding, and overloading. Then the discussion
    about the design of a software system and the advantage of aggregation (vs inheritance)
    will bring the reader into the realm of best design practices. The overview of
    Java data structures will conclude the chapter, providing the reader with practical
    programming advice and recommendations.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将介绍Java编程的最常见术语和编码解决方案-**应用程序编程接口**（**API**），对象工厂，方法覆盖，隐藏和重载。然后，关于软件系统设计和聚合（vs继承）的优势的讨论将使读者进入最佳设计实践的领域。
    Java数据结构的概述将结束本章，为读者提供实用的编程建议和推荐。
