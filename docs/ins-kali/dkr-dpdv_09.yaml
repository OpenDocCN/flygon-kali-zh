- en: '7: Containers'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7：容器
- en: Now that we know a bit about images, it’s time to get into containers. As this
    is a book about Docker, we’ll be talking specifically about Docker containers.
    However, Docker has been hard at work implementing the image and container specs
    published by the Open Container Initiative (OCI) at https://www.opencontainers.org.
    This means a lot of what you learn here will apply to other container runtimes
    that are OCI compliant.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对镜像有了一些了解，是时候进入容器了。由于这是一本关于Docker的书，我们将专门讨论Docker容器。然而，Docker一直在努力实现由开放容器倡议（OCI）在https://www.opencontainers.org发布的镜像和容器规范。这意味着你在这里学到的很多东西将适用于其他符合OCI标准的容器运行时。
- en: 'We’ll split this chapter into the usual three parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章分为通常的三个部分：
- en: The TLDR
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之
- en: The deep dive
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨
- en: The commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Let’s go and learn about containers!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去学习关于容器的知识吧！
- en: Docker containers - The TLDR
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker容器-简而言之
- en: A container is the runtime instance of an image. In the same way that we can
    start a virtual machine (VM) from a virtual machine template, we start one or
    more containers from a single image. The big difference between a VM and a container
    is that containers are faster and more lightweight — instead of running a full-blown
    OS like a VM, containers share the OS/kernel with the host they’re running on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行时实例。就像我们可以从虚拟机模板启动虚拟机（VM）一样，我们可以从单个镜像启动一个或多个容器。容器和虚拟机之间的主要区别在于容器更快速和更轻量级-容器不像虚拟机一样运行完整的操作系统，而是与它们运行的主机共享操作系统/内核。
- en: Figure 7.1 shows a single Docker image being used to start multiple Docker containers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1显示了一个Docker镜像被用来启动多个Docker容器。
- en: '![Figure 7.1](images/figure7-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1](images/figure7-1.png)'
- en: Figure 7.1
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1
- en: 'The simplest way to start a container is with the `docker container run` command.
    The command can take a lot of arguments, but in its most basic form you tell it
    an image to use and a app to run: `docker container run <image> <app>`. This next
    command will start an Ubuntu Linux container running the Bash shell as its app:
    `docker container run -it ubuntu /bin/bash`. To start a Windows container running
    the PowerShell app, you could do `docker container run -it microsoft/powershell:nanoserver
    pwsh.exe`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器的最简单方法是使用`docker container run`命令。该命令可以带很多参数，但在其最基本的形式中，你告诉它要使用的镜像和要运行的应用程序：`docker
    container run <image> <app>`。下一个命令将启动一个运行Bash shell的Ubuntu Linux容器：`docker container
    run -it ubuntu /bin/bash`。要启动一个运行PowerShell应用程序的Windows容器，你可以这样做：`docker container
    run -it microsoft/powershell:nanoserver pwsh.exe`。
- en: The `-it` flags will connect your current terminal window to the container’s
    shell.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it`标志将把你当前的终端窗口连接到容器的shell。'
- en: Containers run until the app they are executing exits. In the two examples above,
    the Linux container will exit when the Bash shell exits, and the Windows container
    will exit when the PowerShell process terminates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行直到它们执行的应用退出。在上面的两个例子中，Linux容器将在Bash shell退出时退出，而Windows容器将在PowerShell进程终止时退出。
- en: 'A really simple way to demonstrate this is to start a new container and tell
    it to run the sleep command for 10 seconds. The container will start, run for
    10 seconds and exit. If you run the following command from a Linux host (or Windows
    host running in Linux containers mode) your shell will attach to the container’s
    shell for 10 seconds and then exit: `docker container run alpine:latest sleep
    10`. You can do the same with a Windows container with the following command `docker
    container run microsoft/powershell:nanoserver Start-Sleep -s 10`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的演示方法是启动一个新的容器，并告诉它运行sleep命令10秒钟。容器将启动，运行10秒钟然后退出。如果你从Linux主机（或在Linux容器模式下运行的Windows主机）运行以下命令，你的shell将附加到容器的shell上10秒钟，然后退出：`docker
    container run alpine:latest sleep 10`。你可以用以下命令在Windows容器中做同样的事情：`docker container
    run microsoft/powershell:nanoserver Start-Sleep -s 10`。
- en: You can manually stop a container with the `docker container stop` command,
    and then restart it with `docker container start`. To get rid of a container forever
    you have to explicitly delete it using `docker container rm`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker container stop`命令手动停止容器，然后使用`docker container start`重新启动它。要永久删除容器，必须使用`docker
    container rm`显式删除它。
- en: That’s the elevator pitch! Now let’s get into the detail…
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是电梯推介！现在让我们深入了解细节...
- en: Docker containers - The deep dive
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker容器-深入探讨
- en: The first things we’ll cover here are the fundamental differences between a
    container and a VM. It’s mainly theory at this stage, but it’s important stuff.
    Along the way, we’ll point out where the container model has potential advantages
    over the VM model.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里首先介绍容器和虚拟机之间的基本区别。目前主要是理论，但这很重要。在此过程中，我们将指出容器模型相对于虚拟机模型的潜在优势。
- en: '**Heads-up:** As the author, I’m going to say this before we go any further.
    A lot of us get passionate about the things we do and the skills we have. I remember
    *big Unix* people resisting the rise of Linux. You might remember the same. You
    might also remember people attempting to resist VMware and the VM juggernaut.
    In both cases “resistance was futile”. In this section I’m going to highlight
    what I consider some of the advantages the container model has over the VM model.
    But I’m guessing a lot of you will be VM experts with a lot invested in the VM
    ecosystem. And I’m guessing that one or two of you might want to fight me over
    some of the things I say. So let me be clear… I’m a big guy and I’d beat you down
    in hand-to-hand combat :-D Just kidding. But I’m not trying to destroy your empire
    or call your baby ugly! I’m trying to help. The whole reason for me writing this
    book is to help you get started with Docker and containers!'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**作为作者，在我们继续之前，我要说这个。我们很多人对我们所做的事情和我们拥有的技能都很热情。我记得*大型Unix*的人抵制Linux的崛起。你可能也记得同样的事情。你可能还记得人们试图抵制VMware和VM巨头。在这两种情况下，“抵抗是徒劳的”。在本节中，我将强调容器模型相对于VM模型的一些优势。但我猜你们中的很多人都是VM专家，对VM生态系统投入了很多。我猜你们中的一两个人可能想和我争论我说的一些事情。所以让我明白一点...我是个大个子，我会在肉搏战中打败你
    :-D 只是开玩笑。但我不是想摧毁你的帝国或者说你的孩子丑陋！我是想帮助你。我写这本书的整个原因就是为了帮助你开始使用Docker和容器！'
- en: Here we go.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧。
- en: Containers vs VMs
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器 vs 虚拟机
- en: Containers and VMs both need a host to run on. This can be anything from your
    laptop, a bare metal server in your data center, all the way up to an instance
    the public cloud. In this example we’ll assume a single physical server that we
    need to run 4 business applications on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和虚拟机都需要主机来运行。这可以是从您的笔记本电脑，到您数据中心的裸机服务器，一直到公共云实例的任何东西。在这个例子中，我们假设需要在单个物理服务器上运行4个业务应用程序。
- en: In the VM model, the physical server is powered on and the hypervisor boots
    (we’re skipping the BIOS and bootloader code etc.). Once the hypervisor boots,
    it lays claim to all physical resources on the system such as CPU, RAM, storage,
    and NICs. The hypervisor then carves these hardware resources into virtual versions
    that look smell and feel exactly like the real thing. It then packages them into
    a software construct called a virtual machine (VM). We then take those VMs and
    install an operating system and application on each one. We said we had a single
    physical server and needed to run 4 applications, so we’d create 4 VMs, install
    4 operating systems, and then install the 4 applications. When it’s all done it
    looks a bit like Figure 7.2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机模型中，物理服务器启动并引导虚拟机监视器（我们跳过BIOS和引导加载程序代码等）。一旦虚拟机监视器启动，它就会占用系统上的所有物理资源，如CPU、RAM、存储和NIC。然后，虚拟机监视器将这些硬件资源划分为看起来、闻起来和感觉起来与真实物品完全相同的虚拟版本。然后将它们打包成一个名为虚拟机（VM）的软件构造。然后我们将这些VM安装操作系统和应用程序。我们说我们有一个单独的物理服务器，需要运行4个应用程序，所以我们会创建4个VM，安装4个操作系统，然后安装4个应用程序。完成后，它看起来有点像图7.2。
- en: '![Figure 7.2](images/figure7-2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2](images/figure7-2.png)'
- en: Figure 7.2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2
- en: Things are a bit different in the container model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器模型中有些不同。
- en: When the server is powered on, your chosen OS boots. In the Docker world this
    can be Linux, or a modern version of Windows that has support for the container
    primitives in its kernel. Similar to the VM model, the OS claims all hardware
    resources. On top of the OS, we install a container engine such as Docker. The
    container engine then takes **OS resources** such as the *process tree*, the *filesystem*,
    and the *network stack*, and carves them up into secure isolated constructs called
    *containers*. Each container looks smells and feels just like a real OS. Inside
    of each *container* we can run an application. Like before, we’re assuming a single
    physical server with 4 applications. Therefore, we’d carve out 4 containers and
    run a single application inside of each. This is shown in Figure 7.3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，您选择的操作系统引导。在Docker世界中，这可以是Linux，或者具有对其内核中容器基元支持的现代Windows版本。与虚拟机模型类似，操作系统占用所有硬件资源。在操作系统之上，我们安装了一个名为Docker的容器引擎。容器引擎然后获取**操作系统资源**，如*进程树*、*文件系统*和*网络堆栈*，并将它们划分为安全隔离的构造，称为*容器*。每个容器看起来、闻起来和感觉起来就像一个真正的操作系统。在每个*容器*内部，我们可以运行一个应用程序。与之前一样，我们假设有一个单独的物理服务器，需要运行4个应用程序。因此，我们会划分出4个容器，并在每个容器内运行一个应用程序。这在图7.3中显示。
- en: '![Figure 7.3](images/figure7-3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3](images/figure7-3.png)'
- en: Figure 7.3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3
- en: At a high level, we can say that hypervisors perform **hardware virtualization**
    — they carve up physical hardware resources into virtual versions. On the other
    hand, containers perform **OS virtualization** — they carve up OS resources into
    virtual versions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，我们可以说虚拟机监视器执行**硬件虚拟化** - 它们将物理硬件资源划分为虚拟版本。另一方面，容器执行**操作系统虚拟化** - 它们将操作系统资源划分为虚拟版本。
- en: The VM tax
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 虚拟机的开销
- en: Let’s build on what we just covered and drill into one of the main problems
    with the hypervisor model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在刚才讨论的基础上深入探讨虚拟机监视器模型的一个主要问题。
- en: We started out with a single physical server and the requirement to run 4 business
    applications. In both models we installed either an OS or a hypervisor (a type
    of OS that is highly tuned for VMs). So far the models are almost identical. But
    this is where the similarities stop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初只有一个物理服务器，需要运行4个业务应用程序。在两种模型中，我们安装了操作系统或者虚拟机监视器（一种针对虚拟机高度优化的操作系统）。到目前为止，这两种模型几乎是相同的。但这就是相似之处的尽头。
- en: The VM model then carves **low-level hardware resources** into VMs. Each VM
    is a software construct containing virtual CPU, virtual RAM, virtual disk etc.
    As such, every VM needs its own OS to claim, initialize, and manage all of those
    virtual resources. And sadly, every OS comes with its own set of baggage and overheads.
    For example, every OS consumes a slice of CPU, a slice of RAM, a slice of storage
    etc. Most need their own licenses as well as people and infrastructure to patch
    and upgrade them. Each OS also presents a sizable attack surface. We often refer
    to all of this as the ***OS tax***, or ***VM tax*** — every OS you install consumes
    resources!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，虚拟机模型将低级硬件资源划分为虚拟机。每个虚拟机都是一个包含虚拟CPU、虚拟RAM、虚拟磁盘等的软件构造。因此，每个虚拟机都需要自己的操作系统来声明、初始化和管理所有这些虚拟资源。不幸的是，每个操作系统都带有自己的一套负担和开销。例如，每个操作系统都会消耗一部分CPU、一部分RAM、一部分存储空间等。大多数还需要自己的许可证，以及人员和基础设施来打补丁和升级它们。每个操作系统还呈现出相当大的攻击面。我们经常将所有这些称为“操作系统税”或“虚拟机税”——你安装的每个操作系统都会消耗资源！
- en: The container model has a single kernel running in the host OS. It’s possible
    to run tens or hundreds of containers on a single host with every container sharing
    that single OS/kernel. That means a single OS consuming CPU, RAM, and storage.
    A single OS that needs licensing. A single OS that needs upgrading and patching.
    And a single OS kernel presenting an attack surface. All in all, a single OS tax
    bill!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器模型在主机操作系统中运行一个单一的内核。可以在单个主机上运行数十甚至数百个容器，每个容器共享同一个操作系统/内核。这意味着一个单一的操作系统消耗CPU、RAM和存储空间。一个需要许可证的单一操作系统。一个需要升级和打补丁的单一操作系统。以及一个呈现攻击面的单一操作系统内核。总而言之，只有一个操作系统税账单！
- en: That might not seem a lot in our example of a single server needing to run 4
    business applications. But when we’re talking about hundreds or thousands of apps,
    this can be game changing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这可能看起来不是很多，因为一个单独的服务器需要运行4个业务应用程序。但是当我们谈论数百或数千个应用程序时，这可能会改变游戏规则。
- en: Another thing to consider is start times. Because a container isn’t a full-blown
    OS, it starts **much faster** than a VM. Remember, there’s no kernel inside of
    a container that needs locating, decompressing, and initializing — not to mention
    all of the hardware enumerating and initializing associated with a normal kernel
    bootstrap. None of that is needed when starting a container! The single shared
    kernel, down at the OS level, is already started! Net result, containers can start
    in less than a second. The only thing that has an impact on container start time
    is the time it takes to start the application it’s running.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的另一件事是启动时间。因为容器不是一个完整的操作系统，所以它的启动速度比虚拟机快得多。记住，容器内部没有需要定位、解压和初始化的内核，更不用说与正常内核引导相关的所有硬件枚举和初始化。启动容器时不需要任何这些！在操作系统级别下，单个共享的内核已经启动了！最终结果是，容器可以在不到一秒的时间内启动。唯一影响容器启动时间的是运行的应用程序启动所需的时间。
- en: This all amounts to the container model being leaner and more efficient than
    the VM model. We can pack more applications onto less resources, start them faster,
    and pay less in licensing and admin costs, as well as present less of an attack
    surface to the dark side. What’s not to like about that!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致容器模型比虚拟机模型更精简和高效。我们可以在更少的资源上运行更多的应用程序，更快地启动它们，并且在许可和管理成本上支付更少，同时对黑暗面呈现出更少的攻击面。这有什么不好的呢！
- en: With that theory out of the way, let’s have a play around with some containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理论，让我们来玩一下一些容器。
- en: Running containers
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行容器
- en: To follow along with these examples, you’ll need a working Docker host. For
    most of the commands it won’t make a difference if it’s Linux or Windows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这些示例，您需要一个可用的Docker主机。对于大多数命令，它是Linux还是Windows都没有关系。
- en: Checking the Docker daemon
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查Docker守护程序
- en: The first thing I always do when I log on to a Docker host is check that Docker
    is running.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我登录到Docker主机时，总是首先检查Docker是否正在运行。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`As long as you get a response back in the `Client` and `Server` sections you
    should be good to go. If you get an error code in the `Server` section there’s
    a good chance that the docker daemon (server) isn’t running, or that your user
    account doesn’t have permission to access it.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在 `Client` 和 `Server` 部分得到响应，你就可以继续。如果在 `Server` 部分得到错误代码，很可能是docker守护程序（服务器）没有运行，或者你的用户账户没有权限访问它。
- en: If you’re running Linux, and your user account doesn’t have permission to access
    the daemon, you need to make sure it’s a member of the local `docker` Unix group.
    If it isn’t, you can add it with `usermod -aG docker <user>` and then you’ll have
    to logout and log back in to your shell for the changes to take effect.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行Linux，并且你的用户账户没有权限访问守护程序，你需要确保它是本地 `docker` Unix 组的成员。如果不是，你可以用 `usermod
    -aG docker <user>` 添加它，然后你需要注销并重新登录到你的shell以使更改生效。
- en: If your user account is already a member of the local `docker` group, the problem
    might be that the Docker daemon isn’t running. To check the status of the Docker
    daemon, run one of the following commands depending on your Docker host’s operating
    system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用户账户已经是本地 `docker` 组的成员，问题可能是Docker守护程序没有运行。要检查Docker守护程序的状态，请根据Docker主机的操作系统运行以下命令之一。
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`If the Docker daemon is running, you’re fine to continue.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker守护程序正在运行，你可以继续。
- en: Starting a simple container
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动一个简单的容器
- en: The simplest way to start a container is with the `docker container run` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器的最简单方法是使用 `docker container run` 命令。
- en: The following command starts a simple container that will run a containerized
    version of Ubuntu Linux.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启动一个简单的容器，将运行Ubuntu Linux的容器化版本。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`A Windows example could be'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的一个例子可能是
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`The format of the command is essentially `docker container run <options> <image>:<tag>
    <app>`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的格式基本上是 `docker container run <options> <image>:<tag> <app>`。
- en: Let’s break the command down.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个命令。
- en: We started with `docker container run`, this is the standard command to start
    a new container. We then used the `-it` flags to make the container interactive
    and attach it to our terminal. Next, we told it to use the `ubuntu:latest` or
    `microsoft/powershell:nanoserver` image. Finally, we told it to run the Bash shell
    in the Linux example, and the PowerShell app in the Windows example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `docker container run` 开始，这是启动新容器的标准命令。然后我们使用了 `-it` 标志使容器交互，并将其附加到我们的终端。接下来，我们告诉它使用
    `ubuntu:latest` 或 `microsoft/powershell:nanoserver` 镜像。最后，我们告诉它在Linux示例中运行Bash
    shell，在Windows示例中运行PowerShell应用程序。
- en: When we hit `Return`, the Docker client made the appropriate API calls to the
    Docker daemon. The Docker daemon accepted the command and searched the Docker
    host’s local cache to see if it already had a copy of the requested image. In
    the example cited, it didn’t, so it went to Docker Hub to see if it could find
    it there. It could, so it *pulled* it locally and stored it in its local cache.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下 `Return` 键时，Docker客户端会向Docker守护程序发出适当的API调用。Docker守护程序接受了命令，并搜索Docker主机的本地缓存，看看它是否已经有所请求的镜像的副本。在所引用的例子中，它没有，所以它去Docker
    Hub看看是否能在那里找到。它找到了，所以它在本地 *拉取* 并将其存储在本地缓存中。
- en: '**Note:** In a standard, out-of-the-box Linux installation, the Docker daemon
    implements the Docker Remote API on a local IPC/Unix socket at `/var/run/docker.sock`.
    On Windows, it listens on a named pipe at `npipe:////./pipe/docker_engine`. It’s
    also possible to configure the Docker client and daemon to communicate over the
    network. The default non-TLS network port for Docker is 2375, the default TLS
    port is 2376.'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 在标准的Linux安装中，Docker守护程序在本地IPC/Unix套接字`/var/run/docker.sock`上实现Docker远程API。在Windows上，它在`npipe:////./pipe/docker_engine`上监听一个命名管道。也可以配置Docker客户端和守护程序通过网络进行通信。Docker的默认非TLS网络端口是2375，默认的TLS端口是2376。'
- en: Once the image was pulled, the daemon created the container and executed the
    specified app inside of it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像被拉取，守护程序就会创建容器并在其中执行指定的应用程序。
- en: If you look closely, you’ll see that your shell prompt has changed and you’re
    now inside of the container. In the example cited, the shell prompt has changed
    to `root@3027eb644874:/#`. The long number after the `@` is the first 12 characters
    of the container’s unique ID.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你会发现你的shell提示已经改变，你现在在容器内部。在所引用的例子中，shell提示已经改变为`root@3027eb644874:/#`。`@`后面的长数字是容器唯一ID的前12个字符。
- en: Try executing some basic commands inside of the container. You might notice
    that some commands do not work. This is because the images we used, like almost
    all container images, are highly optimized for containers. This means they don’t
    have all of the normal commands and packages installed. The following example
    shows a couple of commands — one succeeds and the other one fails.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在容器内执行一些基本命令。你可能会注意到一些命令无法使用。这是因为我们使用的镜像，就像几乎所有的容器镜像一样，都是针对容器高度优化的。这意味着它们并没有安装所有正常的命令和软件包。下面的例子展示了一些命令
    - 一个成功，另一个失败。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`As shown in the output above, the `ping` utility is not included as part of
    the official Ubuntu image.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`如上所示，`ping`实用程序不包含在官方Ubuntu镜像中。'
- en: Container processes
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器进程
- en: When we started the Ubuntu container in the previous section, we told it to
    run the Bash shell (`/bin/bash`). This makes the Bash shell the **one and only
    process running inside of the container**. You can see this by running `ps -elf`
    from inside the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一节中启动Ubuntu容器时，我们告诉它运行Bash shell（`/bin/bash`）。这使得Bash shell成为**容器内唯一运行的进程**。你可以通过在容器内运行`ps
    -elf`来看到这一点。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Although it might look like there are two processes running in the output
    above, there aren’t. The first process in the list, with PID 1, is the Bash shell
    we told the container to run. The second process is the `ps -elf` command we ran
    to produce the list. This is a short-lived process that has already exited by
    the time the output is displayed. Long story short, this container is running
    a single process — `/bin/bash`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`虽然在上面的输出中看起来有两个进程在运行，但实际上并没有。列表中的第一个进程，PID为1，是我们告诉容器运行的Bash shell。第二个进程是我们运行的`ps
    -elf`命令来生成列表。这是一个短暂的进程，在输出显示时已经退出。长话短说，这个容器正在运行一个单一的进程 - `/bin/bash`。'
- en: '**Note:** Windows containers are slightly different and tend to run quite a
    few processes.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** Windows容器略有不同，通常会运行相当多的进程。'
- en: This means that if you type `exit`, to exit the Bash shell, the container will
    also exit (terminate). The reason for this is that a container cannot exist without
    a running process — killing the Bash shell kills the container’s only process,
    resulting in the container also being killed. This is also true of Windows containers
    — **killing the main process in the container will also kill the container**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你输入`exit`来退出Bash shell，容器也会退出（终止）。原因是容器不能在没有运行的进程的情况下存在 - 终止Bash shell会终止容器的唯一进程，导致容器也被终止。这对Windows容器也是适用的
    - **终止容器中的主进程也会终止容器**。
- en: Press `Ctrl-PQ` to exit the container without terminating it. Doing this will
    place you back in the shell of your Docker host and leave the container running
    in the background. You can use the `docker container ls` command to view the list
    of running containers on your system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`Ctrl-PQ`退出容器而不终止它。这样做会将你放回Docker主机的shell，并将容器保持在后台运行。你可以使用`docker container
    ls`命令查看系统上正在运行的容器列表。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`It’s important to understand that this container is still running and you
    can re-attach your terminal to it with the `docker container exec` command.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这个容器仍在运行，你可以使用`docker container exec`命令重新连接你的终端。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`The command to re-attach to the Windows Nano Server PowerShell container would
    be `docker container exec -it <container-name-or-ID> pwsh.exe`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重新连接到Windows Nano Server PowerShell容器的命令将是`docker container exec -it <container-name-or-ID>
    pwsh.exe`。
- en: As you can see, the shell prompt has changed back to the container. If you run
    the `ps` command again you will now see **two** Bash or PowerShell processes.
    This is because the `docker container exec` command created a new Bash or PowerShell
    process and attached to that. This means that typing `exit` in this shell will
    not terminate the container, because the original Bash or PowerShell process will
    continue running.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，shell提示已经改回到容器。如果再次运行`ps`命令，您现在将看到**两个** Bash或PowerShell进程。这是因为`docker
    container exec`命令创建了一个新的Bash或PowerShell进程并附加到其中。这意味着在这个shell中输入`exit`不会终止容器，因为原始的Bash或PowerShell进程将继续运行。
- en: Type `exit` to leave the container and verify it’s still running with a `docker
    container ps`. It will still be running.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`exit`离开容器，并使用`docker container ps`验证它仍在运行。它仍在运行。
- en: If you are following along with the examples on your own Docker host, you should
    stop and delete the container with the following two commands (you will need to
    substitute the ID of your container).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在自己的Docker主机上跟着示例操作，您应该使用以下两个命令停止并删除容器（您需要替换您的容器的ID）。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`The containers started in the previous examples will no longer be present
    on your system.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中启动的容器将不再存在于您的系统中。
- en: Container lifecycle
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器生命周期
- en: It’s a common myth that containers can’t persist data. They can!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍的误解是容器无法持久保存数据。它们可以！
- en: A big part of the reason people think containers aren’t good for persistent
    workloads, or persisting data, is because they’re so good at non-persistent stuff.
    But being good at one thing doesn’t mean you can’t do other things. A lot of VM
    admins out there will remember companies like Microsoft and Oracle telling you
    that you couldn’t run their applications inside of VMs — or at least they wouldn’t
    support you if you did. I wonder if we’re seeing something similar with the move
    to containerization — are there people out there trying to protect their empires
    of persistent workloads from what they perceive as the threat of containers?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 人们认为容器不适合持久工作负载或持久数据的一个很大的原因是因为它们在非持久性工作上表现得很好。但擅长一件事并不意味着你不能做其他事情。很多虚拟机管理员会记得微软和甲骨文这样的公司告诉你他们的应用程序不能在虚拟机内运行，或者至少如果你这样做他们不会支持你。我想知道我们是否在容器化的过程中看到了类似的情况——是否有人试图保护他们认为受到容器威胁的持久工作负载帝国？
- en: In this section we’ll look at the lifecycle of a container — from birth, through
    work and vacations, to eventual death.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下容器的生命周期——从诞生，工作和休假，到最终的死亡。
- en: We’ve already seen how to start containers with the `docker container run` command.
    Let’s start another one so we can walk it through its entire lifecycle. The following
    examples will be from a Linux Docker host running an Ubuntu container. However,
    all of the examples will work with the Windows PowerShell container we’ve used
    in previous examples — though you’ll have to substitute Linux commands with their
    equivalent Windows commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`docker container run`命令启动容器。让我们启动另一个，以便我们可以完整地了解其生命周期。以下示例将来自运行Ubuntu容器的Linux
    Docker主机。但是，所有示例都将适用于我们在先前示例中使用的Windows PowerShell容器 - 尽管您将不得不用其等效的Windows命令替换Linux命令。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`That’s our container created, and we named it “percy” for persistent :-S'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们创建的容器，我们将其命名为“percy”以表示持久:-S
- en: Now let’s put it to work by writing some data to it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过向其写入一些数据来让其工作。
- en: From within the shell of your new container, follow the procedure below to write
    some data to a new file in the `tmp` directory and verify that the write operation
    succeeded.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在新容器的shell中，按照以下步骤将一些数据写入`tmp`目录中的新文件，并验证写入操作是否成功。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Press `Ctrl-PQ` to exit the container without killing it.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按`Ctrl-PQ`退出容器而不杀死它。
- en: Now use the `docker container stop` command to stop the container and put in
    on *vacation*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`docker container stop`命令停止容器并将其放在*休假*中。
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`You can use the container’s name or ID with the `docker container stop` command.
    The format is `docker container stop <container-id or container-name>`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker container stop`命令的容器名称或ID。格式为`docker container stop <container-id或container-name>`。
- en: Now run a `docker container ls` command to list all running containers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`docker container ls`命令以列出所有正在运行的容器。
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`The container is not listed in the output above because you put it in the
    stopped state with the `docker container stop` command. Run the same command again,
    only this time add the `-a` flag to show all containers, including those that
    are stopped.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 容器未在上面的输出中列出，因为您使用`docker container stop`命令将其置于停止状态。再次运行相同的命令，只是这次添加`-a`标志以显示所有容器，包括那些已停止的容器。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Now we can see the container showing as `Exited (0)`. Stopping a container
    is like stopping a virtual machine. Although it’s not currently running, its entire
    configuration and contents still exist on the filesystem of the Docker host, and
    it can be restarted at any time.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到容器显示为`Exited (0)`。停止容器就像停止虚拟机一样。尽管它目前没有运行，但它的整个配置和内容仍然存在于Docker主机的文件系统中，并且可以随时重新启动。
- en: Let’s use the `docker container start` command to bring it back from vacation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`docker container start`命令将其从休假中带回来。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`The stopped container is now restarted. Time to verify that the file we created
    earlier still exists. Connect to the restarted container with the `docker container
    exec` command.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器现在已重新启动。是时候验证我们之前创建的文件是否仍然存在了。使用`docker container exec`命令连接到重新启动的容器。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Your shell prompt will change to show that you are now operating within the
    namespace of the container.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您的shell提示符将更改以显示您现在正在容器的命名空间中操作。
- en: Verify that the file you created earlier is still there and contains the data
    you wrote to it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 验证您之前创建的文件是否仍然存在，并且包含您写入其中的数据。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`As if by magic, the file you created is still there and the data it contains
    is exactly how you left it! This proves that stopping a container does not destroy
    the container or the data inside of it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔术一样，您创建的文件仍然存在，并且其中包含的数据与您离开时完全相同！这证明停止容器不会销毁容器或其中的数据。
- en: While this example illustrates the persistent nature of containers, I should
    point out that *volumes* are the preferred way to store persistent data in containers.
    But at this stage of our journey I think this is an effective example of the persistent
    nature of containers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子说明了容器的持久性，我应该指出，*卷*是在容器中存储持久数据的首选方式。但在我们的旅程中的这个阶段，我认为这是容器持久性的一个有效例子。
- en: So far I think you’d be hard pressed to draw a major difference in the behavior
    of a container vs a VM.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我认为你很难在容器与虚拟机的行为中找到重大差异。
- en: Now let’s kill the container and delete it from our system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们杀死容器并从系统中删除它。
- en: It is possible to delete a *running* container with a single command by passing
    the `-f` flag to `docker container rm`. However, it’s considered a best practice
    to take the two-step approach of stopping the container first and then deleting
    it. This gives the application/process that the container is running a fighting
    chance of stopping cleanly. More on this in a second.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向`docker container rm`传递`-f`标志来删除*运行中*的容器。然而，最佳做法是先停止容器，然后再删除容器。这样做可以给容器正在运行的应用/进程一个干净停止的机会。稍后会详细介绍这一点。
- en: The next example will stop the `percy` container, delete it, and verify the
    operation. If your terminal is still attached to the percy container, you will
    need to get back to your Docker host’s terminal by pressing `Ctrl-PQ`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子将停止`percy`容器，删除它，并验证操作。如果您的终端仍然连接到percy容器，您需要通过按`Ctrl-PQ`返回到Docker主机的终端。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`The container is now deleted — literally wiped off the face of the planet.
    If it was a good container, it becomes a *serverless function* in the afterlife.
    If it was a naughty container, it becomes a dumb terminal :-D'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: “容器现在已被删除 - 在地球上被彻底抹去。如果它是一个好容器，它将成为*无服务器函数*在来世。如果它是一个淘气的容器，它将成为一个愚蠢的终端:-D
- en: To summarize the lifecycle of a container… You can stop, start, pause, and restart
    a container as many times as you want. And it’ll all happen really fast. But the
    container and its data will always be safe. It’s not until you explicitly delete
    a container that you run any chance of losing its data. And even then, if you’re
    storing container data in a *volume*, that data’s going to persist even after
    the container has gone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结容器的生命周期...您可以停止、启动、暂停和重新启动容器多次。而且这一切都会发生得非常快。但容器及其数据始终是安全的。直到您明确删除容器，您才有可能丢失其数据。即使在那种情况下，如果您将容器数据存储在*卷*中，那么数据将在容器消失后仍然存在。
- en: Let’s quickly mention why we recommended a two-stage approach of stopping the
    container before deleting it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速提一下为什么我们建议在删除容器之前采取两阶段的停止容器的方法。
- en: Stopping containers gracefully
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优雅地停止容器
- en: Most containers in the Linux world will run a single process. In the Windows
    world they run a few processes, but the following rules still apply.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux世界中，大多数容器将运行单个进程。在Windows世界中，它们会运行一些进程，但以下规则仍然适用。
- en: In our previous example the container was running the `/bin/bash` app. When
    you kill a running container with `docker container rm <container> -f`, the container
    will be killed without warning. The procedure is quite violent — a bit like sneaking
    up behind the container and shooting it in the back of the head. You’re literally
    giving the container, and the app it’s running, no chance to straighten its affairs
    before being killed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，容器正在运行`/bin/bash`应用程序。当您使用`docker container rm <container> -f`杀死正在运行的容器时，容器将在没有警告的情况下被杀死。这个过程非常暴力
    - 有点像从容器背后悄悄接近并向其后脑勺开枪。您实际上给了容器和它正在运行的应用程序在被杀死之前没有机会整理自己的事务。
- en: However, the `docker container stop` command is far more polite (like pointing
    a gun to the containers head and saying “you’ve got 10 seconds to say any final
    words”). It gives the process inside of the container a heads-up that it’s about
    to be stopped, giving it a chance to get things in order before the end comes.
    Once the `docker stop` command returns, you can then delete the container with
    `docker container rm`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`docker container stop`命令要温和得多（就像拿枪指着容器的头说“你有10秒钟说最后的话”）。它会提醒容器内的进程即将被停止，让它有机会在结束之前整理好事情。一旦`docker
    stop`命令返回，你就可以用`docker container rm`删除容器。
- en: The magic behind the scenes here can be explained with Linux/POSIX *signals*.
    `docker container stop` sends a **SIGTERM** signal to the PID 1 process inside
    of the container. As we just said, this gives the process a chance to clean things
    up and gracefully shut itself down. If it doesn’t exit within 10 seconds, it will
    receive a **SIGKILL**. This is effectively the bullet to the head. But hey, it
    got 10 seconds to sort itself out first!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里背后的魔法可以用Linux/POSIX *信号*来解释。`docker container stop`向容器内的PID 1进程发送**SIGTERM**信号。正如我们刚才说的，这给了进程一个机会来清理事情并优雅地关闭自己。如果它在10秒内没有退出，它将收到**SIGKILL**。这实际上就是子弹打在头上。但是嘿，它有10秒的时间先整理自己！
- en: '`docker container rm <container> -f` doesn’t bother asking nicely with a **SIGTERM**,
    it goes straight to the **SIGKILL**. Like we said a second ago, this is like creeping
    up from behind and smashing it over the head. I’m not a violent person by the
    way!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container rm <container> -f`不会用**SIGTERM**客气地询问，它直接使用**SIGKILL**。就像我们刚才说的，这就像从背后悄悄接近并猛击头部。顺便说一句，我不是一个暴力的人！'
- en: Self-healing containers with restart policies
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用重启策略的自我修复容器
- en: It’s often a good idea to run containers with a restart policy. It’s a form
    of self-healing that enables Docker to automatically restart them after certain
    events or failures have occurred.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用重启策略来运行容器是个好主意。这是一种自我修复的形式，使Docker能够在发生某些事件或故障后自动重新启动它们。
- en: Restart policies are applied per-container, and can be configured imperatively
    on the command line as part of `docker-container run` commands, or declaratively
    in Compose files for use with Docker Compose and Docker Stacks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重启策略是针对每个容器应用的，并且可以作为`docker-container run`命令的一部分在命令行上进行配置，也可以在Compose文件中声明式地用于Docker
    Compose和Docker Stacks。
- en: 'At the time of writing, the following restart policies exist:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，存在以下重启策略：
- en: '`always`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`'
- en: '`unless-stopped`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless-stopped`'
- en: '`on-failed`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on-failed`'
- en: The **always** policy is the simplest. It will always restart a stopped container
    unless it has been explicitly stopped, such as via a `docker container stop` command.
    An easy way to demonstrate this is to start a new interactive container with the
    `--restart always` policy, and tell it to run a shell process. When the container
    starts you will be attached to its shell. Typing exit from the shell will kill
    the container’s PID 1 process and therefore kill the container. However, Docker
    will automatically restart it because it was started with the `--restart always`
    policy. If you issue a `docker container ls` command, you will see that the container’s
    uptime will be less than the time since it was created. We show this in the following
    example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**always**策略是最简单的。它会始终重新启动已停止的容器，除非它已被明确停止，比如通过`docker container stop`命令。演示这一点的简单方法是使用`--restart
    always`策略启动一个新的交互式容器，并告诉它运行一个shell进程。当容器启动时，您将附加到其shell。从shell中输入exit将杀死容器的PID
    1进程，从而杀死容器。但是，Docker会自动重新启动它，因为它是使用`--restart always`策略启动的。如果您发出`docker container
    ls`命令，您将看到容器的正常运行时间将少于其创建时间。我们在以下示例中展示了这一点。'
- en: 'If you’re following a long with Windows, substitute the `docker container run`
    command in the example with this one: `docker container run --name neversaydie
    -it --restart always microsoft/powershell:nanoserver`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上进行操作，请用以下命令替换示例中的`docker container run`命令：`docker container run
    --name neversaydie -it --restart always microsoft/powershell:nanoserver`。
- en: '[PRE18]`exit[PRE19][PRE20]`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]`exit[PRE19][PRE20]`'
