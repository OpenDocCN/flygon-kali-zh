- en: Rolling Up the Sleeves
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷起袖子
- en: 'In the previous chapter, we looked at what containers are, what role they can
    fill in your infrastructure, and why Docker is the one leading the pack in service
    deployments. Now that we know what Docker is and isn''t, we can get started with
    the basics. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了容器是什么，它们在基础设施中可以扮演什么角色，以及为什么Docker是服务部署中的领头羊。现在我们知道了Docker是什么，也知道了它不是什么，我们可以开始基础知识了。在本章中，我们将涵盖以下主题：
- en: Installing Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Extending a container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展一个容器
- en: Building a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个容器
- en: Debugging containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试容器
- en: Installing Docker
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'The installation of Docker varies greatly between operating systems, but for
    most systems, there are detailed instructions at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
    Two levels of Docker are generally available: the **Community Edition** (**CE**)
    and the **Enterprise Edition** (**EE**). While slightly different, for almost
    everything that we will work on in this book, the Community Edition is perfectly
    functional and will suffice in every way. Once you reach levels of scale where
    you need much more advanced features, such as security scans, LDAP, and technical
    support, the Enterprise Edition might make sense. As would be expected, the Enterprise
    Edition is not free, and you can take a look at [https://www.docker.com/pricing](https://www.docker.com/pricing)
    to see how these editions differ.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的安装在操作系统之间有很大的差异，但对于大多数系统，都有详细的说明。通常有两个级别的Docker可用：**社区版**（**CE**）和**企业版**（**EE**）。虽然略有不同，但对于本书中我们将要处理的几乎所有内容来说，社区版都是完全功能的，完全够用。一旦你达到需要更高级功能的规模，比如安全扫描、LDAP和技术支持，企业版可能是有意义的。不出所料，企业版是收费的，您可以查看[https://www.docker.com/pricing](https://www.docker.com/pricing)来了解这些版本的区别。
- en: For our examples and any OS-specific commands in this book, from here on, we
    will be using Ubuntu's **Long Term Support** (**LTS**) version, with Ubuntu being
    currently the most popular Linux distribution. The latest version of the LTS product
    available is 16.04, which will be the base for our CLI interactions and examples
    but by the time you read this book, 18.04 might be available too. Keep in mind
    that outside of the installation part, most code and examples are very portable
    and should generally run on other platforms, so even if there are changes needed,
    they should be minimal. That said, developing Docker services on non-Linux platforms
    may not be as refined or stable due to the fact that Docker is generally used
    to deploy Linux-based services on Linux machines even though other niche cases
    are supported to some extent. Microsoft has been making significant advancements
    in this space with Docker for Windows since they have been trying to push their
    own container strategy, so keep an eye on their progress as it may become a pretty
    competent development platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的示例和任何特定于操作系统的命令，从现在开始，我们将使用Ubuntu的**长期支持**（**LTS**）版本，Ubuntu目前是最流行的Linux发行版。
    LTS产品的最新版本是16.04，这将是我们CLI交互和示例的基础，但在您阅读本书时，18.04也可能已经推出。请记住，除了安装部分外，大多数代码和示例都是非常可移植的，通常可以在其他平台上运行，因此即使需要进行更改，也应该是最小的。也就是说，在非Linux平台上开发Docker服务可能不太精细或稳定，因为Docker通常用于在Linux机器上部署基于Linux的服务，尽管其他一些特殊情况也得到了一定程度的支持。自从微软试图推动他们自己的容器策略以来，他们在这个领域取得了重大进展，因此请密切关注他们的进展，因为它可能成为一个非常有竞争力的开发平台。
- en: Some manual networking examples in later chapters may not work fully in macOS
    due to the different implementation of this subsystem for that platform. For those,
    using a virtual machine with Ubuntu LTS is advised if you want to follow along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后续章节中的手动网络示例在macOS中可能无法完全工作，因为该平台对该子系统的实现不同。对于这些情况，建议您在虚拟机上使用Ubuntu LTS进行跟随操作。
- en: 'So, with our clean Ubuntu 16.04 LTS machine, VM, or a compatible OS, let''s
    get Docker installed. While the Docker package is already available on `apt` repositories
    within the distribution, I would highly discourage installation this way, as these
    versions are usually much older. While this is not a problem for most software,
    for fast-moving projects such as Docker, it will put you at a significant disadvantage
    when it comes to support for the latest features. For this reason, we will install
    Docker from its own apt repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用我们干净的Ubuntu 16.04 LTS机器、虚拟机或兼容的操作系统，让我们安装Docker。虽然Docker软件包已经在分发中的`apt`仓库中可用，但我强烈不建议以这种方式安装，因为这些版本通常要旧得多。虽然对于大多数软件来说这不是问题，但对于像Docker这样快速发展的项目来说，这将使您在支持最新功能方面处于明显的劣势。因此，出于这个原因，我们将从Docker自己的apt仓库中安装Docker：
- en: Warning! There are couple of other ways to install Docker using many of the
    following tools, but unless absolutely necessary, installation with the `sudo
    curl -sSL https://somesite.com/ | sh` pattern or anything similar to it is a very
    dangerous thing to do as you are rooting your own box for a website without checking
    what the script does. This execution pattern also leaves minimal evidence of what
    was done behind. Additionally mid-stream exception can corrupt the download but
    still execute, partially causing damage, and you are only relying on **Transport
    Layer Security** (**TLS**), for which hundreds of organizations across the world
    can create fake certificates. In other words, if you care about your machine,
    you should never, ever try to install software in this way unless, of course,
    the software vendor is clueless about security and they force you to do this,
    in which case, you are at their mercy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！还有其他几种安装Docker的方法，但除非绝对必要，使用`sudo curl -sSL https://somesite.com/ | sh`模式或类似的方式进行安装是非常危险的，因为您在未检查脚本功能的情况下为网站的脚本授予了root权限。这种执行模式也几乎没有留下执行过程的证据。此外，中途出现的异常可能会损坏下载文件但仍然执行，部分造成损害，并且您只依赖**传输层安全性**（**TLS**），全球数百家组织都可以创建伪造证书。换句话说，如果您关心您的机器，除非软件供应商对安全一无所知并且他们强迫您这样做，否则您绝对不应该以这种方式安装软件，那么您就完全受他们的支配。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, Docker will require `sudo` (or `root`) prefixed to all of your
    commands to run including ones in this book that don''t have it explicitly mentioned.
    Generally, for development machines, this is a big pain to deal with so I might
    mention, but *strongly* discourage, that you can also add your current user to
    the `docker` group so that you do not need to prefix every Docker command with
    `sudo`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker将要求在所有命令前加上`sudo`（或`root`）来运行，包括本书中未明确提到的命令。通常情况下，对于开发机器来说，这是一个很大的麻烦，所以我可能会提到，但*强烈*不建议，您也可以将当前用户添加到`docker`组中，这样您就不需要在每个Docker命令前加上`sudo`：
- en: Add user to group with `usermod`  (for example `$ sudo usermod -aG docker $USER`).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`usermod`将用户添加到组中（例如`$ sudo usermod -aG docker $USER`）。
- en: Fully log out and log back in (groups are evaluated only on session start).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全注销并重新登录（组仅在会话启动时进行评估）。
- en: Keep in mind that this is a *huge* security hole that can allow a local user
    to escalate to root privileges trivially so never, under any circumstance, do
    this on any server that will sit on the Internet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个*巨大*的安全漏洞，可以允许本地用户轻松提升为根权限，因此在任何情况下都不要在任何将连接到互联网的服务器上执行此操作。
- en: 'If all of the preceding commands work as expected, you will be able to see
    whether Docker is installed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有前面的命令都按预期工作，您将能够看到Docker是否已安装：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having Docker installed without anything to run is pretty useless, so let us
    see whether we can get an image that we can run locally. Our choices here would
    be to either make our own image from scratch or use something that's already built.
    Given that a big reason why Docker has reached such high adoption rates is its
    ease of sharing of images through Docker Hub ([https://hub.docker.com/](https://hub.docker.com/))
    and we're just starting out, we will delay creating our own image for a little
    bit to explore this site, a centralized place for publishing and downloading Docker
    images.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Docker但没有任何东西可运行是相当无用的，所以让我们看看是否可以获得一个可以在本地运行的镜像。我们的选择是要么从头开始制作自己的镜像，要么使用已经构建好的东西。鉴于Docker之所以能够达到如此高的采用率的一个重要原因是通过Docker
    Hub（[https://hub.docker.com/](https://hub.docker.com/)）轻松共享镜像，而我们刚刚开始，我们将延迟一点时间来创建自己的镜像，以探索这个站点，这是一个集中发布和下载Docker镜像的地方。
- en: '![](assets/23f9cd78-8642-458f-a455-be3f7500a5c8.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23f9cd78-8642-458f-a455-be3f7500a5c8.png)'
- en: 'Behind this non-descriptive and bland page is the storage of thousands of Docker
    images, and since we are not interested in publishing images right now, we can
    just click on the Explore button in the top-right corner of the page to see what
    images are available:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非描述性和单调的页面背后是成千上万的Docker镜像的存储，由于我们目前不感兴趣发布镜像，我们可以点击页面右上角的“探索”按钮，看看有哪些可用的镜像：
- en: '![](assets/aa15341a-9d6e-4376-a016-ff0167b56dd5.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa15341a-9d6e-4376-a016-ff0167b56dd5.png)'
- en: As you can see, this lists the most popular images at the time of writing, but
    you can look for specific ones through the Search box in the upper-left corner
    as well. For now, as mentioned a while ago, we will not be spending too much time
    here, but it will be valuable for you to know how to run images from Docker Hub,
    so we will try to pull and run one of them to show you how it is done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这列出了写作时最受欢迎的镜像，但您也可以通过左上角的搜索框查找特定的镜像。目前，正如之前提到的，我们不会在这里花太多时间，但对于您来说，了解如何从Docker
    Hub运行镜像将是有价值的，因此我们将尝试拉取和运行其中一个来向您展示如何操作。
- en: 'The top container available here right now seems to be NGINX, so we will try
    to run that in our Docker environment. If you have not worked with NGINX before,
    it is a high-performance web server that is used by a large number of websites
    on the internet. At this stage, we just want to get the feel for running these
    containers, so let us see how that is done:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可用的顶级容器似乎是NGINX，所以我们将尝试在我们的Docker环境中运行它。如果您以前没有使用过NGINX，它是一个高性能的Web服务器，被许多互联网上的网站使用。在这个阶段，我们只是想要感受一下运行这些容器的感觉，让我们看看如何做到：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `pull` command pulls any and all layers that compose this image. In this
    case, the NGINX image is based on three stacked layers and has a hash of `788fa277..27a311c3`,
    and since we didn't specify a specific version that we wanted, we got the default
    tag, which is `latest`. With this single command, we have retrieved the NGINX
    image from Docker Hub so that we can run it locally. If we wanted to use a different
    tag or pull from a different server, the command gets the more expressive form
    similar to `docker pull <hostname_or_ip>:<port>/<tag_name>` , but we will cover
    these advanced usages in later chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull`命令拉取组成此镜像的任何和所有层。在这种情况下，NGINX镜像基于三个堆叠的层，并且具有哈希值`788fa277..27a311c3`，由于我们没有指定我们想要的特定版本，我们得到了默认标签，即`latest`。通过这个单一的命令，我们已经从Docker
    Hub检索了NGINX镜像，以便我们可以在本地运行它。如果我们想使用不同的标签或从不同的服务器拉取，该命令将变得更加具有表现力，类似于`docker pull
    <hostname_or_ip>:<port>/<tag_name>`，但我们将在后面的章节中介绍这些高级用法。'
- en: 'With the image now sitting in our local Docker storage (usually in `/var/lib/docker`),
    we can try to run it. NGINX has an absolute sea of possible options that you can
    examine in further detail at [https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/),
    but we are interested in just starting the image for now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像已经存储在我们本地的Docker存储中（通常在`/var/lib/docker`中），我们可以尝试运行它。NGINX有大量可能的选项，您可以在[https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)上进一步了解，但我们现在只对启动镜像感兴趣：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You probably noticed that nothing is happening, but do not worry as this is
    expected. Sadly, this command by itself is not enough as NGINX will run in foreground
    and not be accessible over a socket at all, so we need to cover a few flags and
    switches to really make it useful. So let''s shut the container down by pressing
    *Ctrl* + *C* and try again, this time adding some of the necessary flags:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到什么都没有发生，但不要担心，这是预期的。遗憾的是，单独这个命令是不够的，因为NGINX将在前台运行，并且根本无法通过套接字访问，所以我们需要覆盖一些标志和开关，使其真正有用。所以让我们按下*Ctrl*
    + *C*关闭容器，然后再试一次，这次添加一些必要的标志：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-d` flag runs the container in the background (the detached mode) so that
    our Terminal isn't held on by NGINX and the `-p 8080:80` flag maps our local port
    `8080` to the container's port `80`. Containers often have specific ports that
    they expose, amd in this case, it is `80` but without the mapping we would have
    no way of accessing it. The output that the command returns is a unique identifier
    (container ID) that can be used to track and control this specific container after
    starting it. Hopefully, you can now see how the port whitelisting approach of
    Docker adds an extra level of security as only the things you explicitly allow
    to listen are permitted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`标志以后台模式运行容器，这样我们的终端就不会被NGINX占用，而`-p 8080:80`标志将我们的本地端口`8080`映射到容器的端口`80`。容器通常会暴露特定的端口，而在这种情况下，是`80`，但如果没有映射，我们将无法访问它。命令返回的输出是一个唯一的标识符（容器ID），可以用来在启动后跟踪和控制这个特定的容器。希望您现在能够看到Docker的端口白名单方法如何增加了额外的安全级别，因为只有您明确允许监听的东西才被允许。'
- en: 'You can now open your browser to `http://localhost:8080`, and you should see
    a page similar to this one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以打开浏览器访问`http://localhost:8080`，您应该会看到一个类似这样的页面：
- en: '![](assets/287da44a-bb94-449b-8065-7dd405fd8a17.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/287da44a-bb94-449b-8065-7dd405fd8a17.png)'
- en: 'But how exactly did we know that port `80` needs to be listened to? Indeed,
    we will cover that in just a second, but first, because we started this container
    in the detached mode, it will still be running in the background and we should
    probably make sure that we stop it too. To see which containers we have running,
    let''s check our Docker container statuses with `docker ps`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们究竟是如何知道端口`80`需要被监听的呢？确实，我们将在接下来的一秒钟内介绍这一点，但首先，因为我们以分离模式启动了这个容器，它仍然在后台运行，我们可能应该确保停止它。要查看我们正在运行的容器，让我们用`docker
    ps`来检查我们的Docker容器状态：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we see here is that our NGINX container is still running, that it has mapped
    localhost interface ports `8080` (including externally accessible ones) with the
    container's port `80`, and that we have been running it for `13` minutes. If we
    had more containers, they would all be listed here so this command is extremely
    useful for working with Docker containers and is generally used for debugging
    and container management.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是，我们的NGINX容器仍在运行，它已经将本地主机接口端口`8080`（包括外部可访问的端口）映射到容器的端口`80`，而且我们已经运行了`13`分钟。如果我们有更多的容器，它们都会在这里列出，因此这个命令对于处理Docker容器非常有用，通常用于调试和容器管理。
- en: 'Since we wanted to shut this container down, we will actually do that now.
    To shut a container down, we need to know the container ID that is both the value
    that was returned by `docker run` and the value that the first column of `docker
    ps` shows (`dd1fd1b62d9c`). Feel free to use either the short or long version
    of the ID, but for brevity, we will use the former:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要关闭这个容器，我们现在将实际执行。要关闭容器，我们需要知道容器ID，这是`docker run`返回的值，也是`docker ps`的第一列显示的值（`dd1fd1b62d9c`）。可以使用ID的短或长版本，但为了简洁起见，我们将使用前者：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will gracefully try to stop the container and return the resources used
    back to the OS and after a specific timeout, kill it forcefully. If the container
    was really stuck and we knew it, we could replace `stop` with `kill` to hard kill
    the process, but that''s rarely needed since `stop` generally does the same thing
    if the process is not responding. We will now make sure that our container is
    gone:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将优雅地尝试停止容器并将使用的资源返回给操作系统，并在特定的超时后强制杀死它。如果容器真的卡住了，我们可以用`kill`替换`stop`来强制杀死进程，但这很少需要，因为如果进程没有响应，`stop`通常会做同样的事情。我们现在要确保我们的容器已经消失了：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Yes, things look as we expect them to, but beware that while stopped containers
    are not visible, they are not completely removed from the filesystem by default:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，事情看起来正如我们所期望的那样，但请注意，虽然停止的容器不可见，但默认情况下它们并没有完全从文件系统中删除：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-a` flag is used to show all container statuses, not just the running ones,
    and you can see that the system still knows about our old container. We can even
    resume it with `docker start`!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a`标志用于显示所有容器状态，而不仅仅是正在运行的容器，您可以看到系统仍然知道我们的旧容器。我们甚至可以使用`docker start`来恢复它！'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To really remove our container permanently, we need to explicitly get rid of
    it using `docker rm`, as shown here, or run the `docker run` command with the
    `--rm` switch (we''ll cover this one in the next few pages):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正永久删除容器，我们需要明确地使用`docker rm`来摆脱它，如下所示，或者使用`--rm`开关运行`docker run`命令（我们将在接下来的几页中介绍这个）：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Success!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 'Now let us get back to the earlier question of how we knew that the container
    needed to have port 80 mapped to it? We have a couple of options there for finding
    this information out, and the simplest one is starting the container and checking
    in `docker ps` to see which ports are unbound:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到之前的问题，我们如何知道容器需要将端口80映射到它？我们有几种选项可以找到这些信息，最简单的一种是启动容器并在`docker ps`中检查未绑定的端口：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The new flag here that we used with `docker run` is `--rm`, which we just mentioned,
    and it tells the Docker daemon to remove the container completely after it is
    stopped so we don't have to do it manually ourselves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`docker run`中使用的新标志是`--rm`，我们刚刚提到过，它告诉Docker守护程序在停止后完全删除容器，这样我们就不必手动删除了。
- en: If you already have a container that you want to check the mapped ports on,
    you can use `docker port <container_id>` command but we are omitting it here since
    it cannot be used on images, but just containers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一个要检查映射端口的容器，可以使用`docker port <container_id>`命令，但我们在这里省略了，因为它不能用于镜像，而只能用于容器。
- en: 'While this is the quickest way to see what ports will be needed, the general
    way to inspect an image outside of reading its Dockerfile and documentation is
    through `docker inspect`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是查看所需端口的最快方法，但在读取其Dockerfile和文档之外检查镜像的一般方法是通过`docker inspect`：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Additionally, `docker inspect` can show all kinds of other interesting information,
    such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`docker inspect`还可以显示各种其他有趣的信息，例如以下内容：
- en: The ID of the image
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像的ID
- en: The tag name
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签名称
- en: The image creation date
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像创建日期
- en: Hardcoded environment variables
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码的环境变量
- en: The command that the container runs on start
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器在启动时运行的命令
- en: The size of the container
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的大小
- en: Image layers IDs
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像层ID
- en: Volumes specified
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的卷
- en: Feel free to run the inspect command on any container or image and see what
    gems you might find there. Majority of the time, this output is mainly used for
    debugging, but in cases where the image documentation is lacking, it can be an
    invaluable tool to get you running in a minimal amount of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随时运行检查命令在任何容器或镜像上，并查看您可能在那里找到的宝石。大多数情况下，这个输出主要用于调试，但在镜像文档缺乏的情况下，它可以是一个无价的工具，让您在最短的时间内运行起来。
- en: Debugging containers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试容器
- en: 'Often in general work with containers, you will likely have to figure out what
    is going on with a container that is running, but `docker ps` is not good enough
    to provide you with all the information you need to figure things out. For these
    cases, the first command to use is `docker logs`. This command displays any output
    that the container has emitted, including both `stdout` and `stderr` streams.
    For the following logs, I started the same NGINX container from before and accessed
    its hosted page on `localhost`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在与容器一般工作中，您可能需要弄清楚正在运行的容器的情况，但`docker ps`并不能提供您需要弄清楚事情的所有信息。对于这些情况，要使用的第一个命令是`docker
    logs`。这个命令显示容器发出的任何输出，包括`stdout`和`stderr`流。对于以下日志，我从前面开始了相同的NGINX容器，并访问了它在`localhost`上托管的页面。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see here that NGINX records all access and the associated response codes
    that are invaluable to debugging a web server. In general, the output can vary
    from very useful to garbage depending on what is running the service, but it is
    usually a good place to start your search. You can also add the `-f` flag if you
    want to follow the logs as they are being written, which is very helpful when
    logs are large and you are trying to filter noise from specific things you are
    looking for.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，NGINX记录了所有访问和相关的响应代码，这对于调试Web服务器非常宝贵。一般来说，输出可以因服务运行的内容而有很大的变化，但通常是开始搜索的好地方。如果您想要在日志被写入时跟踪日志，还可以添加`-f`标志，这在日志很大并且您试图过滤特定内容时非常有帮助。
- en: Seeing what the container sees
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看到容器看到的内容
- en: 'When logs aren''t really enough to figure things out, the command to use is
    `docker exec` in order to execute a command on the running container that can
    include access to a full-blown shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当日志并不能真正解决问题时，要使用的命令是`docker exec`，以便在运行的容器上执行一个命令，可以包括访问完整的shell：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we used `docker exec` to run the `ls` command in the container,
    but as-is that is not really a powerful debugging tool. What if we try to get
    that full shell within the container and examine it that way?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`docker exec`在容器中运行`ls`命令，但实际上这并不是一个强大的调试工具。如果我们尝试在容器内获取完整的shell并以这种方式进行检查呢？
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, we used `-it`, which is shorthand for `-i` and `-t` flags that combine
    to set up the interactive Terminal needed for a full shell access and then we
    use `/bin/bash` to run Bash within the container. The shell within the container
    is a much more useful tool here, but we are at the mercy of the container itself
    in terms of installed tooling since many images trim out any unnecessary packages
    from the image--in this case, the NGINX container doesn''t have `ps`, which is
    an extremely valuable utility for finding causes of problems. Since containers
    are isolated throwaway components generally, sometimes it might be fine to add
    your debugging tools to the container in order to find out what is causing problems
    (though we will cover a much better way of doing this with `pid` namespaces joining
    in later chapters):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用了`-it`，这是`-i`和`-t`标志的简写，结合起来设置了所需的交互式终端，然后我们使用`/bin/bash`在容器内运行Bash。容器内的shell在这里是一个更有用的工具，但由于许多镜像会删除图像中的任何不必要的软件包，我们受制于容器本身--在这种情况下，NGINX容器没有`ps`，这是一个非常有价值的用于查找问题原因的实用程序。由于容器通常是隔离的一次性组件，有时可能可以向容器添加调试工具以找出问题的原因（尽管我们将在后面的章节中介绍使用`pid`命名空间的更好方法）：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, adding any debug tooling to the container from its upstream
    distribution is easy, but be aware that once you find your issue, you should start
    a new container and remove the old one to clean up the leftover junk since it
    is wasting space and a new container will start from the image that did not have
    your newly-installed debugging tools added (in our case `procps`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，从上游分发的任何调试工具都很容易添加到容器中，但请注意，一旦找到问题，您应该启动一个新的容器并删除旧的容器，以清理掉剩下的垃圾，因为它浪费空间，而新的容器将从没有添加您新安装的调试工具的图像开始（在我们的情况下是`procps`）。
- en: Another thing to keep in mind is that sometimes, the images prevent the installation
    of additional packages, so for those cases we will need to wait until later chapters
    to see how we can use namespaces to work in such constrained settings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事需要记住的是，有时镜像会阻止安装额外的软件包，因此对于这些情况，我们需要等到后面的章节来看看如何使用命名空间在这样受限制的环境中工作。
- en: Sometimes, the container is locked into a limited user shell, and because of
    it, you will be unable to access or modify other parts of the system of the container.
    In such configurations, you can add the `-u 0` flag to run the `docker exec` command
    as `root` (`user 0`). You can also specify any other username or user ID instead,
    but generally if you need a secondary user to work with on a container, `root`
    is what you want.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，容器被锁定在有限的用户shell中，因此您将无法访问或修改容器系统的其他部分。在这种配置中，您可以添加`-u 0`标志来将`docker exec`命令作为`root`（`user
    0`）运行。您也可以指定任何其他用户名或用户ID，但通常如果您需要在容器上使用辅助用户，`root`是您想要的。
- en: Our first Dockerfile
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Dockerfile
- en: 'Now that we know a little bit about how to get around containers, this is a
    good place to try out creating our own container. To start building a container,
    the first thing that we need to know is that the default filename that Docker
    looks for when building images is `Dockerfile`. While you can use different names
    for this main configuration file, it is highly discouraged though in some rare
    cases, you might not be able to avoid it - if, for example, you need a test suite
    image and the main image build files in the same folder. For now, we will assume
    you just have a single build configuration, and with that in mind, how about we
    see what one of these basic `Dockerfile` looks like. Create a test folder somewhere
    on your filesystem and put this into a file named `Dockerfile`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何操作容器有了一点了解，这是一个很好的地方来尝试创建我们自己的容器。要开始构建容器，我们需要知道的第一件事是，Docker在构建镜像时查找的默认文件名是`Dockerfile`。虽然您可以为此主要配置文件使用不同的名称，但这是极不鼓励的，尽管在一些罕见的情况下，您可能无法避免
    - 例如，如果您需要一个测试套件镜像和主镜像构建文件在同一个文件夹中。现在，我们假设您只有一个单一的构建配置，考虑到这一点，我们来看看这些基本`Dockerfile`是什么样子的。在您的文件系统的某个地方创建一个测试文件夹，并将其放入名为`Dockerfile`的文件中：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's examine this file line by line. First, we have the `FROM ubuntu:latest`
    line in there. This line indicates that we want to use the latest Ubuntu Docker
    image as our base on which we will layer our own service. This image will be automatically
    pulled from Docker Hub, but this image can also be from a custom repository, your
    own local image, and could be based on any other image as long as it provides
    a good base for your service (that is, NGINX, Apline Linux, Jenkins, and so on)
    if we wanted to.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行检查这个文件。首先，我们有`FROM ubuntu:latest`这一行。这行表示我们要使用最新的Ubuntu Docker镜像作为我们自己服务的基础。这个镜像将自动从Docker
    Hub中拉取，但这个镜像也可以来自自定义存储库、您自己的本地镜像，并且可以基于任何其他镜像，只要它为您的服务提供了一个良好的基础（即NGINX、Apline
    Linux、Jenkins等）。
- en: The next line is very important as the base Ubuntu image does not come with
    almost anything out of the box, so we need to install the package that provides
    the ping utility (`iputils-ping`) through its package manager `apt` , just like
    we would on the command line by using the `RUN` directive to Docker. Before we
    install it, though, we also need to make sure that our update indexes are up-to-date,
    and we use `apt-get update` for that. In a bit, we will cover in detail why we
    used `&&` to chain the `update` and `install` commands, but for now, we will magically
    ignore it so that we don't derail our example too much.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一行非常重要，因为基本的Ubuntu镜像默认情况下几乎没有任何东西，所以我们需要通过其软件包管理器`apt`安装提供ping实用程序（`iputils-ping`）的软件包，就像我们在命令行上使用`RUN`指令给Docker一样。不过，在安装之前，我们还需要确保我们的更新索引是最新的，我们使用`apt-get
    update`来做到这一点。稍后，我们将详细介绍为什么使用`&&`来链接`update`和`install`命令，但现在我们将神奇地忽略它，以免我们的示例偏离太多。
- en: The `CMD` directive instructs Docker that by default, Docker will run `"ping"
    "google.com"` every time the container is started without further arguments. This
    directive is used to start the service within the container, and it ties the life
    cycle of the container to that process, so if our `ping` fails, our container
    terminates, and vice versa. You can only have one `CMD` line in your Dockerfile,
    so be especially careful what you use it for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令指示Docker默认情况下，每次启动容器时Docker都会运行`"ping" "google.com"`，而无需进一步的参数。该指令用于在容器内启动服务，并将容器的生命周期与该进程绑定，因此如果我们的`ping`失败，容器将终止，反之亦然。您的Dockerfile中只能有一行`CMD`，因此要特别小心如何使用它。'
- en: 'Now that we have the whole container configured, let''s build it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好整个容器，让我们来构建它：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As the comment on it implies, what we did here with `docker build -t test_container
    .` is that we built the container (using the default Dockerfile configuration
    name) in our current directory and tagged it with the name `test_container`. Since
    we didn''t specify the version at the end of `test_container`, Docker assigned
    us one called `latest`, as we can see from the end of the output. If we carefully
    examine the output, we can also see that each change to the base image creates
    a new layer and that layer''s ID is then used as the input into the next directive,
    each layer creating its own filesystem diff onto the image. If, for example, we
    run the build again, Docker is smart enough to know that nothing has changed and
    it will use the cached version of those layers again. Compare the final container
    ID (`a719d8db1c35`) with the one from the previous run:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它所暗示的评论，我们在这里使用`docker build -t test_container .`构建了容器（使用默认的Dockerfile配置名称）在我们当前的目录，并用名称`test_container`标记了它。由于我们没有在`test_container`的末尾指定版本，Docker为我们分配了一个称为`latest`的版本，正如我们可以从输出的末尾看到的那样。如果我们仔细检查输出，我们还可以看到对基本镜像的每个更改都会创建一个新的层，并且该层的ID然后被用作下一个指令的输入，每个层都会将自己的文件系统差异添加到镜像中。例如，如果我们再次运行构建，Docker足够聪明，知道没有任何变化，它将再次使用这些层的缓存版本。将最终容器ID（`a719d8db1c35`）与上一次运行的ID进行比较：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If any change is detected in the directives of the Dockerfile, Docker will rebuild
    that layer and any subsequent ones to ensure consistency. This functionality and
    selective "cache busting" will also be covered later and it has a very important
    role in managing your repository and image sizes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Dockerfile的指令中检测到任何更改，Docker将重建该层和任何后续层，以确保一致性。这种功能和选择性的“缓存破坏”将在以后进行介绍，并且它在管理您的存储库和镜像大小方面起着非常重要的作用。
- en: 'With the container built, let''s see whether it actually works (to exit its
    loop, press *Ctrl* + *C*):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 容器构建完成后，让我们看看它是否真的有效（要退出循环，请按*Ctrl* + *C*）：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another success! You wrote your first running Docker container!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 又一个成功！你写了你的第一个运行Docker容器！
- en: Breaking the cache
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破缓存
- en: 'In the container we just wrote, we somewhat glanced over the line `RUN apt-get
    update -q && apt-get install -qy iputils-ping` since it requires a bit of a deeper
    discussion here. In most Linux distributions, packages rotate in versions all
    the time, but the listing of these indexes that tell us where to find these is
    baked into the original Docker image when it gets created (`ubuntu:latest` in
    this case). Before we can install a package, in most cases, our index files have
    been stale for too long (if they haven''t been completely removed), so we need
    to update them. Splitting this `&&` joined line into two separate ones would work
    for that first build:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚写的容器中，我们有点忽略了这一行`RUN apt-get update -q && apt-get install -qy iputils-ping`，因为它需要在这里进行更深入的讨论。在大多数Linux发行版中，软件包的版本经常变化，但告诉我们在哪里找到这些软件包的索引列表是在创建原始Docker镜像时就已经固定了（在这种情况下是`ubuntu:latest`）。在大多数情况下，在我们安装软件包之前，我们的索引文件已经过时太久了（如果它们没有被完全删除），所以我们需要更新它们。将这个`&&`连接的行拆分成两个单独的行将适用于第一次构建：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But what happens when you add another package to that second line later, as
    shown in the following line?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你以后在第二行添加另一个软件包时，会发生什么，就像下一行所示的那样？
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, Docker is not very smart and will consider the `update` line to
    be unchanged and will not run the update command again, so it will use the state
    from the cache for the update layer and then continue on to the next one that
    tries to install `curl` (since that one did change since the last build), which
    is likely to fail if enough versions have been rotated in the repositories as
    the indexes will be stale again. To prevent this from occurring, we join the `update`
    and the `install` commands with `&&` so they are treated as one directive and
    create one layer, in which case, changing any part of either of the two joined
    commands will break the cache and run the `update` correctly. Sadly, as you get
    more involved with scalable Docker components, using odd tricks such as these
    to manage the cache and do selective cache busting will become a large part of
    your work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Docker 并不是很智能，它会认为 `update` 行没有改变，不会再次运行更新命令，因此它将使用缓存中的状态进行更新层，然后继续下一个尝试安装
    `curl` 的命令（自上次构建以来已更改），如果仓库中的版本已经足够多次轮换，索引将再次过时，这很可能会失败。为了防止这种情况发生，我们使用 `&&` 将
    `update` 和 `install` 命令连接起来，这样它们将被视为一个指令并创建一个层，在这种情况下，更改两个连接命令中的任何部分都将破坏缓存并正确运行
    `update`。不幸的是，随着您更多地涉足可扩展的 Docker 组件，使用这些奇技淫巧来管理缓存和进行选择性缓存破坏将成为您工作的重要部分。
- en: A container more practical
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更实用的容器。
- en: This is probably where we start diverging from other Docker materials out there
    that practically assume that with just this basic knowledge, the rest of the work
    is a cakewalk when it is really nothing like that. It is not rocket science, but
    these simple examples really do not do enough to get us where we need to be, so
    we will use a practical example based a bit on our previous work with NGINX and
    create a container that uses this web server image to provide and serve up content
    that we will bake into the image.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们开始与其他 Docker 材料有所不同的地方，其他材料几乎假设只要掌握了这些基本知识，其余的工作就像小菜一碟一样，但实际上并非如此。这并不是什么高深的科学，但这些简单的例子确实不足以让我们达到我们需要的地方，因此我们将使用一个实际的例子，基于我们之前使用
    NGINX 的工作，并创建一个使用这个 Web 服务器镜像的容器，以提供和提供我们将嵌入到镜像中的内容。
- en: This example and all the other ones in this book are also available on GitHub
    at [https://github.com/sgnn7/deploying_with_docker](https://github.com/sgnn7/deploying_with_docker).
    You can use either `git` or their web interface to follow along with the examples,
    but all examples of code that we will use will be directly included in the book
    too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的这个例子和其他所有例子也可以在 GitHub 上找到 [https://github.com/sgnn7/deploying_with_docker](https://github.com/sgnn7/deploying_with_docker)。您可以使用
    `git` 或他们的 Web 界面来跟随这些例子，但我们将使用的所有代码示例也将直接包含在书中。
- en: 'To begin creating our web server, we need to create a directory to put all
    of our files in:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建我们的 Web 服务器，我们需要创建一个目录来放置我们所有的文件：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first file we need to create is our dummy text file that we will try to
    serve up in the image:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个文件是我们将尝试在镜像中提供的虚拟文本文件：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next file we will need is the required NGINX configuration. Put the following
    text into a file called `nginx_main_site.conf`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要的文件是所需的 NGINX 配置。将以下文本放入一个名为 `nginx_main_site.conf` 的文件中：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you've never worked with NGINX, let's check out what this file does. In the
    first block, we are creating a `server` that listens on port `80` rooted in `/srv/www/html`
    on the image. The second block, while not strictly needed and would require changing
    for bigger websites, should be muscle memory for anyone working on NGINX since
    it prevents the downloading of hidden files like `.htaccess`, `.htpasswd`, and
    many others that should not be available publicly. The last block just makes sure
    that any path starting with `/` will be read from `root` and if the index file
    is not provided, it will use `index.html`. If no such file is available and we
    are in a directory, `autoindex` ensures that it can show you a human-readable
    listing of a directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过 NGINX，让我们看看这个文件做了什么。在第一个块中，我们创建了一个在镜像上以 `/srv/www/html` 为根的监听端口 `80`
    的 `server`。第二个块虽然不是严格必需的，并且对于更大的网站需要进行更改，但对于任何在 NGINX 上工作的人来说，这应该是一种肌肉记忆，因为它可以防止下载像
    `.htaccess`、`.htpasswd` 和许多其他不应该公开的隐藏文件。最后一个块只是确保任何以 `/` 开头的路径将从 `root` 中读取，并且如果没有提供索引文件，它将使用
    `index.html`。如果没有这样的文件可用并且我们在一个目录中，`autoindex` 确保它可以向您显示一个目录的可读列表。
- en: While this NGINX configuration is functional, there are many things that it
    is not including (SSL configuration, logging, error files, file lookup matching,
    and so on), but that is mostly because this is a book is trying to focus on Docker
    itself and not NGINX. If you would like to learn more about how to fully and properly
    configure NGINX, you can visit [https://nginx.org/en/docs/](https://nginx.org/en/docs/)
    for more information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个 NGINX 配置是功能性的，但它还有很多不包括的东西（如 SSL 配置、日志记录、错误文件、文件查找匹配等），但这主要是因为这本书试图专注于
    Docker 本身而不是 NGINX。如果您想了解如何完全和正确地配置 NGINX，您可以访问 [https://nginx.org/en/docs/](https://nginx.org/en/docs/)
    了解更多信息。
- en: 'With the configuration written, we can now create our Dockerfile, which will
    take our test file, our configuration file, and the NGINX image and turn it all
    into a Docker image that runs a web server and serves up our test file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 配置写好后，我们现在可以创建我们的 Dockerfile，它将获取我们的测试文件、配置文件和 NGINX 镜像，并将它们转换成一个运行 Web 服务器并提供我们的测试文件的
    Docker 镜像。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This Dockerfile probably looks a lot different from the first one, so we will
    spend some time diving into what we are doing here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 可能看起来与第一个有很大不同，所以我们将花一些时间来深入了解我们在这里做了什么。
- en: Extending another container with FROM
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FROM 扩展另一个容器
- en: Similar to our last container, our `FROM nginx:latest` line ensures that we
    are using the latest version of a base image, but instead of Ubuntu, here, we
    will use NGINX as our base. The `latest` ensures that we get the image with the
    latest features and often patches too at a slight risk of breakages and API incompatibility
    in the future.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们上一个容器类似，我们的 `FROM nginx:latest` 行确保我们使用基础镜像的最新版本，但这里我们将使用 NGINX 作为基础，而不是
    Ubuntu。`latest` 确保我们获取具有最新功能和通常也有补丁的镜像，但稍微存在未来破坏和 API 不兼容的风险。
- en: When writing your Docker containers, you will often have to make these trade-off
    decisions based on your situation and stability requirements, but the NGINX API
    has been very stable for years now, so in this specific case, we do not need the
    stability that the named tags provide. If we wanted one of those tagged versions
    here, `latest` would just change to the version we wanted that is offered on Docker
    Hub, which we can find at [https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/) ,
    so something like `FROM nginx:1.13` would have been perfectly fine too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Docker容器时，您通常必须根据您的情况和稳定性要求做出这些权衡决定，但是NGINX API多年来一直非常稳定，因此在这种特定情况下，我们不需要命名标签提供的稳定性。如果我们想在这里使用其中一个带有标签的版本，`latest`只需更改为我们在Docker
    Hub上找到的所需版本，例如[https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)，因此像`FROM
    nginx:1.13`这样的东西也完全可以。
- en: Ensuring the latest patches are included
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保包含最新的补丁
- en: Our next steps, `apt-get upgrade` and `apt-get dist-upgrade`, are a bit controversial
    in the current Docker world, but I think they are a good addition, and I'll explain
    why. On a regular `deb` package-based Linux distribution (that is, Debian, Ubuntu,
    and so on), these two commands ensure that your system is fully up to date with
    the currently released packages for your version of the system. This means that
    any package that isn't the newest version will be upgraded and any obsolete packages
    will be replaced with newer ones. Since the general maxim of Docker is that the
    containers are more or less disposable, updating your container this way seems
    to be somewhat frowned upon, but it's not without its faults.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步，`apt-get upgrade` 和 `apt-get dist-upgrade`，在当前的Docker世界中有点争议，但我认为它们是一个很好的补充，我会解释原因。在常规的基于`deb`软件包的Linux发行版（即Debian，Ubuntu等），这两个命令确保您的系统与当前发布的软件包完全保持最新。这意味着任何不是最新版本的软件包将被升级，任何过时的软件包将被替换为更新的软件包。由于Docker的一般准则是容器多多少是可丢弃的，以这种方式更新容器似乎有点不受欢迎，但它并非没有缺点。
- en: Since most Docker images on Docker Hub are only built when the base source files
    or Dockerfile itself changes, many of these images have older and/or unpatched
    system libraries, so when the service uses them as a dynamic library, it may be
    vulnerable to any bugs that have since been fixed. To ensure that we are not behind
    on this security hardening, we make sure that we update the system before we do
    anything else. While there is a small risk of the service breaking due to the
    system API possibly changing and there is an increase in image size due to the
    additional changes applied, the trade-off is, in my opinion, not good enough to
    leave the service unprotected, but feel free to use your best judgment here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker Hub上的大多数Docker镜像只有在基本源文件或Dockerfile本身发生更改时才构建，因此许多这些镜像具有较旧和/或未修补的系统库，因此当服务将它们用作动态库时，可能会受到已经修复的任何错误的影响。为了确保我们在这方面的安全加固工作不落后，我们确保在做任何其他事情之前更新系统。虽然由于系统API可能发生变化而导致服务中断的风险很小，并且由于应用了额外的更改而导致镜像大小增加，但在我看来，这种权衡不足以让服务处于无保护状态，但在这里请随意使用您的最佳判断。
- en: Applying our custom NGINX configuration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用我们的自定义NGINX配置
- en: Our directive after the system update (`RUN rm /etc/nginx/conf.d/default.conf`)
    is one that removes the default web server configuration from the container. You
    can find out more about the NGINX configuration with the link from our last tip,
    but for now, it will suffice to say that by default, all the individual site configuration
    files are stored in `/etc/nginx/conf.d` and NGINX Docker image comes out of the
    box with a simple example file called `default.conf` , which we absolutely do
    not want to use.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在系统更新后的指令（`RUN rm /etc/nginx/conf.d/default.conf`）是删除容器中默认的web服务器配置。您可以通过我们上一个提示中的链接了解更多关于NGINX配置的信息，但现在，我们可以说默认情况下，所有单独的站点配置文件都存储在`/etc/nginx/conf.d`中，NGINX
    Docker镜像默认带有一个名为`default.conf`的简单示例文件，我们绝对不想使用。
- en: While we could overwrite the mentioned file, we would be stuck with the name
    `default`, which isn't very descriptive, so for our configuration, we will delete
    this one and add ours with a better filename.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以覆盖提到的文件，但我们将被困在名为`default`的名称中，这并不是很描述性的，因此对于我们的配置，我们将删除这个文件，并使用一个更好的文件名添加我们自己的文件。
- en: 'Next, we need to make sure that the folder we will be serving files from is
    available and readable by the web server process. The first command using `mkdir
    -p` creates all the relevant directories, but since NGINX doesn''t run as the
    root, we need to know what user the process will be reading the files we want
    to serve up or otherwise our server will not be able to display anything. We can
    find what the original configuration has there as the default user by showing
    the first few lines of the system-wide NGINX configuration included in the image
    at `/etc/nginx/nginx.conf`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们将要提供文件的文件夹可以被网络服务器进程访问和读取。使用`mkdir -p`的第一个命令创建了所有相关的目录，但由于NGINX不以root身份运行，我们需要知道进程将以什么用户来读取我们想要提供的文件，否则我们的服务器将无法显示任何内容。我们可以通过显示包含在镜像中的系统范围NGINX配置的前几行来找到原始配置中的默认用户，该配置位于`/etc/nginx/nginx.conf`中。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Perfect! Well, now that the user that needs to be able to read this directory
    is `nginx` , we will change the owner of our target folder with `chown nginx:nginx
    /srv/www/html` , but what is going on with that new style of `run` Docker command
    we just used when trying to find this out? If you include a command after specifying
    the image name instead of the `CMD` directive in the image, Docker will substitute
    it with this new command. In the preceding command, we are running the `/bin/head`
    executable, passing in arguments to tell it that we only want the top two lines
    from the `/etc/nginx/nginx.conf` file. Since this command exits as soon as it
    is done, the container stops and is fully removed because we used the `--rm` flag.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，需要能够读取这个目录的用户是`nginx`，我们将使用`chown nginx:nginx /srv/www/html`来更改我们目标文件夹的所有者，但是我们刚刚使用了新的`run`
    Docker命令来尝试找到这个信息，这是怎么回事？如果在指定镜像名称后包含一个命令，而不是在镜像中使用`CMD`指令，Docker将用这个新命令替换它。在前面的命令中，我们运行了`/bin/head`可执行文件，并传入参数告诉它我们只想要从`/etc/nginx/nginx.conf`文件中获取前两行。由于这个命令一旦完成就退出了，容器就会停止并完全删除，因为我们使用了`--rm`标志。
- en: With the default configuration gone and our directories created, we can now
    copy our main configuration for NGINX in place with `COPY nginx_main_site.conf
    /etc/nginx/conf.d/`. The `COPY` argument does pretty much the obvious thing of
    copying a file from the current build directory into the image at a specified
    location.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随着默认配置的消失和我们的目录创建，我们现在可以使用`COPY nginx_main_site.conf /etc/nginx/conf.d/`将NGINX的主要配置放在指定位置。`COPY`参数基本上就是将当前构建目录中的文件复制到镜像中的指定位置。
- en: Be very careful with how you end the `COPY` directive argument, as leaving the
    slash off will put the source into a file at the destination even if the destination
    is a directory. To ensure that this doesn't happen, always end your target directory
    paths with a slash.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 非常小心地结束`COPY`指令的参数，如果不加斜杠，源文件会被放入目标文件，即使目标是一个目录。为了确保这种情况不会发生，始终在目标目录路径的末尾加上斜杠。
- en: Adding our main `test.txt` file that we want hosted is the last part, and it
    follows along the same lines as the other `COPY` directive, but we will make sure
    that we put this one in the folder that our NGINX configuration is referencing.
    Since we turned on the `autoindex` flag for this endpoint, there are no additional
    steps to be taken as the folder itself will be browsable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们想要托管的主要`test.txt`文件是最后一部分，它遵循与其他`COPY`指令相同的步骤，但我们将确保将其放入我们的NGINX配置引用的文件夹中。由于我们为这个端点打开了`autoindex`标志，因此不需要采取其他步骤，因为文件夹本身是可浏览的。
- en: Building and running
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行
- en: 'Now that we went over the whole build configuration, we can create our image
    and see what we just made:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了整个构建配置，我们可以创建我们的镜像，看看我们刚刚做了什么：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Seems like the container build is just fine; let''s run it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 容器构建似乎很好，让我们来运行它：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So far, so good, as it seems to be running fine. Now we will access the container
    with our browser at `http://localhost:8080`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，似乎运行得很好。现在我们将在`http://localhost:8080`上用浏览器访问容器。
- en: '![](assets/db512100-8d98-4a43-b3a1-e44bf11f56a2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db512100-8d98-4a43-b3a1-e44bf11f56a2.png)'
- en: 'As we were hoping, our server is working and showing us the content of `/srv/www/html`,
    but let''s click on `test.txt` to make sure it is working too:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所希望的那样，我们的服务器正在工作，并显示`/srv/www/html`的内容，但让我们点击`test.txt`，确保它也在工作：
- en: '![](assets/9fe2c484-ccde-41db-b19e-ff2c81ffa618.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9fe2c484-ccde-41db-b19e-ff2c81ffa618.png)'
- en: Great, it looks like our plan worked and we have created a high-performance
    static website hosting server container! Sure, there are many other things we
    can add to this, but our main goal of extending a sample image to do something
    useful is a success!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，看起来我们的计划成功了，我们创建了一个高性能的静态网站托管服务器容器！当然，我们还可以添加许多其他东西，但我们扩展示例镜像以执行一些有用的操作的主要目标已经实现了！
- en: Service from scratch
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始的服务
- en: Our last example was decently comprehensive but it left out some important Docker
    commands that we should also know, so we will use another example, albeit reworking
    the web server solution in a slightly less optimal way, to both show them used
    and to explain what they do. In the process, we will go a bit deeper and see whether
    we can make as many parts of the service on our own.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一个示例相当全面，但遗漏了一些重要的Docker命令，我们也应该知道，因此我们将使用另一个示例，尽管以略微不太理想的方式重新设计Web服务器解决方案，以展示它们的使用并解释它们的作用。在这个过程中，我们将深入一点，看看是否可以自己制作服务的许多部分。
- en: 'We will start this example with creating a clean directory and creating the
    same test file we used earlier:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个干净的目录开始这个示例，并创建我们之前使用的相同的测试文件：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we will create our bit-more-complex Python-based web server container by
    putting the following content in the `Dockerfile`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过将以下内容放入`Dockerfile`来创建一个稍微复杂一点的基于Python的Web服务器容器。
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Python's built-in web server is highly discouraged in almost all cases,
    as it is neither scalable nor configurable in any significant way, but it serves
    as a good example of a service that could be hosted through Docker and is available
    on almost all systems with Python. Do not use this in real production services
    unless you really know what you are doing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，使用Python内置的Web服务器都是极不推荐的，因为它既不可扩展，也没有任何显著的配置方式，但它可以作为一个通过Docker托管的服务的良好示例，并且几乎在所有安装了Python的系统上都可用。除非你真的知道自己在做什么，否则不要在真实的生产服务中使用它。
- en: Barring the note about using python's web server module in production, this
    is still a good example of all of the other major Dockerfile directives that we
    didn't cover and that you will now learn how to use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于在生产中使用python的web服务器模块的注意之外，这仍然是我们没有涵盖的所有其他主要Dockerfile指令的一个很好的例子，现在您将学习如何使用它们。
- en: Labels
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: 'Our first new directive here is `LABEL`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的第一个新指令是`LABEL`：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`LABEL <key>=<value>` or `LABEL <key> <value>` is used to add metadata about
    the image that is being built, which can later be examined and filtered by `docker
    ps` and `docker images` using something like `docker images --filter "<key>=<value>"`.
    Keys are generally all lowercase in the `reverse-dns` notation, but you can use
    anything you want here and `version` should be present on every image, so we use
    the top-level version key name. However, the version here is not only there so
    that we can filter images but also to break Docker''s cache if we change it. Without
    cache-busting of this sort or through the manually set flag during builds ( `docker
    build --no-cache` ), Docker will keep reusing the cache all the way up to the
    most recently changed directive or files so there is a high probability that your
    container will stay stuck in a frozen package configuration. This condition may
    or may not be what you want, but just in case you have automated build tooling,
    adding a `version` layer that can break the cache whenever you change it makes
    the container very easy to update.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL <key>=<value>`或`LABEL <key> <value>`用于向正在构建的镜像添加元数据，稍后可以通过`docker ps`和`docker
    images`进行检查和过滤，使用类似`docker images --filter "<key>=<value>"`的方式。键通常以`reverse-dns`表示法全部小写，但在这里您可以使用任何内容，`version`应该出现在每个镜像上，因此我们使用顶级版本键名称。但是，这里的版本不仅用于过滤图像，还用于在更改时打破Docker的缓存。如果没有这种缓存破坏或在构建过程中通过手动设置标志（`docker
    build --no-cache`），Docker将一直重用缓存，直到最近更改的指令或文件，因此您的容器很可能会保持在冻结的软件包配置中。这种情况可能是您想要的，也可能不是，但是以防万一您有自动化构建工具，添加一个`version`层，可以在更改时打破缓存，使得容器非常容易更新。'
- en: Setting environment variables with ENV
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ENV设置环境变量
- en: '`ENV`, unlike some of these other commands, should be mostly self-explanatory:
    it sets the environmental variables both in the `Dockerfile` and the container.
    Since we would need to keep re-typing `/srv/www/html` in our `Dockerfile`, in
    order to prevent typos and to ensure easy changes to our final server directory
    target, we set the `SRV_PATH` variable that we keep reusing with `$SRV_PATH` later.
    Generally for Docker containers, almost all the configurations to containers are
    done through environmental variables such as these, so expect to see this directive
    more in the later chapters.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`与其他一些命令不同，应该大部分是不言自明的：它在`Dockerfile`和容器中设置环境变量。由于我们需要在`Dockerfile`中不断重新输入`/srv/www/html`，为了防止拼写错误并确保对最终服务器目录目标的轻松更改，我们设置了`SRV_PATH`变量，稍后我们将不断重用`$SRV_PATH`。通常对于Docker容器，几乎所有的容器配置都是通过这些环境变量完成的，因此在后面的章节中可以预期会看到这个指令。'
- en: 'Even though we don''t use it in this example, you need to watch out when using
    environment variables in the `CMD` directive directly as it does not get expanded
    but runs directly. You can ensure that your variable gets expanded in `CMD` by
    using it as part of a shell command structure similar to this: `CMD [ "sh", "-c",
    "echo", "$SRV_PATH" ]`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个示例中我们没有使用它，但是在`CMD`指令中直接使用环境变量时需要注意，因为它不会被展开，而是直接运行。您可以通过将其作为类似于这样的shell命令结构的一部分来确保您的变量在`CMD`中被展开：`CMD
    [ "sh", "-c", "echo", "$SRV_PATH" ]`。
- en: Exposing ports
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露端口
- en: Our next new directive here is `EXPOSE 8000`. Remember how we used `docker info`
    to find out what port the NGINX container was using? This directive filled in
    that information in the metadata and is used by the Docker orchestration tooling
    to map incoming ports into the right ingress port on the container. Since Python's
    HTTP server starts its service on port `8000` by default, we use `EXPOSE` to inform
    Docker that whoever uses this container should make sure that they map this port
    on the host. You can also list multiple ports here with this directive but since
    our service is using only one, we will not need to use that right now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的新指令是`EXPOSE 8000`。还记得我们如何使用`docker info`来找出NGINX容器使用的端口吗？这个指令填写了元数据中的信息，并且被Docker编排工具用来将传入端口映射到容器的正确入口端口。由于Python的HTTP服务器默认在端口`8000`上启动服务，我们使用`EXPOSE`来通知Docker，使用这个容器的人应该确保他们在主机上映射这个端口。你也可以在这个指令中列出多个端口，但由于我们的服务只使用一个端口，所以现在不需要使用。
- en: Container security layering with limited users
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限用户的容器安全层
- en: 'The following novel block of code in our `Dockerfile` is probably a little
    bit of a convoluted puzzle, but we will go through it together:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Dockerfile`中的以下新代码块可能有点复杂，但我们将一起学习：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is something we need to expand on multiple levels, but the first thing
    you need to know is that by default, Dockerfile directives are executed as `root`,
    and if at any point later you do not specify a different `USER`, your service
    will run with `root` credentials, which is a massive hole from a security perspective
    that we are trying to patch up by running our service as a limited user only.
    However, without the user and group defined, we cannot switch our context away
    from the `root`, so we create both a `pythonsrv` group first and then we follow
    it up by creating the `pythonsrv` user attached to the said group. The `-r` flags
    mark the user and group a system-level entity and is a good practice for groups
    and users that will not be directly logged into.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要在多个层面上扩展的内容，但你首先需要知道的是，默认情况下，Dockerfile指令是以`root`用户执行的，如果稍后没有指定不同的`USER`，你的服务将以`root`凭据运行，从安全角度来看，这是一个巨大的漏洞，我们试图通过将我们的服务仅作为有限用户运行来修补这个漏洞。然而，如果没有定义用户和组，我们无法将上下文从`root`切换，因此我们首先创建一个`pythonsrv`组，然后创建附属于该组的`pythonsrv`用户。`-r`标志将用户和组标记为系统级实体，对于不会直接登录的组和用户来说，这是一个良好的做法。
- en: Speaking of users and groups, if you mount a volume from the host to the Docker container
    that is running as a limited user, if neither the host nor the container perfectly
    agree on the user and group IDs (`uid` and `gid`, respectively), you cannot read
    or write files from volumes. To avoid this situation, we use a stable UID and
    GID of `350` that is easy to remember and is not normally in the regular UID/GID
    tables on most host systems. This number is mostly arbitrary, but as long as it
    is in the service range for your host OS and doesn't clash with the users or groups
    on the host either, it should be fine.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 说到用户和组，如果你将一个卷从主机挂载到以有限用户身份运行的Docker容器中，如果主机和容器对用户和组ID（分别为`uid`和`gid`）没有完全一致，你将无法从卷中读取或写入文件。为了避免这种情况，我们使用一个稳定的UID和GID，即`350`，这个数字易于记忆，在大多数主机系统的常规UID/GID表中通常不会出现。这个数字大多是任意的，但只要它在主机OS的服务范围内，并且不会与主机上的用户或组冲突，就应该没问题。
- en: The last flag that wasn't covered so far is `-m`, and what it does is create
    the home directory skeleton files for the user. Most of the time, you will not
    need this, but if any subsequent operations try to use `$HOME` (such as `npm`
    or a large swathe of other services), there will be no such directory unless you
    specify this flag and your build will fail so we make sure we do not hit this
    condition by creating `$HOME` for the `pythonsrv` user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有涵盖的最后一个标志是`-m`，它的作用是为用户创建主目录骨架文件。大多数情况下，你不需要这个，但如果任何后续操作尝试使用`$HOME`（比如`npm`或大量其他服务），除非你指定这个标志并且你的构建将失败，否则不会有这样的目录，所以我们确保通过为`pythonsrv`用户创建`$HOME`来避免这种情况。
- en: To round this off, we chained all of these `RUN` commands together to ensure
    that we use as few layers as we can. Each layer creates additional metadata and
    increases the size of your image, so just like the Docker best practices document
    states, we try to reduce them by stacking these commands together. While it is
    not the best thing to do in all cases as debugging this style of configuration
    is pretty difficult, it does usually trim the container size significantly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一切，我们将所有这些`RUN`命令链接在一起，以确保我们使用尽可能少的层。每一层都会创建额外的元数据，并增加你的镜像大小，所以就像Docker最佳实践文档所述，我们尝试通过堆叠这些命令来减少它们。虽然在所有情况下都不是最好的做法，因为调试这种风格的配置非常困难，但通常会显著减小容器的大小。
- en: VOLUMEs and data that lives outside of the container
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷和存在于容器之外的数据
- en: But what if we want to add files that live outside of the container that might
    need to persist even when the container dies? That is where the `VOLUME` directive
    comes into play. With `VOLUME`s, any time you start the container, this path is
    actually assumed to be mounted from outside of the container, and if none is provided,
    one will be created and attached for you automatically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要添加存在于容器之外的文件，即使容器死亡时也需要持久存在的文件呢？这就是`VOLUME`指令发挥作用的地方。使用`VOLUME`，每次启动容器时，这个路径实际上被假定为从容器外部挂载，如果没有提供，将会自动为你创建并附加一个。
- en: Here, we are assigning our `/srv/www/html/external` path to this unnamed volume,
    but we will reserve majority of our detailed discussion about volumes for later
    chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`/srv/www/html/external`路径分配给这个未命名的卷，但我们将保留大部分关于卷的详细讨论到后面的章节。
- en: Setting the working directory
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置工作目录
- en: Since the Python HTTP server can only serve files from the current directory
    that it runs in, without explicitly configuring this correctly our container would
    show files out of the `/` directory. To work around this, we include `WORKDIR
    $SRV_ROOT` into the `Dockerfile` which changes our working directory to the one
    that will contain the files we want to serve up. A thing to note about this command
    is that you can reuse it as many times as you want and it applies to any subsequent
    commands in the Dockerfile (such as `RUN` or `CMD`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python HTTP服务器只能从其运行的当前目录中提供文件，如果不正确配置，我们的容器将显示`/`目录之外的文件。为了解决这个问题，我们在`Dockerfile`中包含了`WORKDIR
    $SRV_ROOT`，这将把我们的工作目录更改为包含我们想要提供的文件的目录。关于这个命令需要注意的一点是，你可以多次重用它，并且它适用于Dockerfile中的任何后续命令（如`RUN`或`CMD`）。
- en: Adding files from the internet
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从互联网添加文件
- en: 'What about trying to add files to your container that are not hosted locally
    and/or due to licensing you cannot include them in your repository where the `Dockerfile`
    lives? For this specific purpose, there is the `ADD` directive. This command downloads
    the file from the URI provided and puts it in the container. If the file is local
    compressed archive, such as a `.tgz` or a `.zip` file and the target path ends
    with a slash, it will get expanded into that directory, making this a very useful
    option as opposed to `COPY`. In the example that we''re writing here, we will
    take a semi-random file from GitHub and put it in the directory to be included
    with the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要尝试向容器中添加不在本地托管的文件和/或由于许可问题无法将它们包含在`Dockerfile`所在的存储库中，该怎么办？为了这个特定的目的，有`ADD`指令。这个命令会从提供的URI下载文件并将其放入容器中。如果文件是本地压缩存档，比如`.tgz`或`.zip`文件，并且目标路径以斜杠结尾，它将被扩展到该目录中，这是一个非常有用的选项，与`COPY`相比。在我们写的例子中，我们将从GitHub中随机选择一个文件，并将其放入要包含的目录中。
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Changing the current user
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变当前用户
- en: We have explained why we need to run our service as a limited user and how we
    created the user for it, but now is the time to permanently switch the context
    to `pythonsrv`. Using `USER pythonsrv`, any further commands will be executed
    as `pythonsrv` user, including the container's `CMD` executable command, which
    is exactly what we want. Just like `WORKDIR`, this directive can be used multiple
    times in a `Dockerfile`, but for our purposes, there is no need to do the rest
    of the configuration as non-`root`. Generally, it is a good practice to keep this
    layer statement as high as possible in the `Dockerfile` since it is very unlikely
    that it will change and would be unlikely to break cache. However, for this example,
    we can't move it higher as our previous command uses `chown`, which requires `root`
    privileges.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了为什么需要将我们的服务运行为受限用户以及我们如何为其创建用户，但现在是永久切换上下文到`pythonsrv`的时候了。使用`USER pythonsrv`，任何进一步的命令都将以`pythonsrv`用户的身份执行，包括容器的`CMD`可执行命令，这正是我们想要的。就像`WORKDIR`一样，这个指令可以在`Dockerfile`中多次使用，但对于我们的目的来说，没有必要将其余的配置设置为非`root`。通常，将这个层语句尽可能放在`Dockerfile`中很高的位置是一个很好的做法，因为它很少会改变，也不太可能破坏缓存。然而，在这个例子中，我们不能将它移到更高的位置，因为我们之前的命令使用了`chown`，这需要`root`权限。
- en: Putting it all together
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'We''re nearly done! The last thing we need to do is start Python''s built-in
    HTTP server module when our container starts:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了！我们需要做的最后一件事是在容器启动时启动Python的内置HTTP服务器模块：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With everything in place, we can build and start our new container:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，我们可以构建并启动我们的新容器：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can cross our fingers and check what we have built by accessing `http://localhost:8000`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以祈祷并通过访问`http://localhost:8000`来检查我们构建的内容：
- en: '![](assets/8cac3147-3307-43d6-9026-d10ee62ac0c2.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cac3147-3307-43d6-9026-d10ee62ac0c2.png)'
- en: It works! Clicking on the `test.txt` shows the correct `Just a test` string
    and `README.md` that we fetched from GitHub downloads just fine when clicked.
    With all of the functionality there, what is in the `external/` directory?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！点击`test.txt`显示了正确的`Just a test`字符串，当点击时，我们从GitHub下载的`README.md`也很好地显示出来。所有的功能都在那里，`external/`目录中有什么？
- en: '![](assets/70ef7834-4904-45e7-b723-429b14c7fb7a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70ef7834-4904-45e7-b723-429b14c7fb7a.png)'
- en: 'If the volume is empty, it is really no surprise that our directory here is
    empty too. How about we see whether we can mount some files from our host into
    this directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷是空的，那么我们的目录也是空的并不奇怪。我们来看看是否可以将一些文件从我们的主机挂载到这个目录中：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we are mounting our current directory (`$(pwd)`) to our `/srv/www/html/external`
    target with our `-v` flag. So what does `http://localhost:8000/external` look
    like now? Do we have our files visible?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`-v`标志将我们的当前目录(`$(pwd)`)挂载到我们的`/srv/www/html/external`目标上。那么现在`http://localhost:8000/external`是什么样子呢？我们的文件可见吗？
- en: '![](assets/81036609-264a-4e9e-8299-de7b1323fe22.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81036609-264a-4e9e-8299-de7b1323fe22.png)'
- en: Indeed we do - our service works exactly as we expect it to! A real service
    written from scratch!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是的 - 我们的服务正如我们所期望的那样工作！一个从头开始编写的真正的服务！
- en: With a working service under our belt, we should now be able to continue our
    journey into Docker in the next chapter by scaling our containers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个正常工作的服务，我们现在应该能够在下一章中继续我们的Docker之旅，通过扩展我们的容器。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered everything from the basic Docker container to extending
    an existing container, all the way to creating our own service from scratch. Along
    the way, we covered the most important Docker and Dockerfile commands and how
    to use them and, even more importantly, *where* and *why* to use them. While this
    was not the most in-depth coverage of the topic, it is just the right amount of
    depth we need in order to start working on scaling containers in our next chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了从基本的Docker容器到扩展现有容器，一直到从头开始创建我们自己的服务的所有内容。在这个过程中，我们涵盖了最重要的Docker和Dockerfile命令以及如何使用它们，更重要的是*在哪里*和*为什么*使用它们。虽然这并不是对该主题最深入的覆盖，但这正是我们在下一章开始扩展容器工作所需要的适当深度。
