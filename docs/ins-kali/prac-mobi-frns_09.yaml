- en: Understanding Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Android
- en: In the previous chapters, we covered details about iOS devices, including the
    filesystem structure, key artifacts, backup files, and acquisition and analysis
    methods. Starting with this chapter, we will focus on the Android platform and
    how to perform forensics on Android devices. Having a good understanding of the
    Android ecosystem, security constraints, filesystems, and other features would
    prove useful during a forensic investigation. Gaining knowledge of these fundamentals
    would help a forensic expert to make informed decisions while conducting an investigation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了iOS设备的详细信息，包括文件系统结构、关键文件、备份文件以及获取和分析方法。从本章开始，我们将专注于Android平台以及如何对Android设备进行取证。在进行取证调查时，对Android生态系统、安全约束、文件系统和其他功能有很好的理解将会很有用。掌握这些基础知识将有助于取证专家在进行调查时做出明智的决定。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The evolution of Android
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android的演变
- en: The Android architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android架构
- en: Android security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android安全
- en: The Android file hierarchy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android文件层次结构
- en: The Android filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android文件系统
- en: The evolution of Android
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android的演变
- en: Android is a Linux-based mobile operating system developed for touchscreen mobile
    devices. It is developed by a consortium of companies known as the **Open Handset
    Alliance** (**OHA**), with the primary contributor and commercial marketer being
    Google. The Android operating system has evolved significantly since its inaugural
    release date. Android was officially launched to the public in 2008, with Android
    version 1.0\. With the Android 1.5 Cupcake release in 2009, the tradition of naming
    Android versions after confectionery was born. The version names were also released
    in alphabetical order for the next 10 years. However, in 2019, Google announced
    that they were ending the confectionery-based naming, and were using numerical
    ordering for future versions. In the initial years, Android versions were updated
    more than twice a year, but in more recent years, version updates are done once
    per year. The most recent major Android update is Android 11, the eleventh major
    version of the Android operating system, announced by Google on February 19, 2020.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android是为触摸屏移动设备开发的基于Linux的移动操作系统。它由一家名为**开放手机联盟**（**OHA**）的公司联合开发，主要贡献者和商业营销商是谷歌。自首次发布以来，Android操作系统已经有了显著的发展。Android于2008年正式向公众发布，版本为Android
    1.0。随着2009年Android 1.5杯子蛋糕版本的发布，以甜点命名Android版本的传统诞生了。接下来的10年，版本名称也按字母顺序发布。然而，2019年，谷歌宣布他们将结束基于甜点的命名，未来将使用数字顺序。最近的几年里，Android版本更新频率减少到每年一次。最新的主要Android更新是Android
    11，这是谷歌于2020年2月19日宣布的第11个主要版本。
- en: 'The following is an overview of Android version history as of the time of writing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是撰写时的Android版本历史概述：
- en: '| **Version** | **Version name** | **Release year** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **版本名称** | **发布年份** |'
- en: '| Android 1.0 | Apple Pie | 2008 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.0 | 苹果派 | 2008年 |'
- en: '| Android 1.1 | Banana Bread | 2009 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.1 | 香蕉面包 | 2009年 |'
- en: '| Android 1.5 | Cupcake | 2009 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.5 | 杯子蛋糕 | 2009年 |'
- en: '| Android 1.6 | Donut | 2009 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Android 1.6 | 甜甜圈 | 2009年 |'
- en: '| Android 2.0 | Eclair | 2009 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.0 | 松饼 | 2009年 |'
- en: '| Android 2.2 | Froyo | 2010 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.2 | 冻酸奶 | 2010年 |'
- en: '| Android 2.3 | Gingerbread | 2010 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Android 2.3 | 姜饼 | 2010年 |'
- en: '| Android 3.0 | Honeycomb | 2011 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Android 3.0 | 蜂巢 | 2011年 |'
- en: '| Android 4.0 | Ice Cream Sandwich | 2011 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.0 | 冰淇淋三明治 | 2011年 |'
- en: '| Android 4.1 | Jelly Bean | 2012 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.1 | 果冻豆 | 2012年 |'
- en: '| Android 4.4 | KitKat | 2013 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Android 4.4 | 奇巧 | 2013年 |'
- en: '| Android 5.0 | Lollipop | 2014 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Android 5.0 | 棒棒糖 | 2014年 |'
- en: '| Android 6.0 | Marshmallow | 2015 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Android 6.0 | 棉花糖 | 2015年 |'
- en: '| Android 7.0 | Nougat | 2016 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Android 7.0 | 牛轧糖 | 2016年 |'
- en: '| Android 8.0 | Oreo | 2017 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Android 8.0 | 奥利奥 | 2017年 |'
- en: '| Android 9.0 | Pie | 2018 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Android 9.0 | 派 | 2018年 |'
- en: '| Android 10.0 | Q | 2019 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Android 10.0 | Q | 2019年 |'
- en: '| Android 11 | R | 2020 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Android 11 | R | 2020年 |'
- en: This evolution has also dramatically impacted the security considerations of
    Android and how forensics techniques are applied. For example, the initial versions
    of Android did not have a **Full Disk Encryption** (**FDE**) mechanism to store
    data in an encrypted format within the device. As a result, extracting data from
    the device was much easier for a forensic investigator than it is currently. With
    each Android version update, more and more security features, such as app permissions,
    **trusted execution environment** (**TEE**), and secure kernel, have been added
    to improve the security of the platform overall but at the same time complicate
    the process of data extraction. We shall cover these security features in detail
    in the other sections of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种演变也极大地影响了Android的安全考虑以及取证技术的应用。例如，最初的Android版本没有**全盘加密**（**FDE**）机制来以加密格式存储设备内的数据。因此，相较于现在，取证人员从设备中提取数据要容易得多。随着每个Android版本的更新，越来越多的安全功能，如应用程序权限、**受信任执行环境**（**TEE**）和安全内核，已被添加以提高整个平台的安全性，但同时也使数据提取的过程变得更加复杂。我们将在本章的其他部分详细介绍这些安全功能。
- en: Now that we know about the history and versions of Android, we will take a look
    at the Android architecture in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Android的历史和版本，接下来我们将在下一节中看一下Android的架构。
- en: The Android architecture
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android架构
- en: To effectively understand forensic concepts when dealing with Android, you should have
    a basic understanding of the Android architecture. Just like a computer, any computing
    system that interacts with the user and performs complicated tasks requires an
    operating system to handle the tasks effectively. This operating system (whether
    it's a desktop operating system or a mobile phone operating system) is responsible
    for managing the resources of the system, to provide a way for the applications
    to talk to the hardware or physical components to accomplish certain tasks. Android
    is currently the most popular mobile operating system designed to power mobile
    devices. You can find out more about this at [https://developer.android.com/about/android.html](https://developer.android.com/about/android.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理安卓时，要有效地理解法医概念，你应该对安卓架构有基本的了解。就像计算机一样，任何与用户交互并执行复杂任务的计算系统都需要一个操作系统来有效地处理任务。这个操作系统（无论是桌面操作系统还是手机操作系统）负责管理系统的资源，为应用程序提供一种与硬件或物理组件交流以完成特定任务的方式。安卓目前是最流行的移动操作系统，旨在为移动设备提供动力。你可以在[https://developer.android.com/about/android.html](https://developer.android.com/about/android.html)了解更多信息。
- en: Android, as an open source operating system, releases its code under the Apache
    License, one of the many open source licenses. Practically, this means anyone
    (especially device manufacturers) can access it, freely modify it, and use the
    software according to the requirements of any device. This is one of the primary
    reasons for its wide acceptance. Notable players that use Android include Samsung,
    HTC, Sony, and LG.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开源操作系统，安卓以Apache许可证的形式发布其代码，这是众多开源许可证之一。实际上，这意味着任何人（尤其是设备制造商）都可以访问它，自由修改它，并根据任何设备的要求使用该软件。这是其广泛接受的主要原因之一。使用安卓的知名厂商包括三星、HTC、索尼和LG。
- en: As with any other platform, Android consists of a stack of layers running one
    above the other. To understand the Android ecosystem, it's essential to have a
    basic understanding of what these layers are and what they do.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他平台一样，安卓由一堆层次运行在另一堆层次之上。要理解安卓生态系统，有必要对这些层次是什么以及它们的作用有基本的了解。
- en: 'The following diagram summarizes the various layers involved in the Android
    software stack:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了安卓软件堆栈中涉及的各个层：
- en: '![](img/6ee0ce43-84de-41ea-8a04-dec28c003cc9.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ee0ce43-84de-41ea-8a04-dec28c003cc9.png)'
- en: Android architecture
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓架构
- en: This image is modified based on work created and shared by the Android Open
    Source Project: https://developer.android.com/guide/platform
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像是基于安卓开源项目创建和共享的工作进行修改：https://developer.android.com/guide/platform
- en: License: https://creativecommons.org/licenses/by/4.0/
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证：https://creativecommons.org/licenses/by/4.0/
- en: Each of these layers performs several operations that support specific operating
    system functions. Each layer provides services to the layers lying on top of it.
    Let's look at them in a little more detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些层每个都执行支持特定操作系统功能的几个操作。每个层为其上面的层提供服务。让我们更详细地看一下。
- en: The Linux kernel layer
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核层
- en: The Android operating system is built on top of the Linux kernel, with some
    architectural changes made by Google. There are several reasons for choosing the
    Linux kernel. Most importantly, Linux is a portable platform that can be compiled
    easily on different hardware. The kernel acts as an abstraction layer between
    the software and hardware present on the device. Consider the case of a camera.
    What happens when you take a photo using the camera button on your device? At
    some point, the hardware instruction (pressing a button) has to be converted to
    a software instruction (to take a picture and store it in the gallery). The kernel
    contains drivers to facilitate this process. When the user presses the button,
    the instruction goes to the corresponding camera driver in the kernel, which sends
    the necessary commands to the camera hardware, similar to what occurs when a key
    is pressed on a keyboard. In simple words, the drivers in the kernel command control
    the underlying hardware. As shown in the Android architecture model, the kernel
    contains drivers related to Wi-Fi, Bluetooth, **Universal Service Bus** (**USB**),
    audio, display, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统是建立在Linux内核之上的，谷歌对其进行了一些架构上的改变。选择Linux内核有几个原因。最重要的是，Linux是一个可以轻松在不同硬件上编译的可移植平台。内核充当软件和设备上的硬件之间的抽象层。考虑一下相机的情况。当你使用设备上的相机按钮拍照时会发生什么？在某个时候，硬件指令（按下按钮）必须转换为软件指令（拍照并将其存储在相册中）。内核包含驱动程序来促进这个过程。当用户按下按钮时，指令传递到内核中相应的相机驱动程序，该驱动程序向相机硬件发送必要的命令，类似于在键盘上按键时发生的情况。简而言之，内核中的驱动程序控制着底层硬件。如安卓架构模型所示，内核包含与Wi-Fi、蓝牙、通用串行总线（USB）、音频、显示等相关的驱动程序。
- en: The Linux kernel is responsible for managing the core functionality of Android,
    such as process management, memory management, security, and networking. Linux
    is a proven platform when it comes to security and process management. Android
    has taken leverage of the existing Linux open source operating system to build
    a solid foundation for its ecosystem. Each version of Android has a different
    version of the underlying Linux kernel. The Oreo Android version is known to use
    Linux kernel 3.18 or 4.9, whereas the Pie version is known to use Linux kernel
    4.4, 4.9, or 4.14. Android Q, targets Linux kernel 4.9, 4.14, or 4.19\. The actual
    kernel depends on the individual device.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核负责管理安卓的核心功能，如进程管理、内存管理、安全性和网络。在安全性和进程管理方面，Linux是一个经过验证的平台。安卓已经利用现有的Linux开源操作系统来构建其生态系统的坚实基础。每个安卓版本都有不同版本的底层Linux内核。Oreo安卓版本已知使用Linux内核3.18或4.9，而Pie版本已知使用Linux内核4.4、4.9或4.14。安卓Q版本的目标是Linux内核4.9、4.14或4.19。实际的内核取决于个别设备。
- en: The Hardware Abstraction Layer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件抽象层
- en: The device hardware capabilities are exposed to the high-level Java framework
    through the **Hardware Abstraction Layer** (**HAL**). The HAL consists of several
    library modules that implement interfaces for a specific type of hardware component.
    This allows hardware vendors to implement functionality without changing the higher-level
    system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 设备硬件功能通过**硬件抽象层**（**HAL**）暴露给高级Java框架。HAL由几个库模块组成，实现特定类型硬件组件的接口。这允许硬件供应商在不改变更高级别系统的情况下实现功能。
- en: Libraries
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: The next layer in the Android architecture consists of Android's native libraries.
    The libraries are written in C or C++, and help the device to handle different
    kinds of data. For example, the SQLite libraries are useful for storing and retrieving
    the data from a database. Other libraries include Media Framework, WebKit, Surface
    Manager, and **Secure Sockets Library** (**SSL**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Android架构中的下一层包括Android的本机库。这些库是用C或C++编写的，帮助设备处理不同类型的数据。例如，SQLite库用于存储和检索数据库中的数据。其他库包括媒体框架、WebKit、Surface
    Manager和**安全套接字库**（**SSL**）。
- en: The Media Framework library acts as the main interface to provide a service
    to the other underlying libraries. The WebKit library provides web pages in web
    browsers, and the Surface Manager library maintains the graphics. In the same
    layer, we have **Android Runtime** (**ART**) and core libraries. ART is responsible
    for running applications on Android devices. The term *runtime* refers to the
    time from when an application is launched until it is shut down.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体框架库充当提供服务给其他底层库的主要接口。WebKit库提供Web浏览器中的网页，Surface Manager库维护图形。在同一层中，我们有**Android运行时**（**ART**）和核心库。ART负责在Android设备上运行应用程序。术语*运行时*指的是从应用程序启动到关闭的时间。
- en: Dalvik Virtual Machine (DVM)
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dalvik虚拟机（DVM）
- en: All the applications that you install on the Android device are written in the
    Java programming language. When a Java program is compiled, we get bytecode. A
    **virtual machine** (**VM**) is an application that acts as an operating system—that
    is, it is possible to run an instance of the Windows operating system on a Mac,
    or vice versa, using a VM. **Java Virtual Machine** (**JVM**) is one such VM that
    can execute the previously mentioned bytecode. But Android versions before Android
    5.0 used something called DVM to run their applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您在Android设备上安装的所有应用程序都是用Java编程语言编写的。当Java程序编译时，我们得到字节码。**虚拟机**（**VM**）是一个充当操作系统的应用程序，也就是说，可以在Mac上运行Windows操作系统的实例，反之亦然，使用VM。**Java虚拟机**（**JVM**）就是这样一个可以执行前面提到的字节码的VM。但是Android
    5.0之前的版本使用了称为DVM的东西来运行它们的应用程序。
- en: DVM runs Dalvik bytecode, which is Java bytecode converted by the **Dalvik Executable**
    (**DEX**) compiler. Thus, the `.class` files are converted to `dex` files using
    the `dx` tool. Dalvik bytecode, when compared with Java bytecode, is more suitable
    for low-memory and low-processing environments. Also, note that JVM's bytecode
    consists of one or more `.class` files, depending on the number of Java files
    that are present in an application, but Dalvik bytecode is composed of only one
    `dex` file. Each Android application runs its own instance of DVM. This is a crucial
    aspect of Android security and will be addressed in detail in [Chapter 8](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml),
    *Android Forensic Setup and Pre-Data Extraction Techniques*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DVM运行Dalvik字节码，这是由**Dalvik可执行文件**（**DEX**）编译器转换的Java字节码。因此，`.class`文件使用`dx`工具转换为`dex`文件。与Java字节码相比，Dalvik字节码更适合于低内存和低处理环境。此外，需要注意的是，JVM的字节码由一个或多个`.class`文件组成，取决于应用程序中存在的Java文件数量，但Dalvik字节码只由一个`dex`文件组成。每个Android应用程序都运行自己的DVM实例。这是Android安全的关键方面，将在[第8章](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml)中详细讨论，即*Android取证设置和数据提取技术*。
- en: 'The following diagram provides an insight into how Android''s DVM differs from
    Java''s JVM:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了Android的DVM与Java的JVM之间的区别：
- en: '![](img/ff51cea3-861f-42fb-b320-de90d9d3b12a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff51cea3-861f-42fb-b320-de90d9d3b12a.png)'
- en: JVM versus DVM
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JVM与DVM
- en: Now that we have understood the basic differences between JVM and DVM, let's
    quickly have a look at ART.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JVM和DVM之间的基本区别，让我们快速看一下ART。
- en: ART
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ART
- en: From the Android 5.0 Lollipop version onward, Dalvik was replaced by ART. Earlier
    versions of Android used **just-in-time** (**JIT**) compilation with Dalvik (frequently
    executed operations are identified and dynamically compiled to native machine
    code). This native execution of these frequently used bytecodes, called traces,
    provides significant performance improvements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 5.0版本的棒棒糖开始，Dalvik被ART取代。Android早期版本使用Dalvik的**即时**（**JIT**）编译（识别并动态编译频繁执行的操作为本机机器代码）。这些频繁使用的字节码的本机执行，称为跟踪，提供了显著的性能改进。
- en: Unlike Dalvik, ART uses **ahead-of-time** (**AOT**) compilation, which compiles
    entire applications into native machine code upon their installation. This automatically
    increases the install time for an application, but a major advantage is that this
    eliminates Dalvik's interpretation and trace-based JIT compilation, and thereby
    increases efficiency and reduces power consumption. ART uses a utility called
    `dex2oat` that accepts `DEX` files as input and generates a compiled app executable
    for the target device. With ART, the **optimized DEX** (**.odex**) files have
    been replaced with the **Executable and Linkable Format** (**ELF**) executables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与Dalvik不同，ART使用**预编译**（**AOT**）编译，即在安装时将整个应用程序编译为本机机器代码。这自动增加了应用程序的安装时间，但一个主要优点是这消除了Dalvik的解释和基于跟踪的JIT编译，从而提高了效率并减少了功耗。ART使用一个名为`dex2oat`的实用程序，它接受`DEX`文件作为输入，并为目标设备生成一个编译的应用程序可执行文件。使用ART，**优化的DEX**（**.odex**）文件已被**可执行和可链接格式**（**ELF**）可执行文件取代。
- en: The Java API framework layer
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API框架层
- en: 'The application framework is the layer responsible for handling the basic functioning
    of a phone, such as resource management, handling calls, and so on. This is the
    block through which the applications installed on the device directly talk to
    it. The following are some of the important blocks in the application framework
    layer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序框架是负责处理手机的基本功能的层，如资源管理，处理通话等。这是应用程序直接与设备通信的块。以下是应用程序框架层中的一些重要块：
- en: '**Telephony Manager**: This block manages all the voice calls.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电话管理器**：此块管理所有语音通话。'
- en: '**Content Provider**: This block manages the sharing of data between different
    applications.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容提供者**：此块管理不同应用程序之间的数据共享。'
- en: '**Resource Manager**: This block manages various resources used in applications.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器**：此块管理应用程序中使用的各种资源。'
- en: The final layer is the system apps layer, which will be discussed next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最终层是系统应用程序层，接下来将讨论这一层。
- en: The system apps layer
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统应用程序层
- en: This is the topmost layer where the user can interact directly with the device.
    There are two kinds of applications—preinstalled applications and user-installed
    applications. Preinstalled applications—such as dialer, web browser, and contacts—come
    along with the device. User-installed applications can be downloaded from different
    places, such as Google Play Store, Amazon Marketplace, and so on. Everything that
    you see on your phone (contacts, mail, camera, and so on) is an application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户可以直接与设备交互的最顶层。有两种应用程序——预装应用程序和用户安装的应用程序。预装应用程序——如拨号器、网络浏览器和联系人——随设备一起提供。用户安装的应用程序可以从不同的地方下载，如Google
    Play商店、亚马逊市场等。您在手机上看到的一切（联系人、邮件、相机等）都是应用程序。
- en: So far, we have learned about the Android architecture and the important building
    blocks. We shall now dive into some of the inherent security features in the Android
    operating system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Android架构和重要的构建块。现在我们将深入了解Android操作系统中固有的一些安全功能。
- en: Android security
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android安全
- en: Android was designed with a specific focus on security. Android as a platform
    offers and enforces certain features that safeguard the user data present on the
    mobile through multilayered security. There are certain safe defaults that will
    protect the user, and there are certain offerings that can be leveraged by the
    development community to build secure applications. As a forensic investigator,
    understanding the internals of Android security is crucial as it helps to identify
    the best techniques to apply in a given situation, the technical limitations of
    certain techniques, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Android的设计专注于安全。作为一个平台，Android提供并强制执行某些功能，以通过多层安全保护移动设备上的用户数据。有一些安全默认设置可以保护用户，也有一些功能可以被开发社区利用来构建安全的应用程序。作为法医调查员，了解Android安全的内部情况至关重要，因为它有助于确定在特定情况下应用的最佳技术，某些技术的技术限制等。
- en: The next few sections will help us understand more about Android's security
    features and offerings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将帮助我们更好地了解Android的安全功能和提供。
- en: A detailed explanation on Android security can be found at [https://source.android.com/security/](https://source.android.com/security/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Android安全的详细说明可在[https://source.android.com/security/](https://source.android.com/security/)找到。
- en: Secure kernel
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全内核
- en: 'The kernel is at the heart of the security of any operating system. By choosing
    Linux, which has evolved as a trusted platform over the years, Android has established
    a very solid security foundation. Most of the security features that are inherent
    to the Linux kernel are automatically adopted by Android. For example, the user-based
    permission model of Linux has, in fact, worked well for Android. As mentioned
    earlier, there is a lot of specific code built into the Linux kernel. With each
    Android version release, the kernel version has also changed. The following table
    shows Android versions and their corresponding kernel versions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是任何操作系统安全的核心。通过选择多年来发展成为可信平台的Linux，Android建立了非常坚实的安全基础。Linux内核固有的大多数安全功能都会自动被Android采用。例如，Linux的基于用户的权限模型实际上对Android非常有效。如前所述，Linux内核中内置了大量特定代码。随着每个Android版本的发布，内核版本也发生了变化。以下表格显示了Android版本及其对应的内核版本：
- en: '| **Android version** | **Linux kernel version** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **Android版本** | **Linux内核版本** |'
- en: '| 1 | 2.6.25 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2.6.25 |'
- en: '| 1.5 | 2.6.27 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 | 2.6.27 |'
- en: '| 1.6 | 2.6.29 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1.6 | 2.6.29 |'
- en: '| 2.2 | 2.6.32 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2.2 | 2.6.32 |'
- en: '| 2.3 | 2.6.35 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 2.3 | 2.6.35 |'
- en: '| 3.0 | 2.6.36 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 2.6.36 |'
- en: '| 4.0 | 3.0.1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | 3.0.1 |'
- en: '| 4.1 | 3.0.31 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 4.1 | 3.0.31 |'
- en: '| 4.2 | 3.4.0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 4.2 | 3.4.0 |'
- en: '| 4.2 | 3.4.39 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 4.2 | 3.4.39 |'
- en: '| 4.4 | 3.8 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 4.4 | 3.8 |'
- en: '| 5.0 | 3.16.1 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 3.16.1 |'
- en: '| 6.0 | 3.18.1 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 3.18.1 |'
- en: '| 7.0 | 4.4.1 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 7.0 | 4.4.1 |'
- en: '| 8.0 | 4.10 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 8.0 | 4.10 |'
- en: '| 9.0 | 4.4, 4.9, and 4.14 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 9.0 | 4.4, 4.9 和 4.14 |'
- en: '| 10.0 |  4.9, 4.14, and 4.19 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 10.0 |  4.9, 4.14 和 4.19 |'
- en: 'The Linux kernel automatically brings some of its inherent security features,
    such as the following, to the Android platform:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核自动为Android平台带来了一些固有的安全功能，例如以下功能：
- en: A user-based permissions model
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的权限模型
- en: Isolation of running processes (application sandbox)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行进程的隔离（应用程序沙盒）
- en: Secure **inter-process communication** (**IPC**)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全**进程间通信**（**IPC**）
- en: We shall now learn about each of these features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将了解每个这些功能。
- en: The permission model
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限模型
- en: As shown in the following screenshot, any Android application must be granted
    permissions to access sensitive functionality—such as the internet, dialer, and
    so on—by the user. This provides an opportunity for the user to know in advance
    which functionality on the device is being accessed by the application. Simply
    put, it requires the user's permission to perform any kind of malicious activity
    (stealing data, compromising the system, and so on).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，任何Android应用程序必须获得用户的权限才能访问敏感功能，例如互联网、拨号器等。这为用户提供了提前了解应用程序访问设备上哪些功能的机会。简而言之，它需要用户的许可才能执行任何恶意活动（窃取数据，破坏系统等）。
- en: This model helps the user to prevent attacks, but if the user is unaware and
    gives away a lot of permissions, it leaves them in trouble (remember—when it comes
    to installing malware on any device, the weakest link is always the user).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型帮助用户防止攻击，但如果用户不知情并授予了很多权限，就会陷入麻烦（记住——当涉及在任何设备上安装恶意软件时，最薄弱的环节始终是用户）。
- en: '![](img/cd2f6a83-7870-4892-8d69-d73868619edd.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd2f6a83-7870-4892-8d69-d73868619edd.png)'
- en: The permission model in Android
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓中的权限模型
- en: Until Android 6.0, users needed to grant the permissions during install time.
    Users had to either accept all the permissions or not install the application.
    But, starting from Android 6.0, users grant permissions to apps while the app
    is running. This new permission system also gives the user more control over the
    app's functionality by allowing the user to grant selective permissions. For example,
    a user can deny a particular app access to their location but provide access to
    the internet. The user can revoke the permissions at any time by going to the
    app's Settings screen. From a forensic perspective, what this means is that the
    kind of information that can be extracted from a device depends not only on the
    device and the installed apps but also on the permissions that are configured
    by the user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 直到安卓6.0之前，用户需要在安装时授予权限。用户必须接受所有权限或者不安装应用程序。但是，从安卓6.0开始，用户在应用程序运行时授予权限。这种新的权限系统还允许用户更多地控制应用程序的功能，允许用户选择性地授予权限。例如，用户可以拒绝某个应用程序访问他们的位置，但允许访问互联网。用户可以随时通过转到应用程序的设置屏幕来撤销权限。从取证的角度来看，这意味着可以从设备中提取的信息类型不仅取决于设备和安装的应用程序，还取决于用户配置的权限。
- en: Application sandbox
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序沙箱
- en: In Linux systems, each user is assigned a unique **user identifier** (**UID**),
    and users are segregated so that one user cannot access the data of another user.
    However, all applications under a particular user are run with the same privileges.
    Similarly, in Android, each application runs as a unique user. In other words,
    a UID is assigned to each application and is run as a separate process. This concept
    ensures an application sandbox at the kernel level. The kernel manages the security
    restrictions between the applications by making use of existing Linux concepts,
    such as UID and **group identifier** (**GID**). If an application attempts to
    do something malicious—say, to read the data of another application—this is not
    permitted as the application does not have user privileges. Hence, the operating
    system protects an application from accessing the data of another application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，每个用户被分配一个唯一的用户标识符（UID），并且用户被隔离开来，以便一个用户无法访问另一个用户的数据。然而，特定用户下的所有应用程序都以相同的权限运行。同样，在安卓中，每个应用程序都作为一个独特的用户运行。换句话说，每个应用程序都被分配一个UID并作为一个独立的进程运行。这个概念确保了内核级别的应用程序沙箱。内核通过利用现有的Linux概念，如UID和组标识符（GID），来管理应用程序之间的安全限制。如果一个应用程序试图执行一些恶意操作——比如读取另一个应用程序的数据——这是不允许的，因为应用程序没有用户权限。因此，操作系统保护应用程序免受访问另一个应用程序数据的侵害。
- en: Secure IPC
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的IPC
- en: 'Android offers secure IPC, through which one activity in an application can
    send messages to another activity in the same or a different application. To achieve
    this, Android provides IPC mechanisms: Intents, Services, Content Providers, and
    so on. This is more relevant to developers who code third-party apps for the Android
    platform. Behind the scenes, forensic tools exploit some of these concepts to
    gain access to the device information.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了安全的IPC，通过它，一个应用程序中的一个活动可以向同一个或不同应用程序中的另一个活动发送消息。为了实现这一点，安卓提供了IPC机制：意图、服务、内容提供程序等。这对为安卓平台编写第三方应用程序的开发人员更为相关。在幕后，取证工具利用其中一些概念来获取设备信息。
- en: Application signing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序签名
- en: 'It is mandatory that all of the installed applications are digitally signed.
    Developers can place their applications in Google''s Play Store only after signing
    the applications. The private key with which the application is signed is held
    by the developer. Using the same key, a developer can provide updates to their
    application, share data between the applications, and so on. Unsigned applications,
    if attempted to be installed, will be rejected by either Google Play or the package
    installer on the Android device. In Android 8.0 and above, users must navigate
    to the Install unknown apps setting in order to run unsigned apps, as shown in
    the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安装的应用程序都必须经过数字签名。开发人员只有在对应用程序进行签名后才能将其放置在谷歌的Play商店中。应用程序签名所使用的私钥由开发人员持有。使用相同的密钥，开发人员可以为他们的应用程序提供更新，在应用程序之间共享数据等。未经签名的应用程序如果尝试安装，将被谷歌Play或安卓设备上的软件包安装程序拒绝。在安卓8.0及以上版本中，用户必须导航到“安装未知应用程序”设置才能运行未经签名的应用程序，如下图所示：
- en: '![](img/c0984e6e-5005-4e9e-ab00-3b83223b7431.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0984e6e-5005-4e9e-ab00-3b83223b7431.png)'
- en: Install unknown apps screen in Android
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓系统中安装未知应用程序屏幕
- en: Now that we have some basic knowledge about digitally signed applications, let's
    look at one of the security features in Android.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数字签名应用程序有了一些基本知识，让我们来看看安卓中的一个安全功能。
- en: Security-Enhanced Linux (SELinux)
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全增强型Linux（SELinux）
- en: 'SELinux is a security feature that was introduced in Android 4.3 and fully
    enforced in Android 5.0\. Until this addition, Android security was based on **Discretionary
    Access Control** (**DAC**), which means applications can ask for permissions,
    and users can grant or deny those permissions. Thus, malware can create havoc
    on phones by gaining those permissions. But SE Android uses **Mandatory Access
    Control** (**MAC**), which ensures that applications work in isolated environments.
    Hence, even if a user installs a malware app, the malware cannot access the operating
    system and corrupt the device. SELinux is used to enforce MAC over all the processes,
    including the ones running with root privileges. In SELinux, anything that is
    not explicitly allowed is, by default, denied. SELinux can operate in one of the
    two global modes: **Permissive** mode, which logs the permission denials but does
    not enforce them; and **Enforcing** mode, which logs and also enforces the permission
    denials. More details about SELinux can be found at [https://source.android.com/security/selinux/concepts](https://source.android.com/security/selinux/concepts).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 是在 Android 4.3 中引入的安全功能，并在 Android 5.0 中得到全面执行。在此添加之前，Android 安全性是基于**自主访问控制**（**DAC**）的，这意味着应用程序可以请求权限，用户可以授予或拒绝这些权限。因此，恶意软件可以通过获得这些权限在手机上制造混乱。但
    SE Android 使用**强制访问控制**（**MAC**），确保应用程序在隔离的环境中工作。因此，即使用户安装了恶意应用程序，恶意软件也无法访问操作系统并损坏设备。SELinux
    用于在所有进程上强制执行 MAC，包括以 root 权限运行的进程。在 SELinux 中，任何未明确允许的操作默认都被拒绝。SELinux 可以在两种全局模式中运行：**宽容**模式，记录权限拒绝但不强制执行；和**强制**模式，记录并强制执行权限拒绝。有关
    SELinux 的更多详细信息，请访问[https://source.android.com/security/selinux/concepts](https://source.android.com/security/selinux/concepts)。
- en: FDE
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FDE
- en: With Android 6.0 Marshmallow, Google has mandated FDE for most devices, provided
    that the hardware meets certain minimum standards. Encryption is the process of
    converting data into ciphertext using a secret key. On Android devices, FDE refers
    to the process of encrypting all user data using a secret key. This key is in
    turn encrypted by the device's **personal identification number** (**PIN**)/pattern/password
    that is set by the user. Once a device is encrypted, all user-created data is
    automatically encrypted before writing it to disk, and all reads automatically
    decrypt data before returning it to the calling process. FDE in Android works
    only with an **Embedded Multimedia Card** (**eMMC**) and similar flash devices
    that present themselves to the kernel as block devices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Android 6.0 Marshmallow，Google 规定大多数设备必须使用 FDE，前提是硬件符合一定的最低标准。加密是将数据使用秘密密钥转换为密文的过程。在
    Android 设备上，FDE 指的是使用秘密密钥加密所有用户数据的过程。然后，该密钥由用户设置的**个人识别号码**（**PIN**）/图案/密码加密。一旦设备加密，所有用户创建的数据在写入磁盘之前会自动加密，并且所有读取操作在返回给调用进程之前会自动解密数据。Android
    中的 FDE 仅适用于**嵌入式多媒体卡**（**eMMC**）和类似的将自身呈现为块设备的闪存设备。
- en: Staring from Android 7.x, Google decided to shift the encryption feature from
    FDE to **file-based encryption** (**FBE**). In FBE, different files are encrypted
    with different keys. By doing so, those files can be accessed independently, without
    the need to decrypt the complete partition. As a result of this, the system can
    now display open notifications or access boot-related files without having to
    wait until the user unlocks the phone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 7.x 开始，Google 决定将加密功能从 FDE 转移到**基于文件的加密**（**FBE**）。在 FBE 中，不同的文件使用不同的密钥进行加密。通过这样做，这些文件可以独立访问，无需解密完整分区。因此，系统现在可以在用户解锁手机之前显示打开通知或访问与引导相关的文件。
- en: Android Keystore
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Keystore
- en: Android Keystore is used to protect sensitive cryptographic keys from unauthorized
    access. Keys stored within a Keystore can be used to perform cryptographic operations,
    but they can never be extracted outside of the Keystore. The hardware-backed Keystores
    provide security at hardware level—that is, even if the operating system is compromised,
    the keys in the hardware module would still be secure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Android Keystore 用于保护敏感的加密密钥，防止未经授权的访问。存储在 Keystore 中的密钥可用于执行加密操作，但永远无法从 Keystore
    外部提取。硬件支持的 Keystore 在硬件级别提供安全性，即使操作系统被 compromise，硬件模块中的密钥仍然是安全的。
- en: TEE
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TEE
- en: A TEE is an isolated area (typically, a separate microprocessor) intended to
    guarantee the security of data stored inside it, and also to execute code with
    integrity. The main processor on mobile devices is considered untrusted and cannot
    be used to store secret data (such as cryptographic keys). Hence, a TEE is used
    specifically to perform such operations, and the software running on the main
    processor delegates any operations that require the use of secret data to the
    TEE processor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TEE 是一个隔离的区域（通常是一个单独的微处理器），旨在保证其中存储的数据的安全性，并以完整性执行代码。移动设备上的主处理器被视为不可信任，不能用于存储秘密数据（如加密密钥）。因此，TEE
    专门用于执行此类操作，并且运行在主处理器上的软件将需要使用秘密数据的任何操作委托给 TEE 处理器。
- en: Verified Boot
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证启动
- en: Verified Boot tries to ensure that all code that is executed on an Android device
    comes from a legitimate source rather than from an attacker or a fraud. It establishes
    a full chain of trust and prevents side-loading of any other operating system.
    During device boot-up, each stage validates the integrity and authenticity of
    the next stage before handing over execution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 验证启动试图确保在 Android 设备上执行的所有代码来自合法来源，而不是来自攻击者或欺诈者。它建立了完整的信任链，并防止任何其他操作系统的侧加载。在设备启动期间，每个阶段在移交执行之前都会验证下一个阶段的完整性和真实性。
- en: We shall now look into the various partitions and filesystems available on an
    Android device.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将研究 Android 设备上可用的各个分区和文件系统。
- en: The Android file hierarchy
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 文件层次结构
- en: In order to perform forensic analysis on any system (desktop or mobile), it's
    important to understand the underlying file hierarchy. A basic understanding of
    how Android organizes its data in files and folders helps a forensic analyst narrow
    down their research to specific issues. Just as with any other operating system,
    Android uses several partitions. This chapter provides an insight into some of
    the most significant partitions and the content stored in them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对任何系统（桌面或移动设备）进行取证分析，了解底层文件层次结构是很重要的。对Android如何在文件和文件夹中组织数据有基本的了解，有助于取证分析师将研究范围缩小到特定问题。与任何其他操作系统一样，Android使用了几个分区。本章提供了一些最重要分区和其中存储的内容的见解。
- en: 'It''s worth mentioning again that Android uses the Linux kernel. Hence, if
    you are familiar with Unix-like systems, you will understand the file hierarchy
    in Android very well. For those who are not very well acquainted with the Linux
    model, here is some basic information: in Linux, the file hierarchy is a single
    tree, with the top of the tree being denoted as `/` (called the *root*). This
    is different from the concept of organizing files in drives (as with Windows).
    Whether the filesystem is local or remote, it will be present under the root.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次提到的是，Android使用Linux内核。因此，如果您熟悉类Unix系统，您将非常了解Android中的文件层次结构。对于那些对Linux模型不太熟悉的人，这里有一些基本信息：在Linux中，文件层次结构是一个单一的树，树的顶部被表示为/（称为*根*）。这与在驱动器中组织文件的概念（如Windows）不同。无论文件系统是本地还是远程，它都将存在于根目录下。
- en: 'The Android file hierarchy is a customized version of this existing Linux hierarchy.
    Based on the device manufacturer and the underlying Linux version, the structure
    of this hierarchy may have a few insignificant changes. The following is a list
    of important folders that are common to most Android devices. Some of the folders
    listed are only visible through root access. Rooting is the process of gaining
    privileged access on an Android device. More details about rooting and executing
    the `adb` commands (which are shown in the following list) are covered in detail
    in [Chapter 8](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml), *Android Forensic
    Setup and Pre-Data Extraction Techniques*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Android文件层次结构是现有Linux层次结构的定制版本。根据设备制造商和底层Linux版本，这个层次结构的结构可能有一些微不足道的变化。以下是大多数Android设备共有的重要文件夹列表。列出的一些文件夹只有通过root访问才能看到。Rooting是在Android设备上获得特权访问的过程。有关rooting和执行adb命令（在下面的列表中显示）的更多详细信息在[第8章](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml)中有详细介绍，*Android取证设置和数据提取前技术*：
- en: '`/boot`: As the name suggests, this partition has the information and files
    required for the phone to boot. It contains the kernel and **Random Access Memory**
    (**RAM**) disk, so without this partition, the phone cannot start its processes.
    Data residing in RAM is rich in value and should be captured during a forensic
    acquisition.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /boot：顾名思义，这个分区包含了手机启动所需的信息和文件。它包含了内核和随机存取存储器（RAM）磁盘，因此没有这个分区，手机无法启动其进程。存储在RAM中的数据价值丰富，在取证获取过程中应该被捕获。
- en: '`/system`: This partition contains system-related files other than the kernel
    and RAM disk. This folder should never be deleted as that will make the device
    unbootable. The contents of this partition can be viewed using the following command:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /system：这个分区包含除了内核和RAM磁盘之外的系统相关文件。这个文件夹不应该被删除，否则设备将无法启动。可以使用以下命令查看此分区的内容：
- en: '![](img/d596a874-3308-425c-8db7-270b404755f3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d596a874-3308-425c-8db7-270b404755f3.png)'
- en: /system partition
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: /system分区
- en: '* `/recovery`: This is designed for backup purposes and allows the device to
    boot into recovery mode. In recovery mode, you can find tools to repair your phone
    installation.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /recovery：这个分区设计用于备份目的，并允许设备启动到恢复模式。在恢复模式下，您可以找到修复手机安装的工具。
- en: '`/data`: This is the partition that contains the data of each application.
    Most of the data belonging to the user—such as the contacts, SMS, and dialed numbers—is
    stored in this folder. This folder has significant importance from a forensic
    point of view as it holds valuable data. The contents of the data folder can be
    viewed using the following command:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /data：这是包含每个应用程序数据的分区。大部分属于用户的数据，如联系人、短信和拨打的号码，都存储在这个文件夹中。从取证的角度来看，这个文件夹非常重要，因为它包含有价值的数据。可以使用以下命令查看数据文件夹的内容：
- en: '![](img/dbfb40c0-e007-4322-be05-327102e4b80c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbfb40c0-e007-4322-be05-327102e4b80c.png)'
- en: /data partition
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: /data分区
- en: '* `/cache`: This is the folder used to store the frequently accessed data and
    some of the logs for faster retrieval. The `/cache` partition is also important
    to a forensic investigation as the data residing here may no longer be present
    in the `/data` partition.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /cache：这是用于存储频繁访问的数据和一些日志以加快检索速度的文件夹。/cache分区对于取证调查也很重要，因为这里的数据可能不再存在于/data分区中。
- en: '* `/misc`: As the name suggests, this folder contains information about miscellaneous
    settings. These settings mostly define the state of the device—that is, on/off.
    Information about hardware settings, USB settings, and so on can be accessed from
    this folder.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /misc：顾名思义，这个文件夹包含有关杂项设置的信息。这些设置主要定义设备的状态，即开/关。有关硬件设置、USB设置等信息可以从这个文件夹中访问。
- en: '`/sdcard`: This is the partition that holds all the information present on
    the **Secure Digital** (**SD**) card. It is valuable as it can contain information
    such as pictures, videos, files, documents, and so on.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /sdcard：这是保存在安全数字（SD）卡上的所有信息的分区。它很有价值，因为它可能包含图片、视频、文件、文档等信息。
- en: Now that we have understood the Android file hierarchy and looked at the important
    folders in it, let's have a look at the filesystem in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Android文件层次结构并查看了其中的重要文件夹，让我们在下一节看看文件系统。
- en: The Android filesystem
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android文件系统
- en: Understanding the filesystem is one essential part of forensic methodologies.
    Knowledge about the properties and the structure of a filesystem proves to be
    useful during forensic analysis. The filesystem refers to the way data is stored,
    organized, and retrieved from a volume. A basic installation may be based on one
    volume split into several partitions; here, each partition can be managed by a
    different filesystem. As is true in Linux, Android utilizes mount points, and
    not drives (that is, `C:` or `E:`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 了解文件系统是取证方法论的一个重要部分。了解文件系统的属性和结构在取证分析过程中非常有用。文件系统是指数据存储、组织和从卷中检索的方式。基本安装可能基于一个分成多个分区的卷；在这里，每个分区可以由不同的文件系统管理。在Linux中，Android使用挂载点，而不是驱动器（即`C:`或`E:`）。
- en: In Linux, mounting is an act of attaching an additional filesystem to the currently
    accessible filesystem of a computer. The filesystems in Linux are not accessed
    by drive names but instead are organized into a multi-level hierarchy with a directory
    called `root` at the top. Each new filesystem is added into this single filesystem
    tree when it is mounted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，挂载是将附加文件系统连接到计算机当前可访问的文件系统的行为。在Linux中，文件系统不是通过驱动器名称访问的，而是组织成一个多级层次结构，顶部有一个名为`root`的目录。每当挂载时，每个新文件系统都添加到这个单一的文件系统树中。
- en: It does not make any difference whether the filesystem exists on the local device
    or on a remote device. Everything is in a single hierarchy that begins with `root`. Each
    filesystem defines its own rules for managing the files in the volume. Depending
    on these rules, each filesystem offers a different speed for file retrieval, security,
    size, and so on. Linux uses several filesystems, and so does Android. From a forensic
    point of view, it's important to understand which filesystems are used by Android
    and to identify the filesystems that are of significance to the investigation.
    For example, the filesystem that stores the user's data is of primary concern
    to us, as opposed to a filesystem used to boot the device.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 无论文件系统存在于本地设备还是远程设备上都没有任何区别。一切都在以`root`开始的单一层次结构中。每个文件系统都定义了管理卷中文件的规则。根据这些规则，每个文件系统提供了不同的文件检索速度、安全性、大小等。Linux使用多个文件系统，Android也是如此。从取证的角度来看，了解Android使用的文件系统以及识别对调查具有重要意义的文件系统是很重要的。例如，存储用户数据的文件系统对我们来说是首要关注的，而不是用于启动设备的文件系统。
- en: Viewing filesystems on an Android device
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Android设备上的文件系统
- en: 'The filesystems supported by the Android kernel can be determined by checking
    the contents of the `filesystems` file in the `proc` folder. The content of this
    file can be viewed using the `# cat /proc/filesystems` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Android内核支持的文件系统可以通过检查`proc`文件夹中的`filesystems`文件的内容来确定。可以使用`# cat /proc/filesystems`命令查看此文件的内容：
- en: '![](img/233ac818-3d93-4d98-8b96-8a364216653d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/233ac818-3d93-4d98-8b96-8a364216653d.png)'
- en: Filesystems on an Android device
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备上的文件系统
- en: In the preceding output, the first column tells us whether the filesystem is
    mounted on the device. The ones with the `nodev` property are not mounted on the
    device.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，第一列告诉我们文件系统是否挂载在设备上。具有`nodev`属性的文件系统未挂载在设备上。
- en: 'The second column lists all the filesystems present on the device. A simple
    `mount` command displays different partitions available on the device, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列列出了设备上存在的所有文件系统。简单的`mount`命令显示设备上可用的不同分区，如下所示：
- en: '![](img/33438950-4399-4e5b-aa48-07cbeb9abf73.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33438950-4399-4e5b-aa48-07cbeb9abf73.png)'
- en: Partitions on the Android device
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备上的分区
- en: Next, let's look at the common filesystems on Android.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Android上常见的文件系统。
- en: Common filesystems found on Android
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上发现的常见文件系统
- en: 'The filesystems present in Android can be organized primarily into three main
    categories, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android中存在的文件系统主要可以分为三个主要类别，如下所示：
- en: Flash memory filesystems
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flash存储器文件系统
- en: Media-based filesystems
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于媒体的文件系统
- en: Pseudo filesystems
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪文件系统
- en: Let's look at each of them in detail.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一个。
- en: Flash memory filesystems
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flash存储器文件系统
- en: 'Flash memory is a type of constantly powered **nonvolatile memory** (**NVM**)
    that retains data in the absence of a power supply. Flash memory can be erased
    and reprogrammed in units of memory called blocks. While the supported filesystems
    vary based on the device and underlying Linux kernel, the common flash memory
    filesystems are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Flash存储器是一种持续供电的**非易失性存储器**（**NVM**），在没有电源供应的情况下保留数据。Flash存储器可以按块擦除和重新编程。虽然支持的文件系统因设备和底层Linux内核而异，但常见的Flash存储器文件系统如下：
- en: '**Extended File Allocation Table** (**exFAT**) is a Microsoft proprietary filesystem
    that was created to be used on flash drives such as USB memory sticks and SD cards.
    Because of the license requirements, it isn''t part of the standard Linux kernel.
    But still, a few manufacturers provide support for this filesystem.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展文件分配表**（**exFAT**）是微软专有的文件系统，用于闪存驱动器，如USB存储设备和SD卡。由于许可要求，它不是标准Linux内核的一部分。但仍然有一些制造商为该文件系统提供支持。'
- en: '**Flash Friendly File System **(**F2FS**) was released in February 2013 to
    support Samsung devices running the Linux 3.8 kernel. F2FS relies on log-structured
    methods that optimize the NAND flash memory. The offline support features are
    a highlight of this filesystem, though it is still transient and being updated.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flash友好文件系统**（**F2FS**）于2013年2月发布，以支持运行Linux 3.8内核的三星设备。F2FS依赖于优化NAND Flash存储器的日志结构方法。离线支持功能是该文件系统的一个亮点，尽管它仍然是临时的并且正在更新。'
- en: '**Yet Another Flash File System 2 **(**YAFFS2**) is an open source, single-threaded
    filesystem released in 2002\. It is mainly designed to be fast when dealing with the
    NAND flash. YAFFS2 utilizes **Out**-**of**-**band **(**OOB**), and this is often
    not captured or decoded correctly during forensic acquisition, which makes analysis difficult.
    We will discuss this further in [Chapter 9](https://cdp.packtpub.com/practical_mobile_forensics__fourth_edition/wp-admin/post.php?post=60&action=edit#post_470), *Android
    Data Extraction Techniques*. YAFFS2 was the most popular release at one point
    and is still widely used in Android devices. YAFFS2 is a log-structured filesystem.
    Data integrity is guaranteed, even in the case of a sudden power outage. In 2010,
    there was an announcement stating that in releases after Gingerbread, devices
    were going to move from YAFFS2 to **fourth extended file system** (**EXT4**).
    Currently, YAFFS2 is not supported by newer kernel versions, but certain mobile
    manufacturers might still continue to support it.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**另一个闪存文件系统2**（**YAFFS2**）是一个开源的单线程文件系统，于2002年发布。它主要设计用于处理NAND闪存时的速度。YAFFS2利用**带外**（**OOB**），这在取证获取时通常无法正确捕获或解码，使得分析变得困难。我们将在[第9章](https://cdp.packtpub.com/practical_mobile_forensics__fourth_edition/wp-admin/post.php?post=60&action=edit#post_470)中进一步讨论这个问题，*安卓数据提取技术*。YAFFS2曾经是最受欢迎的版本，并且仍然广泛用于安卓设备。YAFFS2是一个日志结构的文件系统。即使在突然断电的情况下，数据完整性也得到了保证。2010年，有一则公告称在Gingerbread之后的版本中，设备将从YAFFS2转移到**第四扩展文件系统**（**EXT4**）。目前，YAFFS2不受新内核版本的支持，但某些手机制造商可能仍然继续支持它。'
- en: '**Robust File System **(**RFS**) supports NAND flash memory on Samsung devices.
    RFS can be summarized as a **File Allocation Table 16** (**FAT16**) or FAT32 filesystem,
    whereby journaling is enabled through a transaction log. Many users complain that
    Samsung should stick with EXT4\. RFS has been known to have lag times that slow
    down the features of Android.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳健文件系统**（**RFS**）支持三星设备上的NAND闪存。RFS可以总结为**文件分配表16**（**FAT16**）或FAT32文件系统，通过事务日志启用日志记录。许多用户抱怨三星应该坚持使用EXT4。RFS已知会导致Android功能的延迟。'
- en: Next in line is media-based filesystems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体为基础的文件系统是接下来的一个主题。
- en: Media-based filesystems
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体为基础的文件系统
- en: The following are some of the media-based filesystems supported by Android devices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些安卓设备支持的媒体为基础的文件系统。
- en: The **Extended File System** (**EXT**), which was introduced in 1992 specifically
    for the Linux kernel, was one of the first filesystems, and it used a virtual
    filesystem. EXT2, EXT3, and EXT4 are the subsequent versions. Journaling is the
    main advantage of EXT3 over EXT2\. With EXT3, if there is an unexpected shutdown,
    there is no need to verify the filesystem. The EXT4 filesystem has gained significance
    with mobile devices implementing dual-core processors. The YAFFS2 filesystem is
    known to have a bottleneck on dual-core systems. With the Gingerbread version
    of Android, the YAFFS filesystem was swapped for EXT4.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展文件系统**（**EXT**）于1992年专门为Linux内核引入，是最早的文件系统之一，它使用了虚拟文件系统。EXT2、EXT3和EXT4是随后的版本。EXT3相对于EXT2的主要优势是日志记录。使用EXT3，如果出现意外关机，就不需要验证文件系统。EXT4文件系统随着移动设备实现双核处理器而变得重要。YAFFS2文件系统在双核系统上已知存在瓶颈。在安卓的Gingerbread版本中，YAFFS文件系统被替换为EXT4。'
- en: 'The following are the mount points that use EXT4 on the Samsung Galaxy mobile:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三星Galaxy手机上使用EXT4的挂载点：
- en: '[PRE0]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Virtual File Allocation Table** (**VFAT**) is an extension to the FAT16 and
    FAT32 filesystems. Microsoft''s FAT32 filesystem is supported by most Android
    devices. It is supported by almost all the major operating systems, including
    Windows, Linux, and macOS. This enables these systems to easily read, modify,
    and delete the files present on the FAT32 portion of the Android device. Most
    of the external SD cards are formatted using the FAT32 filesystem.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟文件分配表**（**VFAT**）是对FAT16和FAT32文件系统的扩展。大多数安卓设备支持微软的FAT32文件系统。它被几乎所有主要操作系统支持，包括Windows、Linux和macOS。这使得这些系统能够轻松地读取、修改和删除安卓设备的FAT32部分上的文件。大多数外部SD卡都是使用FAT32文件系统格式化的。'
- en: 'Observe the following output, which shows that the `/sdcard` and `/secure/asec` mount
    points use the VFAT filesystem:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下输出，显示了`/sdcard`和`/secure/asec`挂载点使用VFAT文件系统：
- en: '![](img/3d4cba12-e8f5-458a-af33-cce3f715f589.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d4cba12-e8f5-458a-af33-cce3f715f589.png)'
- en: mount command output in Android
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓中的挂载命令输出
- en: The final category is pseudo filesystems.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个类别是伪文件系统。
- en: Pseudo filesystems
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪文件系统
- en: 'Pseudo filesystems, as the name suggests, are not actual files but a logical
    grouping of files. The following are some of the important pseudo filesystems
    in Android:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 伪文件系统，顾名思义，不是实际的文件，而是文件的逻辑分组。以下是安卓中一些重要的伪文件系统：
- en: The root filesystem (`rootfs`) is one of the main components of Android and
    contains all the information required to boot the device. When the device starts
    the boot process, it needs access to many core files, and thus, it mounts the
    root filesystem. As shown in the preceding `mount` command-line output, this filesystem
    is mounted at `/` (`root` folder). Hence, this is the filesystem on which all
    the other filesystems are slowly mounted. If this filesystem is corrupt, the device
    cannot be booted.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统（`rootfs`）是安卓的主要组成部分之一，包含了启动设备所需的所有信息。当设备启动引导过程时，它需要访问许多核心文件，因此会挂载根文件系统。如前面的`mount`命令行输出所示，这个文件系统被挂载在`/`（`root`文件夹）上。因此，这是所有其他文件系统逐渐挂载的文件系统。如果这个文件系统损坏了，设备就无法启动。
- en: 'The `sysfs` filesystem mounts the `/sys` folder, which contains information
    about the configuration of the device. The following output shows various folders
    under the `sys` directory in an Android device:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysfs`文件系统挂载了`/sys`文件夹，其中包含了设备配置的信息。以下输出显示了安卓设备中`sys`目录下的各种文件夹：'
- en: '![](img/5539a170-e9b9-432a-b089-f9a0aaf70de5.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5539a170-e9b9-432a-b089-f9a0aaf70de5.png)'
- en: Folders under /sys directory in Android
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统中/sys目录下的文件夹
- en: Since the data present in these folders is mostly related to configuration,
    this is not usually of much significance to a forensic investigator. But there
    can be some circumstances where we might want to check whether a particular setting
    was enabled on the phone, and analyzing this folder could be useful under such
    conditions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些文件夹中的数据大多与配置相关，这对于取证调查员通常并不是非常重要。但在某些情况下，我们可能需要检查手机上是否启用了特定设置，并在这种情况下分析这个文件夹可能是有用的。
- en: Note that each folder consists of a large number of files. Capturing this data
    through forensic acquisition is the best method to ensure that this data is not
    changed during an examination.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个文件夹都包含大量文件。通过取证获取数据是确保在检查过程中数据不被更改的最佳方法。
- en: 'The `devpts` filesystem presents an interface to the Terminal session on an
    Android device. It is mounted at `/dev/pts`. Whenever a Terminal connection is
    established—for instance, when an `adb` shell is connected to an Android device—a
    new node is created under `/dev/pts`. The following is the output showing this
    when the `adb` shell is connected to the device:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devpts`文件系统提供了一个接口，用于在安卓设备上的终端会话。它被挂载在`/dev/pts`上。每当建立一个终端连接时，例如当`adb` shell连接到安卓设备时，一个新的节点会在`/dev/pts`下创建。以下是当`adb`
    shell连接到设备时显示的输出：'
- en: '[PRE1]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `cgroup` filesystem stands for **control groups**. Android devices use this
    filesystem to track their job. They are responsible for aggregating the tasks
    and keeping track of them. This data is generally not very useful during forensic
    analysis.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgroup`文件系统代表**控制组**。安卓设备使用这个文件系统来跟踪它们的任务。它们负责聚合任务并跟踪它们。这些数据通常在取证分析过程中并不是非常有用。'
- en: 'The `proc` filesystem contains information about kernel data structures, processes,
    and other system-related information in the `/proc` directory. For instance, the `/sys` directory
    contains files related to kernel parameters. Similarly, `/proc/filesystems` displays
    the list of available filesystems on the device. The following command shows all
    the information about the **central processing unit** (**CPU**) of the device:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc`文件系统包含有关内核数据结构、进程和其他系统相关信息的信息，存储在`/proc`目录中。例如，`/sys`目录包含与内核参数相关的文件。同样，`/proc/filesystems`显示设备上可用文件系统的列表。以下命令显示了设备的**中央处理器**（**CPU**）的所有信息：'
- en: '![](img/f84b90ee-5d42-419a-abf3-b9b5871a95e5.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f84b90ee-5d42-419a-abf3-b9b5871a95e5.png)'
- en: Output of the cpuinfo command on an Android device
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓设备上运行cpuinfo命令的输出。
- en: Similarly, there are many other useful files that provide valuable information
    when you traverse them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当您遍历这些文件时，还有许多其他有用的文件可以提供有价值的信息。
- en: The `tmpfs` filesystem is a temporary storage facility on the device that stores
    the files in RAM (volatile memory). The main advantage of using RAM is faster
    access and retrieval. But once the device is restarted or switched off, this data
    will not be accessible anymore. Hence, it's important for a forensic investigator
    to examine the data in RAM before a device reboot happens, or to extract the data
    via RAM acquisition methods.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmpfs`文件系统是设备上的临时存储设施，它将文件存储在RAM（易失性内存）中。使用RAM的主要优势是更快的访问和检索。但一旦设备重新启动或关闭，这些数据将不再可访问。因此，对于取证调查员来说，在设备重新启动之前检查RAM中的数据，或者通过RAM获取方法提取数据是很重要的。'
- en: Today's forensic tools can easily mount these filesystems and display the contents
    in a **graphical user interface** (**GUI**) screen, thereby enabling forensic
    investigators to easily navigate and parse through the files. In the initial days
    of Android forensics, an investigator had to typically run a set of Linux or Windows
    commands to format and view these filesystems.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的取证工具可以轻松地挂载这些文件系统，并在**图形用户界面**（**GUI**）屏幕上显示内容，从而使取证调查员能够轻松地浏览和解析文件。在安卓取证的早期阶段，调查员通常需要运行一系列Linux或Windows命令来格式化和查看这些文件系统。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the Android operating system's underlying features,
    filesystems, and other details that are useful in a forensic investigation. We
    learned about interesting security capabilities that are built into Android. Unlike
    iOS, several variants of Android exist as many devices run the Android operating
    system, and each may have different filesystems and unique features. The fact
    that Android is open and customizable also changes the playing field of digital
    forensics. This knowledge will be helpful to understand forensic acquisition techniques.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了安卓操作系统的基本特性、文件系统和其他在取证调查中有用的细节。我们了解了内置在安卓中的有趣的安全功能。与iOS不同，安卓存在多个变体，因为许多设备运行安卓操作系统，每个设备可能具有不同的文件系统和独特的特性。安卓是开放和可定制的事实也改变了数字取证的格局。这些知识将有助于理解取证获取技术。
- en: In the next chapter, we will discuss how to set up a forensic workstation before
    performing the analysis.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在进行分析之前设置取证工作站。
