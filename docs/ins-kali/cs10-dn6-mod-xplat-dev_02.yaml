- en: '02'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '02'
- en: Speaking C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说C#
- en: This chapter is all about the basics of the C# programming language. Over the
    course of this chapter, you'll learn how to write statements using the grammar
    of C#, as well as being introduced to some of the common vocabulary that you will
    use every day. In addition to this, by the end of the chapter, you'll feel confident
    in knowing how to temporarily store and work with information in your computer's
    memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍C#编程语言的基础知识。在本章的过程中，您将学习如何使用C#的语法编写语句，以及一些您每天都会使用的常见词汇。此外，在本章结束时，您将自信地知道如何在计算机内存中临时存储和处理信息。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing the C# language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C#语言
- en: Understanding C# grammar and vocabulary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解C#语法和词汇
- en: Working with variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Exploring more about console applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于控制台应用程序的探索
- en: Introducing the C# language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C#语言
- en: This part of the book is about the C# language—the grammar and vocabulary that
    you will use every day to write the source code for your applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这部分是关于C#语言的——您每天都会用来为应用程序编写源代码的语法和词汇。
- en: Programming languages have many similarities to human languages, except that
    in programming languages, you can make up your own words, just like Dr. Seuss!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言与人类语言有许多相似之处，只是在编程语言中，您可以编造自己的词，就像苏斯博士一样！
- en: 'In a book written by Dr. Seuss in 1950, *If I Ran the Zoo* , he states this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在1950年由苏斯博士撰写的一本书《如果我经营动物园》，他说：
- en: '"And then, just to show them, I''ll sail to Ka-Troo And Bring Back an It-Kutch,
    a Preep, and a Proo, A Nerkle, a Nerd, and a Seersucker, too!"'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “然后，只是为了向他们展示，我将航行到卡特鲁，带回一个伊特库奇，一个普里普和一个普鲁，一个纳克尔，一个书呆子，还有一件粗花呢外套！”
- en: Understanding language versions and features
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解语言版本和功能
- en: This part of the book covers the C# programming language and is written primarily
    for beginners, so it covers the fundamental topics that all developers need to
    know, from declaring variables to storing data to how to define your own custom
    data types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这部分涵盖了C#编程语言，主要是为初学者编写的，因此涵盖了所有开发人员需要了解的基本主题，从声明变量到存储数据，再到如何定义自己的自定义数据类型。
- en: This book covers features of the C# language from version 1.0 up to the latest
    version 10.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了C#语言从1.0版本到最新的10.0版本的特性。
- en: If you already have some familiarity with older versions of C# and are excited
    to find out about the new features in the most recent versions of C#, I have made
    it easier for you to jump around by listing language versions and their important
    new features below, along with the chapter number and topic title where you can
    learn about them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经对旧版本的C#有一定了解，并且对最新版本的C#的新功能感到兴奋，我已经为您列出了语言版本及其重要的新功能，以及您可以了解它们的章节编号和主题标题，以便您更轻松地跳转。
- en: C# 1.0
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 1.0
- en: C# 1.0 was released in 2002 and included all the important features of a statically
    typed object-oriented modern language, as you will see throughout *Chapters* *2*
    to *6* .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C# 1.0于2002年发布，包括了所有重要的静态类型面向对象的现代语言的特性，正如您将在*第2*至*第6*章中看到的。
- en: C# 2.0
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 2.0
- en: 'C# 2.0 was released in 2005 and focused on enabling strong data typing using
    generics, to improve code performance and reduce type errors, including the topics
    listed in the following table:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2.0于2005年发布，重点是使用泛型实现强大的数据类型，以提高代码性能并减少类型错误，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Nullable value types | 6 | Making a value type nullable |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 可空值类型 | 6 | 使值类型可为空 |'
- en: '| Generics | 6 | Making types more reusable with generics |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 泛型 | 6 | 使用泛型使类型更可重用 |'
- en: C# 3.0
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 3.0
- en: 'C# 3.0 was released in 2007 and focused on enabling declarative coding with
    **Language INtegrated Queries** (**LINQ** ) and related features like anonymous
    types and lambda expressions, including the topics listed in the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3.0于2007年发布，重点是通过**语言集成查询**（**LINQ**）和相关功能，如匿名类型和lambda表达式，实现声明式编码，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Implicitly typed local variables | 2 | Inferring the type of a local variable
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 隐式类型的局部变量 | 2 | 推断局部变量的类型 |'
- en: '| LINQ | 11 | All topics in *Chapter 11* , *Querying and Manipulating Data
    Using LINQ* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| LINQ | 11 | *第11章*中的所有主题，*使用LINQ查询和操作数据* |'
- en: C# 4.0
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 4.0
- en: 'C# 4.0 was released in 2010 and focused on improving interoperability with
    dynamic languages like F# and Python, including the topics listed in the following
    table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4.0于2010年发布，重点是改进与F#和Python等动态语言的互操作性，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Dynamic types | 2 | Storing dynamic types |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 动态类型 | 2 | 存储动态类型 |'
- en: '| Named/optional arguments | 5 | Optional parameters and named arguments |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 命名/可选参数 | 5 | 可选参数和命名参数 |'
- en: C# 5.0
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 5.0
- en: 'C# 5.0 was released in 2012 and focused on simplifying asynchronous operation
    support by automatically implementing complex state machines while writing what
    looks like synchronous statements, including the topics listed in the following
    table:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5.0于2012年发布，重点是通过自动实现复杂状态机来简化异步操作支持，同时编写看起来像同步语句的内容，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Simplified asynchronous tasks | 12 | Understanding async and await |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 简化的异步任务 | 12 | 理解async和await |'
- en: C# 6.0
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 6.0
- en: 'C# 6.0 was released in 2015 and focused on minor refinements to the language,
    including the topics listed in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0于2015年发布，重点是对语言进行微小的改进，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| `static` imports | 2 | Simplifying the usage of the console |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `static`导入 | 2 | 简化控制台的使用 |'
- en: '| Interpolated strings | 2 | Displaying output to the user |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 插值字符串 | 2 | 向用户显示输出 |'
- en: '| Expression bodied members | 5 | Defining read-only properties |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 表达式主体成员 | 5 | 定义只读属性 |'
- en: C# 7.0
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.0
- en: 'C# 7.0 was released in March 2017 and focused on adding functional language
    features like tuples and pattern matching, as well as minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0于2017年3月发布，重点是添加元组和模式匹配等功能语言特性，以及对语言的一些微小改进，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Binary literals and digit separators | 2 | Storing whole numbers |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 二进制文字和数字分隔符 | 2 | 存储整数 |'
- en: '| Pattern matching | 3 | Pattern matching with the `if` statement |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 模式匹配 | 3 | 使用`if`语句进行模式匹配 |'
- en: '| `out` variables | 5 | Controlling how parameters are passed |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '`out`变量 | 5 | 控制参数传递方式 |'
- en: '| Tuples | 5 | Combining multiple values with tuples |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: 元组 | 5 | 使用元组组合多个值 |
- en: '| Local functions | 6 | Defining local functions |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: 本地函数 | 6 | 定义本地函数 |
- en: C# 7.1
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.1
- en: 'C# 7.1 was released in August 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.1于2017年8月发布，重点是对语言进行微小改进，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Default literal expressions | 5 | Setting fields with default literal |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 默认文字表达式 | 5 | 使用默认文字设置字段 |'
- en: '| Inferred tuple element names | 5 | Inferring tuple names |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 推断元组元素名称 | 5 | 推断元组名称 |'
- en: '| `async` Main | 12 | Improving responsiveness for console apps |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `async` Main | 12 | 改善控制台应用程序的响应性 |'
- en: C# 7.2
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.2
- en: 'C# 7.2 was released in November 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2于2017年11月发布，重点是对语言进行微小改进，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Leading underscores in numeric literals | 2 | Storing whole numbers |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 数字文字中的前导下划线 | 2 | 存储整数 |'
- en: '| Non-trailing named arguments | 5 | Optional parameters and named arguments
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: 非尾随命名参数 | 5 | 可选参数和命名参数 |
- en: '| `private protected` access modifier | 5 | Understanding access modifiers
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '`private protected`访问修饰符 | 5 | 理解访问修饰符 |'
- en: '| You can test `==` and `!=` with tuple types | 5 | Comparing tuples |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: 您可以使用元组类型测试`==`和`!=` | 5 | 比较元组 |
- en: C# 7.3
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.3
- en: C# 7.3 was released in May 2018 and focused on performance-oriented safe code
    that improves `ref` variables, pointers, and `stackalloc` . These are advanced
    and rarely needed for most developers, so they are not covered in this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3于2018年5月发布，重点是性能导向的安全代码，改进了`ref`变量、指针和`stackalloc`。这些对大多数开发人员来说是高级且很少需要的，因此本书不涵盖它们。
- en: C# 8
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 8
- en: 'C# 8 was released in September 2019 and focused on a major change to the language
    related to null handling, including the topics listed in the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8于2019年9月发布，重点是与空处理相关的语言的重大变化，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Nullable reference types | 6 | Making a reference type nullable |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 可空引用类型 | 6 | 使引用类型可为空 |'
- en: '| Switch expressions | 3 | Simplifying `switch` statements with switch expressions
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 开关表达式 | 3 | 使用开关表达式简化`switch`语句 |'
- en: '| Default interface methods | 6 | Understanding default interface methods |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: 默认接口方法 | 6 | 理解默认接口方法 |
- en: C# 9
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 9
- en: 'C# 9 was released in November 2020 and focused on record types, refinements
    to pattern matching, and minimal-code console apps, including the topics listed
    in the following table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9于2020年11月发布，重点是记录类型、模式匹配的改进以及最小代码控制台应用程序，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Minimal-code console apps | 1 | Top-level programs |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 最小代码控制台应用程序 | 1 | 顶级程序 |'
- en: '| Target-typed new | 2 | Using target-typed new to instantiate objects |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: 目标类型的新 | 2 | 使用目标类型的新来实例化对象 |
- en: '| Enhanced pattern matching | 5 | Pattern matching with objects |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 增强模式匹配 | 5 | 对象的模式匹配 |'
- en: '| Records | 5 | Working with records |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 记录 | 5 | 使用记录 |'
- en: C# 10
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 10
- en: 'C# 10 was released in November 2021 and focused on features that minimize the
    amount of code needed in common scenarios, including the topics listed in the
    following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10于2021年11月发布，重点是在常见场景中最小化所需代码量的功能，包括以下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 章节 | 主题 |'
- en: '| Global namespace imports | 2 | Importing namespaces |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: 全局命名空间导入 | 2 | 导入命名空间 |
- en: '| Constant string literals | 2 | Formatting using interpolated strings |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 常量字符串文字 | 2 | 使用插值字符串进行格式化 |'
- en: '| File-scoped namespaces | 5 | Simplifying namespace declarations |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: 文件范围命名空间 | 5 | 简化命名空间声明 |
- en: '| Required properties | 5 | Requiring properties to be set during instantiation
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 必需属性 | 5 | 要求在实例化期间设置属性 |'
- en: '| Record structs | 6 | Working with record struct types |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 记录结构 | 6 | 使用记录结构类型 |'
- en: '| Null parameter checks | 6 | Checking for null in method parameters |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 空参数检查 | 6 | 检查方法参数是否为空 |'
- en: Understanding C# standards
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#标准
- en: 'Over the years, Microsoft has submitted a few versions of C# to standards bodies,
    as shown in the following table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，微软向标准机构提交了几个版本的C#，如下表所示：
- en: '| C# version | ECMA standard | ISO/IEC standard |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| C#版本 | ECMA标准 | ISO/IEC标准 |'
- en: '| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |'
- en: '| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |'
- en: '| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |'
- en: The standard for C# 6 is still a draft and work on adding C# 7 features is progressing.
    Microsoft made C# open source in 2014.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6的标准仍然是草案，正在进行添加C# 7功能的工作。微软于2014年将C#开源。
- en: 'There are currently three public GitHub repositories for making the work on
    C# and related technologies as open as possible, as shown in the following table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三个公共的GitHub存储库，使C#和相关技术的工作尽可能地开放，如下表所示：
- en: '| Description | Link |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: 描述 | 链接 |
- en: '| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| C#语言设计 | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
- en: '| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 编译器实现 | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
- en: '| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 用于描述语言的标准 | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
- en: Discovering your C# compiler versions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现您的C#编译器版本
- en: '.NET language compilers for C# and Visual Basic, also known as Roslyn, along
    with a separate compiler for F#, are distributed as part of the .NET SDK. To use
    a specific version of C#, you must have at least that version of the .NET SDK
    installed, as shown in the following table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: .NET语言编译器C#和Visual Basic，以及F#的单独编译器，也称为Roslyn，与.NET SDK的一部分一起分发。要使用特定版本的C#，您必须至少安装该版本的.NET
    SDK，如下表所示：
- en: '| .NET SDK | Roslyn compiler | Default C# language |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| .NET SDK | Roslyn编译器 | 默认C#语言 |'
- en: '| 1.0.4 | 2.0 - 2.2 | 7.0 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: 1.0.4 | 2.0 - 2.2 | 7.0 |
- en: '| 1.1.4 | 2.3 - 2.4 | 7.1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.4 | 2.3 - 2.4 | 7.1 |'
- en: '| 2.1.2 | 2.6 - 2.7 | 7.2 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.2 | 2.6 - 2.7 | 7.2 |'
- en: '| 2.1.200 | 2.8 - 2.10 | 7.3 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.200 | 2.8 - 2.10 | 7.3 |'
- en: '| 3.0 | 3.0 - 3.4 | 8.0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 3.0 - 3.4 | 8.0 |'
- en: '| 5.0 | 3.8 | 9.0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: 5.0 | 3.8 | 9.0 |
- en: '| 6.0 | 3.9 - 3.10 | 10.0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 3.9 - 3.10 | 10.0 |'
- en: 'When you create class libraries then you can choose to target .NET Standard
    as well as versions of modern .NET. They have default C# language versions, as
    shown in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建类库时，您可以选择将其目标设置为.NET标准以及现代.NET的版本。它们具有默认的C#语言版本，如下表所示：
- en: '| .NET Standard | C# |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: .NET标准 | C# |
- en: '| 2.0 | 7.3 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | 7.3 |'
- en: '| 2.1 | 8.0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | 8.0 |'
- en: How to output the SDK version
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何输出SDK版本
- en: 'Let''s see what .NET SDK and C# language compiler versions you have available:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您有哪些可用的.NET SDK和C#语言编译器版本：
- en: On macOS, start **Terminal** . On Windows, start **Command Prompt** .
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS上，启动**Terminal**。在Windows上，启动**命令提示符**。
- en: 'To determine which version of the .NET SDK you have available, enter the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定您有哪个版本的.NET SDK可用，请输入以下命令：
- en: '```cs'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: dotnet --version
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet --version
- en: '```'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the version at the time of writing is 6.0.100, indicating that it is the
    initial version of the SDK without any bug fixes or new features yet, as shown
    in the following output:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，撰写时的版本是6.0.100，表明这是SDK的初始版本，尚未进行任何错误修复或新功能添加，如下面的输出所示：
- en: '```cs'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 6.0.100
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 6.0.100
- en: '```'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Enabling a specific language version compiler
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用特定版本的语言编译器
- en: 'Developer tools like Visual Studio and the `dotnet` command-line interface
    assume that you want to use the latest major version of a C# language compiler
    by default. Before C# 8.0 was released, C# 7.0 was the latest major version and
    was used by default. To use the improvements in a C# point release like 7.1, 7.2,
    or 7.3, you had to add a `<LangVersion>` configuration element to the project
    file, as shown in the following markup:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像Visual Studio和`dotnet`命令行界面这样的开发工具默认假定您想要使用最新的C#语言编译器的主要版本。在C# 8.0发布之前，C# 7.0是最新的主要版本，并且默认情况下使用。要使用C#
    7.1、7.2或7.3这样的C#点发布的改进，您必须向项目文件添加`<LangVersion>`配置元素，如下面的标记所示：
- en: '```cs'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <LangVersion>7.3
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <LangVersion>7.3
- en: </LangVersion>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: </LangVersion>
- en: '```'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After the release of C# 10.0 with .NET 6.0, if Microsoft releases a C# 10.1
    compiler and you want to use its new language features then you will have to add
    a configuration element to your project file, as shown in the following markup:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布了带有.NET 6.0的C# 10.0之后，如果微软发布了C# 10.1编译器，并且您想要使用其新的语言特性，那么您将不得不向项目文件添加一个配置元素，如下面的标记所示：
- en: '```cs'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <LangVersion>10.1
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <LangVersion>10.1
- en: </LangVersion>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: </LangVersion>
- en: '```'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Potential values for the `<LangVersion>` are shown in the following table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<LangVersion>`的潜在值如下表所示：'
- en: '| LangVersion | Description |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| LangVersion | 描述 |'
- en: '| 7, 7.1, 7.2, 7.38, 9, 10 | Entering a specific version number will use that
    compiler if it has been installed. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 7, 7.1, 7.2, 7.38, 9, 10 | 输入特定版本号将使用已安装的编译器。 |'
- en: '| latestmajor | Uses the highest major number, for example, 7.0 in August 2019,
    8.0 in October 2019, 9.0 in November 2020, 10.0 in November 2021. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| latestmajor | 使用最高主要号，例如，2019年8月为7.0，2019年10月为8.0，2020年11月为9.0，2021年11月为10.0。
    |'
- en: '| `latest` | Uses the highest major and highest minor number, for example,
    7.2 in 2017, 7.3 in 2018, 8 in 2019, perhaps 10.1 in early 2022. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `latest` | 使用最高主要号和最高次要号，例如，2017年为7.2，2018年为7.3，2019年为8，也许2022年初为10.1。 |'
- en: '| `preview` | Uses the highest available preview version, for example, 10.0
    in July 2021 with .NET 6.0 Preview 6 installed. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `preview` | 使用最高可用的预览版本，例如，2021年7月安装了.NET 6.0预览6时的10.0。 |'
- en: 'After creating a new project, you can edit the `.csproj` file and add the `<LangVersion>`
    element, as shown highlighted in the following markup:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目后，您可以编辑`.csproj`文件并添加`<LangVersion>`元素，如下面标记中突出显示的那样：
- en: '```cs'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: '**<LangVersion>preview</LangVersion>**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**<LangVersion>preview</LangVersion>**'
- en: </PropertyGroup>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: </Project>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Your projects must target `net6.0` to use the full features of C# 10.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目必须以`net6.0`为目标，才能使用C# 10的全部功能。
- en: '**Good Practice** : If you are using Visual Studio Code and you have not done
    so already, install the Visual Studio Code extension named **MSBuild project tools**
    . This will give you IntelliSense while editing `.csproj` files, including making
    it easy to add the `<LangVersion>` element with appropriate values.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您使用Visual Studio Code，并且尚未这样做，请安装名为**MSBuild项目工具**的Visual Studio
    Code扩展。这将在编辑`.csproj`文件时为您提供智能感知，包括轻松添加带有适当值的`<LangVersion>`元素。'
- en: Understanding C# grammar and vocabulary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解C#语法和词汇
- en: To learn simple C# language features, you can use .NET Interactive Notebooks,
    which remove the need to create an application of any kind.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习简单的C#语言特性，您可以使用.NET交互式笔记本，它消除了创建任何类型的应用程序的需要。
- en: To learn some other C# language features, you will need to create an application.
    The simplest type of application is a console application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其他C#语言特性，您需要创建一个应用程序。最简单的应用程序类型是控制台应用程序。
- en: Let's start by looking at the basics of the grammar and vocabulary of C#. Throughout
    this chapter, you will create multiple console applications, with each one showing
    related features of the C# language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的C#语法和词汇开始。在本章中，您将创建多个控制台应用程序，每个应用程序显示C#语言的相关特性。
- en: Showing the compiler version
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示编译器版本
- en: 'We will start by writing code that shows the compiler version:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写显示编译器版本的代码开始：
- en: If you've completed *Chapter 1* , *Hello, C#! Welcome, .NET!* , then you will
    already have a `Code` folder. If not, then you'll need to create it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经完成了*第1章*，*你好，C#！欢迎，.NET！*，那么您已经有了一个`Code`文件夹。如果没有，那么您需要创建它。
- en: 'Use your preferred code editor to create a new console app, as defined in the
    following list:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器创建一个新的控制台应用程序，如下列表所示：
- en: 'Project template: **Console Application [C#]** / `console`'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序[C#]** / `控制台`
- en: 'Workspace/solution file and folder: `Chapter02`'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`第02章`
- en: 'Project file and folder: `Vocabulary`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`词汇`
- en: '**Good Practice** : If you have forgotten how, or did not complete the previous
    chapter, then step-by-step instructions for creating a workspace/solution with
    multiple projects are given in *Chapter 1* , *Hello, C#! Welcome, .NET!* .'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您忘记了如何做，或者没有完成上一章，那么在*第1章*，*你好，C#！欢迎，.NET！*中提供了创建具有多个项目的工作区/解决方案的逐步说明。'
- en: 'Open the `Program.cs` file, and at the top of the file, under the comment,
    add a statement to show the C# version as an error, as shown in the following
    code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，在文件顶部的注释下方，添加一个显示C#版本的语句作为错误，如下面的代码所示：
- en: '```cs'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: error
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: version
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 版本
- en: '```'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the console application:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序：
- en: In Visual Studio Code, in a terminal, enter the command `dotnet run` .
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端中输入命令`dotnet run`。
- en: In Visual Studio, navigate to **Debug** | **Start Without Debugging** . When
    prompted to continue and run the last successful build, click **No** .
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，转到**调试** | **开始调试**。当提示继续并运行上次成功构建时，单击**否**。
- en: Note the compiler version and language version appear as a compiler error message
    number `CS8304` , as shown in *Figure 2.1* :![](img/Image00030.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意编译器版本和语言版本显示为编译器错误消息编号`CS8304`，如*图2.1*所示：![](img/Image00030.jpg)
- en: 'Figure 2.1: A compiler error that shows the C# language version'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：显示C#语言版本的编译器错误
- en: 'The error message in the Visual Studio Code **PROBLEMS** window or Visual Studio
    **Error List** window says `Compiler version: ''4.0.0...''` with language version
    `10.0` .'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio Code中的错误消息窗口或Visual Studio中的**错误列表**窗口显示错误消息`编译器版本：'4.0.0...'`，语言版本为`10.0`。
- en: 'Comment out the statement that causes the error, as shown in the following
    code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致错误的语句，如下面的代码所示：
- en: '```cs'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '// #error version'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '// #error版本'
- en: '```'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note that the compiler error messages disappear.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意编译器错误消息消失了。
- en: Understanding C# grammar
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#语法
- en: The grammar of C# includes statements and blocks. To document your code, you
    can use comments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C#的语法包括语句和块。要记录您的代码，您可以使用注释。
- en: '**Good Practice** : Comments should not be the only way that you document your
    code. Choosing sensible names for variables and functions, writing unit tests,
    and creating actual documents are other ways to document your code.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：注释不应该是您记录代码的唯一方式。选择合理的变量和函数名称，编写单元测试，并创建实际文档是记录代码的其他方式。'
- en: Statements
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: In English, we indicate the end of a sentence with a full stop. A sentence can
    be composed of multiple words and phrases, with the order of words being part
    of the grammar. For example, in English, we say "the black cat."
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们用句号表示句子的结束。句子可以由多个单词和短语组成，单词的顺序是语法的一部分。例如，在英语中，我们说“the black cat.”
- en: 'The adjective, *black* , comes before the noun, *cat* . Whereas French grammar
    has a different order; the adjective comes after the noun: "le chat noir." What''s
    important to take away from this is that the order matters.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词*黑色*在名词*猫*之前。而法语语法的顺序不同；形容词在名词之后：“le chat noir.” 从中重要的是顺序很重要。
- en: 'C# indicates the end of a **statement** with a semicolon. A statement can be
    composed of multiple **variables** and **expressions** . For example, in the following
    statement, `totalPrice` is a variable and `subtotal + salesTax` is an expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C#用分号表示**语句**的结束。语句可以由多个**变量**和**表达式**组成。例如，在下面的语句中，`totalPrice`是一个变量，`subtotal
    + salesTax`是一个表达式：
- en: '```cs'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: totalPrice = subtotal + salesTax;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: totalPrice = subtotal + salesTax;
- en: '```'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The expression is made up of an operand named `subtotal` , an operator `+` ,
    and another operand named `salesTax` . The order of operands and operators matters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式由名为`subtotal`的操作数、名为`+`的运算符和名为`salesTax`的另一个操作数组成。操作数和运算符的顺序很重要。
- en: Comments
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评论
- en: 'When writing your code, you''re able to add comments to explain your code using
    a double slash, `//` . By inserting `//` the compiler will ignore everything after
    the `//` until the end of the line, as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，您可以使用双斜杠`//`添加注释来解释您的代码。通过插入`//`，编译器将忽略`//`之后的所有内容，直到行尾，如下面的代码所示：
- en: '```cs'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // sales tax must be added to the subtotal
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: //销售税必须添加到小计中
- en: var
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: totalPrice = subtotal + salesTax;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: totalPrice = subtotal + salesTax;
- en: '```'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To write a multiline comment, use `/*` at the beginning and `*/` at the end
    of the comment, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写多行注释，请在注释开头使用`/*`，在注释结尾使用`*/`，如下面的代码所示：
- en: '```cs'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: /*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: /*
- en: This is a multi-line comment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多行注释。
- en: '*/'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: '```'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Well-designed code, including function signatures with
    well-named parameters and class encapsulation, can be somewhat self-documenting.
    When you find yourself putting too many comments and explanations in your code,
    ask yourself: can I rewrite, aka refactor, this code to make it more understandable
    without long comments?'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：设计良好的代码，包括具有良好命名参数和类封装的函数签名，可以在一定程度上自我记录。当您发现自己在代码中放置了太多注释和解释时，请问自己：我能否重写，即重构，这段代码，使其更易理解而不需要长篇注释？'
- en: 'Your code editor has commands to make it easier to add and remove comment characters,
    as shown in the following list:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码编辑器有命令可以更容易地添加和删除注释字符，如下列表所示：
- en: '**Visual Studio 2022 for Windows** : Navigate to **Edit** | **Advanced** |
    **Comment Selection** or **Uncomment Selection**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio 2022 for Windows**：导航到**编辑** | **高级** | **注释选择**或**取消注释选择**'
- en: '**Visual Studio Code** : Navigate to **Edit** | **Toggle Line Comment** or
    **Toggle Block Comment**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：导航到**编辑** | **切换行注释**或**切换块注释**'
- en: '**Good Practice** : You **comment** code by adding descriptive text above or
    after code statements. You **comment out** code by adding comment characters before
    or around statements to make them inactive. **Uncommenting** means removing the
    comment characters.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：您可以通过在代码语句上方或下方添加描述性文本来**注释**代码。您可以通过在语句之前或周围添加注释字符来**注释掉**代码，使其无效。**取消注释**意味着删除注释字符。'
- en: Blocks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: In English, we indicate a new paragraph by starting a new line. C# indicates
    a **block** of code with the use of curly brackets, `{ }` .
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们通过开始新的一行来表示新的段落。C#使用花括号`{}`来表示代码的**块**。
- en: Blocks start with a declaration to indicate what is being defined. For example,
    a block can define the start and end of many language constructs including namespaces,
    classes, methods, or statements like `foreach` .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 块以声明开始，以指示正在定义什么。例如，一个块可以定义许多语言结构的开始和结束，包括命名空间、类、方法或`foreach`等语句。
- en: 'You will learn more about namespaces, classes, and methods later in this chapter
    and subsequent chapters but to briefly introduce some of those concepts now:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章和后续章节中更多地了解有关命名空间、类和方法的内容，但现在简要介绍一些概念：
- en: A **namespace** contains types like classes to group them together.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**包含类等类型，以将它们组合在一起。'
- en: A **class** contains the members of an object including methods.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**类**包含了对象的成员，包括方法。
- en: A **method** contains statements that implement an action that an object can
    take.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**方法**包含了实现对象可以执行的动作的语句。
- en: Examples of statements and blocks
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和块的示例
- en: 'In the project template for console apps when targeting .NET 5.0, note that
    examples of the grammar of C# have been written for you by the project template.
    I''ve added some comments to the statements and blocks, as shown in the following
    code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对.NET 5.0的控制台应用程序项目模板中，注意C#语法的示例已经由项目模板为您编写。我已经在语句和块中添加了一些注释，如下面的代码所示：
- en: '```cs'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: System; // a semicolon indicates the end of a statement
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: System; // 分号表示语句的结束
- en: namespace
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Basics
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识
- en: '{ // an open brace indicates the start of a block'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '{ // 开括号表示块的开始'
- en: class
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Program
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Program
- en: '{'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: static
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: void
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Main
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Main
- en: (
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '[] args'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[] args'
- en: )
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Hello World!"
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Hello World!"
- en: ); // a statement
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 语句
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} // a close brace indicates the end of a block'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '} // 闭括号表示块的结束'
- en: '```'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding C# vocabulary
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解C#词汇
- en: The C# vocabulary is made up of **keywords** , **symbol characters** , and **types**
    .
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: C#词汇由**关键字**，**符号字符**和**类型**组成。
- en: Some of the predefined, reserved keywords that you will see in this book include
    `using` , `namespace` , `class` , `static` , `int` , `string` , `double` , `bool`
    , `if` , `switch` , `break` , `while` , `do` , `for` , `foreach` , `and` , `or`
    , `not` , `record` , and `init` .
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将看到一些预定义的保留关键字，包括`using`,`namespace`,`class`,`static`,`int`,`string`,`double`,`bool`,`if`,`switch`,`break`,`while`,`do`,`for`,`foreach`,`and`,`or`,`not`,`record`和`init`。
- en: Some of the symbol characters that you will see include `"` , `'` , `+` , `-`
    , `*` , `/` , `%` , `@` , and `$` .
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的一些符号字符包括`"`,`'`,`+`,`-`,`*`,`/`,`%`,`@`和`$`。
- en: There are other contextual keywords that only have a special meaning in a specific
    context.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些上下文关键字，它们只在特定上下文中具有特殊含义。
- en: However, that still means that there are only about 100 actual C# keywords in
    the language.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着语言中实际上只有大约100个C#关键字。
- en: Comparing programming languages to human languages
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编程语言与人类语言进行比较
- en: The English language has more than 250,000 distinct words, so how does C# get
    away with only having about 100 keywords? Moreover, why is C# so difficult to
    learn if it has only 0.0416% of the number of words in the English language?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 英语语言有超过25万个不同的单词，那么为什么C#只有大约100个关键字？此外，如果C#只有英语语言中单词数量的0.0416%，为什么学习起来如此困难？
- en: One of the key differences between a human language and a programming language
    is that developers need to be able to define the new "words" with new meanings.
    Apart from the about 100 keywords in the C# language, this book will teach you
    about some of the hundreds of thousands of "words" that other developers have
    defined, but you will also learn how to define your own "words."
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言和编程语言之间的一个关键区别是开发人员需要能够定义具有新含义的新“单词”。除了C#语言中的大约100个关键字之外，本书还将教您一些其他开发人员定义的数十万个“单词”，但您还将学习如何定义自己的“单词”。
- en: 'Programmers all over the world must learn English because most programming
    languages use English words such as namespace and class. There are programming
    languages that use other human languages, such as Arabic, but they are rare. If
    you are interested in learning more, this YouTube video shows a demonstration
    of an Arabic programming language: [https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8)
    .'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的程序员都必须学习英语，因为大多数编程语言使用英语单词，如namespace和class。还有一些使用其他人类语言（如阿拉伯语）的编程语言，但它们很少见。如果您有兴趣了解更多，这个YouTube视频展示了阿拉伯编程语言的演示：[https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8)。
- en: Changing the color scheme for C# syntax
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改C#语法的颜色方案
- en: 'By default, Visual Studio Code and Visual Studio show C# keywords in blue to
    make them easier to differentiate from other code. Both tools allow you to customize
    the color scheme:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio Code和Visual Studio会以蓝色显示C#关键字，以便更容易区分其他代码。这两个工具都允许您自定义颜色方案：
- en: In Visual Studio Code, navigate to **Code** | **Preferences** | **Color Theme**
    (it is on the **File** menu on Windows).
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，导航到**代码** | **首选项** | **颜色主题**（在Windows上是**文件**菜单）。
- en: Select a color theme. For reference, I'll use the **Light+ (default light)**
    color theme so that the screenshots look good in a printed book.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个颜色主题。作为参考，我将使用**Light+（默认浅色）**颜色主题，以便截图在印刷书籍中看起来好看。
- en: In Visual Studio, navigate to **Tools** | **Options** .
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**工具** | **选项**。
- en: In the **Options** dialog box, select **Fonts and Colors** , and then select
    the display items that you would like to customize.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选项**对话框中，选择**字体和颜色**，然后选择要自定义的显示项。
- en: Help for writing correct code
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助编写正确的代码
- en: Plain text editors such as Notepad don't help you write correct English. Likewise,
    Notepad won't help you write correct C# either.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 像记事本这样的纯文本编辑器无法帮助您编写正确的英语。同样，记事本也无法帮助您编写正确的C#。
- en: Microsoft Word can help you write English by highlighting spelling mistakes
    with red squiggles, with Word saying that "icecream" should be ice-cream or ice
    cream, and grammatical errors with blue squiggles, such as a sentence should have
    an uppercase first letter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Word可以通过红色波浪线突出显示拼写错误来帮助您编写英语，Word会说“icecream”应该是ice-cream或ice cream，并通过蓝色波浪线突出显示语法错误，例如句子应以大写字母开头。
- en: Similarly, Visual Studio Code's C# extension and Visual Studio help you write
    C# code by highlighting spelling mistakes, such as the method name should be `WriteLine`
    with an uppercase L, and grammatical errors, such as statements that must end
    with a semicolon.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Visual Studio Code的C#扩展和Visual Studio通过突出显示拼写错误（例如，方法名应为`WriteLine`，L应大写）和语法错误（例如，语句必须以分号结尾）来帮助您编写C#代码。
- en: The C# extension constantly watches what you type and gives you feedback by
    highlighting problems with colored squiggly lines, similar to that of Microsoft
    Word.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: C#扩展不断监视您的输入，并通过突出显示有问题的地方以彩色波浪线的方式给出反馈，类似于Microsoft Word。
- en: 'Let''s see it in action:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的效果：
- en: In `Program.cs` , change the `L` in the `WriteLine` method to lowercase.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，将`WriteLine`方法中的`L`改为小写。
- en: Delete the semicolon at the end of the statement.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除语句末尾的分号。
- en: In Visual Studio Code, navigate to **View** | **Problems** , or in Visual Studio
    navigate to **View** | **Error List** , and note that a red squiggle appears under
    the code mistakes and details are shown, as you can see in *Figure 2.2* :![](img/Image00031.jpg)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，导航到**视图** | **问题**，或在Visual Studio中导航到**视图** | **错误列表**，注意到代码错误下方出现了红色波浪线，并显示了详细信息，如*图2.2*所示：![](img/Image00031.jpg)
- en: 'Figure 2.2: The Error List window showing two compile errors'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：错误列表窗口显示两个编译错误
- en: Fix the two coding errors.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复两个编码错误。
- en: Importing namespaces
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间
- en: '`System` is a namespace, which is like an address for a type. To refer to someone''s
    location exactly, you might use `Oxford.HighStreet.BobSmith` , which tells us
    to look for a person named Bob Smith on the High Street in the city of Oxford.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`是一个命名空间，类似于类型的地址。要确切地指代某人的位置，您可能会使用`Oxford.HighStreet.BobSmith`，这告诉我们在牛津市的High
    Street上寻找一个名叫Bob Smith的人。'
- en: '`System.Console.WriteLine` tells the compiler to look for a method named `WriteLine`
    in a type named `Console` in a namespace named `System` . To simplify our code,
    the **Console Application** project template for every version of .NET before
    6.0 added a statement at the top of the code file to tell the compiler to always
    look in the `System` namespace for types that haven''t been prefixed with their
    namespace, as shown in the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Console.WriteLine`告诉编译器在名为`System`的命名空间中查找名为`Console`的类型中的名为`WriteLine`的方法。为了简化我们的代码，在.NET
    6.0之前的每个版本的**控制台应用程序**项目模板都会在代码文件顶部添加一条语句，告诉编译器始终在`System`命名空间中查找未加前缀的类型，如下面的代码所示：'
- en: '```cs'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System; // import the System namespace
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: System; // 导入System命名空间
- en: '```'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We call this *importing the namespace* . The effect of importing a namespace
    is that all available types in that namespace will be available to your program
    without needing to enter the namespace prefix and will be seen in IntelliSense
    while you write code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为*导入命名空间*。导入命名空间的效果是该命名空间中的所有可用类型都将在您的程序中可用，而无需输入命名空间前缀，并且在编写代码时将在IntelliSense中看到。
- en: .NET Interactive notebooks have most namespaces imported automatically.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: .NET交互式笔记本自动导入大多数命名空间。
- en: Implicitly and globally importing namespaces
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式和全局导入命名空间
- en: 'Traditionally, every `.cs` file that needs to import namespaces would have
    to start with `using` statements to import those namespaces. Namespaces like `System`
    and `System.Linq` are needed in almost all `.cs` files, so the first few lines
    of every `.cs` file often had at least a few `using` statements, as shown in the
    following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个需要导入命名空间的`.cs`文件都必须以`using`语句开头来导入这些命名空间。像`System`和`System.Linq`这样的命名空间几乎在所有`.cs`文件中都是必需的，因此每个`.cs`文件的前几行通常至少有几个`using`语句，如下面的代码所示：
- en: '```cs'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: using
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Linq;
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: System.Linq;
- en: using
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Collections.Generic;
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: System.Collections.Generic;
- en: '```'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When creating websites and services using ASP.NET Core, there are often dozens
    of namespaces that each file would have to import.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ASP.NET Core创建网站和服务时，通常会有几十个命名空间需要每个文件导入。
- en: C# 10 introduces some new features that simplify importing namespaces.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了一些新功能，简化了导入命名空间。
- en: 'First, the `global using` statement means you only need to import a namespace
    in one `.cs` file and it will be available throughout all `.cs` files. You could
    put `global using` statements in the `Program.cs` file but I recommend creating
    a separate file for those statements named something like `GlobalUsings.cs` or
    `GlobalNamespaces.cs` , as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`global using`语句意味着您只需要在一个`.cs`文件中导入一个命名空间，它将在所有`.cs`文件中可用。您可以将`global using`语句放在`Program.cs`文件中，但我建议创建一个单独的文件来放置这些语句，命名为`GlobalUsings.cs`或`GlobalNamespaces.cs`，如下面的代码所示：
- en: '```cs'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: global
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: using
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: global
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: using
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Linq;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: System.Linq;
- en: global
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: using
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Collections.Generic;
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: System.Collections.Generic;
- en: '```'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : As developers get used to this new C# feature, I expect
    one naming convention for this file to become the standard.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：随着开发人员习惯于这一新的C#功能，我期望这个文件的一种命名约定成为标准。'
- en: 'Second, any projects that target .NET 6.0 and therefore use the C# 10 compiler
    generate a`.cs` file in the `obj` folder to implicitly globally import some common
    namespaces like `System` . The specific list of implicitly imported namespaces
    depends on which SDK you target, as shown in the following table:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，任何针对.NET 6.0的项目并因此使用C# 10编译器的项目都会在`obj`文件夹中生成一个`.cs`文件，以隐式全局导入一些常见的命名空间，如`System`。隐式导入的命名空间的具体列表取决于您的目标SDK，如下表所示：
- en: '| SDK | Implicitly imported namespaces |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| SDK | 隐式导入的命名空间 |'
- en: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
- en: '| `Microsoft.NET.Sdk.Web` | Same as `Microsoft.NET.Sdk` and:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Web` | 与`Microsoft.NET.Sdk`相同:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
- en: '| `Microsoft.NET.Sdk.Worker` | Same as `Microsoft.NET.Sdk` and:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Worker` | 与`Microsoft.NET.Sdk`相同:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
- en: 'Let''s see the current auto-generated implicit imports file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前自动生成的隐式导入文件：
- en: In **Solution Explorer** , select the `Vocabulary` project, toggle on the **Show
    All Files** button, and note the compiler-generated `bin` and `obj` folders are
    visible.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，选择`Vocabulary`项目，切换打开**显示所有文件**按钮，并注意编译器生成的`bin`和`obj`文件夹是可见的。
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs` .
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。
- en: 'Note this file is automatically created by the compiler for projects that target
    .NET 6.0, and that it imports some commonly used namespaces including `System.Threading`
    , as shown in the following code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，此文件是由编译器自动生成的，用于针对.NET 6.0的项目，并且它导入了一些常用的命名空间，包括`System.Threading`，如下代码所示：
- en: '```cs'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // <autogenerated />
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: // <autogenerated />
- en: global
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System;'
- en: global
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: ::System.Collections.Generic;
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Collections.Generic;'
- en: global
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.IO;
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.IO;'
- en: global
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Linq;
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Linq;'
- en: global
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Net.Http;
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Net.Http;'
- en: global
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Threading;
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Threading;'
- en: global
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Threading.Tasks;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Threading.Tasks;'
- en: '```'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Vocabulary.GlobalUsings.g.cs`文件。
- en: 'In **Solution Explorer** , select the project, and then add additional entries
    to the project file to control which namespaces are implicitly imported, as shown
    highlighted in the following markup:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，选择项目，然后向项目文件添加其他条目以控制隐式导入的命名空间，如下标记所示：
- en: '```cs'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType> Exe </ OutputType>
- en: <TargetFramework>net6.0
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: </ TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>启用</ Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>启用</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: </ PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<Using Remove=**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**<Using Remove=**'
- en: '**"System.Threading"**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**"System.Threading"**'
- en: '**/>**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**<Using Include=**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**<Using Include=**'
- en: '**"System.Numerics"**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**"System.Numerics"**'
- en: '**/>**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ ItemGroup>**'
- en: </Project>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: </ Project>
- en: '```'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Save the changes to the project file.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对项目文件的更改。
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs` .
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。
- en: 'Note this file now imports `System.Numerics` instead of `System.Threading`
    , as shown highlighted in the following code:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，此文件现在导入`System.Numerics`而不是`System.Threading`，如下代码中所示：
- en: '```cs'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // <autogenerated />
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: // <autogenerated />
- en: global
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: ::System;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System;'
- en: global
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 全局
- en: ::System.Collections.Generic;
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Collections.Generic;'
- en: global
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.IO;
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.IO;'
- en: global
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Linq;
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Linq;'
- en: global
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Net.Http;
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Net.Http;'
- en: global
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: using
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: global
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 全球
- en: ::System.Threading.Tasks;
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ':: System.Threading.Tasks;'
- en: '**global**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**全球**'
- en: '**using**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用**'
- en: '**global**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**全球**'
- en: '**::System.Numerics;**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**:: System.Numerics;**'
- en: '```'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Vocabulary.GlobalUsings.g.cs`文件。
- en: 'You can disable the implicitly imported namespaces feature for all SDKs by
    removing an entry in the project file, as shown in the following markup:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从项目文件中删除条目来禁用所有SDK的隐式导入命名空间功能，如下标记所示：
- en: '```cs'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>启用</ImplicitUsings>
- en: '```'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Verbs are methods
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动词是方法
- en: In English, verbs are doing or action words, like run and jump. In C#, doing
    or action words are called **methods** . There are hundreds of thousands of methods
    available to C#. In English, verbs change how they are written based on when in
    time the action happens. For example, Amir *was jumping* in the past, Beth *jumps*
    in the present, they *jumped* in the past, and Charlie *will jump* in the future.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，动词是做或动作词，比如run和jump。在C#中，做或动作词称为**方法**。有数十万种方法可供C#使用。在英语中，动词根据动作发生的时间而改变书写方式。例如，Amir
    *过去正在跳*，Beth *现在跳*，他们*过去跳*，Charlie *将来会跳*。
- en: 'In C#, methods such as `WriteLine` change how they are called or executed based
    on the specifics of the action. This is called overloading, which we''ll cover
    in more detail in *Chapter 5* , *Building Your Own Types with Object-Oriented
    Programming* . But for now, consider the following example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，诸如`WriteLine`的方法根据具体的操作方式或执行方式而改变。这被称为重载，我们将在*第5章*，*使用面向对象编程构建自己的类型*中详细介绍。但现在，考虑以下示例：
- en: '```cs'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // outputs the current line terminator string
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: // 输出当前行终止符字符串
- en: // by default, this is a carriage-return and line feed
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: // 默认情况下，这是回车和换行
- en: Console.WriteLine();
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine();
- en: // outputs the greeting and the current line terminator string
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: // 输出问候语和当前行终止符字符串
- en: Console.WriteLine("Hello Ahmed"
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Hello Ahmed"
- en: );
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // outputs a formatted number and date and the current line terminator string
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: // 输出格式化的数字和日期以及当前行终止符字符串
- en: Console.WriteLine("Temperature on {0:D} is {1}°C."
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Temperature on {0:D} is {1}°C."
- en: ','
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: DateTime.Today, 23.4
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime.Today, 23.4
- en: );
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A different analogy is that some words are spelled the same but have different
    meanings depending on the context.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类比是，有些单词拼写相同，但根据上下文有不同的含义。
- en: Nouns are types, variables, fields, and properties
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名词是类型、变量、字段和属性
- en: In English, nouns are names that refer to things. For example, Fido is the name
    of a dog. The word "dog" tells us the type of thing that Fido is, and so in order
    for Fido to fetch a ball, we would use his name.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，名词是指代事物的名称。例如，Fido是一只狗的名字。单词“狗”告诉我们Fido是什么类型的东西，所以为了让Fido去接球，我们会用他的名字。
- en: 'In C#, their equivalents are **types** , **variables** , **fields** , and **properties**
    . For example:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它们的等价物是**类型**、**变量**、**字段**和**属性**。例如：
- en: '`Animal` and `Car` are types; they are nouns for categorizing things.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal`和`Car`是类型；它们是用于对事物进行分类的名词。'
- en: '`Head` and `Engine` might be fields or properties; nouns that belong to `Animal`
    and `Car` .'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Head`和`Engine`可能是字段或属性；属于`Animal`和`Car`的名词。'
- en: '`Fido` and `Bob` are variables; nouns for referring to a specific object.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fido`和`Bob`是变量；用于指代特定对象的名词。'
- en: There are tens of thousands of types available to C#, though have you noticed
    how I didn't say, "There are tens of thousands of types in C#?" The difference
    is subtle but important. The language of C# only has a few keywords for types,
    such as `string` and `int` , and strictly speaking, C# doesn't define any types.
    Keywords such as `string` that look like types are **aliases** , which represent
    types provided by the platform on which C# runs.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有数以万计的类型可用，尽管你是否注意到我没有说，“C#中有数以万计的类型？” 这种差异微妙但重要。C#语言只有少数关键字用于类型，例如`string`和`int`，严格来说，C#并没有定义任何类型。看起来像类型的关键字，如`string`，是**别名**，代表着C#运行的平台提供的类型。
- en: It's important to know that C# cannot exist alone; after all, it's a language
    that runs on variants of .NET. In theory, someone could write a compiler for C#
    that uses a different platform, with different underlying types. In practice,
    the platform for C# is .NET, which provides tens of thousands of types to C#,
    including `System.Int32` , which is the C# keyword alias `int` maps to, as well
    as many more complex types, such as `System.Xml.Linq.XDocument` .
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，C#不能独立存在；毕竟，它是一种运行在.NET变体上的语言。理论上，有人可以为C#编写一个使用不同平台、具有不同底层类型的编译器。实际上，C#的平台是.NET，它为C#提供了数以万计的类型，包括`System.Int32`，它是C#关键字别名`int`映射到的类型，以及许多更复杂的类型，如`System.Xml.Linq.XDocument`。
- en: It's worth taking note that the term **type** is often confused with **class**
    . Have you ever played the parlor game *Twenty Questions* , also known as *Animal,
    Vegetable, or Mineral* ? In the game, everything can be categorized as an animal,
    vegetable, or mineral. In C#, every **type** can be categorized as a `class` ,
    `struct` , `enum` , `interface` , or `delegate` . You will learn what these mean
    in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* . As examples,
    the C# keyword `string` is a `class` , but `int` is a `struct` . So, it is best
    to use the term **type** to refer to both.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，术语**类型**经常与**类**混淆。你玩过推理游戏*二十个问题*吗，也称为*动物、植物或矿物*？在这个游戏中，一切都可以归类为动物、植物或矿物。在C#中，每个**类型**都可以归类为`class`、`struct`、`enum`、`interface`或`delegate`。你将在*第6章*，*实现接口和继承类*中学到这些含义。例如，C#关键字`string`是一个`class`，但`int`是一个`struct`。因此，最好使用术语**类型**来指代两者。
- en: Revealing the extent of the C# vocabulary
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示C#词汇的广度
- en: We know that there are more than 100 keywords in C#, but how many types are
    there? Let's write some code to find out how many types (and their methods) are
    available to C# in our simple console application.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道C#中有100多个关键字，但有多少种类型呢？让我们编写一些代码来找出我们简单控制台应用程序中有多少种类型（及其方法）可供C#使用。
- en: 'Don''t worry exactly how this code works for now but know that it uses a technique
    called **reflection** :'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不用担心这段代码是如何工作的，但要知道它使用了一种叫做**反射**的技术：
- en: 'We''ll start by importing the `System.Reflection` namespace at the top of the
    `Program.cs` file, as shown in the following code:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`Program.cs`文件的顶部导入`System.Reflection`命名空间，如下面的代码所示：
- en: '```cs'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Reflection;
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: System.Reflection;
- en: '```'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Delete the statement that writes `Hello World!` and replace it with the following
    code:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除写入`Hello World!`的语句，并用以下代码替换它：
- en: '```cs'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Assembly? assembly = Assembly.GetEntryAssembly();
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Assembly? assembly = Assembly.GetEntryAssembly();
- en: if
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (assembly == null
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: （assembly == null
- en: ) return
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ）返回
- en: ;
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ；
- en: // loop through the assemblies that this app references
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: // 循环遍历此应用程序引用的程序集
- en: foreach
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (AssemblyName name in
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: （AssemblyName name in
- en: assembly.GetReferencedAssemblies())
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: assembly.GetReferencedAssemblies())
- en: '{'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // load the assembly so we can read its details
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: // 加载程序集以便读取其详细信息
- en: Assembly a = Assembly.Load(name);
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Assembly a = Assembly.Load(name);
- en: // declare a variable to count the number of methods
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: // 声明一个变量来计算方法的数量
- en: int
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: methodCount = 0
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: methodCount = 0
- en: ;
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // loop through all the types in the assembly
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: // 遍历程序集中的所有类型
- en: foreach
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (TypeInfo t in
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: （TypeInfo t in
- en: a.DefinedTypes)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: a.DefinedTypes)
- en: '{'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // add up the counts of methods
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: //累加方法的计数
- en: methodCount += t.GetMethods().Count();
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: methodCount += t.GetMethods().Count();
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // output the count of types and their methods
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: //输出类型的计数和它们的方法
- en: Console.WriteLine(
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: '"{0:N0} types with {1:N0} methods in {2} assembly."'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '"{0:N0}个类型，{1:N0}个方法在{2}程序集中。"'
- en: ','
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: a.DefinedTypes.Count(),'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: a.DefinedTypes.Count(),'
- en: 'arg1: methodCount, arg2: name.Name);'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: methodCount, arg2: name.Name);'
- en: '}'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code. You will see the actual number of types and methods that are
    available to you in the simplest application when running on your OS. The number
    of types and methods displayed will be different depending on the operating system
    that you are using, as shown in the following outputs:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。当在您的操作系统上运行时，您将看到最简单应用程序中可用的类型和方法的实际数量。显示的类型和方法数量将取决于您使用的操作系统，如以下输出所示：
- en: '```cs'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // Output on Windows
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: // Windows上的输出
- en: 0 types with 0 methods in System.Runtime assembly.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 0个类型，System.Runtime程序集中有0个方法。
- en: 106 types with 1,126 methods in System.Linq assembly.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 106个类型，System.Linq程序集中有1,126个方法。
- en: 44 types with 645 methods in System.Console assembly.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 44个类型，System.Console程序集中有645个方法。
- en: // Output on macOS
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: // macOS上的输出
- en: 0 types with 0 methods in System.Runtime assembly.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 0个类型，System.Runtime程序集中有0个方法。
- en: 103 types with 1,094 methods in System.Linq assembly.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 103个类型，System.Linq程序集中有1,094个方法。
- en: 57 types with 701 methods in System.Console assembly.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 57个类型，System.Console程序集中有701个方法。
- en: '```'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Why does the `System.Runtime` assembly contain zero types? This assembly is
    special because it contains only **type-forwarders** rather than actual types.
    A type-forwarder represents a type that has been implemented outside of .NET or
    for some other advanced reason.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`System.Runtime`程序集中不包含任何类型？这个程序集很特殊，因为它只包含**类型转发器**而不是实际类型。类型转发器表示已在.NET之外或出于其他高级原因实现的类型。
- en: 'Add statements to the top of the file after importing the namespace to declare
    some variables, as shown highlighted in the following code:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入命名空间后，向文件顶部添加语句以声明一些变量，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Reflection;
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: System.Reflection;
- en: '**// declare some unused variables using types**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**//使用类型声明一些未使用的变量**'
- en: '**// in additional assemblies**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**//在其他程序集中**'
- en: '**System.Data.DataSet ds;**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Data.DataSet ds;**'
- en: '**HttpClient client;**'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**HttpClient client;**'
- en: '```'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: By declaring variables that use types in other assemblies, those assemblies
    are loaded with our application, which allows our code to see all the types and
    methods in them. The compiler will warn you that you have unused variables but
    that won't stop your code from running.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明使用其他程序集中的类型的变量，这些程序集将随我们的应用程序一起加载，从而使我们的代码能够看到其中的所有类型和方法。编译器会警告您有未使用的变量，但这不会阻止您的代码运行。
- en: 'Run the console application again and view the results, which should look similar
    to the following outputs:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序并查看结果，结果应该与以下输出类似：
- en: '```cs'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // Output on Windows
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: // Windows上的输出
- en: 0 types with 0 methods in System.Runtime assembly.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 0个类型，System.Runtime程序集中有0个方法。
- en: 383 types with 6,854 methods in System.Data.Common assembly.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 383个类型，System.Data.Common程序集中有6,854个方法。
- en: 456 types with 4,590 methods in System.Net.Http assembly.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 456个类型，System.Net.Http程序集中有4,590个方法。
- en: 106 types with 1,126 methods in System.Linq assembly.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 106个类型，System.Linq程序集中有1,126个方法。
- en: 44 types with 645 methods in System.Console assembly.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 44个类型，System.Console程序集中有645个方法。
- en: // Output on macOS
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: // macOS上的输出
- en: 0 types with 0 methods in System.Runtime assembly.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 0个类型，System.Runtime程序集中有0个方法。
- en: 376 types with 6,763 methods in System.Data.Common assembly.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 376个类型，System.Data.Common程序集中有6,763个方法。
- en: 522 types with 5,141 methods in System.Net.Http assembly.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 522个类型，System.Net.Http程序集中有5,141个方法。
- en: 103 types with 1,094 methods in System.Linq assembly.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 103个类型，System.Linq程序集中有1,094个方法。
- en: 57 types with 701 methods in System.Console assembly.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 57个类型，System.Console程序集中有701个方法。
- en: '```'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now, you have a better sense of why learning C# is a challenge, because there
    are so many types and methods to learn. Methods are only one category of a member
    that a type can have, and you and other programmers are constantly defining new
    types and members!
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您更清楚地了解了为什么学习C#是一项挑战，因为有太多类型和方法需要学习。方法只是类型可以拥有的成员的一类，您和其他程序员不断地定义新的类型和成员！
- en: Working with variables
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理变量
- en: All applications process data. Data comes in, data is processed, and then data
    goes out.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都会处理数据。数据进入，数据被处理，然后数据输出。
- en: Data usually comes into our program from files, databases, or user input, and
    it can be put temporarily into variables that will be stored in the memory of
    the running program. When the program ends, the data in memory is lost. Data is
    usually output to files and databases, or to the screen or a printer. When using
    variables, you should think about, firstly, how much space the variable takes
    in the memory, and, secondly, how fast it can be processed.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常从文件、数据库或用户输入中输入我们的程序，并且可以暂时放入变量中，这些变量将存储在运行程序的内存中。程序结束时，内存中的数据将丢失。数据通常输出到文件和数据库，或者输出到屏幕或打印机。在使用变量时，您应该首先考虑变量在内存中占用多少空间，其次是它可以被处理的速度。
- en: We control this by picking an appropriate type. You can think of simple common
    types such as `int` and `double` as being different-sized storage boxes, where
    a smaller box would take less memory but may not be as fast at being processed;
    for example, adding 16-bit numbers might not be processed as fast as adding 64-bit
    numbers on a 64-bit operating system. Some of these boxes may be stacked close
    by, and some may be thrown into a big heap further away.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择适当的类型来控制这一点。您可以将简单的常见类型（如`int`和`double`）视为不同大小的存储盒，较小的盒子将占用更少的内存，但处理速度可能不如较快；例如，在64位操作系统上，添加16位数字的速度可能不如添加64位数字的速度快。其中一些盒子可能靠得很近，而另一些可能被扔到远处的大堆中。
- en: Naming things and assigning values
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名事物和分配值
- en: 'There are naming conventions for things, and it is good practice to follow
    them, as shown in the following table:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 事物有命名约定，遵循它们是一个好习惯，如下表所示：
- en: '| Naming convention | Examples | Used for |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 命名约定 | 示例 | 用途 |'
- en: '| Camel case | `cost` , `orderDetail` , `dateOfBirth` | Local variables, private
    fields |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| Camel case | `cost` , `orderDetail` , `dateOfBirth` | 本地变量，私有字段 |'
- en: '| Title case aka Pascal case | `String` , `Int32` , `Cost` , `DateOfBirth`
    , `Run` | Types, non-private fields, and other members like methods |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| Title case aka Pascal case | `String` , `Int32` , `Cost` , `DateOfBirth`
    , `Run` | 类型，非私有字段和其他成员，如方法 |'
- en: '**Good Practice** : Following a consistent set of naming conventions will enable
    your code to be easily understood by other developers (and yourself in the future!).'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：遵循一致的命名约定将使其他开发人员（以及将来的自己）能够轻松理解您的代码。'
- en: 'The following code block shows an example of declaring a named local variable
    and assigning a value to it with the `=` symbol. You should note that you can
    output the name of a variable using a keyword introduced in C# 6.0, `nameof` :'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了声明命名本地变量并使用`=`符号为其赋值的示例。您应该注意，您可以使用C# 6.0中引入的关键字`nameof`输出变量的名称：
- en: '```cs'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // let the heightInMetres variable become equal to the value 1.88
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: // 让heightInMetres变量等于值1.88
- en: double
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 双
- en: heightInMetres = 1.88
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: heightInMetres = 1.88
- en: ;
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Console.WriteLine($"The variable
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"变量
- en: '{'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: nameof
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: nameof
- en: (heightInMetres)}
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (heightInMetres)}
- en: has the value
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 具有值
- en: '{heightInMetres}'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '{heightInMetres}'
- en: ."
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The message in double quotes in the preceding code wraps onto a second line
    because the width of a printed page is too narrow. When entering a statement like
    this in your code editor, type it all in a single line.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中双引号中的消息换行到第二行，因为打印页面的宽度太窄。在代码编辑器中输入这样的语句时，将其全部输入单行。
- en: Literal values
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字值
- en: When you assign to a variable, you often, but not always, assign a **literal**
    value. But what is a literal value? A literal is a notation that represents a
    fixed value. Data types have different notations for their literal values, and
    over the next few sections, you will see examples of using literal notation to
    assign values to variables.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为变量赋值时，通常但并非总是分配**文字**值。但是什么是文字值？文字是表示固定值的符号。数据类型有不同的符号表示它们的文字值，接下来的几节中，您将看到使用文字符号分配值给变量的示例。
- en: Storing text
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储文本
- en: For text, a single letter, such as an `A` , is stored as a `char` type.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，如`A`这样的单个字母存储为`char`类型。
- en: '**Good Practice** : Actually, it can be more complicated than that. Egyptian
    Hieroglyph A002 (U+13001) needs two `System.Char` values (known as surrogate pairs)
    to represent it: `\uD80C` and `\uDC01` . Do not always assume one `char` equals
    one letter or you could introduce weird bugs into your code.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：实际上，情况可能比这更复杂。埃及象形文字A002（U+13001）需要两个`System.Char`值（称为代理对）来表示它：`\uD80C`和`\uDC01`。不要总是假设一个`char`等于一个字母，否则可能会在代码中引入奇怪的错误。'
- en: 'A `char` is assigned using single quotes around the literal value, or assigning
    the return value of a fictitious function call, as shown in the following code:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`使用单引号括起来的文字值进行分配，或者分配虚构函数调用的返回值，如下面的代码所示：'
- en: '```cs'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: char
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: letter = 'A'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: letter = 'A'
- en: ; // assigning literal characters
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 分配文字字符
- en: char
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: digit = '1'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: digit = '1'
- en: ;
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: char
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: symbol = '$'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 = '$'
- en: ;
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: char
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: userChoice = GetSomeKeystroke(); // assigning from a fictitious function
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: userChoice = GetSomeKeystroke(); // 从一个虚构的函数赋值
- en: '```'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'For text, multiple letters, such as `Bob` , are stored as a `string` type and
    are assigned using double quotes around the literal value, or assigning the return
    value of a function call, as shown in the following code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，如`Bob`这样的多个字母存储为`string`类型，并使用双引号括起来的文字值或分配函数调用的返回值，如下面的代码所示：
- en: '```cs'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: firstName = "Bob"
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: firstName = "Bob"
- en: ; // assigning literal strings
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 分配文字字符串
- en: string
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: lastName = "Smith"
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: lastName = "Smith"
- en: ;
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: phoneNumber = "(215) 555-4256"
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: phoneNumber = "(215) 555-4256"
- en: ;
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // assigning a string returned from a fictitious function
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: // 分配从虚构函数返回的字符串
- en: string
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: 'address = GetAddressFromDatabase(id: 563'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 'address = GetAddressFromDatabase(id: 563'
- en: );
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding verbatim strings
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解逐字字符串
- en: 'When storing text in a `string` variable, you can include escape sequences,
    which represent special characters like tabs and new lines using a backslash,
    as shown in the following code:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 当将文本存储在`string`变量中时，可以包含转义序列，这些序列代表特殊字符，如制表符和换行符，使用反斜杠，如下面的代码所示：
- en: '```cs'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs```'
- en: string
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: fullNameWithTabSeparator = "Bob\tSmith"
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: fullNameWithTabSeparator = "Bob\tSmith"
- en: ;
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But what if you are storing the path to a file on Windows, and one of the folder
    names starts with a `T` , as shown in the following code?
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您要在Windows上存储文件的路径，并且其中一个文件夹名称以`T`开头，如下面的代码所示，会怎么样呢？
- en: '```cs'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: filePath = "C:\televisions\sony\bravia.txt"
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: filePath = "C:\televisions\sony\bravia.txt"
- en: ;
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The compiler will convert the `\t` into a tab character and you will get errors!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`\t`转换为制表符，并且您将收到错误！
- en: 'You must prefix with the `@` symbol to use a verbatim literal `string` , as
    shown in the following code:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用`@`符号前缀来使用逐字文字`string`，如下面的代码所示：
- en: '```cs'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: filePath = @"C:\televisions\sony\bravia.txt"
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: filePath = @"C:\televisions\sony\bravia.txt"
- en: ;
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To summarize:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: '**Literal string** : Characters enclosed in double-quote characters. They can
    use escape characters like `\t` for tab. To represent a backslash, use two: `\\`
    .'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文字字符串**：用双引号括起来的字符。它们可以使用转义字符，如制表符`\t`。要表示反斜杠，请使用两个：`\\`。'
- en: '**Verbatim string** : A literal string prefixed with `@` to disable escape
    characters so that a backslash is a backslash. It also allows the `string` value
    to span multiple lines because the white space characters are treated as themselves
    instead of instructions to the compiler.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐字字符串**：以`@`为前缀的文字字符串，以禁用转义字符，使反斜杠成为反斜杠。它还允许`string`值跨多行，因为空格字符被视为它们自己，而不是编译器的指令。'
- en: '**Interpolated string** : A literal string prefixed with `$` to enable embedded
    formatted variables. You will learn more about this later in this chapter.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值字符串**：以`$`为前缀的文字字符串，以启用嵌入格式化变量。您将在本章后面学到更多关于这个的知识。'
- en: Storing numbers
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储数字
- en: Numbers are data that we want to perform an arithmetic calculation on, for example,
    multiplying. A telephone number is not a number. To decide whether a variable
    should be stored as a number or not, ask yourself whether you need to perform
    arithmetic operations on the number or whether the number includes non-digit characters
    such as parentheses or hyphens to format the number, such as (414) 555-1234\.
    In this case, the number is a sequence of characters, so it should be stored as
    a `string` .
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是我们想要进行算术计算的数据，例如乘法。 电话号码不是一个数字。 要决定变量是否应存储为数字，请问自己是否需要对数字执行算术运算，或者数字是否包含非数字字符，例如括号或连字符，以格式化数字，例如(414)
    555-1234。 在这种情况下，数字是一系列字符，因此应将其存储为`string`。
- en: Numbers can be natural numbers, such as 42, used for counting (also called whole
    numbers); they can also be negative numbers, such as -42 (called integers); or,
    they can be real numbers, such as 3.9 (with a fractional part), which are called
    single- or double-precision floating-point numbers in computing.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以是自然数，例如42，用于计数（也称为整数）；它们也可以是负数，例如-42（称为整数）；或者，它们可以是实数，例如3.9（带有分数部分），在计算中称为单精度或双精度浮点数。
- en: 'Let''s explore numbers:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数字：
- en: 'Use your preferred code editor to add a new **Console Application** to the
    `Chapter02` workspace/solution named `Numbers` :'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将新的**控制台应用程序**添加到名为`Numbers`的`Chapter02`工作区/解决方案中：
- en: In Visual Studio Code, select `Numbers` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`Numbers`选择为活动的OmniSharp项目。 当看到弹出的警告消息说缺少所需资产时，点击**是**以添加它们。
- en: In Visual Studio, set the startup project to the current selection.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将启动项目设置为当前选择。
- en: 'In `Program.cs` , delete the existing code and then type statements to declare
    some number variables using various data types, as shown in the following code:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有代码，然后键入语句以使用各种数据类型声明一些数字变量，如下面的代码所示：
- en: '```cs'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // unsigned integer means positive whole number or 0
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: // 无符号整数表示正整数或0
- en: uint naturalNumber = 23
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: uint naturalNumber = 23
- en: ;
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // integer means negative or positive whole number or 0
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: // 整数表示负整数或正整数或0
- en: int
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: integerNumber = -23
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: integerNumber = -23
- en: ;
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // float means single-precision floating point
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: // 浮点数表示单精度浮点
- en: // F suffix makes it a float literal
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: // F后缀使其成为浮点文字
- en: float
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: float
- en: realNumber = 2.3F
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: realNumber = 2.3F
- en: ;
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // double means double-precision floating point
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: // double表示双精度浮点
- en: double
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: anotherRealNumber = 2.3
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: anotherRealNumber = 2.3
- en: ; // double literal
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 双精度文字
- en: '```'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Storing whole numbers
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储整数
- en: You might know that computers store everything as bits. The value of a bit is
    either 0 or 1\. This is called a **binary number system** . Humans use a **decimal
    number system** .
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道计算机将所有内容都存储为位。 位的值要么是0，要么是1。 这称为**二进制数系统**。 人类使用**十进制数系统**。
- en: The decimal number system, also known as Base 10, has 10 as its **base** , meaning
    there are ten digits, from 0 to 9\. Although it is the number base most commonly
    used by human civilizations, other number base systems are popular in science,
    engineering, and computing. The binary number system, also known as Base 2, has
    two as its base, meaning there are two digits, 0 and 1.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数系统，也称为基数10，其**基数**为10，意味着有十个数字，从0到9。 尽管它是人类文明中最常用的数字基数，但其他数字基数系统在科学，工程和计算中也很受欢迎。
    二进制数系统，也称为基数2，其基数为2，意味着有两个数字，0和1。
- en: 'The following table shows how computers store the decimal number 10\. Take
    note of the bits with the value 1 in the 8 and 2 columns; 8 + 2 = 10:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了计算机如何存储十进制数10。 注意值为1的位在8和2列中； 8 + 2 = 10：
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
- en: So, `10` in decimal is `00001010` in binary.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制中的`10`在二进制中是`00001010`。
- en: Improving legibility by using digit separators
  id: totrans-634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过使用数字分隔符来提高可读性
- en: Two of the improvements seen in C# 7.0 and later are the use of the underscore
    character `_` as a digit separator, and support for binary literals.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0及更高版本中看到的两项改进是使用下划线字符`_`作为数字分隔符，以及支持二进制文字。
- en: You can insert underscores anywhere into the digits of a number literal, including
    decimal, binary, or hexadecimal notation, to improve legibility.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在数字文字的数字中的任何位置插入下划线，包括十进制，二进制或十六进制表示法，以提高可读性。
- en: For example, you could write the value for 1 million in decimal notation, that
    is, Base 10, as `1_000_000` .
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将100万的值用十进制表示法写成`1_000_000`。
- en: 'You can even use the 2/3 grouping common in India: `10_00_000` .'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用印度常见的2/3分组：`10_00_000`。
- en: Using binary notation
  id: totrans-639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用二进制表示法
- en: To use binary notation, that is, Base 2, using only 1s and 0s, start the number
    literal with `0b` . To use hexadecimal notation, that is, Base 16, using 0 to
    9 and A to F, start the number literal with `0x` .
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用二进制表示法，即基数2，只使用1和0，从`0b`开始数字文字。 要使用十六进制表示法，即基数16，使用0到9和A到F，从`0x`开始数字文字。
- en: Exploring whole numbers
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索整数
- en: 'Let''s enter some code to see some examples:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入一些代码来看一些例子：
- en: 'In `Program.cs` , type statements to declare some number variables using underscore
    separators, as shown in the following code:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，键入语句以使用下划线分隔符声明一些数字变量，如下面的代码所示：
- en: '```cs'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // three variables that store the number 2 million
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: // 存储数字200万的三个变量
- en: int
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: decimalNotation = 2
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: decimalNotation = 2
- en: _000_000;
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: _000_000;
- en: int
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: binaryNotation = 0b
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: binaryNotation = 0b
- en: _0001_1110_1000_0100_1000_0000;
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: _0001_1110_1000_0100_1000_0000;
- en: int
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: hexadecimalNotation = 0
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: hexadecimalNotation = 0
- en: x_001E_8480;
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: x_001E_8480;
- en: // check the three variables have the same value
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: // 检查三个变量是否具有相同的值
- en: // both statements output true
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: // 两个语句都输出true
- en: Console.WriteLine($"
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{decimalNotation == binaryNotation}'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '{decimalNotation == binaryNotation}'
- en: '"'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine(
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: $"
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{decimalNotation == hexadecimalNotation}'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '{decimalNotation == hexadecimalNotation}'
- en: '"'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the result is that all three numbers are the same, as
    shown in the following output:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果是所有三个数字都相同，如下面的输出所示：
- en: '```cs'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'True'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'True'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '```'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Computers can always exactly represent integers using the `int` type or one
    of its sibling types, such as `long` and `short` .
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机总是可以使用`int`类型或其兄弟类型（如`long`和`short`）精确表示整数。
- en: Storing real numbers
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储实数
- en: Computers cannot always represent real, aka decimal or non-integer, numbers
    precisely. The `float` and `double` types store real numbers using single- and
    double-precision floating points.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不能总是精确地表示实数，也就是十进制或非整数。`float` 和 `double` 类型使用单精度和双精度浮点数存储实数。
- en: Most programming languages implement the IEEE Standard for Floating-Point Arithmetic.
    IEEE 754 is a technical standard for floating-point arithmetic established in
    1985 by the **Institute of Electrical and Electronics Engineers** (**IEEE** ).
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言实现了IEEE浮点算术标准。IEEE 754是1985年由**电气和电子工程师协会**（**IEEE**）制定的浮点算术技术标准。
- en: The following table shows a simplification of how a computer represents the
    number `12.75` in binary notation. Note the bits with the value `1` in the 8,
    4, ½, and ¼ columns.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了计算机如何以二进制表示数字`12.75`的简化。请注意，8、4、½和¼列中的值为`1`的位。
- en: 8 + 4 + ½ + ¼ = 12¾ = 12.75.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 8 + 4 + ½ + ¼ = 12¾ = 12.75。
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 |'
- en: '| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |'
- en: So, `12.75` in decimal is `00001100.1100` in binary. As you can see, the number
    `12.75` can be exactly represented using bits. However, some numbers can't, something
    that we'll be exploring shortly.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制中的`12.75`是二进制中的`00001100.1100`。正如您所看到的，数字`12.75`可以用位数精确表示。然而，有些数字不能，这是我们将要探索的内容。
- en: Writing code to explore number sizes
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写代码来探索数字大小
- en: 'C# has an operator named `sizeof()` that returns the number of bytes that a
    type uses in memory. Some types have members named `MinValue` and `MaxValue` ,
    which return the minimum and maximum values that can be stored in a variable of
    that type. We are now going to use these features to create a console application
    to explore number types:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: C#有一个名为`sizeof()`的运算符，它返回类型在内存中使用的字节数。一些类型有名为`MinValue`和`MaxValue`的成员，它们返回该类型的变量中可以存储的最小值和最大值。我们现在将使用这些特性创建一个控制台应用程序来探索数字类型：
- en: 'In `Program.cs` , type statements to show the size of three number data types,
    as shown in the following code:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句以显示三种数字数据类型的大小，如下面的代码所示：
- en: '```cs'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Console.WriteLine($"int uses
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"int 使用
- en: '{'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: sizeof
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof
- en: (
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: )}
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: bytes and can store numbers in the range
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 字节，并且可以存储范围内的数字
- en: '{'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: .MinValue:N0}
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: .MinValue:N0}
- en: to
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '{'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: .MaxValue:N0}
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue:N0}
- en: ."
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine($"double uses
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"double 使用
- en: '{'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: sizeof
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof
- en: (
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: double
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: )}
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: bytes and can store numbers in the range
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 字节，并且可以存储范围内的数字
- en: '{'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: double
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: .MinValue:N0}
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: .MinValue:N0}
- en: to
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '{'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: double
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: .MaxValue:N0}
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue:N0}
- en: ."
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine($"decimal uses
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"decimal 使用
- en: '{'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: sizeof
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof
- en: (
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: decimal
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: )}
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: bytes and can store numbers in the range
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 字节，并且可以存储范围内的数字
- en: '{'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: decimal
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制
- en: .MinValue:N0}
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: .MinValue:N0}
- en: to
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '{'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: decimal
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: .MaxValue:N0}
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue:N0}
- en: ."
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The width of the printed pages in this book makes the `string` values (in double
    quotes) wrap over multiple lines. You must type them on a single line, or you
    will get compile errors.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中打印页面的宽度使得`string`值（用双引号括起来）会跨越多行。您必须将它们输入到一行中，否则会出现编译错误。
- en: Run the code and view the output, as shown in *Figure 2.3* :![](img/Image00032.jpg)
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出，如*图2.3*所示：![](img/Image00032.jpg)
- en: 'Figure 2.3: Size and range information for common number data types'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：常见数字数据类型的大小和范围信息
- en: An `int` variable uses four bytes of memory and can store positive or negative
    numbers up to about 2 billion. A `double` variable uses eight bytes of memory
    and can store much bigger values! A `decimal` variable uses 16 bytes of memory
    and can store big numbers, but not as big as a `double` type.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`变量使用四个字节的内存，可以存储正数或负数，最大约为20亿。`double`变量使用八个字节的内存，可以存储更大的值！`decimal`变量使用16个字节的内存，可以存储大数字，但不及`double`类型大。'
- en: But you may be asking yourself, why might a `double` variable be able to store
    bigger numbers than a `decimal` variable, yet it's only using half the space in
    memory? Well, let's now find out!
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可能会问自己，为什么`double`变量能够存储比`decimal`变量更大的数字，但是它只使用了一半的内存空间？好吧，现在让我们找出答案！
- en: Comparing double and decimal types
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较double和decimal类型
- en: 'You will now write some code to compare `double` and `decimal` values. Although
    it isn''t hard to follow, don''t worry about understanding the syntax right now:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将编写一些代码来比较`double`和`decimal`值。虽然不难理解，但现在不用担心理解语法：
- en: 'Type statements to declare two `double` variables, add them together and compare
    them to the expected result, and write the result to the console, as shown in
    the following code:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型语句声明两个`double`变量，将它们相加并将结果与预期结果进行比较，并将结果写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Console.WriteLine("Using doubles:"
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("使用双精度："
- en: );
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: );}
- en: double
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: a = 0.1
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: a = 0.1
- en: ;
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: double
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: b = 0.2
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: b = 0.2
- en: ;
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: if
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (a + b == 0.3
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: (a + b == 0.3
- en: )
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine($"
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{a}'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: +
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{b}'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: equals
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: '{'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '0.3'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3'
- en: '}'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine($"
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{a}'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: +
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{b}'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: does NOT equal
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于
- en: '{'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '0.3'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3'
- en: '}'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Using doubles:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双精度：
- en: 0.1 + 0.2 does NOT equal 0.3
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 0.1 + 0.2 不等于 0.3
- en: '```'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In locales that use a comma for the decimal separator the result will look
    slightly different, as shown in the following output:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用逗号作为小数分隔符的区域，结果会略有不同，如下面的输出所示：
- en: '```cs'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 0,1 + 0,2 does NOT equal 0,3
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 0,1 + 0,2 不等于 0,3
- en: '```'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `double` type is not guaranteed to be accurate because some numbers like
    `0.1` literally cannot be represented as floating-point values.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型不能保证精确，因为一些数字如`0.1`在浮点数值中无法准确表示。'
- en: As a rule of thumb, you should only use `double` when accuracy, especially when
    comparing the equality of two numbers, is not important. An example of this may
    be when you're measuring a person's height and you will only compare values using
    greater than or less than, but never equals.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，只有在精度不重要时才应该使用`double`。一个例子是当你测量一个人的身高，你只会使用大于或小于来比较值，但永远不会使用等于。
- en: The problem with the preceding code is illustrated by how the computer stores
    the number `0.1` , or multiples of it. To represent `0.1` in binary, the computer
    stores 1 in the 1/16 column, 1 in the 1/32 column, 1 in the 1/256 column, 1 in
    the 1/512 column, and so on.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码问题在于计算机如何存储数字`0.1`或它的倍数。为了表示二进制中的`0.1`，计算机在1/16列中存储1，在1/32列中存储1，在1/256列中存储1，在1/512列中存储1，依此类推。
- en: 'The number `0.1` in decimal is `0.00011001100110011` … in binary, repeating
    forever:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制中的数字`0.1`在二进制中是`0.00011001100110011`…一直重复下去：
- en: '| 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512
    | 1/1024 | 1/2048 |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512
    | 1/1024 | 1/2048 |'
- en: '| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |'
- en: '**Good Practice** : Never compare `double` values using `==` . During the First
    Gulf War, an American Patriot missile battery used `double` values in its calculations.
    The inaccuracy caused it to fail to track and intercept an incoming Iraqi Scud
    missile, and 28 soldiers were killed; you can read about this at [https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html)
    .'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：永远不要使用`==`来比较`double`值。在第一次海湾战争中，一支美国爱国者导弹连使用`double`值进行计算。这种不准确性导致它未能跟踪和拦截一枚来袭的伊拉克飞毛腿导弹，造成了28名士兵死亡；你可以在[https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html)上阅读相关内容。'
- en: Copy and paste the statements that you wrote before (that used the `double`
    variables).
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴之前写的使用`double`变量的语句。
- en: 'Modify the statements to use `decimal` and rename the variables to `c` and
    `d` , as shown in the following code:'
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句以使用`decimal`并将变量重命名为`c`和`d`，如下面的代码所示：
- en: '```cs'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Console.WriteLine("Using decimals:"
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("使用小数："
- en: );
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: decimal
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: c = 0.1
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: c = 0.1
- en: M; // M suffix means a decimal literal value
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: M; // M后缀表示十进制字面值
- en: decimal
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: d = 0.2
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: d = 0.2
- en: M;
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: M;
- en: if
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (c + d == 0.3
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: (c + d == 0.3
- en: M)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: M)
- en: '{'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine($"
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{c}'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '{c}'
- en: +
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{d}'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '{d}'
- en: equals
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: '{'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '0.3'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3'
- en: M}
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: M}
- en: '"'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine($"
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{c}'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '{c}'
- en: +
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{d}'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '{d}'
- en: does NOT equal
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于
- en: '{'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '0.3'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3'
- en: M}
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: M}
- en: '"'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-836
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Using decimals:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小数：
- en: 0.1 + 0.2 equals 0.3
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 0.1 + 0.2 等于 0.3
- en: '```'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `decimal` type is accurate because it stores the number as a large integer
    and shifts the decimal point. For example, `0.1` is stored as `1` , with a note
    to shift the decimal point one place to the left. `12.75` is stored as `1275`
    , with a note to shift the decimal point two places to the left.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`类型是精确的，因为它将数字存储为一个大整数，并移动小数点。例如，`0.1`被存储为`1`，并注明将小数点向左移动一位。`12.75`被存储为`1275`，并注明将小数点向左移动两位。'
- en: '**Good Practice** : Use `int` for whole numbers. Use `double` for real numbers
    that will not be compared for equality to other values; it is okay to compare
    `double` values being less than or greater than, and so on. Use `decimal` for
    money, CAD drawings, general engineering, and wherever the accuracy of a real
    number is important.'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：对于整数使用`int`。对于不需要与其他值相等比较的实数使用`double`；可以将`double`值进行小于或大于等比较。对于货币、CAD图纸、一般工程等需要实数精度的地方使用`decimal`。'
- en: 'The `double` type has some useful special values: `double.NaN` represents not-a-number
    (for example, the result of dividing by zero), `double.Epsilon` represents the
    smallest positive number that can be stored in a `double` , and `double.PositiveInfinity`
    and `double.NegativeInfinity` represent infinitely large positive and negative
    values.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型有一些有用的特殊值：`double.NaN`表示非数字（例如除以零的结果），`double.Epsilon`表示可以存储在`double`中的最小正数，`double.PositiveInfinity`和`double.NegativeInfinity`表示无限大的正数和负数。'
- en: Storing Booleans
  id: totrans-844
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储布尔值
- en: 'Booleans can only contain one of the two literal values `true` or `false` ,
    as shown in the following code:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值只能包含两个字面值`true`或`false`，如下面的代码所示：
- en: '```cs'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bool
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: happy = true
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: happy = true
- en: ;
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: bool
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: sad = false
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: sad = false
- en: ;
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: They are most commonly used to branch and loop. You don't need to fully understand
    them yet, as they are covered more in *Chapter 3* , *Controlling Flow, Converting
    Types, and Handling Exceptions* .
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最常用于分支和循环。你现在不需要完全理解它们，因为它们在*第3章*，*控制流、类型转换和异常处理*中有更详细的介绍。
- en: Storing any type of object
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储任何类型的对象
- en: 'There is a special type named `object` that can store any type of data, but
    its flexibility comes at the cost of messier code and possibly poor performance.
    Because of those two reasons, you should avoid it whenever possible. The following
    steps show how to use object types if you need to use them:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型叫做`object`，它可以存储任何类型的数据，但它的灵活性是以代码混乱和可能的性能不佳为代价的。因为这两个原因，尽可能避免使用它。以下步骤展示了如何在需要时使用对象类型：
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Variables` .
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器向`Chapter02`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`Variables`。
- en: In Visual Studio Code, select `Variables` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`Variables`作为活动的OmniSharp项目。当看到弹出的警告消息说缺少所需的资产时，点击**是**以添加它们。
- en: 'In `Program.cs` , type statements to declare and use some variables using the
    `object` type, as shown in the following code:'
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句来声明和使用一些使用`object`类型的变量，如下面的代码所示：
- en: '```cs'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: object
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: height = 1.88
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: height = 1.88
- en: ; // storing a double in an object
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 在对象中存储一个双精度值
- en: object
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: name = "Amir"
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: name = "Amir"
- en: ; // storing a string in an object
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 在对象中存储一个字符串
- en: Console.WriteLine($"
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{name}'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '{name}'
- en: is
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '{height}'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '{height}'
- en: metres tall."
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 米高。"
- en: );
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: int
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: length1 = name.Length; // gives compile error!
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: length1 = name.Length; // 编译错误！
- en: int
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: length2 = ((string
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: length2 = ((string
- en: )name).Length; // tell compiler it is a string
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: )name).Length; // 告诉编译器它是一个字符串
- en: Console.WriteLine($"
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{name}'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '{name}'
- en: has
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{length2}'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '{length2}'
- en: characters."
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 字符。"
- en: );
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Run the code and note that the fourth statement cannot compile because the data
    type of the `name` variable is not known by the compiler, as shown in *Figure
    2.4* :![](img/Image00033.jpg)
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意第四个语句无法编译，因为编译器不知道`name`变量的数据类型，如*图2.4*所示：![](img/Image00033.jpg)
- en: 'Figure 2.4: The object type does not have a Length property'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：对象类型没有Length属性
- en: Add comment double slashes to the beginning of the statement that cannot compile
    to "comment out" the statement to make it inactive.
  id: totrans-887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无法编译的语句开头添加双斜杠注释以"注释掉"该语句，使其无效。
- en: 'Run the code again and note that the compiler can access the length of a `string`
    if the programmer explicitly tells the compiler that the `object` variable contains
    a `string` by prefixing with a cast expression like `(string)` , as shown in the
    following output:'
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意，如果程序员显式告诉编译器`object`变量包含一个`string`，则编译器可以访问`string`的长度，方法是使用前缀为`(string)`的转换表达式，如下面的输出所示：
- en: '```cs'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Amir is 1.88 metres tall.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: Amir身高1.88米。
- en: Amir has 4 characters.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: Amir有4个字符。
- en: '```'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `object` type has been available since the first version of C#, but C# 2.0
    and later have a better alternative called **generics** , which we will cover
    in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* , which will
    provide us with the flexibility we want, but without the performance overhead.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型自第一个C#版本以来就可用，但C# 2.0及更高版本有一个更好的替代方案，称为**泛型**，我们将在*第6章*，*实现接口和继承类*中介绍，这将为我们提供所需的灵活性，但没有性能开销。'
- en: Storing dynamic types
  id: totrans-894
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储动态类型
- en: 'There is another special type named `dynamic` that can also store any type
    of data, but even more than `object` , its flexibility comes at the cost of performance.
    The `dynamic` keyword was introduced in C# 4.0\. However, unlike `object` , the
    value stored in the variable can have its members invoked without an explicit
    cast. Let''s make use of a `dynamic` type:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊类型叫做`dynamic`，它也可以存储任何类型的数据，但与`object`相比，它的灵活性更多，但性能更差。`dynamic`关键字是在C#
    4.0中引入的。然而，与`object`不同，存储在变量中的值可以在没有显式转换的情况下调用其成员。让我们使用`dynamic`类型：
- en: 'Add statements to declare a `dynamic` variable and then assign a `string` literal
    value, and then an integer value, and then an array of integer values, as shown
    in the following code:'
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明一个`dynamic`变量，然后分配一个`string`字面值，然后是一个整数值，然后是一个整数值数组，如下面的代码所示：
- en: '```cs'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // storing a string in a dynamic object
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: // 在动态对象中存储一个字符串
- en: // string has a Length property
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: // string有一个Length属性
- en: dynamic
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: dynamic
- en: something = "Ahmed"
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: something = "Ahmed"
- en: ;
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // int does not have a Length property
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: // int没有Length属性
- en: // something = 12;
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: // something = 12;
- en: // an array of any type has a Length property
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: // 任何类型的数组都有Length属性
- en: // something = new[] { 3, 5, 7 };
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: // something = new[] { 3, 5, 7 };
- en: '```'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add a statement to output the length of the `dynamic` variable, as shown in
    the following code:'
  id: totrans-908
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个语句来输出`dynamic`变量的长度，如下面的代码所示：
- en: '```cs'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // this compiles but would throw an exception at run-time
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: // 这样编译，但会在运行时引发异常
- en: // if you later store a data type that does not have a
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果以后存储了一个没有的数据类型
- en: // property named Length
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: // 名为Length的属性
- en: Console.WriteLine($"Length is
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"长度为
- en: '{something.Length}'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '{something.Length}'
- en: '"'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note it works because a `string` value does have a `Length`
    property, as shown in the following output:'
  id: totrans-918
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它可以工作，因为`string`值确实有一个`Length`属性，如下面的输出所示：
- en: '```cs'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Length is 5
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为5
- en: '```'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Uncomment the statement that assigns an `int` value.
  id: totrans-922
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释分配`int`值的语句。
- en: 'Run the code and note the runtime error because `int` does not have a `Length`
    property, as shown in the following output:'
  id: totrans-923
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意运行时错误，因为`int`没有`Length`属性，如下面的输出所示：
- en: '```cs'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:
    ''int'' does not contain a definition for ''Length'''
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '未处理的异常。Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: ''int''不包含''Length''的定义'
- en: '```'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Uncomment the statement that assigns the array.
  id: totrans-927
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释分配数组的语句。
- en: 'Run the code and note the output because an array of three `int` values does
    have a `Length` property, as shown in the following output:'
  id: totrans-928
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意输出，因为三个`int`值的数组确实有一个`Length`属性，如下面的输出所示：
- en: '```cs'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Length is 3
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为3
- en: '```'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: One limitation of `dynamic` is that code editors cannot show IntelliSense to
    help you write the code. This is because the compiler cannot check what the type
    is during build time. Instead, the CLR checks for the member at runtime and throws
    an exception if it is missing.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`的一个限制是代码编辑器无法显示智能感知以帮助您编写代码。这是因为编译器无法在构建时检查类型是什么。相反，CLR在运行时检查成员并在缺失时引发异常。'
- en: Exceptions are a way to indicate that something has gone wrong at runtime. You
    will learn more about them and how to handle them in *Chapter 3* , *Controlling
    Flow, Converting Types, and Handling Exceptions* .
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是指示在运行时出现了问题的一种方式。您将在*第3章*，*控制流程，转换类型和处理异常*中学到更多关于它们以及如何处理它们。
- en: Declaring local variables
  id: totrans-934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明局部变量
- en: Local variables are declared inside methods, and they only exist during the
    execution of that method, and once the method returns, the memory allocated to
    any local variables is released.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在方法内声明，它们只在该方法执行期间存在，一旦方法返回，为任何局部变量分配的内存将被释放。
- en: Strictly speaking, value types are released while reference types must wait
    for a garbage collection. You will learn about the difference between value types
    and reference types in *Chapter 6* , *Implementing Interfaces and Inheriting Classes*
    .
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，值类型会被释放，而引用类型必须等待垃圾回收。您将在*第6章*，*实现接口和继承类*中了解值类型和引用类型之间的区别。
- en: Specifying the type of a local variable
  id: totrans-937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定本地变量的类型
- en: 'Let''s explore local variables declared with specific types and using type
    inference:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用特定类型声明的本地变量和使用类型推断：
- en: 'Type statements to declare and assign values to some local variables using
    specific types, as shown in the following code:'
  id: totrans-939
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特定类型的语句声明并为一些本地变量分配值，如下面的代码所示：
- en: '```cs'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: population = 66
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: population = 66
- en: _000_000; // 66 million in UK
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: _000_000; // 66 million in UK
- en: double
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: weight = 1.88
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: weight = 1.88
- en: ; // in kilograms
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: ; // in kilograms
- en: decimal
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: price = 4.99
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: price = 4.99
- en: M; // in pounds sterling
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: M; // in pounds sterling
- en: string
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: fruit = "Apples"
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: fruit = "Apples"
- en: ; // strings use double-quotes
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: ; // strings use double-quotes
- en: char
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: char
- en: letter = 'Z'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: letter = 'Z'
- en: ; // chars use single-quotes
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: ; // chars use single-quotes
- en: bool
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: happy = true
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: happy = true
- en: ; // Booleans have value of true or false
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 布尔值为true或false
- en: '```'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Depending on your code editor and color scheme, it will show green squiggles
    under each of the variable names and lighten their text color to warn you that
    the variable is assigned but its value is never used.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的代码编辑器和颜色方案，它将在每个变量名称下显示绿色波浪线，并将它们的文本颜色变浅，以警告您变量被赋值，但其值从未被使用。
- en: Inferring the type of a local variable
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断本地变量的类型
- en: You can use the `var` keyword to declare local variables. The compiler will
    infer the type from the value that you assign after the assignment operator, `=`
    .
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`var`关键字声明本地变量。编译器将从赋值运算符`=`后分配的值中推断类型。
- en: 'A literal number without a decimal point is inferred as an `int` variable,
    that is, unless you add a suffix, as described in the following list:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 没有小数点的文字数字被推断为`int`变量，也就是说，除非你添加一个后缀，如下面的列表所述：
- en: '`L` : infers `long`'
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L`：推断`long`'
- en: '`UL` : infers `ulong`'
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UL`：推断`ulong`'
- en: '`M` : infers `decimal`'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`：推断`decimal`'
- en: '`D` : infers `double`'
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`：推断`double`'
- en: '`F` : infers `float`'
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`：推断`float`'
- en: A literal number with a decimal point is inferred as `double` unless you add
    the `M` suffix, in which case, it infers a `decimal` variable, or the `F` suffix,
    in which case, it infers a `float` variable.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 具有小数点的文字数字被推断为`double`，除非您添加`M`后缀，此时它推断为`decimal`变量，或者添加`F`后缀，此时它推断为`float`变量。
- en: 'Double quotes indicate a `string` variable, single quotes indicate a `char`
    variable, and the `true` and `false` values infer a `bool` type:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号表示`string`变量，单引号表示`char`变量，`true`和`false`值推断为`bool`类型：
- en: 'Modify the previous statements to use `var` , as shown in the following code:'
  id: totrans-971
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前面的语句以使用`var`，如下面的代码所示：
- en: '```cs'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: population = 66
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: population = 66
- en: _000_000; // 66 million in UK
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: _000_000; // 66 million in UK
- en: var
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: weight = 1.88
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: weight = 1.88
- en: ; // in kilograms
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: ; // in kilograms
- en: var
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: price = 4.99
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: price = 4.99
- en: M; // in pounds sterling
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: M; // in pounds sterling
- en: var
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: fruit = "Apples"
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: fruit = "Apples"
- en: ; // strings use double-quotes
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: ; // strings use double-quotes
- en: var
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: letter = 'Z'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: letter = 'Z'
- en: ; // chars use single-quotes
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: ; // chars use single-quotes
- en: var
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: happy = true
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: happy = true
- en: ; // Booleans have value of true or false
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 布尔值为true或false
- en: '```'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Hover your mouse over each of the `var` keywords and note that your code editor
    shows a tooltip with information about the type that has been inferred.
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在每个`var`关键字上，并注意您的代码编辑器显示了有关已推断类型的信息的工具提示。
- en: 'At the top of the class file, import the namespace for working with XML to
    enable us to declare some variables using types in that namespace, as shown in
    the following code:'
  id: totrans-993
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类文件的顶部，导入用于处理XML的命名空间，以便我们可以使用该命名空间中的类型声明一些变量，如下面的代码所示：```
- en: '```cs'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: System.Xml;
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: System.Xml;
- en: '```'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : If you are using .NET Interactive Notebooks, then add `using`
    statements in a separate code cell above the code cell where you write the main
    code. Then click **Execute Cell** to ensure the namespaces are imported. They
    will then be available in subsequent code cells.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您正在使用.NET交互式笔记本，则在您编写主要代码的代码单元格上方的单独代码单元格中添加`using`语句。然后单击**执行单元格**以确保导入了命名空间。然后它们将在随后的代码单元格中可用。'
- en: 'Under the previous statements, add statements to create some new objects, as
    shown in the following code:'
  id: totrans-999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的语句下，添加语句以创建一些新对象，如下面的代码所示：
- en: '```cs'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // good use of var because it avoids the repeated type
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用var的良好用法，因为它避免了重复的类型
- en: // as shown in the more verbose second statement
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: // 如更冗长的第二个语句所示
- en: var
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: xml1 = new
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: xml1 = new
- en: XmlDocument();
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: XmlDocument();
- en: XmlDocument xml2 = new
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: XmlDocument xml2 = new
- en: XmlDocument();
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: XmlDocument();
- en: // bad use of var because we cannot tell the type, so we
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用var的不良用法，因为我们无法确定类型，所以我们
- en: // should use a specific type declaration as shown in
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: // 应该使用特定类型声明，如下所示
- en: // the second statement
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: // 第二个语句
- en: var
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: file1 = File.CreateText("something1.txt"
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: file1 = File.CreateText("something1.txt"
- en: );
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: StreamWriter file2 = File.CreateText("something2.txt"
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: StreamWriter file2 = File.CreateText("something2.txt"
- en: );
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Although using `var` is convenient, some developers avoid
    using it, to make it easier for a code reader to understand the types in use.
    Personally, I use it only when the type is obvious. For example, in the preceding
    code statements, the first statement is just as clear as the second in stating
    what the type of the `xml` variables are, but it is shorter. However, the third
    statement isn''t clear in showing the type of the `file` variable, so the fourth
    is better because it shows that the type is `StreamWriter` . If in doubt, spell
    it out!'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：虽然使用`var`很方便，但一些开发人员避免使用它，以使代码读者更容易理解所使用的类型。就个人而言，我只在类型明显时使用它。例如，在前面的代码语句中，第一个语句和第二个语句一样清楚地说明了`xml`变量的类型，但它更短。但是，第三个语句并没有清楚地显示`file`变量的类型，因此第四个语句更好，因为它显示了类型是`StreamWriter`。如果有疑问，就把它写出来！'
- en: Using target-typed new to instantiate objects
  id: totrans-1018
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用目标类型的新实例化对象
- en: 'With C# 9, Microsoft introduced another syntax for instantiating objects known
    as **target-typed new** . When instantiating an object, you can specify the type
    first and then use `new` without repeating the type, as shown in the following
    code:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C# 9，Microsoft引入了另一种用于实例化对象的语法，称为**目标类型的新功能**。在实例化对象时，您可以首先指定类型，然后使用`new`而不重复类型，如下所示：
- en: '```cs'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: XmlDocument xml3 = new
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: XmlDocument xml3 = new
- en: (); // target-typed new in C# 9 or later
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: (); // C# 9或更高版本中的目标类型的新功能
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you have a type with a field or property that needs to be set, then the
    type can be inferred, as shown in the following code:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个需要设置字段或属性的类型，则可以推断类型，如下所示：
- en: '```cs'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: class
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: '{'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DateTime BirthDate;
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime BirthDate;
- en: '}'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Person kim = new
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: Person kim = new
- en: ();
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: kim.BirthDate = new
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: kim.BirthDate = new
- en: (1967
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: (1967
- en: ', 12'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: ', 12'
- en: ', 26'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: ', 26'
- en: '); // instead of: new DateTime(1967, 12, 26)'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 而不是：new DateTime(1967, 12, 26)
- en: '```'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Use target-typed new to instantiate objects unless you
    must use a pre-version 9 C# compiler. I have used target-typed new throughout
    the rest of this book. Please let me know if you spot any cases that I missed!'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：除非必须使用早于版本9的C#编译器，否则使用目标类型的新功能来实例化对象。我在本书的其余部分中都使用了目标类型的新功能。如果您发现我错过了任何情况，请告诉我！'
- en: Getting and setting the default values for types
  id: totrans-1041
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置类型的默认值
- en: Most of the primitive types except `string` are **value types** , which means
    that they must have a value. You can determine the default value of a type by
    using the `default()` operator and passing the type as a parameter. You can assign
    the default value of a type by using the `default` keyword.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`string`之外，大多数基本类型都是**值类型**，这意味着它们必须有一个值。您可以使用`default()`运算符并将类型作为参数来确定类型的默认值。您可以使用`default`关键字来分配类型的默认值。
- en: The `string` type is a **reference type** . This means that `string` variables
    contain the memory address of a value, not the value itself. A reference type
    variable can have a `null` value, which is a literal that indicates that the variable
    does not reference anything (yet). `null` is the default for all reference types.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类型是**引用类型**。这意味着`string`变量包含值的内存地址，而不是值本身。引用类型变量可以有一个`null`值，这是一个字面量，表示变量尚未引用任何内容。`null`是所有引用类型的默认值。'
- en: You'll learn more about value types and reference types in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第6章*，*实现接口和继承类*中更多地了解值类型和引用类型。
- en: 'Let''s explore default values:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索默认值：
- en: 'Add statements to show the default values of an `int` , `bool` , `DateTime`
    , and `string` , as shown in the following code:'
  id: totrans-1046
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以显示`int`，`bool`，`DateTime`和`string`的默认值，如下所示：
- en: '```cs'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Console.WriteLine($"default(int) =
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"默认(int) =
- en: '{'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: default
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值
- en: (
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: )}
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: '"'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine($"default(bool) =
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"默认(bool) =
- en: '{'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: default
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值
- en: (
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: bool
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: )}
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: '"'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine($"default(DateTime) =
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"默认(DateTime) =
- en: '{'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: default
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: (DateTime)}
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: (DateTime)}
- en: '"'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine($"default(string) =
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"默认(string) =
- en: '{'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: default
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: (
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: )}
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: '"'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, noting that your output for the date and
    time might be formatted differently if you are not running it in the UK, and that
    `null` values output as an empty `string` , as shown in the following output:'
  id: totrans-1079
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意如果您不是在英国运行代码，日期和时间的输出可能会有不同的格式，并且`null`值会输出为空字符串，如下所示：
- en: '```cs'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: default(int) = 0
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 默认(int) = 0
- en: default(bool) = False
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 默认(bool) = False
- en: default(DateTime) = 01/01/0001 00:00:00
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 默认(DateTime) = 01/01/0001 00:00:00
- en: default(string) =
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 默认(string) =
- en: '```'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to declare a number, assign a value, and then reset it to its
    default value, as shown in the following code:'
  id: totrans-1086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明一个数字，赋值，然后将其重置为默认值，如下所示：
- en: '```cs'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: number = 13
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: number = 13
- en: ;
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'Console.WriteLine($"number has been set to:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"数字已设置为：
- en: '{number}'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '{number}'
- en: '"'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: number = default
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: number = 默认值
- en: ;
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'Console.WriteLine($"number has been reset to its default:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"数字已重置为默认值：
- en: '{number}'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '{number}'
- en: '"'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'number has been set to: 13'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 数字已设置为：13
- en: 'number has been reset to its default: 0'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 数字已重置为默认值：0
- en: '```'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Storing multiple values in an array
  id: totrans-1107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中存储多个值
- en: When you need to store multiple values of the same type, you can declare an
    **array** . For example, you may do this when you need to store four names in
    a `string` array.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要存储相同类型的多个值时，可以声明一个**数组**。例如，当您需要在`string`数组中存储四个名称时，可以这样做。
- en: The code that you will write next will allocate memory for an array for storing
    four `string` values. It will then store `string` values at index positions 0
    to 3 (arrays usually have a lower bound of zero, so the index of the last item
    is one less than the length of the array).
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要编写的代码将为存储四个`string`值的数组分配内存。然后，它将在索引位置0到3存储`string`值（数组通常具有零的下限，因此最后一项的索引比数组的长度少1）。
- en: '**Good Practice** : Do not assume that all arrays count from zero. The most
    common type of array in .NET is an **szArray** , a single-dimension zero-indexed
    array, and these use the normal `[]` syntax. But .NET also has **mdArray** , a
    multi-dimensional array, and they do not have to have a lower bound of zero. These
    are rarely used but you should know they exist.'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：不要假设所有数组都从零开始计数。.NET中最常见的数组类型是**szArray**，即单维零索引数组，它们使用正常的`[]`语法。但.NET还有**mdArray**，即多维数组，它们不必具有零的下限。这些很少使用，但您应该知道它们的存在。'
- en: Finally, it will loop through each item in the array using a `for` statement,
    something that we will cover in more detail in *Chapter 3* , *Controlling Flow,
    Converting Types, and Handling Exceptions* .
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将使用`for`语句循环遍历数组中的每个项目，这是我们将在*第3章*，*控制流，类型转换和处理异常*中更详细地介绍的内容。
- en: 'Let''s look at how to use an array:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用数组：
- en: 'Type statements to declare and use an array of `string` values, as shown in
    the following code:'
  id: totrans-1113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明和使用一个`string`值数组的类型语句，如下面的代码所示：
- en: '```cs'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '[] names; // can reference any size array of strings'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '[] names; // 可引用任何大小的字符串数组'
- en: // allocating memory for four strings in an array
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: // 在数组中为四个字符串分配内存
- en: names = new
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: names = new
- en: string
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '[4'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '[4'
- en: '];'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: // storing items at index positions
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: // 在索引位置存储项目
- en: names[0
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: names[0
- en: '] = "Kate"'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '] = "Kate"'
- en: ;
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: names[1
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: names[1
- en: '] = "Jack"'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '] = "Jack"'
- en: ;
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: names[2
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: names[2
- en: '] = "Rebecca"'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '] = "Rebecca"'
- en: ;
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: names[3
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: names[3
- en: '] = "Tom"'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '] = "Tom"'
- en: ;
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // looping through the names
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: // 循环遍历名称
- en: for
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < names.Length; i++)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < names.Length; i++)
- en: '{'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // output the item at index position i
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: // 输出索引位置i处的项目
- en: Console.WriteLine(names[i]);
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(names[i]);
- en: '}'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-1145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Kate
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: Kate
- en: Jack
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: Jack
- en: Rebecca
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: Rebecca
- en: Tom
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: Tom
- en: '```'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Arrays are always of a fixed size at the time of memory allocation, so you need
    to decide how many items you want to store before instantiating them.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在内存分配时总是固定大小的，因此在实例化之前，您需要决定要存储多少项目。
- en: 'An alternative to defining the array in three steps as above is to use array
    initializer syntax, as shown in the following code:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面三个步骤定义数组的另一种选择是使用数组初始化程序语法，如下面的代码所示：
- en: '```cs'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '[] names2 = new'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '[] names2 = new'
- en: '[] { "Kate"'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '[] { "Kate"'
- en: ', "Jack"'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: ', "Jack"'
- en: ', "Rebecca"'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: ', "Rebecca"'
- en: ', "Tom"'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: ', "Tom"'
- en: '};'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '```'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When you use the `new[]` syntax to allocate memory for the array, you must have
    at least one item in the curly braces so that the compiler can infer the data
    type.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`new[]`语法为数组分配内存时，大括号中必须至少有一项，以便编译器可以推断数据类型。
- en: Arrays are useful for temporarily storing multiple items, but collections are
    a more flexible option when adding and removing items dynamically. You don't need
    to worry about collections right now, as we will cover them in *Chapter 8* , *Working
    with Common .NET Types* .
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 数组用于临时存储多个项目，但在动态添加和删除项目时，集合是更灵活的选择。您现在不需要担心集合，因为我们将在*第8章* *使用常见的.NET类型*中介绍它们。
- en: Exploring more about console applications
  id: totrans-1165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于控制台应用程序的探索
- en: We have already created and used basic console applications, but we're now at
    a stage where we should delve into them more deeply.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建并使用了基本的控制台应用程序，但现在我们应该更深入地研究它们。
- en: Console applications are text-based and are run at the command line. They typically
    perform simple tasks that need to be scripted, such as compiling a file or encrypting
    a section of a configuration file.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序是基于文本的，并在命令行上运行。它们通常执行需要脚本化的简单任务，例如编译文件或加密配置文件的一部分。
- en: Equally, they can also have arguments passed to them to control their behavior.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它们也可以接受传递给它们的参数来控制它们的行为。
- en: 'An example of this would be to create a new console app using the F# language
    with a specified name instead of using the name of the current folder, as shown
    in the following command line:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用指定的名称创建一个新的F#语言控制台应用程序，而不是使用当前文件夹的名称，如下面的命令行所示：
- en: '```cs'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: dotnet new console -lang "F#" --name "ExploringConsole"
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet new console -lang "F#" --name "ExploringConsole"
- en: '```'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Displaying output to the user
  id: totrans-1173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户显示输出
- en: The two most common tasks that a console application performs are writing and
    reading data. We have already been using the `WriteLine` method to output, but
    if we didn't want a carriage return at the end of the lines, we could have used
    the `Write` method.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序执行的两个最常见任务是写入和读取数据。我们已经在使用`WriteLine`方法输出数据，但如果我们不希望在行末使用换行符，我们可以使用`Write`方法。
- en: Formatting using numbered positional arguments
  id: totrans-1175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用编号的位置参数进行格式化
- en: One way of generating formatted strings is to use numbered positional arguments.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 生成格式化字符串的一种方法是使用编号的位置参数。
- en: This feature is supported by methods like `Write` and `WriteLine` , and for
    methods that do not support the feature, the `string` parameter can be formatted
    using the `Format` method of `string` .
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能由`Write`和`WriteLine`等方法支持，对于不支持该功能的方法，可以使用`string`的`Format`方法格式化`string`参数。
- en: The first few code examples in this section will work with a .NET Interactive
    notebook because they are about outputting to the console. Later in this section,
    you will learn about getting input via the console and sadly notebooks do not
    support this.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的前几个代码示例将使用.NET交互式笔记本，因为它们是关于向控制台输出。在本节的后面，您将学习通过控制台获取输入，遗憾的是笔记本不支持这一点。
- en: 'Let''s begin formatting:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始格式化：
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Formatting` .
  id: totrans-1180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter02`工作区/解决方案添加一个新的**控制台应用程序**，名称为`Formatting`。
- en: In Visual Studio Code, select `Formatting` as the active OmniSharp project.
  id: totrans-1181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Formatting`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , type statements to declare some number variables and write
    them to the console, as shown in the following code:'
  id: totrans-1182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句来声明一些数字变量并将它们写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: numberOfApples = 12
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfApples = 12
- en: ;
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: decimal
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: pricePerApple = 0.35
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: pricePerApple = 0.35
- en: M;
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: M;
- en: Console.WriteLine(
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: 'format: "{0} apples costs {1:C}"'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 'format: "{0} apples costs {1:C}"'
- en: ','
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: numberOfApples,'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: numberOfApples,'
- en: 'arg1: pricePerApple * numberOfApples);'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: pricePerApple * numberOfApples);'
- en: string
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: formatted = string
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: formatted = string
- en: .Format(
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: .Format(
- en: 'format: "{0} apples costs {1:C}"'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 'format: "{0} apples costs {1:C}"'
- en: ','
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: numberOfApples,'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: numberOfApples,'
- en: 'arg1: pricePerApple * numberOfApples);'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: pricePerApple * numberOfApples);'
- en: //WriteToFile(formatted); // writes the string into a file
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: //WriteToFile(formatted); // 将字符串写入文件
- en: '```'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `WriteToFile` method is a nonexistent method used to illustrate the idea.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteToFile`方法是一个不存在的方法，用于说明这个想法。'
- en: '**Good Practice** : Once you become more comfortable with formatting strings,
    you should stop naming the parameters, for example, stop using `format:` , `arg0:`
    , and `arg1:` . The preceding code uses a non-canonical style to show where the
    `0` and `1` came from while you are learning.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：一旦您对格式化字符串更加熟悉，您应该停止命名参数，例如，停止使用`format：`，`arg0：`和`arg1：`。上面的代码使用了一个非规范的样式来显示`0`和`1`来自于哪里，这样您在学习时就能知道。'
- en: Formatting using interpolated strings
  id: totrans-1206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插值字符串进行格式化
- en: 'C# 6.0 and later have a handy feature named **interpolated strings** . A `string`
    prefixed with `$` can use curly braces around the name of a variable or expression
    to output the current value of that variable or expression at that position in
    the `string` , as the following shows:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0及更高版本有一个方便的功能，名为**插值字符串**。以`$`为前缀的`string`可以使用大括号将变量或表达式的名称括起来，以在`string`中的该位置输出该变量或表达式的当前值，如下所示：
- en: 'Enter a statement at the bottom of the `Program.cs` file, as shown in the following
    code:'
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的底部输入一条语句，如下面的代码所示：
- en: '```cs'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Console.WriteLine($"
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"
- en: '{numberOfApples}'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '{苹果的数量}'
- en: apples costs
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的成本
- en: '{pricePerApple * numberOfApples:C}'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '{pricePerApple * numberOfApples:C}'
- en: '"'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-1217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的部分输出所示：
- en: '```cs'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 12 apples costs £4.20
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 12个苹果的成本为4.20英镑
- en: '```'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For short, formatted `string` values, an interpolated `string` can be easier
    for people to read. But for code examples in a book, where lines need to wrap
    over multiple lines, this can be tricky. For many of the code examples in this
    book, I will use numbered positional arguments.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于短的，格式化的`string`值，插值的`string`对于人们来说可能更容易阅读。但是对于书中需要跨越多行的代码示例来说，这可能有些棘手。对于本书中的许多代码示例，我将使用编号的位置参数。
- en: Another reason to avoid interpolated strings is that they can't be read from
    resource files to be localized.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 避免插值字符串的另一个原因是它们无法从资源文件中读取以进行本地化。
- en: 'Before C# 10, string constants could only be combined by using concatenation,
    as shown in the following code:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10之前，只能通过连接来组合字符串常量，如下面的代码所示：
- en: '```cs'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: private
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的
- en: const
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: string
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: firstname = "Omar"
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: firstname = "Omar"
- en: ;
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的
- en: const
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: string
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: lastname = "Rudberg"
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: lastname = "Rudberg"
- en: ;
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的
- en: const
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: string
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: fullname = firstname + " "
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: fullname = firstname + " "
- en: + lastname;
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: + 姓;
- en: '```'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With C# 10, interpolated strings can now be used, as shown in the following
    code:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C# 10，可以使用插值字符串，如下面的代码所示：
- en: '```cs'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: private
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的
- en: const
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: string
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: fullname = "{firstname} {lastname}"
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: fullname = "{firstname} {lastname}"
- en: ;
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This only works for combining string constant values. It cannot work with other
    types like numbers that would require runtime data type conversions.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅适用于组合字符串常量值。它无法处理其他类型，比如需要运行时数据类型转换的数字。
- en: Understanding format strings
  id: totrans-1250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解格式化字符串
- en: A variable or expression can be formatted using a format string after a comma
    or colon.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 变量或表达式可以在逗号或冒号后使用格式字符串进行格式化。
- en: An `N0` format string means a number with a thousand separators and no decimal
    places, while a `C` format string means currency. The currency format will be
    determined by the current thread.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '`N0`格式字符串表示带有千位分隔符且没有小数位的数字，而`C`格式字符串表示货币。货币格式将由当前线程确定。'
- en: For instance, if you run this code on a PC in the UK, you'll get pounds sterling
    with commas as the thousand separators, but if you run this code on a PC in Germany,
    you will get euros with dots as the thousand separators.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在英国的PC上运行此代码，您将得到英镑和逗号作为千位分隔符，但如果您在德国的PC上运行此代码，您将得到欧元和点作为千位分隔符。
- en: 'The full syntax of a format item is:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 格式项的完整语法是：
- en: '```cs'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '{ index [, alignment ] [ : formatString ] }'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '{ index [, alignment ] [ : formatString ] }'
- en: '```'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Each format item can have an alignment, which is useful when outputting tables
    of values, some of which might need to be left- or right-aligned within a width
    of characters. Alignment values are integers. Positive integers mean right-aligned
    and negative integers mean left-aligned.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 每个格式项都可以有一个对齐，这在输出值的表格中非常有用，其中一些值可能需要在字符宽度内左对齐或右对齐。对齐值是整数。正整数表示右对齐，负整数表示左对齐。
- en: 'For example, to output a table of fruit and how many of each there are, we
    might want to left-align the names within a column of 10 characters and right-align
    the counts formatted as numbers with zero decimal places within a column of six
    characters:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要输出一张水果表以及每种水果的数量，我们可能希望将名称左对齐到10个字符的列中，并将格式化为不带小数位的数字的计数右对齐到6个字符的列中：
- en: 'At the bottom of `Program.cs` , enter the following statements:'
  id: totrans-1260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，输入以下语句：
- en: '```cs'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: applesText = "Apples"
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: applesText = "苹果"
- en: ;
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: applesCount = 1234
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: applesCount = 1234
- en: ;
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: bananasText = "Bananas"
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: bananasText = "香蕉"
- en: ;
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: bananasCount = 56789
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: bananasCount = 56789
- en: ;
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Console.WriteLine(
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: 'format: "{0,-10} {1,6:N0}"'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："{0，-10} {1,6:N0}"
- en: ','
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: "Name"'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: arg0："名字"
- en: ','
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg1: "Count"'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: arg1："计数"
- en: );
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Console.WriteLine(
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: 'format: "{0,-10} {1,6:N0}"'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："{0，-10} {1,6:N0}"
- en: ','
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: applesText,'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：applesText，
- en: 'arg1: applesCount);'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：applesCount);
- en: Console.WriteLine(
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: 'format: "{0,-10} {1,6:N0}"'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："{0，-10} {1,6:N0}"
- en: ','
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: bananasText,'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：bananasText，
- en: 'arg1: bananasCount);'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：bananasCount);
- en: '```'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the effect of the alignment and number format, as shown
    in the following output:'
  id: totrans-1292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意对齐和数字格式的效果，如下面的输出所示：
- en: '```cs'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Name          Count
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 名字          计数
- en: Apples        1,234
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果        1,234
- en: Bananas      56,789
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 香蕉      56,789
- en: '```'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Getting text input from the user
  id: totrans-1298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户那里获取文本输入
- en: We can get text input from the user using the `ReadLine` method. This method
    waits for the user to type some text, then as soon as the user presses Enter ,
    whatever the user has typed is returned as a `string` value.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ReadLine`方法从用户那里获取文本输入。该方法等待用户输入一些文本，然后一旦用户按下Enter键，无论用户输入了什么都将作为`string`值返回。
- en: '**Good Practice** : If you are using a .NET Interactive notebook for this section,
    then note that it does not support reading input from the console using `Console.ReadLine()`
    . Instead, you must set literal values, as shown in the following code: `string?
    firstName = "Gary";` . This is often quicker to experiment with because you can
    simply change the literal `string` value and click the **Execute Cell** button
    instead of having to restart a console app each time you want to enter a different
    `string` value.'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您在本节使用.NET交互式笔记本，则请注意它不支持使用`Console.ReadLine()`从控制台读取输入。相反，您必须设置文字值，如下面的代码所示：`string?
    firstName = "Gary";`。这通常更快，因为您可以简单地更改文字`string`值并单击**执行单元格**按钮，而不必每次想要输入不同的`string`值时都必须重新启动控制台应用程序。'
- en: 'Let''s get input from the user:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用户那里获取输入：
- en: 'Type statements to ask the user for their name and age and then output what
    they entered, as shown in the following code:'
  id: totrans-1302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以询问用户姓名和年龄，然后输出他们输入的内容，如下面的代码所示：
- en: '```cs'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Console.Write("Type your first name and press ENTER: "'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write("输入您的名字并按回车键："
- en: );
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: string
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? firstName = Console.ReadLine();'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: ？firstName = Console.ReadLine();
- en: 'Console.Write("Type your age and press ENTER: "'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: Console.Write("输入您的年龄并按回车键："
- en: );
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: string
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? age = Console.ReadLine();'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: ？age = Console.ReadLine();
- en: Console.WriteLine(
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: $"Hello
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: $"你好
- en: '{firstName}'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '{firstName}'
- en: ', you look good for'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: ，你看起来很不错
- en: '{age}'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '{age}'
- en: ."
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: '```'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, and then enter a name and age, as shown in the following output:'
  id: totrans-1320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，然后输入姓名和年龄，如下面的输出所示：
- en: '```cs'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Type your name and press ENTER: Gary'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的姓名并按回车键：Gary
- en: 'Type your age and press ENTER: 34'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的年龄并按回车键：34
- en: Hello Gary, you look good for 34.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 你好Gary，你看起来很不错，年龄为34岁。
- en: '```'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The question marks at the end of the `string?` data type declaration indicate
    that we acknowledge that a `null` (empty) value could be returned from the call
    to `ReadLine` . You will learn more about this in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '`string?`数据类型声明末尾的问号表示我们承认从对`ReadLine`的调用中可能返回`null`（空）值。您将在*第6章*，*实现接口和继承类*中了解更多信息。'
- en: Simplifying the usage of the console
  id: totrans-1327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化控制台的使用
- en: 'In C# 6.0 and later, the `using` statement can be used not only to import a
    namespace but also to further simplify our code by importing a static class. Then,
    we won''t need to enter the `Console` type name throughout our code. You can use
    your code editor''s find and replace feature to remove the times we have previously
    written `Console` :'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 6.0及更高版本中，`using`语句不仅可以用于导入命名空间，还可以通过导入静态类进一步简化我们的代码。然后，我们就不需要在整个代码中输入`Console`类型名称。您可以使用代码编辑器的查找和替换功能来删除我们以前写过的`Console`：
- en: 'At the top of the `Program.cs` file, add a statement to **statically import**
    the `System.Console` class, as shown in the following code:'
  id: totrans-1329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的顶部，添加一个语句以**静态导入**`System.Console`类，如下面的代码所示：
- en: '```cs'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。控制台；
- en: '```'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Select the first `Console.` in your code, ensuring that you select the dot after
    the word `Console` too.
  id: totrans-1335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中选择第一个`Console.`，确保您也选择了`Console`一词后面的句点。
- en: In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**
    , or in Visual Studio Code, navigate to **Edit** | **Replace** , and note that
    an overlay dialog appears ready for you to enter what you would like to replace
    **Console.** with, as shown in *Figure 2.5* :![](img/Image00034.jpg)
  id: totrans-1336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**编辑** | **查找和替换** | **快速替换**，或在Visual Studio Code中，导航到**编辑**
    | **替换**，注意到一个覆盖对话框已准备好让您输入您想要用什么替换**Console.**，如*图2.5*所示：![](img/Image00034.jpg)
- en: 'Figure 2.5: Using the Replace feature in Visual Studio to simplify your code'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：在Visual Studio中使用替换功能简化您的代码
- en: Leave the replace box empty, click on the **Replace all** button (the second
    of the two buttons to the right of the replace box), and then close the replace
    box by clicking on the cross in its top-right corner.
  id: totrans-1338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将替换框留空，单击“全部替换”按钮（替换框右侧的第二个按钮），然后单击替换框右上角的十字叉关闭替换框。
- en: Getting key input from the user
  id: totrans-1339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户那里获取按键输入
- en: We can get key input from the user using the `ReadKey` method. This method waits
    for the user to press a key or key combination that is then returned as a `ConsoleKeyInfo`
    value.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ReadKey`方法从用户那里获取按键输入。该方法等待用户按下一个键或键组合，然后将其作为`ConsoleKeyInfo`值返回。
- en: 'You will not be able to execute the call to the `ReadKey` method using a .NET
    Interactive notebook, but if you have created a console application, then let''s
    explore reading key presses:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 您将无法使用.NET交互式笔记本执行对`ReadKey`方法的调用，但如果您创建了一个控制台应用程序，那么让我们来探索读取按键：
- en: 'Type statements to ask the user to press any key combination and then output
    information about it, as shown in the following code:'
  id: totrans-1342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以要求用户按任意键组合，然后输出有关它的信息，如下面的代码所示：
- en: '```cs'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Write("Press any key combination: "'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: Write("按任意键组合："
- en: );
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: ConsoleKeyInfo key = ReadKey();
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKeyInfo key = ReadKey();
- en: WriteLine();
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: 'WriteLine("Key: {0}, Char: {1}, Modifiers: {2}"'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("键：{0}，字符：{1}，修饰符：{2}"
- en: ','
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: key.Key,'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：key.Key，
- en: 'arg1: key.KeyChar,'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：key.KeyChar，
- en: 'arg2: key.Modifiers);'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: arg2：key.Modifiers);
- en: '```'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, press the K key, and note the result, as shown in the following
    output:'
  id: totrans-1354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按K键，然后注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Press any key combination: k'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键组合：k
- en: 'Key: K, Char: k, Modifiers: 0'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 键：K，字符：k，修饰符：0
- en: '```'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, hold down Shift and press the K key, and note the result, as
    shown in the following output:'
  id: totrans-1359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按住Shift键并按下K键，然后注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Press any key combination: K'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键组合：K
- en: 'Key: K, Char: K, Modifiers: Shift'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 键：K，字符：K，修饰符：Shift
- en: '```'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, press the F12 key, and note the result, as shown in the following
    output:'
  id: totrans-1364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按F12键，然后注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Press any key combination:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键组合：
- en: 'Key: F12, Char: , Modifiers: 0'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 键：F12，字符：，修饰符：0
- en: '```'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When running a console application in a terminal within Visual Studio Code,
    some keyboard combinations will be captured by the code editor or operating system
    before they can be processed by your app.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端中运行控制台应用程序时，某些键盘组合将在代码编辑器或操作系统之前被捕获，然后才能被您的应用程序处理。
- en: Passing arguments to a console app
  id: totrans-1370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向控制台应用程序传递参数
- en: You might have been wondering how to get any arguments that might be passed
    to a console application.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能一直在想如何获取可能传递给控制台应用程序的任何参数。
- en: 'In every version of .NET prior to version 6.0, the console application project
    template made it obvious, as shown in the following code:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6.0之前的每个版本中，控制台应用程序项目模板都很明显，如下面的代码所示：
- en: '```cs'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 系统；
- en: namespace
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Arguments
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '{'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: class
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Program
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: Program
- en: '{'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: static
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: void
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Main
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: Main
- en: (
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '[] args'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '[] args'
- en: )
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Hello World!"
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Hello World!"
- en: );
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `string[] args` arguments are declared and passed in the `Main` method of
    the `Program` class. They're an array used to pass arguments into a console application.
    But in top-level programs, as used by the console application project template
    in .NET 6.0 and later, the `Program` class and its `Main` method are hidden, along
    with the declaration of the `args` string array. The trick is that you must know
    it still exists.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '`string[] args`参数在`Program`类的`Main`方法中声明和传递。它们是用于将参数传递到控制台应用程序中的数组。但在顶级程序中，即.NET
    6.0及以后版本中控制台应用程序项目模板使用的方式，`Program`类及其`Main`方法被隐藏，以及`args`字符串数组的声明。诀窍在于您必须知道它仍然存在。'
- en: Command-line arguments are separated by spaces. Other characters like hyphens
    and colons are treated as part of an argument value.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数由空格分隔。连字符和冒号等其他字符被视为参数值的一部分。
- en: To include spaces in an argument value, enclose the argument value in single
    or double quotes.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 要在参数值中包含空格，请将参数值括在单引号或双引号中。
- en: 'Imagine that we want to be able to enter the names of some colors for the foreground
    and background, and the dimensions of the terminal window at the command line.
    We would be able to read the colors and numbers by reading them from the `args`
    array, which is always passed into the `Main` method aka the entry point of a
    console application:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望能够在命令行中输入前景和背景的一些颜色名称，以及终端窗口的尺寸。我们可以通过从始终传递到`Main`方法（即控制台应用程序的入口点）的`args`数组中读取颜色和数字来实现。
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Arguments` . You will not be able to use a .NET Interactive
    notebook because you cannot pass arguments to a notebook.
  id: totrans-1400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter02`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`Arguments`。您将无法使用.NET交互笔记本，因为您无法向笔记本传递参数。
- en: In Visual Studio Code, select `Arguments` as the active OmniSharp project.
  id: totrans-1401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Arguments`作为活动的OmniSharp项目。
- en: 'Add a statement to statically import the `System.Console` type and a statement
    to output the number of arguments passed to the application, as shown in the following
    code:'
  id: totrans-1402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个语句来静态导入`System.Console`类型，并添加一个语句来输出传递给应用程序的参数数量，如下面的代码所示：
- en: '```cs'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: System.Console;
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: WriteLine($"There are
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"有
- en: '{args.Length}'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '{args.Length}'
- en: arguments."
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。"
- en: );
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: '```'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Remember to statically import the `System.Console` type
    in all future projects to simplify your code, as these instructions will not be
    repeated every time.'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：记住在所有未来的项目中静态导入`System.Console`类型，以简化您的代码，因为这些说明不会每次重复。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: There are 0 arguments.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数。
- en: '```'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If you are using Visual Studio, then navigate to **Project** | **Arguments**
    **Properties** , select the **Debug** tab, and in the **Application arguments**
    box, enter some arguments, save the changes, and then run the console application,
    as shown in *Figure 2.6* :![Graphical user interface, text, application Description
    automatically generated](img/Image00035.jpg)
  id: totrans-1417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用Visual Studio，则转到**项目** | **参数** **属性**，选择**调试**选项卡，在**应用程序参数**框中输入一些参数，保存更改，然后运行控制台应用程序，如*图2.6*所示：![图形用户界面，文本，应用程序说明自动生成](img/Image00035.jpg)
- en: 'Figure 2.6: Entering application arguments in Visual Studio project properties'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：在Visual Studio项目属性中输入应用程序参数
- en: 'If you are using Visual Studio Code, then in a terminal, enter some arguments
    after the `dotnet run` command, as shown in the following command line:'
  id: totrans-1419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用Visual Studio Code，则在终端中，在`dotnet run`命令之后输入一些参数，如下所示：
- en: '```cs'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: dotnet run firstarg second-arg third:arg "fourth arg"
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet run firstarg second-arg third:arg "fourth arg"
- en: '```'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the result indicates four arguments, as shown in the following output:'
  id: totrans-1423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意结果显示了四个参数，如下面的输出所示：
- en: '```cs'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: There are 4 arguments.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 有4个参数。
- en: '```'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To enumerate or iterate (that is, loop through) the values of those four arguments,
    add the following statements after outputting the length of the array:'
  id: totrans-1427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要枚举或迭代（即循环）这四个参数的值，请在输出数组长度之后添加以下语句：
- en: '```cs'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: foreach
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (string
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: arg in
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: arg in
- en: args)
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: args)
- en: '{'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine(arg);
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(arg);
- en: '}'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code again and note the result shows the details of the four arguments,
    as shown in the following output:'
  id: totrans-1437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，注意结果显示了四个参数的详细信息，如下所示：
- en: '```cs'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: There are 4 arguments.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 有4个参数。
- en: firstarg
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: firstarg
- en: second-arg
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: second-arg
- en: third:arg
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: third:arg
- en: fourth arg
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个参数
- en: '```'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Setting options with arguments
  id: totrans-1445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用参数设置选项
- en: We will now use these arguments to allow the user to pick a color for the background,
    foreground, and cursor size of the output window. The cursor size can be an integer
    value from 1, meaning a line at the bottom of the cursor cell, up to 100, meaning
    a percentage of the height of the cursor cell.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用这些参数，允许用户为输出窗口的背景、前景和光标大小选择颜色。光标大小可以是从1开始的整数值，表示光标单元底部的一条线，最大到100，表示光标单元高度的百分比。
- en: 'The `System` namespace is already imported so that the compiler knows about
    the `ConsoleColor` and `Enum` types:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`命名空间已经导入，因此编译器知道`ConsoleColor`和`Enum`类型：'
- en: 'Add statements to warn the user if they do not enter three arguments and then
    parse those arguments and use them to set the color and dimensions of the console
    window, as shown in the following code:'
  id: totrans-1448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以警告用户如果他们没有输入三个参数，然后解析这些参数并使用它们来设置控制台窗口的颜色和尺寸，如下代码所示：
- en: '```cs'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (args.Length < 3
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: (args.Length < 3
- en: )
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("You must specify two colors and cursor size, e.g."
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("您必须指定两种颜色和光标大小，例如。"
- en: );
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine("dotnet run red yellow 50"
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("dotnet run red yellow 50"
- en: );
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: return
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: ; // stop running
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 停止运行
- en: '}'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ForegroundColor = (ConsoleColor)Enum.Parse(
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 前景色 = (ConsoleColor)Enum.Parse(
- en: 'enumType: typeof'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 'enumType: typeof'
- en: (ConsoleColor),
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: (ConsoleColor),
- en: value
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: value
- en: ': args[0'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: ': args[0'
- en: '],'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: 'ignoreCase: true'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 'ignoreCase: true'
- en: );
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: BackgroundColor = (ConsoleColor)Enum.Parse(
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: BackgroundColor = (ConsoleColor)Enum.Parse(
- en: 'enumType: typeof'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 'enumType: typeof'
- en: (ConsoleColor),
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: (ConsoleColor),
- en: value
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: value
- en: ': args[1'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: ': args[1'
- en: '],'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: 'ignoreCase: true'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 'ignoreCase: true'
- en: );
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: CursorSize = int
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: CursorSize = int
- en: .Parse(args[2
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: .Parse(args[2
- en: ']);'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: ']);'
- en: '```'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Setting the `CursorSize` is only supported on Windows.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`CursorSize`仅在Windows上受支持。
- en: 'In Visual Studio, navigate to **Project** | **Arguments Properties** , and
    change the arguments to: `red yellow 50` , run the console app, and note the cursor
    is half the size and the colors have changed in the window, as shown in *Figure
    2.7* :![Graphical user interface, application, website Description automatically
    generated](img/Image00036.jpg)'
  id: totrans-1482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**项目** | **参数属性**，并将参数更改为：`red yellow 50`，运行控制台应用程序，注意光标的大小减半，窗口中的颜色已更改，如*图2.7*所示：![图形用户界面，应用程序，网站描述自动生成](img/Image00036.jpg)
- en: 'Figure 2.7: Setting colors and cursor size on Windows'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：在Windows上设置颜色和光标大小
- en: 'In Visual Studio Code, run the code with arguments to set the foreground color
    to red, the background color to yellow, and the cursor size to 50%, as shown in
    the following command:'
  id: totrans-1484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，使用参数运行代码，将前景色设置为红色，背景色设置为黄色，光标大小设置为50%，如下命令所示：
- en: '```cs'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: dotnet run red yellow 50
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet run red yellow 50
- en: '```'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'On macOS, you''ll see an unhandled exception, as shown in *Figure 2.8* :'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，您将看到一个未处理的异常，如*图2.8*所示：
- en: '![Graphical user interface, text, application Description automatically generated](img/Image00037.jpg)'
  id: totrans-1489
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/Image00037.jpg)'
- en: 'Figure 2.8: An unhandled exception on unsupported macOS'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：在不支持的macOS上发生未处理的异常
- en: Although the compiler did not give an error or warning, at runtime some API
    calls may fail on some platforms. Although a console application running on Windows
    can change its cursor size, on macOS, it cannot, and complains if you try.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器没有给出错误或警告，但在运行时，一些API调用可能在某些平台上失败。尽管在Windows上运行的控制台应用程序可以更改其光标大小，但在macOS上却不能，并且如果尝试，则会出现错误。
- en: Handling platforms that do not support an API
  id: totrans-1492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不支持API的平台
- en: 'So how do we solve this problem? We can solve this by using an exception handler.
    You will learn more details about the `try-catch` statement in *Chapter 3* , *Controlling
    Flow, Converting Types, and Handling Exceptions* , so for now, just enter the
    code:'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何解决这个问题呢？我们可以通过使用异常处理程序来解决这个问题。您将在*第3章*，*控制流，类型转换和异常处理*中了解更多关于`try-catch`语句的细节，所以现在，只需输入以下代码：
- en: 'Modify the code to wrap the lines that change the cursor size in a `try` statement,
    as shown in the following code:'
  id: totrans-1494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码以在`try`语句中包装更改光标大小的行，如下代码所示：
- en: '```cs'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: try
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: CursorSize = int
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: CursorSize = int
- en: .Parse(args[2
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: .Parse(args[2
- en: ']);'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: ']);'
- en: '}'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: catch (PlatformNotSupportedException)
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: catch (PlatformNotSupportedException)
- en: '{'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("The current platform does not support changing the size of the cursor."
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("当前平台不支持更改光标的大小。"
- en: );
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If you were to run the code on macOS then you would see the exception is caught,
    and a friendlier message is shown to the user.
  id: totrans-1508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在macOS上运行代码，则会看到捕获到异常，并向用户显示更友好的消息。
- en: 'Another way to handle differences in operating systems is to use the `OperatingSystem`
    class in the `System` namespace, as shown in the following code:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 处理操作系统差异的另一种方法是使用`System`命名空间中的`OperatingSystem`类，如下代码所示：
- en: '```cs'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (OperatingSystem.IsWindows())
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: (OperatingSystem.IsWindows())
- en: '{'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // execute code that only works on Windows
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: // 执行仅在Windows上有效的代码
- en: '}'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: if
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: '(OperatingSystem.IsWindowsVersionAtLeast(major: 10'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '(OperatingSystem.IsWindowsVersionAtLeast(major: 10'
- en: ))
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: ))
- en: '{'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // execute code that only works on Windows 10 or later
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: // 执行仅在Windows 10或更高版本上有效的代码
- en: '}'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: if
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: '(OperatingSystem.IsIOSVersionAtLeast(major: 14'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '(OperatingSystem.IsIOSVersionAtLeast(major: 14'
- en: ', minor: 5'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: ', minor: 5'
- en: ))
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: ))
- en: '{'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // execute code that only works on iOS 14.5 or later
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: // 执行仅在iOS 14.5或更高版本上有效的代码
- en: '}'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: if
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (OperatingSystem.IsBrowser())
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: (OperatingSystem.IsBrowser())
- en: '{'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // execute code that only works in the browser with Blazor
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: // 执行仅在具有Blazor的浏览器上有效的代码
- en: '}'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `OperatingSystem` class has equivalent methods for other common operating
    systems like Android, iOS, Linux, macOS, and even the browser, which is useful
    for Blazor web components.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperatingSystem`类还具有其他常见操作系统的等效方法，如Android、iOS、Linux、macOS甚至浏览器，这对于Blazor网络组件非常有用。'
- en: A third way to handle different platforms is to use conditional compilation
    statements.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不同平台的第三种方法是使用条件编译语句。
- en: 'There are four preprocessor directives that control conditional compilation:
    `#if` , `#elif` , `#else` , and `#endif` .'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个预处理指令来控制条件编译：`#if`，`#elif`，`#else`和`#endif`。
- en: 'You define symbols using `#define` , as shown in the following code:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`#define`来定义符号，如下代码所示：
- en: '```cs'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: define
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: define
- en: MYSYMBOL
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: MYSYMBOL
- en: '```'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Many symbols are automatically defined for you, as shown in the following table:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 许多符号已经自动为您定义，如下表所示：
- en: '| Target Framework | Symbols |'
  id: totrans-1548
  prefs: []
  type: TYPE_TB
  zh: '| 目标框架 | 符号 |'
- en: '| .NET Standard | `NETSTANDARD2_0` , `NETSTANDARD2_1` , and so on |'
  id: totrans-1549
  prefs: []
  type: TYPE_TB
  zh: '| .NET标准 | `NETSTANDARD2_0`，`NETSTANDARD2_1`等 |'
- en: '| Modern .NET | `NET6_0` , `NET6_0_ANDROID` , `NET6_0_IOS` , `NET6_0_WINDOWS`
    , and so on |'
  id: totrans-1550
  prefs: []
  type: TYPE_TB
  zh: '| 现代.NET | `NET6_0`，`NET6_0_ANDROID`，`NET6_0_IOS`，`NET6_0_WINDOWS`等 |'
- en: 'You can then write statements that will compile only for the specified platforms,
    as shown in the following code:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以编写只在指定平台上编译的语句，就像下面的代码所示：
- en: '```cs'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: if
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: NET6_0_ANDROID
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: NET6_0_ANDROID
- en: // compile statements that only works on Android
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: // 编译语句仅适用于Android
- en: '#'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: elif
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: elif
- en: NET6_0_IOS
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: NET6_0_IOS
- en: // compile statements that only works on iOS
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: // 编译语句仅适用于iOS
- en: '#'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: else
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: // compile statements that work everywhere else
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: // 编译语句适用于其他所有地方
- en: '#'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: endif
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: endif
- en: '```'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Practicing and exploring
  id: totrans-1567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore the topics covered in this chapter with deeper
    research.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解，进行一些实践，并深入研究本章涵盖的主题。
- en: Exercise 2.1 – Test your knowledge
  id: totrans-1569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.1 – 测试你的知识
- en: To get the best answer to some of these questions, you will need to do your
    own research. I want you to "think outside the book" so I have deliberately not
    provided all the answers in the book.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一些问题的最佳答案，你需要进行自己的研究。我希望你“超越书本”，所以我故意没有在书中提供所有答案。
- en: I want to encourage you to get in to the good habit of looking for help elsewhere,
    following the principle of "teach a person to fish."
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 我想鼓励你养成到其他地方寻求帮助的好习惯，遵循“授人以鱼不如授人以渔”的原则。
- en: What statement can you type in a C# file to discover the compiler and language
    version?
  id: totrans-1572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在C#文件中输入什么语句来发现编译器和语言版本？
- en: What are the two types of comments in C#?
  id: totrans-1573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中有哪两种类型的注释？
- en: What is the difference between a verbatim string and an interpolated string?
  id: totrans-1574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐字字符串和插值字符串之间有什么区别？
- en: Why should you be careful when using `float` and `double` values?
  id: totrans-1575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用`float`和`double`值时要小心？
- en: How can you determine how many bytes a type like `double` uses in memory?
  id: totrans-1576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确定像`double`这样的类型在内存中使用了多少字节？
- en: When should you use the `var` keyword?
  id: totrans-1577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你什么时候应该使用`var`关键字？
- en: What is the newest way to create an instance of a class like `XmlDocument` ?
  id: totrans-1578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`XmlDocument`这样的类的实例的最新方法是什么？
- en: Why should you be careful when using the `dynamic` type?
  id: totrans-1579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用`dynamic`类型时要小心？
- en: How do you right-align a format string?
  id: totrans-1580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使格式字符串右对齐？
- en: What character separates arguments for a console application?
  id: totrans-1581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台应用程序的参数是由什么字符分隔的？
- en: '*Appendix* , *Answers to the Test Your Knowledge Questions* is available to
    download from a link in the README on the GitHub repository: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)
    .'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '*附录*，*测试你的知识问题的答案* 可以从GitHub存储库的README中的链接下载：[https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)。'
- en: Exercise 2.2 – Test your knowledge of number types
  id: totrans-1583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.2 – 测试数字类型的知识
- en: What type would you choose for the following "numbers"?
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 你会选择什么类型来表示以下的“数字”？
- en: A person's telephone number
  id: totrans-1585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人的电话号码
- en: A person's height
  id: totrans-1586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人的身高
- en: A person's age
  id: totrans-1587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人的年龄
- en: A person's salary
  id: totrans-1588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人的工资
- en: A book's ISBN
  id: totrans-1589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一本书的ISBN
- en: A book's price
  id: totrans-1590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一本书的价格
- en: A book's shipping weight
  id: totrans-1591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一本书的运输重量
- en: A country's population
  id: totrans-1592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个国家的人口
- en: The number of stars in the universe
  id: totrans-1593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宇宙中的星星数量
- en: The number of employees in each of the small or medium businesses in the United
    Kingdom (up to about 50,000 employees per business)
  id: totrans-1594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 英国小型或中型企业中的员工人数（每家企业最多约50,000名员工）
- en: Exercise 2.3 – Practice number sizes and ranges
  id: totrans-1595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.3 – 练习数字大小和范围
- en: 'In the `Chapter02` solution/workspace, create a console application project
    named `Exercise02` that outputs the number of bytes in memory that each of the
    following number types uses and the minimum and maximum values they can have:
    `sbyte` , `byte` , `short` , `ushort` , `int` , `uint` , `long` , `ulong` , `float`
    , `double` , and `decimal` .'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter02`解决方案/工作区中，创建一个名为`Exercise02`的控制台应用程序项目，输出以下每种数字类型在内存中使用的字节数以及它们可以具有的最小和最大值：`sbyte`，`byte`，`short`，`ushort`，`int`，`uint`，`long`，`ulong`，`float`，`double`和`decimal`。
- en: 'The result of running your console application should look something like *Figure
    2.9* :'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序的结果应该类似于*图2.9*：
- en: '![Text Description automatically generated](img/Image00038.jpg)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本描述](img/Image00038.jpg)'
- en: 'Figure 2.9: The result of outputting number type sizes'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：输出数字类型大小的结果
- en: 'Code solutions for all exercises are available to download or clone from the
    GitHub repository at the following link: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)
    .'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 所有练习的代码解决方案都可以从以下链接的GitHub存储库中下载或克隆：[https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)。
- en: Exercise 2.4 – Explore topics
  id: totrans-1601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.4 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接，了解本章涵盖的主题的更多细节：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c)'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c)'
- en: Summary
  id: totrans-1604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何：
- en: Declare variables with a specified or an inferred type.
  id: totrans-1606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明具有指定或推断类型的变量。
- en: Use some of the built-in types for numbers, text, and Booleans.
  id: totrans-1607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些内置的类型来表示数字、文本和布尔值。
- en: Choose between number types.
  id: totrans-1608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字类型之间进行选择。
- en: Control output formatting in console apps.
  id: totrans-1609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制控制台应用程序中的输出格式。
- en: In the next chapter, you will learn about operators, branching, looping, converting
    between types, and how to handle exceptions.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于运算符、分支、循环、类型转换以及如何处理异常。
