- en: BDD – Working Together with the Whole Team
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BDD - 与整个团队合作
- en: '"I''m not a great programmer; I''m just a good programmer with great habits."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我不是一个伟大的程序员；我只是一个有着伟大习惯的好程序员。”
- en: – Kent Beck
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 肯特·贝克'
- en: Everything we have done until now is related to techniques that can be applied
    only by developers, for developers. Customers, business representatives, and other
    parties that are not capable of reading and understanding code were not involved
    in the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都与只能由开发人员应用的技术有关。客户、业务代表和其他无法阅读和理解代码的人并未参与其中。
- en: TDD can be much more than what we have done up to now. We can define requirements,
    discuss them with the client, and get agreement as to what should be developed.
    We can use those same requirements and make them executable so that they drive
    and validate our development. We can use ubiquitous language to write acceptance
    criteria. All this, and more, is accomplished with a flavor of TDD called **behavior-driven
    development** (**BDD**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TDD可以做得比我们到目前为止所做的更多。我们可以定义需求，与客户讨论，并就应该开发什么达成一致。我们可以使用这些需求并使它们可执行，以便驱动和验证我们的开发。我们可以使用通用语言编写验收标准。所有这些，以及更多，都是通过一种称为**行为驱动开发**（**BDD**）的TDD风格实现的。
- en: We'll develop a book store application using a BDD approach. We'll define acceptance
    criteria in English, make the implementation of each feature separately, confirm
    that it is working correctly by running BDD scenarios and, if required, refactor
    the code to accomplish the desired level of quality. The process still follows
    the Red-Green-Refactor that is the essence of TDD. The major difference is the
    definition level. While, until this moment, we have been mostly working at the
    units level, this time we'll move a bit higher and apply TDD through functional
    and integration tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用BDD方法开发一个书店应用程序。我们将用英语定义验收标准，分别实现每个功能，通过运行BDD场景确认其是否正常工作，并在必要时重构代码以达到所需的质量水平。该过程仍然遵循TDD的红-绿-重构，这是TDD的本质。主要区别在于定义级别。直到此刻，我们大多在单元级别工作，这次我们将稍微提高一点，并通过功能和集成测试应用TDD。
- en: Our frameworks of choice will be JBehave and Selenide.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的框架将是JBehave和Selenide。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The different types of specifications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的规范
- en: Behavior-driven development (BDD)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）
- en: The book store BDD story
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书店BDD故事
- en: JBehave
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JBehave
- en: Different specifications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的规范
- en: We have already mentioned that one of the benefits of TDD is executable documentation
    that is always up to date. However, documentation obtained through unit tests
    is often not enough. When working at such a low-level, we get insights into details;
    however, it is all too easy to miss the big picture. If, for example, you were
    to inspect specifications that we created for the Tic-Tac-Toe game, you might
    easily miss the point of the application. You would understand what each unit
    does and how it interoperates with other units, but would have a hard time grasping
    the idea behind it. To be precise, you would understand that unit *X* does *Y*
    and communicates with *Z*; however, the functional documentation and the idea
    behind it would be, at best, hard to find.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到TDD的一个好处是可执行的文档，它始终保持最新状态。然而，通过单元测试获得的文档通常是不够的。在这样低级别的工作中，我们可以深入了解细节；然而，很容易忽略整体情况。例如，如果您要检查我们为井字游戏创建的规范，您可能很容易忽略应用程序的要点。您会了解每个单元的功能以及它如何与其他单元互操作，但很难理解其背后的想法。准确地说，您会了解单元*X*执行*Y*并与*Z*通信；然而，功能文档和其背后的想法最多也是很难找到。
- en: The same can be said for development. Before we start working on specifications
    in the form of unit tests, we need to get a bigger picture. Throughout this book,
    you were presented with requirements that we used for writing specifications that
    resulted in their implementation. Those requirements were later on discarded;
    they are nowhere to be seen. We did not put them in to the repository, nor did
    we use them to validate the result of our work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发也是如此。在我们开始以单元测试的形式工作之前，我们需要先了解整体情况。在本书中，我们提出了用于编写规范的需求，这些规范导致了它们的实施。这些要求后来被丢弃了；它们已经不见了。我们没有把它们放入存储库，也没有用它们来验证我们工作的结果。
- en: Documentation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: In many of the organizations that we worked with, the documentation was created
    for the wrong reasons. The management tends to think that documentation is somehow
    related to project success—that without a lot of (often short-lived) documentation,
    the project will fail. Thus, we are asked to spend a lot of time planning, answering
    questions, and filling in questionnaires that are often designed not to help the
    project but to provide an illusion that everything is under control. Someone's
    existence is often justified with documentation (the result of my work is this
    document). It also serves as a reassurance that everything is going as planned
    (there is an Excel sheet that states that we are on schedule). However, by far
    the most common reason for the creation of documentation is a process that simply
    states that certain documents need to be created. We might question the value
    of those documents, however, since the process is sacred, they need to be produced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们合作的许多组织中，文档是出于错误的原因而创建的。管理层倾向于认为文档与项目成功有某种关联——没有大量（通常是短暂的）文档，项目就会失败。因此，我们被要求花费大量时间规划、回答问题，并填写通常并非旨在帮助项目而是提供一种一切都在控制之下的错觉的问卷调查。有时候，某人的存在往往是通过文档来证明的（我的工作成果就是这份文件）。它还作为一种保证，表明一切都按计划进行（有一张Excel表格表明我们按计划进行）。然而，创建文档最常见的原因远非如此，而是一个简单陈述某些文档需要被创建的流程。我们可能会质疑这些文档的价值，然而，由于流程是神圣的，它们必须被制作出来。
- en: Not only might that documentation be created for the wrong reasons and not provide
    enough value, but, as is often the case, it might also do a lot of damage. If
    we created the documentation, it is natural that we trust it. However, what happens
    if that documentation is not up to date? The requirements are changing, bugs are
    getting fixed, new functionalities are being developed, and some are being removed.
    If given enough time, all traditional documentation becomes obsolete. The sheer
    task of updating documentation with every change we make to the code is so big
    and complex that, sooner or later, we must face the fact that static documents
    do not reflect the reality. If we are putting our trust into something that is
    not accurate, our development is based on wrong assumptions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可能出于错误原因创建文档并且价值不够，而且通常情况下，它可能也会造成很大的损害。如果我们创建了文档，那么我们自然会相信它。但是，如果文档不是最新的，会发生什么？需求在变化，错误正在修复，正在开发新功能，有些功能正在被移除。如果给予足够的时间，所有传统文档都会过时。随着我们对代码进行的每一次更改，更新文档的任务是如此庞大和复杂，以至于迟早我们必须面对静态文档不反映现实的事实。如果我们对不准确的东西产生信任，我们的开发就是基于错误的假设。
- en: The only accurate documentation is our code. The code is what we develop, what
    we deploy, and is the only source that truthfully represents our application.
    However, code is not readable by everyone involved with the project. Besides coders,
    we might work with managers, testers, business people, end users, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一准确的文档是我们的代码。代码是我们开发的东西，我们部署的东西，也是唯一真实代表我们应用程序的来源。然而，代码并非每个参与项目的人都能阅读。除了程序员，我们可能还与经理、测试人员、业务人员、最终用户等一起工作。
- en: In search of a better way to define what would constitute better documentation,
    let us explore a bit further into who the potential documentation consumers are.
    For the sake of simplicity, we'll divide them into coders (those capable of reading
    and understanding code) and non-coders (everyone else).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了寻找更好的定义什么构成更好的文档的方法，让我们进一步探讨一下潜在的文档使用者是谁。为了简单起见，我们将它们分为程序员（能够阅读和理解代码的人）和非程序员（其他人）。
- en: Documentation for coders
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向程序员的文档
- en: Developers work with code and, since we have established that code is the most
    accurate documentation, there is no reason to not utilize it. If you want to understand
    what some method does, take a look at the code of that method. In doubt about
    what some class does? Take a look at that class. Having trouble understanding
    a piece of code? We have a problem! However, the problem is not that the documentation
    is missing, but that the code itself is not written well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员使用代码，既然我们已经确定代码是最准确的文档，那就没有理由不利用它。如果您想了解某个方法的作用，请查看该方法的代码。对某个类的功能有疑问？看看那个类。难以理解某段代码？我们有问题！然而，问题不是文档丢失，而是代码本身写得不好。
- en: Looking at the code to understand the code is still often not enough. Even though
    you might understand what the code does, the purpose of that code might not be
    so obvious. Why was it written in the first place?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码以理解代码通常还不够。即使您可能理解代码的功能，该代码的目的可能并不那么明显。它首先是为什么编写的呢？
- en: That's where specifications come in. Not only are we using them to continuously
    validate the code, but they also act as executable documentation. They are always
    up to date because if they aren't, their execution will fail. At the same time,
    while code itself should be written in a way that is easy to read and understand,
    specifications provide a much easier and faster way to understand the reasons,
    logic, and motivations that lead us to write some piece of implementation code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是规格的作用。我们不仅在持续验证代码时使用它们，而且它们还充当可执行文档。它们始终保持最新，因为如果它们不是，它们的执行将失败。同时，虽然代码本身应该以易于阅读和理解的方式编写，但规格提供了一种更容易和更快速地理解我们编写某些实现代码的原因、逻辑和动机的方式。
- en: Using code as documentation does not exclude other types. Quite the contrary,
    the key is not to avoid using static documentation, but to avoid duplication.
    When code provides the necessary details, use it before anything else. In most
    cases, this leaves us with higher-level documentation, such as an overview, the
    general purpose of the system, the technologies used, the environment set-up,
    the installation, building, and packaging, and other types of data that tend to
    serve more like guidelines and quick-start information than detailed information.
    For those cases, a simple `README` in markdown format ([http://whatismarkdown.com/](http://whatismarkdown.com/))
    tends to be the best.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码作为文档并不排除其他类型。相反，关键不是避免使用静态文档，而是避免重复。当代码提供必要的细节时，首先使用它。在大多数情况下，这使我们得到更高级别的文档，例如概述、系统的一般目的、使用的技术、环境设置、安装、构建和打包，以及其他类型的数据，往往更像指南和快速启动信息而不是详细信息。对于这些情况，markdown格式的简单`README`（[http://whatismarkdown.com/](http://whatismarkdown.com/)）往往是最好的。
- en: For all code-based documentation, TDD is the best enabler. Until now, we worked
    only with units (methods). We are yet to see how to apply TDD on a higher-level,
    such as, for example, functional specifications. However, before we get there,
    let's speak about other roles in the team.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有基于代码的文档，TDD是最好的启用程序。到目前为止，我们只与单元（方法）一起工作。我们还没有看到如何在更高层次上应用TDD，比如，例如，功能规格。然而，在我们到达那里之前，让我们谈谈团队中的其他角色。
- en: Documentation for non-coders
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非程序员的文档
- en: Traditional testers tend to form groups completely separated from developers.
    This separation leads to an increased number of testers who are not familiar with
    code and assume that their job is to be quality checkers. They are validators
    at the end of the process and act as a kind of border police who decide what can
    be deployed and what should be returned back. There is, on the other hand, an
    increasing number of organizations that are employing testers as integral members
    of the team, with the job of ensuring that quality is built in. This latter group
    requires testers to be proficient with code. For them, using code as documentation
    is quite natural. However, what should we do with the first group? What should
    we do with testers who do not understand the code? Also, it is not only (some)
    testers that fall into this group. Managers, end-users, business representatives,
    and so on are also included. The world is full of people that cannot read and
    understand code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的测试人员倾向于形成与开发人员完全分离的团体。这种分离导致了越来越多的测试人员不熟悉代码，并假设他们的工作是质量检查。他们是流程结束时的验证者，起到了一种边境警察的作用，决定什么可以部署，什么应该退回。另一方面，越来越多的组织将测试人员作为团队的一部分，负责确保质量得到建立。后一组要求测试人员精通代码。对于他们来说，使用代码作为文档是非常自然的。然而，我们应该怎么处理第一组？对于不理解代码的测试人员，我们应该怎么办？此外，不仅（一些）测试人员属于这一组。经理、最终用户、业务代表等也包括在内。世界上充满了无法阅读和理解代码的人。
- en: We should look for a way to retain the advantages that the executable documentation
    provides, but write it in a way that can be understood by everyone. Moreover,
    in TDD fashion, we should allow everyone to participate in the creation of executable
    documentation from the very start. We should allow them to define requirements
    that we'll use to develop applications and, at the same time, to validate the
    result of that development. We need something that will define what we'll do on
    a higher-level, since low-level is already covered with unit tests. To summarize,
    we need documentation that can serve as requirements, that can be executed, that
    can validate our work, and that can be written and understood by everyone.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该寻找一种方法来保留可执行文档提供的优势，但以一种所有人都能理解的方式编写它。此外，在TDD的方式下，我们应该允许每个人从一开始就参与可执行文档的创建。我们应该允许他们定义我们将用来开发应用程序的需求，并同时验证开发结果。我们需要一些能够在更高层次上定义我们将要做什么的东西，因为低级已经通过单元测试覆盖了。总之，我们需要可以作为需求的文档，可以执行的文档，可以验证我们工作的文档，并且可以被所有人编写和理解的文档。
- en: Say hello to BDD.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 向BDD问好。
- en: Behavior-driven development
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: Behavior-driven development (BDD) is an agile process designed to keep the focus
    on stakeholder value throughout the whole project; it is a form of TDD. Specifications
    are defined in advance, the implementation is done according to those specifications,
    and they are run periodically to validate the outcome. Besides those similarities,
    there are a few differences as well. Unlike TDD, which is based on unit tests,
    BDD encourages us to write multiple specifications (called scenarios) before starting
    the implementation (coding). Even though there is no specific rule, BDD tends
    to levitate towards higher-level functional requirements. While it can be employed
    at a unit level as well, the real benefits are obtained when taking a higher approach
    that can be written and understood by everyone. The audience is another difference—BDD
    tries to empower everyone (coders, testers, managers, end users, business representatives,
    and so on).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）是一种旨在在整个项目过程中保持对利益相关者价值的关注的敏捷过程；它是TDD的一种形式。规范是提前定义的，实施是根据这些规范进行的，并定期运行以验证结果。除了这些相似之处，还有一些区别。与TDD不同，BDD鼓励我们在开始实施（编码）之前编写多个规范（称为场景）。尽管没有具体的规则，但BDD倾向于更高级的功能需求。虽然它也可以在单元级别上使用，但真正的好处是在采用可以被所有人编写和理解的更高级别方法时获得的。受众是另一个不同之处——BDD试图赋予每个人（编码人员、测试人员、经理、最终用户、业务代表等）权力。
- en: While TDD, which is based on unit level, can be described as inside-out (we
    begin with units and build up towards functionalities), BDD is often understood
    as outside-in (we start with features and go inside towards units). BDD acts as
    an **acceptance criteria** that acts as an indicator of readiness. It tells us
    when something is finished and ready for production.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于单元级别的TDD可以被描述为从内到外（我们从单元开始，逐渐构建功能），但BDD通常被理解为从外到内（我们从功能开始，逐渐向内部单元发展）。BDD充当了**验收标准**，作为准备就绪的指标。它告诉我们什么时候完成并准备投入生产。
- en: We start by defining functionalities (or behaviors), work on them by employing
    TDD with unit tests, and, once a complete behavior has finished, validate with
    BDD. One BDD scenario can take hours or even days to finish. During all that time,
    we can employ TDD and unit testing. Once we're done, we run BDD scenarios to do
    the final validation. TDD is for coders and has a very fast cycle, while BDD is
    for everyone and has a much slower turnout time. For each BDD scenario, we have
    many TDD unit tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义功能（或行为），通过使用TDD和单元测试来处理它们，一旦完成一个完整的行为，就用BDD进行验证。一个BDD场景可能需要数小时甚至数天才能完成。在此期间，我们可以使用TDD和单元测试。完成后，我们运行BDD场景进行最终验证。TDD是为编码人员设计的，具有非常快的周期，而BDD是为所有人设计的，具有更慢的周转时间。对于每个BDD场景，我们有许多TDD单元测试。
- en: At this point, you might have gotten confused about what BDD really is, so let
    us go back a bit. We'll start with the explanation of its format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能已经对BDD真正是什么感到困惑，所以让我们回顾一下。我们将从其格式的解释开始。
- en: Narrative
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叙述
- en: A BDD story consists of one narrative followed by at least one scenario. A narrative
    is only informative, and its main purpose is to provide just enough information
    that can serve as a beginning of communication between everyone involved (testers,
    business representatives, developers, analysts, and so on). It is a short and
    simple description of a feature, told from the perspective of a person who requires
    it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: BDD故事由一个叙述和至少一个场景组成。叙述只是提供信息，其主要目的是提供足够的信息，可以作为所有参与者之间沟通的开始（测试人员，业务代表，开发人员，分析师等）。它是一个简短而简单的功能描述，从需要它的人的角度讲述。
- en: 'The goal of a narrative is to answer three basic questions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 叙述的目标是回答三个基本问题：
- en: '**In order to**: What is the benefit or value of the feature that should be
    built?'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了：应该构建的功能的好处或价值是什么？
- en: '**As a**: Who needs the feature that was requested?'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**作为**：谁需要所请求的功能？'
- en: '**I want to**: What is the feature or goal that should be developed?'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想要：应该开发什么功能或目标？
- en: Once we have those questions answered, we can start defining what we think would
    be the best solution. This thinking process results in scenarios that provide
    a lower-level of detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们回答了这些问题，我们就可以开始定义我们认为最佳解决方案的内容。这种思考过程会产生提供更低级别细节的场景。
- en: Until now, we were working at a very low-level using unit tests as a driving
    force. We were specifying what should be built from the coder's perspective. We
    assumed that high-level requirements were defined earlier and that our job was
    to do the code specific to one of them. Now, let us take a few steps back and
    start from the beginning.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在低级别使用单元测试作为驱动力。我们从编码人员的角度规定了应该从哪里构建。我们假设高级需求早已定义，并且我们的工作是针对其中之一进行代码编写。现在，让我们退后几步，从头开始。
- en: 'Let us act, let''s say, as a customer or a business representative. Someone
    got this great idea and we are discussing it with the rest of the team. In short,
    we want to build an online book store. It is only an idea and we''re not even
    certain of how it will develop, so we want to work on a **Minimum Viable Product**
    (**MVP**). One of the roles that we want to explore is the one of a store administrator.
    This person should be able to add new books and update or remove the existing
    ones. All those actions should be doable, because we want this person to be able
    to manage our book store collection in an efficient way. The narrative that we
    came up with for this role is the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，比如说，作为一个客户或业务代表。有人想到了这个好主意，我们正在与团队讨论。简而言之，我们想要建立一个在线书店。这只是一个想法，我们甚至不确定它会如何发展，所以我们想要开发一个**最小可行产品**（**MVP**）。我们想要探索的角色之一是商店管理员。这个人应该能够添加新书籍，更新或删除现有的书籍。所有这些操作都应该是可行的，因为我们希望这个人能够以高效的方式管理我们的书店收藏。我们为这个角色想出的叙述如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we know what the benefit is (managing books), who needs it (`administrator`),
    and finally what the feature that should be developed is (`insert`, `update`,
    and `delete` operations). Keep in mind that this was not a detailed description
    of what should be done. The narrative's purpose is to initiate a discussion that
    will result in one or more scenarios.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了好处是什么（管理书籍），谁需要它（`管理员`），最后应该开发的功能是什么（`插入`，`更新`和`删除`操作）。请记住，这不是对应该做什么的详细描述。叙述的目的是引发一场讨论，从而产生一个或多个场景。
- en: Unlike TDD unit tests, narratives, and indeed the rest of the BDD story, can
    be written by anyone. They do not require coding skills, nor do they have to go
    into too many details. Depending on the organization, all narratives can be written
    by the same person (a business representative, product owner, customer, and so
    on) or it might be a collaborative effort by the whole team.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDD单元测试不同，叙述，实际上整个BDD故事，可以由任何人撰写。它们不需要编码技能，也不必涉及太多细节。根据组织的不同，所有叙述可以由同一个人（业务代表，产品所有者，客户等）撰写，或者可能是整个团队的协作努力。
- en: Now that we have a clearer idea regarding narratives, let us take a look at
    scenarios.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对叙述有了更清晰的想法，让我们来看看场景。
- en: Scenarios
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: A narrative acts as a communication enabler, and scenarios are the result of
    that communication. They should describe interactions that the role (specified
    in the *Narrative *section) has with the system. Unlike unit tests, which were
    written as code by developers for developers, BDD scenarios should be defined
    in plain language and with minimum technical details so that all those involved
    with the project (developers, testers, designers, managers, customers, and so
    on) can have a common understanding about behaviors (or features) that will be
    added to the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 叙述作为一种沟通促进者，场景是该沟通的结果。它们应该描述角色（在*叙述*部分中指定）与系统的交互。与由开发人员为开发人员编写的代码不同，BDD场景应该用简单的语言和最少的技术细节来定义，以便项目中的所有参与者（开发人员，测试人员，设计师，经理，客户等）都能对将添加到系统中的行为（或功能）有共同的理解。
- en: Scenarios act as the acceptance criteria of the narrative. Once all scenarios
    related to the narrative are run successfully, the job can be considered done.
    Each scenario is very similar to a unit test, with the main difference being the
    scope (one method against a whole feature) and the time it takes to implement
    it (a few seconds or minutes against a few hours or even days). Similarly to unit
    tests, scenarios drive the development; they are defined first.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 场景充当叙述的验收标准。一旦与叙述相关的所有场景都成功运行，工作就可以被认为完成了。每个场景非常类似于一个单元测试，主要区别在于范围（一个方法对整个功能）和实现所需的时间（几秒钟或几分钟对几个小时甚至几天）。与单元测试类似，场景推动开发；它们首先被定义。
- en: Each scenario consists of a description and one or more steps that start with
    the words `Given`, `When`, or `Then`. The description is short and only informative.
    It helps us to understand, at a glance, what the scenario does. Steps, on the
    other hand, are a sequence of the preconditions, events, and expected outcomes
    of the scenario. They help us define the behavior unambiguously and it's easy
    to translate them to automated tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景由描述和一个或多个以“给定”、“当”或“那么”开头的步骤组成。描述简短且仅供参考。它帮助我们一目了然地理解场景的功能。另一方面，步骤是场景的前提条件、事件和预期结果的序列。它们帮助我们明确定义行为，并且很容易将它们转化为自动化测试。
- en: Throughout this chapter, we'll focus more on the technical aspects of BDD and
    the ways they fit into the developer's mindset. For broader usage of BDD and much
    deeper discussion, consult the book, *Specification by Example:* *How Successful
    Teams Deliver the Right Software* by Gojko Adzic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更多地关注BDD的技术方面以及它们如何融入开发者的思维方式。要了解更广泛的BDD使用和更深入的讨论，请参考Gojko Adzic的书《实例说明：成功团队如何交付正确的软件》。
- en: 'The `Given` step defines a context or preconditions that need to be fulfilled
    for the rest of the scenario to be successful. Going back to the book''s administration
    narrative, one such precondition might be the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “给定”步骤定义了上下文或前提条件，需要满足这些条件才能成功执行场景的其余部分。回到书籍管理的叙述，一个这样的前提条件可能是：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a very simple but pretty necessary precondition. Our website might have
    many pages, and we need to make sure that the user is on the correct screen before
    we perform any action.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单但非常必要的前提条件。我们的网站可能有很多页面，我们需要确保用户在执行任何操作之前处于正确的屏幕上。
- en: 'The `When` step defines an action or some kind of an event. In our narrative,
    we defined that the `administrator` should be able to `add`, `update`, and `remove`
    books. Let''s see what should be an action related to, for example, the `delete`
    operation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “当”步骤定义了一个动作或某种事件。在我们的叙述中，我们定义了“管理员”应该能够“添加”、“更新”和“删除”书籍。让我们看看与“删除”操作相关的动作应该是什么：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we multiplied actions defined with the `When` steps. First,
    we should select a book and then we should click on the `deleteBook` button. In
    this case, we used an ID (`deleteBook`) instead of text (Delete the book) to define
    the button that should be clicked. In most cases, IDs are preferable because they
    provide multiple benefits. They are unique (only one ID can exist on a given screen),
    they provide clear instructions for developers (create an element with an ID `deleteBook`),
    and they are not affected by other changes on the same screen. The text of an
    element can easily change; if this happens, all scenarios that used it would fail
    as well. In the case of websites, an alternative could be XPath. However, avoid
    this whenever possible. It tends to fail with the smallest change to the HTML
    structure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用“当”步骤定义了多个操作。首先，我们应该选择一本书，然后我们应该点击“deleteBook”按钮。在这种情况下，我们使用了一个ID（“deleteBook”）来定义应该点击的按钮，而不是文本（删除书籍）。在大多数情况下，ID更可取，因为它们提供了多种好处。它们是唯一的（在给定屏幕上只能存在一个ID），它们为开发人员提供清晰的指示（创建一个带有ID“deleteBook”的元素），并且它们不受同一屏幕上其他更改的影响。元素的文本可以很容易地改变；如果发生这种情况，使用它的所有场景也会失败。在网站的情况下，一个替代方案可能是XPath。但是，尽量避免这种情况。它往往会因HTML结构的最小更改而失败。
- en: Similarly to unit tests, scenarios should be reliable and fail when a feature
    is not yet developed or when there is a real problem. Otherwise, it is a natural
    reaction to start ignoring specifications when they produce false negatives.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试类似，场景应该是可靠的，并且在功能尚未开发或出现真正问题时失败。否则，当它们产生错误的负面影响时，开始忽略规范是一种自然反应。
- en: 'Finally, we should always end the scenario with some kind of verification.
    We should specify the desired outcome of actions that were performed. Following
    the same scenario, our `Then` step could be the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该始终以某种验证结束场景。我们应该指定已执行操作的期望结果。按照相同的场景，我们的“那么”步骤可能是以下内容：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This outcome strikes a balance between providing just enough data and not going
    into design details. We could have, for example, mentioned the database or, even
    more specifically, MongoDB. However, in many cases, that information is not important
    from the behavioral point of view. We should simply confirm that the book is removed
    from the catalog, no matter where it is stored.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果在提供足够的数据和不涉及设计细节之间取得了平衡。例如，我们可以提到数据库，甚至更具体地说是MongoDB。然而，在许多情况下，从行为角度来看，这些信息并不重要。我们只需确认书籍已从目录中删除，无论它存储在哪里。
- en: Now that we are familiar with the BDD story format, let us write the book store
    BDD story.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了BDD故事格式，让我们写书店BDD故事。
- en: The book store BDD story
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书店BDD故事
- en: Before we start, clone the code that is available at [https://bitbucket.org/vfarcic/tdd-java-ch08-books-store](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store).
    It is an empty project that we'll use throughout this chapter. As with previous
    chapters, it contains branches for each section, in case you miss something.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请克隆位于[https://bitbucket.org/vfarcic/tdd-java-ch08-books-store](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store)的可用代码。这是一个我们将在本章中使用的空项目。与以前的章节一样，它包含了每个部分的分支，以防您错过了什么。
- en: We'll write one BDD story that will be in a pure text format, in plain English
    and without any code. That way, all stakeholders can participate and get involved
    independently of their coding proficiency. Later on, we'll see how to automate
    the story we're writing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个BDD故事，它将以纯文本格式、用简单的英语编写，没有任何代码。这样，所有利益相关者都可以参与并独立参与，而不受其编码能力的限制。稍后，我们将看到如何自动化我们正在编写的故事。
- en: 'Let us start by creating a new file called `administration.story` inside the
    `stories` directory:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在“stories”目录中创建一个名为“administration.story”的新文件：
- en: '![](img/e029d960-8a3b-417d-a3e6-0d8ce2b31304.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e029d960-8a3b-417d-a3e6-0d8ce2b31304.png)'
- en: 'We already have the narrative that we wrote earlier, so we''ll build on top
    of that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了之前写的叙述，所以我们将在此基础上进行构建：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll be using JBehave format for writing stories. More details regarding JBehave
    are coming soon. Until then, visit [http://jbehave.org/](http://jbehave.org/)
    for more info.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JBehave格式来编写故事。有关JBehave的更多详细信息即将推出。在此之前，请访问[http://jbehave.org/](http://jbehave.org/)获取更多信息。
- en: A narrative always starts with the `Narrative` line and is followed with the
    `In order to`, `As a`, and `I want to lines`. We already discussed the meaning
    of each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 叙述总是以`Narrative`行开始，然后是`In order to`、`As a`和`I want to`行。我们已经讨论过它们各自的含义。
- en: 'Now that we know the answers to why, who, and what, it is time to sit with
    the rest of the team and discuss possible scenarios. We''re still not talking
    about steps (`Given`, `When`, and `Then`), but simply what would be the outlines
    or short descriptions of the potential scenarios. The list could be the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了为什么、谁和什么的答案，是时候和团队的其他成员坐下来讨论可能的场景了。我们还没有谈论步骤（`Given`、`When`和`Then`），而只是潜在场景的概述或简短描述。列表可能如下：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're following the JBehave syntax by using `Scenario` followed by a short description.
    There is no reason to go into detail at this stage; the purpose of this stage
    is to serve as a quick brainstorming session. In this case, we came up with those
    five scenarios. The first one should define fields of the form that we'll use
    to administer books. The rest of the scenarios are trying to define different
    administrative tasks. There's nothing truly creative about them. We're supposed
    to develop an MVP of a very simple application. If it proves to be successful,
    we can expand and truly employ our creativity. With the current objective, the
    application will be simple and straightforward.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循JBehave语法，使用`Scenario`后跟一个简短的描述。在这个阶段没有必要详细讨论；这个阶段的目的是作为一个快速的头脑风暴会议。在这种情况下，我们想出了这五个场景。第一个应该定义我们将用来管理书籍的表单字段。其余的场景试图定义不同的管理任务。它们都没有什么真正创造性的。我们应该开发一个非常简单的应用的MVP。如果证明成功，我们可以扩展并真正发挥我们的创造力。根据当前的目标，应用将是简单而直接的。
- en: 'Now that we know what our scenarios are, in general terms, it is time to properly
    define each of them. Let us start working on the first one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的场景是什么，总体上，是时候适当地定义每一个了。让我们开始处理第一个：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This scenario does not contain any actions; there are no `When` steps. It can
    be considered a sanity check. It tells developers what fields should be present
    in the book form. Through those fields, we can decide what data schema we'll use.
    IDs are descriptive enough that we know what each field is about (one ID and three
    text fields). Keep in mind that this scenario (and those that will follow) are
    pure texts without any code. The main advantage is that anyone can write them,
    and we'll try to keep it that way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景不包含任何动作；没有`When`步骤。它可以被视为一个健全性检查。它告诉开发人员书籍表单中应该有哪些字段。通过这些字段，我们可以决定使用什么数据模式。ID足够描述性，我们知道每个字段是关于什么的（一个ID和三个文本字段）。请记住，这个场景（以及接下来的场景）都是纯文本，没有任何代码。主要优点是任何人都可以编写它们，我们会尽量保持这种方式。
- en: 'Let''s see what the second scenario should look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个场景应该是什么样子的：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This scenario is a bit better formed than the previous one. There is a clear
    prerequisite (`user` should be on a certain screen); there are several actions
    (click on the `newBook` button, fill in the form, and click on the `saveBook`
    button); finally, there is the verification of the outcome (book is stored).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景比之前的一个好一点。有一个明确的前提条件（`user`应该在某个屏幕上）；有几个动作（点击`newBook`按钮，填写表单，点击`saveBook`按钮）；最后是结果的验证（书已存储）。
- en: 'The rest of the scenarios are as follows (since they all work in a similar
    way, we feel that there is no reason to explain each of them separately):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的场景如下（因为它们都以类似的方式工作，我们觉得没有必要单独解释每一个）：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only thing that might be worth noticing is that we are using the same steps
    when appropriate (for example, `When user selects a book`). Since we'll soon try
    to automate all those scenarios, having the same text for the same step will save
    us some time by duplicating the code. It is important to strike a balance between
    the freedom to express scenarios in the best possible way and the ease of automation.
    There are a few more things that we can modify in our existing scenarios, however,
    before we refactor them, let us introduce you to JBehave.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一值得注意的是，当合适时我们使用相同的步骤（例如，`When user selects a book`）。因为我们很快会尝试自动化所有这些场景，使用相同的步骤文本将节省我们一些时间，避免重复编写代码。在表达场景的最佳方式和自动化的便利性之间保持平衡是很重要的。我们可以修改现有场景中的一些内容，但在重构它们之前，让我们先介绍一下JBehave。
- en: The source code can be found in the `00-story` branch of the `tdd-java-ch08-books-store`
    Git repository, at [https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/00-story](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/00-story).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`00-story`分支的`tdd-java-ch08-books-store` Git存储库中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/00-story](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/00-story)。
- en: JBehave
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JBehave
- en: There are two major components required for JBehave to run BDD stories—runners
    and steps. A runner is a class that will parse the story, run all scenarios, and
    generate a report. Steps are code methods that match steps written in scenarios.
    The project already contains all Gradle dependencies, so we can dive right into
    creating the JBehave runner.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JBehave运行BDD故事需要两个主要组件——运行器和步骤。运行器是一个类，它将解析故事，运行所有场景，并生成报告。步骤是与场景中编写的步骤匹配的代码方法。项目已经包含了所有Gradle依赖项，所以我们可以直接开始创建JBehave运行器。
- en: JBehave runner
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JBehave运行器
- en: JBehave is no exception to the rule that every type of test needs a runner.
    In the previous chapters, we used JUnit and TestNG runners. While neither of those
    needed any special configuration, JBehave is a bit more demanding and forces us
    to create a class that will hold all the configuration required for running stories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JBehave也不例外，每种类型的测试都需要一个运行器。在前几章中，我们使用了JUnit和TestNG运行器。虽然这两者都不需要任何特殊配置，但JBehave要求我们创建一个类，其中包含运行故事所需的所有配置。
- en: 'The following is the `Runner` code that we''ll use throughout this chapter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中使用的`Runner`代码：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is very uneventful code, so we'll comment only on a few important parts.
    The overridden method `storyPaths` has the location to our story files set to
    the `stories/**/*.story` path. This is a standard Apache Ant ([http://ant.apache.org/](http://ant.apache.org/))
    syntax that, when translated to plain language, means that any file ending with
    `.story` inside the `stories` directory or any subdirectory (`**`) will be included.
    Another important overridden method is `stepsFactory`, which is used to set classes
    containing the steps definition (we'll work with them very soon). In this case,
    we set it to the instance of a single class called `Steps` (the repository already
    contains an empty class that we'll use later on).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常平淡无奇的代码，所以我们只会对一些重要的部分进行评论。重写的`storyPaths`方法将我们的故事文件位置设置为`stories/**/*.story`路径。这是标准的Apache
    Ant ([http://ant.apache.org/](http://ant.apache.org/))语法，翻译成普通语言意味着`stories`目录或任何子目录（`**`）中以`.story`结尾的任何文件都将被包括在内。另一个重要的重写方法是`stepsFactory`，用于设置包含步骤定义的类（我们很快就会与它们一起工作）。在这种情况下，我们将其设置为一个名为`Steps`的单个类的实例（存储库已经包含了一个我们稍后会使用的空类）。
- en: The source code can be found in the `01-runner` branch of the `tdd-java-ch08-books-store`
    Git repository, at [https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/01-runner](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/01-runner).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`01-runner`分支的` tdd-java-ch08-books-store` Git存储库中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/01-runner](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/01-runner)。
- en: Now that we have our runner done, it is time to fire it up and see what the
    result is.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的运行器已经完成，是时候启动它并查看结果了。
- en: Pending steps
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待定步骤
- en: 'We can run our scenarios with the following Gradle command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下Gradle命令运行我们的情景：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Gradle only runs tasks that changed from the last execution. Since our source
    code will not always change (we often modify only stories in text format), the
    `clean` task is required to be run before the `test` so that the cache is removed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle只运行自上次执行以来发生变化的任务。由于我们的源代码不会总是改变（我们通常只修改文本格式的故事），因此需要在`test`之前运行`clean`任务以删除缓存。
- en: JBehave creates a nice report for us and puts it into the `target/jbehave/view`
    directory. Open the `reports.html` file in your favorite browser.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JBehave为我们创建了一个漂亮的报告，并将其放入`target/jbehave/view`目录。在您喜欢的浏览器中打开`reports.html`文件。
- en: The initial page of the report displays a list of our stories (in our case,
    only Administration) and two predefined ones called BeforeStories and AfterStories.
    Their purpose is similar to the `@BeforeClass` and `@AfterClass` JUnit annotated
    methods. They are run before and after stories, and can be useful for setting
    up and tearing down data, servers, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的初始页面显示了我们故事的列表（在我们的情况下，只有Administration）和两个预定义的故事，称为BeforeStories和AfterStories。它们的目的类似于`@BeforeClass`和`@AfterClass`
    JUnit注解方法。它们在故事之前和之后运行，并且可以用于设置和拆除数据、服务器等。
- en: 'This initial reports page shows that we have five scenarios and all of them
    are in the Pending status. This is JBehave''s way of telling us that they were
    neither successful nor failed, but that there is code missing behind the steps
    we used:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始报告页面显示我们有五种情景，它们都处于待定状态。这是JBehave告诉我们的方式，它们既不成功也不失败，而是我们使用的步骤背后缺少代码：
- en: '![](img/71212836-767b-49ff-babc-8b3caef3562f.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71212836-767b-49ff-babc-8b3caef3562f.png)'
- en: 'The last column in each row contains a link that allows us to see details of
    each story:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的最后一列包含一个链接，允许我们查看每个故事的详细信息：
- en: '![](img/64b19c4e-c087-4791-be7a-eb538eeeaeb0.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64b19c4e-c087-4791-be7a-eb538eeeaeb0.png)'
- en: In our case, all the steps are marked as pending. JBehave even puts a suggestion
    of a method that we need to create for each pending step.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，所有的步骤都标记为待定。JBehave甚至提出了我们需要为每个待定步骤创建的方法的建议。
- en: To recapitulate, at this point, we wrote one story with five scenarios. Each
    of those scenarios is equivalent to a specification that will be used both as
    a definition that should be developed and to verify that the development was done
    correctly. Each of those scenarios consists of several steps that define preconditions
    (`Given`), actions (`When`), and the expected outcome (`Then`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在这一点上，我们编写了一个包含五个情景的故事。这些情景中的每一个都相当于一个规范，既应该被开发，也应该用来验证开发是否正确完成。这些情景中的每一个都由几个步骤组成，定义了前提条件（`Given`）、行动（`When`）和预期结果（`Then`）。
- en: Now it is time, to write the code behind our steps. However, before we start
    coding, let us get introduced to Selenium and Selenide.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写我们步骤背后的代码了。然而，在我们开始编码之前，让我们先介绍一下Selenium和Selenide。
- en: Selenium and Selenide
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium和Selenide
- en: Selenium is a set of drivers that can be used to automate browsers. We can use
    them to manipulate browsers and page elements by, for example, clicking on a button
    or a link, filling up a form field, opening a specific URL, and so on. There are
    drivers for almost any browser—Android, Chrome, FireFox, Internet Explorer, Safari,
    and many more. Our favorite is PhantomJS, which is a headless browser that works
    without any UI. Running stories with it is faster than with traditional browsers,
    and we often use it to get fast feedback on the readiness of web applications.
    If it works as expected, we can proceed and try it out in all the different browsers
    and versions that our application is supposed to support.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一组可以用来自动化浏览器的驱动程序。我们可以使用它们来操作浏览器和页面元素，例如点击按钮或链接，填写表单字段，打开特定的URL等等。几乎所有浏览器都有相应的驱动程序，包括Android、Chrome、FireFox、Internet
    Explorer、Safari等等。我们最喜欢的是PhantomJS，它是一个无界面的浏览器，比传统浏览器运行速度更快，我们经常用它来快速获取关于Web应用程序准备就绪的反馈。如果它按预期工作，我们可以继续在所有不同的浏览器和版本中尝试它，以确保我们的应用程序能够支持。
- en: More information about Selenium can be found at [http://www.seleniumhq.org/](http://www.seleniumhq.org/),
    with the list of supported drivers at [http://www.seleniumhq.org/projects/webdriver/](http://www.seleniumhq.org/projects/webdriver/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Selenium的更多信息可以在[http://www.seleniumhq.org/](http://www.seleniumhq.org/)找到，支持的驱动程序列表在[http://www.seleniumhq.org/projects/webdriver/](http://www.seleniumhq.org/projects/webdriver/)。
- en: 'While Selenium is great for automating browsers, it has its downsides, one
    of them being that it is operating at a very low-level. Clicking on a button,
    for example, is easy and can be accomplished with a single line of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Selenium非常适合自动化浏览器，但它也有缺点，其中之一是它在非常低的级别上操作。例如，点击按钮很容易，可以用一行代码完成：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the element with the ID `myLink` does not exist, Selenium will throw an exception
    and the test will fail. While we want our tests to fail when the expected element
    does not exist, in many cases it is not so simple. For example, our page might
    load dynamically with that element appearing only after an asynchronous request
    to the server got a response. For this reason, we might not only want to click
    on that element, but also wait until it is available, and fail only if a timeout
    is reached. While this can be done with Selenium, it is tedious and error prone.
    Besides, why would we do the work that is already done by others? Say hello to
    Selenide.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ID为`myLink`的元素不存在，Selenium将抛出异常，测试将失败。虽然我们希望当预期的元素不存在时测试失败，但在许多情况下并不那么简单。例如，我们的页面可能会在异步请求服务器得到响应后才动态加载该元素。因此，我们可能不仅希望点击该元素，还希望等待直到它可用，并且只有在超时时才失败。虽然这可以用Selenium完成，但是这很繁琐且容易出错。此外，为什么我们要做别人已经做过的工作呢？让我们来认识一下Selenide。
- en: Selenide ([http://selenide.org/](http://selenide.org/)) is a wrapper around
    Selenium `WebDrivers` with a more concise API, support for Ajax, selectors that
    use JQuery style, and so on. We'll use Selenide for all our Web steps, and you'll
    get more familiar with it soon.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Selenide（[http://selenide.org/](http://selenide.org/)）是对Selenium `WebDrivers`的封装，具有更简洁的API、对Ajax的支持、使用JQuery风格的选择器等等。我们将在所有的Web步骤中使用Selenide，您很快就会更加熟悉它。
- en: Now, let us write some code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们写一些代码。
- en: JBehave steps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JBehave步骤
- en: Before we start writing steps, install the PhantomJS browser. The instructions
    for your operating system can be found at [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写步骤之前，安装PhantomJS浏览器。您可以在[http://phantomjs.org/download.html](http://phantomjs.org/download.html)找到有关您操作系统的说明。
- en: 'With PhantomJS installed, it is time to specify a few Gradle dependencies:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了PhantomJS后，现在是时候指定一些Gradle依赖了：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You are already familiar with JUnit and JBehave Core, which was set up earlier.
    Two new additions are Selenide and PhantomJS. Refresh Gradle dependencies so that
    they are included in your IDEA project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了JUnit和之前设置的JBehave Core。两个新的添加是Selenide和PhantomJS。刷新Gradle依赖项，以便它们包含在您的IDEA项目中。
- en: 'Now, it is time to add the PhantomJS `WebDriver` to our `Steps` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将PhantomJS `WebDriver`添加到我们的`Steps`类中了：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're utilizing the `@BeforeStory` annotation to define the method that we're
    using to do some basic setup. If a driver is not already specified, we're setting
    it up to be `PhantomJSDriver`. Since this application will look different on smaller
    devices (phones, tablets, and so on), it is important that we specify clearly
    what the size of the screen is. In this case, we're setting it to be a reasonable
    desktop/laptop monitor screen resolution of 1024 x 768.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@BeforeStory`注解来定义我们用来进行一些基本设置的方法。如果驱动程序尚未指定，我们将设置为`PhantomJSDriver`。由于这个应用程序在较小的设备（手机、平板等）上会有不同的外观，因此我们需要清楚地指定屏幕的尺寸。在这种情况下，我们将其设置为合理的桌面/笔记本显示器分辨率1024
    x 768。
- en: 'With setup out of the way, let us code our first pending step. We can simply
    copy and paste the first method `JBehave` suggested for us in the report:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，让我们编写我们的第一个待定步骤。我们可以简单地复制并粘贴报告中JBehave为我们建议的第一个方法：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Imagine that our application will have a link that will open the book's screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的应用程序将有一个链接，点击它将打开书的界面。
- en: 'To do that, we''ll need to perform two steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要执行两个步骤：
- en: Open the website home page.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开网站主页。
- en: Click on the books link in the menu.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击菜单中的书籍链接。
- en: We'll specify that this link will have the ID `books`. IDs are very important
    as they allow us to easily locate an element on the page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定这个链接的ID为`books`。ID非常重要，因为它们可以让我们轻松地在页面上定位一个元素。
- en: 'The steps we described earlier can be translated to the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的步骤可以翻译成以下代码：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We're assuming that our application will run on the `9001` port on the `localhost`.
    Therefore, we are first opening the home page URL and then clicking on the element
    with the ID `books`. Selenide/JQuery syntax for specifying an ID is `#`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的应用程序将在`localhost`的`9001`端口上运行。因此，我们首先打开主页的URL，然后点击ID为`books`的元素。Selenide/JQuery指定ID的语法是`#`。
- en: If we run our runner again, we'd see that the first step failed and the rest
    is still in the `Pending` state. Now, we are in the red state of the Red-Green-Refactor
    cycle.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的运行器，我们会看到第一步失败了，其余的仍然处于“待定”状态。现在，我们处于红色状态的红-绿-重构周期中。
- en: 'Let us continue working on the rest of the steps used in the first scenario.
    The second one can be the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续完成第一个场景中使用的其余步骤。第二个可以是以下内容：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The third one is almost the same, so we can refactor the previous method and
    convert an element ID into a variable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个步骤几乎相同，所以我们可以重构前一个方法，并将元素ID转换为变量：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this change, all the steps in the first scenario are done. If we run our
    tests again, the result is the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，第一个场景中的所有步骤都完成了。如果我们再次运行我们的测试，结果如下：
- en: '![](img/fba0f8bb-160e-419e-bdcb-e7279cfa6e91.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fba0f8bb-160e-419e-bdcb-e7279cfa6e91.png)'
- en: The first step failed since we did not even start working on the implementation
    of our book store application. Selenide has a nice feature that creates a screenshot
    of the browser every time there is a failure. We can see the path in the report.
    The rest of the steps are in the not performed state since the execution of the
    scenario stopped on failure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步失败了，因为我们甚至还没有开始实现我们的书店应用程序。Selenide有一个很好的功能，每次失败时都会创建浏览器的截图。我们可以在报告中看到路径。其余的步骤处于未执行状态，因为场景的执行在失败时停止了。
- en: What should be done next depends on the structure of the team. If the same person
    is working both on functional tests and the implementation, he could start working
    on the implementation and write just enough code to make this scenario pass. In
    many other situations, separate people are working on the functional specification
    and the implementation code. In that case, one could continue working on the missing
    steps for the rest of the scenarios, while the other would start working on the
    implementation. Since all scenarios are already written in text form, a coder
    already knows what should be done and the two can work in parallel. We'll take
    the former route and write the code for the rest of the pending steps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事取决于团队的结构。如果同一个人既负责功能测试又负责实现，他可以开始实现并编写足够的代码使该场景通过。在许多其他情况下，不同的人负责功能规格和实现代码。在这种情况下，一个人可以继续为其余场景编写缺失的步骤，而另一个人可以开始实现。由于所有场景已经以文本形式编写，编码人员已经知道应该做什么，两者可以并行工作。我们将选择前一种方式，并为其余待办步骤编写代码。
- en: 'Let''s go through the next scenario:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一个场景：
- en: '![](img/7764ae22-8928-422f-bb9a-84509441b1a3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7764ae22-8928-422f-bb9a-84509441b1a3.png)'
- en: We already have half of the steps done from the previous scenario, so there
    are only two pending. After we click on the `newBook` button, we should set some
    values to the form, click on the `saveBook` button, and verify that the book was
    stored correctly. We can do the last part by checking whether it appeared in the
    list of available books.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了上一个场景中一半的步骤，所以只剩下两个待办事项。在我们点击`newBook`按钮之后，我们应该给表单设置一些值，点击`saveBook`按钮，并验证书籍是否被正确存储。我们可以通过检查它是否出现在可用书籍列表中来完成最后一部分。
- en: 'The missing steps can be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的步骤可以是以下内容：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second step assumes that each of the available books will have an ID in
    the format `book[ID]`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步假设每本可用的书都将以`book[ID]`的格式有一个ID。
- en: 'Let us take a look at the next scenario:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一个场景：
- en: '![](img/fe09e624-4f55-4b09-bb55-9610baf3e64b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe09e624-4f55-4b09-bb55-9610baf3e64b.png)'
- en: 'Like in the previous scenario, there are two steps pending development. We
    need to have a way to select a book and to verify that data in the form is correctly
    populated:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个场景中一样，还有两个待开发的步骤。我们需要有一种方法来选择一本书，并验证表单中的数据是否正确填充：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These two methods are interesting because they not only specify the expected
    behavior (when a specific book link is clicked, then a form with its data is displayed),
    but also expect certain data to be available for testing. When this scenario is
    run, a book with the ID `1`, title `TDD for Java Developers`, author `Viktor Farcic`,
    and description `Cool book!` should already exist. We can choose to add that data
    to the database or use a mock server that will serve the predefined values. No
    matter what the choice of how to set test data is, we can finish with this scenario
    and jump into the next one:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法很有趣，因为它们不仅指定了预期的行为（当点击特定书籍链接时，显示带有其数据的表单），还期望某些数据可用于测试。当运行此场景时，ID为`1`的书，标题为`TDD
    for Java Developers`，作者为`Viktor Farcic`，描述为`Cool book!`的书应该已经存在。我们可以选择将这些数据添加到数据库中，或者使用一个将提前定义的值提供给测试的模拟服务器。无论如何选择设置测试数据的方式，我们都可以完成这个场景并进入下一个场景：
- en: '![](img/44e20820-5033-42f1-9291-b2c7da917642.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44e20820-5033-42f1-9291-b2c7da917642.png)'
- en: 'The implementation of the pending steps could be the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 待办步骤的实现可以是以下内容：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, there is only one scenario left:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只剩下一个场景：
- en: '![](img/6d88b83f-ea0e-48ba-a0b4-d63de3bb12d9.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d88b83f-ea0e-48ba-a0b4-d63de3bb12d9.png)'
- en: 'We can verify that a book is removed by verifying that it is not in the list
    of available books:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过验证它不在可用书籍列表中来验证书籍是否已被移除：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We're finished with the steps code. Now, the person who is developing the application
    not only has requirements but also has a way to validate each behavior (scenario).
    He can move through the Red-Green-Refactor cycle one scenario at a time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了步骤代码。现在，开发应用程序的人不仅有需求，还有一种验证每个行为（场景）的方法。他可以逐个场景地通过红-绿-重构周期。
- en: 'The source code can be found in the `02-steps` branch of the `tdd-java-ch08-books-store`
    Git repository: [https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/02-steps](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/02-steps).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch08-books-store` Git存储库的`02-steps`分支中找到：[https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/02-steps](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/02-steps)。
- en: Final validation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终验证
- en: Let us imagine that a different person worked on the code that should fulfill
    the requirements set by our scenarios. This person picked one scenario at the
    time, developed the code, ran that scenario, and confirmed that his implementation
    was correct. Once the implementation of all scenarios has been done, it is time
    to run the whole story and do the final validation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个不同的人在代码上工作，应该满足我们的场景设定的要求。这个人一次选择一个场景，开发代码，运行该场景，并确认他的实现是正确的。一旦所有场景的实现都完成了，就是运行整个故事并进行最终验证的时候了。
- en: For that matter, the application has been packed as a `Docker` file and we have
    prepared a virtual machine with Vagrant for executing the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，应用程序已经打包为`Docker`文件，并且我们已经为执行应用程序准备了一个带有Vagrant的虚拟机。
- en: 'Check out the branch at [https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/03-validation](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/03-validation)
    and run Vagrant:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 查看分支[https://bitbucket.org/vfarcic/tdd-java-ch08-books-store/branch/03-validation](https://bitbucket.org/vfarcic/tdd-java-ch07-books-store/branch/03-validation)并运行Vagrant：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be similar to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once Vagrant is finished, we can see the application by opening `http://localhost:9001`
    in our browser of choice:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Vagrant完成，我们可以通过在我们选择的浏览器中打开`http://localhost:9001`来查看应用程序：
- en: '![](img/f012b0d2-fd07-4234-923f-06243a8e6122.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f012b0d2-fd07-4234-923f-06243a8e6122.png)'
- en: 'Now, let us run our scenarios again:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行我们的场景：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time there were no failures and all scenarios ran successfully:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次没有失败，所有场景都成功运行了：
- en: '![](img/cf336342-f442-4174-8bf8-ad5eb38eafdc.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf336342-f442-4174-8bf8-ad5eb38eafdc.png)'
- en: Once all scenarios are passing, we meet the acceptance criteria and the application
    can be delivered to production.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有场景都通过，我们就满足了验收标准，应用程序就可以交付到生产环境中。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: BDD, in its essence, is a flavor of TDD. It follows the same basic principle
    of writing tests (scenarios) before the implementation code. It drives the development
    and helps to us better understand what should be done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: BDD，本质上是TDD的一种变体。它遵循编写测试（场景）在实现代码之前的相同基本原则。它推动开发并帮助我们更好地理解应该做什么。
- en: One of the major differences is the life cycle duration. While with TDD, which
    is based on unit tests, we're moving from red to green very fast (in minutes if
    not seconds) BDD often takes a higher-level approach that might require hours
    or days until we get from the red to the green state. Another important difference
    is the audience. While unit tests-based TDD is done by developers for developers,
    BDD intends to involve everyone through its ubiquitous language.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的区别是生命周期持续时间。虽然TDD是基于单元测试的，我们从红色到绿色的转变非常快（如果不是秒数，就是分钟），BDD通常采用更高级别的方法，可能需要几个小时甚至几天，直到我们从红色到绿色状态。另一个重要的区别是受众。虽然基于单元测试的TDD是开发人员为开发人员完成的，但BDD意图通过其无处不在的语言让每个人都参与其中。
- en: While a whole book can be written on this subject, our intention was to give
    you just enough information so that you can investigate BDD further.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然整本书都可以写关于这个主题，我们的意图是给你足够的信息，以便你可以进一步调查BDD。
- en: Now it is time to take a look at legacy code and how to adapt it and make it
    more TDD friendly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一看遗留代码以及如何使其更适合TDD了。
