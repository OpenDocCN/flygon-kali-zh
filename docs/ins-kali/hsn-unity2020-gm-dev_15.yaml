- en: '*Chapter 15*: Physics Collisions and Health System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：物理碰撞和健康系统'
- en: As games try to simulate real-world behaviors, one important aspect to simulate
    is physics, which dictates how Objects move and how they collide with each other,
    such as the collision of players and walls or bullets and enemies. Physics can
    be difficult to control due to the myriad of reactions that can happen after a
    collision, so we will learn how to properly configure it to obtain a semi-accurate
    Physics, which will generate the desired arcade movement feeling but get collisions
    working—after all, sometimes, real life is not as interesting as videogames.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏试图模拟现实世界的行为，模拟物理是一个重要的方面，它决定了对象如何移动以及它们如何相互碰撞，比如玩家和墙壁的碰撞或子弹和敌人的碰撞。由于碰撞后可能发生的各种反应，物理可能很难控制，因此我们将学习如何正确配置它以获得半准确的物理效果，这将产生期望的街机运动感觉，但会使碰撞生效——毕竟，有时候现实生活并不像视频游戏那样有趣。
- en: 'In this chapter, we will examine the following collision concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下碰撞概念：
- en: Configuring Physics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置物理
- en: Detecting collisions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Moving with Physics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: First, we will learn how to properly configure Physics, a step needed for the
    collisions between Objects to be detected by our scripts, using new events we
    are also going to learn. Then, we are going to discuss the difference between
    moving with `Transform`, as we have done so far, and moving with Rigidbody and
    the pros and cons of each version. Let's start discussing Physics settings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何正确配置物理，这是检测对象之间碰撞的必要步骤，我们将使用新的事件来学习。然后，我们将讨论使用`Transform`移动和使用Rigidbody移动之间的区别，以及每个版本的优缺点。让我们开始讨论物理设置。
- en: Configuring Physics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置物理
- en: The Unity's Physics system is prepared to cover a great range of possible gameplay
    applications, so properly configuring it is important to get the desired result.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理系统准备好覆盖各种可能的游戏应用，因此正确配置它对于获得期望的结果非常重要。
- en: 'In this section, we will examine the following Physics settings concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下物理设置概念：
- en: Setting shapes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置形状
- en: Physics Object types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: Filtering collisions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤碰撞
- en: We are going to start learning about the different kinds of colliders that Unity
    offers, to then learn about different ways to configure those to detect different
    kinds of Physics reactions (collisions and triggers). Finally, we will discuss
    how to ignore collisions between specific Objects to prevent situations such as
    the Player's bullets damaging the Player.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始学习Unity提供的不同类型的碰撞器，然后学习不同的配置方式来检测不同类型的物理反应（碰撞和触发）。最后，我们将讨论如何忽略特定对象之间的碰撞，以防止玩家的子弹伤害玩家等情况发生。
- en: Setting shapes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置形状
- en: At the beginning of this book, we learned that Objects usually have two shapes,
    the visual shape, which is basically the 3D mesh, and the physical one, the collider,
    the one that the Physics system will use to calculate collisions. Remember that
    the idea of this is to allow you to have a highly detailed visual model while
    having a simplified Physics shape to increase the performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们学到对象通常有两种形状，一种是视觉形状，基本上就是3D网格，另一种是物理形状，也就是碰撞器，物理系统将使用它来计算碰撞。请记住，这样做的目的是让你拥有高度详细的视觉模型，同时拥有简化的物理形状以提高性能。
- en: 'Unity has several types of colliders, so here we will recap the common ones,
    starting with the primitive types, that is, Box, Sphere, and Capsule. These shapes
    are the cheapest ones (in terms of performance) to detect collisions due to the
    fact that the collisions between them are done via mathematical formulas, unlike
    other colliders such as the Mesh Collider, which allows you to use any mesh as
    the physics body of the Object, but with a higher cost and some limitations. The
    idea is that you should use a primitive type to represent your Objects or a combination
    of them, for example, a plane could be done with two Box Colliders, one for the
    body and the other one for the wings. You can see an example of this in the following
    screenshot, where you can see a weapons collider made out of primitives:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有几种类型的碰撞器，因此我们将回顾常见的碰撞器，从基本类型开始，即盒子、球体和胶囊体。这些形状是最便宜的（性能方面）来检测碰撞，因为它们之间的碰撞是通过数学公式进行的，不像其他碰撞器，比如Mesh
    Collider，它允许你使用任何网格作为对象的物理主体，但代价更高且有一些限制。理念是你应该使用基本类型来表示你的对象，或者它们的组合，例如，一个平面可以用两个盒子碰撞器来做，一个用于主体，另一个用于翅膀。你可以在下面的截图中看到一个例子，其中你可以看到由基本形状制作的武器碰撞器：
- en: '![Figure 15.1 – Compound colliders'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 - 复合碰撞器'
- en: '](img/Figure_15.01_B14199.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.01_B14199.jpg)'
- en: Figure 15.1 – Compound colliders
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 复合碰撞器
- en: Anyway, try to avoid doing this; if we want the weapon to just fall to the ground,
    maybe a Box Collider covering the entire weapon can be enough, considering those
    kinds of collisions don't need to be accurate, thereby increasing performance.
    Also, some shapes cannot be represented even with a combination of primitive shapes,
    such as ramps or pyramids, where your only solution is to use a Mesh Collider,
    which asks for a 3D mesh to use for collisions, but we won't use them in this
    book; we will solve all of our Physics colliders with primitives.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，尽量避免这样做；如果我们只是希望武器掉落到地面上，也许一个覆盖整个武器的盒子碰撞器就足够了，考虑到这些类型的碰撞不需要精确，从而提高性能。此外，有些形状甚至不能用基本形状的组合来表示，比如坡道或金字塔，你唯一的解决方案就是使用Mesh
    Collider，它需要一个3D网格用于碰撞，但我们不会在本书中使用它们；我们将用基本形状来解决所有的物理碰撞器。
- en: 'Now, let''s add the necessary colliders to our scene to prepare it to calculate
    collisions properly. Consider that if you used an Asset Store environment package
    other than mine, you may already have the scene modules with colliders; I will
    be showing the work I needed to do in my case, but try to extrapolate the main
    ideas here to your scene. To add the colliders, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为场景添加必要的碰撞器，以便正确计算碰撞。请注意，如果您使用的是除了我的之外的Asset Store环境包，您可能已经具有带有碰撞器的场景模块；我将展示我需要在我的情况下做的工作，但请尝试将这里的主要思想推广到您的场景中。要添加碰撞器，请按照以下步骤操作：
- en: Select a wall in the base and check the Object and possible child Objects for
    collider components; in my case, I have no colliders. If you detect any Mesh Collider,
    you can leave it, but I would suggest you remove it and replace it with another
    option in the next step. The idea is to add the collider to it, but the problem
    I detected here is that, due to the fact that my wall is not an instance of a
    Prefab, I need to add a collider to every wall.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基础中选择一面墙，并检查对象和可能的子对象是否有碰撞器组件；在我的情况下，我没有碰撞器。如果检测到任何网格碰撞器，可以保留它，但我建议您删除它，并在下一步中用另一个选项替换它。想法是给它添加碰撞器，但我在这里检测到的问题是，由于我的墙不是预制体的实例，我需要给每面墙都添加碰撞器。
- en: One option is to create a Prefab and replace all of the walls for instances
    of the Prefab (the recommended solution) or to just select all walls in the Hierarchy
    (by clicking them while pressing *Ctrl* or *Cmd* on Mac) and, with them selected,
    use the `Box Collider` component, which will adapt the size of the collider to
    the mesh. If it doesn't adapt, you can just change the Size and Center properties
    of the Box Collider to cover the entire wall:![Figure 15.2 – A Box Collider added
    to a wall
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种选择是创建一个预制体，并将所有墙替换为预制体的实例（推荐的解决方案），或者只需在层次结构中选择所有墙（按住*Ctrl*或Mac上的*Cmd*并单击它们），然后在选择它们时使用`Box
    Collider`组件，该组件将使碰撞器的大小适应网格。如果它不适应，您可以只需更改Box Collider的Size和Center属性以覆盖整个墙：![图15.2
    - 添加到墙上的盒子碰撞器
- en: '](img/Figure_15.02_B14199.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.02_B14199.jpg)'
- en: Figure 15.2 – A Box Collider added to a wall
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 添加到墙上的盒子碰撞器
- en: Repeat *steps 1 and 2* for the corners, floor tiles, and any other obstacle
    that will block Player and Enemy movement.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于角落、地板瓷砖和任何其他会阻碍玩家和敌人移动的障碍，重复*步骤1和2*。
- en: For our Enemy and Player, we will be adding the Capsule Collider, the usual
    collider to use in movable characters due to the fact that the rounded bottom
    will allow the Object to smoothly climb ramps, and being horizontally rounded
    allows the Object to easily rotate in corners without getting stuck, along with
    other conveniences of that shape. Remember that the Enemy is a Prefab, so you
    will need to add the collider to the Prefab, while our Player is a simple Object
    in the scene, so you will need to add the collider to that one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的敌人和玩家，我们将添加胶囊碰撞器，这是可移动角色中常用的碰撞器，因为其圆形底部将允许对象顺利爬坡，并且横向圆形允许对象在拐角处轻松旋转而不会卡住，还有其他这种形状的便利之处。请记住，敌人是一个预制体，所以您需要将碰撞器添加到预制体中，而我们的玩家是场景中的一个简单对象，所以您需要将碰撞器添加到该对象中。
- en: Important Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may be tempted to add several Box Colliders to the bones of the character
    to create a realistic shape of the Object, and while we can do that to apply different
    damage according to the part of the body where the enemies where shot, we are
    just creating movement colliders; the capsule is enough. In advanced damage systems,
    both capsule and bone colliders will coexist, one for the movement and the other
    for damage detection; but we will simplify this in our game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会诱惑地在角色的骨骼上添加几个盒子碰撞器，以创建对象的真实形状，虽然我们可以这样做，根据敌人被击中的身体部位应用不同的伤害，但我们只是创建了移动碰撞器；胶囊足够了。在高级伤害系统中，胶囊和骨骼碰撞器将共存，一个用于移动，另一个用于伤害检测；但在我们的游戏中，我们将简化这一过程。
- en: 'Also, sometimes the collider won''t adapt well to the visual shape of the Object,
    and in my case, the Capsule Collider didn''t have a nice shape for the character.
    I needed to fix its shape to match the character by setting its values as shown
    in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时碰撞器无法很好地适应对象的视觉形状，在我的情况下，胶囊碰撞器对角色来说形状不好。我需要通过设置其值来修复其形状，如下面的截图所示：
- en: '![Figure 15.3 – Character Collider'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 - 角色碰撞器'
- en: '](img/Figure_15.03_B14199.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.03_B14199.jpg)'
- en: Figure 15.3 – Character Collider
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 - 角色碰撞器
- en: The bullet we created with the Sphere already had a Sphere Collider, but if
    you replaced the mesh of the bullet with another one, you might want to change
    the collider. For now, we don't need other Objects in our game, so now that everyone
    has its proper collider, let's see how to set the different Physics settings to
    each Object to enable proper collision detection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用球体创建的子弹已经有了一个球体碰撞器，但如果您用另一个替换了子弹的网格，您可能需要更改碰撞器。目前，我们的游戏不需要其他对象，所以现在每个对象都有了适当的碰撞器，让我们看看如何为每个对象设置不同的物理设置以启用适当的碰撞检测。
- en: Physics Object types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理对象类型
- en: 'Now that we have added colliders to every Object by making the Objects have
    a presence in the Physics Simulation, it is time to configure them to have the
    exact Physics behavior we want. We have a myriad of possible combinations of settings,
    but we will discuss a set of common profiles that cover most situations. Remember
    besides colliders, we saw the Rigidbody component at the beginning of this book,
    which is the one that applies physics to the Object. The following profiles are
    done with a combination of colliders and Rigidbody settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使对象在物理模拟中存在，我们已经为每个对象添加了碰撞器，是时候配置它们以获得我们想要的确切物理行为了。我们有许多可能的设置组合，但我们将讨论一组常见的配置文件，涵盖大多数情况。请记住，除了碰撞器，我们在本书的开头看到了Rigidbody组件，它是将物理应用于对象的组件。以下配置文件是通过碰撞器和Rigidbody设置的组合完成的：
- en: '`Rigidbody` component, so they have a presence in the Physics Simulation, but
    don''t have any Physics applied to them; they cannot be moved by other Objects,
    they won''t have physics, and they will be fixed at their position no matter what.
    Take into account that this has nothing to do with the static checkbox at the
    top-right part of the Editor; those are for the previously seen systems (such
    as Lighting and others), so you can have a Static Collider with that checkbox
    unchecked if needed.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “刚体”组件，因此它们在物理模拟中存在，但没有任何物理作用；它们不能被其他物体移动，它们不会有物理效应，无论如何它们都会固定在它们的位置。需要注意的是，这与编辑器右上角的静态复选框无关；那些是用于之前看到的系统（比如照明和其他系统），所以如果需要的话，你可以有一个未选中该复选框的静态碰撞体。
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Take into account that these Objects can be moved via scripting, but you shouldn't.
    Unity applies an optimization technique to them, and every time a Static Collider
    is moved, the optimization becomes invalid, needing further calculation to update
    it, and doing that every frame is costly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，这些物体可以通过脚本移动，但你不应该这样做。Unity对它们应用了一种优化技术，每当静态碰撞体移动时，优化就会失效，需要进一步计算来更新它，而且每一帧都这样做是很昂贵的。
- en: We just mentioned Terrain as an example, and if you check the Terrain's components,
    you will see that it has its own kind of collider, the Terrain Collider. For Terrains,
    that's the only collider to use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚提到地形作为一个例子，如果你检查地形的组件，你会发现它有自己的一种碰撞体，地形碰撞体。对于地形来说，这是唯一要使用的碰撞体。
- en: '`Rigidbody` component, like the example of the falling ball we did in the first
    part of this book. These are fully Physics-driven Objects that have gravity and
    can be moved through forces; other Objects can push them and they perform every
    other Physics reaction you can expect. You can use this for the Player, grenade
    movement, or falling crates or in all Objects in heavily physics-based games such
    as **The Incredible Machine**.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “刚体”组件，就像我们在本书的第一部分中所做的掉落球的例子。这些是完全由物理驱动的物体，具有重力，并且可以通过力移动；其他物体可以推动它们，并且它们会执行你可以期望的每一个物理反应。你可以用它来控制玩家、手榴弹移动，或者掉落的板条箱，或者在像“不可思议的机器”这样的重度物理游戏中的所有物体。
- en: '`Rigidbody` component but have the `transform.Translate`) with no performance
    penalty. Consider that due to the fact they don''t have Physics, they won''t have
    collisions either, so they can pass through walls. These can be used in Objects
    that need to move using animations or custom scripting movement such as moving
    platforms, considering that, in this case, the platform won''t collide with other
    Objects, but the Player, having usually a Physics Collider, will collide against
    them; actually, the Physics Collider is the one that will collide with every kind
    of collider.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “刚体”组件但有“transform.Translate”）而没有性能损失。需要考虑的是，由于它们没有物理效应，它们也不会有碰撞，所以它们可以穿过墙壁。这些可以用于需要使用动画或自定义脚本移动的物体，比如移动平台，考虑到在这种情况下，平台不会与其他物体发生碰撞，但是玩家通常会与它们发生碰撞，因为玩家通常会有一个物理碰撞体，实际上，物理碰撞体是会与各种碰撞体发生碰撞的。
- en: '`Trigger` event, an event that can be captured via scripting, and tells us
    that something is inside the collider. This can be used to create buttons or trigger
    Objects, in areas of the game when the Player passes through something happening,
    such as a wave of enemies being spawned, a door being opened, or winning the game
    in case that area is the goal place of the Player. Consider that regular Static
    Colliders won''t generate a trigger event when passing through this type because
    those aren''t supposed to move.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “触发器”事件，这是可以通过脚本捕获的事件，告诉我们有东西在碰撞体内。这可以用来创建按钮或触发物体，在游戏中当玩家通过某些事件发生的区域时，比如生成一波敌人、打开门，或者在玩家到达目标位置时赢得游戏。需要考虑的是，普通的静态碰撞体在通过这种类型的碰撞体时不会生成触发事件，因为它们不应该移动。
- en: '**Trigger Kinematic Collider**: Kinematic Colliders don''t generate collisions,
    so they will pass through any other Object, but they will generate Trigger events,
    so we can react via scripting. This can be used to create moveable power-ups that,
    when touched, disappear and gives us points, or bullets that move with custom
    scripting movement and no physics, just straight like our bullets, but that damage
    other Objects on contact.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “触发器运动碰撞体”：运动碰撞体不会生成碰撞，所以它们会穿过任何其他物体，但它们会生成触发事件，所以我们可以通过脚本做出反应。这可以用来创建可移动的能量增强道具，当触碰时消失并给我们分数，或者子弹通过自定义脚本移动而没有物理效应，就像我们的子弹一样直线前进，但在接触时会对其他物体造成伤害。
- en: We can have a Trigger Physics Collider, a collider with Rigidbody but with **Is
    Trigger** checked, usually, it has no real use; it will be an ever-falling Object
    that will generate trigger events in the world, but passing through everything.
    Of course, other profiles can exist aside from the specified ones to use in some
    games with specific gameplay requirements, but considering all possible combinations
    of Physics settings are up to you to experiment with to see whether some are useful
    for your case, the described profiles will cover 99% of cases.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以有一个触发器物理碰撞体，一个带有刚体但勾选了“是触发器”的碰撞体，通常它没有真正的用途；它将是一个永远下落的物体，在世界中生成触发事件，但通过一切。当然，除了指定的这些配置外，还可以存在其他配置，用于一些具有特定游戏玩法要求的游戏，但是考虑到所有可能的物理设置组合是由你来实验的，看看哪些对你的情况有用，描述的配置将涵盖99%的情况。
- en: 'To recap the previous scenarios, I leave you with the following table showing
    the reaction of contact between all of the types of colliders. You will find a
    row per each profile that can move; remember that static profiles aren''t supposed
    to move. Each column represents the reaction when they collide with the other
    types, "Nothing" meaning the Object will pass through with no effect, "Trigger"
    meaning the Object will pass through but raising Trigger events, and "Collision"
    meaning that the Object won''t be able to pass through the Object:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了总结之前的情景，我给你留下以下表格，显示了所有类型的碰撞体之间的接触反应。你会发现每个可以移动的配置文件都有一行；记住静态配置文件不应该移动。每一列代表了它们与其他类型碰撞时的反应，“Nothing”表示物体会毫无影响地穿过，“Trigger”表示物体会穿过但会触发触发事件，“Collision”表示物体无法穿过物体：
- en: '![Table 15.4 Collision Reaction Matrix'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![表15.4 碰撞反应矩阵'
- en: '](img/Figure_15.04_B14199.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.04_B14199.jpg)'
- en: Table 15.4 Collision Reaction Matrix
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.4 碰撞反应矩阵
- en: Considering this, let's start configuring the physics of our Scene's Objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始配置场景物体的物理。
- en: 'The walls, corners, floor tiles, and obstacles should use the Static Collider
    Profile, so they have no `Rigidbody` component on them and their colliders will
    have the **Is Trigger** checkbox unchecked:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 墙壁、角落、地板砖和障碍物应该使用静态碰撞体配置文件，所以它们上面没有`Rigidbody`组件，它们的碰撞体将不勾选**Is Trigger**复选框：
- en: '![Figure 15.5 – Configuration for floor tiles; remember the static checkbox
    is for lighting only'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5 - 地板砖的配置；记住静态复选框只是用于照明'
- en: '](img/Figure_15.05_B14199.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.05_B14199.jpg)'
- en: Figure 15.5 – Configuration for floor tiles; remember the static checkbox is
    for lighting only
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 - 地板砖的配置；记住静态复选框只是用于照明
- en: 'The Player should move and generate collisions against Objects, so we need
    it to have a Dynamic Profile. This profile will generate a funny behavior with
    our current movement script (which I encourage you to test), especially when colliding
    against walls, so it won''t behave as you expected. We will deal with this later
    in this chapter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该移动并与物体发生碰撞，所以我们需要它具有动态配置文件。这个配置文件将会生成一个有趣的行为与我们当前的移动脚本（我鼓励你去测试），特别是当与墙壁碰撞时，它不会像你期望的那样行为。我们将在本章后面处理这个问题：
- en: '![Figure 15.6 – Dynamic settings on the Player'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6 - 玩家的动态设置'
- en: '](img/Figure_15.06_B14199.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.06_B14199.jpg)'
- en: Figure 15.6 – Dynamic settings on the Player
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 - 玩家的动态设置
- en: 'For the `Enemy` Prefab, we will be using the Kinematic profile here because
    we will be moving this Object with Unity''s AI systems later, so we don''t need
    Physics here, and as we want the player to collide against them, we need a Collision
    reaction there, so there''s no `Trigger` here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Enemy` Prefab，我们将在这里使用Kinematic配置文件，因为我们稍后将使用Unity的AI系统移动这个物体，所以我们这里不需要物理，而且我们希望玩家与它们发生碰撞，所以这里需要一个碰撞反应，所以这里没有`Trigger`：
- en: '![Figure 15.7 – Kinematic setting for the Enemy'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.7 - 敌人的运动设置'
- en: '](img/Figure_15.07_B14199.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.07_B14199.jpg)'
- en: Figure 15.7 – Kinematic setting for the Enemy
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 - 敌人的运动设置
- en: 'For the `Bullet` Prefab, it will move but with simplistic movement via scripting
    (just move forward), and not Physics. We don''t need collisions; we will code
    the bullet to destroy itself as soon as it touches something and will damage the
    collided Object (if possible), so a Kinematic Trigger profile is enough for this
    one; we will use the `Trigger` event to script the contact reactions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Bullet` Prefab，它会移动，但是通过脚本进行简单的移动（只是向前移动），而不是物理。我们不需要碰撞；我们将编写代码，使子弹在触碰到物体时立即销毁，并且会对碰撞到的物体造成伤害（如果可能的话），所以对于这个物体来说，Kinematic
    Trigger配置文件就足够了；我们将使用`Trigger`事件来编写接触反应：
- en: '![Figure 15.8 – The Kinematic Trigger setting for our bullet; Is Trigger and
    Is Kinematic are checked'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.8 - 我们子弹的运动触发器设置；Is Trigger和Is Kinematic都被勾选了'
- en: '](img/Figure_15.08_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.08_B14199.jpg)'
- en: Figure 15.8 – The Kinematic Trigger setting for our bullet; Is Trigger and Is
    Kinematic are checked
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 - 我们子弹的运动触发器设置；Is Trigger和Is Kinematic都被勾选了
- en: Now that we have properly configured the Objects, let's check how to filter
    undesired collisions between certain Object types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了物体，让我们来看看如何过滤掉某些物体类型之间不需要的碰撞。
- en: Filtering collisions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤碰撞
- en: After all of the hassle of configuring Objects, do we want to prevent collisions?
    Actually, yes, sometimes we want certain Objects to ignore each other. As an example,
    the bullets shot by the Player shouldn't collide with the Player itself and the
    bullets from the enemies shouldn't hit them. We can always filter that with an
    `If` statement in the C# script, checking whether the hit Object is from the opposite
    team or whatever filtering logic you want, but by then, it is too late, the Physics
    system has already wasted resources by checking a collision between Objects that
    were never meant to collide. Here is where the Layer Collision Matrix can help
    us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置物体的所有麻烦之后，我们是否想要阻止碰撞？实际上，有时我们希望某些物体忽略彼此。例如，玩家射出的子弹不应该与玩家自身发生碰撞，敌人的子弹也不应该击中它们。我们可以在C#脚本中使用`If`语句来过滤，检查击中的物体是否来自对立的队伍或者其他你想要的过滤逻辑，但那时已经太迟了，物理系统已经浪费了资源来检查本来不应该碰撞的物体之间的碰撞。这就是图层碰撞矩阵可以帮助我们的地方。
- en: The Layer Collision Matrix sounds scary, but it is a simple setting of the Physics
    system that allows us to specify which groups of Objects should collide with other
    groups, for example, the Player's bullets should collide with enemies, and Enemy
    bullets should collide with the Player. The idea is to create those groups and
    put our Objects inside them, and in Unity, those groups are called **layers**.
    We can create layers and set the layer property of the GameObject (the top part
    of the Inspector) to assign the Object to that group or layer. Consider that you
    have a limited number of layers, so try to use them wisely.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图层碰撞矩阵听起来很可怕，但它是物理系统的一个简单设置，允许我们指定哪些对象组应该与其他组发生碰撞，例如，玩家的子弹应该与敌人发生碰撞，敌人的子弹应该与玩家发生碰撞。这个想法是创建这些组并将我们的对象放在其中，在Unity中，这些组被称为**图层**。我们可以创建图层并设置GameObject的图层属性（检查器的顶部部分）以将对象分配到该组或图层。请注意，您拥有有限数量的图层，因此请明智地使用它们。
- en: 'Once we create the layers and assign the Object, we can go to the Physics settings
    and specify which layers will collide against other layers. We can achieve this
    by doing the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图层并分配对象后，我们可以转到物理设置并指定哪些图层将与其他图层发生碰撞。我们可以通过以下方式实现这一点：
- en: Go to **Edit** | **Project Settings** and, inside it, look for the **Tags and
    Layers** option from the left pane:![Figure 15.9 – Tags and Layers settings
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑** | **项目设置**，在其中，从左侧窗格中查找**标签和图层**选项：![图15.9 - 标签和图层设置
- en: '](img/Figure_15.09_B14199.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.09_B14199.jpg)'
- en: Figure 15.9 – Tags and Layers settings
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 - 标签和图层设置
- en: From the `Player`, `Enemy`, `PlayerBullet`, and `PlayerEnemy`:![Figure 15.10
    – Creating layers
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Player`，`Enemy`，`PlayerBullet`和`PlayerEnemy`：![图15.10 - 创建图层
- en: '](img/Figure_15.10_B14199.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.10_B14199.jpg)'
- en: Figure 15.10 – Creating layers
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 - 创建图层
- en: Select the `Player` and, from the top part of the Inspector, change the layer
    property to `Player`. Also, change the `Enemy` Prefab to have the `Enemy` layer.
    A window will show asking you whether you want to change the child Objects also;
    select that option:![Figure 15.11 – Changing the layers of the Player and the
    Enemy Prefab
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Player`，并从检查器的顶部部分将图层属性更改为`Player`。还要将`Enemy`预制件更改为`Enemy`图层。将显示一个窗口询问您是否要更改子对象；选择该选项：![图15.11
    - 更改玩家和敌人预制件的图层
- en: '](img/Figure_15.11_B14199.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.11_B14199.jpg)'
- en: Figure 15.11 – Changing the layers of the Player and the Enemy Prefab
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 - 更改玩家和敌人预制件的图层
- en: In the case of the bullet, we have a problem; we have one Prefab but two layers
    and a Prefab can only have one layer. We have two options, that is, changing the
    layer according to the shooter via scripting or have two bullet Prefabs with different
    layers. For simplicity, I will choose the latter, also taking the chance to apply
    another material to the Enemy bullet to make it look different.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子弹，我们有一个问题；我们有一个预制件，但有两个图层，而预制件只能有一个图层。我们有两个选择，即根据射手通过脚本更改图层或具有两个具有不同图层的子弹预制件。为简单起见，我将选择后者，同时也有机会将另一个材料应用于敌人子弹，使其看起来不同。
- en: 'We will be creating a Prefab Variant of the Player bullet. Remember that a
    Variant is a Prefab that is based on an original one like class inheritance. When
    the original Prefab changes, the Variant will change, but the Variant can have
    differences, which will make it unique:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建玩家子弹的预制件变体。请记住，变体是基于原始预制件的预制件，就像类继承一样。当原始预制件更改时，变体将更改，但变体可以有差异，这将使其成为独特的：
- en: Drop a bullet in to the Scene to create an instance.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子弹放入场景中创建一个实例。
- en: Drag the instance again to the `Prefabs` folder, this time selecting the `Prefab
    Variant` option. Call it `Enemy Bullet`. Remember to destroy the Prefab instance
    in the scene.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将实例拖放到`预制件`文件夹中，这次选择`预制件变体`选项。将其命名为`敌人子弹`。记得销毁场景中的预制件实例。
- en: Create a second material similar to the Player bullet, but yellow or whatever
    color you like, and put it on the Enemy Bullet Prefab Variant.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二种类似于玩家子弹的材质，但是黄色或您喜欢的任何颜色，并将其放在敌人子弹预制件变体上。
- en: Select the Variant for the Enemy bullet, set its layer (`EnemyBullet`), and
    do the same for the original Prefab (`PlayerBullet`). Even if you changed the
    original Prefab layer, as the Variant modified it, the modified version (or override)
    will prevail, allowing each Prefab to have its own layer.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择敌人子弹的变体，设置其图层（`EnemyBullet`），并对原始预制件（`PlayerBullet`）执行相同操作。即使您更改了原始预制件的图层，由于变体修改了它，修改后的版本（或覆盖）将占上风，从而使每个预制件都有自己的图层。
- en: Go to **Edit** | **Project Settings** and look for the **Physics settings**
    (not Physics 2D).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑** | **项目设置**，查找**物理设置**（不是物理2D）。
- en: 'Scroll down until you see the Layer Collision Matrix, a half grid of checkboxes.
    You will notice that each column and row is labeled with the names of the layers,
    so each checkbox in the cross of a row and column will allow us to specify whether
    these two should collide. In our case, we configured it as shown in the following
    screenshot:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动，直到看到图层碰撞矩阵，一个半复选框网格。您会注意到每一列和行都标有图层的名称，因此在行和列的交叉处的每个复选框都允许我们指定这两个是否应该发生碰撞。在我们的情况下，我们将其配置如下截图所示：
- en: '![Figure 15.12 – Making Player bullets to collide with enemies and Enemy bullets
    with the Player'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12 - 使玩家子弹与敌人发生碰撞，敌人子弹与玩家发生碰撞'
- en: '](img/Figure_15.12_B14199.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.12_B14199.jpg)'
- en: Figure 15.12 – Making Player bullets to collide with enemies and Enemy bullets
    with the Player
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 - 使玩家子弹与敌人发生碰撞，敌人子弹与玩家发生碰撞
- en: It is worth noticing that sometimes filtering logic won't be that fixed or predictable,
    for example, our bullet may only hit Objects that have a certain amount of life
    or Objects that don't have an invisibility temporal buff or conditions that can
    change during the game and are difficult to generate all possible layers for all
    possible groups. So, in these cases, we should rely on manual filtering after
    the Trigger or Collision event.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时过滤逻辑可能不那么固定或可预测，例如，我们的子弹可能只会击中具有一定生命值的对象，或者不具有临时隐身增益的对象，或者在游戏过程中可能会发生变化且难以为所有可能的组生成所有可能的层。因此，在这些情况下，我们应该依靠触发或碰撞事件后的手动过滤。
- en: Now that we have filtered collisions, let's check whether our settings are working
    properly by reacting to collisions in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经过滤了碰撞，让我们通过在下一节对碰撞做出反应来检查我们的设置是否正常工作。
- en: Detecting collisions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: As you can see, proper Physics settings can be complicated and very important,
    but now that we have tackled that, let's do something with those settings by reacting
    to the contact in different ways and creating a Health System in the process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，正确的物理设置可能会很复杂且非常重要，但现在我们已经解决了这个问题，让我们通过以不同的方式对接触做出反应并在此过程中创建一个健康系统来利用这些设置。
- en: 'In this section, we will examine the following collision concepts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下碰撞概念：
- en: Detecting Trigger events
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: Modifying the other Object
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: First, we are going to explore the different collision and trigger events Unity
    offers to react to contact between two Objects through the Unity collision events.
    This allows us to execute any reaction code we want to place, but we are going
    to explore how to modify the contacted Object components using the `GetComponent`
    function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索Unity提供的不同碰撞和触发事件，以对两个对象之间的接触做出反应。这使我们能够执行任何我们想要放置的反应代码，但我们将探索如何使用`GetComponent`函数修改接触对象的组件。
- en: Detecting Trigger events
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测触发事件
- en: If Objects are properly configured, as previously discussed, we can get two
    reactions, triggers and collisions. The Collision reaction has a default effect
    that is blocking the movement of the Objects, but we can add custom behavior on
    top of that using scripting, but with triggers, unless we add custom behavior,
    it won't produce any noticeable effect. Either way, we can script reactions to
    both possible scenarios such as adding a score, reducing health, and losing the
    game. To do so, we can use the suite of Physics events.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象被正确配置，就像之前讨论的那样，我们可以得到两种反应，触发和碰撞。碰撞反应有一个默认效果，即阻止对象的移动，但我们可以使用脚本添加自定义行为，但是触发器，除非我们添加自定义行为，否则不会产生任何明显的效果。无论哪种方式，我们都可以对两种可能的情况进行脚本反应，比如添加得分、减少生命和输掉游戏。为此，我们可以使用物理事件套件。
- en: These events are split into two groups, Collision events and Trigger events,
    so according to your Object setting, you will need to pick the proper group. Both
    groups have three main events, **Enter**, **Stay**, and **Exit**, telling us when
    a collision or trigger began (Enter), whether they are still happening or are
    still in contact (Stay), and when they stopped contacting (Exit). For example,
    we can script a behavior such as playing a sound when two Objects start contact
    in the Enter event, such as a friction sound, and stop it when the contact ends,
    in the Exit event.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件分为两组，碰撞事件和触发事件，因此根据您的对象设置，您将需要选择适当的组。两个组都有三个主要事件，**进入**、**停留**和**退出**，告诉我们碰撞或触发何时开始（进入），它们是否仍在发生或仍在接触（停留），以及何时停止接触（退出）。例如，我们可以在进入事件中编写一个行为，比如在两个对象开始接触时播放声音，比如摩擦声音，并在退出事件中停止它。
- en: 'Let''s test this by creating our first contact behavior, that is, the bullet
    being destroyed when contacting something. Remember that the bullets are configured
    to be triggers, so they will generate Trigger events on contact with anything.
    You can do this with the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建我们的第一个接触行为来测试这一点，也就是说，当子弹接触到某物时被销毁。请记住，子弹被配置为触发器，因此它们在接触任何物体时都会生成触发事件。您可以按照以下步骤进行操作：
- en: Create and add a script called `ContactDestroyer` on the Bullet Player Prefab;
    as the Bullet Enemy Prefab is a Variant of it, it will have also the same script.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子弹玩家预制件上创建并添加一个名为`ContactDestroyer`的脚本；因为子弹敌人预制件是它的变体，它也会有相同的脚本。
- en: To detect when a trigger happens, such as with Start and Update, create an event
    function named `OnTriggerEnter`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检测触发发生的时候，就像使用Start和Update一样，创建一个名为`OnTriggerEnter`的事件函数。
- en: Inside the event, use the `Destroy(gameObject);` line to make the bullet destroy
    itself when touching something:![Figure 15.13 – Auto destroying on contact with
    something
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件中，使用`Destroy(gameObject);`行使子弹在接触到物体时自我销毁：![图15.13 - 与某物接触时自动销毁
- en: '](img/Figure_15.13_B14199.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.13_B14199.jpg)'
- en: Figure 15.13 – Auto destroying on contact with something
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 - 与某物接触时自动销毁
- en: Save and shoot the bullets against the walls to see how they disappear instead
    of passing through it. Again, here, we don't have a collision but a trigger that
    destroys the bullet on contact. So, in this way, we are sure that the bullet will
    never pass through anything, but we are still not using Physics movement.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并射击子弹，看看它们在接触墙壁时如何消失而不是穿过它。同样，在这里，我们没有碰撞，而是触发了接触时销毁子弹。因此，通过这种方式，我们可以确保子弹永远不会穿过任何东西，但我们仍然没有使用物理运动。
- en: 'For now, we won''t need the other Collision events, but in case you need them,
    they will work similarly; just put `OnCollisionEnter` instead. Now, let''s explore
    another version of the same function. It not only tells us that we hit something
    but also what we contacted against. We will use this to make our Contact Destroyer
    also destroy the other Object. To do this, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要其他碰撞事件，但如果您需要它们，它们将类似工作；只需使用`OnCollisionEnter`即可。现在，让我们探索相同函数的另一个版本。它不仅告诉我们我们击中了什么，还告诉我们我们接触了什么。我们将使用这个来使我们的接触销毁器也销毁其他对象。要做到这一点，请按照以下步骤进行：
- en: Replace the `OnTriggerEnter` method signature with the one in the following
    screenshot. This one receives a parameter of the `Collider` type, indicating the
    exact collider that hit us:![Figure 15.14 – Version of the trigger event that
    tells us which Object we collided with
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下截图中的方法签名替换`OnTriggerEnter`方法签名。这个方法接收`Collider`类型的参数，指示精确撞击我们的碰撞体：![图15.14
    - 告诉我们与之发生碰撞的对象的触发事件的版本
- en: '](img/Figure_15.14_B14199.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.14_B14199.jpg)'
- en: Figure 15.14 – Version of the trigger event that tells us which Object we collided
    with
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 - 告诉我们与之发生碰撞的对象的触发事件的版本
- en: We can access the entire Object of that collider using the `gameObject` setter,
    so we can use this to destroy the other one also, as shown in the following screenshot.
    If we just use `Destroy` by passing the `other` reference, it would only destroy
    the `Collider` component:![Figure 15.15 – Destroying both Objects
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`gameObject` setter来访问碰撞体的整个对象，因此我们也可以使用它来摧毁另一个对象，如下截图所示。如果我们只是通过传递`other`引用来使用`Destroy`，那么它只会摧毁`Collider`组件：![图15.15
    - 摧毁两个对象
- en: '](img/Figure_15.15_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.15_B14199.jpg)'
- en: Figure 15.15 – Destroying both Objects
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 - 摧毁两个对象
- en: Save and test the script. You will notice that the bullet will destroy everything
    it touches.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试脚本。您会注意到子弹会摧毁它接触到的一切。
- en: Of course, we don't want the bullet to destroy everything on contact, just itself
    and the other Object if it complies with certain criteria, such as being on the
    opposite team or something else, according to our game. In our case, we will move
    a step forward, and instead of directly destroying the Object on contact, we will
    make the Enemies and the Player have a life amount, so the bullets will reduce
    it until reaching 0.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望子弹在接触时摧毁一切，只摧毁自身和其他对象，如果符合某些条件，比如在对立队伍或其他情况下，根据我们的游戏。在我们的情况下，我们将向前迈进一步，而不是直接在接触时摧毁对象，而是使敌人和玩家具有生命值，因此子弹将减少生命值直到达到0。
- en: Modifying the other Object
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改其他对象
- en: So far, we used the `transform` field to access a specific component of the
    Object, but what happens when we need to access others? In our scenario, for the
    bullet to damage the collided Object, it will need to access its `Life` component
    to change the amount of life. Remember that Unity doesn't have all kinds of possible
    behaviors for games. So, in our case, the `Life` component is the one that we
    are going to create just to hold a float field with the amount of life. Every
    Object that has this component will be considered as a damageable Object. Here
    is where the `GetComponent` function will help us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`transform`字段来访问对象的特定组件，但是当我们需要访问其他组件时会发生什么？在我们的场景中，为了使子弹损坏碰撞的对象，它将需要访问其`Life`组件以改变生命值。请记住，Unity并没有游戏的所有可能行为。因此，在我们的情况下，`Life`组件就是我们要创建的组件，只是用来保存一个带有生命值的浮点字段。拥有此组件的每个对象都将被视为可损坏对象。这就是`GetComponent`函数将帮助我们的地方。
- en: 'If you have a reference to a GameObject or Component, you can use `GetComponent`
    to access a reference of a target component if the Object contains it (if not,
    it will return null). Let''s see how to use that function to make the bullet lower
    the amount of life of the other Object if it is damaged by following these steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个对GameObject或Component的引用，您可以使用`GetComponent`来访问目标组件的引用，如果对象包含它（如果没有，它将返回null）。让我们看看如何使用该函数来使子弹降低其他对象的生命值，如果它受到损坏，按照以下步骤进行：
- en: Create and add a `Life` component with a `public float` field called `amount`
    to both the Player and enemies. Remember to set the value in the amount field
    for both Objects in the Inspector:![Figure 15.16 – The Life component
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家和敌人上创建并添加一个`Life`组件，其中包含一个名为`amount`的`public float`字段。记得在检查器中为两个对象的amount字段设置值：![图15.16
    - 生命组件
- en: '](img/Figure_15.16_B14199.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.16_B14199.jpg)'
- en: Figure 15.16 – The Life component
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 - 生命组件
- en: Remove the `ContactDestroyer` component from the Player bullet, which will also
    remove it from the Enemy Bullet Variant, and instead add a new one called `ContactDamager`;
    you may need the `ContactDestroyer` behavior later. So, we are creating another
    component.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从玩家子弹中删除`ContactDestroyer`组件，这也会将其从敌人子弹变体中删除，并添加一个名为`ContactDamager`的新组件；您可能稍后需要`ContactDestroyer`行为。因此，我们正在创建另一个组件。
- en: Add an `OnTriggerEnter` event that receives the other collider and just add
    the `Destroy` function call that auto destroys itself, not the one that destroyed
    the other Object; our script won't be responsible for destroying it, just reducing
    its life.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`OnTriggerEnter`事件，接收其他碰撞体，并只添加`Destroy`函数调用，自动摧毁自身，而不是摧毁其他对象的那个；我们的脚本不会负责摧毁它，只是减少它的生命值。
- en: Add a float field called damage, so we can configure the amount of damage to
    inflict to the other Object. Remember to save the file and set a value before
    continuing.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为damage的浮点字段，这样我们就可以配置对其他对象造成的伤害量。在继续之前，请记得保存文件并设置一个值。
- en: Use `GetComponent` on the reference to the other collider to get a reference
    to its `life` component and save it in a variable:![Figure 15.17 – Accessing the
    collided Object's Life component
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对其他碰撞体的引用上使用`GetComponent`来获取其`life`组件的引用并将其保存在一个变量中：![图15.17 - 访问碰撞对象的生命组件
- en: '](img/Figure_15.17_B14199.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.17_B14199.jpg)'
- en: Figure 15.17 – Accessing the collided Object's Life component
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17 - 访问碰撞对象的生命组件
- en: Before reducing the life of the Object, we must check whether the life reference
    isn't null, which would happen if the other Object doesn't have the `Life` component,
    as in the case of walls and obstacles. The idea is that the bullet will destroy
    itself when anything collides with it and reduce the life of the other Object
    if it is a damageable Object that contains the `Life` component.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在减少对象的生命之前，我们必须检查生命引用是否不为空，如果其他对象没有`Life`组件，就会发生这种情况，比如墙壁和障碍物。子弹将在任何碰撞时摧毁自身，并减少其他对象的生命，如果它是包含`Life`组件的可损坏对象。
- en: 'In the following screenshot, you will find the full script finished:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您将找到完整的脚本完成：
- en: '![Figure 15.18 – Reducing the life of the collided Object'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.18 - 减少碰撞对象的生命'
- en: '](img/Figure_15.18_B14199.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.18_B14199.jpg)'
- en: Figure 15.18 – Reducing the life of the collided Object
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18 - 减少碰撞对象的生命值
- en: Place an Enemy in the scene based on a Prefab and set the instance speed (the
    one in the scene) to `0` to prevent it from moving.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中放置一个基于预制件的敌人，并将实例速度（场景中的速度）设置为“0”，以防止其移动。
- en: Select it before hitting Play and start shooting at it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击播放之前选择它并开始向其射击。
- en: You can see how the life value reduces in the Inspector. You can also press
    the *Esc* key to regain control of the mouse and select the Object while in Play
    Mode to see the life field change during the runtime in the Editor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在检查器中看到生命值的减少。您还可以在播放模式下按*Esc*键重新获得鼠标控制权，并在编辑器中查看运行时生命字段的变化。
- en: 'Now, you will notice that life is decreasing, but it will become negative;
    we want the Object to destroy itself when its life is below 0 instead. We can
    do this in two ways, one is to add an `Update` to the `Life` component, which
    will check all of the frames for whether life is below 0, destroying itself when
    that happens. The second way is by encapsulating the `life` field and checking
    that inside the setter to prevent checking all frames. I would prefer the second
    way, but we will implement the first one to make our scripts as simple as possible
    for beginners. To do this, follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您会注意到生命值正在减少，但它将变为负数；我们希望对象在生命值低于0时自行销毁。我们可以通过两种方式实现这一点，一种是向“Life”组件添加“Update”，它将检查所有帧是否生命值低于0，并在发生时销毁自身。第二种方法是通过封装“life”字段，并在setter内部进行检查，以防止检查所有帧。我更喜欢第二种方式，但我们将实现第一种方式，以使我们的脚本对初学者尽可能简单。要做到这一点，请按照以下步骤操作：
- en: Add `Update` to the `Life` component.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向“Life”组件添加“Update”。
- en: Add `If` to check whether the `amount` field is below `0`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“如果”添加到检查“amount”字段是否低于“0”。
- en: Add `Destroy` in case the `if` condition is true.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“if”条件为真的情况下添加“Destroy”。
- en: The full `Life` script will look like the following screenshot:![Figure 15.19
    – The Life component
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的“Life”脚本将如下截图所示：![图15.19 - 生命组件
- en: '](img/Figure_15.19_B14199.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.19_B14199.jpg)'
- en: Figure 15.19 – The Life component
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19 - 生命组件
- en: Save and see how the Object is destroyed once its life value becomes 0\.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '保存并查看对象在其生命值变为0时被销毁。 '
- en: Optionally, you can instantiate an Object when this happens such as a sound,
    a particle, or maybe a power-up. I will leave this as a challenge for you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以在发生这种情况时实例化一个对象，比如声音、粒子或者一个道具。我将把这留给您作为一个挑战。
- en: By using a similar script, you can make a life power-up that increases the life
    value or a speed power-up that accesses the `PlayerMovement` script and increases
    the speed field; from now on, use your imagination to create exciting behaviors
    using this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类似的脚本，您可以制作增加生命值的生命力道具，或者访问“PlayerMovement”脚本并增加速度字段的速度道具；从现在开始，尽情发挥想象力，创造出令人兴奋的行为。
- en: Now that we have explored how to detect collisions and react to them, let's
    explore how to fix the Player falling when hitting some wall.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何检测碰撞并对其做出反应，让我们探索一下当玩家撞到墙壁时如何修复玩家下落的问题。
- en: Moving with Physics
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物理移动
- en: So far, the Player, the only Object that moves with the Dynamic Collider Profile
    and the one that will move with Physics, is actually moving through custom scripting
    using the Transform API. Every dynamic Object should instead move using the Rigidbody
    API functions in a way the Physics system understands better, so here we will
    explore how to move Objects, this time through the Rigidbody component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一使用动态碰撞器配置文件移动的对象是玩家，也是将使用物理移动的对象，实际上是通过使用Transform API进行自定义脚本编写移动。每个动态对象都应该使用Rigidbody
    API函数移动，以便物理系统更好地理解，因此在这里我们将探讨如何移动对象，这次是通过Rigidbody组件。
- en: 'In this section, we will examine the following Physics movement concepts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下物理运动概念：
- en: Applying forces
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用力量
- en: Tweaking Physics
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整物理
- en: We will start seeing how to move Objects the correct physical way, through forces,
    and we will apply this concept to the movement of our player. Then, we will explore
    why real physics is not always fun, and how we can tweak the Physics properties
    of our Objects to have a more responsive and appealing behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始看到如何以正确的物理方式移动对象，通过力量，并将这个概念应用到我们玩家的移动上。然后，我们将探讨为什么真实的物理并不总是有趣，以及如何调整我们对象的物理属性以获得更具响应性和吸引力的行为。
- en: Applying forces
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用力量
- en: The physically accurate way of moving an Object is through forces, which affect
    the Object's velocity. To apply force, we need to access `Rigidbody` instead of
    `Transform` and use the `AddForce` and `AddTorque` functions to move and rotate,
    respectively. These are functions where you can specify the amount of force to
    apply to each axis of position and rotation. This technique of movement will have
    full Physics reactions; the forces will accumulate on the velocity to start moving
    and will suffer drag effects that will make the speed slowly decrease, and the
    most important aspect here is that it will collide against walls, blocking the
    Object's way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过力量的物理准确移动对象的方式是通过影响对象的速度。要应用力量，我们需要访问“Rigidbody”而不是“Transform”，并使用“AddForce”和“AddTorque”函数分别移动和旋转。这些是函数，您可以在其中指定要应用到位置和旋转的每个轴上的力量量。这种移动技术将产生完整的物理反应；力量将累积到速度上开始移动，并且将遭受减速效果，使速度缓慢减小，这里最重要的一点是它将与墙壁发生碰撞，阻挡对象的路径。
- en: 'To get this kind of movement, we can do the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这种移动方式，我们可以这样做：
- en: Create a `Rigidbody` field in the `PlayerMovement` script, but this time, make
    it `private`, meaning, do not write the `public` keyword in the field, which will
    make it disappear in the Editor; we will get the reference another way.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“PlayerMovement”脚本中创建一个“Rigidbody”字段，但这次将其设置为“private”，意思是在字段中不写“public”关键字，这将使其在编辑器中消失；我们将以另一种方式获取引用。
- en: 'Certain coding standards specify that you need to explicitly replace the `public`
    keyword with the `private` keyword, but in C#, putting `private` and not putting
    it have the same effect, so it''s up to your preference:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 某些编码标准规定您需要明确用`private`关键字替换`public`关键字，但在C#中，使用`private`和不使用它具有相同的效果，所以这取决于您的偏好：
- en: '![Figure 15.20 – The private Rigidbody reference field'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.20–私有刚体引用字段'
- en: '](img/Figure_15.20_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.20_B14199.jpg]'
- en: Figure 15.20 – The private Rigidbody reference field
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20–私有刚体引用字段
- en: Using `GetComponent` in the `Start` event function, get our `Rigidbody` and
    save it in the field. We will use this field to cache the result of the `GetComponent`
    function; calling that function every frame to access the Rigidbody is not performant.
    Also, you can notice here that the `GetComponent` function can be used to retrieve
    not only components from other Objects (like the collision example) but also your
    own:![Figure 15.21 – Caching the Rigidbody reference for future usage
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`事件函数中使用`GetComponent`，获取我们的`Rigidbody`并将其保存在字段中。我们将使用此字段来缓存`GetComponent`函数的结果；每帧调用该函数以访问刚体的性能不佳。此外，您还可以注意到`GetComponent`函数不仅可用于从其他对象（如碰撞示例）检索组件，还可以用于检索自己的组件：![图15.21–缓存刚体引用以供将来使用
- en: '](img/Figure_15.21_B14199.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.21_B14199.jpg]'
- en: Figure 15.21 – Caching the Rigidbody reference for future usage
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21–缓存刚体引用以供将来使用
- en: Replace the `transform.Translate` calls with `rb.AddRelativeForce`. This will
    call the add force functions of the Rigidbody, specifically, the relative ones,
    which will consider the current rotation of the Object. For example, if you specify
    a force on the z axis (the third parameter), the Object will apply its force along
    with its forward vector.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`rb.AddRelativeForce`替换`transform.Translate`调用。这将调用刚体的添加力函数，具体来说是相对的力函数，它将考虑对象的当前旋转。例如，如果您在z轴（第三个参数）上指定一个力，对象将沿着它的前向矢量施加力。
- en: 'Replace the `transform.Rotate` calls with `rb.AddRelativeTorque`, which will
    apply rotation forces:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`rb.AddRelativeTorque`替换`transform.Rotate`调用，这将应用旋转力：
- en: '![Figure 15.22 – Using the Rigidbody forces API'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.22–使用刚体力API'
- en: '](img/Figure_15.22_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.22_B14199.jpg]'
- en: Figure 15.22 – Using the Rigidbody forces API
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22–使用刚体力API
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are familiar with Unity, you might be thinking that I need to do this
    in a Fixed Update, and while that's correct, doing this in the Update won't have
    any noticeable effect. I prefer to use `Update` in beginners' scripts to prevent
    problems that can happen when using `GetKeyDown` and `GetKeyUp` in `FixedUpdate`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Unity，您可能会认为我需要在Fixed Update中执行此操作，虽然这是正确的，但在Update中执行此操作不会产生任何显着效果。我更喜欢在初学者脚本中使用“Update”来防止在“FixedUpdate”中使用“GetKeyDown”和“GetKeyUp”时可能发生的问题。
- en: Now, if you save and test the results, you will probably find the Player falling
    and that's because now we are using real physics, which contains floor friction,
    and due to the force being applied at the center of gravity, it will make the
    Object fall. Remember that, in terms of Physics, you are a Capsule; you don't
    have legs to move, and here is where standard physics is not suitable for our
    game. The solution is to tweak Physics to emulate the kind of behavior we need.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您保存并测试结果，您可能会发现玩家正在下落，这是因为现在我们正在使用真正的物理，其中包含地板摩擦力，并且由于力被施加在重心上，它将使对象下落。请记住，在物理学上，您是一个胶囊；您没有腿来移动，这就是标准物理学不适合我们的游戏的地方。解决方案是调整物理以模拟我们需要的行为。
- en: Tweaking Physics
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整物理
- en: 'To make our Player move like in a regular platformer game, we will need to
    freeze certain axes to prevent the Object from falling. Remove the friction to
    the ground and increase the air friction (drag) to make the Player reduce its
    speed automatically when releasing the keys. To do this, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的玩家像常规平台游戏中一样移动，我们需要冻结某些轴以防止对象下落。去除地面摩擦力，并增加空气摩擦力（阻力），以使玩家在释放按键时自动减速。要做到这一点，请按照以下步骤进行：
- en: In the `Rigidbody` component, look at the **Constraints** section at the bottom
    and check the **X** and **Z** axes of the **Freeze Rotation** property:![Figure
    15.23 – Freezing rotation axes
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rigidbody`组件中，查看底部的**Constraints**部分，并检查**Freeze Rotation**属性的**X**和**Z**轴：![图15.23–冻结旋转轴
- en: '](img/Figure_15.23_B14199.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.23_B14199.jpg]'
- en: Figure 15.23 – Freezing rotation axes
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.23–冻结旋转轴
- en: This will prevent the Object from falling sideways but will allow the Object
    to rotate horizontally. You might also freeze the y axis of the **Freeze Position**
    property if you don't want the Player to jump, preventing some undesired vertical
    movement on collisions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止对象侧倾，但允许对象水平旋转。如果您不希望玩家跳跃，可以冻结**Freeze Position**属性的y轴，以防止在碰撞时发生一些不希望的垂直移动。
- en: You will probably need to change the speed values because you changed from a
    meters-per-second value to newtons per second, the expected value of the `45`
    in rotation speed was enough for me.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要更改速度值，因为您从每秒米的值更改为每秒牛顿的值，旋转速度中的`45`预期值对我来说已经足够了。
- en: Now, you will probably notice that the speed will increase a lot over time,
    as will the rotation. Remember that you are using forces, which affects your velocity.
    When you stop applying forces, the velocity is preserved, and that's why the Player
    still keeps rotating even if you are not moving the mouse. The fix to this is
    to increase the `Drag` and `Angular Drag values`, which emulates air friction
    and which will reduce the movement and rotation respectively when no force is
    applied. Experiment with values that you see suitable; in my case, I used `2`
    for `Drag` and `10` for `Angular Drag`, needing to increase the `Rotation Speed`
    to `150` to compensate for the drag increase:![Figure 15.24 – Setting air friction
    for rotation and movement
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能会注意到速度和旋转会随着时间的推移而大幅增加。记住，你正在使用力量，这会影响你的速度。当你停止施加力时，速度会保持不变，这就是为什么即使你不移动鼠标，玩家仍然会保持旋转。解决这个问题的方法是增加`阻力`和`角阻力值`，这模拟了空气摩擦，当不施加力时，将分别减少移动和旋转。尝试适合你的值；在我的情况下，我使用了`2`作为`阻力`和`10`作为`角阻力`，需要将`旋转速度`增加到`150`来补偿阻力的增加：![图15.24
    – 设置旋转和移动的空气摩擦
- en: '](img/Figure_15.24_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.24_B14199.jpg)'
- en: Figure 15.24 – Setting air friction for rotation and movement
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.24 – 设置旋转和移动的空气摩擦
- en: Now, if you move while touching the wall, instead of sliding, like most games,
    your Player will stick to the obstacles due to contact friction. We can remove
    this by creating a Physics Material, an asset that can be assigned to the colliders
    to control how they react in those scenarios. Start creating one by clicking on
    the `Physics Material` (not the 2D version). Call it `Player` and remember to
    put it in a folder for those kinds of assets.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你在触摸墙壁时移动，你的玩家不会像大多数游戏那样滑动，而是会因为接触摩擦而粘在障碍物上。我们可以通过创建一个物理材质来消除这种情况，这是一个可以分配给碰撞体以控制它们在这些情况下如何反应的资源。通过点击`物理材质`（不是2D版本）来开始创建一个。将其命名为`玩家`，并记得将其放在专门的资源文件夹中。
- en: Select it and set `0`, and `Minimum`, which will make the Physics system pick
    the minimum friction of the two colliding Objects, being always the minimum—in
    our case, zero:![Figure 15.25 – Creating a Physics Material
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并设置为`0`和`最小`，这将使物理系统选择两个碰撞物体的最小摩擦，始终是最小的—在我们的情况下是零：![图15.25 – 创建物理材质
- en: '](img/Figure_15.25_B14199.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.25_B14199.jpg)'
- en: Figure 15.25 – Creating a Physics Material
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.25 – 创建物理材质
- en: Select the Player and drag this asset to the **Material** property of the **Capsule
    Collider**:![Figure 15.26 – Setting the Physics material of the Player
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择玩家并将此资源拖到**胶囊碰撞体**的**材质**属性中：![图15.26 – 设置玩家的物理材质
- en: '](img/Figure_15.26_B14199.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.26_B14199.jpg)'
- en: Figure 15.26 – Setting the Physics material of the Player
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.26 – 设置玩家的物理材质
- en: If you play the game now, you may notice that the Player will move faster than
    before because now we don't have any kind of friction on the floor, so you may
    need to reduce the movement force.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在玩游戏，你可能会注意到玩家移动得比以前快，因为现在地板上没有任何摩擦，所以你可能需要减少移动力。
- en: 'A little error you might find here is that the motion blur effect applied by
    the camera post-processing on the Player has some hiccups, such as frames where
    the Object is moving and others where it''s not. The problem is that Physics is
    not executed in every frame due to the performance and determinism (by default,
    it is 50 times per frame), but the rendering does, and that is affecting the postprocessing.
    You can set the **Interpolate** property of the Rigidbody to the **Interpolate**
    value to make the Rigidbody calculate Physics at its own rate but interpolate
    the position every frame to simulate fluidness:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会发现一个小错误，就是相机后期处理对玩家应用的运动模糊效果有些小问题，有些帧是物体在移动，有些帧是不移动的。问题在于由于性能和确定性，物理不是在每一帧都执行的（默认情况下是每帧50次），但渲染是执行的，这影响了后期处理。你可以将刚体的**插值**属性设置为**插值**值，使刚体以自己的速率计算物理，但每帧插值位置以模拟流畅度：
- en: '![Figure 15.27 – Making the Rigidbody interpolate its position'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.27 – 使刚体插值其位置'
- en: '](img/Figure_15.27_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.27_B14199.jpg)'
- en: Figure 15.27 – Making the Rigidbody interpolate its position
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.27 – 使刚体插值其位置
- en: As you can see, we needed to bend the Physics rules to allow a responsive player
    movement. You can get more responsiveness by increasing drags and forces, so the
    speeds are applied faster and reduced faster, but that depends, again, on the
    experience you want your game to have. Some games want an immediate response with
    no velocity interpolation, going from 0 to full speed and vice versa from one
    frame to the other, and in these cases, you can override the velocity and rotation
    vectors of the Player directly at your will or even use other systems instead
    of Physics, such as the Character Controller component, which have special physics
    for platformer characters; but let's keep things simple for now.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们需要弯曲物理规则来允许玩家的灵活移动。通过增加阻力和力量，可以获得更高的灵敏度，使速度更快地应用和减少，但这取决于你希望游戏拥有的体验。有些游戏希望立即响应，没有速度插值，从0到全速度，反之亦然，而在这种情况下，你可以直接覆盖玩家的速度和旋转向量，甚至在物理系统之外使用其他系统，比如角色控制器组件，它对平台角色有特殊的物理效果；但现在让我们保持简单。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Every game has physics one way or the other, for movement, collision detection,
    or both. In this chapter, we learned how to use the Physics system for both, being
    aware of proper settings to make the system work properly, reacting to collisions
    to generate gameplay systems, and moving the Player in such a way it collides
    with obstacles, keeping its physically-inaccurate movement. We used these concepts
    to create our Player and bullet movement and make our bullets damage the Enemies,
    but we can reuse the knowledge to create a myriad of other possible gameplay requirements,
    so I suggest you play a little bit with the physics concepts seen here; you can
    discover a lot of interesting use cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都以某种方式具有物理特性，用于移动、碰撞检测或两者兼而有之。在本章中，我们学习了如何使用物理系统来处理这些情况，了解适当的设置以使系统正常工作，对碰撞做出反应以生成游戏系统，并以使玩家与障碍物发生碰撞，保持其物理上不准确的移动方式。我们利用这些概念来创建我们的玩家和子弹移动，并使我们的子弹对敌人造成伤害，但我们可以重复利用这些知识来满足各种其他可能的游戏需求，因此我建议你在这里玩一下物理概念；你可以发现许多有趣的用例。
- en: In the next chapter, we will be discussing how to program the visual aspects
    of the game, such as effects, and make the UI react to input.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何编程游戏的视觉方面，例如效果，并使用户界面对输入做出反应。
