- en: Chapter 5. Looping Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章.循环结构
- en: It is often desirable to repeat a sequence of actions again and again. For example,
    we may want to display information about the employees in an organization stored
    in an array. Each element of the array might hold a reference to a `Employee`
    object. A call to methods of the object would be placed inside a looping construct.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望一遍又一遍地重复一系列操作。例如，我们可能希望显示存储在数组中的组织中员工的信息。数组的每个元素可能包含对`Employee`对象的引用。对象的方法调用将放置在循环结构内部。
- en: 'In Java there are four looping constructs available:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中有四种循环结构可用：
- en: For statement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for语句
- en: For-each statement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: For-each语句
- en: While statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: while语句
- en: d. while statement
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: d. while语句
- en: In addition, the break and continue statements are used within a loop to control
    how the loop behaves. The break statement is used to prematurely exit or short
    circuit the loop and is discussed in the *The break statement* section. As we
    observed in the *The switch statement* section in [Chapter 3](ch03.html "Chapter 3. Decision
    Constructs"), *Decision Constructs*, the break is also used within the switch
    statement. The continue statement is used to bypass statements in a loop and continue
    executing the loop. It is covered in the *The continue statement* section. We
    will also examine the use of labels in Java, though they should be used sparingly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，break和continue语句用于控制循环的行为。break语句用于提前退出或短路循环，并在*break语句*部分讨论。正如我们在[第3章](ch03.html
    "第3章.决策结构")中观察到的，在*决策结构*中，break也在switch语句中使用。continue语句用于绕过循环中的语句并继续执行循环。它在*continue语句*部分中介绍。我们还将研究在Java中使用标签，尽管它们应该谨慎使用。
- en: The body of the loop is iterated through a specific number of times based on
    the loop structure. Iteration is the term commonly used to describe this execution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的循环体根据循环结构的特定次数进行迭代。迭代是通常用来描述这种执行的术语。
- en: Loops use control information to determine how many times the body of the loop
    will be executed. For most loops there is an initial set of values, a set of operations
    to be performed at the end of the body, and a terminal condition which will stop
    the execution of the loop. Not all loops have all of these parts, as some of these
    parts are either missing or implied. The terminal condition is almost always present
    as this is needed to terminate the iteration of the loop. If the terminal condition
    is missing, an infinite loop is created.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 循环使用控制信息来确定循环体将被执行多少次。对于大多数循环，有一组初始值，一组在循环体结束时执行的操作，以及一个终止条件，它将停止循环的执行。并非所有循环都有这些部分，因为其中一些部分要么缺失，要么隐含。终止条件几乎总是存在的，因为这是终止循环迭代所需的。如果终止条件缺失，则会创建一个无限循环。
- en: Infinite loops refer to those loops that may never terminate without using a
    statement, such as the break statement. Despite their name, infinite loops do
    not execute indefinitely as they will always terminate at some point. They are
    useful in situations where it is inconvenient or awkward to provide a loop termination
    condition as a part of the basic loop construct.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环指的是那些可能永远不会终止的循环，而不使用break语句等语句。尽管它们的名称是无限循环，但它们并不会无限执行，因为它们总会在某个时刻终止。它们在某些情况下很有用，这些情况中提供循环终止条件是不方便或尴尬的。
- en: We will also cover the use of nested loops and various pitfalls associated with
    loops. A section dealing with the development of programming logic is also presented
    to help provide an approach when creating the program logic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍嵌套循环的使用以及与循环相关的各种陷阱。还提供了一个处理编程逻辑开发的部分，以帮助在创建程序逻辑时提供一种方法。
- en: The for statement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for语句
- en: The for statement is used when the number of times the loop needs to be executed
    is known. There are two variations of the for loop. The first one is discussed
    in this section and is the traditional form. The for-each statement is the second
    form and was introduced in Java 5\. It is discussed in the *The for-each statement*
    section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要知道循环需要执行的次数时，使用for语句。for循环有两种变体。第一种在本节中讨论，是传统形式。for-each语句是第二种形式，引入于Java
    5。它在*for-each语句*部分中讨论。
- en: 'The for statement consists of the following three parts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: for语句由以下三部分组成：
- en: Initial operation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始操作
- en: Terminal condition
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止条件
- en: End loop operation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束循环操作
- en: 'The general form of the for loop follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: for循环的一般形式如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The body of a for loop is typically a block statement. The initial operation
    takes place prior to the first iteration of the loop and is executed only once.
    The end loop operations take place at the end of each execution of the loop. The
    terminal condition determines when the loop will terminate and is a logical expression.
    It is executed at the beginning of each repetition of the loop. Thus, the body
    of the for loop may be executed zero times if the first time the terminal condition
    is evaluated, it evaluates to false.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: for循环的循环体通常是一个块语句。初始操作在循环的第一次迭代之前进行，只执行一次。结束循环操作在每次循环执行结束时进行。终止条件确定循环何时终止，并且是一个逻辑表达式。它在每次循环重复开始时执行。因此，如果第一次评估终止条件时，它的值为false，则for循环的循环体可能会执行零次。
- en: 'A variable is normally used as part of the initial operation, terminal condition,
    and end loop operation . The variable is either declared as part of the loop or
    is declared external to the loop. The following code snippet is an example of
    declaring a variable, `i`, as part of the loop. An example of using an external
    variable is covered in the *The for statement and scope* section:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常作为初始操作、终止条件和结束循环操作的一部分使用变量。变量要么作为循环的一部分声明，要么作为循环外部声明。以下代码片段是声明变量`i`作为循环一部分的示例。使用外部变量的示例在*for语句和作用域*部分中介绍：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example we used a single statement in the body of the loop. The variable
    `i` was assigned an initial value of 1 and is incremented by 1 each time the loop
    executes. The loop executed 10 times and produced 1 line of output. The statement,
    `i++`, is a more concise way of saying `i = i + 1`. The output should be the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在循环体中使用了一个语句。变量`i`被赋予初始值1，并且每次循环执行时增加1。循环执行了10次，并产生了1行输出。语句`i++`是一种更简洁的方式，表示`i
    = i + 1`。输出应该是以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following example uses a for statement to compute the square of the integers
    from `1` to `64`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用for语句计算从`1`到`64`的整数的平方：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A partial listing of the output follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的部分列表如下：
- en: '**1 squared is = 1**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**1的平方是= 1**'
- en: '**2 squared is = 4**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**2的平方是= 4**'
- en: '**3 squared is = 9**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**3的平方是= 9**'
- en: '**4 squared is = 16**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**4的平方是= 16**'
- en: '**...**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: 'The initial value of the loop variable can be any value. In addition, the end
    loop operation can decrement or otherwise modify the variable as needed. In the
    next example, numbers are displayed from `10` to `1`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 循环变量的初始值可以是任何值。此外，结束循环操作可以根据需要递减或修改变量。在下一个例子中，从`10`到`1`显示数字：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of this sequence follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此序列的输出：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A common operation is to compute a cumulative sum, as illustrated with the
    following code sequence. This example is discussed in more detail in the *Timing
    is everything* section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的操作是计算累积和，如下面的代码序列所示。这个例子在*时间就是一切*部分中有更详细的讨论：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The value of `sum` should be `55`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`的值应该是`55`。'
- en: The comma operator
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逗号运算符
- en: 'The comma operator can be used as part of a for statement to add other variables
    for use within the loop and/or to control the loop. It is used to separate the
    parts of the initial-expression and the end-loop operation sections of the for
    loop. The use of the comma operator is shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符可以作为for语句的一部分，用于添加其他变量以在循环内使用和/或控制循环。它用于分隔for循环的初始表达式和结束循环操作部分的各个部分。逗号运算符的使用如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice the use of the `%n` format specifier in the `printf` statement. This
    specifies that a new line character should be generated. In addition, this new
    line separator is platform-specific making the application more portable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`printf`语句中使用了`%n`格式说明符。这指定应生成一个新行字符。此外，这个新行分隔符是特定于平台的，使应用程序更具可移植性。
- en: 'When executed, this code sequence will produce the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码序列时，将产生以下输出：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Two variables were declared for the loop, `i` and `j`. The variable `i` was
    initialed to `0` and `j` was initialized to `10`. At the end of the loop, `i`
    was incremented by `1` and `j` was decremented by `1`. The loop executed as long
    as `j` was greater than `5`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 循环声明了两个变量，`i`和`j`。变量`i`初始化为`0`，`j`初始化为`10`。循环结束时，`i`增加了`1`，`j`减少了`1`。只要`j`大于`5`，循环就会执行。
- en: 'We could have used a more complex terminal condition, such as illustrated in
    the following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更复杂的终止条件，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the loop will terminate after the third iteration resulting
    in the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，循环将在第三次迭代后终止，产生以下输出：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is illegal to declare the variables separately, as attempted here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里分别声明变量是非法的：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A syntax error is generated, shown as follows. Only the first part of the message
    is provided as it is lengthy. This also illustrates the cryptic nature of error
    messages generated by Java and most other programming languages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了一个语法错误，如下所示。由于消息过长，只提供了消息的第一部分。这也说明了Java和大多数其他编程语言生成的错误消息的神秘性质：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The for statement and scope
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for语句和作用域
- en: 'The index variable used by a for statement can have different scope depending
    on how it is declared. We can use this to control the execution of the loop and
    then use the variable outside the loop, as needed. The first example of a for
    loop is repeated as follows. In this code sequence the scope of the `i` variable
    is restricted to the body of the for loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: for语句使用的索引变量可以根据其声明方式具有不同的作用域。我们可以利用这一点来控制循环的执行，然后根据需要在循环外部使用变量。第一个for循环的示例如下重复。在这个代码序列中，`i`变量的作用域仅限于for循环的主体：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An alternate approach declares `i` external to the loop as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是将`i`声明为循环外部，如下所示：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These two for loops are equivalent as they both display the numbers 1 to 10
    on a single line. They differ in the scope of the `i` variable. In the first example,
    the scope is restricted to the body of the loop. An attempt to use the variable
    outside of the loop, as illustrated in the following code, will result in a syntax
    error:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个for循环是等价的，因为它们都在一行上显示1到10的数字。它们在`i`变量的作用域上有所不同。在第一个例子中，作用域仅限于循环体。尝试在循环外部使用变量，如下面的代码所示，将导致语法错误：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The error message follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息如下：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second example, upon termination of the loop the variable will retain
    its value and will be available for subsequent use. The following example illustrates
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，循环终止后，变量将保留其值，并可供后续使用。以下示例说明了这一点：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of this sequence follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此序列的输出：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Scope is discussed in more detail in the *Scope and lifetime* section in [Chapter
    2](ch02.html "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and
    Their Usage*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域在[第2章](ch02.html "第2章。Java数据类型及其用法")的*作用域和生存期*部分中有更详细的讨论，*Java数据类型及其用法*。
- en: The for loop variations
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环的变体
- en: 'The for loop may have a body consisting of multiple statements. It is important
    to remember that the for loop body consists of a single statement. The following
    illustrates the use of multiple statements in a loop. This loop will read in a
    sequence of numbers and print them out one per line. It will continue until it
    reads in a negative value and then it will exit the loop. The `java.util.Scanner`
    class is used to read in data from the input source. In this case it uses `System.in`
    which specifies the keyboard as its input source:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: for循环的主体可能由多个语句组成。重要的是要记住for循环的主体只包含一个语句。下面说明了循环中多个语句的使用。这个循环将读取一系列数字并将它们逐行打印出来。它将继续读取，直到读取到一个负值，然后退出循环。`java.util.Scanner`类用于从输入源中读取数据。在这种情况下，它使用`System.in`指定键盘作为输入源：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One possible output of executing this code sequence is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这段代码序列的一个可能的输出如下：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The initial operation, terminal condition, or end loop operation are not required.
    For example, the following statements will execute the `i++` statement 5 times
    with a value `5` assigned to `i` upon the exit from the loop:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初始操作、终止条件或结束循环操作是不需要的。例如，以下语句将执行`i++`语句5次，退出循环时`i`的值为`5`：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following example, the body of the loop will execute forever creating
    an infinite loop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，循环的主体将永远执行，创建一个无限循环：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The same is true for the following for loop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下的for循环也是一样的：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is called an **infinite loop** and is covered in more detail in the *Infinite
    loops* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**无限循环**，在*无限循环*部分中有更详细的介绍。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The for loop is normally used when you know how many times the loop will be
    executed. A controlling integer variable is typically used as an index into an
    array or for computational purposes within the body of the loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道循环将被执行多少次时，通常使用for循环。通常使用一个控制整数变量作为数组的索引或在循环体内进行计算。
- en: The for-each statement
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for-each语句
- en: 'The for-each statement was introduced with the release of Java 5\. It is sometimes
    referred to as the enhanced for loop. Advantages of using the for-each statement
    include:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句是在Java 5发布时引入的。有时它被称为增强型for循环。使用for-each语句的优点包括：
- en: It is unnecessary to provide end conditions for the counter variable
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要为计数变量提供结束条件
- en: It is simpler and more readable
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更简单，更易读
- en: The statement provides opportunities for compiler optimization
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语句提供了编译器优化的机会
- en: The use of generics is simplified
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型的使用变得更简单
- en: The for-each statement is used in conjunction with collections and arrays. It
    provides an easier way to iterate through each member of an array or class that
    has implemented the `java.util.Iterable` interface. As the `Iterable` interface
    is the super interface of the `java.util.Collection` interface, the for-each statement
    can be used with those classes that implement the `Collection` interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句与集合和数组一起使用。它提供了一种更容易遍历数组或实现了`java.util.Iterable`接口的类的每个成员的方法。由于`Iterable`接口是`java.util.Collection`接口的超级接口，因此for-each语句可以与实现`Collection`接口的类一起使用。
- en: 'The syntax of this statement is similar to the regular for statement, except
    for the contents of its parentheses. The contents include a data type followed
    by a variable, a colon, and then an array name or collection, illustrated as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句的语法与常规的for语句类似，除了括号内的内容。括号内包括数据类型，后跟一个变量，一个冒号，然后是数组名或集合，如下所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Its use with a collection is illustrated in the *Using the for-each statement
    with a list* section. In the following sequence, an array of integers is declared,
    initialized, and a for-each statement is used to display each element of the array:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它与集合的使用在*使用for-each语句与列表*部分进行了说明。在下面的序列中，声明了一个整数数组，初始化了它，并使用for-each语句显示了数组的每个元素：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The elements of the numbers array were initialized to their index. Notice that
    a for statement was used. This was because we are unable to access an index variable
    directly in a for-each statement easily. The for-each statement in the preceding
    code snippet is read as **"**for each element in numbers". During each iteration
    of the loop, `element` corresponds to an element of the array. It starts with
    the first element and ends with the last element. The output of this sequence
    is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: numbers数组的元素被初始化为它们的索引。请注意使用了for语句。这是因为我们无法在for-each语句中直接访问索引变量。在上述代码片段中，for-each语句被读作“对于numbers中的每个元素”。在循环的每次迭代中，`element`对应数组的一个元素。它从第一个元素开始，直到最后一个元素结束。这个序列的输出如下：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are drawbacks to the use of the for-each statement with an array. It
    is not possible to do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-each语句与数组存在一些缺点。无法执行以下操作：
- en: Modify the current position in an array or list
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数组或列表中的当前位置
- en: Directly iterate over multiple arrays or collections
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接迭代多个数组或集合
- en: 'For example, using the previous example, if we try to modify the element of
    the array containing a 5 with the following code, it will not result in a syntax
    error. But it also will not modify the corresponding array element:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用前面的例子，如果我们尝试使用以下代码修改包含5的数组元素，它不会导致语法错误。但它也不会修改相应的数组元素：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this sequence is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to use one loop to access two different arrays, the for-each loop
    cannot be used. For example, if we want to copy one array to another, we need
    to use the for loop, shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用一个循环来访问两个不同的数组，就不能使用for-each循环。例如，如果我们想要将一个数组复制到另一个数组，我们需要使用for循环，如下所示：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While we used a for-each to initialize the source array, we can only address
    a single array at a time. Thus, in the second loop we were forced to use the for
    statement.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用for-each来初始化源数组，但我们一次只能处理一个数组。因此，在第二个循环中，我们被迫使用for语句。
- en: Using the for-each statement with a list
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for-each语句与列表
- en: 'We will start by illustrating the use of the for-each statement with the `ArrayList`.
    The `ArrayList` class implements the `List` interface which extends the `Collection`
    interface. The use and declaration of interfaces is addressed in more detail in
    [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*. As the for-each statement can be used with classes
    that implement the `Collection` interface, we can also use it with the `ArrayList`
    class. In the next section, we will create our own `Iterable` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先说明如何使用for-each语句与`ArrayList`。`ArrayList`类实现了`List`接口，该接口扩展了`Collection`接口。接口的使用和声明在[第6章](ch06.html
    "第6章。类，构造函数和方法")中有更详细的介绍，*类，构造函数和方法*。由于for-each语句可以与实现`Collection`接口的类一起使用，我们也可以将其与`ArrayList`类一起使用。在下一节中，我们将创建自己的`Iterable`类：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output, as you might predict, is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出，正如你可能预测的那样，如下所示：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The use of the for-each in this example is not that much different from its
    use with an array. We simply used the name of the `ArrayList` instead of an array
    name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用for-each与数组的使用并没有太大的不同。我们只是使用了`ArrayList`的名称而不是数组名称。
- en: 'Using a for-each statement with a list has similar restrictions to those we
    saw earlier with arrays:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-each语句与列表具有与我们之前在数组中看到的类似的限制：
- en: May not be able to remove elements from a list as you traverse it
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能无法在遍历列表时删除元素
- en: Inability to modify the current position in a list
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法修改列表中的当前位置
- en: Not possible to iterate over multiple collections
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能同时迭代多个集合
- en: The `remove` method can throw a `UnsupportedOperationException` exception. This
    is possible because the implementation of the `Iteratable` interface's `Iterator`
    may not have implemented the `remove` method. This is elaborated on in the next
    section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`方法可能会抛出`UnsupportedOperationException`异常。这是可能的，因为`Iteratable`接口的`Iterator`的实现可能没有实现`remove`方法。这将在下一节详细说明。'
- en: 'In the case of the `ArrayList`, we can remove an element, as demonstrated in
    the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrayList`的情况下，我们可以移除一个元素，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The for-each statement was used to iterate over the list. When the `bears.`
    string was found, it was removed. The output of the preceding sequence is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句用于遍历列表。当找到`bears.`字符串时，它被移除。前面序列的输出如下：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We cannot modify the list from within the for-each statement. For example,
    the following code sequence attempts to modify `word` and add a string to `list`.
    The list will not be affected:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在for-each语句内修改列表。例如，以下代码序列尝试修改`word`并向`list`添加一个字符串。列表不会受到影响：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While the attempt to modify the `word` variable does not do anything, it does
    not generate an exception. This is not the case with the `add` method. When used
    within the preceding for-each statement, it will generate a `java.util.ConcurrentModificationException`
    exception.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改`word`变量并不会产生任何效果，也不会生成异常。但`add`方法不是这样。在前面的for-each语句中使用它将生成一个`java.util.ConcurrentModificationException`异常。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with arrays, it is not possible to iterate over more than one collection
    at a time using the for-each statement. As the for-each statement supports only
    one reference variable, only one list can be accessed at a time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，使用for-each语句一次只能迭代一个集合。由于for-each语句只支持一个引用变量，因此一次只能访问一个列表。
- en: If you need to remove an element from a list, use an iterator instead of a for-each
    statement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从列表中删除一个元素，请使用迭代器而不是for-each语句。
- en: Implementing the Iterator interface
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现迭代器接口
- en: 'As mentioned earlier, any class that implements the `Iterable` interface can
    be used with the for-each statement. To illustrate this we will create two classes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，任何实现`Iterable`接口的类都可以与for-each语句一起使用。为了说明这一点，我们将创建两个类：
- en: '`MyIterator`: This implements the `Iterator` interface and supports a trivial
    iteration'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyIterator`：这实现了`Iterator`接口并支持一个简单的迭代'
- en: '`MyIterable`: This uses `MyIterator` to support its use in a for-each statement'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyIterable`：这使用`MyIterator`来支持它在for-each语句中的使用'
- en: 'First, let''s examine the `MyIterator` class that follows. The class will iterate
    through the numbers 1 to 10\. It does this by comparing the `value` variable against
    an upper bound of 10 and returning either `true` or `false` in its `hasNext` method.
    The `next` method simply returns and increments the current value. The `remove`
    method is not supported:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下接下来的`MyIterator`类。该类将迭代1到10的数字。它通过将`value`变量与10的上限进行比较，并在其`hasNext`方法中返回`true`或`false`来实现这一点。`next`方法只是返回并增加当前值。`remove`方法不受支持：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `MyIterable` class implements the `Iterable` interface. This interface
    consists of a single method, `iterator`. In this class, it uses an instance of
    the `MyIterator` class to provide a `Iterator` object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIterable`类实现了`Iterable`接口。该接口包含一个方法`iterator`。在这个类中，它使用`MyIterator`类的一个实例来提供一个`Iterator`对象：'
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can test these classes with the following code sequence:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码序列测试这些类：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will display the numbers from 1 to 10, shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示数字从1到10，如下所示：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the `Iterator` methods for iterating through a collection is not
    always needed. In many situations, the for-each statement provides a much more
    convenient and simple technique.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，并不总是需要使用`Iterator`方法来迭代集合。在许多情况下，for-each语句提供了一种更方便和简单的技术。
- en: The for-each statement – usage issues
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for-each语句-使用问题
- en: 'There are several issues that you should be aware of when working with the
    for-each statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用for-each语句时，有几个问题需要注意：
- en: If the array/collection is null, you will get a null pointer exception
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组/集合为空，您将会得到一个空指针异常
- en: It works well with a method having a variable number of arguments
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以很好地与具有可变数量参数的方法一起使用
- en: Null values
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值
- en: 'If the array/collection is null, you will get a null pointer exception. Consider
    the following example. We create an array of strings but fail to initialize the
    third element:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组/集合为null，您将获得一个空指针异常。考虑以下示例。我们创建了一个字符串数组，但未初始化第三个元素：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can display the names using a for-each statement as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for-each语句显示名称，如下所示：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output, shown as follows, will display `null` for the missing entry. This
    is because the `println` method checks its argument for a null value and when
    it is, it prints `null`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示，将为缺失的条目显示`null`。这是因为`println`方法检查其参数是否为null值，当为null时，它会打印`null`：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, if we apply the `toString` method against the name as follows, we
    will get `java.lang.NullPointerException` on the third element:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们对名称应用`toString`方法，我们将在第三个元素上得到`java.lang.NullPointerException`：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is verified, as shown in the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如下输出所示，这是经过验证的：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Variable number of arguments
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: The for-each statement works well in methods using a variable number of arguments.
    A more detailed explanation of methods that use a variable number of arguments
    is found in the *Variable number of arguments* section in [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句在使用可变数量的参数的方法中效果很好。关于使用可变数量的参数的方法的更详细解释可以在[第6章](ch06.html "第6章. 类、构造函数和方法")的*可变数量的参数*部分找到。
- en: 'In the following method we pass a variable number of integer arguments. Next,
    we calculate the cumulative sum of these integers and return the sum:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，我们传递了可变数量的整数参数。接下来，我们计算这些整数的累积和并返回总和：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When this is executed with the following calls, we get `15` and `0` as output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用以下调用执行时，我们得到`15`和`0`作为输出：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, we need to be careful not to pass a `null` value as this will result
    in `java.lang.NullPointerException`, as illustrated in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要小心，不要传递`null`值，因为这将导致`java.lang.NullPointerException`，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the for-each loop whenever possible, instead of the for loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用for-each循环，而不是for循环。
- en: The while statement
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while语句
- en: 'The while statement provides an alternate way of repeatedly executing a block
    of statements. It is frequently used when the number of times the block is to
    be executed is not known. Its general form consists of the `while` keyword followed
    by a set of parentheses enclosing a logical expression and then a statement. The
    body of the loop will execute as long as the logical expression evaluates to true:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: while语句提供了另一种重复执行一组语句的方法。当要执行块的次数未知时，它经常被使用。它的一般形式包括`while`关键字后跟一组括号括起来的逻辑表达式，然后是一个语句。只要逻辑表达式评估为true，循环的主体将执行：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A simple example duplicates the first for loop example where we display the
    numbers 1 to 10 on a single line:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例重复了第一个for循环示例，其中我们在一行上显示数字1到10：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following example is a bit more complicated and computes the factors of
    the `number` variable:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例稍微复杂一些，计算了`number`变量的因子：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When executed with the input as `6`, we get the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用输入`6`执行时，我们得到以下输出：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following table illustrates the action of the statement''s sequence:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格说明了语句序列的操作：
- en: '| Iteration count | divisor | number | Output |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 迭代次数 | 除数 | 数字 | 输出 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 1 | 6 | 1 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 6 | 1 |'
- en: '| 2 | 2 | 6 | 2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 6 | 2 |'
- en: '| 3 | 3 | 6 | 3 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 6 | 3 |'
- en: '| 4 | 4 | 6 |   |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 6 |   |'
- en: '| 5 | 5 | 6 |   |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 6 |   |'
- en: '| 6 | 6 | 6 | 6 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 6 | 6 |'
- en: 'In the following example, the loop will terminate when the user types in a
    negative number. In the process, it calculates the cumulative sum of the numbers
    entered:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当用户输入负数时，循环将终止。在此过程中，它计算了输入数字的累积和：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice how this example duplicated the code needed to prompt the user for a
    number. The problem can be handled more elegantly using a do-while statement as
    discussed in the next section. The following output illustrates the execution
    of this code for a series of numbers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例重复了提示用户输入数字所需的代码。可以更优雅地使用do-while语句来处理这个问题，如下一节所讨论的。以下输出说明了对一系列数字执行此代码的执行情况：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The while statement is useful for loops where the number of loop iterations
    required is not known. The body of the while loop will execute until the loop
    expression becomes false. It is also useful when the terminal condition is rather
    complex.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: while语句对于需要未知循环次数的循环很有用。while循环的主体将执行，直到循环表达式变为false。当终止条件相当复杂时，它也很有用。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An important characteristic of the while statement is the evaluation of the
    expression at the beginning of the loop. As a result, the body of the loop may
    never be executed if the first evaluation of the logical expression evaluates
    to false.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: while语句的一个重要特点是在循环开始时对表达式进行评估。因此，如果逻辑表达式的第一次评估为false，则循环的主体可能永远不会执行。
- en: The do-while statement
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do-while语句
- en: 'The do-while statement is similar to a while loop except that the body of the
    loop always executes at least once. It consists of the `do` keyword followed by
    a statement, the `while` keyword, and then a logical expression enclosed in parentheses:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: do-while语句类似于while循环，不同之处在于循环的主体始终至少执行一次。它由`do`关键字后跟一个语句，`while`关键字，然后是括号括起来的逻辑表达式组成：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Typically, the body of the do-while loop, as represented by the statement,
    is a block statement. The following code snippet illustrates the use of the do
    statement. It is an improvement over the equivalent while loop used in the previous
    section, as it avoids prompting for a number before the loop starts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，do-while循环的主体，如语句所表示的那样，是一个块语句。以下代码片段说明了do语句的用法。它是对前一节中使用的等效while循环的改进，因为它避免了在循环开始之前提示输入一个数字：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When executed you should get output similar to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，您应该获得类似以下的输出：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The do-while statement differs from that of the while statement as the evaluation
    of the expression occurs at the end of the loop. This means that this statement
    will be executed at least once.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`语句与`while`语句不同，因为表达式的评估发生在循环结束时。这意味着该语句至少会执行一次。'
- en: 'This statement is not used as frequently as the for or while statement, but
    is useful in situations where a test at the bottom of a loop is best. The next
    statement sequence will determine the number of digits in an integer number:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句并不像`for`或`while`语句那样经常使用，但在循环底部进行测试时很有用。下一个语句序列将确定整数数字中的数字位数：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output of this sequence follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result for the value `452` is illustrated in the following table:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 值`452`的结果如下表所示：
- en: '| Iteration count | number | numOfDigits |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 迭代次数 | 数字 | 数字位数 |'
- en: '| --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 452 | 0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 452 | 0 |'
- en: '| 1 | 45 | 1 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 45 | 1 |'
- en: '| 2 | 4 | 2 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 2 |'
- en: '| 3 | 0 | 3 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | 3 |'
- en: The break statement
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: The effect of the break statement is to terminate the current loop, whether
    it be a while, for, for-each, or do-while statement. It is also used in the switch
    statement. The break statement passes control to the next statement following
    the loop. The break statement consists of the `break` keyword.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句的效果是终止当前循环，无论是`while`、`for`、`for-each`还是`do-while`语句。它也用于`switch`语句。`break`语句将控制传递给循环后面的下一个语句。`break`语句由关键字`break`组成。'
- en: 'Consider the effect of the following statement sequence which repeatedly prompts
    the user for a command within an infinite loop. The loop will be terminated when
    the user enters the `Quit` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语句序列的影响，该序列会在无限循环中重复提示用户输入命令。当用户输入`Quit`命令时，循环将终止：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice how the `equals` method is used. The `equals` method is executed against
    the string literal and the command is used as its argument. This approach avoids
    `NullPointerException` that will result if the command contains a null value.
    As the string literals are never null, this exception will never occur.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`equals`方法的使用方式。`equals`方法针对字符串字面量执行，并将命令用作其参数。这种方法避免了`NullPointerException`，如果命令包含空值，将会导致该异常。由于字符串字面量永远不会为空，这种异常永远不会发生。
- en: The continue statement
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`continue`语句'
- en: The continue statement is used to transfer control from inside a loop to the
    end of the loop but does not exit the loop like the break statement does. The
    continue statement consists of the keyword, `continue`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句用于将控制从循环内部转移到循环的末尾，但不像`break`语句那样退出循环。`continue`语句由关键字`continue`组成。'
- en: 'When executed, it forces the evaluation of the loop''s logical expression.
    In the following statement sequence:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，它会强制执行循环的逻辑表达式。在以下语句序列中：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: if `i` is less than `0`, it will bypass the rest of the body of the loop. If
    the loop condition `i<j` does not evaluate to false, the next iteration of the
    loop will be performed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`i`小于`0`，它将绕过循环体的其余部分。如果循环条件`i<j`不为假，将执行循环的下一次迭代。
- en: 'The continue statement is often used to eliminate a level of nesting which
    is often necessary. The preceding example would appear as follows, if the continue
    statement was not used:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句通常用于消除通常是必要的嵌套级别。如果没有使用`continue`语句，前面的示例将如下所示：'
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Nested loops
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: 'Loops can be nested within each other. Any nested combination of the for, for-each,
    while, or do-while loops is permitted. This is useful for addressing a number
    of problems. The example that follows computes the sum of the elements of a row
    in a two-dimensional array. It starts by initializing each element to the sum
    of its indexes. The array is then displayed. This is followed by nested loops
    to compute and display the sum of the elements for each row:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可以嵌套在彼此之内。可以嵌套组合`for`、`for-each`、`while`或`do-while`循环。这对解决许多问题很有用。接下来的示例计算了二维数组中一行元素的总和。它首先将每个元素初始化为其索引的总和。然后显示数组。然后使用嵌套循环计算并显示每行元素的总和：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice the use of the `length` method used to control the number of times the
    loops are executed. This makes the code more maintainable if the size of the arrays
    change. When executed we get the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`length`方法来控制循环执行的次数。如果数组的大小发生变化，这将使代码更易于维护。执行时，我们得到以下输出：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice the use of the for-each statement when the array is displayed and the
    sum of the rows are calculated. This simplifies the calculations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在显示数组和计算行的总和时使用`for-each`语句。这简化了计算。
- en: The break and continue statements can also be used within nested loops. However,
    they will only be used in conjunction with the current loop. That is, a break
    out of an inner loop will only break out of the inner loop and not the outer loop.
    As we will see in the next section, we can break out of the outer loop from an
    inner loop using labels.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句也可以在嵌套循环中使用。但是，它们只能与当前循环一起使用。也就是说，从内部循环中跳出只会跳出内部循环，而不是外部循环。正如我们将在下一节中看到的，我们可以使用标签从内部循环中跳出外部循环。'
- en: 'In the following modification of the last nested loop sequence, we break out
    of the inner loop when the sum exceeds 2:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个嵌套循环序列的修改中，当总和超过2时，我们跳出内部循环：
- en: '[PRE64]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The execution of this nested loop will change the sum of the last row as shown
    below:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个嵌套循环的执行将改变最后一行的总和，如下所示：
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The break statement took us out of the inner loop but not the outer loop. We
    can break out of the outer loop if there was a corresponding break statement within
    the immediate body of the outer loop. The continue statement behaves in a similar
    fashion in relation to inner and outer loops.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句使我们跳出内部循环，但没有跳出外部循环。如果在外部循环的立即体中有相应的`break`语句，我们可以跳出外部循环。`continue`语句在内部和外部循环方面的行为类似。'
- en: Using labels
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: Labels are names of locations within a program. They can be used to alter the
    flow of control and should be used sparingly. In the previous example, we were
    unable to break out of the inner most loop using the break statement. However,
    labels can be used to break us out of more than one loop.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是程序内的位置名称。它们可以用于改变控制流，并且应该谨慎使用。在前面的例子中，我们无法使用break语句跳出最内层的循环。但是，标签可以用于跳出多个循环。
- en: 'In the following example, we place a label in front of the outer loop. In the
    inner loop, we execute the break statement when `i` is larger than 0 effectively
    terminating the outer loop after the sum has been calculated for the first row.
    A label consists of a name followed by a colon:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们在外部循环前放置一个标签。在内部循环中，当`i`大于0时执行break语句，有效地在第一行的求和计算完成后终止外部循环。标签由名称后跟一个冒号组成：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output of this sequence is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can also use the continue statement with labels for a similar effect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用带有标签的continue语句来达到类似的效果。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Labels should be avoided as they can result in unreadable and hard to maintain
    code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 标签应该避免，因为它们会导致代码难以阅读和维护。
- en: Infinite loops
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限循环
- en: An infinite loop is one that will execute forever unless a statement, such as
    the break statement is used to force its termination. Infinite loops are quite
    useful to avoid an awkward logical condition for a loop.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环是一种除非使用break语句等语句强制终止，否则将永远执行的循环。无限循环非常有用，可以避免循环的尴尬逻辑条件。
- en: 'An infinite while loop should use the `true` keyword as its logical expression:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无限while循环应该使用`true`关键字作为其逻辑表达式：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A for loop could be as simple as using nulls for each part of the for statement:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个for循环可以简单到使用nulls作为for语句的每个部分：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A loop that never terminates would not normally be of value for most programs
    since most programs should eventually terminate. However, most infinite loops
    are designed to terminate using the break statement, shown as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个永远不会终止的循环通常对大多数程序没有价值，因为大多数程序最终应该终止。然而，大多数无限循环都设计为使用break语句终止，如下所示：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This technique is fairly common and is used to simplify the logic of a program.
    Consider the need to read in an age and terminate when the age is negative. It
    is necessary to assign a non-negative value to age to ensure that the loop executes
    at least once:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术相当常见，用于简化程序的逻辑。考虑需要读取年龄并在年龄为负时终止的需要。需要为年龄分配一个非负值，以确保循环至少执行一次：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The other option is to duplicate the user prompt and the statement used to
    read in the age before the loop begins:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是在循环开始之前复制用户提示和用于读取年龄的语句：
- en: '[PRE72]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Either an arbitrary value had to be assigned to age before the loop began, or
    it was necessary to duplicate code. Neither approach is satisfactory.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环开始之前，要么需要为年龄分配一个任意值，要么需要复制代码。这两种方法都不令人满意。
- en: 'However, the use of an infinite loop results in cleaner code. No arbitrary
    value needs to be assigned and code does not need to be duplicated:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用无限循环会导致更清晰的代码。不需要分配任意值，也不需要复制代码：
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'While there are many situations where an infinite loop is desirable, they can
    also occur when the programmer is not careful, resulting in unanticipated results.
    One common way is to build a for loop without a valid termination condition, illustrated
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多情况下无限循环是可取的，但程序员在不小心的情况下也可能出现无限循环，导致意想不到的结果。一个常见的方式是构建一个没有有效终止条件的for循环，如下所示：
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The loop starts with a value of 1 for `i` and will increment `i` by 1 during
    each iteration of the loop. The termination condition suggests that the loop will
    not terminate as `i` will only get larger and would, thus, always be greater than
    0\. However, eventually the variable will overflow and `i` will become negative
    and the loop will terminate. How long this might take depends on the execution
    speed of the machine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 循环从`i`的值为1开始，并且在每次循环迭代时递增`i`。终止条件表明循环不会终止，因为`i`只会变得更大，因此总是大于0。然而，最终变量会溢出，`i`会变成负数，循环将终止。这需要多长时间取决于机器的执行速度。
- en: The moral of the story is, "Be careful with loops". Infinite loops can be both
    a useful construct for solving some problems and a problematic construct when
    used unintentionally.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，“小心循环”。无限循环既可以是解决某些问题的有用构造，也可以是在无意中使用时出现问题的构造。
- en: Timing is everything
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间就是一切
- en: A common programming need is to perform some sort of summation. We have computed
    the sum of several sequences of numbers in previous examples. While the summation
    process is relatively straightforward, it can be difficult for novice programmers.
    More importantly, we will use it here to provide an insight to the programming
    process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的编程需求是执行某种求和。我们在之前的例子中已经计算了几个数字序列的和。虽然求和过程相对简单，但对于新手程序员来说可能会很困难。更重要的是，我们将在这里使用它来提供对编程过程的洞察。
- en: 'Programming, by its nature, is an abstract process. The programmer will need
    to look at a static code listing and infer its dynamic execution. This can be
    difficult for many people. One way of assisting the developer in writing code
    is to consider the following three issues:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 编程本质上是一个抽象的过程。程序员需要查看静态代码清单并推断其动态执行。这对很多人来说可能很困难。帮助开发人员编写代码的一种方法是考虑以下三个问题：
- en: What do we want to do?
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要做什么？
- en: How do we want to do it?
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要怎么做？
- en: When do we want to do it?
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要做什么时候？
- en: Here, we will ask and apply the answers to these three questions to address
    the summation problem. However, these questions are equally applicable to other
    programming problems.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将询问并应用这三个问题的答案来解决求和问题。然而，这些问题同样适用于其他编程问题。
- en: 'Let''s focus on calculating the average age for a group of students, which
    will involve the summation process. Assume the ages are stored in `age` array
    and then initialized as shown in the following code snippet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于计算一组学生的平均年龄，这将涉及到求和过程。假设年龄存储在`age`数组中，然后按照以下代码片段中所示进行初始化：
- en: '[PRE75]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then the summation can be calculated as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后求和可以如下计算：
- en: '[PRE76]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Notice that `total` is explicitly assigned a zero value. Each iteration of
    the for loop will add the next `age` to `total`. At the completion of the loop,
    `total` will be divided by the length of the array times `1.0f` to compute the
    average. By using the array length the code expression does not need to be changed
    if the array size changes. Multiplying by `1.0f` is necessary to avoid integer
    division. The following table illustrates the variable''s values as the loop executes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`total`明确地被赋予了零值。for循环的每次迭代将把下一个`age`添加到`total`中。在循环完成时，`total`将被数组的长度乘以`1.0f`来计算平均值。通过使用数组长度，如果数组大小发生变化，代码表达式就不需要更改。乘以`1.0f`是为了避免整数除法。以下表格说明了循环执行时变量的值：
- en: '| Loop count | i | total |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 循环计数 | i | total |'
- en: '| --- | --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | - | 0 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 0 | - | 0 |'
- en: '| 1 | 1 | 23 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 23 |'
- en: '| 2 | 2 | 41 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 41 |'
- en: '| 3 | 3 | 60 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 60 |'
- en: '| 4 | 4 | 78 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 78 |'
- en: '| 5 | 5 | 99 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 99 |'
- en: 'Let''s examine this problem from the standpoint of the three basic questions,
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下三个基本问题的角度来考虑这个问题：
- en: '**What do we want to do**: We want to calculate the total pay for a department.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们想要做什么**：我们想要计算一个部门的总工资。'
- en: '**How do we want to do it**: This has a multipart answer. We know we need a
    variable to hold the total pay, `total`, and that it needs to be initialized to
    0.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们想要如何做**：这有一个多部分的答案。我们知道我们需要一个变量来保存总工资，`total`，并且它需要初始化为0。'
- en: '[PRE77]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also understand the basic operation to calculate the cumulative sum is as
    follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到计算累积和的基本操作如下：
- en: '[PRE78]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The loop needs to use each element of the array so a for-each statement is
    used:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 循环需要使用数组的每个元素，因此使用for-each语句：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We have the foundation for a solution to our problem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为解决问题奠定了基础。
- en: '**When do we want to do it**: The "when" in this situation suggests three basic
    choices:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们想要什么时候做**：在这种情况下，“何时”暗示着三个基本选择：'
- en: Before the loop
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环之前
- en: In the loop
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中
- en: After the loop
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环之后
- en: The three parts of our solution can be combined in different ways. The basic
    operation needs to be inside the loop because it needs to be performed more than
    once. Executing the basic operation only once will not result in an answer we
    will like.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案的三个部分可以以不同的方式组合。基本操作需要在循环内部，因为它需要执行多次。只执行一次基本操作将不会得到我们喜欢的答案。
- en: The variable, `total`, needs to be initialized with a 0\. How is this done?
    We do this by using an assignment statement. When should this be done? Before,
    in, or after the loop? Doing this after the loop would be silly. When the loop
    completes, `total` should contain the answer, not a zero. If we initialize it
    to 0 inside of the loop, then with each iteration of the loop, `total` is reset
    back to `0`. That leaves us with placing the statement before the loop as the
    only option that makes sense. The first thing we want to do is to assign a `0`
    to `total`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`total`需要初始化为0。如何做到这一点？我们通过使用赋值语句来实现。这应该在循环之前、之中还是之后完成？在循环之后这样做是愚蠢的。当循环完成时，`total`应该包含答案，而不是零。如果我们在循环内部将其初始化为0，那么在循环的每次迭代中，`total`都会被重置为0。这让我们只能选择在循环之前放置该语句作为唯一有意义的选项。我们想要做的第一件事是将`total`赋值为0。
- en: 'There seems to always be variations to the solutions of most problems. For
    example, we could have used a while loop instead of a for-each loop. The `+=`
    operator could be used to shorten the basic operation. One potential solution
    that uses these techniques introduces an index variable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数问题的解决方案似乎总是有所变化。例如，我们可以使用while循环而不是for-each循环。`+=`运算符可以用来简化基本操作。使用这些技术的一个潜在解决方案引入了一个索引变量：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Clearly, there is not always a best solution to a specific problem. This makes
    the programming process both a creative and potentially fun activity.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并不总是有一个特定问题的最佳解决方案。这使得编程过程既是一种创造性的，也是一种潜在有趣的活动。
- en: Pitfalls
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陷阱
- en: As with most programming constructs, loops have their own set of potential pitfalls.
    In this section we will address areas that can present problems to the unwary
    developer.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程结构一样，循环也有自己一套潜在的陷阱。在本节中，我们将讨论可能对不慎的开发人员造成问题的领域。
- en: 'One common problem occurs when programmers use a semicolon after every statement.
    For example, the following statement results in an infinite loop because of the
    extra semicolon:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员在每个语句后使用分号时，常见的问题之一是出现问题。例如，以下语句由于额外的分号导致无限循环：
- en: '[PRE81]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The semicolon on a line by itself is the empty statement. This statement does
    nothing. However, in this example it constitutes the body of the while loop. The
    increment statement is not part of the while loop. It is the first statement that
    follows the while loop. Indention, while desirable, does not make the statement
    a part of the loop. Thus, `i` is never incremented and the logical control expression
    will always return true.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 单独一行上的分号是空语句。这个语句什么也不做。然而，在这个例子中，它构成了while循环的主体部分。增量语句不是while循环的一部分。它是跟在while循环后面的第一个语句。缩进虽然是可取的，但并不会使语句成为循环的一部分。因此，`i`永远不会增加，逻辑控制表达式将始终返回true。
- en: 'Failure to use a block statement for the body of a loop can be a problem. In
    the following example we attempt to calculate the sum of the product of the numbers
    from 1 to 5\. However, this does not work properly because the body of the loop
    only encompasses the calculation of the product. The summation statement, when
    it is indented, is not part of the body of the loop and is only executed once:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的主体部分没有使用块语句可能会导致问题。在下面的例子中，我们尝试计算从1到5的数字的乘积的总和。然而，这并不起作用，因为循环的主体部分只包括了乘积的计算。当求和语句缩进时，它不是循环的主体部分，只会执行一次：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The correct implementation of the loop uses a block statement as shown below:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的正确实现如下所示使用块语句：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is always a good policy to use a block statement for the body of a loop,
    even if the body consists of a single statement.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的主体中始终使用块语句是一个很好的策略，即使主体只包含一个语句。
- en: 'In the following sequence the body of the loop consists of multiple statements.
    However, `i` is never incremented. This will also result in an infinite loop unless
    either limit is changed or a break statement is encountered:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下序列中，循环的主体由多个语句组成。然而，`i`从未递增。这也将导致无限循环，除非限制之一被更改或遇到break语句：
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Even simple-appearing loops may, in effect, be infinite loops if one is not
    careful with how floating-point arithmetic occurs. In this example, `0.1` is added
    to `x` with each iteration of the loop. The loop is supposed to stop when `x`
    exactly equals `1.1`. This will never occur because of issues in how floating
    point numbers are stored for certain values:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是看似简单的循环，如果对浮点运算不小心，实际上可能是无限循环。在这个例子中，每次循环迭代时，`x`都会加上`0.1`。循环应该在`x`恰好等于`1.1`时停止。这永远不会发生，因为某些值的浮点数存储方式存在问题：
- en: '[PRE85]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The number `0.1` cannot be stored precisely in base two in the same way that
    the decimal equivalent of the fraction 1/3 cannot be represented exactly (0.333333…).
    The result of adding this number repeatedly to `x` will result in a number that
    is not quite `1.1`. The comparison, `x != 1.1`, will return true and the loop
    will never end. The output of the `printf` statement does not show this difference:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制基数中，`0.1`不能被精确存储，就像分数1/3的十进制等价物无法被精确表示一样（0.333333…）。将这个数字重复添加到`x`的结果将导致一个不完全等于`1.1`的数字。比较`x
    != 1.1`将返回true，循环永远不会结束。`printf`语句的输出不显示这种差异：
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Be careful when working with operations that will involve auto-boxing. Depending
    on the implementation, it can result in a performance hit if boxing and un-boxing
    occurs frequently.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理涉及自动装箱的操作时要小心。根据实现方式，如果频繁发生装箱和拆箱，可能会导致性能损失。
- en: While not necessarily a pitfall, remember that logical expressions can short
    circuit. That is, the last part of a logical AND or OR operation may not be evaluated
    depending on the value returned from the evaluation of the first part. This is
    discussed in detail in the *Short circuit evaluation* section in [Chapter 3](ch03.html
    "Chapter 3. Decision Constructs"), *Decision Constructs*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不一定是陷阱，但要记住逻辑表达式可能会短路。也就是说，逻辑AND或OR操作的最后部分可能不会被评估，这取决于从第一部分评估返回的值。这在[第3章](ch03.html
    "第3章。决策结构")的*短路评估*部分中有详细讨论，*决策结构*。
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that arrays, strings, and most collections are zero based. Forgetting
    to start the loop at `0` will overlook this first element.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组、字符串和大多数集合都是从零开始的。忘记从`0`开始循环将忽略第一个元素。
- en: Always use a block statement as the body of a loop.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用块语句作为循环的主体。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we examined the support Java provides for loops. We have illustrated
    the use of the for, for-each, while, and do-while statements. These demonstrations
    provided insight into their correct usage, when they should be used, and when
    they should not be used.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了Java为循环提供的支持。我们已经说明了for、for-each、while和do-while语句的使用。这些演示提供了正确使用它们的见解，以及何时应该使用它们，何时不应该使用它们。
- en: The use of the break and continue statements was shown, along with the use of
    labels. We saw the utility of the break statement, in particular, in support of
    infinite loops. Labels, while they should be avoided, can be useful in breaking
    out of deeply nested loops.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了使用break和continue语句，以及标签的使用。我们看到了break语句的实用性，特别是在支持无限循环时。标签虽然应该避免使用，但在跳出嵌套循环时可能会有用。
- en: Various pitfalls were examined and the creation of the summation process was
    studied to gain insight into general programming problems. Specifically, it addressed
    the question of where a code segment should be placed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 研究了各种陷阱，并研究了总结过程的创建，以深入了解一般编程问题。具体而言，它解决了代码段应放置在何处的问题。
- en: Now that we've learned about loops, we're ready to examine the creation of classes,
    methods, and data encapsulation, which is the topic of the next chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了循环，我们准备研究类、方法和数据封装的创建，这是下一章的主题。
- en: Certification objectives covered
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证目标涵盖
- en: 'In this chapter we addressed the following certification objectives:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解决了以下认证目标：
- en: Creating and using the while loops
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用while循环
- en: Creating and using the for loops including the enhanced for loop
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用for循环，包括增强的for循环
- en: Creating and using the do/while loops
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用do/while循环
- en: Comparing the loop constructs
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较循环结构
- en: Using break and continue
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用break和continue
- en: 'In addition, we provided additional coverage of these objectives:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了对这些目标的额外覆盖：
- en: Define the scope of variables
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量的作用域
- en: Use operators and decision constructs
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符和决策结构
- en: Declaring and using an ArrayList
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和使用ArrayList
- en: Test your knowledge
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Given the following declarations, which of the following statement will compile?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下声明，哪个语句将编译？
- en: '[PRE87]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: a. `while(i < j) {}`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: a. `while(i < j) {}`
- en: b. `while(i) {}`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: b. `while(i) {}`
- en: c. `while(i = 5) {}`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: c. `while(i = 5) {}`
- en: d. `while((i = 12)!=5) {}`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: d. `while((i = 12)!=5) {}`
- en: Given the following declaration of an array, which statement will display each
    element of the array?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定数组的以下声明，哪个语句将显示数组的每个元素？
- en: '[PRE88]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'a. `for(int n : arr[]) { System.out.println(n); }`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'a. `for(int n : arr[]) { System.out.println(n); }`'
- en: 'b. `for(int n : arr) { System.out.println(n); }`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'b. `for(int n : arr) { System.out.println(n); }`'
- en: c. `for(int n=1; n < 6; n++) { System.out.println(arr[n]); }`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: c. `for(int n=1; n < 6; n++) { System.out.println(arr[n]); }`
- en: d. `for(int n=1; n <= 5; n++) { System.out.println(arr[n]); }`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: d. `for(int n=1; n <= 5; n++) { System.out.println(arr[n]); }`
- en: Which of the following do/while loops will compile without errors?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个do/while循环将在没有错误的情况下编译？
- en: a.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE89]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: b.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE90]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: c.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: d.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: d.
- en: '[PRE92]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Which of the following loops are equivalent?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个循环是等价的？
- en: a.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE93]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: b.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: c.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE95]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: What will be output by the following code?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将输出什么？
- en: '[PRE96]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'a. `i: 1 j: 2i: 2 j: 2i: 3 j: 2`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'a. `i: 1 j: 2i: 2 j: 2i: 3 j: 2`'
- en: 'b. `i: 1 j: 3i: 2 j: 3i: 3 j: 3`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'b. `i: 1 j: 3i: 2 j: 3i: 3 j: 3`'
- en: 'c. `i: 1 j: 1i: 2 j: 1i: 3 j: 1`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'c. `i: 1 j: 1i: 2 j: 1i: 3 j: 1`'
