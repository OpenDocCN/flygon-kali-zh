- en: Control Flow Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流语句
- en: This chapter describes one particular kind of Java statement, called control
    statements, which allow the building of a program flow according to the logic
    of the implemented algorithm, which includes selection statements, iteration statements,
    branching statements, and exception handling statements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一种特定类型的Java语句，称为控制语句，它允许根据实现的算法的逻辑构建程序流程，其中包括选择语句、迭代语句、分支语句和异常处理语句。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a control flow?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是控制流？
- en: 'Selection statements: `if`, `if....else`, `switch...case`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句：`if`、`if....else`、`switch...case`
- en: 'Iteration statements: `for`, `while`, `do...while`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代语句：`for`、`while`、`do...while`
- en: 'Branching statements: `break`, `continue`, `return`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支语句：`break`、`continue`、`return`
- en: 'Exception handling statements: `try...catch...finally`, `throw`, `assert`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理语句：`try...catch...finally`、`throw`、`assert`
- en: Exercise – Infinite loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-无限循环
- en: What is a control flow?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是控制流？
- en: A Java program is a sequence of statements that can be executed and produce
    some data or/and initiate some actions. To make the program more generic, some
    statements are executed conditionally, based on the result of an expression evaluation.  Such
    statements are called control flow statements because, in computer science, control
    flow (or flow of control) is the order in which individual statements are executed
    or evaluated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序是一系列可以执行并产生一些数据或/和启动一些操作的语句。为了使程序更通用，一些语句是有条件执行的，根据表达式评估的结果。这些语句称为控制流语句，因为在计算机科学中，控制流（或控制流）是执行或评估单个语句的顺序。
- en: By convention, they are divided into four groups: selection statements, iteration
    statements, branching statements, and exception handling statements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，它们被分为四组：选择语句、迭代语句、分支语句和异常处理语句。
- en: 'In the following sections, we will use the term block, which means a sequence
    of statements enclosed in braces. Here is an example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用术语块，它表示一系列用大括号括起来的语句。这是一个例子：
- en: '```java'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: x = 42;
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: x = 42;
- en: y = method(7, x);
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: y = method(7, x);
- en: System.out.println("Example");
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Example");
- en: '}'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A block can also include control statements – a doll inside a doll, inside a
    doll, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个块也可以包括控制语句-一个娃娃里面的娃娃，里面的娃娃，依此类推。
- en: Selection statements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'The control flow statements of the selection statements group are based on
    an expression evaluation. For example, here is one possible format: `if(expression)
    do something`. Or, another possible format: `if(expression) {do something} else
    {do something else}`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句组的控制流语句基于表达式的评估。例如，这是一种可能的格式：`if(expression) do something`。或者，另一种可能的格式：`if(expression)
    {do something} else {do something else}`。
- en: The expression may return a `boolean` value (as in the previous examples) or
    a specific value that can be compared with a constant. In the latter case, the
    selection statement has the format of a `switch` statement, which executes the
    statement or block that is associated with a particular constant value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可能返回一个`boolean`值（如前面的例子）或一个可以与常量进行比较的特定值。在后一种情况下，选择语句的格式为`switch`语句，它执行与特定常量值相关联的语句或块。
- en: Iteration statements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代语句
- en: Iteration statements execute a certain statement or block until a certain condition
    is reached. For example, it can be a `for` statement that executes a statement
    or a block for each value of a collection of values, or until a certain counter
    reaches the predefined threshold, or some other condition is reached. Each cycle
    of the execution is called an iteration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句执行某个语句或块，直到达到某个条件。例如，它可以是一个`for`语句，它执行一个语句或一组值的集合的每个值，或者直到某个计数器达到预定义的阈值，或者达到其他某些条件。执行的每个循环称为迭代。
- en: Branching statements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支语句
- en: Branching statements allow for breaking the current flow of the execution and
    continue executing from the first line after the current block, or from a certain
    (labeled) point in the control flow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分支语句允许中断当前执行流程并从当前块后的第一行继续执行，或者从控制流中的某个（标记的）点继续执行。
- en: A `return` statement in a method is also an example of a branching statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的`return`语句也是分支语句的一个例子。
- en: Exception handling statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理语句
- en: Exceptions are classes that represent events that happen during program execution
    and disrupt the normal execution flow. We have already seen examples of `NullPointerException`,
    `ClassCastException`, and `ArrayIndexOutOfBoundsException` generated under the
    corresponding conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是表示程序执行过程中发生的事件并中断正常执行流程的类。我们已经看到了在相应条件下生成的`NullPointerException`、`ClassCastException`和`ArrayIndexOutOfBoundsException`的示例。
- en: All the exception classes in Java have a common parent, the `java.lang.Exception`
    class, which in turn extends the `java.lang.Throwable` class. That's why all exception
    objects have common behaviors. They contain information about the cause of the
    exceptional condition and the location of its origination (line number of the
    class source code).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有异常类都有一个共同的父类，即`java.lang.Exception`类，它又扩展了`java.lang.Throwable`类。这就是为什么所有异常对象都有共同的行为。它们包含有关异常条件的原因和其起源位置（类源代码的行号）的信息。
- en: Each exception can be thrown either automatically (by JVM) or by the application
    code using the `throw` keyword. The method caller can catch the exception using
    the exception statements and perform some action based on the exception type and
    the message it (optionally) carries, or it can let the exception propagate further
    up the method call stack.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异常都可以被自动（由JVM）抛出，或者由应用程序代码使用`throw`关键字。方法调用者可以使用异常语句捕获异常，并根据异常类型和它（可选地）携带的消息执行某些操作，或者让异常进一步传播到方法调用堆栈的更高层。
- en: If none of the application methods in the stack catches the exception, it will
    eventually be caught by the JVM which will abort the application execution with
    an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆栈中的应用程序方法都没有捕获异常，最终将由JVM捕获异常，并用错误中止应用程序执行。
- en: So, the purpose of the exception handling statements is to generate (`throw`)
    and `catch` the exceptions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，异常处理语句的目的是生成（`throw`）和捕获异常。
- en: Selection statements
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'The selection statements have four variations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句有四种变体：
- en: '`if` statement'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: '`if...else` statement'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if...else`语句'
- en: '`if...else if-...-else` statement'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if...else if-...-else`语句'
- en: '`switch...case` statement'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch...case`语句'
- en: if
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if
- en: 'The simple `if` statement allows executing a certain statement or block conditionally,
    only when the result of the expression evaluation is `true`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`if`语句允许有条件地执行某个语句或块，仅当表达式求值结果为`true`时：
- en: '```java'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(booelan expression){
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: if(booelan expression){
- en: //do something
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些事情
- en: '}'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here are a few examples:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '```java'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'if(true) System.out.println("true");    //1: true'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'if(true) System.out.println("true");    //1: true'
- en: 'if(false) System.out.println("false");  //2:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'if(false) System.out.println("false");  //2:'
- en: int x = 1, y = 5;
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 1, y = 5;
- en: 'if(x > y) System.out.println("x > y");  //3:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'if(x > y) System.out.println("x > y");  //3:'
- en: 'if(x < y) System.out.println("x < y");  //4: x < y'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'if(x < y) System.out.println("x < y");  //4: x < y'
- en: 'if((x + 5) > y) {                       //5: x + 5 > y'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'if((x + 5) > y) {                       //5: x + 5 > y'
- en: System.out.println("x + 5 > y");
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x + 5 > y");
- en: x = y;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: x = y;
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'if(x == y){                             //6: x == y'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'if(x == y){                             //6: x == y'
- en: System.out.println("x == y");
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x == y");
- en: '}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Statement 1 prints `true`. Statements 2 and 3 print nothing. Statement 4 prints
    `x < y`. Statement 5 prints `x + 5 > y`. We used braces to create a block because
    we wanted the `x = y` statement to be executed only when the expression of this
    `if` statement evaluates to `true`. Statement 6 prints `x == y`. We could avoid
    using braces here because there is only one statement to execute. We did it for
    two reasons:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 语句1打印`true`。语句2和3什么也不打印。语句4打印`x < y`。语句5打印`x + 5 > y`。我们使用大括号创建了一个块，因为我们希望`x
    = y`语句仅在此`if`语句的表达式求值为`true`时执行。语句6打印`x == y`。我们可以避免在这里使用大括号，因为只有一个语句需要执行。我们这样做有两个原因：
- en: To demonstrate that braces can be used with a single statement too, thus forming
    a block of one statement.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了证明大括号也可以与单个语句一起使用，从而形成一个语句块。
- en: 'It is a good practice, in general, to have braces after `if`; it reads better
    and helps to avoid this frustrating error: you add another statement after if,
    assuming it is going to be executed only when the expression returns `true`:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的实践是，在`if`后面总是使用大括号`{}`；这样读起来更好，并有助于避免这种令人沮丧的错误：在`if`后添加另一个语句，假设它只在表达式返回`true`时执行：
- en: '```java'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(x > y) System.out.println("x > y");
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: if(x > y) System.out.println("x > y");
- en: x = y;
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: x = y;
- en: '```'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But, the statement `x = y` in this code is executed unconditionally. If you
    think such an error doesn't happen very often, you will be surprised.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，此代码中的语句`x = y`是无条件执行的。如果您认为这种错误并不经常发生，您会感到惊讶。
- en: It is a good practice to always use braces `{}` with an `if` statement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 始终在`if`语句后使用大括号`{}`是一个好习惯。
- en: 'As we have mentioned already, it is possible to include a selection statement
    inside the selection statement to create a more refined logic for the control
    flow:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，可以在选择语句内包含选择语句，以创建更精细的控制流逻辑：
- en: '```java'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(x > y){
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: if(x > y){
- en: System.out.println("x > y");
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x > y");
- en: if(x == 3){
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: if(x == 3){
- en: System.out.println("x == 3");
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x == 3");
- en: '}'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(y == 3){
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: if(y == 3){
- en: System.out.println("y == 3");
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("y == 3");
- en: System.out.println("x == " + x);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x == " + x);
- en: '}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It can go as deep (nested) as the logic requires.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以根据逻辑要求深入（嵌套）。
- en: if...else
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if...else
- en: 'The `if...else` construct allows executing a certain statement or block if
    the expression evaluates to `true`; otherwise, another statement or block is executed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`结构允许在表达式求值为`true`时执行某个语句或块；否则，将执行另一个语句或块：'
- en: '```java'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(Boolean expression){
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: if(Boolean expression){
- en: //do something
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些事情
- en: '} else {'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: //do something else
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些其他事情
- en: '}'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here are two examples:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个例子：
- en: '```java'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 1, y = 1;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 1, y = 1;
- en: if(x == y){
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: if(x == y){
- en: 'System.out.println("x == y");  //prints: x == y'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x == y");  //打印：x == y
- en: x = y - 1;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: x = y - 1;
- en: '} else {'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("x != y");
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x != y");
- en: '}'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(x == y){
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: if(x == y){
- en: System.out.println("x == y");
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x == y");
- en: '} else {'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: 'System.out.println("x != y");  //prints: x != y'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("x != y");  //打印：x != y
- en: '}'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see how easy it is to read this code when the braces `{}` are used consistently.
    And, as in the previous case of a simple `if` statement, each block can have another
    nested block with another `if` statement, and so on – as many blocks and as deeply nested
    as necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当大括号`{}`被一致使用时，您可以看到阅读此代码有多容易。并且，就像简单的`if`语句的情况一样，每个块都可以有另一个嵌套块，其中包含另一个`if`语句，依此类推
    - 可以有多少块和多么深的嵌套。
- en: if...else if-...-else
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if...else if-...-else
- en: 'You can use this form to avoid creating nested blocks and make the code easier
    to read and understand. For example, look at the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此形式来避免创建嵌套块，并使代码更易于阅读和理解。例如，看下面的代码片段：
- en: '```java'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(n > 5){
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: if(n > 5){
- en: System.out.println("n > 5");
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n > 5");
- en: '} else {'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: if (n == 5) {
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: if (n == 5) {
- en: System.out.println("n == 5");
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 5");
- en: '} else {'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: if (n == 4) {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: if (n == 4) {
- en: System.out.println("n == 4");
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 4");
- en: '} else {'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("n < 4");
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n < 4");
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'These nested `if...else` statements can be replaced by `if...else...if` statements
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些嵌套的`if...else`语句可以被以下`if...else...if`语句替换：
- en: '```java'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(n > 5){
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: if(n > 5){
- en: System.out.println("n > 5");
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n > 5");
- en: '} else if (n == 5) {'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (n == 5) {'
- en: System.out.println("n == 5");
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 5");
- en: '} else if (n == 4) {'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (n == 4) {'
- en: System.out.println("n == 4");
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 4");
- en: '} else {'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("n < 4");
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n < 4");
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Such code is easier to read and understand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码更容易阅读和理解。
- en: 'If you don''t need to do anything when `n < 4`, you can leave out the last
    catch-all-the-rest-options `else` clause:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n < 4`时不需要执行任何操作，则可以省略最后的`else`子句：
- en: '```java'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(n > 5){
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: if(n > 5){
- en: System.out.println("n > 5");
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n > 5");
- en: '} else if (n == 5) {'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (n == 5) {'
- en: System.out.println("n == 5");
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 5");
- en: '} else if (n == 4) {'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (n == 4) {'
- en: System.out.println("n == 4");
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("n == 4");
- en: '}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you need to do something for each particular value, you can write, for example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要针对每个特定值执行某些操作，可以编写如下：
- en: '```java'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if(x == 5){
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: if(x == 5){
- en: //do something
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些
- en: '} else if (x == 7) {'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (x == 7) {'
- en: //do something else
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些其他事情
- en: '} else if (x == 12) {'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (x == 12) {'
- en: //do something different
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些不同的事情
- en: '} else if (x = 50) {'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (x = 50) {'
- en: //do something yet more different
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些不同的事情
- en: '} else {'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: //do something completely different
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些完全不同的事情
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But there is a dedicated selection statement for such cases, called `switch...case`,
    which is easier to read and understand.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于这种情况有一个专门的选择语句，称为`switch...case`，更容易阅读和理解。
- en: switch...case
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: switch...case
- en: 'The previous code example of the last section can be expressed as a `switch`
    statement, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的代码示例可以表示为`switch`语句，如下所示：
- en: '```java'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: switch(x){
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: switch(x){
- en: 'case 5:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 5:'
- en: //do something
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些
- en: break;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'case 7:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 7:'
- en: //do something else
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些其他事情
- en: break;
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'case 12:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 12:'
- en: //do something different
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些不同的事情
- en: break;
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'case 50:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 50:'
- en: //do something yet more different
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些不同的事情
- en: break;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'default:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: //do something completely different
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些完全不同的事情
- en: '}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The type of the expression that returns the value of the `x` variable can be
    either `char`, `byte`, `short`, `int`, `Character`, `Byte`, `Short`, `Integer`,
    `String`, or an `enum` type. Notice the `break` keyword. It forces the exit from
    the `switch...case` statement. Without it, the following statement, `do something`,
    would be executed. We will talk about the `break` statement in the *Branching
    statements* section later.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`x`变量值的表达式的类型可以是`char`、`byte`、`short`、`int`、`Character`、`Byte`、`Short`、`Integer`、`String`或`enum`类型。注意`break`关键字。它强制退出`switch...case`语句。如果没有它，接下来的语句`do
    something`将被执行。我们将在*分支语句*部分后面讨论`break`语句。
- en: The types that can be used in a `switch` statement are `char`, `byte`, `short`, `int`, `Character`, `Byte`, `Short`, `Integer`, `String`,
    and an `enum` type. The value set in a case clause has to be a constant.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`switch`语句中使用的类型有`char`、`byte`、`short`、`int`、`Character`、`Byte`、`Short`、`Integer`、`String`和`enum`类型。在case子句中设置的值必须是常量。
- en: 'Let''s look at a method that takes advantage of the `switch` statement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个利用`switch`语句的方法：
- en: '```java'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void switchDemo(int n){
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: void switchDemo(int n){
- en: switch(n + 1){
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: switch(n + 1){
- en: 'case 1:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 1:'
- en: 'System.out.println("case 1: " + n);'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("case 1: " + n);'
- en: break;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'case 2:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 2:'
- en: 'System.out.println("case 2: " + n);'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("case 2: " + n);'
- en: break;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'default:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: 'System.out.println("default: " + n);'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("default: " + n);'
- en: break;
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The following code demonstrates how the `switch` statement works:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`switch`语句的工作原理：
- en: '```java'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'switchDemo(0);     //prints: case1: 0'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'switchDemo(0);     //打印：case1: 0'
- en: 'switchDemo(1);     //prints: case2: 1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'switchDemo(1);     //打印：case2: 1'
- en: 'switchDemo(2);     //prints: default: 2'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: switchDemo(2);     //打印：默认：2
- en: '```'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And, similar to the `else` clause in an `if` statement, the default clause
    is not required in a `switch` statement if it is not needed for the program logic:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句中的`else`子句类似，如果在程序逻辑中不需要`switch`语句中的默认子句，则默认子句是不需要的：
- en: '```java'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: switch(n + 1){
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: switch(n + 1){
- en: 'case 1:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 1:'
- en: 'System.out.println("case 1: " + n);'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("case 1: " + n);'
- en: break;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: 'case 2:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 2:'
- en: 'System.out.println("case 2: " + n);'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("case 2: " + n);'
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Iteration statements
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代语句
- en: Iteration statements are as fundamental for Java programming as selection statements.
    There is a good chance you will see and use them very often, too. Each iteration
    statement can be one of three forms: `while`, `do...while`, or `for`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句对于Java编程和选择语句一样重要。您很有可能经常看到并使用它们。每个迭代语句可以是`while`、`do...while`或`for`中的一种形式。
- en: while
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while
- en: 'The `while` statement executes a Boolean expression and a statement or a block
    repeatedly until the value of the expression evaluates as `false`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句执行布尔表达式和语句或块，直到表达式的值评估为`false`：'
- en: '```java'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: while (Boolean expression){
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: while (布尔表达式){
- en: //do something
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: //做一些
- en: '}'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are two things to note:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事需要注意：
- en: Braces `{}` are not necessary when only one statement has to be repeatedly executed,
    but are recommended for consistency and better code understanding
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当只有一个语句需要重复执行时，大括号`{}`是不必要的，但为了一致性和更好的代码理解，建议使用。
- en: The statement may not be executed at all (when the very first expression evaluation
    returns `false`)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语句可能根本不会执行（当第一个表达式评估为`false`时）
- en: 'Let''s look at some examples. The following loop executes the printing statement
    five times:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些示例。以下循环执行打印语句五次：
- en: '```java'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 0;
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 0;
- en: while(i++ < 5){
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: while(i++ < 5){
- en: 'System.out.print(i + " ");   //prints: 1 2 3 4 5'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(i + " ");   //打印：1 2 3 4 5
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice a different method used for printing: `print()` instead of `println()`.
    The latter adds an escape sequence `\n` after the printed line (we have explained
    what an escape sequence is in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*), which moves the cursor to the next line.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用的不同的打印方法：`print()`而不是`println()`。后者在打印行之后添加了一个转义序列`\n`（我们已经解释了转义序列是什么，位于[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*），它将光标移动到下一行。
- en: 'And here is an example of calling a method that returns some value which is
    accumulated until the required threshold is reached:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用返回某个值并累积直到达到所需阈值的方法的示例：
- en: '```java'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: while (result < 1d){
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: while (result < 1d){
- en: result += tryAndGetValue();
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: result += tryAndGetValue();
- en: System.out.println(result);
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `tryAndGetValue()` method is very simple and unrealistic, written only
    for demo purposes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`tryAndGetValue()` 方法非常简单和不切实际，只是为了演示目的而编写的：'
- en: '```java'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double tryAndGetValue(){
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: double tryAndGetValue(){
- en: return Math.random();
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: return Math.random();
- en: '}'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the last `while` statement, we will see something similar to the
    following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行最后一个 `while` 语句，我们将看到类似于以下内容：
- en: '![](img/fab4ec67-c60b-4037-a459-37af35dbc04d.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fab4ec67-c60b-4037-a459-37af35dbc04d.png)'
- en: The exact values will vary from run to run because the `Math.random()` method
    generates pseudo-random `double` values greater than or equal to 0.0 and less
    than 1.0\. As soon as an accumulated value becomes equal to 1.0 or exceeds it,
    the loop exits.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的值会因运行而异，因为 `Math.random()` 方法生成大于或等于0.0且小于1.0的伪随机 `double` 值。一旦累积值等于1.0或超过1.0，循环就会退出。
- en: 'It is tempting to make this loop simpler:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个循环变得更简单是很诱人的：
- en: '```java'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: while ((result += tryAndGetValue()) < 1d){
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: while ((result += tryAndGetValue()) < 1d){
- en: System.out.println(result);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or even simpler yet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至更简单：
- en: '```java'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: while ((result += Math.random()) < 1d){
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: while ((result += Math.random()) < 1d){
- en: System.out.println(result);
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '}'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But if we run any of the last two `while` statement variations, we will get
    something like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们运行最后两个 `while` 语句的变体中的任何一个，我们将得到以下内容：
- en: '![](img/08d31c48-80e3-42d0-89ce-c6634ee01f5d.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08d31c48-80e3-42d0-89ce-c6634ee01f5d.png)'
- en: The printed value will never be equal or exceed 1.0 because the expression with
    the newly accumulated value is evaluated before entering the execution block.
    That is something to keep an eye on when the calculations are included in the
    expression, not in the execution block.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的值永远不会等于或超过1.0，因为新累积值的表达式在进入执行块之前被评估。当计算包含在表达式中而不是在执行块中时，这是需要注意的事情。
- en: do...while
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do...while
- en: 'Similarly to the `while` statement, the `do...while` statement executes the
    Boolean expression repeatedly and the statement or block until the value of the
    Boolean expression evaluates as `false`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `while` 语句，`do...while` 语句重复执行布尔表达式和语句或块，直到布尔表达式的值评估为 `false`：
- en: '```java'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: do {
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: //statement or block
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: //语句或块
- en: '} while (Boolean expression)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '} while (Boolean expression)'
- en: '```'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But it executes the statement or the block first before the expression is evaluated,
    which means that the statement or block is executed at least once.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但它在评估表达式之前首先执行语句或块，这意味着语句或块至少会被执行一次。
- en: 'Let''s look at some examples. The following code executes the printing statement
    six times (one more than the similar `while` statement):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。以下代码执行打印语句六次（比类似的 `while` 语句多一次）：
- en: '```java'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 0;
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 0;
- en: do {
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: 'System.out.print(i + " ");   //prints: 0 1 2 3 4 5'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(i + " ");   //打印：0 1 2 3 4 5
- en: '} while(i++ < 5);'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '} while(i++ < 5);'
- en: '```'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'While the following code behaves the same way as a `while` statement:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的行为与 `while` 语句相同：
- en: '```java'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: do {
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: result += tryAndGetValue();
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: result += tryAndGetValue();
- en: System.out.println(result);
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '} while (result < 1d);'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '} while (result < 1d);'
- en: '```'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run this code, we will see something similar to the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到类似于以下内容：
- en: '![](img/7957ae0e-88ff-4d36-a4b9-9df736c28d38.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7957ae0e-88ff-4d36-a4b9-9df736c28d38.png)'
- en: That is because the value is printed after it is accumulated, and then the expression
    is evaluated before entering the execution block again.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为值在累积后被打印，然后在再次进入执行块之前评估表达式。
- en: 'The simplified `do...while` statement behaves differently. Here is an example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的 `do...while` 语句的行为不同。以下是一个例子：
- en: '```java'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: do {
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: System.out.println(result);
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '} while ((result += tryAndGetValue()) < 1d);'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '} while ((result += tryAndGetValue()) < 1d);'
- en: '```'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is the same code, but without using the `tryAndGetValue()` method:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的代码，但没有使用 `tryAndGetValue()` 方法：
- en: '```java'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double result = 0d;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: double result = 0d;
- en: do {
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: System.out.println(result);
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: '} while ((result += Math.random()) < 1d);'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '} while ((result += Math.random()) < 1d);'
- en: '```'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run any of the preceding two examples, we will get something like what''s
    in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前两个示例中的任何一个，我们将得到以下截图中的内容：
- en: '![](img/da256ca8-5d1a-4fe6-8b10-20d1f22b757a.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da256ca8-5d1a-4fe6-8b10-20d1f22b757a.png)'
- en: The initial value of the `result` variable is always printed first because the
    statement is executed at least once before the expression is evaluated the first
    time.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 变量的初始值总是首先打印，因为在第一次评估表达式之前至少执行一次该语句。'
- en: for
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for
- en: 'The format of the basic `for` statement looks as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 基本 `for` 语句的格式如下：
- en: '```java'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for(ListInit; Boolean Expression; ListUpdate) block or statement
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: for(ListInit; Boolean Expression; ListUpdate) block or statement
- en: '```'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, we will start with the most popular, much simpler, version and get back
    to the full version in the *For with multiple initializers and expressions* section later.
    The simpler basic `for` statement format looks like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们将从最流行的、更简单的版本开始，并在稍后的*带有多个初始化器和表达式的 For*部分回到完整版本。更简单的基本 `for` 语句格式如下：
- en: '```java'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for(DeclInitExpr; Boolean Expression; IncrDecrExpr) block or statement
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: for(DeclInitExpr; Boolean Expression; IncrDecrExpr) block or statement
- en: '```'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This definition consists of the following components:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义由以下组件组成：
- en: '`DeclInitExpr` is a declaration and initialization expression, like `x = 1`,
    that is evaluated only once at the very beginning of the `for` statement''s execution'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeclInitExpr` 是一个声明和初始化表达式，比如 `x = 1`，它只在 `for` 语句执行的最开始被评估一次'
- en: Boolean Expression is a Boolean expression, like `x < 10`,  that is evaluated
    at the beginning of each iteration – every time before executing the block or
    statement; if the result is `false`,  the `for` statement terminates
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boolean Expression 是一个布尔表达式，比如 `x < 10`，它在每次迭代开始时被评估 - 在执行块或语句之前每次都会被评估；如果结果是
    `false`，`for` 语句就会终止
- en: '`IncrDecrExpr` is an increment or a decrement unary expression, like `++x`, `--x`, `x++`, `x-`,
    that is evaluated at the end of each iteration – after the block or statement
    is executed'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IncrDecrExpr`是增量或递减一元表达式，如`++x`、`--x`、`x++`、`x-`，它在每次迭代结束后评估-在执行块或语句后'
- en: 'Notice that we talk about expressions, not statements, although with added
    semicolons, they look like statements. The reason for that is that a semicolon
    serves as the separator between the expressions in the `for` statement. Let''s
    look at an example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们谈论的是表达式，而不是语句，尽管添加了分号，它们看起来像语句。这是因为分号在`for`语句中作为表达式之间的分隔符。让我们看一个例子：
- en: '```java'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (int i=0; i < 3; i++){
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i=0; i < 3; i++){
- en: 'System.out.print(i + " ");  //prints: 0 1 2'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(i + " ");  //输出：0 1 2
- en: '}'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In this code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中：
- en: '`int i=0` is the declaration and initialization expression, evaluated only
    once at the very beginning'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int i=0`是声明和初始化表达式，仅在一开始时评估一次'
- en: '`i < 3` is the Boolean expression, evaluated at the beginning of each iteration
    – before executing the block or statement; if the result is `false` ( `i >= 3`,
    in this case), the `for` statement execution terminates'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i < 3`是布尔表达式，在每次迭代开始时评估-在执行块或语句之前；如果结果为`false`（在这种情况下为`i >= 3`），则`for`语句的执行终止'
- en: '`i++` is the increment expression, evaluated after the block or statement is
    executed'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i++`是增量表达式，在执行块或语句后评估'
- en: And, as in the case of a `while` statement, the braces `{}` are not needed when
    only one statement has to be executed, but it is a good style to have them, so
    the code is consistent and easier to read.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，与`while`语句的情况一样，当只有一个语句需要执行时，大括号`{}`是不需要的，但最好有它们，这样代码就更一致，更容易阅读。
- en: 'None of the expressions in a `for` statement are required:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句中的任何表达式都不是必需的：'
- en: '```java'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int k = 0;
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: int k = 0;
- en: for (;;){
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: for (;;){
- en: 'System.out.print(k++ + " ");     //prints: 0 1 2'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(k++ + " ");     //输出：0 1 2
- en: if(k > 2) break;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: if(k > 2) break;
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But using expressions in the statement declaration is more convenient and conventional,
    thus easier to understand. And here are other examples:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但在语句声明中使用表达式更方便和常规，因此更容易理解。以下是其他示例：
- en: '```java'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (int i=0; i < 3;){
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i=0; i < 3;){
- en: 'System.out.print(i++ + " "); //prints: 0 1 2'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(i++ + " "); //输出：0 1 2
- en: '}'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for (int i=2; i > 0; i--){
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i=2; i > 0; i--){
- en: 'System.out.print(i + " "); //prints: 2 1'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(i + " "); //输出：2 1
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice how in the last example, the decrement operator is used to walk down
    the initial `i` value.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后一个示例中，递减运算符用于减小初始`i`值。
- en: While using a `for` statement, or any iteration statement for that matter, make
    sure the exit condition will be reached (unless you deliberately create an infinite
    loop). That is the main concern around which the iteration statement is built.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`for`语句或任何迭代语句时，请确保达到退出条件（除非您故意创建无限循环）。这是迭代语句构建的主要关注点。
- en: for enhanced
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于增强
- en: 'As we have mentioned already, a `for` statement is a very convenient way to
    access array components (elements):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，`for`语句是访问数组组件（元素）的一种非常方便的方式：
- en: '```java'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arr = {21, 34, 5};
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {21, 34, 5};
- en: for (int i=0; i < arr.length; i++){
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i=0; i < arr.length; i++){
- en: 'System.out.print(arr[i] + " ");  //prints: 21 34 5'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(arr[i] + " ");  //输出：21 34 5
- en: '}'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice how we use the public property `length` of an array object to make sure
    we have reached all the array elements. But in such a case, when all the array
    has to be traversed, it is better (easier to write and to read) to use an enhanced
    `for` statement that has the following format:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用数组对象的公共属性`length`来确保我们已经到达了所有的数组元素。但在这种情况下，当需要遍历整个数组时，最好（更容易编写和阅读）使用以下格式的增强`for`语句：
- en: '```java'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <Type> arr = ...;              //an array or any Iterable
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <Type> arr = ...;              //数组或任何Iterable
- en: 'for (<Type> a: arr){'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (<Type> a: arr){'
- en: System.out.print(a + " ");
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(a + " ");
- en: '}'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see from the comment, it is applicable to an array or a class that
    implements the interface `Iterable`. This interface has an `iterator()` method that
    returns an object of class `Iterator` which, in turn, has a method called `next()`
    that allows accessing the class members sequentially.  We will talk about such
    classes, called collections, in [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java Collections*. So, we can rewrite the last `for` statement example and use
    the enhanced `for` statement:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 从注释中可以看出，它适用于数组或实现接口`Iterable`的类。该接口具有一个`iterator()`方法，返回一个`Iterator`类的对象，该类又有一个名为`next()`的方法，允许按顺序访问类成员。我们将在[第13章](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml)中讨论这样的类，称为集合，*Java集合*。因此，我们可以重写最后的`for`语句示例并使用增强的`for`语句：
- en: '```java'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arr = {21, 34, 5};
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {21, 34, 5};
- en: 'for (int a: arr){'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (int a: arr){'
- en: 'System.out.print(a + " ");  //prints: 21 34 5'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(a + " ");  //输出：21 34 5
- en: '}'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the case of a collection class that implements an interface `List` (and
    `List` extends `Iterable`), the sequential access to its members looks very similar:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现`List`接口（`List`扩展`Iterable`）的集合类，对其成员的顺序访问看起来非常相似：
- en: '```java'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("Bob", "Joe", "Jill");
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("Bob", "Joe", "Jill");
- en: 'for (String s: list){'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s: list){'
- en: 'System.out.print(s + " ");  //prints: Bob Joe Jill'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(s + " ");  //输出：Bob Joe Jill
- en: '}'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But when not all elements of an array or collection have to be accessed, some
    other form of an iteration statement is probably better suited.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当不需要访问数组或集合的所有元素时，可能有其他形式的迭代语句更适合。
- en: Also, please notice that since Java 8, many data structures can produce streams
    that allow writing much more compact code and avoid the use of for statements
    whatsoever. We will show you how to do it in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，自Java 8以来，许多数据结构可以生成流，允许编写更紧凑的代码，并且完全避免使用`for`语句。我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中向您展示如何做到这一点，*流和管道*。
- en: for with multiple initializers and expressions
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于多个初始化程序和表达式
- en: Now, let's return to the basic `for` statement format once more. It allows much
    more variety in using it than many programmers even know about. And it is not
    because of a lack of interest or professional curiosity, but probably because
    this additional functionality usually is not needed. Yet, once in a while, when
    you read somebody's code or during a job interview, you may encounter the need
    to know the full picture. So, we decided to at least mention it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次回到基本的`for`语句格式。它允许使用的变化比许多程序员知道的要多得多。这不是因为缺乏兴趣或专业好奇心，而可能是因为通常不需要这种额外的功能。然而，偶尔当你阅读别人的代码或在面试中，你可能会遇到需要了解全貌的情况。因此，我们决定至少提一下。
- en: 'The full format of `for` statements is built around lists of expressions:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的完整格式建立在表达式列表周围：'
- en: '```java'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for(ListInit; Boolean Expression; ListUpdate) block or statement
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: for(ListInit; Boolean Expression; ListUpdate) block or statement
- en: '```'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This definition consists of the following components:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义由以下组件组成：
- en: '`ListInit`: May include a declaration list and/or an expression list'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListInit`: 可包括声明列表和/或表达式列表'
- en: '`Expression`: Boolean expression'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expression`: 布尔表达式'
- en: '`ListUpdate`: Expression list'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListUpdate`: 表达式列表'
- en: 'The expression list members, separated by a comma, can be:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式列表成员，用逗号分隔，可以是：
- en: '**Assignment**: `x = 3`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值**：`x = 3`'
- en: '**Pre/postfix increment/decrement expression**: `++x`  `--x`  `x++`  `x--`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前/后缀递增/递减表达式**：`++x`  `--x`  `x++`  `x--`'
- en: '**Method invocation**: `method(42)`'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用**：`method(42)`'
- en: '**Object creation expression**: `new SomeClass(2, "Bob")`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象创建表达式**：`new SomeClass(2, "Bob")`'
- en: 'The following two `for` statements produce identical results:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个`for`语句产生相同的结果：
- en: '```java'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (int i=0, j=0; i < 3 && j < 3; ++i, ++j){
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i=0, j=0; i < 3 && j < 3; ++i, ++j){
- en: System.out.println(i + " " + j);
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i + " " + j);
- en: '}'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'for (int x=new A().getInitialValue(), i=x == -2 ? x + 2 : 0, j=0;'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (int x=new A().getInitialValue(), i=x == -2 ? x + 2 : 0, j=0;'
- en: i < 3 || j < 3 ; ++i, j = i) {
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: i < 3 || j < 3 ; ++i, j = i) {
- en: System.out.println(i + " " + j);
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i + " " + j);
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Where the `getInitialValue()` method has the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInitialValue()`方法的代码如下：'
- en: '```java'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A{
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: class A{
- en: int getInitialValue(){ return -2; }
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: int getInitialValue(){ return -2; }
- en: '}'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, even such a simple functionality can look very complex and even
    be confusing when multiple initializers, assignments, and expressions are excessively
    used. If in doubt, keep your code simple and easy to understand. Sometimes it
    is not easy, but in our experience, it can always be done, and being easy to understand
    is one of the most important criteria of good code quality.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，即使是这样一个简单的功能，当过多地使用多个初始化程序、赋值和表达式时，它看起来可能非常复杂甚至令人困惑。如果有疑问，保持你的代码简单易懂。有时候这并不容易，但根据我们的经验，总是可以做到的，而易于理解是良好代码质量的最重要标准之一。
- en: Branching statements
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支语句
- en: You have already seen the branching statements `break` and `return` in our examples. 
    We will define and discuss them and the third member of the group—the branching
    statement `continue` —in this section.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在我们的例子中看到了分支语句`break`和`return`。我们将在本节中定义和讨论它们以及该组的第三个成员——分支语句`continue`。
- en: Break and labeled break
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和标记中断
- en: As you have probably noticed, the `break` statement is essential for the `switch...case`
    selection statements to be able to work (see the s*witch...case* section for more
    information). If included in the execution block of an iteration statement, it causes
    the `for` or `while` statement to terminate immediately.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`break`语句对于`switch...case`选择语句能够正常工作是至关重要的（有关更多信息，请参阅`switch...case`部分）。如果包含在迭代语句的执行块中，它会立即终止`for`或`while`语句。
- en: 'It is widely used in iteration statements while searching for a particular
    element in an array or collection. To demonstrate how it works, let''s assume,
    for example, that we need to find a certain person by age and name among the students
    and teachers of a community college. Let''s first create the classes `Person`,
    `Student`, and `Teacher`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 它在迭代语句中被广泛使用，用于在数组或集合中搜索特定元素。为了演示它的工作原理，例如，假设我们需要在社区学院的学生和教师中通过年龄和姓名找到某个人。首先创建`Person`，`Student`和`Teacher`类：
- en: '```java'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person{
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: class Person{
- en: private int age;
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private  String name;
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: private  String name;
- en: public Person(int age, String name) {
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name) {
- en: this.age = age;
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: this.name = name;
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: '}'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public Boolean equals(Object o) {
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: public Boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == o) return true;
- en: Person person = (Person) o;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = (Person) o;
- en: return age == person.age &&
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: return age == person.age &&
- en: Objects.equals(name, person.name);
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Objects.equals(name, person.name);
- en: '}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{age=" + age +
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: return "Person{age=" + age +
- en: '", name=''" + name + "''}";'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '", name=''" + name + "''}";'
- en: '}'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class Student extends Person {
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: class Student extends Person {
- en: private int year;
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: private int year;
- en: public Student(int age, String name, int year) {
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: public Student(int age, String name, int year) {
- en: super(age, name);
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: super(age, name);
- en: this.year = year;
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: this.year = year;
- en: '}'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Student{year=" + year +
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: return "Student{year=" + year +
- en: '", " + super.toString() + "}";'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '", " + super.toString() + "}";'
- en: '}'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class Teacher extends Person {
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: class Teacher extends Person {
- en: private String subject;
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: private String subject;
- en: public Teacher(int age, String name, String subject) {
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: public Teacher(int age, String name, String subject) {
- en: super(age, name);
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: super(age, name);
- en: this.subject = subject;
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: this.subject = subject;
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Student{subject=" + subject +
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: return "Student{subject=" + subject +
- en: '", " + super.toString() + "}";'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '", " + super.toString() + "}";'
- en: '}'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the method `equals()` is implemented only in the base class `Person`.
    We identify a person by name and age only. Also, notice the use of the keyword
    `super` that allows us to access the constructor and `toString()` method of the
    parent class.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`equals()`方法只在基类`Person`中实现。我们只通过姓名和年龄来识别一个人。还要注意使用关键字`super`，它允许我们访问父类的构造函数和`toString()`方法。
- en: 'Let''s assume that we are assigned to find a person (by name and age) in a
    community college database. So, we have created a collection of type `List` and
    we will iterate over it until we find a match:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被指派在社区学院数据库中查找一个人（按姓名和年龄）。因此，我们已经创建了一个`List`类型的集合，并将在其中进行迭代，直到找到匹配项：
- en: '```java'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list =
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list =
- en: List.of(new Teacher(32, "Joe", "History"),
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: List.of(new Teacher(32, "Joe", "History"),
- en: new Student(29,"Joe", 4),
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(29,"Joe", 4),
- en: new Student(28,"Jill", 3),
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(28,"Jill", 3),
- en: new Teacher(33, "ALice", "Maths"));
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: new Teacher(33, "ALice", "Maths"));
- en: Person personOfInterest = new Person(29,"Joe");
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Person personOfInterest = new Person(29,"Joe");
- en: Person person = null;
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = null;
- en: 'for (Person p: list){'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（Person p: list）{'
- en: System.out.println(p);
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p);
- en: if(p.equals(personOfInterest)){
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（p.equals(personOfInterest)）{
- en: person = p;
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: person = p;
- en: break;
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(person == null){
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（人== null）{
- en: 'System.out.println("Not found: " + personOfInterest);'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Not found: " + personOfInterest);'
- en: '} else {'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: 'System.out.println("Found: " + person);'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Found: " + person);'
- en: '}'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run this program, the result will be:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，结果将是：
- en: '![](img/5d1a86d0-d089-4e18-80b6-fb25ea409a53.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d1a86d0-d089-4e18-80b6-fb25ea409a53.png)'
- en: 'We have found the person we were looking for. But if we change our search and
    look for another person (just one year at age difference):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了我们要找的人。但是如果我们改变我们的搜索并寻找另一个人（只相差一岁）：
- en: '```java'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person personOfInterest = new Person(30,"Joe");
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Person personOfInterest = new Person(30,"Joe");
- en: '```'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '![](img/61fb11ee-a3a3-4c3b-a0cc-c2228878a8f7.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61fb11ee-a3a3-4c3b-a0cc-c2228878a8f7.png)'
- en: As you can see, the `break` statement allows exiting the loop as soon as the
    object of interest is found, thus not wasting time on iterating over all the collection,
    which may be quite large.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`break`语句允许在找到感兴趣的对象时立即退出循环，从而不浪费时间在迭代整个可能相当大的集合上。
- en: In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*,
    we will show you another (often more efficient) way to search a collection or
    an array. But iterating over the elements is still a viable way to do it in many
    cases.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中，*流和管道*，我们将向您展示另一种（通常更有效）搜索集合或数组的方法。但在许多情况下，迭代元素仍然是一种可行的方法。
- en: 'The `break` statement can be used for searching a particular element in a multidimensional
    data structure, too. Let''s assume we need to search a three-dimensional array
    and find the array of the lowest dimension that has the sum of its elements equal
    to or bigger than 4\. Here is an example of such an array:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句也可以用于在多维数据结构中搜索特定元素。假设我们需要搜索一个三维数组，并找到其元素之和等于或大于4的最低维度数组。这是这样一个数组的示例：'
- en: '```java'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
- en: '```'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The lowest dimension array we are looking for is `{1,3,0}`. If the first dimension
    is `x` and the second dimension is `y`, then the location of this array is `x=1`,
    `y=1`, or `[1][1]`. Let''s write a program that finds this array:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的最低维度数组是`{1,3,0}`。如果第一维是`x`，第二维是`y`，那么这个数组的位置是`x=1`，`y=1`，或`[1][1]`。让我们编写一个程序来找到这个数组：
- en: '```java'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
- en: int threshold = 4;
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: int threshold = 4;
- en: int x = 0, y = 0;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0, y = 0;
- en: Boolean isFound = false;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Boolean isFound = false;
- en: 'for(int[][] dd: data){'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int[][] dd: data）{'
- en: y = 0;
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0;
- en: 'for(int[] d: dd){'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int[] d: dd）{'
- en: int sum = 0;
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = 0;
- en: 'for(int i: d){'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int i: d）{'
- en: sum += i;
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: sum += i;
- en: if(sum >= threshold){
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（sum >= threshold）{
- en: isFound = true;
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: isFound = true;
- en: break;
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(isFound){
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（isFound）{
- en: break;
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: y++;
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: '}'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(isFound){
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（isFound）{
- en: break;
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: x++;
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: '}'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
- en: '//prints: isFound=true, x=1, y=1'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：isFound=true, x=1, y=1
- en: '```'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, we use a Boolean variable called `isFound` to facilitate exit
    from outer loops as soon as the desired result is found in the innermost loop.
    The boring need to check the value of the `isFound` variable made Java authors
    introduce a label – an identifier followed by a colon sign (`:`) that can be placed
    in front of a statement. The `break` statement can take advantage of it. Here
    is how the previous code can be changed using a label:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用一个名为`isFound`的布尔变量来方便地从最内层循环中退出，一旦在内部循环中找到了期望的结果。检查`isFound`变量的值的无聊需要使Java作者引入了一个标签
    - 一个标识符后跟着一个冒号（`:`），可以放在语句的前面。`break`语句可以利用它。以下是如何使用标签更改先前的代码：
- en: '```java'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
- en: int threshold = 4;
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: int threshold = 4;
- en: int x = 0, y = 0;
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0, y = 0;
- en: Boolean isFound = false;
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Boolean isFound = false;
- en: 'exit:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 退出：
- en: 'for(int[][] dd: data){'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int[][] dd: data）{'
- en: y = 0;
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0;
- en: 'for(int[] d: dd){'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int[] d: dd）{'
- en: int sum = 0;
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = 0;
- en: 'for(int i: d){'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '对于（int i: d）{'
- en: sum += i;
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: sum += i;
- en: if(sum >= threshold){
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（sum >= threshold）{
- en: isFound = true;
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: isFound = true;
- en: break exit;
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: break exit;
- en: '}'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: y++;
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: '}'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: x++;
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: '}'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
- en: '//prints: isFound=true, x=1, y=1'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：isFound=true, x=1, y=1
- en: '```'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We still use the variable `isFound` but only for reporting purposes. The `exit:` label
    allows the `break` statement to specify which statement has to stop executing.
    This way, we do not need to write boilerplate code checking the `isFound` variable's
    value.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用变量`isFound`，但仅用于报告目的。`exit:`标签允许`break`语句指定哪个语句必须停止执行。这样，我们就不需要编写检查`isFound`变量值的样板代码。
- en: Continue and labeled continue
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续和标记继续
- en: 'The `continue` statement supports functionality similar to the one supported
    by the `break` statement. But instead of exiting the loop, it forces exiting the
    current iteration only, so the loop continues executing. To demonstrate how it
    works, let''s assume that, as in the case with the `break` statement in the previous
    section, we need to search a three-dimensional array and find the array of the
    lowest dimension that has the sum of its elements equal to or bigger than 4\.
    But this time, the sum should not include an element equal to 1\. Here is the
    array:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句支持与`break`语句支持的功能类似。但是，它不是退出循环，而是强制退出当前迭代，所以循环继续执行。为了演示它的工作原理，让我们假设，就像前一节中`break`语句的情况一样，我们需要搜索一个三维数组，并找到其元素总和等于或大于4的最低维度的数组。但是这次，总和不应包括等于1的元素。这是数组：'
- en: '```java'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
- en: '```'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Our program should find the following arrays:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序应该找到以下数组：
- en: '`data[0][2] = {2,4,1}`, `sum = 6` (because 1 has to be skipped)'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[0][2] = {2,4,1}`, `sum = 6` (因为1必须被跳过)'
- en: '`data[0][3] = {2,3,2}`, `sum = 7`'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[0][3] = {2,3,2}`, `sum = 7`'
- en: '`data[1][1] = {1,3,4}`, `sum = 7` (because 1 has to be skipped)'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[1][1] = {1,3,4}`, `sum = 7` (因为1必须被跳过)'
- en: '`data[1][3]={2,2,2}`, `sum = 6`'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[1][3]={2,2,2}`, `sum = 6`'
- en: The sum of other array elements does not reach 4 if 1 is skipped.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跳过1，则其他数组元素的总和不会达到4。
- en: 'Here is the program:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序：
- en: '```java'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
- en: int threshold = 4;
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: int threshold = 4;
- en: int x = 0, y;
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0, y;
- en: 'for(int[][] dd: data){'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(int[][] dd: data){'
- en: y = 0;
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0;
- en: 'for(int[] d: dd){'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(int[] d: dd){'
- en: int sum = 0;
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = 0;
- en: 'for(int i: d){'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(int i: d){'
- en: if(i == 1){
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 1){
- en: continue;
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: continue;
- en: '}'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: sum += i;
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: sum += i;
- en: '}'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(sum >= threshold){
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: if(sum >= threshold){
- en: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
- en: '}'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: y++;
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: '}'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: x++;
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: '}'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run it, the result will be:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，结果将是：
- en: '![](img/74f53e31-3c98-4c50-9dc5-ea22b18790dd.png)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74f53e31-3c98-4c50-9dc5-ea22b18790dd.png)'
- en: 'As you can see, the results are exactly as we expected: all elements of 1 were
    skipped.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果正如我们所期望的那样：所有元素1都被跳过了。
- en: 'To demonstrate how the labeled `continue` statement can be used, let''s change
    the requirements: not only the element 1 has to be skipped, but all the arrays
    that contain such an element have to be ignored too. In other words, we need to
    find arrays that do not contain 1 and have a sum of the elements equal to or bigger
    than 4.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用带标签的`continue`语句，让我们改变要求：不仅要跳过元素1，还要忽略包含这样一个元素的所有数组。换句话说，我们需要找到不包含1并且元素的总和等于或大于4的数组。
- en: 'Our program should find only two arrays:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序应该只找到两个数组：
- en: '`data[0][3] = {2,3,2}`, `sum = 7`'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[0][3] = {2,3,2}`, `sum = 7`'
- en: '`data[1][3] = {2,2,2}`, `sum = 6`'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data[1][3] = {2,2,2}`, `sum = 6`'
- en: 'Here is the code that does it:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现它的代码：
- en: '```java'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[][][] data = {
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: int[][][] data = {
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
- en: int threshold = 4;
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: int threshold = 4;
- en: int x = 0, y;
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0, y;
- en: 'for(int[][] dd: data){'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(int[][] dd: data){'
- en: y = 0;
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0;
- en: 'cont: for(int[] d: dd){'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 'cont: for(int[] d: dd){'
- en: int sum = 0;
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = 0;
- en: 'for(int i: d){'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(int i: d){'
- en: if(i == 1){
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: if(i == 1){
- en: y++;
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: continue cont;
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: continue cont;
- en: '}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: sum += i;
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: sum += i;
- en: '}'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(sum >= threshold){
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: if(sum >= threshold){
- en: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
- en: '}'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: y++;
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: '}'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: x++;
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: '}'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, we have added a label called `cont:` and refer it in the `continue`
    statement, so the current iteration of the innermost loop and the iteration of
    the next outer loop stops executing. The outer loop then continues executing the
    next iteration.  If we run the code, the results will be:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加了一个名为`cont:`的标签，并在`continue`语句中引用它，因此内部循环的当前迭代和下一个外部循环的迭代停止执行。外部循环然后继续执行下一个迭代。如果我们运行代码，结果将是：
- en: '![](img/9e701141-fa2f-411a-8827-6e7aa41bc93e.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e701141-fa2f-411a-8827-6e7aa41bc93e.png)'
- en: All the other arrays were skipped either because they contained 1 or the sum
    of their elements was less than 4.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他数组都被跳过，因为它们包含1或其元素的总和小于4。
- en: return
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回
- en: The `return` statement can be placed only in a method or a constructor. Its
    function is to return control to the invoker with or without a value.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句只能放在方法或构造函数中。它的功能是返回控制权给调用者，有或没有值。'
- en: 'In the case of a constructor, the `return` statement is not required. If placed
    in the constructor, it has to be the last statement that returns no value:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的情况下，不需要`return`语句。如果放在构造函数中，它必须是最后一条不返回值的语句：
- en: '```java'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ConstructorDemo{
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 类ConstructorDemo{
- en: private int field;
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: private int field;
- en: public ConstructorDemo(int i) {
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: public ConstructorDemo(int i) {
- en: this.field = i;
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: this.field = i;
- en: return;
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: An attempt to place the `return` statement as not the last statement of a constructor
    or to make it return any value will result in a compilation error.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 试图将`return`语句放在构造函数的最后一条语句之外，或者使其返回任何值，都会导致编译错误。
- en: 'In the case of a method, if the method was declared as returning some type:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的情况下，如果方法被声明为返回某种类型：
- en: The `return` statement is required
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句是必需的'
- en: The `return` statement has to be effectively (see the following example) the
    last statement of the method
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句必须有效地（见下面的示例）是方法的最后一条语句'
- en: There may be several return statements, but one of them has to be effectively
    (see the following example) the last statement of the method, while the others
    have to be inside a selection statement; otherwise, a compilation error will be
    generated
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能有几个返回语句，但其中一个必须有效地（见下面的示例）是方法的最后一条语句，而其他的必须在选择语句内部；否则，将生成编译错误
- en: If the `return` statement does not return anything, it causes a compilation
    error
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`return`语句不返回任何内容，将导致编译错误
- en: If the `return` statement returns a type that is not the one declared in the
    method definition and not its subtype, it causes a compilation error
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`return`语句返回的类型不是方法定义中声明的类型，也不是其子类型，它会导致编译错误
- en: Boxing, unboxing, and type widening are performed automatically, while type
    narrowing requires typecasting
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装箱、拆箱和类型扩宽是自动执行的，而类型缩窄需要类型转换
- en: 'The following example demonstrates the `return` statement being effectively
    the last statement of a method:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了`return`语句有效地成为方法的最后一条语句：
- en: '```java'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public String method(int n){
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(int n){
- en: if(n == 1){
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: if(n == 1){
- en: return "One";
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 返回“一个”；
- en: '} else {'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: return "Not one";
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: return "不是一个";
- en: '}'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The last statement of the method is a selection statement, but the `return`
    statement is the last one executed inside the selection statement.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的最后一条语句是选择语句，但`return`语句是选择语句内最后执行的语句。
- en: 'Here''s an example of a method with many return statements:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有许多返回语句的方法的示例：
- en: '```java'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static String methodWithManyReturns(){
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: public static String methodWithManyReturns(){
- en: if(true){
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: if(true){
- en: return "The only one returned";
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: return "唯一返回的";
- en: '}'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(true){
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: if(true){
- en: return "Is never reached";
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: return "永远不会到达";
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return "Is never reached";
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: return "永远不会到达";
- en: '}'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although in the method, only the first `return` statement always returned, the
    compiler does not complain and the method is executed without a runtime error.
    It just always returns a `The only one returned` literal.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在方法中，只有第一个`return`语句总是返回，但编译器不会抱怨，方法会在没有运行时错误的情况下执行。它只是总是返回一个`唯一返回的`文字。
- en: 'The following examples of methods with several return statements are more realistic:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是具有多个返回语句的更现实的方法示例：
- en: '```java'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public Boolean method01(int n){
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: public Boolean method01(int n){
- en: if(n < 0) {
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: if(n < 0) {
- en: return true;
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '} else {'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: return false;
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Boolean sameAsMethod01(int n){
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: public Boolean sameAsMethod01(int n){
- en: if(n < 0) {
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: if(n < 0) {
- en: return true;
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Boolean sameAsAbove(int n){
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: public Boolean sameAsAbove(int n){
- en: 'return n < 0 ? true : false;'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 'return n < 0 ? true : false;'
- en: '}'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int method02(int n){
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: public int method02(int n){
- en: if(n < 0) {
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: if(n < 0) {
- en: return 1;
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '} else if(n == 0) {'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if(n == 0) {'
- en: return 2;
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: return 2;
- en: '} else if (n == 1){'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (n == 1){'
- en: return 3;
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: return 3;
- en: '} else {'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: return 4;
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int methodSameAsMethod02(int n){
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: public int methodSameAsMethod02(int n){
- en: if(n < 0) {
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: if(n < 0) {
- en: return 1;
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '}'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: switch(n) {
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: switch(n) {
- en: 'case 0:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 0:'
- en: return 2;
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: return 2;
- en: 'case 1:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 'case 1:'
- en: return 3;
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: return 3;
- en: 'default:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: return 4;
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here are examples of boxing, unboxing, and type widening and narrowing:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有关于装箱、拆箱、类型扩宽和缩窄的示例：
- en: '```java'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public Integer methodBoxing(){
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: public Integer methodBoxing(){
- en: return 42;
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: return 42;
- en: '}'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int methodUnboxing(){
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: public int methodUnboxing(){
- en: return Integer.valueOf(42);
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: return Integer.valueOf(42);
- en: '}'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int methodWidening(){
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: public int methodWidening(){
- en: byte b = 42;
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = 42;
- en: return b;
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: return b;
- en: '}'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public byte methodNarrowing(){
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: public byte methodNarrowing(){
- en: int n = 42;
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 42;
- en: return (byte)n;
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: return (byte)n;
- en: '}'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We also can revisit the program that looks for a particular person in the list
    of teachers and students:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重新审视程序，该程序在教师和学生名单中寻找特定的人：
- en: '```java'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list =
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list =
- en: List.of(new Teacher(32, "Joe", "History"),
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: List.of(new Teacher(32, "Joe", "History"),
- en: new Student(29,"Joe", 4),
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(29,"Joe", 4),
- en: new Student(28,"Jill", 3),
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(28,"Jill", 3),
- en: new Teacher(33, "ALice", "Maths"));
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: new Teacher(33, "ALice", "Maths"));
- en: Person personOfInterest = new Person(29,"Joe");
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Person personOfInterest = new Person(29,"Joe");
- en: Person person = null;
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = null;
- en: 'for (Person p: list){'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Person p: list){'
- en: System.out.println(p);
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p);
- en: if(p.equals(personOfInterest)){
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: if(p.equals(personOfInterest)){
- en: person = p;
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: person = p;
- en: break;
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(person == null){
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: if(person == null){
- en: 'System.out.println("Not found: " + personOfInterest);'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("未找到：" + personOfInterest);
- en: '} else {'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: 'System.out.println("Found: " + person);'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("找到了：" + person);
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Using the return statements, we can now create the method `findPerson()`:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回语句，我们现在可以创建`findPerson()`方法：
- en: '```java'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person findPerson(List<Person> list, Person personOfInterest){
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: Person findPerson(List<Person> list, Person personOfInterest){
- en: Person person = null;
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = null;
- en: 'for (Person p: list){'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Person p: list){'
- en: System.out.println(p);
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p);
- en: if(p.equals(personOfInterest)){
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: if(p.equals(personOfInterest)){
- en: person = p;
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: person = p;
- en: break;
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return person;
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: return person;
- en: '}'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This method can be used as follows:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以这样使用：
- en: '```java'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
- en: new Student(29,"Joe", 4),
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(29,"Joe", 4),
- en: new Student(28,"Jill", 3),
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(28,"Jill", 3),
- en: new Teacher(33, "ALice", "Maths"));
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: new Teacher(33, "ALice", "Maths"));
- en: Person personOfInterest = new Person(29,"Joe");
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: Person personOfInterest = new Person(29,"Joe");
- en: Person person = findPerson(list, personOfInterest);
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = findPerson(list, personOfInterest);
- en: if(person == null){
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: if(person == null){
- en: 'System.out.println("Not found: " + personOfInterest);'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("未找到：" + personOfInterest);
- en: '} else {'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: 'System.out.println("Found: " + person);'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("找到了：" + person);
- en: '}'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Taking advantage of the new code structure, we can change the `findPerson()`
    method further and demonstrate greater variety in `return` statement usage:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 利用新的代码结构，我们可以进一步改变`findPerson()`方法，并展示`return`语句使用的更多变化：
- en: '```java'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person findPerson(List<Person> list, Person personOfInterest){
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: Person findPerson(List<Person> list, Person personOfInterest){
- en: 'for (Person p: list){'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Person p: list){'
- en: System.out.println(p);
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p);
- en: if(p.equals(personOfInterest)){
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: if(p.equals(personOfInterest)){
- en: return p;
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: return p;
- en: '}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return null;
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: return null;
- en: '}'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we have replaced the `break` statement with the return statement.
    Is the code more readable now? Some programmers would say no, as they prefer to
    have one `return` statement to be the only source of the returned result. Otherwise,
    they argue, one has to study the code and see if there is another—the third—`return`
    statement that might return yet another value. If the code is not as simple, one
    is never sure that all possible returns have been identified. The programmers
    of the opposite camp would counter-argue that a method should be small, so finding
    all return statements is easy. But making a method small often forces the creation
    of deeply nested methods that are not so easy to understand. The argument may
    go on for a long time. That's why we leave it up to you to try and decide which
    style you prefer.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经用返回语句替换了`break`语句。现在代码更易读了吗？一些程序员可能会说不，因为他们更喜欢只有一个`return`语句是返回结果的唯一来源。否则，他们认为，人们必须研究代码，看看是否有另一个——第三个——`return`语句，可能会返回另一个值。如果代码不那么简单，人们永远不确定是否已经识别了所有可能的返回。相反派的程序员可能会反驳说，方法应该很小，因此很容易找到所有的返回语句。但是，将方法变得很小通常会迫使创建深度嵌套的方法，这样就不那么容易理解了。这个争论可能会持续很长时间。这就是为什么我们让您自己尝试并决定您更喜欢哪种风格。
- en: 'If the return type of a method is defined as `void`:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法的返回类型定义为`void`：
- en: The `return` statement is not required
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要`return`语句
- en: If the `return` statement is present, it does not return any value
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在`return`语句，则不返回任何值
- en: If the `return` statement returns some value, it causes a compilation error
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`return`语句返回一些值，会导致编译错误
- en: There may be several return statements, but one of them has to be effectively
    the last statement of the method, while the others have to be inside a selection
    statement; otherwise, a compilation error will be generated
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能有几个返回语句，但其中一个必须有效地成为方法的最后一个语句，而其他语句必须在选择语句内部；否则，将生成编译错误
- en: 'To demonstrate the `return` statement without a value, we will use the `findPerson()`
    method again. If all we need to do is to print out the results, then the method
    can be changed as follows:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示没有值的`return`语句，我们将再次使用`findPerson()`方法。如果我们只需要打印结果，那么方法可以更改如下：
- en: '```java'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void findPerson2(List<Person> list, Person personOfInterest){
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: void findPerson2(List<Person> list, Person personOfInterest){
- en: 'for (Person p: list){'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Person p: list){'
- en: System.out.println(p);
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p);
- en: if(p.equals(personOfInterest)){
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: if(p.equals(personOfInterest)){
- en: 'System.out.println("Found: " + p);'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Found: " + p);'
- en: return;
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'System.out.println("Not found: " + personOfInterest);'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Not found: " + personOfInterest);'
- en: return;  //this statement is optional
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: return;  //此语句是可选的
- en: '}'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the client code will look much simpler:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 并且客户端代码看起来更简单：
- en: '```java'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
- en: new Student(29,"Joe", 4),
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(29,"Joe", 4),
- en: new Student(28,"Jill", 3),
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(28,"Jill", 3),
- en: new Teacher(33, "ALice", "Maths"));
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: new Teacher(33, "ALice", "Maths"));
- en: Person personOfInterest = new Person(29,"Joe");
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: Person personOfInterest = new Person(29,"Joe");
- en: findPerson(list, personOfInterest);
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: findPerson(list, personOfInterest);
- en: '```'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or it can be even more compact:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它甚至可以更紧凑：
- en: '```java'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
- en: new Student(29,"Joe", 4),
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(29,"Joe", 4),
- en: new Student(28,"Jill", 3),
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: new Student(28,"Jill", 3),
- en: new Teacher(33, "ALice", "Maths"));
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: new Teacher(33, "ALice", "Maths"));
- en: findPerson(list, new Person(29, "Joe");
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: findPerson(list, new Person(29, "Joe");
- en: '```'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As in the previous discussion, there are different styles for passing the parameters
    into a method. Some people prefer the more compact style as in the code here.
    Others argue that each parameter has to have a variable because the name of the
    variable carries additional information that helps to communicate the intent (like
    the name `personOfInterest`).
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的讨论一样，有不同的风格将参数传递到方法中。有些人更喜欢更紧凑的代码风格。其他人则认为每个参数都必须有一个变量，因为变量的名称携带了额外的信息，有助于传达意图（比如`personOfInterest`的名称）。
- en: Such discussions are inevitable because the same code has to be understood and
    maintained by different people, and each development team has to find the style
    that suits the needs and preferences of all the team members.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的讨论是不可避免的，因为同样的代码必须由不同的人理解和维护，每个开发团队都必须找到适合所有团队成员需求和偏好的风格。
- en: Exception handling statements
  id: totrans-853
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理语句
- en: 'As we have explained in the introduction, an unexpected condition can cause
    JVM to create and throw an exception object, or the application code can do it.
    As soon as it happens, the control flow is transferred to the exception handling
    `try` statement (also called a `try-catch` or `try-catch-finally` statement) if
    the exception was thrown inside a `try` block. Here is an example of a caught
    exception:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中解释的那样，意外条件可能会导致JVM创建并抛出异常对象，或者应用程序代码可以这样做。一旦发生这种情况，控制流就会转移到异常处理`try`语句（也称为`try-catch`或`try-catch-finally`语句），如果异常是在`try`块内抛出的。这是一个捕获异常的例子：
- en: '```java'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void exceptionCaught(){
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: void exceptionCaught(){
- en: try {
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: method2();
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: method2();
- en: '} catch (Exception ex){'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex){'
- en: ex.printStackTrace();
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method2(){
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: void method2(){
- en: method1(null);
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: method1(null);
- en: '}'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method1(String s){
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: s.equals("whatever");
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: s.equals("whatever");
- en: '}'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The method `exceptionCaught()` calls `method2()` which calls `method1()` and passes
    to it `null`. The line `s.equals("whatever")` throws `NullPointerException` which
    propagates through the method call stack until caught by the `try-catch` block
    of the method `exceptionCaught()` and its stack trace (which method called which
    method and in which line of the class) is printed:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`exceptionCaught()`调用`method2()`，`method2()`调用`method1()`并将`null`传递给它。行`s.equals("whatever")`抛出`NullPointerException`，它通过方法调用堆栈传播，直到被`exceptionCaught()`方法的`try-catch`块捕获，并打印其堆栈跟踪（哪个方法调用了哪个方法以及类的哪一行）：
- en: '![](img/67e2282b-6d05-4627-ab9f-55ae0b280afa.png)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67e2282b-6d05-4627-ab9f-55ae0b280afa.png)'
- en: 'From the stack trace, you can see that all the involved methods belong to the
    same class, `ExceptionHandlingDemo`. Reading from the bottom up, you can see that:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆栈跟踪中，您可以看到所有涉及的方法都属于同一个类`ExceptionHandlingDemo`。从下往上阅读，您可以看到：
- en: The method `main()` called the method `exceptionCaught()` in line 5 of `ExceptionHandlingDemo`
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`main()`在`ExceptionHandlingDemo`的第5行调用了方法`exceptionCaught()`
- en: The method `exceptionCaught()` called `method2()` in line 10 of the same class
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`exceptionCaught()`在同一类的第10行调用了`method2()`
- en: The `method2()` called `method1()` in line 17
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method2()`在第17行调用了`method1()`'
- en: The `method1()` has thrown `java.lang.NullpointerException` from line 21
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method1()`在第21行抛出了`java.lang.NullpointerException`'
- en: 'If we don''t see the code, we don''t know if this exception was thrown deliberately.
    For example, `method1()` might look as follows:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不看代码，我们就不知道这个异常是故意抛出的。例如，`method1()`可能如下所示：
- en: '```java'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: if(s == null){
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 如果s == null){
- en: throw new NullPointerException();
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: throw new NullPointerException();
- en: '}'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But usually, programmers add a message to indicate what the problem is:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常，程序员会添加一条消息来指示问题是什么：
- en: '```java'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: if(s == null){
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: if(s == null){
- en: throw new NullPointerException("Parameter String is null");
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: throw new NullPointerException("参数String为空");
- en: '}'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If that were the case, the stack trace would show a message:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，堆栈跟踪将显示一条消息：
- en: '![](img/42776307-171b-476f-a280-ba2e3d606546.png)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42776307-171b-476f-a280-ba2e3d606546.png)'
- en: 'But the message is not a reliable indicator of the custom exception. Some standard
    exceptions carry their own message, too. The exception package is better evidence
    of a custom exception or if the exception is one of the base classes (`java.lang.Exception`
    or `java.langRuntimeException`) and has a message in it. The following code, for
    example, customizes `RuntimeException`:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 但是消息并不是自定义异常的可靠指标。一些标准异常也携带自己的消息。异常包是自定义异常的更好证据，或者异常是基类之一（`java.lang.Exception`或`java.langRuntimeException`）并且其中有一条消息。例如，以下代码自定义了`RuntimeException`：
- en: '```java'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: if(s == null){
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果s == null){
- en: throw new RuntimeException("Parameter String is null");
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("参数String为空");
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is what the stack trace looks like with such a customized exception:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此类自定义异常的堆栈跟踪：
- en: '![](img/13e41dba-0766-4f70-9448-6c0cc91cce5a.png)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13e41dba-0766-4f70-9448-6c0cc91cce5a.png)'
- en: We will talk more about exception customization in the *Custom exceptions* section
    later.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将在*自定义异常*部分更多地讨论异常定制。
- en: 'If the exception is thrown outside a `try...catch` block, the program execution
    is terminated by JVM. Here is an example of an exception not caught by the application:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常在`try...catch`块之外抛出，则程序执行将由JVM终止。以下是一个未被应用程序捕获的异常的示例：
- en: '```java'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void exceptionNotCaught(){
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: void exceptionNotCaught(){
- en: method2();
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: method2();
- en: '}'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method2(){
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: void method2(){
- en: method1(null);
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: method1(null);
- en: '}'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method1(String s){
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: s.equals("whatever");
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: s.equals("whatever");
- en: '}'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run this code, the result is:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，结果是：
- en: '![](img/7f0cbbec-63b6-49a5-81a6-0db76a269dbc.png)'
  id: totrans-919
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f0cbbec-63b6-49a5-81a6-0db76a269dbc.png)'
- en: Now, let's talk about the exception handling statements and then come back to
    the discussion about the best way to handle the exceptions.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈异常处理语句，然后再回到关于处理异常的最佳方法的讨论。
- en: throw
  id: totrans-921
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throw
- en: 'The `throw` statement consists of the keyword `throw` and either a variable
    or value of a reference type `java.lang.Throwable`, or the `null` reference. Since
    all the exceptions are children of `java.lang.Throwable`, any of the following
    throw statements is correct:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句由关键字`throw`和`java.lang.Throwable`的变量或引用类型的值，或`null`引用组成。由于所有异常都是`java.lang.Throwable`的子类，因此以下任何一个`throw`语句都是正确的：'
- en: '```java'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: throw new Exception("Something happened");
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: throw new Exception("发生了一些事情");
- en: Exception ex = new Exception("Something happened");
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: Exception ex = new Exception("发生了一些事情");
- en: throw ex;
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: throw ex;
- en: Throwable thr = new Exception("Something happened");
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: Throwable thr = new Exception("发生了一些事情");
- en: throw thr;
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: throw thr;
- en: throw null;
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: throw null;
- en: '```'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If `null` is thrown, as it is in the last statement, then JVM converts it to
    a `NullPointerException`, so these two statements are equivalent:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出`null`，就像在最后一条语句中一样，那么JVM会将其转换为`NullPointerException`，因此这两条语句是等价的：
- en: '```java'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: throw null;
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: throw null;
- en: throw new NullPointerException;
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: throw new NullPointerException;
- en: '```'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: And, just to remind you, the package `java.lang` does not need to be imported.
    You can refer to any of the package `java.lang` members—interface or class—by
    its name without using the fully qualified name (that includes package name too).
    That is why we are able to write `NullPointerException` without importing the
    class instead of using its fully qualified name, `java.lang.NullPointerException`.
    We will look into the content of the package `java.lang` in [Chapter 12](dc404209-4f4f-42f6-b63e-ea494ba593db.xhtml),
    *Java Standard and External Libraries*.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，提醒一下，包`java.lang`不需要被导入。您可以通过名称引用`java.lang`包的任何成员（接口或类），而无需使用完全限定名称（包括包名）。这就是为什么我们能够写`NullPointerException`而不导入该类，而不是使用其完全限定名称`java.lang.NullPointerException`。我们将在[第12章](dc404209-4f4f-42f6-b63e-ea494ba593db.xhtml)
    *Java标准和外部库*中查看`java.lang`包的内容。
- en: 'You can also create your own exception by extending `Throwable` or any of its
    children and throw them instead of standard exceptions of the package `java.lang`:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过扩展`Throwable`或其任何子类来创建自己的异常，并抛出它们，而不是抛出`java.lang`包中的标准异常：
- en: '```java'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class MyNpe extends NullPointerException{
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: class MyNpe extends NullPointerException{
- en: public MyNpe(String message){
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: public MyNpe(String message){
- en: super(message);
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: super(message);
- en: '}'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: //您需要在此处添加任何代码
- en: '}'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class MyRuntimeException extends RuntimeException{
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: class MyRuntimeException extends RuntimeException{
- en: public MyRuntimeException(String message){
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: public MyRuntimeException(String message){
- en: super(message);
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: super(message);
- en: '}'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: //您需要在此处添加任何代码
- en: '}'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class MyThrowable extends Throwable{
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: class MyThrowable extends Throwable{
- en: public MyThrowable(String message){
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: public MyThrowable(String message){
- en: super(message);
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: super(message);
- en: '}'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: //您需要在此处编写的任何代码
- en: '}'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class MyException extends Exception{
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: class MyException extends Exception{
- en: public MyException(String message){
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: public MyException(String message){
- en: super(message);
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 调用super(message);
- en: '}'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: //您需要在此处编写的任何代码
- en: '}'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Why you would want to do that will become clear after reading the *Custom exceptions* section later.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做将在阅读*自定义异常*部分后变得清晰。
- en: try...catch
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试...捕获
- en: 'When an exception is thrown inside a `try` block, it redirects control flow
    to its first `catch` clause (the one that catches `NullPointerException` in the
    following example):'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`try`块内抛出异常时，它将控制流重定向到其第一个`catch`子句（在下面的示例中捕获`NullPointerException`）：
- en: '```java'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void exceptionCaught(){
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: void exceptionCaught(){
- en: try {
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: method2();
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: method2();
- en: '} catch (NullPointerException ex){'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (NullPointerException ex){'
- en: System.out.println("NPE caught");
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("NPE捕获");
- en: ex.printStackTrace();
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '} catch (RuntimeException ex){'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (RuntimeException ex){'
- en: System.out.println("RuntimeException caught");
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("捕获RuntimeException");
- en: ex.printStackTrace();
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '} catch (Exception ex){'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex){'
- en: System.out.println("Exception caught");
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("捕获异常");
- en: ex.printStackTrace();
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If there are more than one `catch` clauses, the compiler forces you to arrange
    them so that the child exception is listed before the parent exception. In our
    previous example, `NullPointerException` extends  `RuntimeException` extends `Exception`.
    If the thrown exception type matches the topmost `catch` clause, this `catch`
    block handles the exception (we will talk about what it means shortly). If the
    topmost clause does not match the exception type, the next `catch` clause gets
    the control flow and handles the exception if it matches the clause type. If not,
    the control flow is passed to the next clause until either the exception is handled
    or all the clauses are tried. If none of the clauses match, the exception is thrown
    further up until is it either handled by some try-catch block or it propagates
    all the way out of the program code. In such a case, JVM terminates the program
    execution (to be precise, it terminates the thread execution, but we will talk
    about threads in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection*).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个`catch`子句，编译器会强制您安排它们，以便子异常在父异常之前列出。在我们之前的示例中，`NullPointerException`扩展了`RuntimeException`扩展了`Exception`。如果抛出的异常类型与最顶层的`catch`子句匹配，此`catch`块处理异常（我们将很快讨论它的含义）。如果最顶层子句不匹配异常类型，则下一个`catch`子句获取控制流并处理异常（如果匹配子句类型）。如果不匹配，则控制流传递到下一个子句，直到异常被处理或尝试所有子句。如果没有一个子句匹配，异常将被抛出直到它被某个try-catch块处理，或者它传播到程序代码之外。在这种情况下，JVM终止程序执行（准确地说，它终止线程执行，但我们将在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)，*JVM进程和垃圾回收*中讨论线程）。
- en: 'Let''s demonstrate this by running the examples. If we use the three `catch`
    clauses in the method `exceptionCaught()` as shown previously, and throw `NullPointerException`
    in  `method1()` as follows:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行示例来演示这一点。如果我们像之前展示的那样在`exceptionCaught()`方法中使用三个`catch`子句，并在`method1()`中抛出`NullPointerException`：
- en: '```java'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: throw new NullPointerException("Parameter String is null");
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: throw new NullPointerException("参数String为空");
- en: '}'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be like that shown in the following screenshot:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下截图所示：
- en: '![](img/b8721c37-ab6d-4418-9406-f8c0e2517e3c.png)'
  id: totrans-991
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8721c37-ab6d-4418-9406-f8c0e2517e3c.png)'
- en: You can see that the topmost `catch` clause caught the exception as expected.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到最顶层的`catch`子句按预期捕获了异常。
- en: 'If we change `method1()` to throw a `RuntimeException`:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`method1()`更改为抛出`RuntimeException`：
- en: '```java'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: throw new RuntimeException("Parameter String is null");
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("参数String为空");
- en: '}'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You probably will be not surprised to see that the second `catch` clause catches
    it. So, we are not going to demonstrate it. We better change `method1()` again
    and let it throw `ArrayIndexOutOfBoundsException`, which extends `RuntimeException`,
    but is not listed in any of the catch clauses:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会感到惊讶，看到第二个`catch`子句捕获它。因此，我们不打算演示它。我们最好再次更改`method1()`，让它抛出`ArrayIndexOutOfBoundsException`，它是`RuntimeException`的扩展，但未列在任何捕获子句中：
- en: '```java'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s){
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s){
- en: throw new ArrayIndexOutOfBoundsException("Index ... is bigger " +
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: throw new ArrayIndexOutOfBoundsException("索引...更大" +
- en: '"than the array length ...");'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '"比数组长度...更大");'
- en: '}'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the code again, the result will be:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行代码，结果将如下所示：
- en: '![](img/4b8464ff-2568-4c63-a7bf-c8a8fb30d954.png)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b8464ff-2568-4c63-a7bf-c8a8fb30d954.png)'
- en: As you can see, the exception was caught by the first `catch` clause that matched
    its type. That is the reason the compiler forces you to list them so that a child
    is often listed before its parent, so the most specific type is listed first.
    This way, the first matched clause is always the best match.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，异常被第一个匹配其类型的`catch`子句捕获。这就是编译器强制您列出它们的原因，以便子类通常在其父类之前列出，因此最具体的类型首先列出。这样，第一个匹配的子句总是最佳匹配。
- en: Now, you probably fully expect to see any non-`RuntimeException` to be caught
    by the last `catch` clause. That is a correct expectation. But before we can throw
    it, we have to address the difference between *checked* and *unchecked* (also
    called *runtime*) exceptions.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能完全希望看到任何非`RuntimeException`都被最后一个`catch`子句捕获。这是一个正确的期望。但在我们抛出它之前，我们必须解决*已检查*和*未检查*（也称为*运行时*）异常之间的区别。
- en: Checked and unchecked (runtime) exceptions
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已检查和未检查（运行时）异常
- en: 'To understand why this topic is important, let''s try to throw an exception
    of type `Exception` in `method1()`. For this test, we will use  `InstantiationException`,
    which extends `Exception`. Let''s assume there was a validation of input data
    (from some external source) and it turned out that they were not good enough for
    some object instantiation:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这个主题很重要，让我们尝试在`method1()`中抛出`Exception`类型的异常。为了进行这个测试，我们将使用`InstantiationException`，它扩展了`Exception`。假设有一些输入数据的验证（来自某些外部来源），结果证明它们不足以实例化某些对象：
- en: '```java'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s) {
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s) {
- en: //some input data validation
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: //一些输入数据验证
- en: throw new InstantiationException("No value for the field" +
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InstantiationException("字段没有值" +
- en: '" someField of SomeClass.");'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '" SomeClass的someField。"'
- en: '}'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We wrote this code and suddenly the compiler generated an error, `Unhandled
    exception java.lang.InstantiationException`, although we do have a `catch` clause
    up in the client code that will match this type of exception (the last `catch`
    clause in the method `exceptionCaught()`).
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了这段代码，突然编译器生成了一个错误，`Unhandled exception java.lang.InstantiationException`，尽管我们在客户端代码中有一个`catch`子句，它将匹配这种类型的异常（在方法`exceptionCaught()`中的最后一个`catch`子句）。
- en: 'The reason for the error is that all exception types that extend the `Exception`
    class but not its child `RuntimeException` are checked at compile time, hence
    the name. The compiler checks if such exceptions are handled in the method of
    their origination:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因是所有扩展`Exception`类但不是其子类`RuntimeException`的异常类型在编译时都会被检查，因此得名。编译器会检查这些异常是否在其发生的方法中得到处理：
- en: If, in the method of the exception origination, there is a `try-catch` block
    that catches this exception and does not let it propagate outside the method,
    the compiler does not complain
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在异常发生的方法中有一个`try-catch`块捕获了这个异常并且不让它传播到方法外部，编译器就不会抱怨
- en: 'Otherwise, it checks if there is a `throws` clause in the method declaration
    that lists this exception; here is an example:'
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它会检查方法声明中是否有列出此异常的`throws`子句；这里是一个例子：
- en: '```java'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s) throws Exception{
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s) throws Exception{
- en: //some input data validation
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: //一些输入数据验证
- en: throw new InstantiationException("No value for the field" +
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InstantiationException("字段没有值" +
- en: '" someField of SomeClass.");'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '" SomeClass的someField。");'
- en: '}'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `throws` clause must list all the checked exceptions that can propagate
    outside the method. By adding `throws Exception`, we made the compiler happy even
    if we decide to throw any other checked exception because they are all of the type
    `Exception` and thus are covered by the new `throws` clause.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`子句必须列出所有可能传播到方法外部的已检查异常。通过添加`throws Exception`，即使我们决定抛出任何其他已检查异常，编译器也会满意，因为它们都是`Exception`类型，因此都包含在新的`throws`子句中。'
- en: In the next section, `Throws`, you will read some pros and cons of using a base
    exception class in a `throws` clause, and in the section *Some best practices
    of exception handling*, later, we discuss some other possible solutions.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节“Throws”中，您将阅读一些使用`throws`子句中基本异常类的优缺点，在稍后的*异常处理的一些最佳实践*部分中，我们将讨论一些其他可能的解决方案。
- en: 'Meanwhile, let''s continue discussing checked exception usage. In our demo
    code, we have decided to add the clause `throws Exception` to the `method1()` declaration.
    This change has immediately triggered the same error `Unhandled exception java.lang.InstantiationException` in
    `method2()`, which calls `method1()` but does not handle `Exception`. So, we had
    to add a `throws` clause to `method2()`, too:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们继续讨论已检查异常的使用。在我们的演示代码中，我们决定在`method1()`的声明中添加`throws Exception`子句。这个改变立即在`method2()`中触发了相同的错误`Unhandled
    exception java.lang.InstantiationException`，因为`method2()`调用了`method1()`但没有处理`Exception`。因此，我们不得不在`method2()`中也添加一个`throws`子句：
- en: '```java'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method2() throws Exception{
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: void method2() throws Exception{
- en: method1(null);
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: method1(null);
- en: '}'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Only the caller of `method2()`—the method `exceptionCaught()`—does not need
    to be changed because it handles the `Exception` type. The final version of the
    code is:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`method2()`的调用者——`exceptionCaught()`方法——不需要更改，因为它处理`Exception`类型。代码的最终版本是：
- en: '```java'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void exceptionCaught(){
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: void exceptionCaught(){
- en: try {
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: method2();
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: method2();
- en: '} catch (NullPointerException ex){'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (NullPointerException ex){'
- en: System.out.println("NPE caught");
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("捕获NPE");
- en: ex.printStackTrace();
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '} catch (RuntimeException ex){'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (RuntimeException ex){'
- en: System.out.println("RuntimeException caught");
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("捕获RuntimeException");
- en: ex.printStackTrace();
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '} catch (Exception ex){'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception ex){'
- en: System.out.println("Exception caught");
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("捕获异常");
- en: ex.printStackTrace();
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method2() throws Exception{
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: void method2() throws Exception{
- en: method1(null);
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: method1(null);
- en: '}'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method1(String s) throws Exception{
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s) throws Exception{
- en: throw new InstantiationException("No value for the field" +
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InstantiationException("字段没有值" +
- en: '" someField of SomeClass.");'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '" SomeClass的someField。");'
- en: '}'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we call the method `exceptionCaught()` now, the result will be:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在调用`exceptionCaught()`方法，结果将是：
- en: '![](img/8faf4c71-38d5-42b8-96bb-6b261faeae1d.png)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8faf4c71-38d5-42b8-96bb-6b261faeae1d.png)'
- en: That is exactly what we expected. The last `catch` clause for the `Exception` type
    matched the `InstantiationException` type.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。`Exception`类型的最后一个`catch`子句匹配了`InstantiationException`类型。
- en: The unchecked exceptions—the descendants of the class `RuntimeExceptions` —are
    not checked at compile time, thus the name, and are not required to be listed
    in the `throws` clause.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查的异常——`RuntimeExceptions`类的后代——在编译时不会被检查，因此得名，并且不需要在`throws`子句中列出。
- en: Generally speaking, checked exceptions are (should be) used for recoverable
    conditions, while unchecked exceptions for unrecoverable conditions. We will talk
    more about it in the *What is exception handling?* and *Some best practices* *of
    exception handling* sections later.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，已检查异常（应该）用于可恢复的条件，而未检查异常用于不可恢复的条件。我们将在稍后的*什么是异常处理？*和*一些最佳实践* *异常处理*部分中更多地讨论这个问题。
- en: throws
  id: totrans-1067
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出
- en: 'A `throws` clause must list all checked exception classes (descendants of the
    class `Exception` but not descendants of the class `RuntimeException`) that the
    method or constructor can throw. It is allowed but not required to list the unchecked
    exception classes (descendants of the class `RuntimeException`) in a `throws`
    clause, too. Here is an example:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`子句必须列出方法或构造函数可以抛出的所有已检查异常类（`Exception`类的后代，但不是`RuntimeException`类的后代）。在`throws`子句中列出未检查的异常类（`RuntimeException`类的后代）是允许的，但不是必需的。以下是一个例子：'
- en: '```java'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s)
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s)
- en: throws InstantiationException, InterruptedException {
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: throws InstantiationException, InterruptedException {
- en: //some input data validation
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: //一些输入数据验证
- en: if(some data missing){
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: if(一些数据丢失){
- en: throw new InstantiationException("No value for the field" +
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InstantiationException("字段没有值" +
- en: '" someField of SomeClass.");'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '" SomeClass的someField字段。");'
- en: '}'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //some other code
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: if(some other reason){
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: if(其他原因){
- en: throw new InterruptedException("Reason..."); //checked exception
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InterruptedException("原因..."); //检查异常
- en: '}'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or, instead of declaring throwing two different exceptions, one can list only
    the base class in the `throws` clause:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以只列出`throws`子句中的基类异常，而不是声明抛出两种不同的异常：
- en: '```java'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void method1(String s) throws Exception {
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: void method1(String s) throws Exception {
- en: //some input data validation
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: //一些输入数据验证
- en: if(some data missing){
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: if(一些数据丢失){
- en: throw new InstantiationException("No value for the field" +
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InstantiationException("字段没有值" +
- en: '" someField of SomeClass.");'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '" SomeClass的someField字段。");'
- en: '}'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //some other code
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: //一些其他代码
- en: if(some other reason){
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: if(其他原因){
- en: throw new InterruptedException("Reason..."); //checked exception
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: throw new InterruptedException("原因..."); //检查异常
- en: '}'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'However, it would mean that the variety and possible reasons for potential
    failures will be hidden from the client this way, so one must either:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着潜在失败的多样性和可能的原因将隐藏在客户端，因此一个人必须要么：
- en: Handle the exceptions inside the method
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法内处理异常
- en: Assume that the client code will base its behavior on the content of the message
    (which is often not reliable and subject to change)
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端代码将根据消息的内容来确定其行为（这通常是不可靠的并且可能会发生变化）
- en: Assume that the client will behave the same way no matter what the actual type
    exception can be
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端无论实际的异常类型是什么都会表现相同
- en: Assume that the method will never throw any other checked exception and, if
    it does, the behavior of the client should not change
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设该方法永远不会抛出任何其他已检查异常，如果确实抛出，客户端的行为不应该改变
- en: There are too many assumptions to feel comfortable declaring only a base class
    exception in the `throws` clause.  But there are some best practices that avoid
    such a dilemma. We will talk about them in the *Some best practices for exception
    handling* section later.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 有太多的假设让人感到不舒服，只声明`throws`子句中的基类异常。但有一些最佳实践可以避免这种困境。我们将在*异常处理的一些最佳实践*部分中讨论它们。
- en: Custom exceptions
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义异常
- en: 'In this section, we promised to discuss the motivation for custom exception
    creation. Here are two examples:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们承诺讨论自定义异常创建的动机。以下是两个例子：
- en: '```java'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: //Unchecked custom exception
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: //未检查的自定义异常
- en: class MyRuntimeException extends RuntimeException{
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: class MyRuntimeException extends RuntimeException{
- en: public MyRuntimeException(String message){
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: public MyRuntimeException(String message){
- en: super(message);
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: super(message);
- en: '}'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: //这里需要任何代码
- en: '}'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //Checked custom exception
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: //检查自定义异常
- en: class MyException extends Exception{
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: class MyException extends Exception{
- en: public MyException(String message){
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: public MyException(String message){
- en: super(message);
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: super(message);
- en: '}'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //whatever code you need to have here
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: //这里需要任何代码
- en: '}'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: These examples don't look particularly useful until you realize that the comment
    `whatever code you need to have here` allows you put any data or functionality
    in your  custom class and utilize the exception handling mechanism to propagate
    such an object from any code depth all the way up to any level you need it.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 直到你意识到注释`这里需要任何代码`允许你在自定义类中放入任何数据或功能，并利用异常处理机制将这样的对象从任何代码深度传播到任何你需要的级别，这些示例看起来并不特别有用。
- en: Since this is only an introduction to Java programming, such cases are beyond
    the scope of this book. We just wanted to make sure you know that such a capability
    exists, so you may search the internet when you need it or build your own innovative
    solution.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是Java编程的介绍，这些情况超出了本书的范围。我们只是想确保你知道这样的功能存在，所以当你需要它或构建你自己的创新解决方案时，你可以在互联网上搜索。
- en: However, there is an ongoing discussion in the Java community on the topic of
    utilizing the exception handling mechanism for business purposes, which we will
    touch on in the *Some best practices of exception handling* section later.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Java社区中有关利用异常处理机制进行业务目的的讨论仍在进行中，我们将在*异常处理的一些最佳实践*部分中稍后讨论。
- en: What is exception handling?
  id: totrans-1124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是异常处理？
- en: As we have mentioned already, checked exceptions were originally thought to
    be used for the recoverable conditions when a caller code may do something automatically
    and take another branch of execution, based on the type of the caught exception
    and maybe the data it carried. And that is the primary purpose and function of
    exception handling.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，检查异常最初被认为是用于可恢复的条件，当调用者代码可能会自动执行某些操作并根据捕获的异常类型和可能携带的数据采取另一个执行分支时。这就是异常处理的主要目的和功能。
- en: Unfortunately, such utilization of exceptions proved to be not very productive
    because as soon as an exceptional condition is discovered, the code is enhanced
    and makes such a condition one of the possible processing options, albeit not
    very often executed.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种利用异常的方式被证明并不是非常有效，因为一旦发现异常条件，代码就会得到增强，并使这样的条件成为可能的处理选项之一，尽管并不经常执行。
- en: The secondary function is to document the error condition and all the related
    information for later analysis and code enhancement.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 次要功能是记录错误条件和所有相关信息，以供以后分析和代码增强。
- en: The third and no less important function of exception handling is to protect
    the application from complete failure. The unexpected condition happened, but
    hopefully such conditions are rare and the mainstream processing is still available
    for the application to continue working as it was designed.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的第三个同样重要的功能是保护应用程序免受完全失败。意外情况发生了，但希望这种情况很少，主流处理仍然可用于应用程序继续按设计工作。
- en: The fourth function of exception handling is to provide a mechanism for information
    delivery in some special cases when other means are not as effective. This last
    function of exception handling remains controversial and not used very often.
    We will talk about it in the next section.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的第四个功能是在其他手段不够有效的特殊情况下提供信息传递的机制。异常处理的这最后一个功能仍然存在争议，且并不经常使用。我们将在下一节讨论它。
- en: Some best practices of exception handling
  id: totrans-1130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理的一些最佳实践
- en: 'The Java exception handling mechanism was designed to address possible edge
    cases and unexpected program termination. The two categories of errors were expected
    to be:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: Java异常处理机制旨在解决可能的边缘情况和意外的程序终止。预期的错误类别是：
- en: '**Recoverable**: Those that can be remedied automatically based on the application
    logic'
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可恢复的**：可以根据应用逻辑自动修复的异常'
- en: '**Unrecoverable**: Those that cannot be corrected automatically and which lead
    to program termination'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可恢复的**：无法自动纠正并导致程序终止的异常'
- en: The first category of errors was addressed by introducing checked exceptions
    (descendants of the `Exception` class), while the second became a realm of unchecked
    exceptions (descendants of the `RuntimeException` class).
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入已检查的异常（`Exception`类的后代）来解决第一类错误，而第二类错误则成为未经检查的异常领域（`RuntimeException`类的后代）。
- en: Unfortunately, such categorization turned out to be not in line with the programming
    practicalities, especially for the areas of programming unrelated to the development
    of libraries and frameworks designed to be used by different users and organizations
    in a variety of environments and execution contexts. Typical application development
    was always able to fix the problem in the code directly without writing a complicated
    mechanism for recovery. The distinction is important because as an author of a
    library, you never know where and how your methods are going to be used, while
    as an application developer, one knows exactly the environment and the execution
    context.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种分类方法在编程实践中并不符合实际情况，特别是对于与开发旨在在各种环境和执行上下文中使用的库和框架无关的编程领域。典型的应用程序开发总是能够直接在代码中解决问题，而无需编写复杂的恢复机制。这种区别很重要，因为作为库的作者，你永远不知道你的方法将在何处以及如何被使用，而作为应用程序开发人员，你确切地了解环境和执行上下文。
- en: 'Even the Java authors indirectly confirmed this experience by adding, as it
    stands at the time of writing, 15 unchecked exceptions and only nine checked exceptions
    to the `java.lang` package. If the original expectations were confirmed by the
    practice, one would expect only a few unrecoverable (unchecked) exceptions and
    many more types of recoverable (checked) exceptions. Meanwhile, even some of the
    checked exceptions of the `java.lang` package do not look as recoverable either:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在写作时，Java的作者们间接地确认了这一经验，向`java.lang`包中添加了15个未经检查的异常和仅九个已检查的异常。如果原始期望得到了实践的确认，人们会期望只有少数不可恢复的（未经检查的）异常和更多类型的可恢复的（已检查的）异常。与此同时，甚至`java.lang`包中的一些已检查的异常看起来也不太可恢复：
- en: '`ClassNotFoundException`: Thrown when JVM is not able to find the referred
    class'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassNotFoundException`：当JVM无法找到所引用的类时抛出'
- en: '`CloneNotSupportedException`: Thrown to indicate that the clone method in the
    object''s class does not implement the `Cloneable` interface'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloneNotSupportedException`：指示对象类中的克隆方法未实现`Cloneable`接口'
- en: '`IllegalAccessException`: Thrown when the currently executing method does not
    have access to the definition of the specified class, field, method, or constructor'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalAccessException`：当当前执行的方法无法访问指定类、字段、方法或构造函数的定义时抛出'
- en: In fact, one would be hard-pressed to find a situation when automatic recovery
    code is worth writing instead of just adding another branch of logic to the mainstream
    processing.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，很难找到一种情况，其中编写自动恢复代码比只是在主流处理中添加另一个逻辑分支更值得。
- en: 'With that in mind, let''s enumerate a few best practices that proved to be
    useful and effective:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们列举一些被证明是有用和有效的最佳实践：
- en: Always catch all exceptions
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终捕获所有异常
- en: Handle each exception as close to the source as possible
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能接近源头处理每个异常
- en: Do not use checked exceptions unless you have to
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必须，否则不要使用已检查的异常
- en: Convert third-party checked exceptions into unchecked by re-throwing them as
    `RuntimeException` with the corresponding message
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重新抛出它们作为带有相应消息的`RuntimeException`，将第三方已检查的异常转换为未经检查的异常
- en: Do not create custom exceptions unless you have to
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必须，否则不要创建自定义异常
- en: Do not drive business logic by using the exception handling mechanism, unless
    you have to
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必须，否则不要使用异常处理机制来驱动业务逻辑
- en: Customize the generic `RuntimeException` by using the system of messages and,
    optionally, enum type instead of using exception type to communicate the cause
    of the error
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用消息系统和可选的枚举类型自定义通用的`RuntimeException`，而不是使用异常类型来传达错误的原因
- en: finally
  id: totrans-1149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后
- en: 'A `finally` block can be added to a `try` block with or without a `catch` clause.
    The format looks like the following:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块可以添加到带有或不带有`catch`子句的`try`块中。格式如下：'
- en: '```java'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: try {
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: //code of the try block
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: //尝试块的代码
- en: '} catch (...){'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (...){'
- en: //optional catch block code
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: //可选的捕获块代码
- en: '} finally {'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '} 最后 {'
- en: //code of the finally block
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: //最后块的代码
- en: '}'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If present, the code in the `finally` block is always executed just before the
    method is exited. Whether the code in the `try` block has thrown an exception,
    and whether this exception was processed in one of the `catch` blocks or if the
    code in the `try` block did not throw an exception, the `finally` block is still
    executed every time just before the method returns the control flow to the caller.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，则`finally`块中的代码总是在方法退出之前执行。无论`try`块中的代码是否抛出异常，以及这个异常是否在`catch`块中的一个中被处理，或者`try`块中的代码是否没有抛出异常，`finally`块都会在方法返回控制流到调用者之前执行。
- en: Originally, the `finally` block was used to close some resources used in the
    `try` block that needed to be closed. For example, if the code has opened a connection
    to the database or has established a reading or writing connection with a file
    on a disk, such a connection has to be closed after the operation is completed
    or when an exception has been thrown. Otherwise, a connection that is not closed
    on time keeps the resources (necessary to maintain the connection) locked without
    being used. We will talk about JVM processes in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml),
    *JVM Processes and Garbage Collection*.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`finally`块用于关闭`try`块中需要关闭的一些资源。例如，如果代码已经打开了到数据库的连接，或者已经在磁盘上与文件建立了读取或写入连接，那么在操作完成或抛出异常时必须关闭这样的连接。否则，未及时关闭的连接会使资源（维护连接所需的资源）被锁定而不被使用。我们将在[第11章]（e8c37d86-291d-4500-84ea-719683172477.xhtml）*JVM进程和垃圾回收*中讨论JVM进程。
- en: 'So, typical code looked like this:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，典型的代码看起来像这样：
- en: '```java'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = null;
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = null;
- en: try {
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: conn = createConnection();
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: conn = createConnection（）;
- en: //code of the try block
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: //尝试块的代码
- en: '} catch (...){'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（...）{'
- en: //optional catch block code
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: //可选的catch块代码
- en: '} finally {'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '}最后{'
- en: if(conn != null){
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: if（conn！= null）{
- en: conn.close();
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: conn.close（）;
- en: '}'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It worked fine. But a new Java capability, called `try...with...resources`,
    allows closing the connection automatically if the connection class implements
    `AutoCloseable` (which most of the popular connection classes do). We will talk
    about the `try...with...resources` construct in  [Chapter 16](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml), *Database
    Programming*. This development decreased the `finally` block''s usefulness, and
    now it is used primarily for handling some code that cannot be executed using
    the `AutoCloseable` interface, yet has to be performed just before the method
    returns unconditionally. For example, we could refactor our `exceptionCaught()` method by
    taking advantage of the `finally` block as follows:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行得很好。但是，一个名为`try...with...resources`的新的Java功能允许在连接类实现`AutoCloseable`时自动关闭连接（大多数流行的连接类都是这样）。我们将在[第16章]（d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml）*数据库编程*中讨论`try...with...resources`结构。这一发展降低了`finally`块的实用性，现在它主要用于处理一些不能使用`AutoCloseable`接口执行的代码，但必须在方法无条件返回之前执行。例如，我们可以通过利用`finally`块来重构我们的`exceptionCaught（）`方法，如下所示：
- en: '```java'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void exceptionCaught(){
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: void exceptionCaught（）{
- en: Exception exf = null;
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: Exception exf = null;
- en: try {
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: method2();
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: method2（）;
- en: '} catch (NullPointerException ex){'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（NullPointerException ex）{'
- en: exf = ex;
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: exf = ex;
- en: System.out.println("NPE caught");
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（"NPE捕获"）;
- en: '} catch (RuntimeException ex){'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（RuntimeException ex）{'
- en: exf = ex;
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: exf = ex;
- en: System.out.println("RuntimeException caught");
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（"RuntimeException捕获"）;
- en: '} catch (Exception ex){'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（Exception ex）{'
- en: exf = ex;
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: exf = ex;
- en: System.out.println("Exception caught");
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（"捕获异常"）;
- en: '} finally {'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '}最后{'
- en: if(exf != null){
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: if（exf！= null）{
- en: exf.printStackTrace();
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: exf.printStackTrace（）;
- en: '}'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '}```'
- en: '```'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There are other cases of `finally` block use too, based on its guaranteed execution
    just before the control flow is returned to the method caller.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他情况下的`finally`块使用，基于它在控制流返回给方法调用者之前的保证执行。
- en: Assert requires JVM option -ea
  id: totrans-1198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Assert需要JVM选项-ea
- en: The branching `assert` statement can be used for validation of the data in application
    testing, especially for accessing rarely used execution paths or combinations
    of data. The unique aspect of this capability is that the code is not executed
    unless the JVM is run with the option `-ea`.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 分支`assert`语句可用于验证应用程序测试中的数据，特别是用于访问很少使用的执行路径或数据组合。这种能力的独特之处在于，除非JVM使用选项`-ea`运行，否则不会执行代码。
- en: A full discussion of the `assert` statement's functionality and possible application
    is outside the scope of this book. We will just demonstrate its basic usage and
    how to turn it on using IntelliJ IDEA.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不讨论`assert`语句的功能和可能的应用。我们只会演示它的基本用法以及如何在IntelliJ IDEA中打开它。
- en: 'Look at the following code:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '```java'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class AssertDemo {
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: public class AssertDemo {
- en: public static void main(String... args) {
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main（String ... args）{
- en: int x = 2;
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 2;
- en: 'assert x > 1 : "x <= 1";'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: assert x>1：“x<=1”;
- en: 'assert x == 1 : "x != 1";'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 断言x == 1：“x！= 1”;
- en: '}'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first `assert` statement evaluates the expression `x > 1` and stops program
    execution (and reports `x <= 1`) if the expression `x > 1` evaluates to `false`.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`assert`语句评估表达式`x>1`，如果表达式`x>1`评估为`false`，则停止程序执行（并报告`x<=1`）。
- en: The second `assert` statement evaluates the expression `x == 1` and stops program
    execution (and reports `x != 1`) if the expression `x == 1` evaluates to `false`.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`assert`语句评估表达式`x == 1`，如果表达式`x == 1`评估为`false`，则停止程序执行（并报告`x！= 1`）。
- en: 'If we run this program now, none of the `assert` statements will be executed.
    To turn them on, click Run in the IntelliJ IDEA menu and select Edit Configurations,
    as shown in the following screenshot:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个程序，将不会执行任何`assert`语句。要打开它们，请单击IntelliJ IDEA菜单中的Run并选择Edit Configurations，如下面的屏幕截图所示：
- en: '![](img/4cfd5dda-e07c-45ec-b9bd-13c4e4b6ac33.png)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 4cfd5dda-e07c-45ec-b9bd-13c4e4b6ac33.png）
- en: 'The Run/Debug Configurations screen will open. Type `-ea` in the field VM options,
    as shown in the following screenshot:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行/调试配置屏幕将打开。在VM选项字段中键入`-ea`，如下面的屏幕截图所示：
- en: '![](img/8019cb61-0d4f-4d29-8d28-d10aef60490e.png)'
  id: totrans-1216
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 8019cb61-0d4f-4d29-8d28-d10aef60490e.png）
- en: Then, click the OK button at the bottom of the screen.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击屏幕底部的确定按钮。
- en: 'If you run the `AssertDemo` program now, the result will be:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行`AssertDemo`程序，结果将是：
- en: '![](img/9666cbdf-3943-494e-a7b8-d8a9eebdd592.png)'
  id: totrans-1219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9666cbdf-3943-494e-a7b8-d8a9eebdd592.png)'
- en: The `-ea` option should not be used in production, except maybe temporarily
    for testing purposes, because it creates overhead and affects the application's
    performance.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ea`选项不应该在生产中使用，除非可能是为了测试目的而临时使用，因为它会增加开销并影响应用程序的性能。'
- en: Exercise – Infinite loop
  id: totrans-1221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-无限循环
- en: Write one or two examples of an infinite loop.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个或两个无限循环的例子。
- en: Answer
  id: totrans-1223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here is one possible infinite loop implementation:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的无限循环实现：
- en: '```java'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: while(true){
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: while(true){
- en: System.out.println("try and stop me"); //prints indefinitely
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("尝试阻止我"); //无限打印
- en: '}'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The following is another one:'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个：
- en: '```java'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (;;){
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: for (;;){
- en: System.out.println("try and stop me"); //prints indefinitely
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("尝试阻止我"); //无限打印
- en: '}'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And this one is an infinite loop, too:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个无限循环：
- en: '```java'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: for (int x=2; x > 0; x--){
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: for (int x=2; x > 0; x--){
- en: System.out.println(x++ + " "); //prints 2 indefinitely
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x++ + " "); //无限打印2
- en: '}'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this code, the Boolean expression `x > 0` is always evaluated to `true` because
    `x` is initialized to `2` and then incremented and decremented by `1` in each
    iteration.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，布尔表达式`x > 0`总是被评估为`true`，因为`x`被初始化为`2`，然后在每次迭代中递增和递减`1`。
- en: Summary
  id: totrans-1243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter described Java statements that let you build a program flow according
    to the logic of the implemented algorithm, using conditional statements, iteration
    statements, branching statements, and exception handling. An extensive discussion
    of Java exception helped you to navigate this complex and very often correctly
    used area. Best practices were provided for the most effective and least confusing
    exception handling.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Java语句，让您根据实现的算法逻辑构建程序流，使用条件语句、迭代语句、分支语句和异常处理。对Java异常的广泛讨论帮助您在这个复杂且经常正确使用的领域中进行导航。为最有效和最少混淆的异常处理提供了最佳实践。
- en: In the next chapter, we will look under the hood of the JVM and discuss its
    processes and other aspects of its inner workings important that are for effective
    Java programming, including mechanism threads and garbage collection, which help
    an application to regain memory that is no longer in use.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解JVM的内部工作机制，讨论其进程和其他重要方面，包括线程和垃圾回收机制，这些对于有效的Java编程非常重要，它们帮助应用程序重新获得不再使用的内存。
