- en: '15: Security in Docker'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15：Docker中的安全性
- en: Good security is all about layers, and Docker has lots of layers. It supports
    all the major Linux security technologies, as well as having plenty of its own
    — and most of them are simple and easy to configure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的安全性建立在多层次之上，而Docker有很多层次。它支持所有主要的Linux安全技术，同时也有很多自己的技术，而且大多数都很简单易配置。
- en: In this chapter, we’ll look at some of the technologies that make running containers
    on Docker very secure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些使在Docker上运行容器非常安全的技术。
- en: 'When we get to the deep dive part of the chapter, we’ll divide things up into
    two categories:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入探讨本章的内容时，我们将把事情分成两类：
- en: Linux security technologies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux安全技术
- en: Docker platform security technologies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker平台安全技术
- en: Large parts of the chapter will be Linux specific. However, the **Docker platform
    security technologies** section is platform agnostic and applies equally to Linux
    and Windows.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将是针对Linux的。然而，Docker平台安全技术部分是与平台无关的，并且同样适用于Linux和Windows。
- en: Security in Docker - The TLDR
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker中的安全性-简而言之
- en: Security is all about layers! Generally speaking, the more security layers you
    have, the more secure you are. Well… Docker offers a lot of security layers. Figure
    15.1 shows some of the security technologies that we’ll cover in the chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性就是多层次的！一般来说，安全层次越多，您就越安全。嗯... Docker提供了很多安全层次。图15.1显示了我们将在本章中涵盖的一些安全技术。
- en: '![Figure 15.1](images/figure15-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: 图15.1
- en: Figure 15.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1
- en: Docker on Linux leverages most of the common Linux security technologies. These
    include *namespaces*, *control groups (cgroups)*, *capabilities*, *mandatory access
    control (MAC) systems*, and *seccomp*. For each one, Docker implements sensible
    defaults for a seamless and *moderately secure* out-of-the-box experience. However,
    it also allows you to customize each one to your own specific requirements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的Docker利用了大部分常见的Linux安全技术。这些包括命名空间，控制组（cgroups），权限，强制访问控制（MAC）系统和seccomp。对于每一种技术，Docker都实现了合理的默认设置，以实现无缝和相对安全的开箱即用体验。但是，它也允许您根据自己的特定要求自定义每一种技术。
- en: The Docker platform itself offers some excellent native security technologies.
    And one of the best things about these, is that they’re **amazingly simple to
    use!**
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台本身提供了一些出色的本地安全技术。其中最好的一点是它们非常简单易用！
- en: '**Docker Swarm Mode** is secure by default. You get all of the following with
    zero configuration required; cryptographic node IDs, mutual authentication, automatic
    CA configuration, automatic certificate rotation, encrypted cluster store, encrypted
    networks, and more.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm Mode默认情况下是安全的。您可以在不需要任何配置的情况下获得以下所有内容；加密节点ID，相互认证，自动CA配置，自动证书轮换，加密集群存储，加密网络等等。
- en: '**Docker Content Trust (DCT)** lets you sign your images and verify the integrity
    and publisher of images you pull.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内容信任（DCT）允许您对图像进行签名，并验证您拉取的图像的完整性和发布者。
- en: '**Docker Security Scanning** analyses Docker images, detects known vulnerabilities,
    and provides detailed reports.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安全扫描分析Docker镜像，检测已知的漏洞，并提供详细报告。
- en: '**Docker secrets** makes secrets first-class citizens in the Docker ecosystem.
    They get stored in the encrypted cluster store, encrypted in-flight when delivered
    to containers, stored in in-memory filesystems when in use, and operate a least-privilege
    model.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker secrets使秘密成为Docker生态系统中的一等公民。它们存储在加密的集群存储中，在传递给容器时进行加密，在使用时存储在内存文件系统中，并且采用最小权限模型。
- en: The important thing to know, is that Docker works with the major Linux security
    technologies as well as providing its own extensive and growing set of security
    technologies. While the Linux security technologies can be a bit complicated to
    configure, the Docker platform’s own security technologies are very simple.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Docker与主要的Linux安全技术一起工作，并提供自己广泛且不断增长的安全技术。虽然Linux安全技术可能有点复杂，但Docker平台的安全技术非常简单。
- en: Security in Docker - The deep dive
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker中的安全-深入挖掘
- en: We all know that security is important. We also know that security can be complicated
    and boring!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道安全性很重要。我们也知道安全性可能会很复杂和无聊！
- en: When Docker decided to bake security into its platform, it decided to make it
    simple and easy. They knew that if security was hard to configure, people wouldn’t
    use it. As a result, most of the security technologies offered by the Docker platform
    are simple to use. They also ship with sensible defaults — this means that you
    get a *fairly secure* platform at zero effort. Of course, the defaults are not
    perfect, but they’re usually enough to give you a safe start. If they don’t suit
    your needs, you can always customize them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker决定将安全性融入其平台时，它决定要使其简单易用。他们知道如果安全性难以配置，人们就不会使用它。因此，Docker平台提供的大多数安全技术都很简单易用。它们还提供合理的默认设置-这意味着你可以零配置得到一个相对安全的平台。当然，默认设置并不完美，但通常足以让你安全启动。如果它们不符合你的需求，你总是可以自定义它们。
- en: 'We’ll organize the rest of this chapter as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式组织本章的其余部分：
- en: Linux security technologies
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux安全技术
- en: Namespaces
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Control Groups
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制组
- en: Capabilities
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: capabilities
- en: Mandatory Access Control
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制访问控制
- en: seccomp
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: seccomp
- en: Docker platform security technologies
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker平台安全技术
- en: Swarm Mode
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swarm模式
- en: Docker Security Scanning
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker安全扫描
- en: Docker Content Trust
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker内容信任
- en: Docker Secrets
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Secrets
- en: Linux security technologies
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux安全技术
- en: All *good* container platforms should use *namespaces* and *cgroups* to build
    containers. The *best* container platforms will also integrate with other Linux
    security technologies such as *capabilities*, *Mandatory Access Control systems*
    like SELinux and AppArmor, and *seccomp*. As expected, Docker integrates with
    them all!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有良好的容器平台都应该使用命名空间和cgroups来构建容器。最好的容器平台还将集成其他Linux安全技术，如*capabilities*、*强制访问控制系统*，如SELinux和AppArmor，以及*seccomp*。如预期的那样，Docker与它们都集成在一起！
- en: In this section of the chapter we’ll take a *brief* look at some of the major
    Linux security technologies used by Docker. We won’t go into detail, as I want
    the main focus of the chapter to be on the Docker platform technologies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将简要介绍Docker使用的一些主要Linux安全技术。我们不会详细介绍，因为我希望本章的主要重点是Docker平台技术。
- en: Namespaces
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名空间
- en: Kernel namespaces are at the very heart of containers! They let us slice up
    an operating system (OS) so that it looks and feels like multiple isolated operating
    systems. This lets us do really cool things like run multiple web servers on the
    same OS without having port conflicts. It also lets us run multiple apps on the
    same OS without them fighting over shared config files and shared libraries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命名空间是容器的核心！它们让我们可以切分操作系统（OS），使其看起来和感觉像多个隔离的操作系统。这让我们可以做一些很酷的事情，比如在同一个OS上运行多个web服务器而不会出现端口冲突。它还让我们在同一个OS上运行多个应用程序，而不会因为共享配置文件和共享库文件而发生冲突。
- en: 'A couple of quick examples:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些快速的例子：
- en: You can run multiple web servers, each on port 443, on a single OS. To do this
    you just run each web server app inside of its own *network namespace*. This works
    because each *network namespace* gets its own IP address and full range of ports.
    You may have to map each one to a separate port on the Docker host, but each can
    run without being re-written or reconfigured to use a different port.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在单个操作系统上运行多个Web服务器，每个Web服务器都在端口443上运行。为此，您只需在每个Web服务器应用程序内运行其自己的*网络命名空间*。这是因为每个*网络命名空间*都有自己的IP地址和完整的端口范围。您可能需要将每个端口映射到Docker主机上的不同端口，但每个端口都可以在不重新编写或重新配置以使用不同端口的情况下运行。
- en: You can run multiple applications, each requiring their own particular version
    of a shared library or configuration file. To do this you run each application
    inside of its own *mount namespace*. This works because each *mount namespace*
    can have its own isolated copy of any directory on the system (e.g. /etc, /var,
    /dev etc.)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以运行多个应用程序，每个应用程序都需要自己特定版本的共享库或配置文件。为此，您可以在每个*挂载命名空间*内运行每个应用程序。这是因为每个*挂载命名空间*可以在系统上拥有任何目录的独立副本（例如/
    etc，/ var，/ dev等）。
- en: Figure 15.2 shows a high-level example of two web server applications running
    on a single host and both using port 443\. Each web server app is running inside
    of its own network namespace.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2显示了单个主机上运行两个Web服务器应用程序的高级示例，两者都使用端口443。每个Web服务器应用程序都在自己的网络命名空间内运行。
- en: '![Figure 15.2](images/figure15-2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2](images/figure15-2.png)'
- en: Figure 15.2
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2
- en: 'Docker on Linux currently utilizes the following kernel namespaces:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的Docker目前利用以下内核命名空间：
- en: Process ID (pid)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程ID（pid）
- en: Network (net)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络（net）
- en: Filesystem/mount (mnt)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统/挂载（mnt）
- en: Inter-process Communication (ipc)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信（ipc）
- en: User (user)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户（用户）
- en: UTS (uts)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTS（uts）
- en: We’ll briefly explain what each one does in a moment. But the most important
    thing to understand is that **Docker containers are an organized collection of
    namespaces**. Let me repeat that… ***A Docker container is an organized collection
    of namespaces***.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将简要解释每个命名空间的作用。但最重要的是要理解**Docker容器是命名空间的有序集合**。让我重复一遍… ***Docker容器是命名空间的有序集合***。
- en: For example, every container is made up of its own `pid`, `net`, `mnt`, `ipc`,
    `uts`, and potentially `user` namespace. The organized collection of these namespaces
    is what we call a container. Figure 15.3 shows a single Linux host running two
    containers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个容器由自己的`pid`，`net`，`mnt`，`ipc`，`uts`和可能的`user`命名空间组成。这些命名空间的有序集合就是我们所说的容器。图15.3显示了一个单个Linux主机运行两个容器。
- en: '![Figure 15.3](images/figure15-3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3](images/figure15-3.png)'
- en: Figure 15.3
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3
- en: 'Let’s briefly look at how Docker uses each namespace:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下Docker如何使用每个命名空间：
- en: '`Process ID namespace:` Docker uses the `pid` namespace to provide isolated
    process trees for each container. Every container gets its own process tree, meaning
    that every container can have its own PID 1\. PID namespaces also mean that a
    container cannot see or access to the process tree of other containers, or the
    host it’s running on.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`进程ID命名空间：` Docker使用`pid`命名空间为每个容器提供独立的进程树。每个容器都有自己的进程树，这意味着每个容器都可以有自己的PID
    1。PID命名空间还意味着容器无法看到或访问其他容器或其运行的主机的进程树。'
- en: '`Network namespace:` Docker uses the `net` namespace to provide each container
    its own isolated network stack. This stack includes; interfaces, IP addresses,
    port ranges, and routing tables. For example, every container gets its own `eth0`
    interface with its own unique IP and range of ports.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网络命名空间：` Docker使用`net`命名空间为每个容器提供独立的网络堆栈。该堆栈包括接口、IP地址、端口范围和路由表。例如，每个容器都有自己的`eth0`接口，具有自己独特的IP和端口范围。'
- en: '`Mount namespace:` Every container gets its own unique isolated root `/` filesystem.
    This means that every container can have its own `/etc`, `/var`, `/dev` etc. Processes
    inside of a container cannot access the mount namespace of the Linux host or other
    containers — they can only see and access their own isolated mount namespace.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mount namespace:` 每个容器都有自己独特的隔离根目录`/`文件系统。这意味着每个容器都可以有自己的`/etc`、`/var`、`/dev`等。容器内的进程无法访问Linux主机或其他容器的挂载命名空间
    - 它们只能看到和访问自己隔离的挂载命名空间。'
- en: '`Inter-process Communication namespace:` Docker uses the `ipc` namespace for
    shared memory access within a container. It also isolates the container from shared
    memory outside of the container.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inter-process Communication namespace:` Docker使用`ipc`命名空间在容器内进行共享内存访问。它还将容器与容器外的共享内存隔离开来。'
- en: '`User namespace:` Docker lets you use `user` namespaces to map users inside
    of a container to different users on the Linux host. A common example is mapping
    the `root` user of a container to a non-root user on the Linux host. User namespaces
    are quite new to Docker and currently optional. This may change in the future.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User namespace:` Docker允许您使用`user`命名空间将容器内的用户映射到Linux主机上的不同用户。一个常见的例子是将容器的`root`用户映射到Linux主机上的非root用户。用户命名空间对于Docker来说是相当新的，目前是可选的。这可能会在将来发生变化。'
- en: '`UTS namespace:` Docker uses the `uts` namespace to provide each container
    with its own hostname.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UTS namespace:` Docker使用`uts`命名空间为每个容器提供自己的主机名。'
- en: Remember… a container is an organized collection of namespaces!!!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住...容器是一组命名空间的有序集合！！！
- en: '![Figure 15.4](images/figure15-4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4](images/figure15-4.png)'
- en: Figure 15.4
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4
- en: Control Groups
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制组
- en: If namespaces are about isolation, *control groups (cgroups)* are about setting
    limits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名空间是关于隔离的话，*控制组（cgroups）*则是关于设置限制的。
- en: Think of containers as similar to rooms in a hotel. Yes, each room is isolated,
    but each room also shares a common set of resources — things like water supply,
    electricity supply, shared swimming pool, shared gym, shared breakfast bar etc.
    Cgroups let us set limits so that (sticking with the hotel analogy) no single
    container can use all of the water or eat everything at the breakfast bar.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器类比为酒店中的房间。是的，每个房间都是隔离的，但每个房间也共享一组公共资源 - 诸如供水、供电、共享游泳池、共享健身房、共享早餐吧等。Cgroups让我们设置限制，以便（继续使用酒店类比）没有单个容器可以使用所有的水或吃光早餐吧的所有食物。
- en: In the real world, not the silly hotel analogy, containers are isolated from
    each other but all share a common set of OS resources — things like CPU, RAM and
    disk I/O. Cgroups let us set limits on each of these so that a single container
    cannot use all of the CPU, RAM, or storage I/O of the host.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，而不是愚蠢的酒店类比，容器彼此隔离，但共享一组公共的操作系统资源 - 诸如CPU、RAM和磁盘I/O之类的东西。Cgroups让我们对这些资源中的每一个设置限制，以便单个容器不能使用主机的所有CPU、RAM或存储I/O。
- en: Capabilities
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Capabilities
- en: It’s a bad idea to run containers as root — root is all-powerful and therefore
    very dangerous. But, it’s a pain in the backside running containers as non-root
    — non-root is so powerless it’s practically useless. What we need is a technology
    that lets us pick and choose which root powers our containers need in order to
    run. Enter *capabilities!*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中以root身份运行是一个坏主意 - root拥有无限的权力，因此非常危险。但是，以非root身份运行容器也很麻烦 - 非root几乎没有任何权力，几乎没有用处。我们需要的是一种技术，让我们可以选择容器需要哪些root权限才能运行。进入*capabilities*！
- en: 'Under the hood, the Linux root account is made up of a long list of capabilities.
    Some of these include:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Linux的root账户由一长串的capabilities组成。其中一些包括：
- en: '`CAP_CHOWN` lets you change file ownership'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_CHOWN`允许您更改文件所有权'
- en: '`CAP_NET_BIND_SERVICE` lets you bind a socket to low numbered network ports'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_NET_BIND_SERVICE`允许您将套接字绑定到低编号的网络端口'
- en: '`CAP_SETUID` lets you elevate the privilege level of a process'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_SETUID`允许您提升进程的特权级别'
- en: '`CAP_SYS_BOOT` lets you reboot the system.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_SYS_BOOT`允许您重新启动系统。'
- en: The list goes on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。
- en: Docker works with *capabilities* so that you can run containers as root, but
    strip out the root capabilities that you don’t need. For example, if the only
    root privilege your container needs is the ability to bind to low numbered network
    ports, you should start a container and drop all root capabilities, then add back
    the CAP_NET_BIND_SERVICE capability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用*capabilities*，因此您可以以root身份运行容器，但剥离掉不需要的root权限。例如，如果容器唯一需要的root权限是绑定到低编号的网络端口的能力，您应该启动一个容器并删除所有root权限，然后再添加CAP_NET_BIND_SERVICE权限。
- en: Docker also imposes restrictions so that containers cannot re-add the removed
    capabilities.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还施加限制，使容器无法重新添加已删除的功能。
- en: Mandatory Access Control systems
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制访问控制系统
- en: Docker works with major Linux MAC technologies such as AppArmor and SELinux.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Docker与主要的Linux MAC技术（如AppArmor和SELinux）兼容。
- en: Depending on your Linux distribution, Docker applies a default AppArmor profile
    to all new containers. According to the Docker documentation, this default profile
    is “moderately protective while providing wide application compatibility”.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的Linux发行版，Docker会为所有新容器应用默认的AppArmor配置文件。根据Docker文档，这个默认配置文件是“适度保护，同时提供广泛的应用程序兼容性”。
- en: Docker also lets you start containers without a policy applied, as well as giving
    you the ability to customize policies to meet your specific requirements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还允许您启动没有应用策略的容器，并且可以自定义策略以满足您的特定要求。
- en: seccomp
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: seccomp
- en: Docker uses seccomp, in filter mode, to limit the syscalls a container can make
    to the host’s kernel.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用seccomp，在过滤模式下，限制容器可以向主机内核发出的系统调用。
- en: As per the Docker security philosophy, all new containers get a default seccomp
    profile configured with sensible defaults. This is intended to provide moderate
    security without impacting application compatibility.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker安全理念，所有新容器都会配置一个默认的seccomp配置文件，其中包含合理的默认设置。这旨在提供适度的安全性，而不影响应用程序的兼容性。
- en: As always, you can customize seccomp profiles, and you can pass a flag to Docker
    so that containers can be started without a seccomp profile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您可以自定义seccomp配置文件，并且可以向Docker传递一个标志，以便可以启动没有seccomp配置文件的容器。
- en: Final thoughts on the Linux security technologies
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于Linux安全技术的最终思考
- en: Docker supports most of the important Linux security technologies and ships
    with sensible defaults that add security but aren’t too restrictive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持大多数重要的Linux安全技术，并提供合理的默认设置，以增加安全性但不会太严格限制。
- en: '![Figure 15.5](images/figure15-5.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5](images/figure15-5.png)'
- en: Figure 15.5
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5
- en: Some of these technologies can be complicated to customize, as they require
    deep knowledge of how they work, as well as how the Linux kernel works. Hopefully
    they will get simpler to configure in the future, but for now, the default configurations
    that ship with Docker are a good place to start.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些技术可能很难定制，因为它们需要深入了解其工作原理以及Linux内核的工作原理。希望它们在未来会变得更容易配置，但目前，Docker随附的默认配置是一个很好的起点。
- en: Docker platform security technologies
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker平台安全技术
- en: In this section of the chapter, we’ll take a look at some of the major security
    technologies offered by the **Docker platform**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将看一下**Docker平台**提供的一些主要安全技术。
- en: Security in Swarm Mode
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Swarm模式下的安全性
- en: Swarm Mode is the future of Docker. It lets you cluster multiple Docker hosts
    and deploy your applications in a declarative way. Every Swarm is comprised of
    *managers* and *workers* that can be Linux or Windows. Managers make up the control
    plane of the cluster and are responsible for configuring the cluster and dispatching
    work to it. Workers are the nodes that run your application code as containers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm Mode是Docker的未来。它允许您集群多个Docker主机，并以声明性方式部署应用程序。每个Swarm由*管理者*和*工作者*组成，可以是Linux或Windows。管理者组成集群的控制平面，并负责配置集群并向其分派工作。工作者是运行应用程序代码的节点，作为容器运行。
- en: 'As expected, Swarm Mode includes many security features that are enabled out-of-the-box
    with sensible defaults. These include:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Swarm Mode包括许多安全功能，这些功能已启用，并具有合理的默认值。这些功能包括：
- en: Cryptographic node IDs
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密节点ID
- en: Mutual authentication via TLS
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TLS的双向认证
- en: Secure join tokens
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全加入令牌
- en: CA configuration with automatic certificate rotation
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有自动证书轮换的CA配置
- en: Encrypted cluster store (config DB)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密集群存储（配置数据库）
- en: Encrypted networks
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密网络
- en: Let’s walk through the process of building a secure Swarm and configuring some
    of the security aspects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍构建安全Swarm并配置一些安全方面的过程。
- en: To follow along, you will need at least three Docker hosts running Docker 1.13
    or higher. The examples cited use three Docker hosts called “mgr1”, “mgr2”, and
    “wrk1”. Each one is running Docker 18.01.0-ce on Ubuntu 16.04\. There is network
    connectivity between all three hosts, and all three can ping each other by name.
    The setup is shown in Figure 15.6.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随操作，您至少需要三个运行Docker 1.13或更高版本的Docker主机。所引用的示例使用三个名为“mgr1”、“mgr2”和“wrk1”的Docker主机。每个主机都在Ubuntu
    16.04上运行Docker 18.01.0-ce。所有三个主机之间有网络连接，并且都可以通过名称相互ping通。设置如图15.6所示。
- en: '![Figure 15.6](images/figure15-6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6](images/figure15-6.png)'
- en: Figure 15.6
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6
- en: Configure a secure Swarm
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置安全Swarm
- en: Run the following command from the node you want to be the first manager in
    the new Swarm. In the example, we will run it from “mgr1”.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从要成为新Swarm中第一个管理者的节点运行以下命令。在示例中，我们将从“mgr1”运行它。
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`That’s it! That is literally all you need to do to configure a secure Swarm!'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`就是这样！这确实是您需要做的一切来配置一个安全的Swarm！'
- en: “mgr1” is configured as the first manager of the Swarm and also as the root
    CA. The Swarm has been given a cryptographic Swarm ID, and “mgr1” has issued itself
    with a client certificate that identifies it as a manager in the Swarm. Certificate
    rotation has been configured with the default value of 90 days, and a cluster
    config database has been configured and encrypted. A set of secure tokens have
    also been created so that new managers and new workers can be joined to the Swarm.
    And all of this with a **single command!**
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: “mgr1”被配置为Swarm的第一个管理者，也是根CA。Swarm已被赋予了一个加密的Swarm ID，“mgr1”已经为自己颁发了一个客户端证书，用于标识其作为Swarm中的管理者。证书轮换已配置为默认值90天，并且已配置和加密了集群配置数据库。一组安全令牌也已创建，以便新的管理者和新的工作者可以加入Swarm。而且所有这些只需**一个命令！**
- en: Figure 15.7 shows how the lab looks now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7显示了实验室的当前状态。
- en: '![Figure 15.7](images/figure15-7.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7](images/figure15-7.png)'
- en: Figure 15.7
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7
- en: Now let’s join “mgr2” as an additional manager.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将“mgr2”作为额外的管理者加入。
- en: Joining new managers to a Swarm is a two-step process. In the first step, you’ll
    extract the token required to join new managers to the Swarm. In the second, you’ll
    run a `docker swarm join` command on “mgr2”. As long as you include the manager
    join token as part of the `docker swarm join` command, “mgr2” will join the Swarm
    as a manager.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将新管理者加入Swarm是一个两步过程。在第一步中，您将提取加入新管理者到Swarm所需的令牌。在第二步中，您将在“mgr2”上运行`docker swarm
    join`命令。只要您在`docker swarm join`命令中包含管理者加入令牌，“mgr2”就会作为管理者加入Swarm。
- en: Run the following command from “mgr1” to extract the manager join token.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从“mgr1”运行以下命令以提取管理节点加入令牌。
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`The output of the command gives you the exact command you need to run on nodes
    that you want to join the Swarm as managers. The join token and IP address will
    be different in your lab.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`命令的输出给出了你需要在要加入Swarm作为管理节点的节点上运行的确切命令。在你的实验室中，加入令牌和IP地址将是不同的。'
- en: 'Copy the command and run it on “mgr2”:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复制命令并在“mgr2”上运行：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`“mgr2” has now joined the Swarm as an additional manager.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`“mgr2”现在作为额外的管理节点加入了Swarm。'
- en: The format of the join command is `docker swarm join --token <manager-join-token>
    <ip-of-existing-manager>:<swarm-port>`.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加入命令的格式是`docker swarm join --token <manager-join-token> <ip-of-existing-manager>:<swarm-port>`。
- en: You can verify the operation by running a `docker node ls` on either of the
    two managers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在两个管理节点中运行`docker node ls`来验证操作。
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`The output above shows that “mgr1” and “mgr2” are both part of the Swarm and
    are both Swarm managers. The updated configuration is shown in Figure 15.8.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`上面的输出显示“mgr1”和“mgr2”都是Swarm的一部分，都是Swarm管理节点。更新后的配置如图15.8所示。'
- en: '![Figure 15.8](images/figure15-8.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8](images/figure15-8.png)'
- en: Figure 15.8
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8
- en: Two managers is possibly the worst number you can have. However, we’re just
    messing about in a demo lab, not building a business critical production environment
    ;-)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 两个管理节点可能是你能拥有的最糟糕的数量。然而，在演示实验室中我们只是在玩玩，而不是建立一个业务关键的生产环境 ;-)
- en: Adding a Swarm worker is a similar two-step process. Step 1 is to extract the
    join token for new workers, and step 2 is to run a `docker swarm join` command
    on the node you want to join as a worker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Swarm工作节点是一个类似的两步过程。第一步是提取新工作节点的加入令牌，第二步是在要加入为工作节点的节点上运行`docker swarm join`命令。
- en: Run the following command on either of the managers to expose the worker join
    token.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一管理节点上运行以下命令以公开工作节点加入令牌。
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Again, you get the exact command you need to run on nodes that you want to
    join as workers. The join token and IP address will be different in your lab.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`同样，你会得到你需要在要加入为工作节点的节点上运行的确切命令。在你的实验室中，加入令牌和IP地址将是不同的。'
- en: 'Copy the command and run it on “wrk1” as shown:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 复制命令并在“wrk1”上运行如下：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Run another `docker node ls` command from either of the Swarm managers.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`从Swarm管理节点中再次运行`docker node ls`命令。'
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`You now have a Swarm with two managers and one worker. The managers are configured
    for high availability (HA) and the cluster store is replicated to them both. This
    updated configuration is shown in Figure 15.9.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`现在你有一个包含两个管理节点和一个工作节点的Swarm。管理节点配置为高可用性（HA），并且集群存储被复制到它们两个。更新后的配置如图15.9所示。'
- en: '![Figure 15.9](images/figure15-9.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9](images/figure15-9.png)'
- en: Figure 15.9
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9
- en: Looking behind the scenes at Swarm security
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看Swarm安全技术的幕后
- en: Now that we’ve built a secure Swarm let’s take a minute to look behind the scenes
    at some of the security technologies involved.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个安全的Swarm，让我们花一分钟来看看一些涉及的安全技术。
- en: Swarm join tokens
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Swarm加入令牌
- en: The only thing that is needed to join managers and workers to an existing Swarm
    is the relevant join token. For this reason, it is vital that you keep your join-tokens
    safe! No posting them on public GitHub repos!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 加入现有Swarm的管理节点和工作节点所需的唯一事物就是相关的加入令牌。因此，保持你的加入令牌安全是至关重要的！不要在公共GitHub仓库上发布它们！
- en: 'Every Swarm maintains two distinct join tokens:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Swarm都维护两个不同的加入令牌：
- en: One for joining new managers
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于加入新管理节点
- en: One for joining new workers
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于加入新工作节点
- en: 'It’s worth understanding the format of the Swarm join token. Every join token
    is comprised of 4 distinct fields separated by dashes (`-`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 值得了解Swarm加入令牌的格式。每个加入令牌由4个不同的字段组成，用破折号（`-`）分隔：
- en: '`PREFIX - VERSION - SWARM ID - TOKEN`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`前缀 - 版本 - Swarm ID - 令牌`'
- en: The prefix is always “SWMTKN”, enabling you to pattern match against it and
    prevent people from accidentally posting it publicly. The version field indicates
    the version of the Swarm. The Swarm ID field is a hash of the Swarm’s certificate.
    The token portion is the part that determines if it can be used to join nodes
    as managers or workers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀始终为“SWMTKN”，使您能够对其进行模式匹配，并防止人们意外地公开发布它。版本字段指示了Swarm的版本。Swarm ID字段是Swarm证书的哈希值。令牌部分是决定它是否可以用于加入节点作为管理器或工作节点的部分。
- en: As the following shows, the manager and worker join tokens for a given Swarm
    are identical except for the final TOKEN field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，给定Swarm的管理器和工作节点加入令牌除了最终的TOKEN字段外是相同的。
- en: 'MANAGER: SWMTKN-1-1dmtwusdc…r17stb-**2axi53zjbs45lqxykaw8p7glz**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器：SWMTKN-1-1dmtwusdc…r17stb-**2axi53zjbs45lqxykaw8p7glz**
- en: 'WORKER: SWMTKN-1-1dmtwusdc…r17stb-**ehp8gltji64jbl45zl6hw738q**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作节点：SWMTKN-1-1dmtwusdc…r17stb-**ehp8gltji64jbl45zl6hw738q**
- en: If you suspect that either of your join tokens has been compromised you can
    revoke them and issue new ones with a single command. The following example revokes
    the existing *manager* join token and issues a new one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您怀疑您的任一加入令牌已被泄露，您可以撤销它们并用单个命令发布新的。以下示例撤销了现有的*manager*加入令牌并发布了一个新的。
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Notice that the only difference between the old and new join tokens is the
    last field. The Swarm ID remains the same.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，旧加入令牌和新加入令牌之间唯一的区别是最后一个字段。Swarm ID保持不变。
- en: Join tokens are stored in the cluster config database which is encrypted by
    default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 加入令牌存储在默认情况下由加密的集群配置数据库中。
- en: TLS and mutual authentication
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: TLS和相互认证
- en: Every manager and worker that joins a Swarm is issued a client certificate.
    This certificate is used for mutual authentication. It identifies the node, which
    Swarm the node is a member of, and role the node performs in the Swarm (manager
    or worker).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 加入Swarm的每个管理器和工作节点都会被发放一个客户端证书。该证书用于相互认证。它标识了节点所属的Swarm，以及节点在Swarm中的角色（管理器或工作节点）。
- en: On a Linux host, you can inspect a node’s client certificate with the following
    command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux主机上，您可以使用以下命令检查节点的客户端证书。
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`The `Subject` data in the output above uses the standard `O`, `OU`, and `CN`
    fields to specify the Swarm ID, the node’s role, and the node ID.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的`Subject`数据使用标准的`O`、`OU`和`CN`字段来指定Swarm ID、节点的角色和节点ID。
- en: The Organization `O` field stores the Swarm ID
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织`O`字段存储了Swarm ID
- en: The Organizational Unit `OU` field stores the node’s role in the Swarm
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织单位`OU`字段存储了节点在Swarm中的角色
- en: The Canonical Name `CN` field stores the node’s crypto ID.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范名称`CN`字段存储了节点的加密ID。
- en: This is shown in Figure 15.10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图15.10中显示。
- en: '![Figure 15.10](images/figure15-10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10](images/figure15-10.png)'
- en: Figure 15.10
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10
- en: We can also see the certificate rotation period in the `Validity` section directly
    above.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接在`Validity`部分看到证书轮换周期。
- en: We can match these values to the corresponding values shown in the output of
    a `docker system info` command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些值与`docker system info`命令的输出中显示的相应值进行匹配。
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`###### Configuring some CA settings'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 配置一些CA设置'
- en: You can configure the certificate rotation period for the Swarm with the `docker
    swarm update` command. The following example changes the certificate rotation
    period to 30 days.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker swarm update`命令为Swarm配置证书轮换周期。以下示例将证书轮换周期更改为30天。
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Swarm allows nodes to renew certificates early (slightly before they expire)
    so that not all nodes in the Swarm try and update their certificates at the same
    time.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swarm允许节点提前更新证书（在证书到期之前稍微提前），以便Swarm中的所有节点不会同时尝试更新它们的证书。'
- en: You can configure an external CA when creating a Swarm by passing the `--external-ca`
    flag to the `docker swarm init` command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向`docker swarm init`命令传递`--external-ca`标志来在创建Swarm时配置外部CA。
- en: The new `docker swarm ca` sub-command can be used to manage CA related configuration.
    Run the command with the `--help` flag to see a list of things it can do.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`docker swarm ca`子命令可以用来管理与CA相关的配置。运行带有`--help`标志的命令，可以看到它可以做的事情列表。
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`###### The cluster store'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '###### 集群存储'
- en: The cluster store is the brains of a Swarm and is the place where cluster config
    and state are stored.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 集群存储是Swarm的大脑，也是存储集群配置和状态的地方。
- en: The store is currently based on an implementation of `etcd`, and is automatically
    configured to replicate itself to all managers in the Swarm. It is also encrypted
    by default.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 存储目前基于`etcd`的实现，并自动配置为在Swarm中的所有管理节点上进行复制。它也默认是加密的。
- en: The cluster store is becoming a critical component of many Docker platform technologies.
    For example, Docker networking and Docker Secrets both leverage the cluster store.
    This is one of the reasons that Swarm Mode is so important to the future of Docker
    — many parts of the Docker platform already leverage the cluster store, and more
    will leverage it in the future. The moral of the story… if you’re not running
    in Swarm Mode, you’ll be limited in what other Docker features you can use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 集群存储正在成为许多Docker平台技术的关键组件。例如，Docker网络和Docker Secrets都利用了集群存储。这就是Swarm Mode对Docker未来如此重要的原因之一——Docker平台的许多部分已经利用了集群存储，而将来还会有更多的部分利用它。故事的寓意是，如果你不在Swarm
    Mode下运行，你将受限于你可以使用的其他Docker功能。
- en: The day-to-day maintenance of the cluster store is taken care of automatically
    by Docker. However, in production environments, you should have strong backup
    and recovery solutions in place for it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Docker会自动处理集群存储的日常维护。然而，在生产环境中，你应该为其提供强大的备份和恢复解决方案。
- en: That’s enough for now about Swarm Mode security.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Swarm Mode安全性的内容就到这里就够了。
- en: Detecting vulnerabilities with Docker Security Scanning
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Docker安全扫描检测漏洞
- en: The ability to quickly identify code vulnerabilities is vital. Docker Security
    Scanning makes detecting known vulnerabilities in Docker images simple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 快速识别代码漏洞的能力至关重要。Docker安全扫描使检测Docker镜像中已知漏洞变得简单。
- en: '**Note:** At the time of writing, Docker Security Scanning is available for
    images in private repositories on Docker Hub. It is also available as part of
    the Docker Trusted Registry on-premises registry solution. Finally, all official
    Docker images are scanned and scan reports are available in their repos.'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**在撰写本文时，Docker安全扫描适用于Docker Hub上私有仓库中的镜像。它也作为Docker Trusted Registry本地注册表解决方案的一部分提供。最后，所有官方Docker镜像都经过扫描，并在其仓库中提供扫描报告。'
- en: Docker Security Scanning performs binary-level scans of Docker images and checks
    the software in them against databases of known vulnerabilities (CVE databases).
    After the scan is performed, a detailed report is made available.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安全扫描对Docker镜像进行二进制级别的扫描，并检查其中的软件是否存在已知漏洞（CVE数据库）。扫描完成后，会提供详细的报告。
- en: Open a web browser to https://hub.docker.com and search for the `alpine` repo.
    Figure 15.11 shows the `Tags` tab of the official Alpine repo.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器，访问https://hub.docker.com，并搜索`alpine`仓库。图15.11显示了官方Alpine仓库的`Tags`标签页。
- en: '![Figure 15.11](images/figure15-11.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图15.11](images/figure15-11.png)'
- en: Figure 15.11
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11
- en: The Alpine repo is an official repo. This means it automatically gets scanned
    and scan reports are made available. As you can see, the images tagged as `edge`,
    `latest`, and `3.6` are free from known vulnerabilities. However, the `alpine:3.5`
    image has known vulnerabilities (red).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine仓库是一个官方仓库。这意味着它会自动进行扫描，并提供扫描报告。正如你所看到的，标记为`edge`、`latest`和`3.6`的镜像都没有已知的漏洞。然而，`alpine:3.5`镜像有已知的漏洞（红色）。
- en: If you drill into the `alpine:3.5` image you get a more detailed report as shown
    in Figure 15.12.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入研究`alpine:3.5`镜像，你将得到一个更详细的报告，如图15.12所示。
- en: '![Figure 15.12](images/figure15-12.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12](images/figure15-12.png)'
- en: Figure 15.12
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12
- en: This is a simple and easy way to get detailed information about known vulnerabilities
    in your software.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单而轻松的方式，可以获取有关软件已知漏洞的详细信息。
- en: Docker Trusted Registry (DTR), which is an on-premises Docker registry included
    as part of Docker Enterprise Edition, provides the same capabilities and gives
    you control over how and when image scans are performed. For example, DTR lets
    you decide if images should be automatically scanned as soon as they are pushed,
    or if scans should only be triggered manually. It also allows you to manually
    upload CVE database updates — this is ideal for situations where your DTR infrastructure
    is air-gapped from the internet and cannot automatically sync updates.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Docker受信任的注册表（DTR）是Docker企业版的一部分，是一个本地Docker注册表，提供相同的功能，并允许您控制图像扫描的方式和时间。例如，DTR允许您决定图像是否应在推送后自动扫描，或者是否应仅手动触发扫描。它还允许您手动上传CVE数据库更新
    - 这对于您的DTR基础设施与互联网隔离并且无法自动同步更新的情况非常理想。
- en: That’s Docker Security Scanning — a great way to deeply inspect your Docker
    images for known vulnerabilities. Beware though, with great knowledge comes great
    responsibility — once you know about vulnerabilities, it’s your responsibility
    to deal with them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Docker安全扫描 - 一种深入检查Docker图像已知漏洞的好方法。但要注意，拥有伟大的知识就意味着拥有伟大的责任 - 一旦您了解了漏洞，就是您的责任来处理它们。
- en: Signing and verifying images with Docker Content Trust
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Docker内容信任对图像进行签名和验证。
- en: Docker Content Trust (DCT) makes it simple and easy to verify the integrity
    and the publisher of images that you download. This is especially important when
    pulling images over untrusted networks such as the internet.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内容信任（DCT）使验证下载的图像的完整性和发布者变得简单而容易。这在通过不受信任的网络（如互联网）拉取图像时尤为重要。
- en: At a high level, DCT allows developers to sign their images when they are pushed
    to Docker Hub or Docker Trusted Registry. It will also automatically verify images
    when they are pulled. This high-level process is shown in Figure 15.13
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，DCT允许开发人员在将图像推送到Docker Hub或Docker受信任的注册表时对其进行签名。它还会在拉取图像时自动验证。这个高层次的过程如图15.13所示。
- en: '![Figure 15.13](images/figure15-13.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图15.13](images/figure15-13.png)'
- en: Figure 15.13
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13
- en: DCT can also provide important *context*. This includes things like; whether
    or not an image has been signed for use in a production environment, or whether
    an image has been superseded by a newer version and is therefore stale.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: DCT还可以提供重要的*上下文*。这包括诸如图像是否已经签名用于生产环境，或者图像是否已被新版本取代并因此过时等信息。
- en: At the time of writing, the *context* offerings of DTC are in their infancy
    and quite complex to configure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，DTC的*上下文*提供还处于起步阶段，并且配置相当复杂。
- en: All you need to do, to enable DCT on a Docker host, is export an environment
    variable called `DOCKER_CONTENT_TRUST` with a value of `1`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在Docker主机上启用DCT，就可以导出一个名为`DOCKER_CONTENT_TRUST`的环境变量，其值为`1`。
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`In the real world, you may want to make this a more permanent feature of your
    system.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`在现实世界中，您可能希望将这变成系统的一个更为永久的特性。'
- en: If you are using Docker Universal Control Plane (part of Docker Enterprise Edition),
    you need to set the `Only run signed images` checkbox as shown in Figure 15.14\.
    This will force all nodes in the UCP cluster to only work with signed images.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Docker Universal Control Plane（Docker企业版的一部分），您需要像图15.14所示，设置`仅运行已签名的图像`复选框。这将强制UCP集群中的所有节点仅使用已签名的图像。
- en: '![Figure 15.14](images/figure15-14.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图15.14](images/figure15-14.png)'
- en: Figure 15.14
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14
- en: You can see from Figure 15.14 that Universal Control Plane takes DCT one step
    further by giving the option to list security principals that are required to
    sign an image. For example, you might have a corporate policy that all images
    used in production need to be signed by the `secops` team.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从图15.14中可以看出，Universal Control Plane通过提供列出需要签署镜像的安全主体的选项，将DCT推向了更高一级。例如，您可能有一个公司政策，即所有在生产中使用的镜像都需要由`secops`团队签名。
- en: Once DCT has been enabled, you will no longer be able to pull and work with
    unsigned images. Figure 15.15 shows the errors you will get if you attempt to
    pull an unsigned image using the Docker CLI and the Universal Control Plane web
    UI (both examples are attempting to pull an image tagged as “unsigned”)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了DCT，您将无法再拉取和使用未签名的镜像。图15.15显示了如果您尝试使用Docker CLI和Universal Control Plane
    web UI拉取未签名镜像时会出现的错误（这两个示例都尝试拉取标记为“未签名”的镜像）
- en: '![Figure 15.15](images/figure15-15.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15](images/figure15-15.png)'
- en: Figure 15.15
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15
- en: Figure 15.16 shows how DCT prevents a Docker client from pulling an image that
    has been tampered with. Figure 15.17 shows DCT preventing a client pulling an
    image that is stale.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16显示了DCT如何阻止Docker客户端拉取被篡改的镜像。图15.17显示了DCT阻止客户端拉取过时镜像。
- en: '![Figure 15.16 Pulling an image that has been tampered with](images/figure15-16.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16拉取被篡改的镜像](images/figure15-16.png)'
- en: Figure 15.16 Pulling an image that has been tampered with
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16拉取被篡改的镜像
- en: '![Figure 15.17 Pulling a stale image](images/figure15-17.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图15.17拉取过时的镜像](images/figure15-17.png)'
- en: Figure 15.17 Pulling a stale image
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17拉取过时的镜像
- en: Docker Content Trust is an important technology for helping you verify the images
    you are pulling from Docker registries. It’s simple to configure in its basic
    form, but more advanced features, such as *context*, are currently more complex
    to configure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Content Trust是一个帮助您验证从Docker注册表中拉取的镜像的重要技术。它在基本形式上很容易配置，但更高级的功能，如*context*，目前配置起来更复杂。
- en: Docker Secrets
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker Secrets
- en: Many applications need secrets. Things like passwords, TLS certificates, SSH
    keys, and more.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要秘密。诸如密码、TLS证书、SSH密钥等。
- en: Prior to Docker 1.13, there was no standard way of making secrets available
    to apps in a secure way. It was common for developers to insert secrets into apps
    via plain text environment variables (we’ve all done it). This was far from ideal.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '在Docker 1.13之前，没有一种标准的方式以安全的方式向应用程序提供秘密。开发人员通常通过明文环境变量将秘密插入应用程序（我们都这样做过）。这远非理想。 '
- en: Docker 1.13 introduced *Docker Secrets*, effectively making secrets first-class
    citizens in the Docker ecosystem. For example, there is a whole new `docker secret`
    sub-command dedicated to managing secrets. There’s also a page for creating and
    managing secrets in the Docker Universal Control Plane UI. Behind the scenes,
    secrets are encrypted at rest, encrypted in-flight, mounted in in-memory filesystems,
    and operate under a least-privilege model where they are only made available to
    services that have been explicitly granted access to them. It’s quite a comprehensive
    end-to-end solution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 1.13引入了*Docker Secrets*，有效地使秘密成为Docker生态系统中的一等公民。例如，有一个全新的`docker secret`子命令专门用于管理秘密。Docker
    Universal Control Plane UI中还有一个页面用于创建和管理秘密。在幕后，秘密在静态时被加密，在传输时被加密，在内存文件系统中被挂载，并在最低特权模型下运行，只有明确授予对它们访问权限的服务才能使用它们。这是一个非常全面的端到端解决方案。
- en: 'Figure 15.18 shows a high-level workflow:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18显示了一个高级工作流程：
- en: '![Figure 15.18](images/figure15-18.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图15.18](images/figure15-18.png)'
- en: Figure 15.18
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18
- en: The following steps walk through the high-level workflow shown in Figure 15.18.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤介绍了图15.18中显示的高级工作流程。
- en: The blue secret is created and posted to the Swarm
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝色秘密被创建并发布到Swarm
- en: It gets stored in the encrypted cluster store (all managers have access to the
    cluster store)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它被存储在加密的集群存储中（所有管理者都可以访问集群存储）
- en: The blue service is created and the secret is attached to it
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝色服务已创建，并且秘密已附加到其中
- en: The secret is encrypted in-flight while it is delivered to the tasks (containers)
    in the blue service
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密在传递到蓝色服务中的任务（容器）时进行了加密
- en: The secret is mounted into the containers of the blue service as an unencrypted
    file at `/run/secrets/`. This is an in-memory tmpfs filesystem (this step is different
    on Windows Docker hosts as they do not have the notion of an in-memory filesystem
    like tmpfs)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密被挂载到蓝色服务的容器中，作为一个未加密的文件在`/run/secrets/`。这是一个内存中的tmpfs文件系统（在Windows Docker主机上，这一步与tmpfs不同，因为它们没有内存文件系统的概念）
- en: Once the container (service task) completes, the in-memory filesystem is torn
    down and the secret flushed from the node.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器（服务任务）完成，内存文件系统将被销毁，并且秘密将从节点中清除。
- en: The red containers in the red service cannot access the secret.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红色服务中的红色容器无法访问秘密。
- en: You can create and manage secrets with the `docker secret` sub-command, and
    you can attach them to services by specifying the `--secret` flag to the `docker
    service create` command.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker secret`子命令创建和管理秘密，并通过在`docker service create`命令中指定`--secret`标志来将它们附加到服务。
- en: Chapter Summary
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节总结
- en: Docker can be configured to be extremely secure. It supports all of the major
    Linux security technologies, including; kernel namespaces, cgroups, capabilities,
    MAC, and seccomp. It ships with sensible defaults for all of these, but you can
    customize them and even disable them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以配置为非常安全。它支持所有主要的Linux安全技术，包括：内核命名空间、cgroups、capabilities、MAC和seccomp。它为所有这些提供了合理的默认值，但您可以自定义它们甚至禁用它们。
- en: Over and above the general Linux security technologies, the Docker platform
    includes an extensive set of its own security technologies. Swarm Mode is built
    on TLS and is insanely simple to configure and customize. Security Scanning performs
    binary-level scans of Docker images and provides detailed reports of known vulnerabilities.
    Docker Content Trust lets you sign and verify content, and secrets are now first-class
    citizens in Docker.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一般的Linux安全技术之外，Docker平台还包括一套自己的安全技术。Swarm Mode建立在TLS之上，配置和定制非常简单。安全扫描对Docker镜像进行二进制级别的扫描，并提供已知漏洞的详细报告。Docker内容信任允许您签署和验证内容，而秘密现在是Docker中的一等公民。
- en: The net result is that your Docker environment can be configured to be as secure
    or insecure as you desire — it all depends on how you configure it.[PRE13]
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，您的Docker环境可以根据您的需求配置为安全或不安全 —— 这完全取决于您如何配置它。[PRE13]
