- en: '*Chapter 1*: Understanding Kubernetes and Helm'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：理解Kubernetes和Helm'
- en: Thank you for choosing this book, Learn Helm. If you are interested in this
    book, you are probably aware of the challenges that modern applications bring.
    Teams face tremendous pressure to ensure that applications are lightweight and
    scalable. Applications must also be highly available and able to withstand varying
    loads. Historically, applications have most commonly been deployed as monoliths,
    or large, single-tiered applications served on a single system. As time has progressed,
    the industry has shifted toward a microservice approach, or toward small, multi-tiered
    applications served on multiple systems. Often deployed using container technology,
    the industry has started leveraging tools such as Kubernetes to orchestrate and
    scale their containerized microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您选择了本书《学习Helm》。如果您对本书感兴趣，您可能已经意识到现代应用程序带来的挑战。团队面临巨大的压力，确保应用程序轻量且可扩展。应用程序还必须具有高可用性，并能承受不同的负载。在历史上，应用程序通常被部署为单体应用，或者在单个系统上提供的大型单层应用。随着时间的推移，行业已经转向了微服务方法，或者转向了在多个系统上提供的小型多层应用。行业通常使用容器技术进行部署，开始利用诸如Kubernetes之类的工具来编排和扩展其容器化的微服务。
- en: Kubernetes, however, comes with its own set of challenges. While it is an effective
    container orchestration tool, it presents a steep learning curve that can be difficult
    for teams to overcome. One tool that helps simplify the challenges of running
    workloads on Kubernetes is Helm. Helm allows users to more simply deploy and manage
    the life cycle of Kubernetes applications. It abstracts many of the complexities
    behind configuring Kubernetes applications and allows teams to be more productive
    on the platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes也带来了自己的一系列挑战。虽然它是一个有效的容器编排工具，但它提供了一个陡峭的学习曲线，对团队来说可能很难克服。一个帮助简化在Kubernetes上运行工作负载挑战的工具是Helm。Helm允许用户更简单地部署和管理Kubernetes应用程序的生命周期。它抽象了许多配置Kubernetes应用程序的复杂性，并允许团队在平台上更加高效地工作。
- en: In this book, you will explore each of the benefits offered by Helm and discover
    how Helm makes application deployments much simpler on Kubernetes. You will first
    assume the role of an end user, consuming Helm charts written by the community
    and learning the best practices behind leveraging Helm as a package manager. As
    this book progresses, you will assume the role of a Helm chart developer and learn
    how to package Kubernetes applications in ways that are easily consumable and
    efficient. Toward the end of this book, you'll learn about advanced patterns around
    application management and security with Helm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将探索Helm提供的每个好处，并了解Helm如何使在Kubernetes上部署应用程序变得更简单。您将首先扮演终端用户的角色，使用社区编写的Helm图表，并学习利用Helm作为软件包管理器的最佳实践。随着本书的进展，您将扮演Helm图表开发人员的角色，并学习如何以易于消费和高效的方式打包Kubernetes应用程序。在本书的最后，您将了解关于应用程序管理和安全性的高级模式。
- en: 'Let''s begin by first understanding microservices, containers, Kubernetes,
    and the challenges that these bring with regards to application deployment. Then,
    we will discuss the key features and benefits of Helm. In this chapter, we will
    cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解微服务、容器、Kubernetes以及这些方面对应用程序部署带来的挑战。然后，我们将讨论Helm的主要特点和好处。在本章中，我们将涵盖以下主要主题：
- en: Monoliths, microservices, and containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用、微服务和容器
- en: An overview of Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes概述
- en: How Kubernetes applications are deployed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes应用的部署方式
- en: Challenges in configuring Kubernetes resources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Kubernetes资源的挑战
- en: Benefits that Helm provides to simplify life application deployments on Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm提供的简化在Kubernetes上部署应用程序的好处
- en: From monoliths to modern microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体应用到现代微服务
- en: Software applications are a foundational component of most modern technology.
    Whether they take the form of a word processor, web browser, or media player,
    they enable user interaction to complete one or more tasks. Applications have
    a long and storied history, from the days of ENIAC—the first general-purpose computer—to
    taking man to the moon in the Apollo space missions, to the rise of the World
    Wide Web, social media, and online retail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序是大多数现代技术的基础组成部分。无论它们是以文字处理器、网络浏览器还是媒体播放器的形式出现，它们都能够使用户进行交互以完成一个或多个任务。应用程序有着悠久而传奇的历史，从第一台通用计算机ENIAC的时代，到阿波罗太空任务将人类送上月球，再到互联网、社交媒体和在线零售的兴起。
- en: These applications can operate on a wide range of platforms and system. We said
    in most cases they run on virtual or physical resources, but aren't these technically
    the only options? Depending on their purpose and resource requirements, entire
    machines may be dedicated to serving the compute and/or storage needs of an application.
    Fortunately, thanks in part to the realization of Moore's law, the power and performance
    of microprocessors initially increased with each passing year, along with the
    overall cost associated with the physical resources. This trend has subsided in
    recent years, but the advent of this trend and its persistence for the first 30
    years of the existence of processors was instrumental to the advances in technology.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序可以在各种平台和系统上运行。我们说在大多数情况下它们在虚拟或物理资源上运行，但这难道是唯一的选择吗？根据它们的目的和资源需求，整个机器可能会被专门用来满足应用程序的计算和/或存储需求。幸运的是，部分归功于摩尔定律的实现，微处理器的功率和性能最初每年都在增加，同时与物理资源相关的整体成本也在增加。这一趋势在最近几年有所减弱，但这一趋势的出现以及在处理器存在的前30年中的持续对技术的进步起着关键作用。
- en: Software developers took full advantage of this opportunity and bundled more
    features and components in their applications. As a result, a single application
    could consist of several smaller components, each of which, on their own, could
    be written as their own individual services. Initially, bundling components together
    yielded several benefits, including a simplified deployment process. However,
    as industry trends began to change and businesses focused more on the ability
    to deliver features more rapidly, the design of a single deployable application
    brought with it a number of challenges. Whenever a change was required, the entire
    application and all of its underlying components needed to be validated once again
    to ensure the change had no adverse features. This process potentially required
    coordination from multiple teams, which slowed the overall delivery of the feature.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员充分利用了这一机会，在他们的应用程序中捆绑了更多的功能和组件。因此，一个单一的应用程序可能由几个较小的组件组成，每个组件本身都可以被编写为它们自己的独立服务。最初，捆绑组件在一起带来了几个好处，包括简化的部署过程。然而，随着行业趋势的改变，企业更加关注能够更快地交付功能，一个可部署的单一应用程序的设计也带来了许多挑战。每当需要进行更改时，整个应用程序及其所有基础组件都需要再次验证，以确保更改没有不利的特性。这个过程可能需要多个团队的协调，从而减慢了功能的整体交付速度。
- en: Delivering features more rapidly, especially across traditional divisions within
    organizations, was also something that organizations wanted. This concept of rapid
    delivery is fundamental to a practice called DevOps, whose rise in popularity
    occurred around the year 2010\. DevOps encouraged more iterative changes to applications
    over time, instead of extensive planning prior to development. In order to be
    sustainable in this new model, architectures evolved from being a single large
    application to instead favoring several smaller applications that can be delivered
    faster. Because of this change in thinking, the more traditional application design
    was labeled as **monolithic**. This new approach of breaking components down into
    separate applications coined the name for these components as **microservices**.
    The traits that were inherent in microservice applications brought with them several
    desirable features, including the ability to develop and deploy services concurrently
    from one another as well as to scale (increase the number of instances) them independently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更快地交付功能，特别是跨组织内的传统部门，也是组织所期望的。这种快速交付的概念是DevOps实践的基础，其在2010年左右开始流行起来。DevOps鼓励对应用程序进行更多的迭代更改，而不是在开发之前进行广泛的规划。为了在这种新模式下可持续发展，架构从单一的大型应用程序发展为更青睐能够更快交付的几个较小的应用程序。由于这种思维方式的改变，更传统的应用程序设计被标记为“单片”。将组件分解为单独的应用程序的这种新方法被称为“微服务”。微服务应用程序固有的特征带来了一些理想的特性，包括能够同时开发和部署服务，以及独立扩展（增加实例数量）。
- en: The change in software architecture from monolithic to microservices also resulted
    in re-evaluating how applications are packaged and deployed at runtime. Traditionally,
    entire machines were dedicated to either one or two applications. Now, as microservices
    resulted in the overall reduction of resources required for a single application,
    dedicating an entire machine to one or two microservices was no longer viable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构从单片到微服务的变化也导致重新评估应用程序在运行时的打包和部署方式。传统上，整个机器都专门用于一个或两个应用程序。现在，由于微服务导致单个应用程序所需资源的总体减少，将整个机器专门用于一个或两个微服务已不再可行。
- en: Fortunately, a technology called **containers** was introduced and gained popularity
    for filling in the gaps for many missing features needed to create a microservices
    runtime environment. Red Hat defines a container as 'a set of one or more processes
    that are isolated from the rest of the system and includes all of the files necessary
    to run' (https://www.redhat.com/en/topics/containers/whats-a-linux-container).
    Containerized technology has a long history in computing, dating back to the 1970s.
    Many of the foundational container technologies, including **chroot** (the ability
    to change the root directory of a process and any of its children to a new location
    on the filesystem) and **jails**, are still in use today.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一种名为“容器”的技术被引入并因填补许多缺失的功能而受到欢迎，以创建微服务运行时环境。Red Hat将容器定义为“一组与系统其余部分隔离的一个或多个进程，并包括运行所需的所有文件”（https://www.redhat.com/en/topics/containers/whats-a-linux-container）。容器化技术在计算机领域有着悠久的历史，可以追溯到20世纪70年代。许多基础容器技术，包括chroot（能够更改进程和其任何子进程的根目录到文件系统上的新位置）和jails，今天仍在使用中。
- en: The combination of a simple and portable packaging model, along with the ability
    to create many isolated sandboxes on each physical or virtual machine, led to
    the rapid adoption of containers in the microservices space. This rise in container
    popularity in the mid-2010s can also be attributed to Docker, which brought containers
    to the masses through simplified packaging and a runtime that could be utilized
    on Linux, macOS, and Windows. The ability to distribute container images with
    ease led to the increase in popularity of container technologies. This was because
    first-time users did not need to know how to create images but instead could make
    use of existing images that were created by others.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单且便携的打包模型，以及在每台物理或虚拟机上创建许多隔离的沙盒的能力的结合，导致了微服务领域容器的快速采用。2010年代中期容器流行的上升也可以归因于Docker，它通过简化的打包和可以在Linux、macOS和Windows上使用的运行时将容器带给了大众。轻松分发容器镜像的能力导致了容器技术的流行增加。这是因为首次用户不需要知道如何创建镜像，而是可以利用其他人创建的现有镜像。
- en: Containers and microservices became a match made in heaven. Applications had
    a packaging and distribution mechanism, along with the ability to share the same
    compute footprint while taking advantage of being isolated from one another. However,
    as more and more containerized microservices were deployed, the overall management
    became a concern. How do you ensure the health of each running container? What
    do you do if a container fails? What happens if your 0my underlying machine does
    not have the compute capacity required? Enter Kubernetes, which helped answer
    this need for container orchestration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务成为了天作之合。应用程序具有打包和分发机制，以及共享相同计算占用的能力，同时又能够从彼此隔离。然而，随着越来越多的容器化微服务被部署，整体管理成为了一个问题。你如何确保每个运行的容器的健康？如果一个容器失败了怎么办？如果你的底层机器没有所需的计算能力会发生什么？于是Kubernetes应运而生，它帮助解决了容器编排的需求。
- en: In the next section, we will discuss how Kubernetes works and provides value
    to an enterprise.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Kubernetes的工作原理以及它为企业提供的价值。
- en: What is Kubernetes?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Kubernetes？
- en: Kubernetes, often abbreviated as **k8s** (pronounced as **kaytes**), is an open
    source container orchestration platform. Originating from Google's proprietary
    orchestration tool, Borg, the project was open sourced in 2015 and was renamed
    Kubernetes. Following the v1.0 release on July 21, 2015, Google and the Linux
    Foundation partnered to form the **Cloud Native Computing Foundation** (**CNCF**),
    which acts as the current maintainer of the Kubernetes project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes，通常缩写为**k8s**（发音为**kaytes**），是一个开源的容器编排平台。起源于谷歌的专有编排工具Borg，该项目于2015年开源并更名为Kubernetes。在2015年7月21日发布v1.0版本后，谷歌和Linux基金会合作成立了**云原生计算基金会**（**CNCF**），该基金会目前是Kubernetes项目的维护者。
- en: The word Kubernetes is a Greek word meaning 'helmsman' or 'pilot'. A helmsman
    is the person who is in charge of steering a ship and works closely with the ship's
    officer to ensure a safe and steady course, along with the overall safety of the
    crew. Kubernetes has similar responsibilities with regards to containers and microservices.
    Kubernetes is in charge of the orchestration and scheduling of containers. It
    is in charge of 'steering' those containers to proper worker nodes that can handle
    their workloads. Kubernetes will also help ensure the safety of those microservices
    by providing high availability and health checks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes这个词是希腊词，意思是“舵手”或“飞行员”。舵手是负责操纵船只并与船员紧密合作以确保航行安全和稳定的人。Kubernetes对于容器和微服务有类似的责任。Kubernetes负责容器的编排和调度。它负责“操纵”这些容器到能够处理它们工作负载的工作节点。Kubernetes还将通过提供高可用性和健康检查来确保这些微服务的安全。
- en: Let's review some of the ways Kubernetes helps simplify the management of containerized
    workloads.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些 Kubernetes 如何帮助简化容器化工作负载管理的方式。
- en: Container Orchestration
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排
- en: The most prominent feature of Kubernetes is container orchestration. This is
    a fairly loaded term, so we'll break it down into different pieces.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最突出的特性是容器编排。这是一个相当复杂的术语，因此我们将其分解为不同的部分。
- en: 'Container orchestration is about placing containers on certain machines from
    a pool of compute resources based on their requirements. The simplest use case
    for container orchestration is for deploying containers on machines that can handle
    their resource requirements. In the following diagram, there is an application
    that requests 2 Gi of memory (Kubernetes resource requests typically use their
    ''power of two'' values, which in this case is roughly equivalent to 2 GB) and
    one CPU core. This means that the container will be allocated 2 Gi of memory and
    1 CPU core from the underlying machine that it is scheduled on. It is up to Kubernetes
    to track which machines, which in this case are called nodes, have the required
    resources available and to place an incoming container on that machine. If a node
    does not have enough resources to satisfy the request, the container will not
    be scheduled on that node. If all of the nodes in a cluster do not have enough
    resources to run the workload, the container will not be deployed. Once a node
    has enough resources free, the container will be deployed on the node with sufficient
    resources:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排是指根据容器的需求，将其放置在计算资源池中的特定机器上。容器编排的最简单用例是在可以处理其资源需求的机器上部署容器。在下图中，有一个应用程序请求2
    Gi内存（Kubernetes资源请求通常使用它们的“二的幂”值，在本例中大致相当于2 GB）和一个CPU核心。这意味着容器将从底层机器上分配2 Gi内存和1个CPU核心。Kubernetes负责跟踪具有所需资源的机器（在本例中称为节点），并将传入的容器放置在该机器上。如果节点没有足够的资源来满足请求，容器将不会被调度到该节点上。如果集群中的所有节点都没有足够的资源来运行工作负载，容器将不会被部署。一旦节点有足够的空闲资源，容器将被部署在具有足够资源的节点上：
- en: '![Figure 1.1: Kubernetes orchestration and scheduling'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：Kubernetes编排和调度'
- en: '](image/Figure_1.1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.1.jpg)'
- en: Figure 1.1 - Kubernetes orchestration and scheduling
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - Kubernetes编排和调度
- en: Container orchestration relieves you of putting in the effort to track the available
    resources on machines at all times. Kubernetes and other monitoring tools provide
    insight into these metrics. So, a day-to-day developer does not need to worry
    about available resources. A developer can simply declare the amount of resources
    they expect a container to use and Kubernetes will take care of the rest on the
    backend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排使您不必一直努力跟踪机器上的可用资源。Kubernetes和其他监控工具提供了对这些指标的洞察。因此，日常开发人员不需要担心可用资源。开发人员只需声明他们期望容器使用的资源量，Kubernetes将在后台处理其余部分。
- en: High availability
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高可用性
- en: Another benefit of Kubernetes is that it provides features that help take care
    of redundancy and high availability. High availability is a characteristic that
    prevents application downtime. It's performed by a load balancer, which splits
    incoming traffic across multiple instances of an application. The premise of high
    availability is that if one instance of an application goes down, other instances
    are still available to accept incoming traffic. In this regard, downtime is avoided
    and the end user, whether a human or another microservice, remains completely
    unaware that there was a failed instance of the application. Kubernetes provides
    a networking mechanism, called a Service, that allows applications to be load
    balanced. We will talk about Services in greater detail later on in the *Deploying
    a Kubernetes application* section of this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的另一个好处是它提供了帮助处理冗余和高可用性的功能。高可用性是防止应用程序停机的特性。它是由负载均衡器执行的，它将传入的流量分配到应用程序的多个实例中。高可用性的前提是，如果一个应用程序实例出现故障，其他实例仍然可以接受传入的流量。在这方面，避免了停机时间，最终用户，无论是人类还是另一个微服务，都完全不知道应用程序出现了故障实例。Kubernetes提供了一种名为Service的网络机制，允许应用程序进行负载均衡。我们将在本章的*部署Kubernetes应用程序*部分更详细地讨论服务。
- en: Scalability
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Given the lightweight nature of containers and microservices, developers can
    use Kubernetes to rapidly scale their workloads, both horizontally and vertically.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于容器和微服务的轻量化特性，开发人员可以使用Kubernetes快速扩展他们的工作负载，无论是水平还是垂直方向。
- en: Horizontal scaling is the act of deploying more container instances. If a team
    running their workloads on Kubernetes were expecting increased load, they could
    simply tell Kubernetes to deploy more instances of their application. Since Kubernetes
    is a container orchestrator, developers would not need to worry about the physical
    infrastructure that those applications would be deployed on. It would simply locate
    a node within the cluster with the available resources and deploy the additional
    instances there. Each extra instance would be added to a load-balancing pool,
    which would allow the application to continue to be highly available.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展是部署更多容器实例的行为。如果一个团队在Kubernetes上运行他们的工作负载，并且预期负载会增加，他们可以简单地告诉Kubernetes部署更多他们的应用实例。由于Kubernetes是一个容器编排器，开发人员不需要担心这些应用将部署在哪些物理基础设施上。它会简单地在集群中找到一个具有可用资源的节点，并在那里部署额外的实例。每个额外的实例都将被添加到一个负载均衡池中，这将允许应用程序继续保持高可用性。
- en: Vertical scaling is the act of allocating additional memory and CPU to an application.
    Developers can modify the resource requirements of their applications while they
    are running. This will prompt Kubernetes to redeploy the running instances and
    reschedule them on nodes that can support the new resource requirements. Depending
    on how this is configured, Kubernetes can redeploy each instance in a way that
    prevents downtime while the new instances are being deployed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展是为应用程序分配额外的内存和CPU的行为。开发人员可以在应用程序运行时修改其资源需求。这将促使Kubernetes重新部署运行实例，并将它们重新调度到可以支持新资源需求的节点上。根据配置方式的不同，Kubernetes可以以一种防止新实例部署期间停机的方式重新部署每个实例。
- en: Active community
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃的社区
- en: The Kubernetes community is an incredibly active open source community. As a
    result, Kubernetes frequently receives patches and new features. The community
    has also made many contributions to documentation, both to the official Kubernetes
    documentation as well as to professional or hobbyist blog websites. In addition
    to documentation, the community is highly involved in planning and attending meetups
    and conferences around the world, which helps increase education and innovation
    of the platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes社区是一个非常活跃的开源社区。因此，Kubernetes经常收到补丁和新功能。社区还为官方Kubernetes文档以及专业或业余博客网站做出了许多贡献。除了文档，社区还积极参与全球各地的聚会和会议的策划和参与，这有助于增加平台的教育和创新。
- en: Another benefit of Kubernetes's large community is the number of different tools
    built to augment the abilities that are provided. Helm is one of those tools.
    As we'll see later in this chapter and throughout this book, Helm—a tool built
    by members of the Kubernetes community—vastly improves a developer's experience
    by simplifying application deployments and life cycle management.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes庞大的社区带来的另一个好处是构建了许多不同的工具来增强所提供的能力。Helm就是其中之一。正如我们将在本章后面和整本书中看到的，Helm是Kubernetes社区成员开发的一个工具，通过简化应用程序部署和生命周期管理，大大改善了开发人员的体验。
- en: With an understanding of the benefits Kubernetes brings to managing containerized
    workloads, let's now discuss how an application can be deployed in Kubernetes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了Kubernetes为管理容器化工作负载带来的好处，现在让我们讨论一下如何在Kubernetes中部署应用程序。
- en: Deploying a Kubernetes application
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Kubernetes应用程序
- en: 'Deploying an application on Kubernetes is fundamentally similar to deploying
    an application outside of Kubernetes. All applications, whether containerized
    or not, must have configuration details around topics that include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署应用程序基本上与在Kubernetes之外部署应用程序类似。所有应用程序，无论是容器化还是非容器化，都必须具有围绕以下主题的配置细节：
- en: Networking
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络连接
- en: Persistent storage and file mounts
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久存储和文件挂载
- en: Availability and redundancy
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性和冗余
- en: Application configuration
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: Security
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Configuring these details on Kubernetes is done by interacting with the Kubernetes
    **application programming interface** (**API**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上配置这些细节是通过与Kubernetes的**应用程序编程接口**（**API**）进行交互来完成的。
- en: The Kubernetes API serves as a set of endpoints that can be interacted with
    to view, modify, or delete different Kubernetes resources, many of which are used
    to configure different details of an application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API充当一组端点，可以与之交互以查看、修改或删除不同的Kubernetes资源，其中许多用于配置应用程序的不同细节。
- en: Let's discuss some of the basic API endpoints users can interact with to deploy
    and configure an application on Kubernetes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些基本的API端点，用户可以与之交互，以在Kubernetes上部署和配置应用程序。
- en: Deployment
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: The first Kubernetes resource we will explore is called a Deployment. Deployments
    determine the basic details required to deploy an application on Kubernetes. One
    of these basic details consists of the container image that Kubernetes should
    deploy. Container images can be built on local workstations using tools such as
    `docker`, and `jib` but images can also be built right on Kubernetes using `kaniko`.
    Because Kubernetes does not expose a native API endpoint for building container
    images, we will not go into detail about how a container image is built prior
    to configuring a Deployment resource.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一个Kubernetes资源称为部署。部署确定了在Kubernetes上部署应用程序所需的基本细节。其中一个基本细节包括Kubernetes应该部署的容器映像。容器映像可以在本地工作站上使用诸如`docker`和`jib`之类的工具构建，但也可以直接在Kubernetes上使用`kaniko`构建。因为Kubernetes不公开用于构建容器映像的本机API端点，所以我们不会详细介绍在配置部署资源之前如何构建容器映像。
- en: In addition to specifying the container image, Deployments also specify the
    number of replicas, or instances, of an application to deploy. When a Deployment
    is created, it spawns an intermediate resource, called a ReplicaSet. The ReplicaSet
    deploys as many instances of the application as determined by the `replicas` field
    on the Deployment. The application is deployed inside a container, which itself
    is deployed inside a construct called a Pod. A Pod is the smallest unit in Kubernetes
    and encapsulates at least one container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定容器映像外，部署还指定要部署的应用程序的副本数或实例数。创建部署时，它会生成一个中间资源，称为副本集。副本集部署应用程序的实例数量由部署上的`replicas`字段确定。应用程序部署在一个容器内，容器本身部署在一个称为Pod的构造内。Pod是Kubernetes中的最小单位，至少封装一个容器。
- en: 'Deployments can additionally define an application''s resource limits, health
    checks, and volume mounts. When a Deployment is created, Kubernetes creates the
    following architecture:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还可以定义应用程序的资源限制、健康检查和卷挂载。创建部署时，Kubernetes创建以下架构：
- en: '![Figure 1.2: A deployment creates a set of Pods'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：部署创建一组Pod'
- en: '](image/Figure_1.2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.2.jpg)'
- en: Figure 1.2 - A Deployment creates a set of Pods
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 部署创建一组Pod
- en: Another basic API endpoint in Kubernetes is used to create Service resources,
    which we will discuss next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的另一个基本API端点用于创建服务资源，我们将在下面讨论。
- en: Services
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: While Deployments are used to deploy an application to Kubernetes, they do not
    configure the networking components that allow an application to be communicated
    with Kubernetes exposes a separate API endpoint used to define the networking
    layer, called a Service. Services allow users and other applications to talk to
    each other by allocating a static IP address to a Service endpoint. The Service
    endpoint can then be configured to route traffic to one or more application instances.
    This kind of configuration provides load balancing and high availability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然部署用于将应用程序部署到Kubernetes，但它们不配置允许应用程序与Kubernetes通信的网络组件，Kubernetes公开了一个用于定义网络层的单独API端点，称为服务。服务允许用户和其他应用程序通过为服务端点分配静态IP地址来相互通信。然后可以配置服务端点以将流量路由到一个或多个应用程序实例。这种配置提供了负载平衡和高可用性。
- en: 'An example architecture using a Service is described in the following diagram.
    Notice that the Service sits in between the client and the Pods to provide load
    balancing and high availability:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用服务的示例架构在下图中描述。请注意，服务位于客户端和Pod之间，以提供负载平衡和高可用性：
- en: '![Figure 1.3: A Service load balancing an incoming request'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：服务负载平衡传入请求'
- en: '](image/Figure_1.3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.3.jpg)'
- en: Figure 1.3 - A Service load balancing an incoming request
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - 服务负载平衡传入请求
- en: As a final example, we will discuss the `PersistentVolumeClaim` API endpoint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，我们将讨论`PersistentVolumeClaim` API端点。
- en: PersistentVolumeClaim
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PersistentVolumeClaim
- en: Microservice-style applications embrace being self-sufficient by maintaining
    their state in an ephemeral manner. However, there are numerous use cases where
    data must live beyond the life span of a single container. Kubernetes addresses
    this issue by providing a subsystem for abstracting the underlying details of
    how storage is provided and how it is consumed. To allocate persistent storage
    for their application, users can create a `PersistentVolumeClaim` endpoint, which
    specifies the type and amount of storage that is desired. Kubernetes administrators
    are responsible for either statically allocating storage, expressed as `PersistentVolume`,
    or dynamically provisioning storage using `StorageClass`, which allocates `PersistentVolume`
    in response to a `PersistentVolumeClaim` endpoint. `PersistentVolume` captures
    all of the necessary storage details, including the type (such as network file
    system [NFS], internet small computer systems interface [iSCSI], or from a cloud
    provider), along with the size of the storage. From a user's perspective, regardless
    of which method of the `PersistentVolume` allocation method or storage backend
    that is used within the cluster, they do not need to manage the underlying details
    of managing storage. The ability to leverage persistent storage within Kubernetes
    increases the number of potential applications that can be deployed on the platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务风格的应用程序通过以临时方式维护其状态来实现自给自足。然而，存在许多情况，数据必须存在于单个容器的寿命之外。Kubernetes通过提供一个用于抽象存储提供和消耗方式的子系统来解决这个问题。为了为他们的应用程序分配持久存储，用户可以创建一个`PersistentVolumeClaim`端点，该端点指定所需存储的类型和数量。Kubernetes管理员负责静态分配存储，表示为`PersistentVolume`，或使用`StorageClass`动态配置存储，该存储类根据`PersistentVolumeClaim`端点分配`PersistentVolume`。`PersistentVolume`包含所有必要的存储细节，包括类型（如网络文件系统[NFS]、互联网小型计算机系统接口[iSCSI]或来自云提供商）以及存储的大小。从用户的角度来看，无论在集群中使用`PersistentVolume`分配方法或存储后端的哪种方法，他们都不需要管理存储的底层细节。在Kubernetes中利用持久存储的能力增加了可以在平台上部署的潜在应用程序的数量。
- en: 'An example of persistent storage being provisioned is depicted in the following
    diagram. The diagram assumes that an administrator has configured dynamic provisioning
    via `StorageClass`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了持久存储的一个例子。该图假定管理员已通过`StorageClass`配置了动态配置：
- en: '![Figure 1.4: A Pod mounting PersistentVolume created by PersistentVolumeClaim'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：由PersistentVolumeClaim创建的Pod挂载PersistentVolume'
- en: '](image/Figure_1.4.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.4.jpg)'
- en: Figure 1.4 - A Pod mounting PersistentVolume created by PersistentVolumeClaim
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - 由PersistentVolumeClaim创建的Pod挂载的PersistentVolume。
- en: There are many more resources in Kubernetes, but by now, you have probably got
    the picture. The question now is how are these resources actually created?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中有更多的资源，但到目前为止，你可能已经有了一个大致的了解。现在的问题是这些资源实际上是如何创建的？
- en: We will explore this question further in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节进一步探讨这个问题。
- en: Approaches in resource management
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理的方法
- en: In order to deploy an application on Kubernetes, we need to interact with the
    Kubernetes API to create resources. `kubectl` is the tool we use to talk to the
    Kubernetes API. `kubectl` is a **command-line interface** (**CLI**) tool used
    to abstract the complexity of the Kubernetes API from end users, allowing them
    to more efficiently work on the platform.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kubernetes上部署应用程序，我们需要与Kubernetes API交互以创建资源。 `kubectl`是我们用来与Kubernetes API交互的工具。
    `kubectl`是一个用于将Kubernetes API的复杂性抽象化的命令行接口（CLI）工具，允许最终用户更有效地在平台上工作。
- en: Let's discuss how `kubectl` can be used to manage Kubernetes resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下如何使用 `kubectl` 来管理 Kubernetes 资源。
- en: Imperative and declarative configuration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式和声明式配置
- en: 'The `kubectl` tool provides a series of subcommands to create and modify resources
    in an imperative fashion. The following is a small list of these commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 工具提供了一系列子命令，以命令式方式创建和修改资源。以下是这些命令的一个小列表：'
- en: '`create`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`'
- en: '`describe`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`'
- en: '`edit`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit`'
- en: '`delete`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: 'The `kubectl` commands follow a common format:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令遵循一个常见的格式：'
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The verb refers to one of the `kubectl` subcommands and the noun refers to
    a particular Kubernetes resource. For example, the following command can be run
    to create a Deployment:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动词指的是 `kubectl` 的子命令之一，名词指的是特定的 Kubernetes 资源。例如，可以运行以下命令来创建一个部署：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would instruct `kubectl` to talk to the Deployment API and create a new
    Deployment called `my-deployment`, using the `busybox` image from Docker Hub.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示 `kubectl` 与部署 API 对话，并使用来自 Docker Hub 的 `busybox` 镜像创建一个名为 `my-deployment`
    的新部署。
- en: 'You could use `kubectl` to get more information on the Deployment that was
    created by using the `describe` subcommand:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl` 获取有关使用 `describe` 子命令创建的部署的更多信息：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command would retrieve information about the Deployment and format the
    result in a readable format that allows developers to inspect the live `my-deployment`
    Deployment on Kubernetes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将检索有关部署的信息，并以可读格式格式化结果，使开发人员可以检查 Kubernetes 上的实时 `my-deployment` 部署。
- en: 'If a change to the Deployment was desired, a developer could use the `edit`
    subcommand to modify it in place:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对部署进行更改，开发人员可以使用 `edit` 子命令在原地修改它：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command would open a text editor, allowing you to modify the Deployment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打开一个文本编辑器，允许您修改部署。
- en: 'When it comes to deleting the resource, the user can run the `delete` subcommand:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除资源时，用户可以运行 `delete` 子命令：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would instruct the API to delete the Deployment called `my-deployment`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示 API 删除名为 `my-deployment` 的部署。
- en: 'Kubernetes resources, once created, exist in the cluster as JSON resource files,
    which can be exported as YAML files for greater human readability. An example
    resource in YAML format can be seen here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，Kubernetes 资源将作为 JSON 资源文件存在于集群中，可以将其导出为 YAML 文件以获得更大的人类可读性。可以在此处看到 YAML
    格式的示例资源：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding YAML format presents a very basic use case. It deploys the `busybox`
    image from Docker Hub and runs the `sleep` command indefinitely to keep the Pod
    running.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 YAML 格式呈现了一个非常基本的用例。它部署了来自 Docker Hub 的 `busybox` 镜像，并无限期地运行 `sleep` 命令以保持
    Pod 运行。
- en: While it may be easier to create resources imperatively using the `kubectl`
    subcommands we have just described, Kubernetes allows you to directly manage the
    YAML resources in a declarative fashion to gain more control over resource creation.
    The `kubectl` subcommands do not always let you configure all the possible resource
    options, but creating the YAML files directly allows you to more flexibly create
    resources and fill in the gaps that the `kubectl` subcommands may contain.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用我们刚刚描述的 `kubectl` 子命令以命令式方式创建资源可能更容易，但 Kubernetes 允许您以声明式方式直接管理 YAML 资源，以获得对资源创建更多的控制。`kubectl`
    子命令并不总是让您配置所有可能的资源选项，但直接创建 YAML 文件允许您更灵活地创建资源并填补 `kubectl` 子命令可能包含的空白。
- en: When creating resources declaratively, users first write out the resource they
    want to create in YAML format. Next, they use the `kubectl` tool to apply the
    resource against the Kubernetes API. While in imperative configuration developers
    use `kubectl` subcommands to manage resources, declarative configuration relies
    primarily on only one subcommand—`apply`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式创建资源时，用户首先以YAML格式编写他们想要创建的资源。接下来，他们使用`kubectl`工具将资源应用于Kubernetes API。而在命令式配置中，开发人员使用`kubectl`子命令来管理资源，声明式配置主要依赖于一个子命令——`apply`。
- en: 'Declarative configuration often takes the following form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式配置通常采用以下形式：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command gives Kubernetes a YAML resource that contains a resource specification,
    although the JSON format can be used as well. Kubernetes infers the action to
    perform on resources (create or modify) based on whether or not they exist.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令为Kubernetes提供了一个包含资源规范的YAML资源，尽管也可以使用JSON格式。Kubernetes根据资源的存在与否来推断要执行的操作（创建或修改）。
- en: 'An application may be configured declaratively by following these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过以下步骤进行声明式配置：
- en: 'First, the user can create a file called `deployment.yaml` and provide a YAML-formatted
    specification for the deployment. We will use the same example as before:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用户可以创建一个名为`deployment.yaml`的文件，并提供部署的YAML格式规范。我们将使用与之前相同的示例：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Deployment can then be created with the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以使用以下命令创建部署：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Upon running this command, Kubernetes will attempt to create the Deployment
    in the way you specified.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kubernetes将尝试按照您指定的方式创建部署。
- en: 'If you wanted to make a change to the Deployment, say by changing the number
    of `replicas` to `2`, you would first modify the `deployment.yaml` file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要对部署进行更改，比如将`replicas`的数量更改为`2`，您首先需要修改`deployment.yaml`文件：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You would then apply the change with `kubectl apply`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用`kubectl apply`应用更改：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After running that command, Kubernetes would apply the provided Deployment declaration
    over the previously applied `deployment`. At this point, the application would
    scale up from a `replica` value of `1` to `2`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，Kubernetes将在先前应用的`deployment`上应用提供的部署声明。此时，应用程序将从`replica`值为`1`扩展到`2`。
- en: 'When it comes to deleting an application, the Kubernetes documentation actually
    recommends doing so in an imperative manner; that is, using the `delete` subcommand
    instead of `apply`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在删除应用程序时，Kubernetes文档实际上建议以命令式方式进行操作；也就是说，使用`delete`子命令而不是`apply`：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `delete` subcommand can be made more declarative by passing in the `-f`
    flag and a filename. This gives `kubectl` the name of the resource to delete that
    is declared in a specific file and it allows the developers to continue managing
    resources with declarative YAML files.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递`-f`标志和文件名，可以使`delete`子命令更具声明性。这样可以向`kubectl`提供在特定文件中声明的要删除的资源的名称，并允许开发人员继续使用声明性YAML文件管理资源。
- en: With an understanding of how Kubernetes resources are created, let's now discuss
    some of the challenges involved in resource configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了Kubernetes资源的创建方式，现在让我们讨论一下资源配置中涉及的一些挑战。
- en: Resource configuration challenges
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源配置挑战
- en: In the previous section, we covered how Kubernetes has two different configuration
    methods—imperative and declarative. One question to consider is what challenges
    do users need to be aware of when creating Kubernetes resources with imperative
    and declarative methodologies?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们介绍了Kubernetes有两种不同的配置方法——命令式和声明式。一个需要考虑的问题是，在使用命令式和声明式方法创建Kubernetes资源时，用户需要注意哪些挑战？
- en: Let's discuss some of the most common challenges.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些最常见的挑战。
- en: The many types of Kubernetes resources
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes资源的多种类型
- en: 'First of all, there are many, *many* different resources in Kubernetes. Here''s
    a short list of resources a developer should be aware of:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes中有许多*许多*不同的资源。以下是开发人员应该了解的资源的简短列表：
- en: Deployment
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: StatefulSet
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatefulSet
- en: Service
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Ingress
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口
- en: ConfigMap
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigMap
- en: Secret
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secret
- en: StorageClass
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StorageClass
- en: PersistentVolumeClaim
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PersistentVolumeClaim
- en: ServiceAccount
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: Role
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色
- en: RoleBinding
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RoleBinding
- en: Namespace
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Out of the box, deploying an application on Kubernetes is not as simple as pushing
    a big red button marked `Deploy`. Developers need to be able to determine which
    resources are required to deploy their application and they need to understand
    those resources at a deep enough level to be able to configure them appropriately.
    This requires a lot of knowledge of and training on the platform. While understanding
    and creating resources may already sound like a large hurdle, this is actually
    just the beginning of many different operational challenges.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署应用程序并不像按下标有“部署”的大红按钮那么简单。开发人员需要能够确定部署其应用程序所需的资源，并且需要深入了解这些资源，以便能够适当地配置它们。这需要对平台有很多的了解和培训。虽然理解和创建资源可能已经听起来像是一个很大的障碍，但实际上这只是许多不同操作挑战的开始。
- en: Keeping the live and local states in sync
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持活动和本地状态同步
- en: A method of configuring Kubernetes resources that we would encourage is to maintain
    their configuration in source control for teams to edit and share, which also
    allows the source control repository to become the source of truth. The configuration
    defined in source control (referred to as the 'local state') is then created by
    applying them to the Kubernetes environment and the resources become 'live' or
    enter what can be called the 'live state.' This sounds simple enough, but what
    happens when developers need to make changes to their resources? The proper answer
    would be to modify the local files and apply the changes to synchronize the local
    state to the live state in an effort to update the source of truth. However, this
    isn't what usually ends up happening. It is often simpler, in the short term,
    to modify the live resource in place with `kubectl patch` or `kubectl edit` and
    completely skip over modifying the local files. This results in a state inconsistency
    between local and live states and is an act that makes scaling on Kubernetes difficult.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励的一种配置Kubernetes资源的方法是将它们的配置保留在源代码控制中，供团队编辑和共享，这也使得源代码控制存储库成为真相的来源。在源代码控制中定义的配置（称为“本地状态”）然后通过将它们应用到Kubernetes环境中来创建，并且资源变为“活动”或进入可以称为“活动状态”的状态。这听起来很简单，但当开发人员需要对其资源进行更改时会发生什么？正确的答案应该是修改本地文件并应用更改，以将本地状态与活动状态同步，以更新真相的来源。然而，这通常不是最终发生的事情。在短期内，更改活动资源的位置通常更简单，而不是修改本地文件。这会导致本地和活动状态之间的状态不一致，并且使得在Kubernetes上扩展变得困难。
- en: Application life cycles are hard to manage
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序生命周期很难管理
- en: Life cycle management is a loaded term, but in this context, we'll refer to
    it as the concept of installing, upgrading, and rolling back applications. In
    the Kubernetes world, an installation would create resources to deploy and configure
    an application. The initial installation would create what we refer to here as
    `version 1` of an application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期管理是一个复杂的术语，但在这个上下文中，我们将把它称为安装、升级和回滚应用程序的概念。在Kubernetes世界中，安装会创建资源来部署和配置应用程序。初始安装将创建我们在这里称为应用程序的“版本1”。
- en: An upgrade, then, can be thought of as an edit or modification to one or many
    of those Kubernetes resources. Each `batch` of edits can be thought of as a single
    upgrade. A developer could modify a single Service resource, which would bump
    the version number to `version 2`. The developer could then modify a Deployment,
    a ConfigMap, and a Service, bumping the version count to `version 3`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，升级可以被视为对一个或多个Kubernetes资源的编辑或修改。每一批编辑可以被视为一个单独的升级。开发人员可以修改单个服务资源，将版本号提升到“版本2”。然后开发人员可以修改部署、配置映射和服务，将版本计数提升到“版本3”。
- en: As newer versions of an application continue to be rolled out onto Kubernetes,
    it becomes more difficult to keep track of the changes that have occurred. Kubernetes,
    in most cases, does not have an inherent way of keeping a history of changes.
    While this makes upgrades harder to keep track of, it also makes restoring a prior
    version of an application much more difficult. Say a developer previously made
    an incorrect edit on a particular resource. How would a team know where to roll
    back to? The `n-1` case is particularly easy to work out, as that is the most
    recent version. What happens, however, if the latest stable release was five versions
    ago? Teams often end up scrambling to resolve issues because they cannot quickly
    identify the latest stable configuration that worked previously.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的新版本继续部署到Kubernetes上，跟踪已发生的更改变得更加困难。在大多数情况下，Kubernetes没有固有的方式来记录更改的历史。虽然这使得升级更难以跟踪，但也使得恢复先前版本的应用程序变得更加困难。假设开发人员之前对特定资源进行了错误的编辑。团队如何知道要回滚到哪个版本？`n-1`情况特别容易解决，因为那是最近的版本。然而，如果最新的稳定版本是五个版本之前呢？团队经常因为无法快速识别先前有效的最新稳定配置而不得不匆忙解决问题。
- en: Resource files are static
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源文件是静态的。
- en: This is a challenge that primarily affects the declarative configuration style
    of applying YAML resources. Part of the difficulty in following a declarative
    approach is that Kubernetes resource files are not natively designed to be parameterized.
    Resource files are largely designed to be written out in full before being applied
    and the contents remain the source of truth until the file is modified. When dealing
    with Kubernetes, this can be a frustrating reality. Some API resources can be
    lengthy, containing many different customizable fields, and it can be quite cumbersome
    to write and configure YAML resources in full.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主要影响应用YAML资源的声明性配置风格的挑战。遵循声明性方法的困难部分在于，Kubernetes资源文件并非原生设计为可参数化。资源文件大多被设计为在应用之前完整地编写出来，并且内容保持不变，直到文件被修改。在处理Kubernetes时，这可能是一个令人沮丧的现实。一些API资源可能会很长，包含许多不同的可定制字段，因此完整地编写和配置YAML资源可能会非常繁琐。
- en: Static files lend themselves to becoming boilerplate. Boilerplate represents
    text or code that remains largely consistent in different but similar contexts.
    This becomes an issue if developers manage multiple different applications, where
    they could potentially manage multiple different Deployment resources, multiple
    different Services, and so on. In comparing the different applications' resource
    files, you may find large numbers of similar YAML configuration between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件很容易变成样板文件。样板文件代表在不同但相似的上下文中基本保持一致的文本或代码。如果开发人员管理多个不同的应用程序，可能需要管理多个不同的部署资源、多个不同的服务资源等。比较不同应用程序的资源文件时，可能会发现它们之间存在大量相似的YAML配置。
- en: 'The following figure depicts an example of two resources with significant boilerplate
    configuration between them. The blue text denotes lines that are boilerplate,
    while the red text denotes lines that are unique:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了两个资源之间具有重要样板配置的示例。蓝色文本表示样板行，而红色文本表示唯一行：
- en: '![Figure 1.5: An example of two resources with boilerplate'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：两个具有样板的资源示例'
- en: '](image/Figure_1.5.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.5.jpg)'
- en: Figure 1.5 - An example of two resources with boilerplate
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - 两个具有样板的资源示例
- en: Notice, in this example, that each file is almost exactly the same. When managing
    files that are as similar as this, boilerplate becomes a major headache for teams
    managing their applications in a declarative fashion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，每个文件几乎完全相同。当管理类似这样相似的文件时，样板变成了团队以声明方式管理其应用程序的主要头痛。
- en: Helm to the rescue!
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm来拯救！
- en: Over time, the Kubernetes community discovered that creating and maintaining
    Kubernetes resources to deploy applications is difficult. This prompted the development
    of a simple yet powerful tool that would allow teams to overcome the challenges
    posed by deploying applications on Kubernetes. The tool that was created is called
    Helm. Helm is an open source tool used for packaging and deploying applications
    on Kubernetes. It is often referred to as the **Kubernetes Package Manager** because
    of its similarities to any other package manager you would find on your favorite
    OS. Helm is widely used throughout the Kubernetes community and is a CNCF graduated
    project.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Kubernetes社区发现创建和维护用于部署应用程序的Kubernetes资源是困难的。这促使开发了一个简单而强大的工具，可以让团队克服在Kubernetes上部署应用程序时所面临的挑战。创建的工具称为Helm。Helm是一个用于在Kubernetes上打包和部署应用程序的开源工具。它通常被称为**Kubernetes软件包管理器**，因为它与您在喜爱的操作系统上找到的任何其他软件包管理器非常相似。Helm在整个Kubernetes社区广泛使用，并且是一个CNCF毕业项目。
- en: Given Helm's similarities to traditional package managers, let's begin exploring
    Helm by first reviewing how a package manager works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Helm与传统软件包管理器的相似之处，让我们首先通过回顾软件包管理器的工作原理来开始探索Helm。
- en: Understanding package managers
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解软件包管理器
- en: Package managers are used to simplify the process of installing, upgrading,
    reverting, and removing a system's applications. These applications are defined
    in units, called **packages**, which contain metadata around target software and
    its dependencies.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器用于简化安装、升级、回滚和删除系统应用程序的过程。这些应用程序以称为**软件包**的单位进行定义，其中包含了关于目标软件及其依赖关系的元数据。
- en: The process behind package managers is simple. First, the user passes the name
    of a software package as an argument. The package manager then performs a lookup
    against a package repository to see whether that package exists. If it is found,
    the package manager installs the application defined by the package and its dependencies
    to the specified locations on the system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器背后的过程很简单。首先，用户将软件包的名称作为参数传递。然后，软件包管理器执行针对软件包存储库的查找，以查看该软件包是否存在。如果找到了，软件包管理器将安装由软件包及其依赖项定义的应用程序到系统上指定的位置。
- en: 'Package managers make managing software very easy. As an example, let''s imagine
    you wanted to install `htop`, a Linux system monitor, to a Fedora machine. Installing
    this would be as simple as typing a single command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器使管理软件变得非常容易。举个例子，假设你想要在Fedora机器上安装`htop`，一个Linux系统监视器。安装这个软件只需要输入一个命令：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This instructs `dnf`, the Fedora package manager since 2015, to find `htop`
    in the Fedora package repository and install it. `dnf` also takes care of installing
    the `htop` package's dependencies, so you would not have to worry about installing
    its requirements beforehand. After `dnf` finds the `htop` package from the upstream
    repository, it asks you whether you're sure you want to proceed. The `--assumeyes`
    flag automatically answers `yes` to this question and any other prompts that `dnf`
    may potentially ask.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示自2015年以来成为 Fedora 软件包管理器的 `dnf` 在 Fedora 软件包存储库中查找 `htop` 并安装它。`dnf`还负责安装`htop`软件包的依赖项，因此您无需担心事先安装其要求。在`dnf`从上游存储库中找到`htop`软件包后，它会询问您是否确定要继续。`--assumeyes`标志会自动回答`yes`这个问题和`dnf`可能潜在询问的任何其他提示。
- en: 'Over time, newer versions of `htop` may appear in the upstream repository.
    `dnf` and other package managers allow users to efficiently upgrade to new versions
    of the software. The subcommand that allows users to upgrade using `dnf` is upgrade:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，新版本的`htop`可能会出现在上游存储库中。`dnf`和其他软件包管理器允许用户高效地升级软件的新版本。允许用户使用`dnf`进行升级的子命令是升级：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This instructs `dnf` to upgrade `htop` to its latest version. It also upgrades
    its dependencies to the versions specified in the package's metadata.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示`dnf`将`htop`升级到最新版本。它还会将其依赖项升级到软件包元数据中指定的版本。
- en: 'While moving forward is often better, package managers also allow users to
    move backward and revert an application back to a prior version if necessary.
    `dnf` does this with the `downgrade` subcommand:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然向前迈进通常更好，但软件包管理器也允许用户向后移动，并在必要时将应用程序恢复到先前的版本。`dnf`使用`downgrade`子命令来实现这一点：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a powerful process because the package manager allows users to quickly
    roll back if a critical bug or vulnerability is reported.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的过程，因为软件包管理器允许用户在报告关键错误或漏洞时快速回滚。
- en: 'If you want to remove an application completely, a package manager can take
    care of that as well. `dnf` provides the `remove` subcommand for this purpose:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想彻底删除一个应用程序，软件包管理器也可以处理。`dnf`提供了`remove`子命令来实现这一目的：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this section, we reviewed how the `dnf` package manager on Fedora can be
    used to manage a software package. Helm, as the Kubernetes package manager, is
    similar to `dnf`, both in its purpose and functionality. While `dnf` is used to
    manage applications on Fedora, Helm is used to manage applications on Kubernetes.
    We will explore this in greater detail next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了在 Fedora 上使用`dnf`软件包管理器来管理软件包的方法。作为 Kubernetes 软件包管理器的 Helm 与`dnf`类似，无论是在目的还是功能上。`dnf`用于在
    Fedora 上管理应用程序，Helm 用于在 Kubernetes 上管理应用程序。我们将在接下来更详细地探讨这一点。
- en: The Kubernetes package manager
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 软件包管理器
- en: Given that Helm was designed to provide an experience similar to that of package
    managers, experienced users of `dnf` or similar tools will immediately understand
    Helm's basic concepts. Things become more complicated, however, when talking about
    the specific implementation details. `dnf` operates on `RPM` packages that provide
    executables, dependency information, and metadata. Helm, on the other hand, works
    with **charts**. A Helm chart can be thought of as a Kubernetes package. Charts
    contain the declarative Kubernetes resource files required to deploy an application.
    Similar to an `RPM`, it can also declare one or more dependencies that the application
    needs in order to run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Helm 的设计目的是提供类似于软件包管理器的体验，`dnf`或类似工具的有经验的用户将立即理解 Helm 的基本概念。然而，当涉及到具体的实现细节时，情况变得更加复杂。`dnf`操作`RPM`软件包，提供可执行文件、依赖信息和元数据。另一方面，Helm
    使用**charts**。Helm chart 可以被视为 Kubernetes 软件包。Charts 包含部署应用程序所需的声明性 Kubernetes
    资源文件。与`RPM`类似，它还可以声明应用程序运行所需的一个或多个依赖项。
- en: Helm relies on repositories to provide widespread access to charts. Chart developers
    create declarative YAML files, package them into charts, and publish them to chart
    repositories. End users then use Helm to search for existing charts to deploy
    onto Kubernetes, similar to how end users of `dnf` will search for `RPM` packages
    to deploy to Fedora.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Helm依赖于存储库来提供对图表的广泛访问。图表开发人员创建声明性的YAML文件，将它们打包成图表，并将它们发布到图表存储库。然后，最终用户使用Helm搜索现有的图表，以部署到Kubernetes，类似于`dnf`的最终用户搜索要部署到Fedora的`RPM`软件包。
- en: 'Let''s go through a basic example. Helm could be used to deploy `Redis`, an
    in-memory cache, to Kubernetes by using a chart published to an upstream repository.
    This could be performed using Helm''s `install` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基本的例子来看看。Helm可以使用发布到上游存储库的图表来部署`Redis`，一个内存缓存，到Kubernetes中。这可以使用Helm的`install`命令来执行：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This would install the `redis` chart from the bitnami chart repository to a
    Kubernetes namespace called `redis`. This installation would be referred to as
    the initial **revision**, or the initial deployment of a Helm chart.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在bitnami图表存储库中安装`redis`图表到名为`redis`的Kubernetes命名空间。这个安装将被称为初始**修订**，或者Helm图表的初始部署。
- en: 'If a new version of the `redis` chart becomes available, users can upgrade
    to a new version using the `upgrade` command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`redis`图表的新版本可用，用户可以使用`upgrade`命令升级到新版本：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would upgrade `Redis` to meet the specification defined by the newer `redis`-ha
    chart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将升级`Redis`，以满足新的`redis`-ha图表定义的规范。
- en: 'With operating systems, users should be concerned about rollbacks if a bug
    or vulnerability is found. The same concern exists with applications on Kubernetes,
    and Helm provides the rollback command to handle this use case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，用户应该关注如果发现了错误或漏洞，如何回滚。在Kubernetes上的应用程序也存在同样的问题，Helm提供了回滚命令来处理这种情况：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command would roll `Redis` back to its first revision.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将`Redis`回滚到它的第一个修订版本。
- en: 'Finally, Helm provides the ability to remove `Redis` altogether with the `uninstall`
    command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Helm提供了使用`uninstall`命令彻底删除`Redis`的能力：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compare `dnf`, Helm''s subcommands, and the functions they serve in the following
    table. Notice that `dnf` and Helm offer similar commands that provide a similar
    user experience:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`dnf`，Helm的子命令，以及它们在下表中提供的功能。注意`dnf`和Helm提供了类似的命令，提供了类似的用户体验：
- en: '![](image/01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](image/01.jpg)'
- en: With an understanding of how Helm functions as a package manager, let's discuss
    in greater detail the benefits that Helm brings to Kubernetes.The benefits of
    Helm
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了Helm作为一个包管理器的功能，让我们更详细地讨论Helm为Kubernetes带来的好处。Helm的好处
- en: Earlier in this chapter, we reviewed how Kubernetes applications are created
    by managing Kubernetes resources, and we discussed some of the challenges involved.
    Here are few ways that Helm can overcome these challenges.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们回顾了如何通过管理Kubernetes资源来创建Kubernetes应用程序，并讨论了一些涉及的挑战。以下是Helm可以克服这些挑战的几种方式。
- en: The abstracted complexity of Kubernetes resources
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象的Kubernetes资源的复杂性
- en: Let's assume that a developer has been given the task of deploying a MySQL database
    onto Kubernetes. The developer would need to create the resources required to
    configure its containers, network, and storage. The amount of Kubernetes knowledge
    required to configure such an application from scratch is high and is a big hurdle
    for new and even intermediate Kubernetes users to clear.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设开发人员被要求在Kubernetes上部署MySQL数据库。开发人员需要创建所需的资源来配置其容器、网络和存储。从头开始配置这样的应用程序所需的Kubernetes知识量很高，对于新手甚至中级的Kubernetes用户来说是一个很大的障碍。
- en: With Helm, a developer tasked with deploying a MySQL database could simply search
    for MySQL charts in upstream chart repositories. These charts would have already
    been written by chart developers in the community and would already contain the
    declarative configuration required to deploy a MySQL database. In this regard,
    developers with this kind of task would act as simple end users that use Helm
    in a similar way to any other package manager.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helm，负责部署MySQL数据库的开发人员可以简单地在上游图表存储库中搜索MySQL图表。这些图表已经由社区中的图表开发人员编写，并且已经包含了部署MySQL数据库所需的声明性配置。在这方面，具有这种任务的开发人员将像任何其他软件包管理器一样使用Helm作为简单的最终用户。
- en: The ongoing history of revisions
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续的修订历史
- en: Helm has a concept called release history. When a Helm chart is installed for
    the first time, Helm adds that initial revision to the history. The history is
    further modified as revisions increase via upgrades, keeping various snapshots
    of how the application was configured at varying revisions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Helm有一个称为发布历史的概念。当首次安装Helm图表时，Helm将该初始修订添加到历史记录中。随着修订通过升级的增加，历史记录会进一步修改，保留应用程序在不同修订中配置的各种快照。
- en: 'The following diagram depicts an ongoing history of revisions. The squares
    in blue illustrate resources that have been modified from their previous versions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了持续的修订历史。蓝色的方块说明了资源已经从其先前版本进行了修改：
- en: '![Figure 1.6: An example of a revision history'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：修订历史的示例'
- en: '](image/Figure_1.6.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.6.jpg)'
- en: Figure 1.6 - An example of a revision history
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - 修订历史的示例
- en: The process of tracking each revision provides opportunities for rollback. Rollbacks
    in Helm are very simple. Users simply point Helm to a previous revision and Helm
    reverts the live state to that of the selected revision. With Helm, gone are the
    days of the `n-1` backup. Helm allows users to roll back their applications as
    far back as they desire, even back to the very first installation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每个修订的过程为回滚提供了机会。Helm中的回滚非常简单。用户只需将Helm指向先前的修订，Helm将live状态恢复到所选修订的状态。有了Helm，过去的“n-1”备份已经过时。Helm允许用户将其应用程序回滚到他们想要的任何时间，甚至可以回滚到最初的安装。
- en: Dynamically configured declarative resources
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态配置声明性资源
- en: One of the biggest hassles with creating resources declaratively is that Kubernetes
    resources are static and cannot be parameterized. As you may recall from earlier,
    this results in resources becoming boilerplate across applications and similar
    configurations, making it more difficult for teams to configure their applications
    as code. Helm alleviates these issues by introducing **values** and **templates**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以声明方式创建资源的最大麻烦之一是Kubernetes资源是静态的，无法参数化。正如您可能还记得的那样，这导致资源在应用程序和类似配置之间变得样板化，使团队更难以将其应用程序配置为代码。Helm通过引入**值**和**模板**来缓解这些问题。
- en: Values are simply what Helm calls parameters for charts. Templates are dynamically
    generated files based on a given set of values. These two constructs provide chart
    developers the ability to write Kubernetes resources that are automatically generated
    based on values that end users provide. By doing so, applications managed by Helm
    become more flexible, less boilerplate, and easier to maintain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 值就是Helm称为图表参数的简单东西。模板是基于给定值集的动态生成文件。这两个构造为图表开发人员提供了根据最终用户提供的值自动生成基于值的Kubernetes资源的能力。通过这样做，由Helm管理的应用程序变得更加灵活，减少样板代码，并更易于维护。
- en: 'Values and templates allow users to do things such as the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 值和模板允许用户执行以下操作：
- en: Parameterize common fields, such as the image name in a Deployment and the ports
    in a Service
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化常见字段，比如在部署中的图像名称和服务中的端口
- en: Generate long pieces of YAML configuration based on user input, such as volume
    mounts in a Deployment or the data in a ConfigMap
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入生成长篇的YAML配置，比如在部署中的卷挂载或ConfigMap中的数据
- en: Include or exclude resources based on user input
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入包含或排除资源
- en: The ability to dynamically generate declarative resource files makes it simpler
    to create YAML-based resources while still ensuring that applications are created
    in an easily reproducible fashion.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 能够动态生成声明性资源文件使得创建基于YAML的资源变得更简单，同时确保应用以一种易于复制的方式创建。
- en: Consistency between the local and live states
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地和实时状态之间的一致性
- en: Package managers prevent users from having to manage an application and its
    dependencies manually. All management can be done through the package manager
    itself. The same idea holds true with Helm. Because a Helm chart contains a flexible
    configuration of Kubernetes resources, users shouldn't have to make modifications
    directly to live Kubernetes resources. Users that want to modify their applications
    can do so by providing new values to a Helm chart or by upgrading their application
    to a more recent version of the associated chart. This allows the local state
    (represented by the Helm chart configuration) and the live state to remain consistent
    across modifications, giving users the ability to provide a source of truth for
    their Kubernetes resource configurations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器可以防止用户手动管理应用程序及其依赖关系。所有管理都可以通过软件包管理器本身完成。Helm也是如此。因为Helm图表包含了灵活的Kubernetes资源配置，用户不应该直接对实时的Kubernetes资源进行修改。想要修改他们的应用程序的用户可以通过向Helm图表提供新值或将其应用程序升级到相关图表的更新版本来实现。这使得本地状态（由Helm图表配置表示）和实时状态在修改过程中保持一致，使用户能够为他们的Kubernetes资源配置提供真实的来源。
- en: Intelligent Deployments
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能部署
- en: Helm simplifies application deployments by determining the order that Kubernetes
    resources need to be created. Helm analyzes each of a chart's resources and orders
    them based on their types. This pre-deterministic order exists to ensure that
    resources that commonly have resources dependent on them are created first. For
    example, Secrets and ConfigMaps should be created before Deployments, since a
    Deployment would likely consume those resources as volumes. Helm performs this
    ordering without any interaction from the user, so this complexity is abstracted
    and prevents users from needing to worry about the order that these resources
    are applied.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Helm通过确定Kubernetes资源需要创建的顺序来简化应用部署。Helm分析每个图表的资源，并根据它们的类型对它们进行排序。这种预先确定的顺序存在是为了确保常常有资源依赖于它们的资源首先被创建。例如，Secrets和ConfigMaps应该在部署之前创建，因为部署很可能会使用这些资源作为卷。Helm在没有用户交互的情况下执行此排序，因此这种复杂性被抽象化，用户无需担心这些资源被应用的顺序。
- en: Automated life cycle hooks
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动生命周期钩子
- en: 'Similar to other package managers, Helm provides the ability to define life
    cycle hooks. Life cycle hooks are actions that take place automatically at different
    stages of an application''s life cycle. They can be used to do things such as
    the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他软件包管理器类似，Helm提供了定义生命周期钩子的能力。生命周期钩子是在应用程序生命周期的不同阶段自动执行的操作。它们可以用来执行诸如以下操作：
- en: Perform a data backup on an upgrade.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在升级时执行数据备份。
- en: Restore data on a rollback.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回滚时恢复数据。
- en: Validate a Kubernetes environment prior to installation.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装之前验证Kubernetes环境。
- en: Life cycle hooks are valuable because they abstract complexities around tasks
    that may not be Kubernetes-specific. For example, a Kubernetes user may not be
    familiar with the best practices behind backing up a database or may not know
    when such a task should be performed. Life cycle hooks allow experts to write
    automation that performs those best practices when recommended so that users can
    continue to be productive without needing to worry about those details.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子非常有价值，因为它们抽象了可能不是特定于Kubernetes的任务的复杂性。例如，Kubernetes用户可能不熟悉数据库备份背后的最佳实践，或者可能不知道何时应执行此类任务。生命周期钩子允许专家编写自动化，以在建议时执行这些最佳实践，以便用户可以继续高效工作，而无需担心这些细节。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began by exploring the change in architectural trends of
    adopting microservice-based architectures to decompose applications into several
    smaller applications instead of deploying one large monolith. The creation of
    applications that are more lightweight and easier to manage has led to utilizing
    containers as a packaging and runtime format to produce releases more frequently.
    By adopting containers, additional operational challenges were introduced and
    solved by using Kubernetes as a container orchestration platform to manage the
    container life cycle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了采用基于微服务的架构的变化趋势，将应用程序分解为几个较小的应用程序，而不是部署一个庞大的单体应用程序。创建更轻量级且更易管理的应用程序导致利用容器作为打包和运行时格式，以更频繁地发布版本。通过采用容器，引入了额外的运营挑战，并通过使用Kubernetes作为容器编排平台来管理容器生命周期来解决这些挑战。
- en: 'Our discussion turned to the various ways that Kubernetes applications can
    be configured, including Deployments, Services, and PersistentVolumeClaims. These
    resources can be expressed using two distinct styles of application configuration:
    imperative and declarative. Each of these configuration styles contributes to
    a set of challenges involved in deploying Kubernetes applications, including the
    amount of knowledge required to understand how Kubernetes resources work and the
    challenge of managing application life cycles.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了配置Kubernetes应用程序的各种方式，包括部署、服务和持久卷索赔。这些资源可以使用两种不同的应用程序配置样式来表示：命令式和声明式。这些配置样式中的每一种都对部署Kubernetes应用程序涉及的一系列挑战做出了贡献，包括理解Kubernetes资源工作的知识量以及管理应用程序生命周期的挑战。
- en: To better manage each of the assets that comprise an application, Helm was introduced
    as the package manager for Kubernetes. Through its rich feature set, the full
    life cycle of applications from install, upgrade, rollback, and removal can be
    managed with ease.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理构成应用程序的每个资产，Helm被引入为Kubernetes的软件包管理器。通过其丰富的功能集，可以轻松管理应用程序的完整生命周期，包括安装、升级、回滚和删除。
- en: In the next chapter, we'll walk through the process of configuring a Helm environment.
    We will also install the tooling required for consuming the Helm ecosystem and
    following along with the examples provided in this book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细介绍配置Helm环境的过程。我们还将安装所需的工具，以便使用Helm生态系统，并按照本书提供的示例进行操作。
- en: Further reading
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about the Kubernetes resources that make up an application,
    please see the *Understanding Kubernetes Objects* page from the Kubernetes docume[ntation
    at https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernet](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/)es-objects/.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构成应用程序的Kubernetes资源的更多信息，请参阅Kubernetes文档中的*了解Kubernetes对象*页面，网址为https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/。
- en: To reinforce some of the benefits of Helm discussed in this chapter, please
    refer to the *Using Helm* page of the Helm docume[ntation at https://helm.sh/docs/intro/](https://helm.sh/docs/intro/using_helm/)using_helm/.
    (This page also dives into some basic usage around Helm, which will be discussed
    throughout this book in greater detail.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强本章讨论的Helm的一些好处，请参考Helm文档中的*使用Helm*页面，网址为https://helm.sh/docs/intro/using_helm/。
    （本页还深入讨论了Helm周围的一些基本用法，这将在本书中更详细地讨论。）
- en: Questions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a monolithic and a microservices application?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用和微服务应用有什么区别？
- en: What is Kubernetes? What problems was it designed to solve?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes是什么？它旨在解决什么问题？
- en: What are some of the `kubectl` commands commonly used when deploying applications
    to Kubernetes?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署应用程序到Kubernetes时，常用的一些`kubectl`命令是什么？
- en: What challenges are often involved in deploying applications to Kubernetes?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署应用程序到Kubernetes时通常涉及哪些挑战？
- en: How does Helm function as a package manager for Kubernetes? How does it address
    the challenges posed by Kubernetes?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm如何作为Kubernetes的包管理器？它是如何解决Kubernetes提出的挑战的？
- en: Imagine you want to roll back an application deployed on Kubernetes. What Helm
    command allows you to perform this action? How does Helm keep track of your changes
    to make this rollback possible?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您想要回滚在Kubernetes上部署的应用程序。哪个Helm命令允许您执行此操作？Helm如何跟踪您的更改以使此回滚成为可能？
- en: What are the four primary Helm commands that allow Helm to function as a package
    manager?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许Helm作为包管理器运行的四个主要Helm命令是什么？
