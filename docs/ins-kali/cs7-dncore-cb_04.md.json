["```cs\n        public class ShippingContainer\n        {\n          public int Width { get; set; }\n          public int Height { get; set; }\n          public int Length { get; set; }\n          public int[] DimensionsWHL { get; set; }\n          public ShippingContainer(int width, int height, int length)\n          {\n            Width = width;\n            Height = height;\n            Length = length;\n\n            DimensionsWHL = new int[] { width, height, length };\n          }\n        }\n\n```", "```cs\n        private static void AnalyzeSymbol(\n          SymbolAnalysisContext context)\n        {\n          // TODO: Replace the following code with your own \n             analysis, generating Diagnostic objects for any \n             issues you find\n          var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n\n          // Find just those named type symbols with names \n             containing lowercase letters.\n          if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))\n          {\n            // For all such symbols, produce a diagnostic.\n            var diagnostic = Diagnostic.Create(Rule, \n              namedTypeSymbol.Locations[0], namedTypeSymbol.Name);\n\n            context.ReportDiagnostic(diagnostic);\n          }\n        }\n\n```", "```cs\n        public const string DiagnosticId = \"PurchaseOrderAnalyzer\";\n\n        public enum ClassTypesToCheck { PurchaseOrder, SalesOrder }\n        public enum MandatoryInterfaces { IReceiptable }\n\n        private static readonly LocalizableString Title = \n          \"Interface Implementation Available\"; \n        private static readonly LocalizableString \n          MessageFormat = \"IReceiptable Interface not Implemented\"; \n        private static readonly LocalizableString Description = \n          \"You need to implement the IReceiptable interface\"; \n        private const string Category = \"Naming\";\n\n        private static DiagnosticDescriptor Rule = new \n          DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, \n          Category, DiagnosticSeverity.Warning, \n          isEnabledByDefault: true, description: Description);\n\n```", "```cs\n        public override void Initialize(AnalysisContext context)\n        {\n          context.RegisterSymbolAction(AnalyzeSymbol, \n            SymbolKind.NamedType);\n        }\n\n```", "```cs\n        private static void AnalyzeSymbol(SymbolAnalysisContext context)\n        {\n\n        }\n\n```", "```cs\n        bool blnInterfaceImplemented = false;\n        if (!context.Symbol.IsAbstract)\n        {\n\n        }\n\n```", "```cs\n        var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n        List<string> classesToCheck = Enum.GetNames(\n          typeof(ClassTypesToCheck)).ToList();\n\n        if (classesToCheck.Any(s => s.Equals(\n          namedTypeSymbol.Name, StringComparison.OrdinalIgnoreCase)))\n        {\n\n        }\n\n```", "```cs\n        string interfaceName = nameof(\n          MandatoryInterfaces.IReceiptable);\n\n        if (namedTypeSymbol.AllInterfaces.Any(s => s.Name.Equals(\n          interfaceName, StringComparison.OrdinalIgnoreCase)))\n        {\n          blnInterfaceImplemented = true;\n        }\n\n        if (!blnInterfaceImplemented)\n        {\n          // Produce a diagnostic.\n          var diagnostic = Diagnostic.Create(Rule, \n            namedTypeSymbol.Locations[0], namedTypeSymbol.Name);\n          context.ReportDiagnostic(diagnostic);\n        }\n\n```", "```cs\n        private static void AnalyzeSymbol(SymbolAnalysisContext context)\n        {\n          bool blnInterfaceImplemented = false;\n          if (!context.Symbol.IsAbstract)\n          {\n            var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n            List<string> classesToCheck = Enum.GetNames(\n              typeof(ClassTypesToCheck)).ToList();\n\n            if (classesToCheck.Any(s => s.Equals(namedTypeSymbol.Name, \n              StringComparison.OrdinalIgnoreCase)))\n            {\n              string interfaceName = nameof(\n                MandatoryInterfaces.IReceiptable);\n\n              if (namedTypeSymbol.AllInterfaces.Any(s => s.Name.Equals(\n                interfaceName, StringComparison.OrdinalIgnoreCase)))\n              {\n                blnInterfaceImplemented = true;\n              }\n\n              if (!blnInterfaceImplemented)\n              {\n                // Produce a diagnostic.\n                var diagnostic = Diagnostic.Create(Rule, \n                  namedTypeSymbol.Locations[0], namedTypeSymbol.Name);\n                context.ReportDiagnostic(diagnostic);\n              }\n            }\n          }\n        }\n\n```", "```cs\n        private const string title = \"Implement IReceiptable\";\n\n```", "```cs\n        public sealed override async Task RegisterCodeFixesAsync(\n          CodeFixContext context)\n        {\n          var root = await context.Document.GetSyntaxRootAsync(\n            context.CancellationToken).ConfigureAwait(false);\n\n          var diagnostic = context.Diagnostics.First();\n          var diagnosticSpan = diagnostic.Location.SourceSpan;\n\n          // Find the type declaration identified by the diagnostic.\n          var declaration = root.FindToken(diagnosticSpan.Start)\n            .Parent.AncestorsAndSelf().OfType\n            <TypeDeclarationSyntax>().First();\n\n          // Register a code action that will invoke the fix.\n          context.RegisterCodeFix(\n            CodeAction.Create(\n              title: title,\n              createChangedSolution: c => \n              ImplementRequiredInterfaceAsync(context.Document, \n                declaration, c),\n            equivalenceKey: title),\n          diagnostic);\n        }\n\n```", "```cs\n        private async Task<Solution> ImplementRequiredInterfaceAsync(\n          Document document, TypeDeclarationSyntax typeDecl, \n          CancellationToken cancellationToken)\n        {\n          // Get the text of the PurchaseOrder class and return one \n             implementing the IPurchaseOrder interface\n          var identifierToken = typeDecl.Identifier;\n\n          var newName = $\"{identifierToken.Text} : IReceiptable\";\n\n          // Get the symbol representing the type to be renamed.\n          var semanticModel = await document.GetSemanticModelAsync(\n            cancellationToken);\n          var typeSymbol = semanticModel.GetDeclaredSymbol(\n            typeDecl, cancellationToken);\n\n          // Produce a new solution that has all references to \n             that type renamed, including the declaration.\n          var originalSolution = document.Project.Solution;\n          var optionSet = originalSolution.Workspace.Options;\n          var newSolution = await Renamer.RenameSymbolAsync(\n            document.Project.Solution, typeSymbol, newName, \n            optionSet, cancellationToken).ConfigureAwait(false);\n\n          return newSolution;\n        }\n\n```", "```cs\n        interface IReceiptable\n        {\n          void MarkAsReceipted(int orderNumber);\n        }\n\n```", "```cs\n        public class PurchaseOrder \n        {\n\n        }\n\n```", "```cs\n        public class PurchaseOrder : IReceiptable \n        {\n\n        }\n\n```", "```cs\n        <?xml version=\"1.0\"?>\n        <package >\n          <metadata>\n            <id>PurchaseOrderAnalyzer</id>\n            <version>1.1.1.1</version>\n            <title>Purchase Order Analyzer</title>\n            <authors>Dirk Strauss</authors>\n            <owners>Acme Corporation</owners>\n            <licenseUrl>http://www.acmecorporation.com/poanalyzer/\n             license</licenseUrl>\n            <projectUrl>http://www.acmecorporation.com/poanalyzer\n             </projectUrl>\n            <requireLicenseAcceptance>true</requireLicenseAcceptance>\n            <description>Validate the creation of Purchase Order Objects \n             withing Acme Corporation's development projects\n            </description>\n            <releaseNotes>Initial release of the Purchase Order \n             Analyzer.</releaseNotes>\n            <copyright>Copyright</copyright>\n            <tags>PurchaseOrderAnalyzer, analyzers</tags>\n            <frameworkAssemblies>\n              <frameworkAssembly assemblyName=\"System\" \n               targetFramework=\"\" />\n            </frameworkAssemblies>\n          </metadata>\n          <!-- The convention for analyzers is to put language \n           agnostic dlls in analyzersportable50 and language \n           specific analyzers in either analyzersportable50cs or \n           analyzersportable50vb -->\n          <files>\n            <file src=\"img/*.dll\" target=\"analyzersdotnetcs\" \n             exclude=\"**Microsoft.CodeAnalysis.*;\n             **System.Collections.Immutable.*;\n             **System.Reflection.Metadata.*;\n             **System.Composition.*\" />\n            <file src=\"img/tools*.ps1\" target=\"tools\" />\n          </files>\n        </package>\n\n```"]