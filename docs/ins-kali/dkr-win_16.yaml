- en: Containerize What You Know - Guidance for Implementing Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您所知道的内容放入容器-实施Docker的指导
- en: In this book I have used older .NET technologies for the sample applications
    to show you that Docker works just as well with them as it does with modern .NET
    Core apps. You can Dockerize a ten year old WebForms application and get many
    of the same benefits you get from running a greenfield ASP.NET Core web application
    in a container.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用了较旧的.NET技术来展示示例应用程序，以向您展示Docker与现代.NET Core应用程序一样有效。您可以将十年前的WebForms应用程序放入Docker，并获得与在容器中运行全新的ASP.NET
    Core Web应用程序相同的许多好处。
- en: You've seen lots of examples of containerized applications and learned how to
    build, ship, and run production-grade apps with Docker. Now, you're ready to start
    working with Docker on your own projects, and this chapter gives you advice on
    how to get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了许多容器化应用程序的示例，并学会了如何使用Docker构建、部署和运行生产级应用程序。现在，您已经准备好在自己的项目中开始使用Docker，并且本章将为您提供如何入门的建议。
- en: 'I''ll cover some techniques and tools that will help you run a proof-of-concept
    project to move an application to Docker. I''ll also walk you through some case
    studies to show you how I''ve introduced Docker to existing projects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍一些技术和工具，这些将帮助您运行一个概念验证项目，将应用程序迁移到Docker。我还将通过一些案例研究向您展示我是如何将Docker引入现有项目的：
- en: A small-scale .NET 2.0 WebForms app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小型的.NET 2.0 WebForms应用程序
- en: A database integration service in a **Windows Communication Foundation** (**WCF**)
    app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Communication Foundation**（**WCF**）应用程序中的数据库集成服务'
- en: A distributed IoT API app running in Azure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Azure中运行的分布式IoT API应用程序
- en: You'll see how to approach typical problems and how the move to Docker can help
    solve them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如何解决典型问题以及Docker的应用如何帮助解决这些问题。
- en: Dockerizing what you know
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您所知道的内容放入Docker
- en: When you move to a new application platform, you have to work with a new set
    of artifacts and new operational processes. If you currently use the Windows installer
    for deployment, your artifacts are Wix files and MSIs. Your deployment process
    is to copy the MSI to the target server, log on, and run the installer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您迁移到新的应用程序平台时，您必须使用一组新的工件和新的操作流程。如果您目前使用Windows安装程序进行部署，您的工件是Wix文件和MSI文件。您的部署过程是将MSI复制到目标服务器，登录并运行安装程序。
- en: After the move to Docker, you will have Dockerfiles and images as the deployment
    artifacts. You push the image to a registry and run a container or update a service
    to deploy the app. The resources and activities are simpler in Docker, and they'll
    be consistent between projects, but there's still a learning curve when you start.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到Docker后，您将拥有Dockerfiles和镜像作为部署工件。您将镜像推送到注册表并运行容器或更新服务以部署应用程序。在Docker中资源和活动更简单，并且它们在项目之间是一致的，但是当您开始时仍然有一个学习曲线。
- en: Containerizing an app that you know well is a great way to provide a solid basis
    to that learning experience. When you first run your app in a container, you may
    see errors or incorrect behavior, *but that will be in the domain of your own
    application*. When you're tracking down the issue, you'll be dealing with an area
    you understand well, so although the platform is new, the problem should be easy
    to identify.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将您熟悉的应用程序放入容器是提供学习经验的一个很好的方法。当您首次在容器中运行应用程序时，可能会出现错误或不正确的行为，*但这将是您自己应用程序的领域*。当您追踪问题时，您将处理一个您很了解的领域，因此尽管平台是新的，问题应该很容易识别。
- en: Selecting a simple Proof-of-Concept app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个简单的概念验证应用程序
- en: Docker is ideally suited to distributed applications, where each component runs
    in a lightweight container, making efficient use of a minimal set of hardware.
    You can choose a distributed application for your first Docker deployment, but
    a simpler application will be faster to migrate and will give you a higher chance
    of success.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker理想地适用于分布式应用程序，其中每个组件在轻量级容器中运行，有效地利用最小的硬件集。您可以选择一个分布式应用程序作为您的第一个Docker部署，但一个更简单的应用程序将更快地迁移，并且会给您更高的成功机会。
- en: A monolithic app is a good choice. It doesn't have to be a small code base,
    but the fewer integrations with other components it has, the more quickly you
    will have it running in Docker. An ASP.NET application that stores state in SQL
    Server is a straightforward option. You can expect to have a **Proof-of-Concept**
    (**PoC**) running in a day or two with a simple application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用是一个不错的选择。它不一定要有一个小的代码库，但是与其他组件的集成越少，您就越快地将其在Docker中运行。将状态存储在SQL Server中的ASP.NET应用程序是一个直接的选择。您可以期望用一个简单的应用程序在一两天内运行一个**概念验证**（**PoC**）。
- en: 'Starting with a compiled application rather than the source code is a good
    way to prove that the app can be Dockerized without having to be changed. There
    are a few factors to consider when you''re selecting your PoC application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从已编译的应用程序开始，而不是源代码，是证明该应用程序可以被Docker化而无需更改的好方法。在选择您的PoC应用程序时，有一些因素需要考虑：
- en: '**Statefulness**: If your target app stores state in memory, you won''t be
    able to scale the PoC by running multiple containers. Each container will have
    its own state, and you''ll get inconsistent behavior as requests are handled by
    different containers unless you also run a reverse proxy with sticky session support.
    Consider stateless apps or apps that can use shared state, like using SQL Server
    as a session state provider for ASP.NET.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态性**：如果您的目标应用程序在内存中存储状态，您将无法通过运行多个容器来扩展PoC。每个容器将有自己的状态，并且除非您还运行具有粘性会话支持的反向代理，否则在不同容器处理请求时会得到不一致的行为。考虑无状态应用程序或可以使用共享状态的应用程序，比如使用SQL
    Server作为ASP.NET的会话状态提供程序。'
- en: '**Configuration**: .NET apps typically use XML configuration files in `Web.config`
    or `app.config`. You can set up your PoC to use an existing config file as the
    base and then swap out any values that don''t apply to the containerized environment.
    It is preferable to read config settings through Docker with environment variables
    and secrets, but staying with config files is easier for the PoC.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：.NET应用程序通常在`Web.config`或`app.config`中使用XML配置文件。您可以设置您的PoC来使用现有的配置文件作为基础，然后替换任何不适用于容器化环境的值。最好通过Docker使用环境变量和秘密来读取配置设置，但对于PoC来说，保持配置文件更容易。'
- en: '**Resilience**: Older applications typically make the assumption of availability—the
    web app expects the database to be always available and doesn''t handle failure
    conditions gracefully. If your app has no retry logic for external connections,
    your PoC will face an error if there are transient connection failures when containers
    are starting up. You can mitigate this in the Dockerfile with a check for dependencies
    on startup, and an ongoing health check.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：较旧的应用程序通常假设可用性——Web应用程序期望数据库始终可用，并且不会优雅地处理故障条件。如果您的应用程序对外部连接没有重试逻辑，那么当容器启动时出现瞬时连接故障时，您的PoC将面临错误。您可以在Dockerfile中通过启动时检查依赖项和持续的健康检查来减轻这种情况。'
- en: '**Windows authentication**: Containers aren''t domain-joined. You can access
    **Active Directory** (**AD**) objects in containers if you create a Group Managed
    Service Account in AD, but that adds complexity. For the PoC, stick to simpler
    authentication schemes like basic authentication.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows身份验证**：容器未加入域。如果您在AD中创建了一个组托管服务帐户，您可以在容器中访问**Active Directory**（**AD**）对象，但这会增加复杂性。对于PoC，坚持使用更简单的身份验证方案，如基本身份验证。'
- en: None of these are major restrictions. You should be able to work on the basis
    of containerizing an existing app without changing code, but you need to be aware
    that the functionality may not be perfect at the PoC stage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不是主要限制。您应该能够在容器化现有应用程序的基础上工作，而无需更改代码，但您需要意识到在PoC阶段功能可能不完美。
- en: Generating an initial Dockerfile with Image2Docker
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Image2Docker生成初始Dockerfile
- en: Image2Docker is an open source tool that you can use to generate a Dockerfile
    for an existing application. It's a PowerShell module that you can run on the
    local machine or against a remote machine or virtual machine disk file (in Hyper-V,
    the files are in `VHD` or `VHDX` format).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Image2Docker是一个开源工具，您可以使用它为现有应用程序生成Dockerfile。它是一个PowerShell模块，您可以在本地计算机上运行，也可以针对远程计算机或虚拟机磁盘文件运行（在Hyper-V中，文件以“VHD”或“VHDX”格式存储）。
- en: It's a very simple way to get started with Docker – you don't even need Docker
    installed on your machine to try it out and see what the Dockerfile would look
    like for your app. Image2Docker can work with different types of application (called
    **artifacts**), but the functionality is mature for ASP.NET apps running on IIS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的开始使用Docker的方法-甚至您甚至不需要在本地计算机上安装Docker来尝试并查看Dockerfile对您的应用程序会是什么样子。Image2Docker可以处理不同类型的应用程序（称为**构件**），但对于在IIS上运行的ASP.NET应用程序，功能是成熟的。
- en: 'On my development machine, I have an ASP.NET application deployed to **Internet
    Information Services** (**IIS**). I can migrate that application to Docker by
    installing Image2Docker from the PowerShell gallery and importing the module to
    use it locally:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的开发计算机上，我有一个部署到**Internet Information Services**（**IIS**）的ASP.NET应用程序。我可以通过从PowerShell库安装Image2Docker并导入模块来在Docker中迁移该应用程序。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: PowerShell 5.0 is the minimum required version for `Image2Docker`, but the tool
    has no other dependencies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 5.0是“Image2Docker”所需的最低版本，但该工具没有其他依赖关系。
- en: 'I can run the `ConvertTo-Dockerfile` cmdlet, specifying the IIS artifact to
    build a Dockerfile that contains all the IIS websites on my machine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以运行“ConvertTo-Dockerfile” cmdlet，指定IIS构件来构建一个包含我计算机上所有IIS网站的Dockerfile：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates a directory at `C:\i2d\iis`, and inside the folder I'll have a
    Dockerfile and sub directories for each of the websites. `Image2Docker` copies
    the website content from the source to the output location. The Dockerfile uses
    the most relevant base image for the applications it finds, that is, `microsoft/iis`,
    `microsoft/aspnet`, or `microsoft/aspnet:3.5`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`C:\i2d\iis`创建一个目录，在文件夹内部，我将有一个Dockerfile和每个网站的子目录。“Image2Docker”将网站内容从源复制到输出位置。Dockerfile使用最相关的基础映像来找到应用程序，即`microsoft/iis`，`microsoft/aspnet`或`microsoft/aspnet:3.5`。
- en: 'If there are multiple websites or web applications on the source, `Image2Docker`
    extracts them all and builds a single Dockerfile that duplicates the original
    IIS setup, so there will be multiple apps in the Docker image. That''s not what
    I''m aiming for, since I want a single app in my Docker image, so I can run with
    a parameter instead to extract a single website:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源中有多个网站或Web应用程序，“Image2Docker”会提取它们所有并构建一个重复原始IIS设置的单个Dockerfile，因此Docker镜像中将有多个应用程序。这不是我的目标，因为我希望我的Docker镜像中只有一个应用程序，所以我可以使用参数来提取单个网站：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The process is the same, but this time, `Image2Docker` extracts only a single
    application from the source—the one that's named in the `ArtifactParam` parameter.
    The Dockerfile contains the steps to deploy the application, and you can run `docker
    image build` to create the image and run the app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是一样的，但这次，`Image2Docker`只从源中提取一个应用程序 - 在`ArtifactParam`参数中命名的应用程序。Dockerfile包含部署应用程序的步骤，您可以运行`docker
    image build`来创建图像并运行应用程序。
- en: This could be your first step in Dockerizing your application, and then you
    would run a container and check the functionality of the app. There may be additional
    setup needed, which `Image2Docker` doesn't do for you, so you'll likely be iterating
    on that generated Dockerfile, but the tool is a good way to get started.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是Docker化应用程序的第一步，然后您将运行一个容器并检查应用程序的功能。可能需要额外的设置，`Image2Docker`不会为您完成，所以您可能会在生成的Dockerfile上进行迭代，但该工具是一个很好的开始。
- en: '`Image2Docker` is an open source project. The source is on GitHub – use the
    following short link to view it: [https://github.com/docker/communitytools-image2docker-win](https://github.com/docker/communitytools-image2docker-win).
    The tool has not been updated recently, as Docker now have a commercial alternative
    called Docker Application Convertor (DAC). DAC has a much greater feature set
    since it supports Linux and Windows applications. You can see it demonstrated
    in DockerCon sessions on YouTube: [https://is.gd/sLMOa1](https://is.gd/sLMOa1).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image2Docker`是一个开源项目。源代码在GitHub上 - 使用以下短链接查看：[https://github.com/docker/communitytools-image2docker-win](https://github.com/docker/communitytools-image2docker-win)。该工具最近没有更新，因为Docker现在有一个商业替代品叫做Docker
    Application Convertor（DAC）。DAC具有更强大的功能集，因为它支持Linux和Windows应用程序。您可以在YouTube上的DockerCon会议上看到演示：[https://is.gd/sLMOa1](https://is.gd/sLMOa1)。'
- en: Engaging other stakeholders
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 吸引其他利益相关者
- en: A successful PoC should be possible in just a few days. The output of that will
    be a sample application that runs in Docker, as well as a set of extra steps you
    need to productionize that PoC. If you're working in a DevOps environment where
    your team owns the delivery of your project, you can agree to make the investment
    to move to Docker for production.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的PoC应该在几天内就能实现。其输出将是在Docker中运行的示例应用程序，以及您需要将该PoC投入生产的一系列额外步骤。如果您在一个DevOps环境中工作，您的团队负责项目的交付，您可以同意投资转移到Docker用于生产。
- en: 'For larger projects or larger teams, you''ll need to engage with other stakeholders
    to take your PoC further. The type of conversations you have will depend on the
    structure of your organization, but there are some themes that focus on the improvements
    you get with Docker:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的项目或更大的团队，您需要与其他利益相关者合作，以进一步进行您的PoC。您进行的对话类型将取决于您的组织结构，但有一些主题侧重于您在Docker中获得的改进：
- en: The operations team often has friction in the handover from development when
    it's time to deploy the application. The Docker artifacts, Dockerfiles and Docker
    Compose files are a central point where dev and ops can work together. There's
    no risk that the ops team will be given an upgrade they can't deploy because the
    upgrade will be a Docker image that's already been tried and tested.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署应用程序时，运维团队经常在从开发部门交接时遇到摩擦。Docker工件、Dockerfiles和Docker Compose文件是开发和运维可以共同努力的中心点。运维团队不会因为升级而无法部署，因为升级将是一个已经经过尝试和测试的Docker镜像。
- en: The security team in large companies often has to demonstrate provenance. They
    need to prove that the software running in production hasn't been tampered with
    and is actually running the code that's in SCM. This may be process-driven right
    now, but with image signing and Docker content trust, it can be explicitly proven.
    In some cases, security also need to demonstrate that a system will run only on
    certified hardware, and that's easy to do with secure labels and constraints in
    Docker Swarm.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大公司的安全团队经常需要证明来源。他们需要证明在生产中运行的软件没有被篡改，并且实际上正在运行SCM中的代码。目前可能是基于流程的，但通过镜像签名和Docker内容信任，可以明确地证明。在某些情况下，安全团队还需要证明系统只能在经过认证的硬件上运行，而在Docker
    Swarm中使用安全标签和约束很容易实现。
- en: Product owners are often trying to balance large backlogs against long release
    schedules. Enterprise .NET projects are typically difficult to deploy—the upgrade
    process is slow, manual, and risky. There's a deployment phase and then a user
    testing phase, during which the application is offline to normal users. In contrast,
    deployments with Docker are fast, automated, and safe, which means you can deploy
    more frequently, adding features when they're ready instead of waiting months
    for the next scheduled release.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品所有者经常试图在长期发布计划中平衡庞大的积压工作。企业.NET项目通常难以部署——升级过程缓慢、手动且风险高。有一个部署阶段，然后是用户测试阶段，在此期间应用程序对普通用户不可用。相比之下，使用Docker进行部署快速、自动化且安全，这意味着您可以更频繁地部署，当功能准备就绪时添加功能，而不是等待下一个预定发布的几个月。
- en: The management team will have a focus on the product and the cost of running
    the product. Docker helps reduce infrastructure costs through more efficient use
    of compute resources and lower licensing costs. It helps reduce project costs
    by letting the team work more efficiently, removing the gaps between environments
    so that deployments are consistent. It also helps increase product quality, as
    automated packaging and rolling updates mean you can deploy more often, adding
    features and fixing defects more quickly.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理团队将专注于产品和产品运行成本。Docker通过更有效地利用计算资源和降低许可成本来帮助降低基础设施成本。它通过让团队更高效地工作，消除环境之间的差异以确保部署一致，帮助降低项目成本。它还有助于提高产品质量，因为自动打包和滚动更新意味着您可以更频繁地部署，更快地添加功能和修复缺陷。
- en: You can get started with Docker by running the **Community Edition** (**CE**)
    for your PoC, which you get with Docker Desktop on Windows 10\. Other stakeholders
    in your organization will want to understand the support that's available for
    applications running in containers. Docker Enterprise Engine is included in the
    Windows Server 2016 or 2019 license cost, so you have support from Microsoft and
    Docker, Inc. at no extra cost. Operations and security teams may see a lot of
    benefit in the full Docker Enterprise suite, which gives you **Universal Control
    Plane** (**UCP**) and **Docker Trusted Registry** (**DTR**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Windows 10上使用Docker桌面获得Docker的**社区版**（**CE**）来开始进行PoC。您组织中的其他利益相关者将希望了解在容器中运行的应用程序可获得的支持。Docker企业引擎包含在Windows
    Server 2016或2019的许可成本中，因此您可以在没有额外成本的情况下获得来自Microsoft和Docker, Inc.的支持。运营和安全团队可能会在完整的Docker企业套件中看到很多好处，其中包括**通用控制平面**（**UCP**）和**Docker受信任的注册表**（**DTR**）。
- en: Docker recently announced that they will be shipping Docker Desktop Enterprise
    for Mac and Windows. It will have the same great user experience as Docker Desktop,
    but with support on Windows 10 and the ability to run the same version of the
    Docker Enterprise Engine locally that your organization is running in production.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker最近宣布他们将为Mac和Windows推出Docker桌面企业版。它将拥有与Docker桌面相同的出色用户体验，但支持Windows 10，并能够在本地运行与您的组织在生产中运行的相同版本的Docker企业引擎。
- en: The Dockerfiles and Docker images from your PoC will work in the same way on
    all of these versions. Docker CE, Docker Enterprise Engine, and Universal Control
    Plane all share the same underlying platform.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您的PoC中的Dockerfiles和Docker镜像将在所有这些版本上以相同的方式工作。 Docker CE，Docker Enterprise Engine和Universal
    Control Plane都共享相同的基础平台。
- en: Case studies for implementing Docker
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Docker的案例研究
- en: I'm going to finish this chapter by looking at three real-life case studies,
    where I have brought Docker into existing solutions or prepared a roadmap to bring
    Docker into a project. These are production scenarios, ranging from a small company
    project with tens of users to a large enterprise project with over a million users.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过查看三个真实案例研究来结束本章，这些案例研究中，我已经将Docker引入现有解决方案，或者准备了将Docker引入项目的路线图。这些都是生产场景，从一个有数十个用户的小公司项目到一个拥有超过一百万用户的大型企业项目。
- en: Case study 1 – an in-house WebForms app
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究1 – 一个内部WebForms应用程序
- en: Some years ago, I took on the support of a WebForms app for a vehicle hire company.
    The app was used by a team of about 30, and it was a small-scale deployment—they
    had one server hosting the database and one server running the web app. Although
    small, it was the core application for the business, and everything they did ran
    from this app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我接手了一家汽车租赁公司的WebForms应用程序的支持工作。该应用程序由一个约30人的团队使用，是一个小规模部署——他们有一个托管数据库的服务器和一个运行Web应用程序的服务器。尽管规模小，但这是公司的核心应用程序，他们所有的业务都是通过这个应用程序运行的。
- en: 'The app had a very simple architecture: just one web application and an SQL
    Server database. Initially, I did a lot of work to improve the performance and
    quality of the application. After that, it became a caretaker role, where I would
    manage two or three releases a year, adding new features or fixing old bugs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的架构非常简单：只有一个Web应用程序和一个SQL Server数据库。最初，我做了很多工作来改善应用程序的性能和质量。之后，它变成了一个看护人的角色，我每年会管理两到三次发布，添加新功能或修复旧的错误。
- en: 'These releases were always more difficult and time-consuming than they needed
    to be. The release usually consisted of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些发布总是比必要的更加困难和耗时。发布通常包括以下内容：
- en: A Web Deploy package with the updated application
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有更新应用程序的Web部署包
- en: A set of SQL scripts with schema and data changes
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组带有模式和数据更改的SQL脚本
- en: A manual testing guide to verify the new features and check for regressions
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个手动测试指南，用于验证新功能并检查是否存在回归
- en: The deployment was done outside office hours to give us a window of time to
    fix any problems we found. I would access their services using the **Remote Desktop** **Protocol **(**RDP**),
    copy the artifacts, and manually run the Web Deploy package and the SQL scripts.
    It was usually months between releases, so I'd rely on the documentation that
    I'd written to remind me of the steps. Then, I'd walk through the testing guide
    and check the main features. Sometimes, there were problems because I was missing
    an SQL script or a dependency for the web application, and I'd need to try and
    track down an issue I hadn't seen earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是在办公时间之外进行的，以便我们有时间窗口来解决我们发现的任何问题。我会使用远程桌面协议（RDP）访问他们的服务，复制工件，并手动运行Web部署包和SQL脚本。通常发布之间相隔几个月，所以我会依赖我写的文档来提醒我这些步骤。然后，我会按照测试指南进行测试并检查主要功能。有时，会出现问题，因为我错过了一个SQL脚本或Web应用程序的依赖项，我需要尝试追踪之前未见过的问题。
- en: Until recently, the application was running on Windows Server 2003, which has
    long been out of support. When the company wanted to upgrade Windows, I recommended
    the move to Windows Server 2016 Core and Docker. My suggestion was to use Docker
    to run the web application and leave SQL Server running natively on its own server,
    but use Docker as a distribution mechanism to deploy database upgrades.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，该应用程序一直在运行Windows Server 2003，这个系统早已不再得到支持。当公司想要升级Windows时，我建议使用Windows
    Server 2016 Core和Docker。我的建议是使用Docker来运行Web应用程序，并将SQL Server原生地运行在自己的服务器上，但使用Docker作为部署数据库升级的分发机制。
- en: 'The move to Docker was very simple. I used Image2Docker against the production
    server to produce an initial Dockerfile, and then I iterated on that by adding
    a health check and environment variables for configuration. I already had an SQL
    Server project in Visual Studio for the schema, so I added another Dockerfile
    to package the Dacpac with a deployment script for the database. It took only
    two days to finalize the Docker artifacts and have the new version running in
    a test environment. This was the architecture with Docker:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到Docker非常简单。我使用Image2Docker对生产服务器进行操作，生成了一个初始的Dockerfile，然后通过添加健康检查和环境变量进行迭代。我在Visual
    Studio中已经有了一个SQL Server项目用于架构，所以我添加了另一个Dockerfile来打包Dacpac和数据库的部署脚本。只用了两天就完成了Docker构件，并在测试环境中运行了新版本。这就是Docker的架构：
- en: '![](Images/afda574a-1c76-4071-b661-d169f2139a59.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/afda574a-1c76-4071-b661-d169f2139a59.png)'
- en: '**1**: The web application runs in a Windows Docker container. In production,
    it connects to a separate SQL Server instance. In non-production environments,
    it connects to a local SQL Server instance running in a container.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：Web应用程序在Windows Docker容器中运行。在生产环境中，它连接到一个独立的SQL Server实例。在非生产环境中，它连接到在容器中运行的本地SQL
    Server实例。'
- en: '**2**: The database is packaged into a Docker image based on SQL Server Express
    and deployed with the database schema in a Dacpac. In production, a task container
    is run from the image to deploy the schema to the existing database. In non-production
    environments, a background container is run to host the database.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：数据库被打包成基于SQL Server Express的Docker镜像，并且使用Dacpac中的数据库架构进行部署。在生产环境中，从该镜像中运行一个任务容器来将架构部署到现有数据库。在非生产环境中，运行一个后台容器来托管数据库。'
- en: 'Since then, deployments have been straightforward, and they always follow the
    same steps. We have a set of private repositories on Docker Hub, where the versioned
    application and database images are stored. I configure my local Docker CLI to
    work against their Docker Engine, and then I do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，部署变得简单明了，并且总是遵循相同的步骤。我们在Docker Hub上有一组私有仓库，其中存储了版本化的应用程序和数据库镜像。我配置了我的本地Docker
    CLI来与他们的Docker Engine一起工作，然后我做了以下操作：
- en: Stop the web application container.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止Web应用程序容器。
- en: Run a container from the new database image to upgrade SQL Server.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的数据库镜像中运行一个容器来升级SQL Server。
- en: Use Docker Compose to update the web application to the new image.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker Compose来将Web应用程序更新为新的镜像。
- en: The biggest benefits of moving to Docker have been fast and reliable releases
    and reduced infrastructure requirements. The company is currently looking at replacing
    their current number of large servers with more smaller servers so that they can
    run Docker Swarm  and have zero downtime upgrades.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到Docker的最大好处是快速可靠的发布和减少了基础设施需求。公司目前正在考虑用更多的小型服务器来替换他们当前的大型服务器，以便能够运行Docker
    Swarm并实现零停机升级。
- en: An additional benefit is the simplicity of the release process. Because the
    deployment is already tried and tested, using the same Docker images that are
    going to be used in production, there's no need to have someone who understands
    the app available to track down issues. The company's IT support folks do the
    releases now, and they can do that without my help.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是发布过程的简单性。因为部署已经经过尝试和测试，使用的是将在生产中使用的相同的Docker镜像，所以不需要有人了解该应用程序并跟踪问题。公司的IT支持人员现在负责发布，他们可以在没有我的帮助下完成。
- en: I'm working with the same company again to manage their upgrade to the latest
    Docker Enterprise on Windows Server 2019\. The plan is very simple—I've already
    built their application and database images on top of the latest Windows Server
    2019 Core images and verified that they work with a suite of end-to-end tests.
    Now, they can perform the server upgrades and deploy the new versions using the
    same tools and be confident of a successful release.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次与同一家公司合作，管理他们升级到最新的Windows Server 2019上的Docker Enterprise。计划非常简单 - 我已经在最新的Windows
    Server 2019 Core镜像上构建了他们的应用程序和数据库镜像，并验证它们可以通过一套端到端测试工作。现在，他们可以执行服务器升级并使用相同的工具部署新版本，并对成功发布感到自信。
- en: Case study 2 – a database integration service
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究2 - 数据库集成服务
- en: I worked on a big, complex web application for a financial company. It was an
    internal-facing app that managed very large volumes of trades. The frontend was
    in ASP.NET MVC, but most of the logic was in the service tier, written in WCF.
    The service tier was also a facade over many third-party apps, isolating the integration
    logic in the WCF layer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾为一家金融公司开发一个庞大而复杂的网络应用。这是一个面向内部的应用程序，管理着大量的交易。前端使用的是ASP.NET MVC，但大部分逻辑都在服务层中，使用WCF编写。服务层还是许多第三方应用程序的外观，将集成逻辑隔离在WCF层中。
- en: Most of the third-party apps had XML web services or JSON REST APIs we could
    consume, but one of the older apps had no integration options. We only used it
    for reference data, so the facade was implemented as a database-level integration.
    The WCF service exposed nicely encapsulated endpoints, but the implementation
    connected directly to the external application database to provide the data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数第三方应用程序都有XML Web服务或JSON REST API可供我们使用，但其中一个较老的应用程序没有集成选项。我们只用它作为参考数据，因此外观是作为数据库级别的集成实现的。WCF服务公开了封装良好的端点，但实现直接连接到外部应用程序数据库以提供数据。
- en: Database integration is brittle because you have to rely on a private database
    schema instead of a public service contract, but sometimes there are no other
    options. In this case, the schema changed infrequently, and we could manage the
    disruption. Unfortunately, the release process was back-to-front. The operations
    team would release new versions of database in production first because the app
    only had support from the vendor in production. When it was all working, they
    would replicate the release in the dev and test environments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库集成是脆弱的，因为你必须依赖私有数据库架构而不是公共服务契约，但有时别无选择。在这种情况下，架构变化不频繁，我们可以管理这种中断。不幸的是，发布过程是反向的。运营团队首先会在生产环境中发布数据库的新版本，因为该应用程序只在生产环境中得到供应商的支持。当一切正常时，他们会在开发和测试环境中复制发布。
- en: One release had a database schema change that broke our integration. Any features
    that used the reference data from the third-party app stopped working, and we
    had to get a fix out as quickly as possible. The fix was straightforward, but
    the WCF app was a large monolith and it needed a lot of regression testing before
    we could be confident that this change didn't impact other areas. I was tasked
    with looking at Docker as a better way of managing the database dependency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个发布中有一个数据库架构的变化破坏了我们的集成。任何使用第三方应用程序的参考数据的功能都停止工作了，我们必须尽快进行修复。修复很简单，但WCF应用程序是一个庞大的单体，需要大量的回归测试，才能确保这个变化不会影响其他领域。我被要求考虑Docker作为更好地管理数据库依赖的方法。
- en: 'The proposal was straightforward. I didn''t recommend moving the whole app
    to Docker—that was already on a longer-term roadmap—but just moving one service
    into Docker. The WCF endpoint for that was that the database app facade would
    run in Docker, isolated from the rest of the application. The web application
    was the only consumer of the service, so it would just be a case of changing the
    URL for the service in the consumer. This is the proposed architecture:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该提案很简单。我并不建议将整个应用程序移至Docker——这已经在长期路线图上了——而只是将一个服务移至Docker。该服务的WCF端点是数据库应用程序外观将在Docker中运行，与应用程序的其余部分隔离。Web应用程序是该服务的唯一消费者，因此只需更改消费者中服务的URL。这是拟议的架构：
- en: '![](Images/9b9125c5-a000-4378-8ddb-4f28f19f0ea8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b9125c5-a000-4378-8ddb-4f28f19f0ea8.png)'
- en: '**1**: The web application runs in IIS. The code is unchanged, but the configuration
    is updated to use the URL for the new integration component, running in a container.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：Web应用程序在IIS中运行。代码没有更改，但配置已更新为使用在容器中运行的新集成组件的URL。'
- en: '**2**: The original WCF services continue to run in IIS but with the previous
    database integration component removed.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：原始的WCF服务继续在IIS中运行，但之前的数据库集成组件已被移除。'
- en: '**3**: The new integration component uses the same WCF contract as earlier,
    but now it is hosted in a container, isolating access to the third-party application
    database.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**：新的集成组件使用与之前相同的WCF合同，但现在它是在容器中托管的，隔离对第三方应用程序数据库的访问。'
- en: 'This approach has a lot of benefits:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有很多好处：
- en: If the database schema changes, we only need to change the Dockerized service
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据库架构发生变化，我们只需要更改Docker化的服务
- en: Service changes can be released without a full application release just by updating
    the Docker image
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务更改可以通过更新Docker镜像而无需进行完整的应用程序发布来发布
- en: It is a sandboxed introduction to Docker, so the dev and ops teams can use it
    for evaluation
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个关于Docker的沙盒介绍，因此开发和运维团队可以用它进行评估。
- en: In this case, the most important benefit was the reduced amount of testing effort.
    For the full monolithic app, a release needs several weeks of testing. By breaking
    out the services into Docker containers, only the services that have changed need
    testing for the release. This drastically reduces the amount of time and effort
    that's needed, which allows for more frequent releases, thus getting new features
    out to the business more quickly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最重要的好处是减少了测试工作量。对于完整的单片应用程序，发布需要数周的测试。通过将服务拆分为Docker容器，只有发生变化的服务需要进行发布的测试。这大大减少了所需的时间和精力，从而可以更频繁地发布，从而更快地将新功能推出到业务中。
- en: Case study 3 – an Azure IoT app
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究3 - Azure IoT应用程序
- en: I was the API architect on a project for delivering backend services that were
    consumed by a mobile application. There were two main APIs. The configuration
    API was read-only, and the devices called it to check for updates to settings
    and software. The events API was write-only, and the devices posted anonymous
    events about user behavior, which the product team used to inform design decisions
    for the next generation of devices.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个项目的API架构师，负责提供移动应用程序消费的后端服务。有两个主要的API。配置API是只读的，设备调用它来检查设置和软件的更新。事件API是只写的，设备发布关于用户行为的匿名事件，产品团队用这些事件来指导下一代设备的设计决策。
- en: 'The APIs supported over 1.5 million devices. The configuration APIs needed
    high availability; they had to respond quickly to device calls and scale to thousands
    of concurrent requests per second. The events APIs consumed data from the devices
    and pushed events to a message queue. Listening on the queue were two sets of
    handlers: one that stored all event data in Hadoop, for long-term analysis, and
    one that stored a subset of events to provide real-time dashboards.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API支持超过150万台设备。配置API需要高可用性；它们必须快速响应设备调用，并能够扩展到每秒数千个并发请求。事件API从设备消费数据并将事件推送到消息队列。在队列上有两组处理程序：一组将所有事件数据存储在Hadoop中，用于长期分析，另一组将事件的子集存储以提供实时仪表板。
- en: 'All the components ran in Azure, and at the peak of the project, we were using
    cloud services, Event Hubs, SQL Azure, and HDInsight. The architecture looked
    like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都在Azure上运行，在项目的高峰期，我们使用了云服务、事件中心、SQL Azure和HDInsight。架构如下：
- en: '![](Images/3994e8aa-c9c8-4b64-9aff-705bd5816469.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3994e8aa-c9c8-4b64-9aff-705bd5816469.png)'
- en: '**1**: The events API was hosted in a cloud service with multiple instances.
    Devices posted events to the API, which does some pre-processing and posts them
    in batches to an Azure Event Hub.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：事件API托管在一个云服务中，有多个实例。设备将事件发布到API，API进行一些预处理，然后将它们批量发布到Azure事件中心。'
- en: '**2**: The Configuration API was also hosted in a Cloud Service with multiple
    instances. Devices connect to the API to check software updates and configuration
    settings.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：配置API也托管在一个云服务中，有多个实例。设备连接到API以检查软件更新和配置设置。'
- en: '**3**: Real-time analytics data, which is used for a subset of key performance
    indicators. This was stored in SQL Azure for fast access, as these are modest
    quantities of data.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**：实时分析数据，用于一些关键性能指标的子集。这些数据存储在SQL Azure中，以便快速访问，因为这些数据量是适度的。'
- en: '**4**: Batch analytics data for storing all the events that are posted by all
    devices. This was stored in HDInsight, the managed Hadoop service on Azure for
    long-running Big Data queries.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4**：批处理分析数据，用于存储所有设备发布的事件。这些数据存储在HDInsight中，这是Azure上的托管Hadoop服务，用于长时间运行的大数据查询。'
- en: This system was expensive to run, but it gave the product team a lot of information
    on how the devices were used, which they fed into the design process for the next
    generation. Everyone was happy, but then the product roadmap was canceled and
    there weren't going to be any more devices, so we had to cut running costs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的运行成本很高，但它为产品团队提供了大量关于设备使用情况的信息，他们将这些信息输入到下一代设计过程中。每个人都很高兴，但后来产品路线被取消了，不会再有任何设备，所以我们不得不削减运行成本。
- en: I had the job of reducing the Azure bill from $50K per month to under $1K per
    month. I could lose some of the reporting features, but the events API and configuration
    API had to stay highly available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我的工作是将Azure账单从每月5万美元降低到每月不到1千美元。我可以放弃一些报告功能，但事件API和配置API必须保持高可用性。
- en: 'This happened before Docker was available on Windows, so my first revision
    of the architecture used Linux containers running on a Docker Swarm in Azure.
    I replaced the analytics side of the system with Elasticsearch and Kibana and
    replaced the configuration API with static content served from Nginx. I left the
    custom .NET components running in cloud services for the events API feeding Azure
    Event Hubs with device data and the message handler pushing data to Elasticsearch:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上可用Docker之前发生了这件事，所以我对架构进行了第一次修订，使用在Azure中运行的Docker Swarm上的Linux容器。我用Elasticsearch和Kibana替换了系统的分析部分，并用Nginx提供了静态内容的配置API。我将自定义的.NET组件留在云服务中，用于从设备数据提供给Azure事件中心的事件API和将数据推送到Elasticsearch的消息处理程序。
- en: '![](Images/97b221e5-2481-43c2-b9b2-1e18a1bc3581.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/97b221e5-2481-43c2-b9b2-1e18a1bc3581.png)'
- en: '**1**: The Configuration API, now running as a static website in Nginx. Configuration
    data is served as JSON payloads, maintaining the original API contract.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：配置API现在作为Nginx中的静态网站运行。配置数据以JSON负载的形式提供，保持原始API契约。'
- en: '**2**: Kibana is used for real-time and historical analytics. By reducing the
    amount of data stored, we reduced the data storage requirements significantly,
    at the cost of losing detailed metrics.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：Kibana用于实时和历史分析。通过减少存储的数据量，我们显著减少了数据存储需求，但代价是失去了详细的指标。'
- en: '**3**: Elasticsearch was used to store incoming event data. A .NET Cloud Service
    is still used to read from Event Hubs, but this version saves data in Elasticsearch.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**：Elasticsearch被用来存储传入的事件数据。仍然使用.NET云服务从事件中心读取数据，但这个版本将数据保存在Elasticsearch中。'
- en: This first revision gave us the cost savings we needed, mainly by reducing the
    number of nodes needed for the APIs and the amount of data we stored from the
    devices. Instead of storing everything in Hadoop and real-time data in SQL Azure,
    I centralized on Elasticsearch and stored just a small subset of the data. Using
    Nginx to serve the configuration APIs, we lost the user-friendly features that
    the product team had for publishing configuration updates, but we could run with
    far smaller compute resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个修订版为我们带来了我们需要的成本节约，主要是通过减少API所需的节点数量和从设备中存储的数据量。我将所有数据都集中存储在Elasticsearch中，而不是在Hadoop中存储所有数据和在SQL
    Azure中存储实时数据的做法。使用Nginx来提供配置API，我们失去了产品团队为发布配置更新而拥有的用户友好功能，但我们可以使用更小的计算资源运行。
- en: 'I oversaw a second revision, when Windows Server 2016 launched and Docker on
    Windows was supported. I added Windows nodes to the existing Linux nodes in the
    Docker Swarm and migrated the events API and message handlers over to Windows
    Docker containers. At the time, I also moved the messaging system over to NATS,
    running in a Linux container:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows Server 2016推出并且Windows上的Docker得到支持时，我进行了第二次修订。我在Docker Swarm中添加了现有Linux节点的Windows节点，并将事件API和消息处理程序迁移到了Windows
    Docker容器中。同时，我还将消息系统迁移到了在Linux容器中运行的NATS：
- en: '![](Images/3243f6ae-0f38-4885-a699-aee1112ae2f5.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3243f6ae-0f38-4885-a699-aee1112ae2f5.png)'
- en: '**1**: The Events API is now hosted in a Docker container, but the code hasn''t
    changed; this is still an ASP.NET web API project, running in a Windows container.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：事件API现在托管在Docker容器中，但代码没有改变；这仍然是一个在Windows容器中运行的ASP.NET Web API项目。'
- en: '**2**: The messaging component is using NATS instead of Event Hubs. We lose
    the ability to store and reprocess messages, but the message queue now has the
    same availability as the Events API.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：消息组件使用NATS而不是事件中心。我们失去了存储和重新处理消息的能力，但消息队列现在具有与事件API相同的可用性。'
- en: '**3**: The message handler reads from NATS and saves data in Elasticsearch.
    The majority of the code is unchanged, but it now runs as a .NET console app in
    a Windows container.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**：消息处理程序从NATS读取数据并将数据保存在Elasticsearch中。大部分代码保持不变，但现在它作为一个.NET控制台应用在Windows容器中运行。'
- en: 'This second revision further reduced costs and complexity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二次修订进一步降低了成本和复杂性：
- en: Every component is now running in Docker, so I can replicate the whole system
    in development
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在每个组件都在Docker中运行，所以我可以在开发中复制整个系统
- en: All components are built with Dockerfiles and packaged as Docker images, so
    everything uses the same artifacts
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有组件都使用Dockerfiles构建并打包为Docker镜像，因此一切都使用相同的构件
- en: The whole solution has the same level of service, running efficiently on a single
    Docker Swarm
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个解决方案具有相同级别的服务，在单个Docker Swarm上高效运行
- en: In this case, the project is destined to wind down, and it will be easy to accommodate
    that with the new solution. Device usage is still recorded and shown with a Kibana
    dashboard. As fewer devices are used over time, the services need less compute,
    and we can remove nodes from the swarm. Ultimately, the project will run on a
    minimal infrastructure, possibly just a two-node swarm, running on small VMs in
    Azure, or it could move back into the company's data center.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该项目注定要逐渐减少，并且很容易通过新解决方案进行适应。设备使用仍然记录并显示在Kibana仪表板上。随着时间的推移，使用的设备越来越少，服务需要的计算量也越来越少，我们可以从Swarm中删除节点。最终，该项目将在最小的基础设施上运行，可能只是一个双节点Swarm，在Azure的小型VM上运行，或者它可以迁回公司的数据中心。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Large and small companies all over the world are moving to Docker on Windows
    and Linux. Some of the main drivers are efficiency, security, and portability.
    Many new projects are designed from the ground up using containers, but there
    are many more existing projects that would benefit from the move to Docker.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 全世界的大大小小公司都在Windows和Linux上转向Docker。一些主要的驱动因素是效率、安全性和可移植性。许多新项目都是使用容器从头开始设计的，但还有许多现有项目可以从迁移到Docker中受益。
- en: In this chapter, I've looked at migrating existing apps to Docker on Windows,
    recommending that you start with an application you know well. A short, time-boxed
    PoC for Dockerizing that app will quickly show you what your app looks like in
    Docker. The outcome of that PoC will help you understand what you need to do next
    and who you need to involve to get that PoC moved into production.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我已经研究了将现有应用迁移到Windows上的Docker，并建议您从您熟悉的应用程序开始。对该应用程序进行短期、限时的Docker化概念验证将迅速向您展示您的应用在Docker中的样子。该概念验证的结果将帮助您了解接下来需要做什么，以及需要谁参与将该概念验证移入生产环境。
- en: I finished with some very different cases studies, showing you how you can introduce
    Docker in existing projects. In one case, I used Docker primarily for the packaging
    benefits to run a monolithic app without changing it, but to power clean upgrades
    for future releases. In another case, I took one component from a monolithic app
    and extracted it to run in a container, in order to reduce the testing burden
    for releases. In the last case, I completely migrated an existing solution to
    Docker, making it cheaper to run, easier to maintain, and giving me the option
    to run it anywhere.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我完成了一些非常不同的案例研究，向您展示了如何在现有项目中引入Docker。在一个案例中，我主要利用Docker的打包优势来运行一个单片应用，而不对其进行更改，但为将来的发布提供干净的升级。在另一个案例中，我从单片应用中提取了一个组件并将其提取到容器中，以减少发布的测试负担。在最后一个案例中，我完全将现有解决方案迁移到Docker，使其更便宜，更易于维护，并为我提供了在任何地方运行它的选项。
- en: I hope this chapter has helped you think about how you can introduce Docker
    into your own projects, and I hope the rest of this book has shown you what you
    can do with Docker and why it's such an exciting technology. Thanks for reading,
    make sure to check out my Pluralsight courses and follow me on Twitter, and good
    luck in your journey with Docker on Windows!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章能帮助您思考如何将Docker引入您自己的项目中，也希望本书的其余部分能向您展示您可以用Docker做什么，以及为什么它是一项如此令人兴奋的技术。感谢阅读，请务必查看我的Pluralsight课程，并在Twitter上关注我，在Windows上使用Docker的旅程中祝您好运！
