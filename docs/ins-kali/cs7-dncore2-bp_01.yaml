- en: eBook Manager and Catalogue App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子书管理器和目录应用程序
- en: C# 7 is a fantastic release and is available in Visual Studio 2017\. It introduces
    developers to a lot of powerful features, some of which were previously only available
    in other languages. The new features introduced in C# 7 allow developers to write
    less code and be more productive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7是一个很棒的版本，可在Visual Studio 2017中使用。它向开发人员介绍了许多强大的功能，其中一些以前只在其他语言中可用。C# 7引入的新功能使开发人员能够编写更少的代码，提高生产力。
- en: 'The features available are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的功能有：
- en: Tuples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Pattern matching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '`Out` variables'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Out”变量
- en: Deconstruction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构
- en: Local functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数
- en: Improvements to literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字改进
- en: Ref returns and locals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用返回和本地变量
- en: Generalized async and return types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛化的异步和返回类型
- en: Expression bodies for accessors, constructors, and finalizers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器、构造函数和终结器的表达式体
- en: Throw expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出表达式
- en: This chapter will take you through some of these features, while the rest of
    the book will introduce you to some of the other features as we go along. In this
    chapter, we will create an `eBookManager` application. If you are like me, you
    have eBooks scattered all over your hard drives and some external drives as well.
    This application will provide a mechanism to bring all these various locations
    together into a Virtual Storage Space. The application is functional, but can
    be further enhanced to suit your needs. The scope for an application such as this
    is vast. You can download the source code from GitHub ([https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints))
    and follow it to see some of the new features of C# 7 in action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍其中一些功能，而本书的其余部分将在学习过程中介绍其他功能。在本章中，我们将创建一个“eBookManager”应用程序。如果您和我一样，在硬盘和一些外部驱动器上散落着电子书，那么这个应用程序将提供一种机制，将所有这些不同的位置汇集到一个虚拟存储空间中。该应用程序是功能性的，但可以进一步增强以满足您的需求。这样的应用程序范围是广阔的。您可以从GitHub（[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints)）下载源代码，并跟随它，看看C#
    7的一些新功能是如何运作的。
- en: Let's begin!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Setting up the project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Using Visual Studio 2017, we will create a simple Windows Forms App template
    project. You can call the application anything you like, but I called mine `eBookManager`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2017，我们将创建一个简单的Windows窗体应用程序模板项目。您可以随意命名应用程序，但我将其命名为“eBookManager”：
- en: '![](img/ade7f9fc-3db8-4ea4-b8c7-0e5fe8dc5ddd.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ade7f9fc-3db8-4ea4-b8c7-0e5fe8dc5ddd.png)'
- en: 'The project will be created and will look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将被创建，并将如下所示：
- en: '![](img/d6f1b4b1-aa41-4d72-be7d-fb8ae2c5d455.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6f1b4b1-aa41-4d72-be7d-fb8ae2c5d455.png)'
- en: 'Our Solution needs a Class Library project to contain the classes that drive
    the `eBookManager` application. Add a new Class Library project to your Solution
    and call it `eBookManager.Engine`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案需要一个类库项目来包含驱动“eBookManager”应用程序的类。在解决方案中添加一个新的类库项目，并将其命名为“eBookManager.Engine”：
- en: '![](img/074b1507-958b-47fc-8f1a-d6c028346f27.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/074b1507-958b-47fc-8f1a-d6c028346f27.png)'
- en: 'A Class Library project is added to the Solution with the default class name.
    Change this class to `Document`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将解决方案添加到类库项目中，默认类名更改为“Document”：
- en: '![](img/d19a9066-c506-4932-8ffa-17d1b6bfaedc.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d19a9066-c506-4932-8ffa-17d1b6bfaedc.png)'
- en: The `Document` class will represent a single eBook. Thinking of a book, we can
    have multiple properties that would represent a single book, but be representative
    of all books. An example of this would be the author. All books must have an author,
    otherwise it would not exist.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “Document”类将代表一本电子书。想到一本书，我们可以有多个属性来代表一本书，但又代表所有书籍。一个例子是作者。所有书籍都必须有作者，否则它就不存在。
- en: I know some of you might be thinking that machines could generate documents
    too, but the information it generates was probably originally written by a person.
    Take code comments for example. A developer writes the comments in code, and a
    tool generates a document from that. The developer is still the author.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有些人可能会认为机器也可以生成文档，但它生成的信息可能最初是由人写的。以代码注释为例。开发人员在代码中编写注释，工具从中生成文档。开发人员仍然是作者。
- en: The properties I have added to the class are merely my interpretation of what
    might represent a book. Feel free to add additional code to make this your own.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加到类中的属性仅仅是我认为可能代表一本书的解释。请随意添加其他代码，使其成为您自己的。
- en: 'Open the `Document.cs` file and add the following code to the class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“Document.cs”文件，并将以下代码添加到类中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that I have included a property called `Classification` of type
    `DeweyDecimal`. We have not added this class yet, and will do so next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我包括了一个名为“Classification”的属性，类型为“DeweyDecimal”。我们还没有添加这个类，接下来会添加。
- en: 'To the `eBookManager.Engine` project, add a class called `DeweyDecimal`. If
    you don''t want to go to this level of classification for your eBooks, you can
    leave this class out. I have included it for the sake of completeness:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在“eBookManager.Engine”项目中，添加一个名为“DeweyDecimal”的类。如果您不想为您的电子书进行这种分类，可以不添加这个类。我包括它是为了完整起见。
- en: '![](img/505f9689-7e75-45a1-ac2e-90f997d423bc.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/505f9689-7e75-45a1-ac2e-90f997d423bc.png)'
- en: 'Your `DeweyDecimal` class must be in the same project as the `Document` class
    added earlier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的“DeweyDecimal”类必须与之前添加的“Document”类在同一个项目中：
- en: '![](img/d21a2328-fe07-4c99-9207-e7fdb7aee38c.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d21a2328-fe07-4c99-9207-e7fdb7aee38c.png)'
- en: The `DeweyDecimal` system is quite big. For this reason, I have not catered
    for every book classification available. I have also only assumed that you would
    want to be working with programming eBooks. In reality, however, you may want
    to add in other classifications, such as literature, the sciences, the arts, and
    so on. It is up to you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “杜威十进制”系统非常庞大。因此，我没有考虑到每种书籍分类。我也只假设您想要处理编程电子书。然而，实际上，您可能想要添加其他分类，如文学、科学、艺术等。这取决于您。
- en: 'So let''s create a class to represent the Dewey Decimal system::'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们创建一个代表杜威十进制系统的类：
- en: 'Open up the `DeweyDecimal` class and add the following code to the class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DeweyDecimal`类并将以下代码添加到类中：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Word nerds may disagree with me here, but I would like to remind them that I'm
    a code nerd. The classifications represented here are just so that I can catalog
    programming and computer science-related eBooks. As mentioned earlier, you can
    change this to suit your needs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字母狂人可能会不同意我的观点，但我想提醒他们，我是一个代码狂人。这里表示的分类只是为了让我能够编目与编程和计算机科学相关的电子书。如前所述，您可以根据自己的需要进行更改。
- en: 'We now need to add in the heart of the `eBookManager.Engine` Solution. This
    is a class called `DocumentEngine` and it will be a class that will contain the
    methods you need to work with the documents:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要在`eBookManager.Engine`解决方案的核心中添加。这是一个名为`DocumentEngine`的类，它将是一个包含您需要处理文档的方法的类：
- en: '![](img/d2cacf4e-425d-48ba-8b6e-b54c93db28fe.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2cacf4e-425d-48ba-8b6e-b54c93db28fe.png)'
- en: 'Your `eBookManager.Engine` Solution will now contain the following classes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`eBookManager.Engine`解决方案现在将包含以下类：
- en: '`DeweyDecimal`'
  id: totrans-42
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeweyDecimal`'
- en: '`Document`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Document`'
- en: '`DocumentEngine`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocumentEngine`'
- en: '![](img/1a779efd-e56b-49df-b3d1-b419fdb71258.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a779efd-e56b-49df-b3d1-b419fdb71258.png)'
- en: 'We now need to add a reference to `eBookManager.Engine` from the `eBookManager`
    project. I''m sure that you all know how to do this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要从`eBookManager`项目中添加对`eBookManager.Engine`的引用。我相信你们都知道如何做到这一点：
- en: '![](img/0d58c2d1-d2d6-44b1-9003-e98f2910f514.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d58c2d1-d2d6-44b1-9003-e98f2910f514.png)'
- en: 'The `eBookManager.Engine` project will be available under the Projects section
    in the Reference Manager screen:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`eBookManager.Engine`项目将在引用管理器屏幕的项目部分中可用：'
- en: '![](img/3077c08c-964a-4df0-a3ff-2e94f13733e0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3077c08c-964a-4df0-a3ff-2e94f13733e0.png)'
- en: 'Once we have added the reference, we need a Windows Form that will be responsible
    for importing new books. Add a new form called `ImportBooks` to the `eBookManager`
    Solution:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了引用后，我们需要一个负责导入新书籍的Windows表单。在`eBookManager`解决方案中添加一个名为`ImportBooks`的新表单：
- en: '![](img/3fb2a00a-dd6b-443e-aea3-f45855b51aec.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb2a00a-dd6b-443e-aea3-f45855b51aec.png)'
- en: Before we forget, add an `ImageList` control to the `ImportBooks` form and call
    it `tvImages`. This will contain the images for the different types of documents
    we want to catalog.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们忘记之前，向`ImportBooks`表单添加一个`ImageList`控件，并将其命名为`tvImages`。这将包含我们想要编目的不同类型文档的图像。
- en: The `ImageList` is a control you add from the Toolbox on to the `ImportBooks`
    form. You can access the Images Collection Editor from the `ImageList` properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageList`是您从工具箱添加到`ImportBooks`表单上的控件。您可以从`ImageList`属性访问图像集合编辑器。'
- en: The icons can be found in the `img` folder in the source code downloadable from
    GitHub at the following URL—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图标可以在GitHub上可下载的源代码的`img`文件夹中找到，网址为[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints)。
- en: 'The icons here are catering for PDF, MS Word, and ePub file types. It also
    contains folder images:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图标适用于PDF、MS Word和ePub文件类型。它还包含文件夹图像：
- en: '![](img/c9767272-01b8-47e1-818b-6c8fb5db1a32.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9767272-01b8-47e1-818b-6c8fb5db1a32.png)'
- en: Now, to use tuples in C# 7, you need to add the `System.ValueTuple` NuGet package.
    Right-click on your Solution and select Manage NuGet Packages for Solution...
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在C# 7中使用元组，您需要添加`System.ValueTuple` NuGet包。右键单击解决方案，然后选择管理解决方案的NuGet包...
- en: Please note that if you are running the .NET Framework 4.7, `System.ValueTuple`
    is included in this version of the framework. You will therefore not need to get
    it from NuGet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您正在运行.NET Framework 4.7，则`System.ValueTuple`已包含在该框架版本中。因此，您将不需要从NuGet获取它。
- en: '![](img/2497780d-23bd-4ad4-8652-5a213b6c65e4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2497780d-23bd-4ad4-8652-5a213b6c65e4.png)'
- en: 'Search for `System.ValueTuple` and add it to your Solution projects. Then click
    Install and let the process complete (you will see the progress in the output
    window in Visual Studio):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`System.ValueTuple`并将其添加到您的解决方案项目中。然后单击安装，让进程完成（您将在Visual Studio的输出窗口中看到进度）：
- en: '![](img/70de0865-a9b2-43db-99df-9133fb4459d2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70de0865-a9b2-43db-99df-9133fb4459d2.png)'
- en: 'I love making use of extension methods in my projects. I usually add a separate
    project and/or class for this purpose. In this application, I added an `eBookManager.Helper`
    class library project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在我的项目中使用扩展方法。我通常为此目的添加一个单独的项目和/或类。在这个应用程序中，我添加了一个`eBookManager.Helper`类库项目：
- en: '![](img/6252e916-0d45-49c9-8058-79975d06054d.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6252e916-0d45-49c9-8058-79975d06054d.png)'
- en: 'This helper class must also be added to the `eBookManager` Solution as a reference:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个帮助类也必须作为引用添加到`eBookManager`解决方案中：
- en: '![](img/0c1750f1-688f-47d9-a836-4c60109dd1df.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c1750f1-688f-47d9-a836-4c60109dd1df.png)'
- en: 'Lastly, I will be using JSON as a simple file store for my eBook catalogue.
    JSON is really flexible and can be consumed by various programming languages.
    What makes JSON so nice is the fact that it is relatively light weight and the
    output it generates is human-readable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将使用JSON作为我的电子书目录的简单文件存储。JSON非常灵活，可以被各种编程语言消耗。JSON之所以如此好用，是因为它相对轻量级，生成的输出是人类可读的：
- en: '![](img/12a59967-de8b-4831-a04e-d6224481671a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12a59967-de8b-4831-a04e-d6224481671a.png)'
- en: Go to Manage the NuGet packages for your Solution and search for `Newtonsoft.Json`.
    Add this then to the projects in your Solution and click the Install button.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到解决方案的NuGet包管理器并搜索`Newtonsoft.Json`。然后将其添加到解决方案中的项目并单击安装按钮。
- en: You have now set up the basics needed for your `eBookManager` application. Next,
    we will venture further into the guts of the application by writing some code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经设置了`eBookManager`应用程序所需的基本内容。接下来，我们将通过编写一些代码进一步深入应用程序的核心。
- en: Virtual Storage Spaces and extension methods
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟存储空间和扩展方法
- en: 'Let''s start by discussing the logic behind a Virtual Storage Space. This is
    a single virtual representation of several physical spaces on your hard drive
    (or hard drives). A storage space will be seen as a single area where a specific
    group of eBooks are *stored*. I use the term *stored* loosely because the storage
    space doesn''t exist. It represents more of a grouping than a physical space on
    the hard drive:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论虚拟存储空间背后的逻辑。这是硬盘（或硬盘）上几个物理空间的单一虚拟表示。存储空间将被视为一个特定的电子书组*存储*的单一区域。我使用术语*存储*是因为存储空间并不存在。它更多地代表了一种分组，而不是硬盘上的物理空间：
- en: 'To start creating Virtual Storage Spaces, add a new class called `StorageSpace`
    to the `eBookManager.Engine` project. Open the `StorageSpace.cs` file and add
    the following code to it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始创建虚拟存储空间，将一个名为`StorageSpace`的新类添加到`eBookManager.Engine`项目中。打开`StorageSpace.cs`文件，并向其中添加以下代码：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that you need to include the `System.Collections.Generic` namespace here,
    because the `StorageSpace` class contains a property called `BookList` of type
    `List<Document>` that will contain all the books in that particular storage space.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要在这里包含`System.Collections.Generic`命名空间，因为`StorageSpace`类包含一个名为`BookList`的属性，类型为`List<Document>`，它将包含该特定存储空间中的所有书籍。
- en: Now we need to focus our attention on the `ExtensionMethods` class in the `eBookManager.Helper`
    project. This will be a static class, because extension methods need to be static
    in nature in order to act on the various objects defined by the extension methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要把注意力集中在`eBookManager.Helper`项目中的`ExtensionMethods`类上。这将是一个静态类，因为扩展方法需要以静态的方式来作用于扩展方法定义的各种对象。
- en: 'Add a new class to the `eBookManager.Helper` project and modify the `ExtensionMethods`
    class as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`eBookManager.Helper`项目中添加一个新类，并修改`ExtensionMethods`类如下：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's add the first extension method to the class called `ToInt()`. What this
    extension method does is take a `string` value and try to parse it to an `integer`
    value. I am too lazy to type `Convert.ToInt32(stringVariable)` whenever I need
    to convert a `string` to an `integer`. It is for this reason that I use an extension
    method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一个扩展方法添加到名为`ToInt()`的类中。这个扩展方法的作用是获取一个`string`值并尝试将其解析为一个`integer`值。每当我需要将`string`转换为`integer`时，我都懒得输入`Convert.ToInt32(stringVariable)`。正因为如此，我使用了一个扩展方法。
- en: 'Add the following static method to the `ExtensionMethods` class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ExtensionMethods`类中添加以下静态方法：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ToInt()` extension method acts only on `string`. This is defined by the
    code `this string value` in the method signature where `value` is the variable
    name that will contain the `string` you are trying to convert to an `integer`.
    It also has a default parameter called `defaultInteger`, which is set to `0.`
    Unless the developer calling the extension method wants to return a default integer
    value of `0`, they can pass a different integer to this extension method (`-1`,
    for example).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToInt()`扩展方法仅对`string`起作用。这是由方法签名中的`this string value`代码定义的，其中`value`是将包含您要转换为`integer`的`string`的变量名称。它还有一个名为`defaultInteger`的默认参数，设置为`0`。除非调用扩展方法的开发人员想要返回默认的整数值`0`，否则他们可以将不同的整数传递给这个扩展方法（例如`-1`）。'
- en: 'It is also here that we find our first feature of C# 7\. The improvement to
    `out` variables. In previous iterations of C#, we had to do the following with
    `out` variables:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们发现C# 7的第一个特性的地方。改进了`out`变量。在以前的C#版本中，我们必须对`out`变量执行以下操作：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There was this predeclared integer variable hanging around and it gets its
    value if the `string` value parsed to an `integer`. C# 7 simplifies the code a
    lot more:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个预声明的整数变量挂在那里，如果`string`值解析为`integer`，它就会得到它的值。C# 7简化了代码：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'C# 7 allows developers to declare an `out` variable right there where it is
    passed as an `out` argument. Moving along to the other methods of the `ExtensionMethods`
    class, these methods are used to provide the following logic:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7允许开发人员在作为`out`参数传递的地方声明一个`out`变量。继续讨论`ExtensionMethods`类的其他方法，这些方法用于提供以下逻辑：
- en: '`Read` and `write` to the data source'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`读取`和`写入`到数据源'
- en: Check whether a storage space exists
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查存储空间是否存在
- en: Convert bytes to megabytes
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节转换为兆字节
- en: Convert a `string` to an `integer` (as discussed previously)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`string`转换为`integer`（如前所述）
- en: 'The `ToMegabytes` method is quite easy. Not having to write this calculation
    all over the place, defining it inside an extension method makes sense:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToMegabytes`方法非常简单。在各个地方都不必写这个计算，将其定义在一个扩展方法中是有意义的：'
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We also need a way to check if a particular storage space already exists.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来检查特定的存储空间是否已经存在。
- en: Be sure to add a project reference to `eBookManager.Engine` from the `eBookManager.Helper`
    project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保从`eBookManager.Helper`项目中向`eBookManager.Engine`添加项目引用。
- en: 'What this extension method also does is to return the next storage space ID
    to the calling code. If the storage space does not exist, the returned ID will
    be the next ID that can be used when creating a new storage space:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展方法的作用也是返回下一个存储空间ID给调用代码。如果存储空间不存在，返回的ID将是在创建新存储空间时可以使用的下一个ID：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also need to create a method that will `write` the data we have to a file
    after converting it to JSON:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个方法，将我们的数据转换为JSON后写入文件：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is rather self-explanatory. It acts on a `List<StorageSpace>` object
    and will create the JSON data, overwriting a file defined in the `storagePath`
    variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法相当不言自明。它作用于一个`List<StorageSpace>`对象，并将创建JSON数据，覆盖在`storagePath`变量中定义的文件中。
- en: 'Lastly, we need to be able to `read` the data back again into a `List<StorageSpace>`
    object and return that to the calling code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要能够再次将数据读取到`List<StorageSpace>`对象中，并将其返回给调用代码：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method will return an empty `List<StorageSpace>` object and nothing is contained
    in the file. The `ExtensionMethods` class can contain many more extension methods
    that you might use often. It is a great way to separate often-used code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将返回一个空的“List<StorageSpace>”对象，并且文件中不包含任何内容。“ExtensionMethods”类可以包含许多您经常使用的扩展方法。这是一个很好的分离经常使用的代码的方法。
- en: The DocumentEngine class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DocumentEngine类
- en: The purpose of this class is merely to provide supporting code to a document.
    In the `eBookManager` application, I am going to use a single method called `GetFileProperties()`
    that will (you guessed it) return the properties of a selected file. This class
    also only contains this single method. As the application is modified for your
    specific purposes, you can modify this class and add additional methods specific
    to documents.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的目的仅仅是为文档提供支持代码。在“eBookManager”应用程序中，我将使用一个名为“GetFileProperties()”的单一方法，它将（你猜对了）返回所选文件的属性。这个类也只包含这一个方法。当应用程序根据您的特定目的进行修改时，您可以修改这个类并添加特定于文档的其他方法。
- en: The `DocumentEngine` class introduces us to the next feature of C# 7 called
    **tuples**. What do tuples do exactly? It is often a requirement for a developer
    to return more than a single value from a method. Among other Solutions, you can
    of course use `out` parameters, but these do not work in `async` methods. Tuples
    provide a better way to do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “DocumentEngine”类向我们介绍了C# 7的下一个特性，称为“元组”。元组到底是做什么的？开发人员经常需要从方法中返回多个值。除了其他解决方案外，当然可以使用“out”参数，但这在“async”方法中不起作用。元组提供了更好的方法来做到这一点。
- en: 'Inside the `DocumentEngine` class, add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在“DocumentEngine”类中添加以下代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GetFileProperties()` method returns a tuple as `(DateTime dateCreated,
    DateTime dateLastAccessed, string fileName, string fileExtension, long fileLength,
    bool error)` and allows us to inspect the values returned from the calling code
    easily.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “GetFileProperties()”方法返回一个元组，格式为“(DateTime dateCreated, DateTime dateLastAccessed,
    string fileName, string fileExtension, long fileLength, bool error)”，并且允许我们轻松地检查从调用代码返回的值。
- en: 'Before I try to get the properties of the specific file, I initialize the `tuple`
    by doing the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试获取特定文件的属性之前，我通过以下方式初始化“元组”：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If there is an exception, I can return default values. Reading the file properties
    is simple enough using the `FileInfo` class. I can then assign the file properties
    to the `tuple` by doing this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现异常，我可以返回默认值。使用“FileInfo”类读取文件属性非常简单。然后我可以通过以下方式将文件属性分配给“元组”：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `tuple` is then returned to the calling code where it will be used as required.
    We will have a look at the calling code next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将“元组”返回给调用代码，在那里将根据需要使用。接下来我们将看一下调用代码。
- en: The ImportBooks form
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入书籍表单
- en: 'The `ImportBooks` form does exactly what the name suggests. It allows us to
    create Virtual Storage Spaces and to import books into those spaces. The form
    design is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “ImportBooks”表单正如其名称所示。它允许我们创建虚拟存储空间并将书籍导入到这些空间中。表单设计如下：
- en: '![](img/971b4446-fbf5-449f-94d0-7682e834a5ea.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/971b4446-fbf5-449f-94d0-7682e834a5ea.png)
- en: The `TreeView` controls are prefixed with `tv`, buttons with `btn`, combo boxes
    with `dl`, textboxes with `txt`, and date time pickers with `dt`. When this form
    loads, if there are any storage spaces defined then these will be listed in the
    `dlVirtualStorageSpaces` combo box. Clicking on the Select source folder button
    will allow us to select a source folder to look for eBooks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “TreeView”控件以“tv”为前缀，按钮以“btn”为前缀，组合框以“dl”为前缀，文本框以“txt”为前缀，日期时间选择器以“dt”为前缀。当这个表单加载时，如果已经定义了任何存储空间，那么这些存储空间将列在“dlVirtualStorageSpaces”组合框中。单击“选择源文件夹”按钮将允许我们选择源文件夹以查找电子书。
- en: If a storage space does not exist, we can add a new Virtual Storage Space by
    clicking the `btnAddNewStorageSpace` button. This will allow us to add a name
    and description for the new storage space and click on the `btnSaveNewStorageSpace`
    button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储空间不存在，我们可以通过单击“btnAddNewStorageSpace”按钮添加新的虚拟存储空间。这将允许我们为新的存储空间添加名称和描述，并单击“btnSaveNewStorageSpace”按钮。
- en: 'Selecting an eBook from the `tvFoundBooks` TreeView will populate the **File
    details** group of controls to the right of the form. You can then add additional
    Book details and click on the `btnAddeBookToStorageSpace` button to add the book
    to our space:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从“tvFoundBooks” TreeView中选择电子书将填充表单右侧的“文件详细信息”组控件。然后您可以添加额外的书籍详细信息，并单击“btnAddeBookToStorageSpace”按钮将书籍添加到我们的空间中：
- en: 'You need to ensure that the following namespaces are added to your `ImportBooks` class:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要确保以下命名空间添加到您的“ImportBooks”类中：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s start at the most logical place to begin with, which is the constructor
    `ImportBooks()` and the form variables. Add the following code above the constructor:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们从最合乎逻辑的地方开始，即构造函数“ImportBooks()”和表单变量。在构造函数上方添加以下代码：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The usefulness of the enumerator will become evident later on in code. The `_jsonPath`
    variable will contain the path to the file used to store our eBook information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举器的用处将在以后的代码中变得明显。"_jsonPath"变量将包含用于存储我们的电子书信息的文件的路径。
- en: 'Modify the constructor as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改构造函数：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `_jsonPath` is initialized to the executing folder for the application and
    the file hard coded to `bookData.txt`. You could provide a settings screen if
    you wanted to configure these settings, but I just decided to make the application
    use a hard-coded setting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “_jsonPath”初始化为应用程序的执行文件夹，并且文件硬编码为“bookData.txt”。如果您想要配置这些设置，可以提供一个设置屏幕，但我决定让应用程序使用硬编码设置。
- en: Next, we need to add another enumerator that defines the file extensions that
    we will be able to save in our application. It is here that we will see another
    feature of C# 7 called `expression-bodied` properties.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加另一个枚举器，定义我们将能够在应用程序中保存的文件扩展名。在这里，我们将看到C# 7的另一个特性，称为“表达式体”属性。
- en: Expression-bodied accessors, constructors, and finalizers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式体访问器、构造函数和终结器
- en: 'If the following expression looks intimidating, it''s because it is using a
    feature introduced in C# 6 and expanded in C# 7:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下表达式看起来令人生畏，那是因为它使用了C# 6中引入并在C# 7中扩展的一个特性：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example returns a `HashSet` of allowed file extensions for our
    application. These have been around since C# 6, but have been extended in C# 7
    to include *accessors*, *constructors*, and *finalizers*. Let's simplify the examples
    a bit.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子返回了我们应用程序允许的文件扩展名的`HashSet`。这些自C# 6以来就存在，但在C# 7中已经扩展到包括*访问器*、*构造函数*和*终结器*。让我们简化一下这些例子。
- en: 'Assume that we had to modify the `Document` class to set a field for `_defaultDate`
    inside the class; traditionally, we would need to do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要修改`Document`类以在类内部设置字段`_defaultDate`；传统上，我们需要这样做：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In C# 7, we can greatly simplify this code by simply doing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7中，我们可以通过简单地执行以下操作大大简化这段代码：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is perfectly legal and compiles correctly. Similarly, the same can be done
    with finalizers (or deconstructors). Another nice implementation of this is `expression-bodied`
    properties as seen with the `AllowedExtensions` property. The `expression-bodied`
    properties have actually been around since C# 6, but who's counting?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全合法的，可以正确编译。同样，终结器（或解构器）也可以这样做。`AllowedExtensions`属性也是`表达式体`属性的一个很好的实现。`表达式体`属性实际上自C#
    6以来就一直存在，但谁在计数呢？
- en: 'Suppose that we wanted to just return the `string` value of the `Extension`
    enumeration for PDFs, we could do something such as the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想返回PDF的`Extension`枚举的`string`值，我们可以这样做：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That property only has a get accessor and will never return anything other
    than the `string` value of `Extension.pdf`. Simplify that by changing the code
    to:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性只有一个获取器，永远不会返回除`Extension.pdf`之外的任何内容。通过更改代码来简化：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. A single line of code does exactly the same thing as the previous
    seven lines of code. Falling into the same category, `expression-bodied` property
    accessors are also simplified. Consider the following 11 lines of code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。一行代码完全可以做到与以前的七行代码相同的事情。同样，*表达式体*属性访问器也被简化了。考虑以下11行代码：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With C# 7, we can simplify this to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了C# 7，我们可以简化为以下内容：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This makes our code a lot more readable and quicker to write. Swing back to
    our `AllowedExtensions` property; traditionally, it would be written as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的代码更易读，更快速编写。回到我们的`AllowedExtensions`属性；传统上，它将被写成如下形式：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since C# 6, we have been able to simplify this, as we saw previously. This gives
    developers a great way to reduce unnecessary code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 6以来，我们已经能够简化这个过程，就像我们之前看到的那样。这为开发人员提供了一个减少不必要代码的好方法。
- en: Populating the TreeView control
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充TreeView控件
- en: 'We can see the implementation of the `AllowedExtensions` property when we look
    at the `PopulateBookList()` method. All that this method does is populate the
    `TreeView` control with files and folders found at the selected source location.
    Consider the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`PopulateBookList()`方法时，我们可以看到`AllowedExtensions`属性的实现。这个方法的作用只是用选定的源位置找到的文件和文件夹填充`TreeView`控件。考虑以下代码：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first place we need to call this method is obviously from within itself,
    as this is a recursive method. The second place we need to call it is from the
    `btnSelectSourceFolder` button click event:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用这个方法的第一个地方显然是在方法内部，因为这是一个递归方法。我们需要调用它的第二个地方是在`btnSelectSourceFolder`按钮的单击事件中：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is all quite straightforward code. Select the folder to recurse and populate
    the `TreeView` control with all the files found that match the file extension
    contained in our `AllowedExtensions` property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这都是非常简单直接的代码。选择要递归的文件夹，并使用我们的`AllowedExtensions`属性中包含的文件扩展名匹配找到的所有文件，然后填充`TreeView`控件。
- en: 'We also need to look at the code when someone selects a book in the `tvFoundBooks`
    `TreeView` control. When a book is selected, we need to read the properties of
    the selected file and return those properties to the file details section:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人在`tvFoundBooks` `TreeView`控件中选择一本书时，我们还需要查看代码。当选择一本书时，我们需要读取所选文件的属性，并将这些属性返回到文件详细信息部分：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will notice that it is here that we are calling the method `GetFileProperties()`
    on the `DocumentEngine` class that returns the tuple.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这里我们在`DocumentEngine`类上调用`GetFileProperties()`方法，该方法返回元组。
- en: Local functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地函数
- en: 'This is one of those features in C# 7 that I truly wondered where I would ever
    find a use for. As it turns out, local functions are extremely useful indeed.
    Also called *nested functions* by some, these functions are nested within another
    parent function. It is obviously only within scope inside the parent function
    and adds a useful way to call code that otherwise wouldn''t have any real purpose
    outside the parent function. Consider the `PopulateStorageSpacesList()` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C# 7中的一个功能，我真的很惊讶我会在哪里找到它的用途。事实证明，本地函数确实非常有用。有些人称之为*嵌套函数*，这些函数嵌套在另一个父函数中。显然，它只在父函数内部范围内有效，并提供了一种有用的方式来调用代码，否则在父函数外部没有任何真正的用途。考虑`PopulateStorageSpacesList()`方法：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To see how `PopulateStorageSpacesList()` calls the local function `BindStorageSpaceList()`,
    have a look at the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`PopulateStorageSpacesList()`如何调用本地函数`BindStorageSpaceList()`，请查看以下屏幕截图：
- en: '![](img/fe2e05bf-ca6a-4d1d-875d-24d09bd593fd.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe2e05bf-ca6a-4d1d-875d-24d09bd593fd.png)'
- en: 'You will notice that the local function can be called from anywhere within
    the parent function. In this case, the `BindStorageSpaceList()` local function
    does not return anything, but you can return whatever you like from a local function.
    You could just as well have done the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到本地函数可以在父函数内的任何地方调用。在这种情况下，`BindStorageSpaceList()`本地函数不返回任何内容，但您可以从本地函数返回任何您喜欢的内容。您也可以这样做：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The local function is accessible from anywhere within the parent function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数可以从父函数的任何地方访问。
- en: Pattern matching
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Staying with the `PopulateStorageSpacesList()` method, we can see the use of
    another C# 7 feature called **pattern matching**. The `spaces is null` line of
    code is probably the simplest form of pattern matching. In reality, pattern matching
    supports several patterns.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`PopulateStorageSpacesList()`方法，我们可以看到另一个C# 7功能的使用，称为**模式匹配**。`spaces is
    null`代码行可能是最简单的模式匹配形式。实际上，模式匹配支持多种模式。
- en: 'Consider a `switch` statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`switch`语句：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Pattern matching allows developers to use the `is` expression to see whether
    something matches a specific pattern. Bear in mind that the pattern needs to check
    for the most specific to the most general pattern. If you simply started the case
    with `case Document doc:` then all the objects passed to the `switch` statement
    of type `Document` would match. You would never find specific documents where
    the author is `Stephen King` or starts with `Stephen`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配允许开发人员使用`is`表达式来查看某物是否与特定模式匹配。请记住，模式需要检查最具体到最一般的模式。如果您只是以`case Document
    doc:`开始，那么传递给`switch`语句的类型为`Document`的所有对象都会匹配。您永远不会找到作者是`Stephen King`或以`Stephen`开头的特定文档。
- en: For a construct inherited by C# from the C language, it hasn't changed much
    since the '70s. C# 7 changes all that with pattern matching.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从C语言继承的构造，自70年代以来它并没有改变太多。C# 7通过模式匹配改变了这一切。
- en: Finishing up the ImportBooks code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成ImportBooks代码
- en: 'Let''s have a look at the rest of the code in the `ImportBooks` form. The form
    load just populates the storage spaces list, if any existing storage spaces have
    been previously saved:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`ImportBooks`表单中的其余代码。如果之前已保存了任何现有存储空间，表单加载将只填充存储空间列表：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now need to add the logic for changing the selected storage space. The `SelectedIndexChanged()`
    event of the `dlVirtualStorageSpaces` control is modified as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加更改所选存储空间的逻辑。`dlVirtualStorageSpaces`控件的`SelectedIndexChanged()`事件修改如下：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: I will not go into any detailed explanation of the code here as it is relatively
    obvious what it is doing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里对代码进行任何详细的解释，因为它相对明显它在做什么。
- en: Throw expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出表达式
- en: 'We also need to add the code to save a new storage space. Add the following
    code to the `Click` event of the `btnSaveNewStorageSpace` button:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加保存新存储空间的代码。将以下代码添加到`btnSaveNewStorageSpace`按钮的`Click`事件中：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see another new feature in the C# 7 language called **throw expressions**.
    This gives developers the ability to throw exceptions from expressions. The code
    in question is this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到C# 7语言中的另一个新功能，称为**throw表达式**。这使开发人员能够从表达式中抛出异常。相关代码如下：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I always like to remember the structure of the code as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是喜欢记住代码的结构如下：
- en: '![](img/6e4b9f28-daa1-46cb-9216-2f708f101a55.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e4b9f28-daa1-46cb-9216-2f708f101a55.png)'
- en: 'The last few methods deal with saving eBooks in the selected Virtual Storage
    Space. Modify the `Click` event of the `btnAddBookToStorageSpace` button. This
    code also contains a throw expression. If you haven''t selected a storage space
    from the combo box, a new exception is thrown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个方法处理将电子书保存在所选虚拟存储空间中。修改`btnAddBookToStorageSpace`按钮的`Click`事件。此代码还包含一个throw表达式。如果您没有从组合框中选择存储空间，则会抛出新异常：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Developers can now immediately throw exceptions in code right there where they
    occur. This is rather nice and makes code cleaner and its intent clearer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员现在可以立即在代码中抛出异常。这相当不错，使代码更清晰。
- en: Saving a selected book to a storage space
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所选书籍保存到存储空间
- en: 'The following code basically updates the book list in the selected storage
    space if it already contains the specific book (after confirming with the user).
    Otherwise, it will add the book to the book list as a new book:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码基本上更新了所选存储空间中的书籍列表（在与用户确认后）如果它已经包含特定书籍。否则，它将将书籍添加到书籍列表作为新书：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, as a matter of housekeeping, the `ImportBooks` form contains the following
    code for displaying and enabling controls based on the button click events of
    `btnCancelNewStorageSpace` and `btnAddNewStorageSpace` buttons:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一种整理的方式，`ImportBooks`表单包含以下代码，用于根据`btnCancelNewStorageSpace`和`btnAddNewStorageSpace`按钮的单击事件显示和启用控件：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All that remains now is for us to complete the code in the `Form1.cs` form,
    which is the start-up form.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要完成`Form1.cs`表单中的代码，这是启动表单。
- en: Main eBookManager form
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主eBookManager表单
- en: 'Start off by renaming `Form1.cs` to `eBookManager.cs`. This is the start-up
    form for the application and it will list all the existing storage spaces previously
    saved:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`Form1.cs`重命名为`eBookManager.cs`。这是应用程序的启动表单，它将列出之前保存的所有现有存储空间：
- en: '![](img/14ca97f5-07c7-4913-9561-0dbda876b642.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14ca97f5-07c7-4913-9561-0dbda876b642.png)'
- en: 'Design your `eBookManager` form as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 设计您的`eBookManager`表单如下：
- en: '`ListView` control for existing storage spaces'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于现有存储空间的`ListView`控件
- en: '`ListView` for eBooks contained in selected storage space'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于所选存储空间中包含的电子书的`ListView`
- en: Button that opens the file location of the eBook
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开电子书文件位置的按钮
- en: A menu control to navigate to the `ImportBooks.cs` form
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单控件以导航到`ImportBooks.cs`表单
- en: Various read-only fields to display the selected eBook information
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种只读字段用于显示所选电子书信息
- en: 'When you have added the controls, your eBook Manager form will look as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加了控件后，您的eBook Manager表单将如下所示：
- en: '![](img/a01fb98a-4c0b-4b4e-8952-19a51e4dfa7c.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a01fb98a-4c0b-4b4e-8952-19a51e4dfa7c.png)'
- en: 'Looking at the code we used earlier, you need to ensure that the following
    `using` statements are imported:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们之前使用的代码，您需要确保导入以下`using`语句：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The constructor is quite similar to the `ImportBooks.cs` form''s constructor.
    It reads any available storage spaces and populates the storage spaces list view
    control with the previously saved storage spaces:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与`ImportBooks.cs`表单的构造函数非常相似。它读取任何可用的存储空间，并使用先前保存的存储空间填充存储空间列表视图控件：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the user clicks on a storage space, we need to be able to read the books
    contained in that selected space:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击了一个存储空间，我们需要能够读取该选定空间中包含的书籍：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We now need to create the method that will populate the `lstBooks` list view
    with the books contained in the selected storage space:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个方法，该方法将使用所选存储空间中包含的书籍填充“lstBooks”列表视图：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will notice that each `ListViewItem` is populated with the title of the
    eBook and the index of an image in an `ImageList` control that I added to the
    form. To find the images in the GitHub repository, browse to the following path:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到每个“ListViewItem”都填充了电子书的标题和我添加到表单的“ImageList”控件中的图像的索引。要在GitHub存储库中找到这些图像，请浏览以下路径：
- en: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img)'
- en: 'Looking at the Images Collection Editor, you will see that I have added them
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图像集编辑器，你会看到我已经添加了它们如下：
- en: '![](img/547c25ea-5ae0-4e34-954c-b8499f87f77d.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/547c25ea-5ae0-4e34-954c-b8499f87f77d.png)'
- en: 'We also need to clear the selected book''s details when the selected storage
    space is changed. I have created two group controls around the file and book details.
    This code just loops through all the child controls, and if the child control
    is a textbox, it clears it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当所选存储空间更改时，我们还需要清除所选书籍的详细信息。我在文件和书籍详细信息周围创建了两个组控件。这段代码只是循环遍历所有子控件，如果子控件是文本框，则清除它。
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `MenuStrip` that was added to the form has a click event on the `ImportEBooks`
    menu item. It simply opens up the `ImportBooks` form:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到表单的MenuStrip上有一个点击事件，点击“ImportEBooks”菜单项。它只是打开“ImportBooks”表单：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following method wraps up the logic to select a specific eBook and populate
    the file and eBook details on the `eBookManager` form:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法总结了选择特定电子书并在“eBookManager”表单上填充文件和电子书详细信息的逻辑：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lastly, when the book selected is the one you wish to read, click on the Read
    eBook button to open the file location of the selected eBook:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所选的书是您想要阅读的书时，请点击“阅读电子书”按钮以打开所选电子书的文件位置：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This completes the code logic contained in the `eBookManager` application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了“eBookManager”应用程序中包含的代码逻辑。
- en: You can further modify the code to open the required application for the selected
    eBook instead of just the file location. In other words, if you click on a PDF
    document, the application can launch a PDF reader with the document loaded. Lastly,
    note that the classification has not been implemented in this version of the application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步修改代码，以打开所选电子书所需的应用程序，而不仅仅是文件位置。换句话说，如果您点击PDF文档，应用程序可以启动加载了文档的PDF阅读器。最后，请注意，此版本的应用程序中尚未实现分类。
- en: It is time to fire up the application and test it out.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候启动应用程序并测试一下了。
- en: Running the eBookManager application
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行eBookManager应用程序
- en: 'When the application starts for the first time, there will be no Virtual Storage
    Spaces available. To create one, we will need to import some books. Click on the
    Import eBooks menu item:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序第一次启动时，将没有可用的虚拟存储空间。要创建一个，我们需要导入一些书籍。点击“导入电子书”菜单项：
- en: '![](img/e0cd2007-0d91-4246-b9c2-7eae31b6aa48.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0cd2007-0d91-4246-b9c2-7eae31b6aa48.png)'
- en: 'The Import eBooks screen opens where you can add a new storage space and Select
    source folder for eBooks:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 打开导入电子书屏幕，您可以添加新的存储空间并选择电子书的源文件夹：
- en: '![](img/a9a81038-8899-4d89-adbe-b83353339422.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9a81038-8899-4d89-adbe-b83353339422.png)'
- en: 'Once you have selected an eBook, add the applicable information regarding the
    book and save it to the storage space:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了一本电子书，添加有关该书的适用信息并将其保存到存储空间：
- en: '![](img/379bc6c2-2c03-493f-85e9-4c4ce9ddf0a1.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/379bc6c2-2c03-493f-85e9-4c4ce9ddf0a1.png)'
- en: 'After you have added all the storage spaces and eBooks, you will see the Virtual
    Storage Spaces listed. As you click on a storage space, the books it contains
    will be listed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了所有存储空间和电子书后，您将看到列出的虚拟存储空间。当您点击一个存储空间时，它包含的书籍将被列出：
- en: '![](img/5603e606-0f2e-406d-88d5-97661ff24a51.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5603e606-0f2e-406d-88d5-97661ff24a51.png)'
- en: 'Selecting an eBook and clicking on the Read eBook button will open up the file
    location containing the selected eBook:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一本电子书并点击“阅读电子书”按钮将打开包含所选电子书的文件位置：
- en: '![](img/3ba21d09-586c-4186-a98c-f4bc693b9673.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ba21d09-586c-4186-a98c-f4bc693b9673.png)'
- en: 'Lastly, let''s have a look at the **JSON** file generated for the `eBook Manager`
    application:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下为“eBook Manager”应用程序生成的**JSON**文件：
- en: '![](img/cc28c3c6-53d3-45de-9ae2-04ccc777f562.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc28c3c6-53d3-45de-9ae2-04ccc777f562.png)'
- en: As you can see, the JSON file is quite nicely laid out and it is easily readable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，JSON文件排列得很好，很容易阅读。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: C# 7 is a fantastic version of the language. In this chapter, we had a look
    at `out` variables. You will remember that with C# 7 we now have the ability to
    declare the variable right at the point it is passed as an out argument. We then
    looked at tuples, which provide an elegant way to return multiple values from
    a method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7是语言的一个很棒的版本。在本章中，我们看了“out”变量。您会记得，使用C# 7，我们现在可以在作为out参数传递的地方声明变量。然后，我们看了元组，它提供了一种优雅的方式从方法中返回多个值。
- en: Moving, on we looked at `expression-bodied` properties, which is a more succinct
    way to write your code. Then, we discussed local functions (one of my favorite
    features) and its ability to create a helper function inside another function.
    This makes sense if the function that uses the local function is the only code
    that uses it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了“表达式体”属性，这是一种更简洁的编写代码的方式。然后，我们讨论了本地函数（我最喜欢的功能之一）及其在另一个函数中创建辅助函数的能力。如果使用本地函数的函数是唯一使用它的代码，这是有道理的。
- en: Pattern matching was up next and are syntactic elements that look to see if
    a specific value has a certain *shape*. This makes `switch` statements (for example)
    nicer to use. Lastly, we looked at throw expressions. This makes it possible to
    add exception throwing to our `expression-bodied` members, conditional and null-coalescing
    expressions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模式匹配，它是一种语法元素，用于查看特定值是否具有特定的“形状”。这使得使用`switch`语句（例如）更加方便。最后，我们看了抛出表达式。这使得我们可以将异常抛出到我们的`expression-bodied`成员、条件和空值合并表达式中。
- en: As you continue to use C# 7, you will discover more opportunities to use these
    new features. At first (for me anyway) I had to purposefully condition myself
    to write code using a new feature (out variables being a perfect example).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您继续使用C# 7，您将发现更多使用这些新功能的机会。起初（至少对我来说），我不得不刻意训练自己使用新功能来编写代码（out变量就是一个完美的例子）。
- en: After a while, the convenience of doing that becomes second nature. You will
    soon start to automatically write code using the new features available to you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一会儿，这样做的便利性就变得很自然。您很快就会开始自动使用可用的新功能来编写代码。
