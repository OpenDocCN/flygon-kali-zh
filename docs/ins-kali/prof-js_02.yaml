- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*'
- en: Node.js and npm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js和npm
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Install and use Node.js to build applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用Node.js构建应用程序
- en: Run JavaScript code using the Node.js execution environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js执行环境运行JavaScript代码
- en: Install and manage multiple Node.js versions using nvm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nvm安装和管理多个Node.js版本
- en: Identify and use modules developed by other developers using npm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别并使用其他开发人员开发的模块，使用npm
- en: Create and configure your own npm package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置自己的npm包
- en: In this chapter, we will switch gears to the backend world by learning about
    Node.js and the basic concepts around it. We will go through how to install and
    manage multiple versions of Node.js using nvm, and then we will learn about npm
    and how to find and use external modules.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将转向后端世界，学习有关Node.js及其基本概念。我们将学习如何使用nvm安装和管理多个Node.js版本，然后我们将学习npm以及如何查找和使用外部模块。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned about how HTML becomes the DOM and how to
    use JavaScript to query and manipulate the content of a page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了HTML如何成为DOM以及如何使用JavaScript来查询和操作页面内容。
- en: Before JavaScript, all pages were static. After Netscape introduced the scripting
    environment to its browser, developers started using it to create dynamic and
    responsive applications. The applications started to become more and more complex
    but the only place where JavaScript was running was inside the browser. Then,
    in 2009, Ryan Dahl, the original developer of Node.js, decided to create a way
    to run JavaScript on the server side, simplifying the web developer's life by
    allowing them to build applications without having to depend on other languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript出现之前，所有页面都是静态的。在Netscape将脚本环境引入其浏览器后，开发人员开始使用它来创建动态和响应式应用程序。应用程序变得越来越复杂，但JavaScript运行的唯一地方是在浏览器内部。然后，在2009年，Node.js的原始开发人员Ryan
    Dahl决定创建一种在服务器端运行JavaScript的方式，通过允许他们构建应用程序而无需依赖其他语言，简化了Web开发人员的生活。
- en: In this chapter, you will learn how Node.js works and how to use it to create
    scripts using JavaScript. You will learn about the basics of the Node.js core
    APIs, where to find their documentation, and how to use their **read-eval-print
    loop** (**REPL**) command line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Node.js的工作原理以及如何使用它来使用JavaScript创建脚本。您将了解Node.js核心API的基础知识，以及如何找到它们的文档，并如何使用它们的**read-eval-print
    loop** (**REPL**)命令行。
- en: With the skills to build JavaScript code, you will then learn how to manage
    multiple versions of Node.js and understand the importance of Node.js. You will
    also learn what npm is and how to import and use packages from other developers
    and build Node.js applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握构建JavaScript代码的技能后，您将学习如何管理多个Node.js版本，并了解Node.js的重要性。您还将学习npm是什么，以及如何导入和使用其他开发人员的软件包并构建Node.js应用程序。
- en: What is Node.js?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Node.js？
- en: Node.js is an execution environment that runs on top of the V8 JavaScript engine.
    Its base premise is that it is asynchronous and event-driven. This means that
    all the blocking operations, such as reading data from a file, can be handled
    in the background while the other parts of the application continue to do their
    work. When the data has finished loading, an event is emitted and whoever was
    waiting for the data can now execute and do the work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是在V8 JavaScript引擎之上运行的执行环境。它的基本前提是它是异步和事件驱动的。这意味着所有阻塞操作，例如从文件中读取数据，可以在后台处理，而应用程序的其他部分可以继续工作。当数据加载完成时，将发出事件，等待数据的人现在可以执行并进行工作。
- en: From its inception, Node.js was designed to serve as an efficient backend for
    web applications. Because of that, it was widely adopted by companies of all sizes
    and industry types. Trello, LinkedIn, PayPal, and NASA are some of the companies
    that use Node.js in multiple parts of their technology stack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从诞生之初，Node.js就被设计为Web应用程序的高效后端。因此，它被各种规模和行业类型的公司广泛采用。Trello、LinkedIn、PayPal和NASA是一些在其技术堆栈的多个部分中使用Node.js的公司。
- en: But what is an execution environment? An execution environment provides basic
    functionality, such as APIs, for a programmer to write applications. Think about
    the browser, for example – it has the DOM, objects such as documents and windows,
    functions such as `setTimeout` and `fetch`, and so many other things you can do
    in the frontend world. All of that is part of the browser's execution environment.
    Since that execution environment is focused on the browser, it provides ways for
    you to interact with the DOM and to communicate with the server, which is all
    that exists in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么是执行环境？执行环境为程序员编写应用程序提供基本功能，例如API。例如，想象一下浏览器-它具有DOM，诸如文档和窗口的对象，诸如`setTimeout`和`fetch`的函数，以及前端世界中可以做的许多其他事情。所有这些都是浏览器执行环境的一部分。由于该执行环境专注于浏览器，它提供了与DOM交互和与服务器通信的方式，这是它存在的全部。
- en: Node.js focuses on creating an environment for developers to build the backend
    part of web applications in an efficient way. It provides APIs to create HTTP(S)
    servers, read/write files, manipulate processes, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js专注于为开发人员提供一种有效构建Web应用程序后端的环境。它提供API来创建HTTP(S)服务器，读写文件，操作进程等。
- en: 'Node.js, as we mentioned previously, uses the V8 JavaScript engine underneath
    the hood. This means that to transform the JavaScript text into executable code
    for the computer to process, it uses V8, the open source JavaScript engine built
    by Google to power the Chromium and Chrome browsers. The following is an illustration
    of this process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Node.js在底层使用V8 JavaScript引擎。这意味着为了将JavaScript文本转换为计算机处理的可执行代码，它使用了V8，这是由Google构建的开源JavaScript引擎，用于驱动Chromium和Chrome浏览器。以下是这个过程的示例：
- en: '![Figure 2.1: Node.js uses a V8 engine to transform JavaScript source code
    into executable code that runs in the processor'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：Node.js使用V8引擎将JavaScript源代码转换为可在处理器中运行的可执行代码'
- en: '](Images/C14587_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_01.jpg)'
- en: 'Figure 2.1: Node.js uses the V8 engine to transform JavaScript source code
    into executable code that runs in the processor'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：Node.js使用V8引擎将JavaScript源代码转换为在处理器中运行的可执行代码
- en: The execution environment that Node.js provides is single-threaded. This means
    that only one piece of JavaScript code can execute at each given moment. But Node.js
    has something called an event loop, which is a way to take code that is waiting
    for something, such as reading data from a file, and put it in a queue while another
    piece of code can execute.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js提供的执行环境是单线程的。这意味着每次只有一段JavaScript代码可以执行。但是Node.js有一个叫做事件循环的东西，它可以将等待某些东西的代码（比如从文件中读取数据）放入队列，而另一段代码可以执行。
- en: Reading or writing data from files and sending or receiving data through the
    network are all tasks that are handled by the system kernel, which is multithreaded
    in most modern systems. Due to this, some of the work ends up being distributed
    in multiple threads. But for developers who are working in the Node.js execution
    environment, that is all hidden away in the form of a programming paradigm called
    asynchronous programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取或写入数据以及通过网络发送或接收数据都是由系统内核处理的任务，在大多数现代系统中都是多线程的。因此，一些工作最终会分布在多个线程中。但对于在Node.js执行环境中工作的开发人员来说，这一切都隐藏在一个叫做异步编程的编程范式中。
- en: 'Asynchronous programming means that you are going to ask some tasks to be executed
    and when the result is available, your code will be executed. Let''s go back to
    the read data from a file example. In most programming languages and paradigms,
    you would just write some pseudocode, like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程意味着你将要求执行一些任务，当结果可用时，你的代码将被执行。让我们回到从文件中读取数据的例子。在大多数编程语言和范式中，你只需编写一些伪代码，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the asynchronous programming model, this works in a different way. You
    open the file and tell Node.js that you want to read it. You also give it a callback
    function, which will be called when the data is available to you. This is what
    the pseudocode looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 采用异步编程模型，工作方式有所不同。你打开文件并告诉Node.js你想要读取它。你还给它一个回调函数，当数据对你可用时将被调用。伪代码如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the script would be loaded, and execution would start. The
    script would execute line by line and open the file. When it gets to the read
    operation, it starts reading the file and schedules the callback to be executed
    later. After that, it reaches the end of the script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，脚本将被加载，并开始执行。脚本将逐行执行并打开文件。当它到达读取操作时，它开始读取文件并安排稍后执行回调。之后，它到达脚本的末尾。
- en: 'When Node.js reaches the end of the script, it starts processing the event
    loop. The event loop is divided into phases. Each phase has a queue that stores
    code that''s scheduled to run in them. I/O operations get scheduled in the poll
    phase, for example. There are six phases, and they are executed in the following
    order:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node.js到达脚本的末尾时，它开始处理事件循环。事件循环分为阶段。每个阶段都有一个队列，存储着计划在其中运行的代码。例如，I/O操作被安排在轮询阶段。有六个阶段，它们按以下顺序执行：
- en: '**Timers**: Code that''s scheduled using `setTimeout` or `setInterval`'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计时器**：使用`setTimeout`或`setInterval`计划的代码'
- en: '**Pending** **Callbacks**: Deferred callbacks for the I/O from the previous
    cycle'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂起** **回调**：上一个周期的I/O的延迟回调'
- en: '**Idle**, **Prepare**: Internal only'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**空闲**，**准备**：仅内部'
- en: '**Poll**: Code that''s scheduled for I/O handling'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮询**：计划进行I/O处理的代码'
- en: '**Check**: The `setImmediate` callbacks are executed here'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查**：`setImmediate`回调在这里执行'
- en: '**Close callbacks**: Code that''s scheduled on closing sockets, for example'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭回调**：计划在关闭套接字等上执行的代码'
- en: 'Code will be executed for each phase until one of two things happens: the phase
    queue is exhausted, or a maximum number of callbacks is executed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都会执行代码，直到发生两种情况之一：阶段队列耗尽，或者执行了最大数量的回调：
- en: '![Figure 2.2: Event loop phases'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：事件循环阶段'
- en: '](Images/C14587_02_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_02.jpg)'
- en: 'Figure 2.2: Event loop phases'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：事件循环阶段
- en: 'To understand how this works, let''s look at some code and map the phases to
    the event loop and understand what exactly is going on under the hood:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们看一些代码，将阶段映射到事件循环，并了解底层到底发生了什么：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this short piece of code, we print something to the console (which, in Node.js,
    goes to Standard Output by default), and then we set a function to be called after
    `100` ms and print some other text to the console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段简短的代码中，我们向控制台打印一些内容（在Node.js中，默认情况下会输出到标准输出），然后我们设置一个函数在`100`毫秒后调用，并向控制台打印一些其他文本。
- en: 'When Node.js starts your application, it parses the JavaScript and executes
    the script all the way to the end. When it finishes, it starts the event loop.
    This means that, when printing to the console directly, it is executed immediately.
    The scheduled function gets pushed to the Timers queue and waits for the script
    to finish (and for the **100** ms to pass) to be executed. When the event loop
    runs out of tasks to execute, the application finishes. The following diagram
    illustrates this process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node.js启动你的应用程序时，它会解析JavaScript并执行脚本直到结束。当结束时，它开始事件循环。这意味着，直接打印到控制台时，它会立即执行。计划的函数被推送到计时器队列，并等待脚本完成（以及**100**毫秒过去）才会执行。当事件循环没有任务可执行时，应用程序结束。以下图表说明了这个过程：
- en: '![Figure 2.3: Execution flow for a Node.js application'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：Node.js应用程序的执行流程'
- en: '](Images/C14587_02_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_03.jpg)'
- en: 'Figure 2.3: Execution flow for a Node.js application'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：Node.js应用程序的执行流程
- en: 'Because of this order of execution, the output of the application is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行顺序，应用程序的输出如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are two important things happening here. First, the code that is passed
    to the `setTimeout` function gets executed after the script finishes executing.
    Second, the application doesn't exit immediately after the script executes to
    the end; instead, it waits for the event loop to run out of tasks to execute.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了两件重要的事情。首先，传递给`setTimeout`函数的代码在脚本执行完成后执行。其次，应用程序在脚本执行到最后不会立即退出；相反，它会等待事件循环耗尽要执行的任务。
- en: Node.js has two methods of execution. The most used one is when you pass in
    the path of a file, from where the JavaScript code will be loaded and executed.
    The second method is in the REPL. If you execute the Node.js command without giving
    it any arguments, it will start in REPL mode, which is like the Console from the
    Dev Tools, which we looked at in the previous chapter. Let's explore this in detail
    in the next exercise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有两种执行方法。最常用的是当您传递文件的路径时，JavaScript代码将从那里加载和执行。第二种方法是在REPL中。如果您执行Node.js命令而不给出任何参数，它将以REPL模式启动，这类似于我们在上一章中看到的Dev
    Tools中的控制台。让我们在下一个练习中详细探讨这一点。
- en: 'Exercise 8: Running Your First Node.js Commands'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：运行您的第一个Node.js命令
- en: In this exercise, you will download and install Node.js on your computer, create
    your first script, and run it. Then, we will use the REPL tool that comes with
    Node.js and run some commands in there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在计算机上下载和安装Node.js，创建您的第一个脚本并运行它。然后，我们将使用Node.js附带的REPL工具，并在其中运行一些命令。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To be able to run Node.js applications, you need to have it installed on your
    machine. For that, you can go to `nodejs.org` and download a Node.js package.
    It is recommended to download the latest **Long-Term** **Support** (**LTS**) version,
    which will give you the most stable and longest support time for security and
    bug patches. At the time of this writing, that version is `10.16.0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行Node.js应用程序，您需要在计算机上安装它。为此，您可以转到`nodejs.org`并下载Node.js软件包。建议下载最新的**长期支持**（**LTS**）版本，这将为您提供最稳定和最长的安全和错误修补支持时间。在撰写本文时，该版本为`10.16.0`。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'After downloading and installing Node.js, go to the command line and check
    the version you have installed:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Node.js后，转到命令行并检查您已安装的版本：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a new text file called `event_loop.js` and add an extended version
    of the code (event loop example), as shown previously. This is what it looks like:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`event_loop.js`的新文本文件，并添加代码的扩展版本（事件循环示例），如前所示。它看起来像这样：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run JavaScript using Node.js, call `node` and pass the path to the file
    you want to execute. To run the file you just created, execute the following code
    in the command line from the directory where you created the file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Node.js运行JavaScript，调用`node`并传递要执行的文件的路径。要运行刚刚创建的文件，请在命令行中执行以下代码，从您创建文件的目录中执行：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The time you see in the end will vary on every run. This is because `setTimeout`
    only ensures that the code will run after the specified time, but it can't guarantee
    that it will execute exactly at the time you asked it to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后看到的时间将在每次运行时都有所不同。这是因为`setTimeout`只能确保代码将在指定的时间之后运行，但不能保证它会准确地在您要求的时间执行。
- en: 'Run the `node` command without any argument; you will go into REPL mode:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`node`命令而不带任何参数；您将进入REPL模式：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `>` indicates that you are now inside the Node.js execution environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`表示您现在在Node.js执行环境中。'
- en: 'In the REPL command line, type in a command and press *Enter* to execute it.
    Let''s try the first one:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL命令行中，键入命令并按*Enter*执行。让我们尝试第一个：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that it prints the string you passed into the `console.log` call.
    It also prints `Undefined`. This is the return value of the last executed statement.
    Since `console.log` doesn't return anything, it printed undefined.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它打印出你传递给`console.log`调用的字符串。它还打印出`Undefined`。这是最后执行语句的返回值。由于`console.log`没有返回任何东西，它打印了undefined。
- en: 'Create the constant that stores the current time:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建存储当前时间的常量：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declaring a variable also doesn''t return anything, so it prints `undefined`
    again:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明变量也不会返回任何东西，所以它再次打印`undefined`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to know what the value of a variable is, you can just type the name
    of the variable and press *Enter*. The return statement of the variable name is
    the variable value, so it prints the value for it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要知道变量的值是多少，只需键入变量名称并按*Enter*。变量名称的返回语句是变量值，因此它会打印出该值。
- en: 'Now, type the `setTimeout` call, just like it was in your file. If you press
    *Enter* and your statement is incomplete because you are starting a function or
    opening parenthesis, Node.js will print an ellipsis indicating that it is waiting
    for the rest of the command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，键入`setTimeout`调用，就像在您的文件中一样。如果您按*Enter*并且您的语句不完整，因为您正在启动一个函数或打开括号，Node.js将打印省略号，表示它正在等待命令的其余部分：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can continue typing until all of the commands have been typed out. The
    `setTimeout` function returns a `Timeout` object, and you can see it in the console.
    You can also see the text that''s printed when the callback is executed:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以继续键入，直到所有命令都被键入。`setTimeout`函数返回一个`Timeout`对象，您可以在控制台中看到它。您还可以看到在执行回调时打印的文本：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the output of the preceding code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the time that's printed is much longer than `100` ms. This
    is because the `start` variable was declared some time ago and it is subtracting
    the current time from that initial value. So, that time indicates the `100` ms,
    plus the time it took for you to type and execute the command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到打印出的时间远远超过了`100`毫秒。这是因为`start`变量是一段时间前声明的，它正在从初始值中减去当前时间。因此，该时间表示`100`毫秒，再加上您键入和执行命令所花费的时间。
- en: 'Try changing the value of `start`. You will observe that Node.js won''t let
    you do it since we declared it as a constant:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改`start`的值。您会观察到Node.js不会让您这样做，因为我们将其声明为常量：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could try to redeclare it as a variable but Node.js won''t let us since
    it was already declared in the current environment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试将其重新声明为一个变量，但是Node.js不会让我们这样做，因为它已经在当前环境中声明过了：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare the whole scheduling of the timeout inside another function to get
    a new scope every time the function is executed:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个函数中声明超时的整个调度，以便每次执行函数时都获得一个新的作用域：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Every time you call the function, it will schedule it and execute it after
    `100` ms, just like in your script. This would output the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用该函数，它都会安排并在`100`毫秒后执行，就像在您的脚本中一样。这将输出以下内容：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To exit the REPL tool, you can press *Ctrl + C* twice or type `.exit` and then
    press *Enter*:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出REPL工具，您可以按两次*Ctrl + C*，或者输入`.exit`然后按*Enter*：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is easy to install Node.js and start using it. Its REPL tool allows you to
    quickly prototype and test things. Knowing how to use both can boost your productivity
    and help you a lot in the day-to-day development of JavaScript applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js并开始使用它非常容易。其REPL工具允许您快速原型设计和测试。了解如何使用这两者可以提高您的生产力，并在日常JavaScript应用程序开发中帮助您很多。
- en: In this exercise, you installed Node.js, wrote a simple program, and learned
    how to run it using Node.js. You also used the REPL tool to explore the Node.js
    execution environment and run some code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您安装了Node.js，编写了一个简单的程序，并学会了如何使用Node.js运行它。您还使用了REPL工具来探索Node.js执行环境并运行一些代码。
- en: Node Version Manager (nvm)
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node版本管理器（nvm）
- en: 'Node.js and JavaScript have a huge community and a very fast-paced development
    cycle. Because of this rapid development and its release cycles, it is very easy
    to become out of date (check Node.js''s previous releases page for more information:
    [https://nodejs.org/en/download/releases/](https://nodejs.org/en/download/releases/)).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和JavaScript拥有一个庞大的社区和非常快速的开发周期。由于这种快速的发展和发布周期，很容易过时（查看Node.js的先前版本页面以获取更多信息：[https://nodejs.org/en/download/releases/](https://nodejs.org/en/download/releases/)）。
- en: Can you imagine working on a project that uses Node.js and is a few years old?
    By the time you come back to fix a bug, you will notice that the version you have
    installed can't run the code anymore because of some compatibility issues. Or,
    you will find that you can't change the code using your current version since
    what is running in production is a couple of years old and doesn't have async/await
    or some other lifesaving feature you use a lot in the most recent version.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象在一个使用Node.js且已经存在几年的项目上工作吗？当您回来修复一个错误时，您会注意到您安装的版本无法再运行代码，因为存在一些兼容性问题。或者，您会发现您无法使用当前版本更改代码，因为生产环境中运行的版本已经有几年了，没有async/await或其他您在最新版本中经常使用的功能。
- en: That issue happens with all programming languages and development environments,
    but in Node.js, this is prominent because of the extremely fast release cycles.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题发生在所有编程语言和开发环境中，但在Node.js中，由于其极快的发布周期，这一点尤为突出。
- en: To solve this, it is common to use a version management tool so that you can
    quickly switch between versions of Node.js. **Node Version Manager** (**nvm**)
    is a widely used tool that's used to manage installed versions of Node.js. You
    can find instructions on how to download and install it at [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，通常会使用版本管理工具，这样您就可以快速在Node.js的不同版本之间切换。**Node版本管理器**（**nvm**）是一个广泛使用的工具，用于管理安装的Node.js版本。您可以在[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)上找到有关如何下载和安装它的说明。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using Windows, you can try nvm-windows ([https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)),
    which provides similar functionality for nvm in Linux and Mac. Also, in this chapter,
    many commands are specific to Mac and Linux. For Windows, please refer to the
    help section of `nvm-windows`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，可以尝试nvm-windows（[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)），它为Linux和Mac中的nvm提供了类似的功能。此外，在本章中，许多命令都是针对Mac和Linux的。对于Windows，请参阅`nvm-windows`的帮助部分。
- en: 'The installer script does two things in your system:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序在您的系统中执行两件事：
- en: Creates a `.nvm` directory inside your home directory where it puts all the
    scripts that are necessary for working with and keeping all the managed versions
    of Node.js
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主目录中创建一个`.nvm`目录，其中放置了所有与管理Node.js的所有托管版本相关的脚本
- en: Adds some configuration to make nvm available in all Terminal sessions
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些配置以使nvm在所有终端会话中可用
- en: nvm is very simple to use and very well-documented. The idea behind it is that
    you will have multiple versions of Node.js running in your machine and you can
    quickly install new versions and switch between them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: nvm非常简单易用，并且有很好的文档。其背后的想法是您的机器上将运行多个版本的Node.js，您可以快速安装新版本并在它们之间切换。
- en: 'In my computer, I initially only had the Node.js version I downloaded some
    time ago (10.16.0). After installing nvm, I ran the command to list all the versions.
    The following is the output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，我最初只安装了一段时间前下载的Node.js版本（10.16.0）。安装nvm后，我运行了列出所有版本的命令。以下是输出：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can see that I have no other versions available. I also have a system version,
    which is whatever version you have installed in your system. I could check the
    current Node.js version by running `node --version`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我没有其他版本可用。我还有一个系统版本，这是您在系统中安装的任何版本。我可以通过运行 `node --version` 来检查当前的Node.js版本：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As an example of how to use nvm, let''s say you wanted to test some experimental
    features on the latest version. The first thing you need to do is find out which
    version that is. So, you run the `nvm ls-remote` command (or the `nvm list` command
    for a Windows system), which is the list remote versions command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用nvm的示例，假设您想要在最新版本上测试一些实验性功能。您需要做的第一件事是找出那个版本。因此，您运行`nvm ls-remote`命令（或者对于Windows系统，运行`nvm
    list`命令），这是列出远程版本的命令：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That prints a long list with all the versions available. The last one, 12.7.0,
    at the time of writing, is the latest, so let''s install that one. To install
    any version, run the `nvm install` <`version`> command. This will download the
    Node.js binaries for the specified version, verify that the package is not corrupted,
    and set it as the current version in your Terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所有可用版本的长列表。在写作时，最新的版本是12.7.0，所以让我们安装这个版本。要安装任何版本，请运行`nvm install` <`version`>命令。这将下载指定版本的Node.js二进制文件，验证包是否损坏，并将其设置为终端中的当前版本：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you can verify that you have the latest version installed and ready to
    be used in your Terminal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以验证您已经安装了最新版本，并准备在终端中使用：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, you could just use the alias `node`, which is an alias to the
    latest version. But for Windows, you will need to mention the specific version
    that needs to be installed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以直接使用别名`node`，这是最新版本的别名。但是对于Windows，您需要提到需要安装的特定版本：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is common for widely used frameworks and languages (such as Node.js) to
    have LTS for specific versions. These LTS versions are considered more stable
    and guaranteed to have longer support for bug and security fixes, which is important
    for companies or teams that can''t migrate to new versions as fast as the normal
    release cycles. If you want to use the most latest LTS version, you can use the
    `--lts` option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛使用的框架和语言（如Node.js）通常会为特定版本提供LTS。这些LTS版本被认为更稳定，并保证对错误和安全修复提供更长时间的支持，这对于无法像正常发布周期那样快速迁移到新版本的公司或团队来说非常重要。如果您想使用最新的LTS版本，可以使用`--lts`选项：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After installing multiple versions of Node.js using nvm, you can switch between
    them by using the `use` command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nvm安装多个版本的Node.js后，您可以使用`use`命令在它们之间切换：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you have multiple projects and you switch between them frequently, it is
    hard to remember the Node.js version you are using for each one. To make our lives
    easier, nvm supports a configuration file in the project's directory. You can
    just add a `.nvmrc` file in the root of the project and it will use the version
    that is in the file. You can also have an `.nvmrc` file in any parent directory
    of the project. So, if you want to group projects by Node.js version in a parent
    directory, you could add the configuration file in that parent directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个项目并经常在它们之间切换时，很难记住您为每个项目使用的Node.js版本。为了让我们的生活更轻松，nvm支持项目目录中的配置文件。您只需在项目的根目录中添加一个`.nvmrc`文件，它将使用文件中的版本。您还可以在项目的任何父目录中添加一个`.nvmrc`文件。因此，如果您想在父目录中按Node.js版本对项目进行分组，可以在该父目录中添加配置文件。
- en: 'For example, if you have a `.nvmrc` file in a folder that''s version `12.7.0`,
    when you change into the folder and run `nvm use`, it will automatically pick
    that version:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在一个文件夹中有一个`.nvmrc`文件，版本为`12.7.0`，当您切换到该文件夹并运行`nvm use`时，它将自动选择该版本：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Exercise 9: Using nvm to Manage Versions'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：使用nvm管理版本
- en: As we mentioned previously, Node.js releases have a very short cycle. If you
    look for the URL class, for example ([https://nodejs.org/dist/latest-v12.x/docs/api/url.html#url_class_url](https://nodejs.org/dist/latest-v12.x/docs/api/url.html#url_class_url)),
    you will see that only recently has it become available in the global scope. This
    happened in version 10.0.0, which is only about a year old at the time of writing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Node.js的发布周期非常短。例如，如果您寻找URL类（[https://nodejs.org/dist/latest-v12.x/docs/api/url.html#url_class_url](https://nodejs.org/dist/latest-v12.x/docs/api/url.html#url_class_url)），您会发现它最近才在全局范围内可用。这发生在10.0.0版本中，这个版本在写作时只有大约一年的历史。
- en: In this exercise, we will write an `.nvmrc` file, install multiple versions
    of Node.js using nvm, and experiment with different versions to see what type
    of error you get when you are using the wrong version of Node.js.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个`.nvmrc`文件，使用nvm安装多个版本的Node.js，并尝试不同的版本，看看当您使用错误的Node.js版本时会得到什么类型的错误。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Add an `.nvmrc` file to your project. In an empty folder, create a file called
    `.nvmrc` and add the number 12.7.0 to it. You can do that in one command by using
    the `echo` command and redirecting the output to the file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中添加一个`.nvmrc`文件。在一个空文件夹中，创建一个名为`.nvmrc`的文件，并在其中添加数字12.7.0。您可以使用`echo`命令一次完成这个操作，并将输出重定向到文件中：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can check that the file has the content you want by using `cat`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`cat`命令检查文件是否包含您想要的内容：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s use `nvm use` command, which will try to use the version from inside
    the `.nvmrc` file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`nvm use`命令，它将尝试使用`.nvmrc`文件中的版本：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You need to run `nvm install 12.7.0` to install it before using it. If you don't
    have the specified version installed, nvm will give you a clear message.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，您需要运行`nvm install 12.7.0`来安装它。如果您没有安装指定的版本，nvm将给出清晰的消息。
- en: 'Call `nvm install` to install the version the project needs:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`nvm install`来安装项目需要的版本：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that you don't have to pass the version you want since nvm will pick
    this up from the `.nvmrc` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不必传递您想要的版本，因为nvm将从`.nvmrc`文件中获取这个版本。
- en: 'Now, create a file called `url_explorer.js`. In it, create an instance of the
    URL by passing a complete URL to it. Let''s also add some calls to explore the
    parts of a URL:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`url_explorer.js`的文件。在其中，通过传递完整的URL来创建一个URL的实例。让我们还添加一些调用来探索URL的各个部分：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the script. You will see that the URL is parsed correctly and that all
    the details about it are printed to the console correctly:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。您会看到URL被正确解析，并且所有关于它的细节都正确地打印到控制台上：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s experiment with the wrong version of Node.js. Install version `9.11.2`
    using `nvm`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试错误的Node.js版本。使用`nvm`安装版本`9.11.2`：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, you can run `url_explorer.js` again and see what happens:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以再次运行`url_explorer.js`，看看会发生什么：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You should see an error similar to the one in the preceding code. It is telling
    you that the URL is not defined. That is because, as we mentioned previously,
    the URL class only became globally available in version 10.0.0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到与前面代码中相似的错误。它告诉您URL未定义。这是因为，正如我们之前提到的，URL类只在10.0.0版本中变为全局可用。
- en: 'Fix the version of Node.js and run the script again to see the correct output:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复Node.js的版本并再次运行脚本以查看正确的输出：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The error message in step 7 doesn't mention the Node.js version. It is just
    some cryptic error about a missing class. Errors like these are hard to identify
    and take a lot of effort in terms of history hunting. This is why having `.nvmrc`
    in the root of your project is important. It makes it easy for other developers
    to quickly identify and use the correct version.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第7步中的错误消息没有提及Node.js版本。它只是一些关于缺少类的神秘错误。这类错误很难识别，并需要大量的历史追踪。这就是为什么在项目的根目录中有`.nvmrc`是重要的原因。它使其他开发人员能够快速识别和使用正确的版本。
- en: In this exercise, you learned how to install and use multiple versions of Node.js,
    and also learned how to create a `.nvmrc` file for a project. Finally, you looked
    at the type of errors you expect to see when you use the wrong version, as well
    as the importance of the `.nvmrc` files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学会了如何安装和使用多个版本的Node.js，还学会了为项目创建`.nvmrc`文件。最后，您还了解了在使用错误版本时会看到的错误类型，以及`.nvmrc`文件的重要性。
- en: Node Package Manager (npm)
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node包管理器（npm）
- en: 'When someone talks about **Node Package Manager** or npm for short, they can
    be referring to one or more of the following three things:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人谈论**Node包管理器**或简称npm时，他们可能指的是以下三种情况之一：
- en: A command-line application that manages packages for a Node.js application
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个管理Node.js应用程序包的命令行应用程序
- en: The repository where developers and companies publish their packages for others
    to use
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员和公司发布他们的包供他人使用的存储库
- en: The website where people manage their profile and search for packages
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理个人资料和搜索包的网站
- en: 'Most programming languages offer at least one way for developers to share packages
    with each other: Java has Maven, C# has NuGet, Python has PIP, and so on. Node.js
    started to ship with its own package manager just a few months after its initial
    release.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言至少提供一种开发人员之间共享包的方式：Java有Maven，C#有NuGet，Python有PIP等。Node.js在初始发布几个月后开始使用自己的包管理器。
- en: Packages can include any type of code that developers think would be useful
    to others. And sometimes, they also include tools to aid developers in terms of
    local development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以包括开发人员认为对他人有用的任何类型的代码。有时，它们还包括帮助开发人员进行本地开发的工具。
- en: As the packaged code needs to be shared, there needs to be a repository where
    all the packages are stored. And to publish their packages, authors need to sign
    up and register themselves and their packages. This explains the repository and
    the website part.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于打包的代码需要共享，因此需要一个存储所有包的存储库。为了发布他们的包，作者需要注册并注册自己和他们的包。这解释了存储库和网站部分。
- en: The third part, that is, the command-line tool, is the actual package manager
    for your application. It comes with Node.js and can be used to set up a new project,
    manage dependencies, and manage scripts for your application, such as build and
    test scripts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分，即命令行工具，是您应用程序的实际包管理器。它随Node.js一起提供，并可用于设置新项目、管理依赖项以及管理应用程序的脚本，如构建和测试脚本。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'A Node.js project or application is also considered a package since it contains
    a `package.json` file that represents what is in the package. So, it is common
    to use the following terms interchangeably: application, package, and project.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js项目或应用程序也被视为一个包，因为它包含一个`package.json`文件，代表了包中的内容。因此，通常可以互换使用以下术语：应用程序、包和项目。
- en: 'Every Node.js package has a `package.json` file that describes the project
    and its dependencies. To create one for your project, you can use the `npm init`
    command. Just run it inside the folder where you want your project to live:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Node.js包都有一个描述项目及其依赖关系的`package.json`文件。要为您的项目创建一个`package.json`文件，您可以使用`npm
    init`命令。只需在您想要项目存在的文件夹中运行它：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The command will ask you a few questions, guiding you regarding the creation
    of your `package.json` file. In the end, it will print the generated file and
    ask you to confirm it. It contains all the information about the project, including
    where to find the code, what license it uses, and who the author is.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将询问您一些问题，指导您创建`package.json`文件。最后，它将打印生成的文件并要求您确认。它包含关于项目的所有信息，包括代码的位置、使用的许可证以及作者是谁。
- en: 'Now that we have an npm package, we can start looking for external modules
    we can use. Let''s go to [https://npmjs.com](https://npmjs.com) and look for a
    package to help us parse command-line arguments. Typing **command line** into
    the search box and pressing *Enter* gives us a list of packages to choose from:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个npm包，我们可以开始寻找可以使用的外部模块。让我们去[https://npmjs.com](https://npmjs.com)寻找一个帮助我们解析命令行参数的包。在搜索框中输入**command
    line**并按*Enter*键，我们会得到一个包选择列表：
- en: '![Figure 2.4: Searching for a package to help us build a command-line application'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：搜索一个包来帮助我们构建一个命令行应用程序'
- en: '](Images/C14587_02_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_04.jpg)'
- en: 'Figure 2.4: Searching for a package to help us build a command-line application'
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：搜索一个包来帮助我们构建一个命令行应用程序
- en: Since we are looking for a tool to help us parse command-line arguments, **commander**
    sounds like a good solution. Its short description is **The complete solution
    for node.js command-line programs**. Let's install that in an application and
    use it to understand how this flow works.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找一个工具来帮助我们解析命令行参数，**commander**听起来像是一个不错的解决方案。它的简短描述是**node.js命令行程序的完整解决方案**。让我们在一个应用程序中安装它，并使用它来理解这个流程是如何工作的。
- en: 'To add a package as a dependency to your package, you ask npm to install it
    by name from the command line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包添加为您的包的依赖项，您可以从命令行请求npm按名称安装它：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see that npm found the package and downloaded the latest version, which
    is `2.20.0` as of this writing. It also mentions something about a `package-lock.json`
    file. We are going to talk more about that later, so don't worry about it for
    now.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到npm找到了该包并下载了最新版本，截至本文撰写时为`2.20.0`。它还提到了关于`package-lock.json`文件的一些内容。我们将稍后更多地讨论这个问题，所以现在不用担心它。
- en: Another cool feature that was added to npm recently is vulnerability checks.
    At the end of the `install` command output, you can see a note about vulnerabilities
    found, or better, no vulnerabilities found. The npm team is doing a great job
    of increasing the vulnerability checks and security scans for all the packages
    in their repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最近添加到npm的另一个很酷的功能是漏洞检查。在`install`命令输出的末尾，您可以看到有关发现的漏洞的注释，或者更好的是，没有发现漏洞。npm团队正在努力增加对其存储库中所有包的漏洞检查和安全扫描。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is so easy to use packages from npm that a lot of people out there are pushing
    malicious code to catch the least-attentive developers. It is highly recommended
    that you pay a lot of attention when installing packages from npm. Check the spelling,
    the download count, and the vulnerability reports and make sure that the package
    you are going to install is really the one you want. You also need to ensure that
    it is from a trusted party.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '从npm使用包是如此简单，以至于很多人都在向那里推送恶意代码，以捕捉最不注意的开发人员。强烈建议您在从npm安装包时要非常注意。检查拼写、下载次数和漏洞报告，并确保您要安装的包确实是您想要的。您还需要确保它来自可信任的方。 '
- en: 'After running `npm install`, you will notice that a new section has been added
    to your `package.json` file. It is the `dependencies` section and contains the
    package you just asked for:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`后，您会注意到`package.json`文件中添加了一个新的部分。它是`dependencies`部分，包含您刚刚请求的包：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That is what the + sign in front of `commander` in the output of the `install`
    command meant: that the package was added as a dependency to your project.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`install`命令输出中`commander`前面的+号的含义：该包已作为项目的依赖项添加。
- en: 'The `dependencies` section is used to automatically detect and install all
    the packages that your project needs. When you are working on a Node.js application
    that has a `package.json` file, you don''t have to manually install each dependency.
    You can just run `npm install` and it will figure everything out based on the
    `dependencies` section of the `package.json` file. Here is an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`部分用于自动检测和安装项目所需的所有包。当您在一个具有`package.json`文件的Node.js应用程序上工作时，您不必手动安装每个依赖项。您只需运行`npm
    install`，它将根据`package.json`文件的`dependencies`部分自动解决所有问题。这里是一个例子：'
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Even though no package was specified, npm assumes you want to install all the
    dependencies for the current package, which reads from `package.json`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有指定任何包，npm假定您想要安装当前包的所有依赖项，这些依赖项来自`package.json`。
- en: 'Besides adding the `dependencies` section to your `package.json` file, it also
    created a `node_modules` folder. That is where it downloads and keep all the packages
    for your project. You can check what is inside `node_modules` by using the list
    command (`ls`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向`package.json`文件添加`dependencies`部分之外，它还创建了一个`node_modules`文件夹。那是它下载并保留项目所有包的地方。您可以使用列表命令（`ls`）检查`node_modules`中的内容：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you run `npm install` again to install the commander, you will notice that
    npm won''t install the package again. It only shows the package as updated and
    audited:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行`npm install`来安装commander，您会注意到npm不会再次安装该包。它只显示该包已更新和已审核：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the next exercise, we will build an npm package that uses commander as a
    dependency and then creates a command-line HTML generator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将构建一个使用commander作为依赖项的npm包，然后创建一个命令行HTML生成器。
- en: 'Exercise 10: Creating a Command-Line HTML Generator'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：创建一个命令行HTML生成器
- en: Now that you have learned the basics of using npm to create a package and how
    to install some dependencies, let's put this all together and build a command-line
    tool that can generate HTML templates for your next website project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了使用npm创建包以及如何安装一些依赖项的基础知识，让我们把这些知识整合起来，构建一个可以为您的下一个网站项目生成HTML模板的命令行工具。
- en: In this exercise, you will create an npm package that uses commander as a dependency
    to process command-line arguments. Then, you will explore the tool that you have
    created and generate some HTML files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个npm包，该包使用commander作为处理命令行参数的依赖项。然后，您将探索您创建的工具，并生成一些HTML文件。
- en: The code for this exercise can be found on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/Exercise10](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/Exercise10).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码可以在GitHub上找到，网址为[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/Exercise10](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/Exercise10)。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Create a new folder where you are going to put all the files for this exercise.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，您将在其中放置此练习的所有文件。
- en: 'In the command line, change to the new folder and run `npm init` to initialize
    a `package.json` file. Picking all the default options should be enough:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，切换到新文件夹并运行`npm init`来初始化一个`package.json`文件。选择所有默认选项应该就足够了：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Install the `commander` package as a dependency:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`commander`包作为依赖项：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In your `package.json`, add the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`package.json`中，添加以下内容：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This means that the entry point for our application is the `index.js` file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应用程序的入口点是`index.js`文件。
- en: 'Run an npm package that has an entry point and use the `node` command, passing
    the directory that contains the `package.json` file in it. The following is an
    example that runs the package in `Lesson02/sample_npm`, which is available at
    [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/sample_npm](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/sample_npm):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个具有入口点的npm包，并使用`node`命令，传递包含`package.json`文件的目录。以下是一个在`Lesson02/sample_npm`中运行该包的示例，该示例可在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/sample_npm](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson02/sample_npm)上找到：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a file called `index.js` and in it, load the `commander` package using
    the `require` function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.js`的文件，在其中使用`require`函数加载`commander`包：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That is all you need to start using an external package.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您开始使用外部包所需要的全部内容。
- en: 'Commander parses the arguments that are passed into your Node.js application.
    You can configure it to tell it what type of parameters you are expecting. For
    this application, we will have three options: `-b` or `--add-bootstrap`, which
    adds bootstrap 4 to the generated output; `-c` or `--add-container`, which adds
    a `<div>` tag with the ID container in the body; and `-t` or `--title`, which
    adds a `<title>` to the page that accepts the text to add in the title.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Commander解析传入Node.js应用程序的参数。您可以配置它告诉它您期望的参数类型。对于这个应用程序，我们将有三个选项：`-b`或`--add-bootstrap`，它将在生成的输出中添加bootstrap
    4；`-c`或`--add-container`，它将在body中添加一个带有ID container的`<div>`标签；以及`-t`或`--title`，它将在页面上添加一个接受标题文本的`<title>`。
- en: 'To configure commander, we call the version method and then the option method
    multiple times to add each option that our application will support. Lastly, we
    call `parse`, which will verify that the arguments that are passed in (`process.argv`
    will be discussed in detail in the next chapter) match the expected options:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置commander，我们调用version方法，然后多次调用option方法来添加应用程序将支持的每个选项。最后，我们调用`parse`，它将验证传入的参数（`process.argv`将在下一章详细讨论）是否与预期的选项匹配：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, you can run your application and check out the results so far:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以运行您的应用程序并查看到目前为止的结果：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will receive the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can see that commander gives you a nice help message explaining how your
    tool is supposed to be used.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到commander为您提供了一个很好的帮助消息，解释了您的工具应该如何使用。
- en: 'Now, let''s use these options to generate the HTML. The first thing we need
    to do is declare a variable that will hold all the HTML:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用这些选项来生成HTML。我们需要做的第一件事是声明一个变量，用于保存所有的HTML：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can initialize it with the `<html>` and `<head>` opening tags.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`<html>`和`<head>`开放标签来初始化它。
- en: 'Then, check whether the program received the `title` option. If it did, add
    a `<title>` tag with the content passed in the tag:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查程序是否接收到`title`选项。如果是，就添加一个带有传入标签内容的`<title>`标签：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Do the same thing for the `Bootstrap` option. In this case, the option is just
    a Boolean, so you just check and add a `<link>` tag pointing to the `Bootstrap.css`
    file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Bootstrap`选项也是同样的操作。在这种情况下，选项只是一个布尔值，因此您只需检查并添加一个指向`Bootstrap.css`文件的`<link>`标签：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Close the `<head>` tag and open the `<body>` tag:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`<head>`标签并打开`<body>`标签：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check for the container `<div>` option and add it if enabled:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查容器`<div>`选项，并在启用时添加它：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, close the `<body>` and `<html>` tags and print the HTML to the console:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭`<body>`和`<html>`标签，并将HTML打印到控制台：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running the application with no options will give us a very simple HTML:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带任何选项运行应用程序将给我们一个非常简单的HTML：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the application, enabling all the options:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，启用所有选项：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: npm makes it really easy to use packages in your applications. Packages such
    as commander and the other hundreds of thousands in the npm repository make Node.js
    a great alternative for building powerful and complex applications with very little
    code. Exploring and learning how to use packages can save you a lot of time and
    effort, making the difference between a project that never sees the light of day
    and a successful application that's used by millions of users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: npm使得在您的应用程序中使用包变得非常容易。像commander和npm存储库中的其他数以千计的包使得Node.js成为构建功能强大且复杂的应用程序的绝佳选择，而代码量却很少。探索和学习如何使用包可以为您节省大量时间和精力，这将决定一个项目是否能够成功应用于数百万用户。
- en: In this exercise, you created an npm package that uses an external package to
    parse command-line arguments, which in general is a laborious task. You have configured
    the commander to parse the arguments into a nice useable format and also learned
    how to use the parsed arguments to build an application that makes decisions based
    on input from the user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个npm包，使用外部包来解析命令行参数，这通常是一项费力的任务。您已经配置了commander来将参数解析为一个很好的可用格式，并学会了如何使用解析后的参数来构建一个根据用户输入做出决策的应用程序。
- en: Dependencies
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项
- en: In the previous section, we saw how npm uses the `dependencies` section of your
    `package.json` file to keep track of the dependencies your package has. Dependencies
    are a complex topic, but what you must keep in mind is that npm supports the semantic
    version, or semver, format for version numbers and that it can use interval and
    other complicated operators to determine what versions of other packages yours
    can accept.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到npm如何使用`package.json`文件的`dependencies`部分来跟踪您的包的依赖关系。依赖关系是一个复杂的话题，但您必须记住的是，npm支持语义版本或semver格式的版本号，并且它可以使用区间和其他复杂的运算符来确定您的包可以接受其他包的哪些版本。
- en: 'By default, as we saw in the previous exercise, npm marks all the package versions
    with a caret, such as 2.20.0\. That caret means that your package can use any
    version that''s compatible with 2.20.0\. Compatibility, in the sense of semver,
    means that new minor or patch versions are considered valid since they are backward
    compatible:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正如我们在上一个练习中看到的，npm使用插入符号标记所有包版本，例如2.20.0。该插入符号表示您的包可以使用与2.20.0兼容的任何版本。在语义版本的意义上，兼容性意味着新的次要或补丁版本被认为是有效的，因为它们是向后兼容的：
- en: '![Figure 2.5: Semantic format considering minor and patch versions as valid'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：将次要和补丁版本视为有效的语义格式'
- en: '](Images/C14587_02_05.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_05.jpg)'
- en: 'Figure 2.5: Semantic format considering minor and patch versions as valid'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.5：将次要和补丁版本视为有效的语义格式
- en: Compatible versions with 2.20.0 are 2.21.0 or 2.21.5, or even 2.150.47!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与2.20.0兼容的版本是2.21.0或2.21.5，甚至是2.150.47！
- en: Every now and then, you will want to update the versions of your packages to
    improve security or move to a version that has a fix for some issue you hit in
    one of your dependencies. That is the reason why npm adds the caret for versions
    of packages you install. With one command, you can update all your dependencies
    to newer compatible versions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能希望更新您的软件包版本，以提高安全性或转移到具有解决某些依赖项中出现的问题的版本。这就是为什么npm为您安装的软件包版本添加了插入符号的原因。使用一个命令，您可以将所有依赖项更新为更新的兼容版本。
- en: 'Let''s say, for example, that a command-line application that was started a
    long time ago was using version 2.0.0 of commander. When the developer ran the
    `install` command, they got version 2.0.0 in their `package.json` file. A few
    years later, they go back and notice that there are some security vulnerabilities
    in commander. They can just run the `npm update` command to take care of that:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很久以前启动的命令行应用程序使用的是commander的2.0.0版本。当开发人员运行`install`命令时，他们在`package.json`文件中得到了2.0.0版本。几年后，他们回过头来注意到commander中存在一些安全漏洞。他们只需运行`npm
    update`命令来解决这个问题：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Most of the time, developers follow the semver convention and do not make breaking
    changes with minor or patch version changes. But when projects grow, the number
    of dependencies quickly gets to the thousands or even tens of thousands, and the
    probability of breaking changes or compatibility issues grows exponentially.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，开发人员遵循语义版本控制规范，并不会在次要或补丁版本更改时进行破坏性更改。但是，随着项目的增长，依赖项的数量很快就会达到成千上万，破坏性更改或兼容性问题的概率呈指数级增长。
- en: To help you in times when you get complicated dependency trees, npm also generates
    a `package-lock.json` file. This file contains a representation of the packages
    in your `node_modules` directory, as they were when you last changed the packages
    you depend on. This can happen when you install a new dependency using the `install`
    command or update versions using the `update` command.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您在出现复杂的依赖树时，npm还会生成一个`package-lock.json`文件。该文件包含了您的`node_modules`目录中的软件包的表示，就像您上次更改依赖包时一样。当您使用`install`命令安装新依赖项或使用`update`命令更新版本时，就会发生这种情况。
- en: The `package-lock.json` file should be checked in with the rest of your code
    because it keeps track of your dependency tree and is useful for debugging complicated
    compatibility issues. `node_modules`, on the other hand, should always be added
    to your `.gitignore` file since npm can recreate that folder any time using information
    from your `package.json` and `package-lock.json` files and downloading the packages
    from the npm repository.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`package-lock.json`文件应该与您的其他代码一起检查，因为它跟踪您的依赖树，并且对于调试复杂的兼容性问题非常有用。另一方面，`node_modules`应该始终添加到您的`.gitignore`文件中，因为npm可以使用来自您的`package.json`和`package-lock.json`文件的信息随时重新创建该文件夹，并从npm存储库下载包。'
- en: Besides the `dependencies` section, your `package.json` file can also contain
    a `devDependencies` section. This section is a way for developers to keep dependencies
    they use during building or testing the package, but others won't need it. This
    can include tools such as `babel` to `transpile` code or testing frameworks such
    as `jest`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`dependencies`部分，您的`package.json`文件还可以包含一个`devDependencies`部分。这个部分是开发人员在构建或测试包时使用的依赖项，但其他人不需要。这可以包括诸如`babel`之类的工具来`转译`代码，或者诸如`jest`之类的测试框架。
- en: Dependencies in `devDependencies` don't get pulled when your package is pulled
    by other packages to use. Some frameworks, such as Webpack or `Parcel.js`, also
    have a production model that will ignore these dependencies when creating the
    final bundle.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`devDependencies`中的依赖项在其他包使用时不会被拉取。一些框架，如Webpack或`Parcel.js`，也有一个生产模型，将在创建最终捆绑包时忽略这些依赖项。'
- en: npm Scripts
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: npm脚本
- en: 'When you run the `npm init` command, the `package.json` file that gets created
    has a `scripts` section in it. By default, a test script is added to it. This
    is what it looks like:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`npm init`命令时，创建的`package.json`文件中将包含一个`scripts`部分。默认情况下，会添加一个测试脚本。它看起来像这样：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Scripts can be used to run any type of command that a developer may need when
    working on a package. Common examples of scripts are testing, linting, and other
    code analysis tools. It is also possible to have scripts to start an application
    or any other thing you can do from the command line.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可用于运行开发人员在处理软件包时可能需要的任何类型的命令。脚本的常见示例包括测试、linting和其他代码分析工具。还可以有脚本来启动应用程序或从命令行执行其他任何操作。
- en: 'To define a script, you add an attribute to the `scripts` section, where the
    value is the script that will be executed, as in the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个脚本，您需要在`scripts`部分添加一个属性，其中值是将要执行的脚本，如下所示：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding code creates a script called `myscript`. When invoked, it will
    print the text "Hello World!".
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为`myscript`的脚本。当调用时，它将打印文本“Hello World!”。
- en: 'To invoke a script, you can use the `npm run` or run-script command, passing
    in the name of the script:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个脚本，您可以使用`npm run`或run-script命令，传入脚本的名称：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'npm will output all the details of what is being executed to let you know what
    it is doing. You can ask it to be silent by using the `--silent` (or `-s`) option:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: npm将输出正在执行的所有细节，以让您知道它在做什么。您可以使用`--silent`（或`-s`）选项要求它保持安静：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'One interesting thing about scripts is that you can use the prefixes "pre"
    and "post" to invoke other scripts before and after you do setup and/or cleanup
    tasks. The following is an example of such usage:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 关于脚本的一个有趣的事情是，您可以使用前缀“pre”和“post”在设置和/或清理任务之前和之后调用其他脚本。以下是这种用法的一个例子：
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`index.js` is a Node.js script that reads a name from a `name.txt` file and
    prints a hello message. The `exec` script will execute the `index.js` file. The
    pre and post `exec` scripts will be automatically called before and after the
    exec one, creating and deleting the `name.txt` file (in Windows, you can use the
    `del` command instead of `rm`). Running the exec script will result in the following
    output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`是一个Node.js脚本，它从`name.txt`文件中读取名称并打印一个hello消息。`exec`脚本将执行`index.js`文件。在执行之前和之后，将自动调用预和后`exec`脚本，创建和删除`name.txt`文件（在Windows中，您可以使用`del`命令而不是`rm`）。运行exec脚本将产生以下输出：'
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can see that, before invoking the exec script, the `name.txt` file didn't
    exist. The `preexec` script is invoked, which creates the file with the name inside.
    Then, the JavaScript is called and prints the hello message. Finally, the `postexec`
    script is invoked, which deletes the file. You can see that the `name.txt` file
    doesn't exist after npm's execution has finished.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在调用exec脚本之前，`name.txt`文件不存在。调用`preexec`脚本，它将创建带有名称的文件。然后调用JavaScript并打印hello消息。最后，调用`postexec`脚本，它将删除文件。您可以看到，在npm执行完成后，`name.txt`文件不存在。
- en: 'npm also comes with some predefined script names. Some of them are published,
    install, pack, test, stop, and start. The advantage of these predefined names
    is that you don''t need to use the `run` or `run-script` command; you can directly
    invoke the script by name. For example, to invoke the default test script created
    by `npm init`, you can just call `npm test`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: npm还带有一些预定义的脚本名称。其中一些是published，install，pack，test，stop和start。这些预定义名称的优势在于您不需要使用`run`或`run-script`命令；您可以直接按名称调用脚本。例如，要调用由`npm
    init`创建的默认测试脚本，只需调用`npm test`：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, you can see that it fails since it has an `exit 1` command, which makes
    the npm script's execution fail since any command that exits with a non-zero status
    will make the invocation stop immediately.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到它失败了，因为它有一个`exit 1`命令，这使得npm脚本的执行失败，因为任何以非零状态退出的命令都会立即使调用停止。
- en: '`start` is a widely used script to start web servers for local frontend development.
    The exec example in the preceding code could be rewritten to look like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`是一个广泛使用的脚本，用于启动本地前端开发的Web服务器。前面代码中的exec示例可以重写为以下形式：'
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, it can be be run just by calling `npm start`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需调用`npm start`即可运行：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: One important thing to keep in mind when writing npm scripts is whether there
    is a need to make them platform independent. For example, if you are working with
    a big group of developers and some of them use Windows machines and some use Mac
    and/or Linux, scripts that are written to run in Windows will probably fail in
    the Unix world, and vice versa. JavaScript is a perfect use case for this since
    Node.js abstracts platform dependency away for you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 编写npm脚本时要牢记的一件重要事情是是否有必要使它们独立于平台。例如，如果您正在与一大群开发人员一起工作，其中一些人使用Windows机器，另一些人使用Mac和/或Linux，那么在Windows中编写的脚本可能会在Unix世界中失败，反之亦然。JavaScript是这种情况的完美用例，因为Node.js为您抽象了平台依赖性。
- en: As we saw in the previous chapter, sometimes we want to extract data from a
    web page. In that chapter, we used some JavaScript that was injected into the
    page from the Developer Tools Console tab to do that so that didn't need to write
    an application for it. Now, you will write a Node.js application to do something
    similar.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，有时我们想从网页中提取数据。在那一章中，我们使用了一些JavaScript，它是从开发者工具控制台选项卡中注入到页面中的，这样就不需要为此编写应用程序。现在，您将编写一个Node.js应用程序来做类似的事情。
- en: 'Activity 3: Creating an npm Package to Parse HTML'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：创建一个用于解析HTML的npm包
- en: In this activity, you will use npm to create a new package. Then, you will write
    some Node.js code to load and parse the HTML code using a library called `cheerio`.
    With the loaded HTML, you will query and manipulate it. In the end, you will print
    the manipulated HTML to see the results.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将使用npm创建一个新的包。然后，您将编写一些Node.js代码来使用名为`cheerio`的库加载和解析HTML代码。有了加载的HTML，您将查询和操作它。最后，您将打印操作后的HTML以查看结果。
- en: 'The steps to perform are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的步骤如下：
- en: Use npm to create a new package inside a new folder.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm在新文件夹中创建一个新包。
- en: Install a library called `cheerio` using `npm install` ([https://www.npmjs.com/package/cheerio](https://www.npmjs.com/package/cheerio)).
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`（[https://www.npmjs.com/package/cheerio](https://www.npmjs.com/package/cheerio)）安装一个名为`cheerio`的库。
- en: Create a new entry file called `index.js` and inside it, load the `cheerio`
    library.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.js`的新条目文件，并在其中加载`cheerio`库。
- en: 'Create a variable that stores the HTML from the first sample from *Chapter
    1, JavaScript, HTML, and the DOM* (the file can be found in GitHub: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html)).'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，用于存储*第1章，JavaScript，HTML和DOM*中第一个示例的HTML（文件可以在GitHub上找到：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html)）。
- en: Use cheerio to load and parse the HTML.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用cheerio加载和解析HTML。
- en: Add a paragraph element with some text into the `div` in the loaded HTML.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载的HTML中的`div`中添加一个带有一些文本的段落元素。
- en: Using cheerio, iterate over all the paragraphs in the current page, and print
    their content to the console.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用cheerio，迭代当前页面中的所有段落，并将它们的内容打印到控制台。
- en: Print the manipulated version of the console.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印控制台的操作版本。
- en: Run your application.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。
- en: 'The output should look something like the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像下面这样：
- en: '![Figure 2.6: Expected output after calling the application from node.js'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：从node.js调用应用程序后的预期输出'
- en: '](Images/C14587_02_06.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_06.jpg)'
- en: 'Figure 2.6: Expected output after calling the application from Node.js'
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：从Node.js调用应用程序后的预期输出
- en: Note
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 588.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第588页找到。
- en: In this activity, you created a Node.js application by using the npm init command.
    Then, you imported an HTML parser library. You used it to manipulate and query
    the parsed HTML. In the next chapter, we will continue to explore techniques that
    will help us scrape web pages faster and we will actually use against a website.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动中，你使用npm init命令创建了一个Node.js应用程序。然后，你导入了一个HTML解析库，用它来操作和查询解析后的HTML。在下一章中，我们将继续探索技术，帮助我们更快地抓取网页，并且我们将实际应用于一个网站。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about what Node.js is and how its single-threaded,
    asynchronous, event-driven programming model can be used to build simple and efficient
    applications. We also learned about nvm and how to manage multiple versions of
    Node.js. Then, we studied npm and used external libraries in our Node.js applications.
    Finally, we learned what npm scripts are and some basic concepts related to them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Node.js是什么，以及它的单线程、异步、事件驱动的编程模型如何用于构建简单高效的应用程序。我们还学习了nvm以及如何管理多个Node.js版本。然后，我们学习了npm，并在我们的Node.js应用程序中使用了外部库。最后，我们学习了npm脚本以及与其相关的一些基本概念。
- en: To help you understand what you learned about in this chapter, you can go to
    the npm repository, find some projects, and explore their code bases. The best
    way to learn about npm, Node.js, and the packages and libraries that exist out
    there is to explore other people's code and see what and how they are building
    and also what libraries they use.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解本章学到的内容，你可以去npm仓库，找一些项目，探索它们的代码库。了解npm、Node.js以及存在的包和库的最佳方法是探索其他人的代码，看看他们是如何构建的，以及他们使用了哪些库。
- en: In the next chapter, we will explore the Node.js APIs and learn how to use them
    to build a real web scraping application. In future chapters, you will learn how
    to use npm scripts and packages to improve the quality of your code through linting
    and automated tests.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Node.js的API，并学习如何使用它们来构建一个真正的网页抓取应用程序。在未来的章节中，你将学习如何使用npm脚本和包来通过linting和自动化测试来提高代码质量。
