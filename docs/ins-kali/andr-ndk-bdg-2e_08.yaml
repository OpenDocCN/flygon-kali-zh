- en: Chapter 8. Handling Input Devices and Sensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。处理输入设备和传感器
- en: '*Android is all about interaction. Admittedly, that means feedback, through
    graphics, audio, vibrations, and so on. But there is no interaction without input!
    The success of today''s smartphones takes its root in their multiple and modern
    input possibilities: touchscreens, keyboard, mouse, GPS, accelerometer, light
    detector, sound recorder, and so on. Handling and combining them properly is a
    key to enrich your application and to make it successful.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android的一切都与交互有关。可以承认，这意味着通过图形、音频、振动等方式进行反馈。但是没有输入就没有交互！今天智能手机的成功根源在于它们多样化和现代化的输入方式：触摸屏、键盘、鼠标、GPS、加速计、光线探测器、录音等等。正确处理和组合它们是丰富您的应用程序并使其成功的关键。*'
- en: 'Although Android handles many input peripherals, the Android NDK has long been
    very limited in its support (not to say the very least), until the release of
    R5! We can now access it directly through a native API. Examples of available
    devices are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Android处理许多输入外设，但直到R5的发布之前，Android NDK在支持方面一直非常有限（甚至可以说是最少的）！现在我们可以通过本机API直接访问它。可用设备的示例包括：
- en: Keyboard, either physical (with a slide-out keyboard) or virtual (which appears
    on screen)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘，无论是物理键盘（带滑出键盘）还是虚拟键盘（显示在屏幕上）
- en: Directional pad (up, down, left, right, and action buttons), often abbreviated
    as D-Pad.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方向键（上、下、左、右和动作按钮），通常简称为D-Pad。
- en: Trackball, optical ones included
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹球，包括光学轨迹球。
- en: Touchscreen, which has made modern smart-phones successful
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏，使现代智能手机成功
- en: Mouse or Track Pad (since NDK R5, but available on Honeycomb devices only)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标或轨迹板（自NDK R5以来，但仅适用于Honeycomb设备）
- en: 'We can also access hardware sensors, which are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问硬件传感器，包括：
- en: Accelerometer, which measures the linear acceleration applied to a device.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计，用于测量施加在设备上的线性加速度。
- en: Gyroscope, which measures the angular velocity. It is often combined with the
    magnetometer to compute orientation accurately and quickly. Gyroscope has been
    introduced recently and is not available on most devices yet.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陀螺仪，用于测量角速度。通常与磁力计结合以准确快速地计算方向。陀螺仪最近才被引入，尚未在大多数设备上可用。
- en: Magnetometer, which gives the ambient magnetic field and consequently the cardinal
    direction.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁力计，提供环境磁场和因此基本方向。
- en: Light sensor, for example, to automatically adapt to screen luminosity.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线传感器，例如自动适应屏幕亮度。
- en: Proximity sensor, for example, to detect ear distance during a call.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接近传感器，例如在通话期间检测耳朵距离。
- en: 'In addition to hardware sensors, "software sensors" have been introduced with
    Gingerbread. These sensors are derived from the hardware sensor''s data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬件传感器，“软件传感器”也在Gingerbread中引入。这些传感器源自硬件传感器的数据：
- en: Gravity sensor, to measure the gravity direction and magnitude
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力传感器，用于测量重力方向和大小
- en: Linear acceleration sensor, which measures device "movement" excluding gravity
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性加速度传感器，测量设备的“运动”，不包括重力
- en: Rotation vector, which indicates device orientation in space
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转矢量，指示设备在空间中的方向
- en: The gravity sensor and the linear acceleration sensor are derived from the accelerometer.
    On the other hand, rotation vector is derived from the magnetometer and the accelerometer.
    Because these sensors are generally computed over time, they usually incur a slight
    delay in getting up-to-date values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重力传感器和线性加速度传感器源自加速度计。另一方面，旋转矢量源自磁力计和加速度计。因为这些传感器通常是随时间计算的，所以通常会在获取最新值时产生轻微延迟。
- en: 'To familiarize ourselves more deeply with input devices and sensors, this chapter
    teaches how to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地熟悉输入设备和传感器，本章教授如何：
- en: Handle screen touches
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理屏幕触摸
- en: Detect keyboard, D-Pad, and trackball events
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测键盘、D-Pad和轨迹球事件
- en: Turn the accelerometer sensor into a joypad
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加速度计传感器转换为手柄
- en: Interacting with touch events
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与触摸事件交互
- en: The most emblematic innovation of today's smart phones is the touchscreen, which
    has replaced the now antique mice. A touchscreen detects, as its name suggests,
    touches made with fingers or styluses on a device's surface. Depending on the
    quality of the screen, several touches (also referred to as cursors in Android)
    can be handled, de-multiplying interaction possibilities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 今天智能手机最具标志性的创新是触摸屏，它取代了现在过时的鼠标。触摸屏如其名称所示，可以检测设备表面上用手指或触控笔进行的触摸。根据屏幕的质量，可以处理多个触摸（在Android中也称为光标），从而增加了交互可能性。
- en: 'So let''s start this chapter by handling touch events in `DroidBlaster`. To
    keep the example simple, we will only handle a single "touch". The goal is to
    move the ship in the direction of touch. The farther the touch, the faster the
    ship goes. Beyond a predefined range `TOUCH_MAX_RANGE`, the ship''s speed reaches
    its speed limit, as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从在`DroidBlaster`中处理触摸事件开始这一章。为了保持示例简单，我们将只处理单个“触摸”。目标是将飞船移动到触摸的方向。触摸越远，飞船速度越快。超出预定义范围`TOUCH_MAX_RANGE`后，飞船的速度达到其速度极限，如下图所示：
- en: '![Interacting with touch events](img/9645OS_08_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![与触摸事件交互](img/9645OS_08_01.jpg)'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part13`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以“DroidBlaster_Part13”命名提供。
- en: Time for action – handling touch events
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-处理触摸事件
- en: 'Let''s intercept touch events in `DroidBlaster`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拦截`DroidBlaster`中的触摸事件：
- en: 'In the same way that we created `ActivityHandler` to process application events
    in [Chapter 5](ch05.html "Chapter 5. Writing a Fully Native Application"), *Writing
    a Fully Native Application*, create `jni/InputHandler.hpp` to process input events.
    The input API is declared in `android/input.h`. Create `onTouchEvent()` to handle
    touch events. These events are packaged in an `AInputEvent` structure. Other input
    peripherals will be described later in this chapter:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们在[第5章](ch05.html "第5章。编写完全本地应用程序")中创建`ActivityHandler`来处理应用程序事件的方式相同，创建`jni/InputHandler.hpp`来处理输入事件。输入API在`android/input.h`中声明。创建`onTouchEvent()`来处理触摸事件。这些事件被打包在`AInputEvent`结构中。其他输入外设将在本章后面描述：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Modify the `jni/EventLoop.hpp` header file to include and handle an `InputHandler`
    instance.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`jni/EventLoop.hpp`头文件以包含和处理`InputHandler`实例。
- en: 'In a similar way, to activity events, define an internal method `processInputEvent()`,
    which is triggered by a static callback `callback_input()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于活动事件，定义一个内部方法`processInputEvent()`，它由静态回调`callback_input()`触发：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to process input events in the `jni/EventLoop.cpp` source file and notify
    the associated `InputHandler`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`jni/EventLoop.cpp`源文件中处理输入事件并通知相关的`InputHandler`。
- en: 'First, connect the Android input queue to `callback_input()`. The `EventLoop`
    itself (that is, `this`) is passed anonymously through the `userData` member of
    the `android_app` structure. That way, callback is able to delegate input processing
    back to our own object, that is, to `processInputEvent()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将Android输入队列连接到`callback_input()`。`EventLoop`本身（即`this`）通过`android_app`结构的`userData`成员匿名传递。这样，回调能够将输入处理委托给我们自己的对象，即`processInputEvent()`：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Touchscreen events are of the type `MotionEvent` (as opposed to key events).
    They can be discriminated according to their source (`AINPUT_SOURCE_TOUCHSCREEN`)
    thanks to the Android native input API (here, `AinputEvent_getSource()`):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸屏事件属于`MotionEvent`类型（与按键事件相反）。它们可以根据其来源（`AINPUT_SOURCE_TOUCHSCREEN`）通过Android本机输入API（这里是`AinputEvent_getSource()`）进行区分：
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how `callback_input()` and by extension `processInputEvent()` return an
    integer value (which is intrinsically a Boolean value). This value indicates that
    an input event (for example, a pressed button) has been processed by the application
    and does not need to be processed further by the system. For example, `1` is returned
    when the back button is pressed to stop event processing and prevent the activity
    from getting terminated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`callback_input()`以及扩展的`processInputEvent()`返回一个整数值（本质上是一个布尔值）。这个值表示应用程序已经处理了一个输入事件（例如，按下按钮），不需要系统进一步处理。例如，当按下返回按钮以停止事件处理并防止活动被终止时，返回`1`。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create `jni/InputManager.hpp` to handle touch events and implement our new `InputHandler`
    interface.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/InputManager.hpp`来处理触摸事件并实现我们的新`InputHandler`接口。
- en: 'Define the methods as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方法如下：
- en: '`start()` to perform the necessary initialization.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`执行必要的初始化。'
- en: '`onTouchEvent()` to update the manager state when a new event is triggered.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTouchEvent()`用于在触发新事件时更新管理器状态。'
- en: '`getDirectionX()` and `getDirectionY()` to indicate the ship direction.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`getDirectionX()`和`getDirectionY()`来指示飞船的方向。
- en: '`setRefPoint()` refers to the ship position. Indeed, the direction is defined
    as the vector between the touch point and the ship location (that is, the reference
    point).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRefPoint()`指的是飞船的位置。事实上，方向被定义为触摸点和飞船位置（即参考点）之间的向量。'
- en: Also, declare the necessary members and more specifically `mScaleFactor`, which
    contains the proper ratio to convert the input event from screen coordinates to
    game coordinates (remember that we use a fixed size).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还要声明必要的成员，特别是`mScaleFactor`，其中包含将输入事件从屏幕坐标转换为游戏坐标的正确比例（请记住我们使用固定大小）。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create `jni/InputManager.cpp`, starting with the constructor:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/InputManager.cpp`，从构造函数开始：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write the `start()` method to clear members and compute the scale factor. The
    scale factor is necessary because, as seen in [Chapter 6](ch06.html "Chapter 6. Rendering
    Graphics with OpenGL ES"), *Rendering Graphics with OpenGL ES*, we need to convert
    screen coordinates provided in input events (which depends on the device) into
    game coordinates:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`start()`方法来清除成员并计算比例因子。比例因子是必要的，因为正如在[第6章](ch06.html "第6章。使用OpenGL ES渲染图形")中所看到的，我们需要将输入事件中提供的屏幕坐标（取决于设备）转换为游戏坐标：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The effective event processing comes in `onTouchEvent()`. Horizontal and vertical
    directions are computed according to the distance between the reference point
    and the touch point. This distance is restricted by `TOUCH_MAX_RANGE` to an arbitrary
    range of `65` units. Thus, a ship's maximum speed is reached when the reference-to-touch
    point distance is beyond `TOUCH_MAX_RANGE` pixels.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效的事件处理发生在`onTouchEvent()`中。根据参考点和触摸点之间的距离计算水平和垂直方向。这个距离被限制在`TOUCH_MAX_RANGE`的范围内，范围为`65`个单位。因此，当参考点到触摸点的距离超过`TOUCH_MAX_RANGE`像素时，飞船的最大速度被达到。
- en: 'Touch coordinates are retrieved thanks to `AMotionEvent_getX()` and `AMotionEvent_getY()`
    when you move your finger. The direction vector is reset to `0` when no more touch
    is detected:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动手指时，触摸坐标是通过`AMotionEvent_getX()`和`AMotionEvent_getY()`来获取的。当不再检测到触摸时，方向向量被重置为`0`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a simple component `jni/MoveableBody.hpp`, whose role is to move `PhysicsBody`
    according to input events:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的组件`jni/MoveableBody.hpp`，其作用是根据输入事件移动`PhysicsBody`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implement this component in `jni/MoveableBody.cpp`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/MoveableBody.cpp`中实现这个组件。
- en: '`InputManager` and the body are bound in `registerMoveableBody()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputManager`和物体在`registerMoveableBody()`中绑定：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initially, the body has no velocity.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，物体没有速度。
- en: 'Then, each time it is updated, the velocity mirrors the current input state.
    This velocity is taken in input by `PhysicsManager` created in [Chapter 5](ch05.html
    "Chapter 5. Writing a Fully Native Application"), *Writing a Fully Native Application*,
    to update the entity''s position:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次更新时，速度都会反映当前的输入状态。这个速度由[第5章](ch05.html "第5章。编写完全本机应用程序")中创建的`PhysicsManager`接收输入，*编写完全本机应用程序*，以更新实体的位置：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reference the new `InputManager` and `MoveableComponent` in `jni/DroidBlaster.hpp`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中引用新的`InputManager`和`MoveableComponent`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, adapt the `jni/DroidBlaster.cpp` constructor to instantiate `InputManager`
    and `MoveableComponent`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整`jni/DroidBlaster.cpp`构造函数以实例化`InputManager`和`MoveableComponent`。
- en: Append `InputManager` to `EventLoop`, which dispatches input events, at construction
    time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造时将`InputManager`附加到`EventLoop`，该循环分派输入事件。
- en: 'The spaceship is the entity being moved. So, pass a reference to its location
    to the `MoveableBody` component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船是正在移动的实体。因此，将其位置的引用传递给`MoveableBody`组件：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize and update `MoveableBody` and `InputManager` in the corresponding
    methods:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的方法中初始化和更新`MoveableBody`和`InputManager`：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a simple example of an input system, based on touch events. The ship
    flies toward the touch point at a speed dependent on the touch distance. The touch
    event coordinates are absolute. Their origin is in the upper-left corner of the
    screen, on the opposite of OpenGL, which is on the lower-left corner. If screen
    rotation is permitted by an application, then the screen origin remains on the
    upper-left corner from the user's point of view, whether the device is in portrait
    or landscape mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基于触摸事件的输入系统的简单示例。飞船朝着触摸点飞行，速度取决于触摸距离。触摸事件的坐标是绝对的。它们的原点位于屏幕的左上角，与OpenGL相反，后者位于左下角。如果应用程序允许屏幕旋转，那么屏幕原点从用户的角度来看仍然保持在左上角，无论设备是处于纵向还是横向模式。
- en: '![What just happened?](img/9645OS_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_08_07.jpg)'
- en: To implement this new feature, we connected our event loop to the input event
    queue provided by the `native_app_glue` module. This queue is internally represented
    as a UNIX pipe, like the activity event queue. Touchscreen events are embedded
    in an `AInputEvent` structure, which stores other kinds of input events. Input
    events are handled with the `AInputEvent` and `AMotionEvent` API declared in `android/input.h`.
    The `AInputEvent` API is necessary to discriminate input event types using `AInputEvent_getType()`
    and `AInputEvent_getSource()` methods. The `AMotionEvent` API provides methods
    to handle touch events only.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一新功能，我们将我们的事件循环连接到`native_app_glue`模块提供的输入事件队列。这个队列在内部被表示为一个UNIX管道，就像活动事件队列一样。触摸屏事件嵌入在`AInputEvent`结构中，该结构存储其他类型的输入事件。输入事件使用`android/input.h`中声明的`AInputEvent`和`AMotionEvent`
    API进行处理。`AInputEvent` API是必要的，以使用`AInputEvent_getType()`和`AInputEvent_getSource()`方法来区分输入事件类型。`AMotionEvent`
    API提供了处理触摸事件的方法。
- en: 'The touch API is rather rich. Many details can be requested as shown in the
    following table (non-exhaustively):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸API相当丰富。可以根据以下表格中显示的许多细节进行请求（非穷尽）：
- en: '| Method | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| To detect whether a finger makes contact with the screen, leaving it, or
    moving over the surface.The result is an integer value composed of the event type
    (on byte `1`, for example, `AMOTION_EVENT_ACTION_DOWN`) and a pointer index (on
    byte `2`, to know which finger the event refers to). |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 检测手指是否接触屏幕，离开屏幕或在表面上移动。结果是一个整数值，由事件类型（例如，字节`1`上的`AMOTION_EVENT_ACTION_DOWN`）和指针索引（例如，字节`2`上的，以了解事件所指的手指）组成。
    |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| To retrieve touch coordinates on screen, expressed in pixels as a float (sub-pixel
    values are possible). |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 以浮点数形式检索屏幕上的触摸坐标（可能存在子像素值）。 |'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| To retrieve how much time a finger has been sliding over the screen and when
    the event was generated in nanoseconds. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 检索手指在屏幕上滑动了多长时间以及事件生成的纳秒数。 |'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| To detect the pressure intensity and zone. Values usually range between `0.0`
    and `1.0` (but may exceed it). Size and pressure are generally closely related.
    The behavior can vary greatly and be noisy, depending on hardware. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 检测压力强度和区域。值通常在`0.0`和`1.0`之间（但可能超过）。大小和压力通常密切相关。行为可能会因硬件的不同而有很大变化并且可能会有噪音。'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Touch events of type `AMOTION_EVENT_ACTION_MOVE` can be grouped together
    for efficiency purposes. These methods give access to these *historical points*
    that occurred between previous and current events. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 类型为`AMOTION_EVENT_ACTION_MOVE`的触摸事件可以为了效率而被分组在一起。这些方法可以访问发生在前一个和当前事件之间的这些*历史点*。
    |'
- en: Have a look at `android/input.h` for an exhaustive list of methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`android/input.h`以获取方法的详尽列表。
- en: 'If you look more deeply at the `AMotionEvent` API, you will notice that some
    events have a second parameter `pointer_index`, which ranges between `0` and the
    number of active pointers. Indeed, most touchscreens today are multi-touch! Two
    or more fingers on a screen (if hardware supports it) are translated in Android
    by two or more pointers. To manipulate them, look at the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更深入地查看`AMotionEvent` API，您会注意到一些事件有第二个参数`pointer_index`，它的范围在`0`到活动指针的数量之间。事实上，今天大多数触摸屏都支持多点触控！在Android中，屏幕上的两个或更多个手指（如果硬件支持）被翻译为两个或更多个指针。要操作它们，请查看以下表格：
- en: '| Method | Description |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| To know how many fingers touch the screen. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 知道有多少手指触摸屏幕。 |'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| To get a pointer unique identifier from a pointer index. This is the only
    way to track a particular pointer (that is, *finger*) over time, as its index
    may change when fingers touch or leave the screen. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 从指针索引获取指针唯一标识符。这是跟踪特定指针（即*手指*）随时间变化的唯一方法，因为当手指触摸或离开屏幕时，其索引可能会发生变化。 |'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you followed the story of the (*now prehistoric!*) Nexus One, then you know
    that it came out with a hardware defect. Pointers were often getting mixed up,
    two of them exchanging one of their coordinates. So always be prepared to handle
    hardware specificities or hardware that behaves incorrectly!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关注过（现在已经过时的！）Nexus One的故事，那么你就知道它出厂时有一个硬件缺陷。指针经常混淆，其中两个指针交换了它们的一个坐标。因此，始终要准备处理硬件特性或行为不正确的硬件！
- en: Detecting keyboard, D-Pad, and Trackball events
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测键盘、D-Pad和轨迹球事件
- en: 'The most common input device among all is the keyboard. This is true for Android
    too. An Android keyboard can be physical: in the device front face (like traditional
    Blackberries) or on a slide-out screen. However, a keyboard is more commonly virtual,
    that is, emulated on the screen at the cost of a large portion of space taken.
    In addition to the keyboard itself, every Android device must include a few physical
    or emulated buttons such as **Menu**, **Home**, and **Tasks**.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有输入设备中，最常见的是键盘。对于Android也是如此。Android键盘可以是物理的：在设备正面（如传统的黑莓手机）或滑出屏幕上。然而，键盘更常见的是虚拟的，即在屏幕上模拟，占用了大量空间。除了键盘本身，每个Android设备都必须包括一些物理或模拟按钮，如**菜单**、**主页**和**任务**。
- en: A much less common type of input device is the Directional-Pad. A D-Pad is a
    set of physical buttons to move up, down, left, or right and a specific action/confirmation
    button. Although they often disappear from recent phones and tablets, D-Pads remain
    one of the most convenient ways to move across text or UI widgets. D-Pads are
    often replaced by trackballs. Trackballs behave similarly to a mouse (the one
    with a ball inside) that would be upside down. Some trackballs are analogical,
    but others (for example, optical ones) behave as a D-Pad (that is, all or nothing).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太常见的输入设备类型是方向键。D-Pad是一组物理按钮，用于向上、向下、向左或向右移动，以及一个特定的动作/确认按钮。尽管它们经常消失在最近的手机和平板电脑上，但D-Pad仍然是移动文本或UI小部件的最方便的方式之一。D-Pad经常被轨迹球所取代。轨迹球的行为类似于鼠标（内部带有一个球）倒置后的行为。一些轨迹球是模拟的，但其他的（例如，光学的）的行为类似于D-Pad（即，全有或全无）。
- en: '![Detecting keyboard, D-Pad, and Trackball events](img/9645OS_08_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![检测键盘、D-Pad和轨迹球事件](img/9645OS_08_02.jpg)'
- en: To see how they work, let's use these peripherals to move our space ship in
    `DroidBlaster`. The Android NDK now allows handling all these input peripherals
    on the native side. So, let's try them!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看它们是如何工作的，让我们使用这些外围设备来移动`DroidBlaster`中的太空飞船。Android NDK现在允许在本地端处理所有这些输入外围设备。所以，让我们来试试吧！
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part14`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书提供的项目名为`DroidBlaster_Part14`。
- en: Time for action – handling keyboard, D-Pad, and trackball events natively
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理键盘、D-Pad和轨迹球事件的本地操作时间
- en: 'Let''s extend our new Input system with more event types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更多的事件类型扩展我们的新输入系统：
- en: 'Open `jni/InputHandler.hpp` and add the keyboard and trackball event handlers:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/InputHandler.hpp`并添加键盘和轨迹球事件处理程序：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Update the method `processInputEvent()` inside the existing file `jni/EventLoop.cpp`
    to redirect the keyboard and trackball events to `InputHandler`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新现有文件`jni/EventLoop.cpp`中的`processInputEvent()`方法，将键盘和轨迹球事件重定向到`InputHandler`。
- en: 'Trackballs and touch events are assimilated to motion events and can be discriminated
    according to their source. On the opposite side, key events are discriminated
    according to their type. Indeed, there exists two dedicated APIs for `MotionEvents`
    (the same for trackballs and touch events) and for `KeyEvents` (identical for
    keyboard, D-Pad, and so on):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 轨迹球和触摸事件被视为运动事件，并可以根据其来源进行区分。相反，键盘事件根据其类型进行区分。事实上，`MotionEvents`（轨迹球和触摸事件相同）和`KeyEvents`（键盘、D-Pad等相同）有两个专用的API：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `jni/InputManager.hpp` file to override these new methods:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`jni/InputManager.hpp`文件以覆盖这些新方法：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `jni/InputManager.cpp`, process the keyboard events in `onKeyboardEvent()`
    using:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.cpp`中，使用`onKeyboardEvent()`处理键盘事件：
- en: '`AKeyEvent_getAction()` to get the event type (that is, pressed or not).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AKeyEvent_getAction()`获取事件类型（即按下或未按下）。
- en: '`AKeyEvent_getKeyCode()` to get the button identity.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AKeyEvent_getKeyCode()`获取按钮标识。'
- en: In the following code, when left, right, up, or down buttons are pressed, `InputManager`
    calculates the direction and saves it into `mDirectionX` and `mDirectionY`. The
    movement starts when the button is down and stops when it is up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，当按下左、右、上或下按钮时，`InputManager`计算方向并将其保存到`mDirectionX`和`mDirectionY`中。当按钮按下时，移动开始，当按钮松开时，移动停止。
- en: 'Return `true` when the key has been consumed and `false` when it has not. Indeed,
    if a user has pressed, for example, the back button (`AKEYCODE_BACK`) or volume
    buttons (`AKEYCODE_VOLUME_UP`, `AKEYCODE_VOLUME_DOWN`), then we let the system
    react appropriately for us:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当按键被消耗时返回`true`，当按键未被消耗时返回`false`。事实上，如果用户按下了返回按钮（`AKEYCODE_BACK`）或音量按钮（`AKEYCODE_VOLUME_UP`，`AKEYCODE_VOLUME_DOWN`），那么我们让系统适当地为我们做出反应：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, process trackball events in a new method `onTrackballEvent()`. Retrieve
    the trackball magnitude with `AMotionEvent_getX()` and `AMotionEvent_getY()`.
    Because some trackballs do not offer a gradated magnitude, the movements are quantified
    with plain constants. The possible noise is ignored with an arbitrary trigger
    threshold:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在一个新的方法`onTrackballEvent()`中处理轨迹球事件。使用`AMotionEvent_getX()`和`AMotionEvent_getY()`检索轨迹球大小。由于一些轨迹球不提供分级大小，因此使用纯粹的常数对移动进行量化。可能的噪音被忽略，设定了一个任意的触发阈值：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When using a trackball that way, the ship moves until a "counter-movement"
    (for example, requesting to go to the right when going left) or action button
    is pressed (the last `else` section):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用轨迹球时，飞船会移动，直到出现“反向运动”（例如，在向左移动时请求向右移动）或按下动作按钮（最后的`else`部分）：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*What just happened?*'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We extended our input system to handle the keyboard, D-Pad, and trackball events.
    D-Pad can be considered as a keyboard extension and is processed the same way.
    Indeed, D-Pad and keyboard events are transported in the same structure (`AInputEvent`)
    and handled by the same API (prefixed with `AKeyEvent`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了我们的输入系统以处理键盘、D-Pad和轨迹球事件。D-Pad可以被视为键盘的扩展，并且以相同的方式处理。实际上，D-Pad和键盘事件被传输到相同的结构（`AInputEvent`）中，并由相同的API（以`AKeyEvent`为前缀）处理。
- en: 'The following table lists the main key event methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了主要的键事件方法：
- en: '| Method | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AKeyEvent_getAction()` | Indicates whether the button is down (`AKEY_EVENT_ACTION_DOWN`)
    or released (`AKEY_EVENT_ACTION_UP`). Note that multiple key actions can be emitted
    in batch (`AKEY_EVENT_ACTION_MULTIPLE`). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getAction()` | 指示按钮是按下（`AKEY_EVENT_ACTION_DOWN`）还是释放（`AKEY_EVENT_ACTION_UP`）。请注意，可以批量发出多个键动作（`AKEY_EVENT_ACTION_MULTIPLE`）。
    |'
- en: '| `AKeyEvent_getKeyCode()` | To retrieve the actual button being pressed (defined
    in `android/keycodes.h`), for example, `AKEYCODE_DPAD_LEFT` for the left button.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getKeyCode()` | 检索实际被按下的按钮（在`android/keycodes.h`中定义），例如，左按钮的`AKEYCODE_DPAD_LEFT`。
    |'
- en: '| `AKeyEvent_getFlags()` | Key events can be associated with one or more flags
    that give various kinds of information on the event, such as `AKEY_EVENT_LONG_PRESS`,
    `AKEY_EVENT_FLAG_SOFT_KEYBOARD` for the event originated from an emulated keyboard.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getFlags()` | 键盘事件可以与一个或多个标志相关联，这些标志提供有关事件的各种信息，例如`AKEY_EVENT_LONG_PRESS`，`AKEY_EVENT_FLAG_SOFT_KEYBOARD`表示事件源自模拟键盘。
    |'
- en: '| `AKeyEvent_getScanCode()` | Is similar to a key code except that this is
    the raw key ID, dependent and different from device to device. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getScanCode()` | 类似于键码，但这是原始的键ID，因设备而异。 |'
- en: '| `AKeyEvent_getMetaState()` | Meta states are flags that indicate whether
    some modifier keys, such as Alt or Shift, are pressed simultaneously (for example,
    `AMETA_SHIFT_ON`, `AMETA_NONE`, and so on). |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getMetaState()` | 元状态是指示某些修改键（例如Alt或Shift）是否同时按下的标志（例如`AMETA_SHIFT_ON`，`AMETA_NONE`等）。
    |'
- en: '| `AKeyEvent_getRepeatCount()` | Indicates how many times the button event
    occurred, usually when you leave the button down. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getRepeatCount()` | 指示按钮事件发生的次数，通常是当你按下按钮时。 |'
- en: '| `AKeyEvent_getDownTime()` | To know when a button was pressed. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getDownTime()` | 了解按钮何时被按下。 |'
- en: 'Although some of them (especially optical ones) behave like a D-Pad, trackballs
    do not use the same API. Actually, trackballs are handled through the `AMotionEvent`
    API (such as touch events). Of course, some information provided for touch events
    is not always available on trackballs. The most important functions to look at
    are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其中一些（尤其是光学的）表现得像D-Pad，轨迹球并不使用相同的API。实际上，轨迹球是通过`AMotionEvent` API（例如触摸事件）处理的。当然，一些提供给触摸事件的信息在轨迹球上并不总是可用的。要查看的最重要的功能如下：
- en: '| `AMotionEvent_getAction()` | To know whether an event represents a move action
    (as opposed to a press action). |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `AMotionEvent_getAction()` | 了解事件是否表示移动操作（与按下操作相对）。 |'
- en: '| `AMotionEvent_getX()``AMotionEvent_getY()` | To get trackball movement. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `AMotionEvent_getX()``AMotionEvent_getY()` | 获取轨迹球移动。 |'
- en: '| `AKeyEvent_getDownTime()` | To know whether the trackball is pressed (such
    as the D-Pad action button). Currently, most trackballs use an all-or-nothing
    pressure to indicate the press event. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getDownTime()` | 了解轨迹球是否被按下（例如D-Pad动作按钮）。目前，大多数轨迹球使用全有或全无的压力来指示按下事件。
    |'
- en: A tricky point to keep in mind when dealing with trackballs is that no event
    is generated to indicate that the trackball is not moving. Moreover, trackball
    events are generated as a "burst", which makes it harder to detect when the movement
    is finished. There is no easy way to handle this, except using a manual timer
    and checking regularly that no event has happened for a sufficient amount of time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 处理轨迹球时需要记住的一个棘手的问题是，没有事件生成来指示轨迹球不在移动。此外，轨迹球事件是作为“突发”生成的，这使得更难以检测移动何时结束。除了使用手动计时器并定期检查一段足够长的时间内是否没有发生事件之外，没有简单的方法来处理这个问题。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never expect peripherals to behave exactly the same on all phones. Trackballs
    are a very good example; they can either indicate a direction like an analogical
    pad or a straight direction like a D-Pad (for example, optical trackballs). There
    is currently no way to differentiate device characteristics from the available
    APIs. The only solutions are to either calibrate the device or configure it at
    runtime or save a kind of device database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要期望外围设备在所有手机上表现完全相同。轨迹球是一个很好的例子；它们可以指示方向，就像模拟摇杆，也可以像D-Pad一样指示直线方向（例如，光学轨迹球）。目前没有办法从可用的API中区分设备特性。唯一的解决方案要么校准设备，要么在运行时配置设备，要么保存一种设备数据库。
- en: Probing device sensors
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测设备传感器
- en: Handling input devices is essential to any application, but probing sensors
    is important for the smartest one! The most spread sensor among Android game applications
    is the accelerometer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 处理输入设备对于任何应用程序都是必不可少的，但探测传感器对于最智能的应用程序也是很重要的！在Android游戏应用程序中最常见的传感器是加速度计。
- en: 'An accelerometer, as its name suggests, measures the linear acceleration applied
    to a device. When moving a device up, down, left, or right, the accelerometer
    gets excited and indicates an acceleration vector in 3D space. Vector is expressed
    in relation to the screen''s default orientation. The coordinate system is relative
    to the device''s natural orientation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计，顾名思义，测量施加在设备上的线性加速度。当向上、向下、向左或向右移动设备时，加速度计会被激发，并在3D空间中指示一个加速度矢量。矢量是相对于屏幕的默认方向表示的。坐标系是相对于设备的自然方向的：
- en: X axis points to the right
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X轴指向右
- en: Y points up
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y向上
- en: Z points from back to front
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z从后到前
- en: Axes become inverted if the device is rotated (for example, Y points left if
    the device is rotated 90 degrees clockwise).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备旋转（例如，如果设备顺时针旋转90度，则Y指向左），轴会变得相反。
- en: 'A very interesting feature of accelerometers is that they undergo a constant
    acceleration: gravity, around 9.8m/s2 on earth. For example, when lying flat on
    a table, acceleration vector indicates -9.8 on the Z-axis. When straight, it indicates
    the same value on Y axis. So assuming the device position is fixed, device orientation
    on two axes in space can be deduced from the gravity acceleration vector. A magnetometer
    is still required to get full device orientation in 3D space.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计非常有趣的一个特性是它们经历恒定的加速度：地球上的重力约为9.8m/s2。例如，当平放在桌子上时，加速度向量在Z轴上指示-9.8。当直立时，它在Y轴上指示相同的值。因此，假设设备位置固定，可以从重力加速度向量中推断出空间中两个轴上的设备方向。在3D空间中仍需要磁力计才能获得完整的设备方向。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that accelerometers work with linear acceleration. They allow detecting
    the translation when the device is not rotating and partial orientation when the
    device is fixed. However, both movements cannot be combined without a magnetometer
    and/or gyroscope.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，加速度计可以用于线性加速度。它们允许在设备不旋转时检测平移，并在设备固定时检测部分方向。然而，这两种运动不能在没有磁力计和/或陀螺仪的情况下结合起来。
- en: So we can use the device orientation deduced from the accelerometer to compute
    a direction. Let's now see how to apply this process in `DroidBlaster`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用从加速度计推断出的设备方向来计算一个方向。现在让我们看看如何在`DroidBlaster`中应用这个过程。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part15`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，提供了名为`DroidBlaster_Part15`的项目。
- en: Time for action – handling accelerometer events
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-处理加速度计事件
- en: 'Let''s handle accelerometer events in `DroidBlaster`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`DroidBlaster`中处理加速度计事件：
- en: 'Open `jni/InputHandler.hpp` and add a new method `onAccelerometerEvent()`.
    Include the `android/sensor.h` official header for sensors:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/InputHandler.hpp`并添加一个新方法`onAccelerometerEvent()`。包括`sensors.h`官方头文件以获取传感器：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create new methods in `jni/EventLoop.hpp`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/EventLoop.hpp`中创建新的方法：
- en: '`activateAccelerometer()` and `deactivateAccelerometer()` to enable/disable
    the accelerometer sensor when the activity starts and stops.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activateAccelerometer()`和`deactivateAccelerometer()`用于在活动启动和停止时启用/禁用加速度计传感器。'
- en: '`processSensorEvent()` retrieves and dispatches sensor events.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processSensorEvent()`检索并分派传感器事件。'
- en: The callback `callback_input()` static method is bound to the Looper.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`callback_input()`静态方法绑定到Looper。
- en: 'Also, define the following members:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义以下成员：
- en: '`mSensorManager`, of type `ASensorManager`, is the main "object" to interact
    with sensors.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorManager`，类型为`ASensorManager`，是与传感器交互的主要“对象”。'
- en: '`mSensorEventQueue` is `ASensorEventQueue`, which is a structure defined by
    the Sensor API to retrieve occurring events.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorEventQueue`是`ASensorEventQueue`，它是由传感器API定义的结构，用于检索发生的事件。'
- en: '`mSensorPollSource` is `android_poll_source` defined in the Native Glue. This
    structure describes how to bind the native thread Looper to the sensor callback.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorPollSource`是在Native Glue中定义的`android_poll_source`。这个结构描述了如何将本地线程Looper绑定到传感器回调。'
- en: '`mAccelerometer`, declared as an `ASensor` structure, represents the sensor
    used:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明为`ASensor`结构的`mAccelerometer`代表所使用的传感器：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Update constructor initialization list in `jni/EventLoop.cpp`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/EventLoop.cpp`中更新构造函数初始化列表：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create the sensor event queue, through which all `sensor` events are notified.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传感器事件队列创建所有`sensor`事件。
- en: Bind it to `callback_sensor()`. Note here that we use the `LOOPER_ID_USER` constant
    provided by the Native App Glue to attach a user-defined queue.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将其绑定到`callback_sensor()`。注意这里我们使用Native App Glue提供的`LOOPER_ID_USER`常量来附加一个用户定义的队列。
- en: 'Then, call `activateAccelerometer()` to initialize the accelerometer sensor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`activateAccelerometer()`初始化加速度计传感器：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When an activity is disabled or terminated, disable the running accelerometer
    to avoid consuming battery needlessly.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当活动被禁用或终止时，禁用正在运行的加速度计以避免不必要地消耗电池。
- en: 'Then, destroy the `sensor` event queue:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，销毁`sensor`事件队列：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`callback_sensor()` is triggered when event loop is polled. It dispatches events
    to `processSensorEvent()` on the `EventLoop` instance. We only care about `ASENSOR_TYPE_ACCELEROMETER`
    events:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事件循环被轮询时，将触发`callback_sensor()`。它将事件分派到`EventLoop`实例上的`processSensorEvent()`。我们只关心`ASENSOR_TYPE_ACCELEROMETER`事件：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Activate the sensor in `activateAccelerometer()` in three main steps:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activateAccelerometer()`中激活传感器有三个主要步骤：
- en: Get a sensor of a specific type with `AsensorManager_getDefaultSensor()`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsensorManager_getDefaultSensor()`获取特定类型的传感器。
- en: Then, enable it with `ASensorEventQueue_enableSensor()` so that the sensor event
    queue gets filled with related events.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用`ASensorEventQueue_enableSensor()`启用它，以便传感器事件队列被相关事件填充。
- en: Set the desired event rate with `ASensorEventQueue_setEventRate()`. For a game,
    we typically want measures close to real time. The minimum delay can be queried
    with `ASensor_getMinDelay()` (setting it to a lower value might result in a failure).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ASensorEventQueue_setEventRate()`设置所需的事件速率。对于游戏，我们通常希望测量接近实时。最小延迟可以通过`ASensor_getMinDelay()`查询（将其设置为较低的值可能会导致失败）。
- en: 'Obviously, we should perform this setup only when the sensor event queue is
    ready:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们应该只在传感器事件队列准备就绪时执行此设置：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Sensor deactivation is easier and only requires a call to the method `AsensorEventQueue_disableSensor()`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传感器停用更容易，只需要调用`AsensorEventQueue_disableSensor()`方法：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We created an event queue to listen to sensor events. Events are wrapped in
    an `ASensorEvent` structure, defined in `android/sensor.h`. This structure provides
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个事件队列来监听传感器事件。事件被包装在`ASensorEvent`结构中，在`android/sensor.h`中定义。这个结构提供了以下内容：
- en: Sensor event origin, that is, which sensor produced this event.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器事件的来源，也就是产生此事件的传感器。
- en: Sensor event occurrence time.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器事件发生时间。
- en: Sensor output value. This value is stored in a union structure, that is, you
    can use either one of the inside structures (here, we are interested in the `acceleration`
    vector).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器输出值。这个值存储在一个联合结构中，也就是说，你可以使用内部结构中的任何一个（这里，我们对`acceleration`向量感兴趣）。
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The same `ASensorEvent` structure is used for any Android sensor. In the case
    of the accelerometer, we retrieve a vector with three coordinates `x`, `y`, and
    `z`, one for each axis:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`ASensorEvent`结构用于任何Android传感器。在加速度计的情况下，我们检索一个带有三个坐标`x`，`y`和`z`的向量，每个轴一个：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our example, the accelerometer is set up with the lowest event rate possible,
    which may vary between devices. It is important to note that the sensor event
    rate has a direct impact on battery saving! So, use a rate that is sufficient
    for your application. The `ASensor` API offers some methods to query the available
    sensors and their capabilities, such as `ASensor_getName()`, `ASensor_getVendor()`,
    `ASensor_getMinDelay()`, and so on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，加速度计设置为可能的最低事件速率，这可能因设备而异。重要的是要注意，传感器事件速率对节电有直接影响！因此，请使用适合您的应用程序的速率。`ASensor`
    API提供了一些方法来查询可用传感器及其功能，例如`ASensor_getName()`，`ASensor_getVendor()`，`ASensor_getMinDelay()`等。
- en: Now that we can retrieve sensor events, let's use them to compute a ship's direction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以获取传感器事件，让我们使用它们来计算飞船的方向。
- en: Time for action – turning an Android device into a Joypad
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-将Android设备变成Joypad
- en: Let's find the device orientation and properly determine the direction.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到设备的方向并正确确定方向。
- en: Write a new file `jni/Configuration.hpp` to help us get device information,
    and more specifically device rotation (defined as `screen_rot`).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个新文件`jni/Configuration.hpp`来帮助我们获取设备信息，更具体地是设备旋转（定义为`screen_rot`）。
- en: 'Declare `findRotation()` to discover the device orientation with the help of
    JNI:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`findRotation()`以通过JNI帮助发现设备方向：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Retrieve configuration details in `jni/Configuration.cpp`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Configuration.cpp`中检索配置详细信息。
- en: 'First, in the constructor, use the `AConfiguration` API to dump configuration
    properties, such as the current language, country, screen size, screen orientation.
    This information may be interesting, but is not sufficient to properly analyze
    accelerometer events:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在构造函数中，使用`AConfiguration` API来转储配置属性，例如当前语言，国家，屏幕大小，屏幕方向。这些信息可能很有趣，但不足以正确分析加速度计事件：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, attach the current native thread to the Android VM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将当前本机线程附加到Android VM。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have carefully read [Chapter 4](ch04.html "Chapter 4. Calling Java Back
    from Native Code"), *Calling Java Back from Native Code*, you know that this step
    is necessary to get access to the `JNIEnv` object (which is thread-specific).
    The `JavaVM` itself can be retrieved from the `android_app` structure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细阅读了[第4章](ch04.html "第4章。从本机代码调用Java返回")，*从本机代码调用Java返回*，您就知道这一步是必要的，以便访问`JNIEnv`对象（它是特定于线程的）。`JavaVM`本身可以从`android_app`结构中检索。
- en: After that, call `findRotation()` to retrieve the current device rotation.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，调用`findRotation()`来检索当前设备的旋转。
- en: 'Finally, we can detach the thread from Dalvik as we will not use JNI any more.
    Remember that an attached thread should always be detached before terminating
    the application:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从Dalvik中分离线程，因为我们将不再使用JNI。请记住，在终止应用程序之前，附加的线程应始终分离：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement `findRotation()`, which basically executes the following Java code
    through JNI:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`findRotation()`，基本上通过JNI执行以下Java代码：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Obviously, this is slightly more complex to write in JNI.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这在JNI中写起来稍微复杂一些。
- en: First, retrieve JNI classes, then methods, and finally, fields
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，检索JNI类，然后方法，最后字段
- en: Then, perform the JNI calls
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，执行JNI调用
- en: Finally, release the allocated JNI references
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，释放分配的JNI引用
- en: 'The following code has been voluntarily simplified to avoid extra checks (that
    is, `FindClass()` and `GetMethodID()` return value and exception checks for each
    method call):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码已经自愿简化，以避免额外的检查（即`FindClass()`和`GetMethodID()`返回值和每个方法调用的异常检查）：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Manage the new accelerometer sensor in `jni/InputManager.hpp`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.hpp`中管理新的加速度传感器。
- en: Accelerometer axes are transformed in `toScreenCoord()`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计轴在`toScreenCoord()`中进行转换。
- en: 'This transformation implies that we keep track of device rotation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换意味着我们需要跟踪设备的旋转：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `jni/InputManager.hpp`, read the current screen rotation settings with the
    help of the new `Configuration` class. Since `DroidBlaster` forces portrait mode,
    we can store rotation once and for all:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.hpp`中，使用新的`Configuration`类读取当前屏幕旋转设置。由于`DroidBlaster`强制使用纵向模式，我们可以一次性存储旋转：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's compute a direction from the accelerometer sensor values.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从加速度传感器值计算一个方向。
- en: First, convert accelerometer values from canonical to screen coordinates to
    handle portrait and landscape devices.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将加速度计值从规范坐标转换为屏幕坐标，以处理纵向和横向设备。
- en: 'Then, compute a direction from the captured accelerometer values. In the following
    code, the `X` and `Z` axis express the roll and pitch, respectively. Check for
    both axes whether the device is in a neutral orientation (that is, `CENTER_X`
    and `CENTER_Z`) or is sloping (`MIN_X`, `MIN_Z`, `MAX_X`, and `MAX_Z`). Note that
    Z values need to be inverted for our needs:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从捕获的加速度计值计算一个方向。在以下代码中，`X`和`Z`轴分别表示横滚和俯仰。检查设备是否处于中立方向（即`CENTER_X`和`CENTER_Z`）或倾斜（`MIN_X`，`MIN_Z`，`MAX_X`和`MAX_Z`）的两个轴。请注意，Z值需要根据我们的需求进行反转：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `toScreenCoord()` helper, swap or invert accelerometer axes depending
    on screen rotation, so that `X` and `Z` axes point toward the same direction,
    whatever device you use when playing `DroidBlaster` in portrait mode:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toScreenCoord()`助手中，根据屏幕旋转交换或反转加速度计轴，以便`X`和`Z`轴指向相同的方向，无论您在纵向模式下玩`DroidBlaster`时使用的设备是什么：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*What just happened?*'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: The accelerometer is now a Joypad! Android devices can be naturally portrait-oriented
    (mainly smartphones and smaller tablets) or landscape-oriented (mainly tablets).
    This has an impact on applications, which receive accelerometer events. Axes are
    not aligned the same way between these types of devices and depending on the way
    they are rotated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加速度计是一个Joypad！Android设备可以自然地是纵向定向（主要是智能手机和较小的平板电脑）或横向定向（主要是平板电脑）。这对于接收加速度计事件的应用程序有影响。这些设备之间的轴线不对齐方式不同，并且取决于它们的旋转方式。
- en: 'Indeed, the screen can be oriented in four different ways: `0`, `90`, `180`,
    and `270` degrees. 0 degree is the device''s natural orientation. Accelerometer
    X axis always points right, Y points up, and Z points towards the front. On a
    phone, Y points up in portrait mode, whereas on most tables, Y points up in landscape
    mode. When the device is oriented at 90 degrees, the axes orientation obviously
    changes (X points up, and so on). This situation may also happen with a tablet
    (where 0 degree corresponds to landscape mode) that is used in portrait mode.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，屏幕可以以四种不同的方式定向：`0`、`90`、`180`和`270`度。0度是设备的自然方向。加速度计X轴始终指向右侧，Y指向上方，Z指向前方。在手机上，Y在纵向模式下指向上方，而在大多数平板电脑上，Y在横向模式下指向上方。当设备定向为90度时，轴的方向显然会改变（X指向上方，依此类推）。这种情况也可能发生在平板电脑上（其中0度对应于纵向模式），该平板电脑在横向模式下使用。
- en: '![What just happened?](img/9645OS_08_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_08_03.jpg)'
- en: There is sadly no way to get device rotation relative to a screen's natural
    orientation with native APIs. Thus, we need to rely on JNI to get accurate device
    rotation. Then, we can easily deduce a direction vector from this like done in
    `onAccelerometerEvent()`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，使用本机API无法获取设备相对于屏幕自然方向的旋转。因此，我们需要依赖JNI来获取准确的设备旋转。然后，我们可以像在`onAccelerometerEvent()`中那样轻松地推断出一个方向矢量。
- en: More on sensors
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于传感器的信息
- en: 'Each Android sensor has a unique identifier, defined in `android/sensor.h`.
    These identifiers are the same across all Android devices:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android传感器都有一个唯一的标识符，在`android/sensor.h`中定义。这些标识符在所有Android设备上都是相同的：
- en: '`ASENSOR_TYPE_ACCELEROMETER`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_ACCELEROMETER`'
- en: '`ASENSOR_TYPE_MAGNETIC_FIELD`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_MAGNETIC_FIELD`'
- en: '`ASENSOR_TYPE_GYRISCOPE`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_GYRISCOPE`'
- en: '`ASENSOR_TYPE_LIGHT`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_LIGHT`'
- en: '`ASENSOR_TYPE_PROXIMITY`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_PROXIMITY`'
- en: 'Additional sensors may exist and be available, even if they are not named in
    the `android/sensor.h` header. On Gingerbread, we have the same case with:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在其他传感器，并且即使它们没有在`android/sensor.h`头文件中命名，也可以使用。在姜饼版本中，我们也有相同的情况：
- en: Gravity sensor (identifier `9`)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力传感器（标识符`9`）
- en: Linear acceleration sensor (identifier `10`)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性加速度传感器（标识符`10`）
- en: Rotation vector (identifier `11`).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转矢量（标识符`11`）。
- en: The rotation vector sensor, successor of the now deprecated orientation vector,
    is essential in the `Augmented Reality` application. It gives you device orientation
    in 3D space. Combined with the GPS, it allows locating any object through the
    eye of your device. The rotation sensor provides a data vector, which can be translated
    to an OpenGL view matrix, thanks to the `android.hardware.SensorManager` class
    (see its source code). That way, you can directly materialize device orientation
    into screen content, linking together real and virtual life.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转矢量传感器是现在已经弃用的方向矢量的继承者，在“增强现实”应用中至关重要。它可以提供设备在3D空间中的方向。结合GPS，它可以通过设备的视角定位任何物体。旋转传感器提供一个数据矢量，可以通过`android.hardware.SensorManager`类（查看其源代码）将其转换为OpenGL视图矩阵。这样，您可以直接将设备方向实现为屏幕内容，将现实生活和虚拟生活联系在一起。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered multiple ways to interact with Android from native
    code. More precisely, we discovered how to attach an input queue to the `Native
    App Glue` event loop. Then, we handled touch events and processed key events from
    keyboards and D-Pads or motion events from trackballs. Finally, we turned the
    accelerometer into a Joypad.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了从本机代码与Android进行交互的多种方式。更具体地说，我们发现了如何将输入队列附加到“本机应用程序粘合剂”事件循环。然后，我们处理了来自键盘和D-Pad的触摸事件和按键事件，或者来自轨迹球的运动事件。最后，我们将加速度计转换为游戏手柄。
- en: Because of Android fragmentation, expect specificities in an input device's
    behavior and be prepared to tweak your code. We have already been far in the capabilities
    of Android NDK in terms of application structure, graphics, sound, input, and
    sensors. However, reinventing the wheel is not a solution!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android的碎片化，预计输入设备的行为会有特殊性，并且要准备好调整您的代码。在应用程序结构、图形、声音、输入和传感器方面，我们已经在Android
    NDK的能力方面取得了很大进展。然而，重新发明轮子并不是一个解决方案！
- en: In the next chapter, we will unleash the real power of the NDK by porting existing
    C/C++ libraries to Android.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过将现有的C/C++库移植到Android来释放NDK的真正力量。
