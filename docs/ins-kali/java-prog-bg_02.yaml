- en: Understanding Typed Variables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解有类型的变量
- en: To create even modest Java programs, we're going to need a way to store and
    manipulate information. Our chief resource, when doing this, is the variable,
    and that's what we're going to take a look at in this chapter. We'll look at the
    different data types in Java and how to use them in our programs. We'll also see
    the `Math` class library and one of its functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建甚至是简单的Java程序，我们需要一种存储和操作信息的方法。在这种情况下，我们的主要资源是变量，这就是我们将在本章中讨论的内容。我们将看看Java中的不同数据类型以及如何在程序中使用它们。我们还将看到`Math`类库及其一个函数。
- en: 'Specifically, we''ll walk through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将讨论以下主题：
- en: Introduction to variables and why they're needed
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的介绍及其必要性
- en: Integer variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数变量
- en: Floating-point variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点变量
- en: The `Math` class library and its `pow()` function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math`类库及其`pow()`函数'
- en: Character variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符变量
- en: The `String` class and its methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类及其方法'
- en: Integer variables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数变量
- en: 'To begin, let''s create a new project in NetBeans. I''m going to call mine
    `Variables`, and this time we''ll allow NetBeans to create the main class for
    us so that we can get to coding as quickly as possible. We need to delete all
    the comments that are created automatically by NetBeans when we create our new
    project, just to keep everything as readable as possible, then we''ll be good
    to go:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在NetBeans中创建一个新项目。我将把我的称为`Variables`，这次我们将允许NetBeans为我们创建主类，以便我们尽快开始编码。我们需要删除NetBeans在创建新项目时自动创建的所有注释，以便尽可能保持一切清晰可读，然后我们就可以开始了：
- en: '![](img/f4dff2ef-aa16-4c77-a6a1-80fa47689ac8.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4dff2ef-aa16-4c77-a6a1-80fa47689ac8.jpg)'
- en: 'The first computers were little more than calculators, and Java, of course,
    retains this functionality. For example, Java can evaluate `1+1`, which will evaluate
    to `2`, of course. However, Java is pretty complicated and designed to do a lot
    of different things, so we need to provide context to our commands. Here, we tell
    Java that we''d like it to print the result of `1+1`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的计算机只不过是计算器，当然，Java保留了这种功能。例如，Java可以计算`1+1`，结果当然是`2`。然而，Java相当复杂，设计用于执行许多不同的任务，因此我们需要为我们的命令提供上下文。在这里，我们告诉Java我们希望它打印`1+1`的结果：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our preceding program will run as expected:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的程序将如预期般运行：
- en: '![](img/ecbc403f-5889-4e61-945e-a3d184e24f97.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecbc403f-5889-4e61-945e-a3d184e24f97.jpg)'
- en: 'In addition to some others, Java can perform all the basic arithmetic operations.
    It can do addition, subtraction, multiplication (for which we use `*`, not `X`
    on our keyboard), and division. If we run the following program with the input
    of `2` and `3`, we''ll see four `println()` commands, all of which will give the
    proper result of the calculations. We can, of course, change these numbers to
    be any combination of numbers we see fit:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他一些操作，Java可以执行所有基本的算术运算。它可以进行加法、减法、乘法（我们使用`*`，而不是键盘上的`X`），以及除法。如果我们运行以下程序并输入`2`和`3`，我们将看到四个`println()`命令，所有这些命令都将给出正确的计算结果。当然，我们可以将这些数字更改为任何我们认为合适的数字组合：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output of the preceding code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/46d2e0fd-de73-44c8-811a-56e8cda1c167.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46d2e0fd-de73-44c8-811a-56e8cda1c167.jpg)'
- en: Changing these lines manually is kind of a pain and quickly becomes infeasible
    if we're writing very complicated programs or dynamic programs that take user
    input.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 手动更改这些行有点麻烦，如果我们编写非常复杂的程序或接受用户输入的动态程序，这很快就变得不可行。
- en: The solution of variables
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的解决方案
- en: Fortunately, programming gives us a way of storing and retrieving data; this
    is called the **variable**. To declare a variable in Java, we first have to specify
    what kind of variable we're going to be using. Variables come in a number of different
    types. In this instance, we're content with using whole numbers, that is, numbers
    that do not have a specified decimal place and aren't fractions. Also, in this
    case, it's appropriate to use one of Java's primitive types. These are essentially
    as base level as we can get with information in the Java programming language;
    just about everything else we work with in Java is built of the primitive types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编程给了我们一种存储和检索数据的方法；这就是**变量**。要在Java中声明一个变量，我们首先必须指定我们将使用的变量类型。变量有许多不同的类型。在这种情况下，我们满足于使用整数，即没有指定小数位并且不是分数的数字。此外，在这种情况下，使用Java的原始类型是合适的。这些基本上是Java编程语言中信息的基本级别；我们在Java中使用的几乎所有其他东西都是由原始类型构建的。
- en: 'To declare a variable of the integer primitive type, that is, whole numbers,
    we use the `int` keyword, all lowercase. Once we do this, we need to give our
    variable a name. This is a unique identifier that we''ll use to access this piece
    of information in future. Each variable in our local program should have its own
    name. Let''s call our first variable `x` and our second variable `y`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明整数原始类型的变量，即整数，我们使用`int`关键字，全部小写。一旦我们这样做，我们需要给我们的变量一个名称。这是一个唯一的标识符，我们将用它来在将来访问这个信息。我们本地程序中的每个变量都应该有自己的名称。让我们称我们的第一个变量为`x`，我们的第二个变量为`y`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ve just written two perfectly legitimate lines of Java code. If we run
    our program now, we''ll see the same output we did before:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了两行完全合法的Java代码。如果我们现在运行程序，我们将看到与之前相同的输出：
- en: '![](img/8367c0c4-8769-4f2b-a658-833cce3172b2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8367c0c4-8769-4f2b-a658-833cce3172b2.jpg)'
- en: However, behind the scenes, Java will also be setting aside memory space for
    our `x` and `y` variables. This allocation doesn't affect our `println` commands
    because the variables are not referenced in them yet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在幕后，Java也会为我们的`x`和`y`变量设置内存空间。这种分配不会影响我们的`println`命令，因为变量在其中还没有被引用。
- en: 'So let''s store some information in our variables. We can reference a variable
    once we''ve created it simply by the variable''s name. It''s important that we
    do not reference our variable by typing `int x` again because this is the command
    for Java to create a brand new variable `x`, not access the existing variable
    `x`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在变量中存储一些信息。我们可以在创建变量后通过变量的名称来引用变量。重要的是我们不要再次键入`int x`来引用我们的变量，因为这是Java创建一个全新变量`x`而不是访问现有变量`x`的命令：
- en: '![](img/f8249e4c-22b4-4ca3-bc16-593d40173ca6.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8249e4c-22b4-4ca3-bc16-593d40173ca6.png)'
- en: 'Once we''ve referenced our variable, we can change its value using the equal
    sign. So let''s set `x` to `4` and `y` to `3`. Our `println` commands currently
    operate with two explicitly declared integers: the numbers `2` and `3`. Since
    `x` and `y` are also integers, it stands to reason that we can simply replace
    the existing numbers with the variables `x` and `y`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们引用了变量，我们就可以使用等号更改其值。所以让我们将`x`设置为`4`，`y`设置为`3`。我们的`println`命令目前使用两个明确声明的整数：数字`2`和`3`。由于`x`和`y`也是整数，我们可以简单地用变量`x`和`y`替换现有的数字：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output of the preceding code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '![](img/e1c7a2a6-9b27-4ad8-b4ba-552e07ebe6b5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1c7a2a6-9b27-4ad8-b4ba-552e07ebe6b5.jpg)'
- en: When our Java code comes to the variables `x` and `y`, it will look to see what
    integer value they have currently been given. It will find the numbers `4` and
    `3`. So if we run our program, we should expect the first `println` statement,
    `x+y`, to evaluate to `4+3`, which then evaluates to `7`. This is exactly what
    occurs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的Java代码涉及变量`x`和`y`时，它将查看它们当前具有的整数值。它会找到数字`4`和`3`。因此，如果我们运行程序，我们应该期望第一个`println`语句`x+y`计算为`4+3`，然后计算为`7`。这正是发生的事情。
- en: So here's something interesting. The last line of our program, in which we divide
    `x` by `y`, isn't evaluating as we might mathematically expect it to. In this
    line of code, `x` has the value `4`, and `y` has the value `3`, Now `4` divided
    by `3` equals 1.3, but our program is simply outputting `1`. That's because 1.3
    is not a valid integer value. Integers are only whole numbers and never fractions
    or decimal numbers. So, to keep us working with integers, Java simply rounds down
    any calculations that have fractional portions to their nearest whole number.
    If we want to work in an environment where we could have fractional results, we
    would need to use a primitive type other than an integer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有一些有趣的事情。我们程序的最后一行，其中我们将`x`除以`y`，并没有像我们在数学上期望的那样进行评估。在这行代码中，`x`的值为`4`，`y`的值为`3`，现在`4`除以`3`等于1.3，但我们的程序只是输出`1`。那是因为1.3不是有效的整数值。整数只能是整数，永远不是分数或小数。因此，为了让我们使用整数，Java会将具有小数部分的任何计算向下舍入到最接近的整数。如果我们想要在可能有分数结果的环境中工作，我们需要使用除整数以外的原始类型。
- en: 'Anyway, now that we''ve set up our `println` commands to take integer variable
    input instead of explicit numbers, we can modify the behavior of all four lines
    of the calculation by simply changing the values of these integer variables. For
    example, if we wanted our program to run on the input values `-10` and `5` (integers
    can be negative; they just can''t have fractional components), all we would need
    to do is change the values we give to our variables `x` and `y`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，现在我们已经设置了我们的`println`命令以接受整数变量输入而不是明确的数字，我们可以通过简单地更改这些整数变量的值来修改所有四行计算的行为。例如，如果我们希望我们的程序在输入值`-10`和`5`（整数可以是负数；它们只是不能有分数部分）上运行，我们只需要更改我们给变量`x`和`y`的值：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run the preceding code quickly, we will see the expected results:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速运行前述代码，我们将看到预期的结果：
- en: '![](img/d32b5c65-880c-41a2-9863-aed25b3dce4c.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d32b5c65-880c-41a2-9863-aed25b3dce4c.jpg)'
- en: Awesome! You've just learned the very basics of working with both integers and
    variables in Java.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了在Java中使用整数和变量的基础知识。
- en: Memory allocation for integer variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数变量的内存分配
- en: Let's go over an edge case and learn a little bit more about how Java thinks.
    You might remember from earlier, I spoke about how Java sets aside memory when
    we declare new variables. This is one of the huge advantages of working in a high-level
    programming language, such as Java. Java abstracts away or automatically takes
    care of most of the memory management for us. Quite often, this makes writing
    programs simpler, and we can write shorter, cleaner, and more easily readable
    code. Of course, it is important that we appreciate what's happening behind the
    scenes, lest we run into issues.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个边缘情况，并了解一下Java的思维方式。您可能还记得我之前提到过，Java在声明新变量时会设置内存。这是在高级编程语言（如Java）中工作的巨大优势之一。Java为我们抽象化或自动处理大部分内存管理。这通常使编写程序更简单，我们可以编写更短、更干净和更易读的代码。当然，重要的是我们要欣赏幕后发生的事情，以免遇到问题。
- en: For example, whenever Java sets aside memory for an integer variable, it also
    sets aside the same amount of memory for all integer variables. This means there's
    a maximum and minimum value that Java could ever conceivably store in an integer
    variable. The maximum integer value is `2147483647` and the minimum integer value
    is `2147483648`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每当Java为整数变量设置内存时，它也为所有整数变量设置相同数量的内存。这意味着Java可能在整数变量中存储的最大和最小值。最大整数值为`2147483647`，最小整数值为`2147483648`。
- en: 'So let''s do an experiment. What happens if we attempt to store and print out
    an integer variable that is one larger than the maximum value? To start with,
    let''s simplify our program. We''re simply going to assign a value, one higher
    than possible, to the variable `x`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们做一个实验。如果我们尝试存储并打印一个比最大值大一的整数变量会发生什么？首先，让我们简化我们的程序。我们只是将一个比可能的值高一的值分配给变量`x`：
- en: '![](img/504868da-232a-43e3-bd1e-81d726d29b6d.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/504868da-232a-43e3-bd1e-81d726d29b6d.png)'
- en: When we attempt to do this, NetBeans yells at us. It's got some logic built
    in that attempts to stop us from making this very basic and common mistake. If
    we were to attempt to compile this program, we would also get an error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试这样做时，NetBeans会对我们大喊大叫。它内置了一些逻辑，试图阻止我们犯下这个非常基本和常见的错误。如果我们尝试编译这个程序，我们也会得到一个错误。
- en: 'However, we want to make this mistake in the name of science, so we''re going
    to trick NetBeans. We''re going to set the value of our variable `x` to the largest
    possible integer value, and then in the next line of our code, we''re going to
    set the value of `x` to be one higher than what `x` is currently, that is, `x=x+1`.
    Actually, there''s a nifty little shorthand we can use for this: `x=x+1` is equivalent
    to `x++`. OK, so when we run this program, which will sneak by the compiler and
    NetBeans, and do our addition at runtime, we attempt to print out an integer value
    that is one plus the highest integer value that Java can store in a memory location:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想要以科学的名义犯这个错误，所以我们要欺骗NetBeans。我们将把变量`x`的值设置为最大可能的整数值，然后在我们的代码的下一行，我们将把`x`的值设置为比当前`x`高一的值，也就是`x=x+1`。实际上，我们可以使用一个巧妙的简写：`x=x+1`等同于`x++`。好的，当我们运行这个程序时，它将欺骗编译器和NetBeans，并在运行时进行加法运算，我们尝试打印出一个整数值，这个值比Java可以存储在内存位置中的最大整数值多一：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the preceding program, we get the following negative number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述程序时，我们会得到以下负数：
- en: '![](img/b95205e1-dc7d-4d43-b244-436bc92bc84c.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b95205e1-dc7d-4d43-b244-436bc92bc84c.jpg)'
- en: This number happens to be the smallest number that we could ever store in an
    integer. This makes some sort of visual sense. We've gone so far positive, or
    to the right, on our integer number line, that we've arrived at the leftmost or
    the most negative point. Of course, in a mathematical sense, this could get pretty
    confusing pretty quickly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字恰好是我们可以存储在整数中的最小数字。这在视觉上有一定的意义。我们已经走得如此之远，或者说向右，在我们的整数数线上，以至于我们到达了最左边或最负的点。当然，在数学上，这可能会变得相当混乱。
- en: 'It''s unlikely that we''re ever going to write programs that will need integer
    numbers higher than this value. However, if we do, we certainly need to be aware
    of this issue and circumvent it, using a variable type that can handle larger
    values. The `long` variable type is just like an integer but we need to allocate
    more memory for it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不太可能编写需要比这个值更高的整数的程序。然而，如果我们确实需要，我们当然需要意识到这个问题并规避它，使用一个可以处理更大值的变量类型。`long`变量类型就像整数一样，但我们需要为它分配更多的内存：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run the preceding program, we will get a mathematically accurate result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述程序时，我们将得到一个数学上准确的结果：
- en: '![](img/e55622b8-4f38-451f-9dbb-4c729df8e319.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e55622b8-4f38-451f-9dbb-4c729df8e319.jpg)'
- en: Floating point variables
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点变量
- en: When we're simply counting and manipulating whole objects, integers are fantastic.
    However, sometimes we need to deal with numbers in a more mathematical sense,
    and we need a data type that will allow us to express ideas that are not entirely
    whole numbers. Floating-point numbers, or floats, are a Java primitive type that
    allow us to express numbers that have decimal points and fractions. In this section,
    we'll modify some float and integer variables side by side to see how they are
    similar and different.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只是简单地计数和操作整个对象时，整数是很棒的。然而，有时我们需要以更数学的方式处理数字，我们需要一个数据类型，可以让我们表达不完全是整数的想法。浮点数，或者浮点数，是Java的一个原始类型，允许我们表示有小数点和分数的数字。在本节中，我们将修改一些浮点和整数变量，以便看到它们的相似之处和不同之处。
- en: 'Let''s create a new Java project (you know the drill by now) and call it `FloatingPointNumbers`.
    Let''s start by declaring two variables: one integer (`iNumber`) and one float
    (`fNumber`). As we know, once we''ve declared these variables, we''re free to
    modify and assign values to them in our Java program later. This time, let me
    show you that we can also modify and assign to these variables in the same line
    that they''re declared. So where I have declared my `iNumber` integer variable,
    I''m free to immediately give it the value of `5`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Java项目（你现在已经知道了）并将其命名为`FloatingPointNumbers`。让我们首先声明两个变量：一个整数（`iNumber`）和一个浮点数（`fNumber`）。正如我们所知，一旦声明了这些变量，我们就可以在我们的Java程序中修改和赋值给它们。这一次，让我向你展示，我们也可以在声明这些变量的同一行中修改和赋值给这些变量。所以当我声明了我的`iNumber`整数变量时，我可以立即给它赋值`5`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that if we try and do something very similar with our float variable,
    NetBeans will yell at us, by displaying a light bulb and red dot on the left-hand
    side:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们尝试用我们的浮点变量做类似的事情，NetBeans会对我们大喊大叫，左侧会显示一个灯泡和红点：
- en: '![](img/00c7ce26-7b13-43af-a214-06143904c0bb.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00c7ce26-7b13-43af-a214-06143904c0bb.png)'
- en: 'In fact, if we attempt to compile our program, we''ll get a legitimate compiler
    error message:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们尝试编译我们的程序，我们会得到一个合法的编译器错误消息：
- en: '![](img/d3765a7c-e60a-46f8-8d1d-9d7ad8e4bde1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3765a7c-e60a-46f8-8d1d-9d7ad8e4bde1.jpg)'
- en: 'Let''s analyze why this happens. When we use an explicit number in Java, that
    is, typing out the digits rather than working with a variable, that explicit number
    is still given a type by Java. So when we type out a number without any decimal
    places, the type that the number is assumed to be is an integer. So our assignment
    works just great. However, a number with decimal places is assumed to be of this
    type and is called `double`; it''s a sister type of the `float` data type, but
    it''s not quite the same. We''ll talk about `double` a little later. Right now,
    what we need to do is tell Java to treat `5.5` as a `float` type number instead
    of `double`. To do this, all we need to do is put `f` after the digits, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下为什么会发生这种情况。当我们在Java中使用一个显式数字，也就是说，打出数字而不是使用一个变量时，Java仍然会给这个显式数字一个类型。因此，当我们打出一个没有小数位的数字时，这个数字被假定为整数类型。所以我们的赋值工作得很好。然而，带有小数位的数字被假定为这种类型，称为`double`；它是`float`数据类型的姐妹类型，但并不完全相同。我们稍后会讨论`double`。现在，我们需要告诉Java将`5.5`视为`float`类型的数字，而不是`double`。为此，我们只需要在数字后面加上`f`，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You''ll see that the bulb and red dot have disappeared. To make sure we get
    the syntax right, let''s give our program some super basic functionality. Let''s
    use `System.out.println()` to print our integer number and then our floating-point
    number variable in sequence:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现灯泡和红点已经消失了。为了确保我们的语法正确，让我们给我们的程序一些超级基本的功能。让我们使用`System.out.println()`按顺序打印我们的整数和浮点数变量：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we build this program, our compiler error goes away, and when we run it,
    we see the two assigned values as expected. Nothing too exciting there:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这个程序时，我们的编译器错误消失了，当我们运行它时，我们看到了两个分配的值，一切都如预期那样。没有什么太激动人心的地方：
- en: '![](img/c91aff6e-852d-4463-a59e-f5427c61a6d9.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c91aff6e-852d-4463-a59e-f5427c61a6d9.jpg)'
- en: Behavior difference between integer and float data types
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数和浮点数据类型之间的行为差异
- en: Now, rather than assigning explicit values to our variables, let's do some basic
    arithmetic so we can see how integer and floats, when modified in Java, behave
    differently. In Java, both `float` and `int` are primitive types, the logical
    building blocks of the programming language. This means we can compare and modify
    them using mathematical operators, such as division.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再为变量分配显式值，而是进行一些基本的算术运算，以便我们可以看到在Java中修改整数和浮点数时的不同行为。在Java中，`float`和`int`都是原始类型，是编程语言的逻辑构建块。这意味着我们可以使用数学运算符进行比较和修改，例如除法。
- en: 'We know that if we attempt to divide one integer by another, we''ll always
    get a whole number as a result, even if the rules of standard mathematics don''t
    make that the expected result. If we divide a floating-point number by another
    floating-point number, however, we''ll get a more mathematically accurate result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们尝试将一个整数除以另一个整数，我们总是会得到一个整数作为结果，即使标准数学规则并不产生预期的结果。然而，如果我们将一个浮点数除以另一个浮点数，我们将得到一个更符合数学规则的结果：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output of the preceding code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/bb4b9190-5d11-4bbe-93c4-46769ff63be5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4b9190-5d11-4bbe-93c4-46769ff63be5.jpg)'
- en: 'Sometimes, Java will let us do things that might not be such a good idea. For
    example, Java lets us set the value of our floating-point variable `fNumber` to
    one integer divided by another instead of one floating-point number divided by
    another:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Java会让我们做一些可能不是那么好的主意的事情。例如，Java允许我们将浮点变量`fNumber`的值设置为一个整数除以另一个整数，而不是一个浮点数除以另一个浮点数：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the computation on the right-hand side of our equals sign occurs before
    the value of our floating-point variable `fNumber` changes, we''re going to see
    the same output in both the calculations of `5/4`. This is because both the 5''s
    and 4''s are integer variables. So when we run our program, even though `fNumber`
    remains a floating-point number (as we can tell because it prints out with the
    decimal place), its value is still set to the rounded down whole number of `5/4`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为等号右侧的计算发生在我们的浮点变量`fNumber`的值改变之前，所以我们将在`5/4`的计算中看到相同的输出。这是因为5和4都是整数变量。因此，当我们运行程序时，即使`fNumber`仍然是一个浮点数（因为它带有小数点），它的值仍然设置为`5/4`的向下取整整数部分：
- en: '![](img/04d86a0b-dda4-44a3-bc9f-a1be8869b39f.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04d86a0b-dda4-44a3-bc9f-a1be8869b39f.jpg)'
- en: 'Solving this problem is pretty straightforward; we simply need to change one
    of our integer values to be a floating-point number by appending `f` to it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题非常简单；我们只需要将我们的整数值之一更改为浮点数，通过在其后添加`f`：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the computation will know how to proceed with a decimal place division:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在计算将知道如何进行小数点的除法：
- en: '![](img/769f67af-a82c-4fb3-99f3-699d080c9821.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/769f67af-a82c-4fb3-99f3-699d080c9821.jpg)'
- en: This becomes a little trickier and more important to navigate properly when
    we stop working with explicitly declared numbers and begin working with variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们停止使用显式声明的数字并开始使用变量时，正确地导航这一点变得更加棘手和重要。
- en: 'Let''s declare two integer variables now. I''ll just call them `iNumber1` and
    `iNumber2`. Now, rather than attempting to set the value of `fNumber` to one explicitly
    declared number divided by another, we''ll set its value to `iNumber1/iNumber2`,
    and we''ll just print out the results stored in `fNumber`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们声明两个整数变量。我只是称它们为`iNumber1`和`iNumber2`。现在，我们不再试图将`fNumber`的值设置为一个显式声明的数字除以另一个数字，而是将其值设置为`iNumber1/iNumber2`，然后我们将打印出存储在`fNumber`中的结果：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we run this program, because once again we''re dividing one integer by
    another, we''re going to see the rounding down phenomenon. The value being stored
    in our floating-point variable is `0.0`, the rounded down result of `5/6`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，因为我们再次将一个整数除以另一个整数，我们将看到向下取整的现象。存储在我们的浮点变量中的值是`0.0`，即`5/6`的向下取整结果：
- en: '![](img/eb11f02b-69bc-4402-bf1d-2f8ea176e037.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb11f02b-69bc-4402-bf1d-2f8ea176e037.jpg)'
- en: If we were working with explicitly declared numbers, we would solve this problem
    by changing one of the two integer numbers to be treated as a floating-point number
    by simply putting a decimal place and `f` after it. In this context, using `iNumber2f`
    is not an option because rather than thinking that we're asking it to treat `iNumber2`
    as a floating-point number, Java now believes it's looking for a variable called
    `iNumber2f`, which certainly doesn't exist within this context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理显式声明的数字，我们可以通过将两个整数数字中的一个更改为浮点数来解决这个问题，只需在其后加上小数点和`f`。在这种情况下，使用`iNumber2f`不是一个选择，因为Java不再认为我们要求它将`iNumber2`视为浮点数，而是认为它正在寻找一个名为`iNumber2f`的变量，而这在这个上下文中显然不存在。
- en: Type casting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: We can achieve a similar result though, using what's called a **cast**. This
    is a command in which we ask Java to treat a variable of one type like it is another
    one. Here we're circumventing Java's natural inclination to treat `iNumber1` and
    `iNumber2` as integers. We're stepping in and saying, "You know what Java, treat
    this number here as a float," and we're assuming some responsibility when we do
    this. Java will attempt to do what we ask, but if we choose poorly and attempt
    to cast one object to an object that it cannot, our program will crash.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用所谓的**转换**来实现类似的结果。这是一个命令，我们要求Java将一个类型的变量视为另一个类型。在这里，我们绕过了Java自然倾向于将`iNumber1`和`iNumber2`视为整数的倾向。我们介入并说：“你知道Java，把这个数字当作浮点数处理”，当我们这样做时，我们承担了一些责任。Java会尝试按照我们的要求做，但如果我们选择不当并尝试将一个对象转换为它不能转换的对象，我们的程序将崩溃。
- en: 'Fortunately, we''re working with primitives here, and primitive types know
    how to act like another type. So, we can cast the variable `iNumber1` to temporarily
    operate like a floating-point number by prefacing it with `(float)`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们在这里使用的是原始类型，原始类型知道如何像另一种类型一样行事。因此，我们可以通过将变量`iNumber1`转换为浮点数来实现类似的结果，方法是在其前面加上`(float)`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if we run our program, we''ll see the expected result of `5/6`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的程序，我们将看到预期的`5/6`结果：
- en: '![](img/f023a0d3-25eb-4199-a362-c8054663de1d.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f023a0d3-25eb-4199-a362-c8054663de1d.jpg)'
- en: That's a pretty solid introduction to working with floating-point numbers, which
    we're going to use just about any time we want to work with numbers in their mathematical
    sense rather than as integers for counting whole objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常扎实的关于使用浮点数的介绍，我们几乎在任何时候都会使用它们来处理数学意义上的数字，而不是作为整数来计算整个对象。
- en: The double data type
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双精度数据类型
- en: 'Let''s quickly talk about the `double` data type. It is a sister type of `float`.
    It provides a greater resolution: `double` numbers can have even more decimal
    places. But they take up a little more memory. At this point in time, using double
    or float is almost always a style or personal preference decision. Unless you''re
    working with complicated software that must run at peak memory efficiency, the
    extra memory space taken up by a double is not very significant.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈`double`数据类型。它是`float`的姐妹类型。它提供更高的分辨率：`double`数字可以有更多的小数位。但它们占用了更多的内存。在这个时候，使用double或float几乎总是一个风格或个人偏好的决定。除非你正在处理必须以最高内存效率运行的复杂软件，否则双精度占用的额外内存空间并不是非常重要的。
- en: 'To illustrate how `double` works, let''s change the two integer numbers in
    our `FloatingPointNumbers.java` program to a `double` data type. When we only
    change the names of the variables, the logic of our program doesn''t change at
    all. But when we change the declaration of these variables from declaring integers
    to doubles, the logic does change. Anyway, when we explicitly declare a number
    with decimal places, it defaults to being `double`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`double`的工作原理，让我们将`FloatingPointNumbers.java`程序中的两个整数更改为`double`数据类型。当我们只更改变量的名称时，程序的逻辑并没有改变。但是当我们将这些变量的声明从整数更改为双精度时，逻辑确实发生了变化。无论如何，当我们显式声明带有小数位的数字时，默认为`double`：
- en: '![](img/99ffb0a4-0064-4de5-959f-eb48396bcbdf.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ffb0a4-0064-4de5-959f-eb48396bcbdf.png)'
- en: 'Now we need to fix the error. The error occurs because dividing a `double`
    data type by another one is going to return a `double` result. We can solve this
    issue in two ways:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修复错误。错误是因为将`double`数据类型除以另一个`double`数据类型将返回一个`double`结果。我们可以通过两种方式解决这个问题：
- en: 'First, we could cast `dNumber1` and `dNumber2` to floating-point numbers and
    then divide them:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以将`dNumber1`和`dNumber2`转换为浮点数，然后再将它们相除：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, dividing our two double numbers by each other is a perfectly legitimate
    operation. So why not allow this to occur naturally and then cast the resulting
    double to a floating-point number, thereby preserving a greater amount of resolution.
    Just like in algebra, we can break up conceptual blocks of our program that we
    would like to occur before another block using parentheses:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，将我们的两个双精度数字相除是一个完全合法的操作。那么为什么不允许这种自然发生，然后将结果的双精度转换为浮点数，从而保留更多的分辨率。就像在代数中一样，我们可以使用括号将我们希望在另一个块之前发生的程序的概念块分解：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now if we run this program, we get the expected result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们运行这个程序，我们会得到预期的结果：
- en: '![](img/f0a31fb1-1568-43f3-85b4-0159b9c245b0.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0a31fb1-1568-43f3-85b4-0159b9c245b0.jpg)'
- en: The Math class library
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math类库
- en: A good portion of our time on any software development project is going to be
    spent teaching our program to solve the types of problems it would comes across
    on a regular basis. As programmers, we too will run into certain problems time
    and time again. Sometimes, we'll need to code our own solutions to these problems
    and hopefully save them for later use. However, more often than not, someone has
    run into these problems before, and if they've made their solution publicly available,
    one of our options is to leverage their solution for our own gain.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件开发项目中，我们将花费大量时间教导我们的程序解决它经常遇到的问题类型。作为程序员，我们也会一次又一次地遇到某些问题。有时，我们需要编写自己的解决方案，并希望将它们保存以备将来使用。然而，更多的时候，有人之前遇到过这些问题，如果他们已经公开提供了解决方案，我们的一个选择就是利用他们的解决方案来获益。
- en: 'In this section, we''ll use the `Math` class library, which is bundled with
    the JDK to solve some math problems for us. To start this section, create a brand
    new NetBeans project (I''m going to name it `TheMathLib`) and enter the `main()`
    function. We''re going to write a very simple program. Let''s declare a floating-point
    number variable and give it a value (don''t forget the `f` alphabet at the end
    of our explicit number to let Java know that we''ve declared a floating-point
    number), then use `System.out.println()` to print this value to the screen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用与JDK捆绑在一起的`Math`类库来解决一些数学问题。要开始这一部分，创建一个全新的NetBeans项目（我将其命名为`TheMathLib`）并输入`main()`函数。我们将编写一个非常简单的程序。让我们声明一个浮点数变量并给它一个值（不要忘记在我们显式数字的末尾加上`f`字母，让Java知道我们声明了一个浮点数），然后使用`System.out.println()`将这个值打印到屏幕上：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, there we go:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '好的，我们到这里： '
- en: '![](img/0e87c80c-cbba-4fba-9eb8-c78c235f9d2f.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e87c80c-cbba-4fba-9eb8-c78c235f9d2f.jpg)'
- en: Now, with this program, we'd like to make it really easy to raise our floating-point
    number to various powers. So, if we simply want to square this number, I guess
    we could just print out the value of `number*number`. If we want to cube it, we
    could print out `number*number*number`. And, if we want to raise it to the power
    of six, we could multiply it six times by itself. Of course, this gets unwieldy
    pretty quickly, and there's certainly a better way.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这个程序，我们希望能够轻松地将我们的浮点数提高到各种幂。所以，如果我们只想将这个数字平方，我想我们可以直接打印出`number*number`的值。如果我们想将其立方，我们可以打印出`number*number*number`。如果我们想将它提高到6次幂，我们可以将它乘以自身六次。当然，这很快就会变得难以控制，肯定有更好的方法。
- en: Let's leverage the Java `Math` class library to help us raise numbers to varying
    exponential powers. Now, I've just told you that the functionality we're looking
    for lives in the `Math` class library. This is the kind of push in the right direction
    you should expect to get from a Google search, or if you're an experienced software
    developer, you can implement a specific API. Unfortunately, that's not quite enough
    information for us to start using the functionality of this class library. We
    don't know the specifics of how it works or even exactly what functionality it
    offers us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用Java的`Math`类库来帮助我们将数字提升到不同的指数幂。现在，我刚告诉你我们正在寻找的功能存在于`Math`类库中。这是你应该期望从Google搜索中得到的正确方向，或者如果你是一名经验丰富的软件开发人员，你可以实现一个特定的API。不幸的是，这对我们来说还不够信息来开始使用这个类库的功能。我们不知道它的工作细节，甚至不知道它为我们提供了什么功能。
- en: 'To find this out, we''re going to have to look at its documentation. Here''s
    the documentation web page managed by Oracle for the libraries found in our Java
    Development Kit: [docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/).
    Among the libraries that show up on the page is `java.lang`. When we select it,
    we''ll find the `Math` class that we''ve been looking for under Class Summary.
    Once we navigate to the `Math` class library page, we get two things. First we
    get some human-friendly text write-up about the library, its history, what its
    intended uses are, very meta-level stuff. If we scroll down, we see the functionality
    and methods implemented by the library. This is the nitty-gritty of where we''d
    like to be:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出这个，我们需要查看它的文档。这是由Oracle管理的Java开发工具包中的库的文档网页：[docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/)。在页面上显示的库中，有`java.lang`。当我们选择它时，我们会在类摘要下找到我们一直在寻找的`Math`类。一旦我们导航到`Math`类库页面，我们会得到两件事。首先，我们得到一些关于库的人性化文本描述，它的历史，它的预期用途，非常元级别的东西。如果我们向下滚动，我们会看到库实现的功能和方法。这就是我们想要的细节：
- en: '![](img/5af38ab7-0226-45ab-9385-b23abde20824.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5af38ab7-0226-45ab-9385-b23abde20824.jpg)'
- en: Using the pow() function
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pow()函数
- en: 'One of these functions should stick out for us, which is `pow()`, or the power
    function. It returns the value of the first argument (`double a`) raised to the
    power of the second argument (`double b`). In short, it will allow us to raise
    numbers to an arbitrary power:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个函数应该引起我们的注意，那就是`pow()`，或者幂函数。它返回第一个参数（`double a`）的值提高到第二个参数（`double b`）的幂。简而言之，它允许我们将数字提高到任意幂：
- en: '![](img/f70ddefb-5585-416c-a21c-9f0fb95452eb.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f70ddefb-5585-416c-a21c-9f0fb95452eb.jpg)'
- en: 'Let''s get back to coding. Alright, let''s employ this `pow()` function to
    modify the value of our variable `number` after we''ve declared it. We''re going
    to do something along the lines of `number = pow`, but we need a little more information:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编码。好的，让我们在声明变量`number`之后使用`pow()`函数来修改它的值。我们要做的事情是`number = pow`之类的事情，但我们需要更多的信息：
- en: '![](img/6def15f6-4682-4b40-9738-c78e12f8c2aa.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6def15f6-4682-4b40-9738-c78e12f8c2aa.png)'
- en: How exactly do we employ this `pow()` function? Well, if we click on our documentation,
    we'll see that when the `pow()` function is declared, in addition to its name,
    there's also, between parentheses, two arguments specified. These arguments, `double
    a` and `double b`, are the two pieces of information the function is requesting
    before it can operate as expected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们如何使用这个`pow()`函数？嗯，如果我们点击我们的文档，我们会看到当`pow()`函数被声明时，除了它的名称之外，还有在括号之间指定的两个参数。这些参数，`double
    a`和`double b`，是函数在操作之前请求的两个信息。 '
- en: Our job, in order to use this function, is to replace the requests `double a`
    and `double b` with actual variables or explicit values so that the `pow()` function
    can do its thing. Our documentation tells us that `double a` should be replaced
    with the variable or value that we'd like to raise to the power of `double b`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个函数，我们的工作是用实际变量或显式值替换请求的`double a`和`double b`，以便`pow()`函数可以发挥作用。我们的文档告诉我们，`double
    a`应该被替换为我们想要提高到`double b`次幂的变量或值。
- en: 'So let''s replace the first type argument with our variable `number`, which
    is what we want to raise to an arbitrary power. On that note, `number` is `float`
    not `double`, and that''s going to give us some trouble unless we simply change
    it to `double`. So let''s do that. For the second argument, we don''t have a precreated
    variable to replace `double b` with, so let''s just use an explicit value, such
    as `4.0`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们用我们想要提高到任意幂的变量`number`替换第一个类型参数。在这一点上，`number`是`float`而不是`double`，除非我们简单地将其更改为`double`，否则这将给我们带来一些麻烦。所以让我们这样做。对于第二个参数，我们没有一个预先创建的变量来替换`double
    b`，所以让我们使用一个显式值，比如`4.0`：
- en: '![](img/811bebe1-6305-4142-9a72-d12617682d4f.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/811bebe1-6305-4142-9a72-d12617682d4f.png)'
- en: Notice that I get rid of the `double` specifier when I call the `pow()` function.
    This specifier only exists to let us know what type Java is expecting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我调用`pow()`函数时，我去掉了`double`说明符。这个说明符只是为了让我们知道Java期望的类型。
- en: 'In theory, the `pow()` function now has all the information it needs to go
    ahead and run and raise the value of our number variable to the power of 4\. However,
    NetBeans is still giving us our red warning sign. Right now, that''s because NetBeans,
    and Java by extension, doesn''t know where to find this `pow` keyword. For the
    same reasons that we need to specify a full path to `System.out.println()`, we
    need to specify a full path in which it can find the `pow()` function for Java.
    This is the same path we followed to get to the `pow()` function in our documentation.
    So let''s specify `java.lang.Math.pow()` as it''s path in our code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`pow()`函数现在具有运行并将我们的数字变量的值提高到4次幂所需的所有信息。然而，NetBeans仍然给我们显示红色警告标志。现在，这是因为NetBeans，以及Java本身，不知道在哪里找到这个`pow`关键字。出于与我们需要指定完整路径到`System.out.println()`相同的原因，我们需要指定一个完整路径，以便Java可以找到`pow()`函数。这是我们在文档中找到`pow()`函数的路径。因此，让我们在我们的代码中指定`java.lang.Math.pow()`作为它的路径：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we''re pretty much good to go. Let''s utilize the `number` variable once
    in our `println` statement, then we should be able to run our program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基本上可以开始了。让我们在`println`语句中使用一次`number`变量，然后我们应该能够运行我们的程序：
- en: '![](img/6ff4def5-2691-46e7-8f33-0373021881f6.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ff4def5-2691-46e7-8f33-0373021881f6.jpg)'
- en: We can plug it into our calculator if we want, but I'm pretty confident that
    our program has outputted the value of 4.321 raised to the power of 4.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，我们可以将它插入我们的计算器，但我非常有信心，我们的程序已经输出了4.321的值提高到4次幂。
- en: So this is great! We've just employed external code to not only make our program
    easier to write, but also to keep it very human-readable. It required much fewer
    lines of code than it would have otherwise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒！我们刚刚使用外部代码不仅使我们的程序更容易编写，而且使它非常易读。它所需的代码行数比以前少得多。
- en: Importing class libraries
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入类库
- en: One thing that's not super human-readable about our program is the long paths
    to functions such as `pow()` and `println()`. Is there a way we could shorten
    them? There certainly is. If the makers of Java had wanted to, they could have
    allowed us to call this function by simply typing `Math.pow()` in all instances.
    This unfortunately would have some unintended side effects. For example, if there
    were two libraries linked up to Java and they both declared a `Math.pow()` function,
    Java would not know which one to use. Hence, by default, we're expected to link
    to libraries directly and explicitly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的程序，有一件事不太容易阅读，那就是到`pow()`和`println()`等函数的长路径。我们能不能缩短它们？当然可以。如果Java的制造商想要的话，他们可以让我们在所有情况下通过简单地输入`Math.pow()`来调用这个函数。不幸的是，这可能会产生一些意想不到的副作用。例如，如果有两个库链接到Java，并且它们都声明了`Math.pow()`函数，Java将不知道使用哪一个。因此，默认情况下，我们期望直接和明确地链接到库。
- en: 'So, if we''d like to just be able to type out something like `Math.pow()`,
    we can import a library into the local space that we''re working in. We just need
    to do an `import` command above our class and the `main()` function declaration.
    All the import command takes as input is the path that we''d like Java to look
    for when it comes across a keyword, such as `pow()`, that it doesn''t immediately
    recognize. In order to allow us to employ the easier syntax `Math.pow()` in our
    program, we simply need to type `import java.lang.Math`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要只输入`Math.pow()`，我们可以将一个库导入到我们正在工作的本地空间中。我们只需要在我们的类和`main()`函数声明上面执行一个`import`命令。导入命令所需的输入只是我们希望Java在遇到一个关键字时查找的路径，比如`pow()`，它不立即识别。为了让我们在程序中使用更简单的语法`Math.pow()`，我们只需要输入`import
    java.lang.Math`：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is some special syntax for imports. Let's say we wanted to import all
    the class libraries in `java.lang`. To do this, we could replace `.Math` with
    `.*` and make it `java.lang.*` which translates to "import every library from
    the `java.lang` package." I should probably inform you that for those of us working
    in NetBeans, this import is done by default. However, in this case, we're going
    to do it explicitly because you may have to do this while working in other Java
    environments as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的导入语法。假设我们想要导入`java.lang`中的所有类库。为了做到这一点，我们可以用`.*`替换`.Math`，并将其变为`java.lang.*`，这意味着“导入`java.lang`包中的每个库”。我应该告诉你，在NetBeans中工作的人，这个导入是默认完成的。然而，在这种情况下，我们将明确地这样做，因为你可能在其他Java环境中工作时也需要这样做。
- en: Char variables
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符变量
- en: Programs that manipulate numbers are all well and good, but quite often, we
    want to be able to work with text and words as well. To help us do this, Java
    defines the character, or `char`, the primitive type. Characters are the smallest
    entity of text that you can work with on a computer. We can think of them to start
    off with as single letters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数字的程序都很好，但通常我们也想要能够处理文本和单词。为了帮助我们做到这一点，Java定义了字符或`char`，原始类型。字符是您可以在计算机上处理的最小文本实体。一开始我们可以把它们想象成单个字母。
- en: 'Let''s create a new project; we''ll call it `Characters.java`. We''ll start
    our program by simply defining a single character. We''ll call it `character1`
    and we''ll assign to it the value of uppercase `H`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新项目；我们将其命名为`Characters.java`。我们将通过简单地定义一个单个字符来开始我们的程序。我们将其称为`character1`，并将其赋值为大写的`H`：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just as we have to use some extra syntax when defining a floating-point number
    explicitly, we need some extra syntax when defining a character. To tell Java
    that we''re explicitly declaring a character value here, we surround the letter
    we would like to assign to our variable with two single quotation marks. The single
    quotation marks, as opposed to double quotation marks, let Java know that we''re
    working with a character or a single letter, as opposed to trying to use an entire
    string. Characters can only have single entity values. If we attempt to assign
    the value of `Hi` to `character1`, NetBeans and Java would both let us know that
    that''s not a valid option:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在明确定义浮点数时我们必须使用一些额外的语法一样，当定义一个字符时，我们需要一些额外的语法。为了告诉Java我们在这里明确声明一个字符值，我们用两个单引号将我们想要分配给变量的字母括起来。单引号与双引号相反，让Java知道我们正在处理一个字符或一个单个字母，而不是尝试使用整个字符串。字符只能有单个实体值。如果我们尝试将`Hi`的值分配给`character1`，NetBeans和Java都会告诉我们这不是一个有效的选项：
- en: '![](img/c94edae3-6ae6-42bf-8c8f-648c655ca1ab.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c94edae3-6ae6-42bf-8c8f-648c655ca1ab.png)'
- en: 'Now, let''s move on and write a somewhat convoluted program that will nonetheless
    work pretty well for our example purposes. Let''s define five characters. We''ll
    call them `character1` through `character5`. We''ll assign each one of them with
    one of the five letters of the word "Hello," in that order. When these characters
    are printed together, our output will show `Hello`. In the second portion of our
    program, let''s use `System.out.print()` to display these letters on the screen.
    The `System.out.print()` code works just the same as `System.out.println()`, except
    that it doesn''t add a carriage return at the end of our line. Let''s have the
    last command as `println` so that our output is separated from all of the additional
    text presented in our console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续编写一个有些复杂但对我们的示例目的非常有效的程序。让我们定义五个字符。我们将它们称为`character1`到`character5`。我们将它们中的每一个分配给单词"Hello"的五个字母中的一个，按顺序。当这些字符一起打印时，我们的输出将显示`Hello`。在我们程序的第二部分，让我们使用`System.out.print()`在屏幕上显示这些字母。`System.out.print()`代码的工作方式与`System.out.println()`完全相同，只是它不会在我们的行末添加回车。让我们将最后一个命令设置为`println`，这样我们的输出就与控制台中呈现的所有附加文本分开了：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run this program, it greets us. It says `Hello` and then there is some
    additional text:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，它会向我们打招呼。它会说`Hello`，然后还会有一些额外的文本：
- en: '![](img/b8050473-9463-4dd5-8718-97230d9a5c7c.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8050473-9463-4dd5-8718-97230d9a5c7c.jpg)'
- en: That's pretty straightforward.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。
- en: Now let me show you something that will give us a little insight into how our
    computer thinks about characters. It turns out that we can set the value of `character1`
    not only by explicitly declaring the capital letter `H` between two single quotation
    marks, but also by giving it an integer value. Each possible character value has
    a corresponding number that we can use in lieu of it. If we replace `H` with the
    value of `72`, we're still going to print out `Hello`. If we were to use the value
    `73`, one greater than `72`, instead of the capital `H`, we'll now get the capital
    letter `I`, as I is the letter that follows H.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我向您展示一些东西，这将让我们对计算机如何处理字符有一点了解。事实证明，我们不仅可以通过在两个单引号之间明确声明大写字母`H`来设置`character1`的值，还可以通过给它一个整数值来设置它的值。每个可能的字符值都有一个相应的数字，我们可以用它来代替。如果我们用值`72`替换`H`，我们仍然会打印出`Hello`。如果我们使用值`73`，比`72`大一的值，而不是大写字母`H`，我们现在会得到大写字母`I`，因为I是紧随H之后的字母。
- en: We have to make sure we don't put `72` between single quotation marks. The best
    case scenario is that Java recognizes that `72` is not a valid character and that
    it looks more like two characters, then our program won't compile. If we use a
    single digit number surrounded by single quotation marks, our program would compile
    just fine, but we would get the completely unexpected output of `7ello`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保不要在两个单引号之间放置`72`。最好的情况是Java会认识到`72`不是一个有效的字符，而更像是两个字符，那么我们的程序就不会编译。如果我们用单引号括起来的单个数字，我们的程序会编译得很好，但我们会得到完全意想不到的输出`7ello`。
- en: 'So how do we figure out the numeric value of characters? Well, there''s a universal
    lookup table, the **ASCII** table, which maps characters to their numeric values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何找出字符的数值呢？嗯，有一个通用的查找表，**ASCII**表，它将字符映射到它们的数值：
- en: '![](img/eb16142c-1f5e-44d0-8b7c-6fbb6a4444b1.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb16142c-1f5e-44d0-8b7c-6fbb6a4444b1.png)'
- en: In this section, we've been dealing with columns 1 (**Dec**) and columns 5 (**Chr**),
    which have the decimal number and the character that they are mapped to. You'll
    notice that while many of these characters are letters, some are keyboard symbols,
    numbers, and other things, such as tabs. As far as programming languages are concerned,
    new lines, tabs, and back spaces are all character elements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们一直在处理第1列（**Dec**）和第5列（**Chr**），它们分别是十进制数和它们映射到的字符。您会注意到，虽然许多这些字符是字母，但有些是键盘符号、数字和其他东西，比如制表符。就编程语言而言，换行、制表符和退格都是字符元素。
- en: 'To see this in action, let''s try replacing some of the characters in our program
    with the decimal value `9`, which should correspond to a tab character. If we
    replace the middle three letters of our word with tabs, as output, we should expect
    `H`, three tabs, and `o`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个过程，让我们尝试用十进制值`9`替换程序中的一些字符，这应该对应一个制表符。如果我们用制表符替换单词中间的三个字母，作为输出，我们应该期望`H`，三个制表符和`o`：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the output of the preceding code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '![](img/4f442e9c-7ff8-4d23-bc48-ad46675cc20a.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f442e9c-7ff8-4d23-bc48-ad46675cc20a.jpg)'
- en: Strings
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Let''s talk about strings in Java. To begin, create a new NetBeans project,
    name it `StringsInJava`, and enter the `main()` function. Then, declare two variables:
    a character called `c` and `String` called `s`. Right away, it becomes clear to
    us that `String` is a little different. You''ll notice that NetBeans did not choose
    to color code our `String` keyword with blue, as it would have done if we were
    declaring a variable of a primitive type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈Java中的字符串。首先，创建一个新的NetBeans项目，命名为`StringsInJava`，并输入`main()`函数。然后，声明两个变量：一个名为`c`的字符和一个名为`s`的`String`。很快，我们就清楚地看到`String`有点不同。您会注意到NetBeans没有选择用蓝色对我们的`String`关键字进行着色，就像我们声明原始类型的变量时那样：
- en: '![](img/74e727d1-8ce8-4eb4-8572-e950945b1dc0.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74e727d1-8ce8-4eb4-8572-e950945b1dc0.png)'
- en: This is because `String`, unlike `char`, is not a primitive type. `String` is
    what we call a class. Classes are the backbone of object-oriented programming.
    Just as we can declare variables of a primitive type, we can also declare variables
    of a class, which are called instances. In our program, the variable `s` is an
    instance of the `String` class. Unlike variables of primitive types, instances
    of a class can contain their own special methodologies and functions declared
    by the class of which they are an instance. In this section, we'll use some of
    these string-specific methods and functions to manipulate text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`String`不像`char`那样是原始类型。`String`是我们所谓的类。类是面向对象编程的支柱。正如我们可以声明原始类型的变量一样，我们也可以声明类的变量，称为实例。在我们的程序中，变量`s`是`String`类的一个实例。与原始类型的变量不同，类的实例可以包含由它们是实例的类声明的自己的特殊方法和函数。在本节中，我们将使用一些特定于字符串的方法和函数来操作文本。
- en: But first, let's take a look at what makes the `String` class so special. As
    we know, we can pretty much use our character variables and our character literals
    interchangeably, as we can with just about any other primitive type. The `String`
    class also maps interchangeably with the string literal, which is like a character
    literal but uses double quotation marks and can contain many or no characters
    at all. Most Java classes do not map to any sort of literal, and our ability to
    manipulate string literals through the `String` class is what makes it so valuable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看`String`类有什么特别之处。我们知道，我们几乎可以将字符变量和字符文字互换使用，就像我们可以用任何其他原始类型一样。`String`类也可以与字符串文字互换使用，它类似于字符文字，但使用双引号并且可以包含许多或没有字符。大多数Java类不能与任何类型的文字互换，而我们通过`String`类来操作字符串文字的能力正是它如此宝贵的原因。
- en: The concatenation operator
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接运算符
- en: 'Another thing strings can do, which most Java classes cannot, is make use of
    the addition sign (`+`) operator. If we declare three strings (say, `s1`, `s2`,
    and `s3`), we can set the value of our third string to be one string plus another
    string. We can even add a string literal into the mix. Then, we print `s3`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串还有一项功能，大多数Java类都做不到，那就是利用加号（`+`）运算符。如果我们声明三个字符串（比如`s1`，`s2`和`s3`），我们可以将第三个字符串的值设置为一个字符串加上另一个字符串。我们甚至可以将一个字符串文字添加到其中。然后，我们打印`s3`：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run this program, we''ll see these three strings added together in
    much the manner that we would expect:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们将看到这三个字符串被添加在一起，就像我们所期望的那样：
- en: '![](img/15aef721-7741-489e-8297-d4ba8efa14af.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15aef721-7741-489e-8297-d4ba8efa14af.jpg)'
- en: The toUpperCase() function
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: toUpperCase()函数
- en: 'So I promised you that strings had the functionality not seen in a simple primitive
    type. To employ this, let''s navigate to the `String` class in our Java documentation
    at [docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/).
    Select java.lang shown under Packages, then scroll down and select String from
    ClassSummary. As with the documentation for all Java classes, the String documentation
    contains Method Summary, which will tell us about all the functions we can call
    on an existing `String` object. If we scroll down in Method Summary, we''ll come
    to the `toUpperCase()` function that converts all the characters in a string into
    uppercase letters:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我向您承诺，字符串具有简单原始类型中看不到的功能。为了使用这个功能，让我们转到我们的Java文档中的`String`类，网址是[docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/)。在Packages下选择java.lang，然后向下滚动并选择ClassSummary中的String。与所有Java类的文档一样，String文档包含Method
    Summary，它将告诉我们关于现有`String`对象可以调用的所有函数。如果我们在Method Summary中向下滚动，我们将找到`toUpperCase()`函数，它将字符串中的所有字符转换为大写字母：
- en: '![](img/d33d6172-8e2e-45de-9e66-5c6a64690309.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d33d6172-8e2e-45de-9e66-5c6a64690309.jpg)'
- en: 'Let''s employ this function now. Back in NetBeans, we now need to determine
    the best place in our program to employ our `toUpperCase()` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这个函数。回到NetBeans，我们现在需要确定在我们的程序中使用`toUpperCase()`函数的最佳位置：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We know we need to employ the `toUpperCase()` function on the `s3` string after
    finalizing the value of `s3` in our `StringsInJava.java` program. We could do
    either of these two things:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要在`StringsInJava.java`程序中确定`s3`的值之后，使用`toUpperCase()`函数。我们可以做以下两件事中的任何一件：
- en: Employ the function on the line immediately after finalizing the value of `s3`
    (by simply typing `s3.toUpperCase();`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定`s3`的值之后，立即在下一行上使用该函数（只需键入`s3.toUpperCase();`）。
- en: 'Call the function as part of the line where we would print out the value of
    `s3`. Instead of printing out the value of `s3`, we could simply print out the
    value of `s3.toUpperCase()`, as shown in the following code block:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们打印出`s3`的值的那一行的一部分中调用该函数。我们可以简单地打印出`s3`的值，也可以打印出`s3.toUpperCase()`的值，如下面的代码块所示：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you remember from our documentation, the `toUpperCase()` function requires
    no arguments. It knows that it''s being called by `s3`, and that''s all the knowledge
    it needs, but we still provide the double empty parentheses so that Java knows
    we are in fact making a function call. If we run this program now, we''ll get
    the uppercased version of the string, as expected:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们的文档，`toUpperCase()`函数不需要参数。它知道它是由`s3`调用的，这就是它所需要的所有知识，但我们仍然提供双空括号，以便Java知道我们实际上正在进行函数调用。如果我们现在运行这个程序，我们将得到预期的字符串大写版本：
- en: '![](img/d52037bd-bb4a-4393-8ffa-a8468da9cf59.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d52037bd-bb4a-4393-8ffa-a8468da9cf59.jpg)'
- en: 'But, it''s important we understand what''s going on behind the scenes here.
    The `System.out.println(s3.toUpperCase());` code line is not modifying the value
    of `s3` and then printing out that value. Rather, our `println` statement evaluates
    `s3.toUpperCase()` and then prints out the string returned by that function. To
    see that the actual value of `s3` is not modified by this function call, we can
    print the value of `s3` again:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，重要的是我们要理解这里发生了什么。`System.out.println(s3.toUpperCase());`代码行并不修改`s3`的值，然后打印出该值。相反，我们的`println`语句评估`s3.toUpperCase()`，然后打印出该函数返回的字符串。为了看到`s3`的实际值并没有被这个函数调用修改，我们可以再次打印`s3`的值：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can see that `s3` keeps its lowercase components:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`s3`保留了它的小写组件：
- en: '![](img/6903f535-8f3a-42ae-8705-bbffc3cbdd70.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6903f535-8f3a-42ae-8705-bbffc3cbdd70.jpg)'
- en: 'If we want to permanently modify the value of `s3`, we could do that on the
    previous line, and we could set the value of `s3` to the function''s result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想永久修改`s3`的值，我们可以在上一行这样做，并且我们可以将`s3`的值设置为函数的结果：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the output of the preceding code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/6a4b2e41-154f-4468-b641-df6521c301b3.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a4b2e41-154f-4468-b641-df6521c301b3.jpg)'
- en: The replace() function
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: replace()函数
- en: 'To confirm that we''re all on the same page, let''s employ one more method
    from the `String` class. If we head back to our documentation and scroll up, we
    can find the String''s `replace()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们都在同一页面上，让我们再使用`String`类的一个方法。如果我们回到我们的文档并向上滚动，我们可以找到String的`replace()`方法：
- en: '![](img/b878df4e-62f5-4c8c-ba1f-e6ba5f737f08.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b878df4e-62f5-4c8c-ba1f-e6ba5f737f08.png)'
- en: Unlike our `toUpperCase()` method, which took no arguments, `replace()` takes
    two characters as arguments. The function will return a new string where all the
    instances of the first character (`oldChar`) we give as an argument are replaced
    with the second character (`newChar`) we gave as an argument.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`toUpperCase()`方法不同，它不带参数，`replace()`需要两个字符作为参数。该函数将返回一个新的字符串，其中我们作为参数给出的第一个字符（`oldChar`）的所有实例都被我们作为参数给出的第二个字符（`newChar`）替换。
- en: 'Let''s utilize this function on our first `println()` line in `StringsInJava.java`.
    We''ll type `s3.replace()` and give our function two characters as arguments.
    Let''s replace the character `g` with the character `o`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`StringsInJava.java`的第一个`println()`行上使用这个函数。我们将输入`s3.replace()`并给我们的函数两个字符作为参数。让我们用字符`g`替换字符`o`：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run our program, of course, nothing happens. This is because by the time
    we reach the print statement, there are no lowercase `g` characters, and there
    are no lowercase `g` characters left in `s3`; there are only uppercase `G` characters.
    So let''s try and replace the uppercase `G` characters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，当然什么也不会发生。这是因为当我们到达打印语句时，没有小写的`g`字符，也没有剩余的小写的`g`字符在`s3`中；只有大写的`G`字符。所以让我们尝试替换大写的`G`字符：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now if we run our program, we see the replacement happen on the first instance
    of `println`, not on the second instance. This is because we haven''t actually
    changed the value of `s3`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的程序，我们会看到替换发生在第一个`println`的实例上，而不是第二个实例上。这是因为我们实际上没有改变`s3`的值：
- en: '![](img/11075cfd-2d3f-4276-8c4f-07faeff0d964.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11075cfd-2d3f-4276-8c4f-07faeff0d964.jpg)'
- en: Excellent! You are now well-equipped, as long as you have the Java documentation
    handy, to call all sorts of `String` methods.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在你已经装备精良，只要你随时准备好Java文档，就可以调用各种`String`方法。
- en: Escape sequences
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义序列
- en: 'If you spend a lot of time working with strings though, I anticipate that you''re
    going to run into a common problem. Let''s take a look at it quickly. I''m just
    going to write a brand new program here. I''m going to declare a string, then
    I''m going to have our program print the string to the screen. But the value I''m
    going to assign to this string is going to be a little tricky. I''d like our program
    to print out `The program says: "Hello World"` (I''d like `Hello World` to be
    surrounded by double quotation marks):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你花了很多时间处理字符串，我预计你会遇到一个常见的问题。让我们快速看一下。我要在这里写一个全新的程序。我要声明一个字符串，然后让我们的程序将字符串打印到屏幕上。但我要给这个字符串赋值的值会有点棘手。我希望我们的程序打印出`The
    program says: "Hello World"`（我希望`Hello World`被双引号括起来）：'
- en: '![](img/28c20394-e017-4a4d-bdac-f5a589ccd91b.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28c20394-e017-4a4d-bdac-f5a589ccd91b.png)'
- en: The problem here is that putting double quotation marks inside a string literal
    confuses Java as shown in the preceding screenshot. When it reads through our
    program, the first full string it sees is `"The program says:"` that tells Java
    that we've ended our string. This is, of course, not what we want.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在字符串文字中放置双引号会让Java感到困惑，就像前面的屏幕截图所示的那样。当它阅读我们的程序时，它看到的第一个完整字符串是`"The program
    says:"`，这告诉Java我们已经结束了字符串。这当然不是我们想要的。
- en: 'Fortunately, there''s a system in place for us to tell Java that we''d like
    a character to be treated as a character literal instead of the special functionality
    that it might otherwise have. To do this, we put a backslash in front of the character.
    This is known as an escape sequence:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个系统可以告诉Java，我们希望一个字符被视为字符文字，而不是它可能具有的特殊功能。为此，我们在字符前面放一个反斜杠。这被称为转义序列：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, when Java reads through this string, it will read `The program says:`
    and then see the backslash and know how to treat our double quotation marks as
    double quotation marks, the character, instead of the double quotation marks that
    surround a string. When we run our program, we will not see backslashes; they
    themselves are special characters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当Java阅读这个字符串时，它将读取`The program says:`，然后看到反斜杠，并知道如何将我们的双引号视为双引号字符，而不是围绕字符串的双引号。当我们运行我们的程序时，我们将看不到反斜杠；它们本身是特殊字符：
- en: '![](img/d7026d00-78d1-4124-9766-63ab2c3442b7.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7026d00-78d1-4124-9766-63ab2c3442b7.jpg)'
- en: 'If we do want to see a backslash in our string, we need to preface it by a
    backslash of its own:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实想在字符串中看到反斜杠，我们需要在其前面加上一个反斜杠：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](img/b2312c48-76f0-4437-b73a-5315b4f764f2.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2312c48-76f0-4437-b73a-5315b4f764f2.jpg)'
- en: That's strings 101!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是字符串101！
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explained what variables are and how important they are
    for creating better programs. We looked at some of the primitive data types of
    Java, namely `int`, `long`, `float`, `char`, and `double`, in detail. We also
    saw the `String` class and two of its manipulation methods.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了变量是什么，以及它们对于创建更好的程序有多重要。我们详细介绍了Java的一些原始数据类型，即`int`、`long`、`float`、`char`和`double`。我们还看到了`String`类及其两种操作方法。
- en: In the next chapter, we'll look at branching statements in Java.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Java中的分支语句。
