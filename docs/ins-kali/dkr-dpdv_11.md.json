["```\n> docker-compose --version\ndocker-compose version 1.18.0, build 8dd22a96 \n```", "```\n$ docker-compose --version\ndocker-compose version `1`.18.0, build 8dd22a96 \n```", "```\n> Invoke-WebRequest ` \"https://github.com/docker/compose/releases/download/1\\\n.18.0/docker-compose-Windows-x86_64.exe\" `\n-UseBasicParsing `\n-OutFile $Env:ProgramFiles\\docker\\docker-compose.exe\n\nWriting web request\nWriting request stream... (Number of bytes written: 5260755) \n```", "```\n> docker-compose --version\ndocker-compose version 1.18.0, build 8dd22a96 \n```", "```\n`$` `curl` `-``L` `\\`\n `https``:``//``github``.``com``/``docker``/``compose``/``releases``/``download``/``1.18.0``/``docker``-``compose-```", "`````-`````", "```` `\\`\n `-``o` `/``usr``/``local``/``bin``/``docker``-``compose`\n\n`% Total    % Received   Time        Time     Time    Current`\n                        `Total`       `Spent`    `Left`    `Speed`\n`100`   `617`    `0`   `617`    `0` `--:--:--` `--:--:--` `--:--:--`  `1047`\n`100` `8280``k`  `100` `8280``k`    `0`  `0``:``00``:``03`  `0``:``00``:``03` `--:--:--`  `4069``k` \n```\n\n `Now that you\u2019ve downloaded the `docker-compose` binary, use the following `chmod` command to make it executable.\n\n```\n$ chmod +x /usr/local/bin/docker-compose \n```\n\n `Verify the installation and check the version.\n\n```\n$ docker-compose --version\ndocker-compose version `1`.18.0, build 8dd22a9 \n```\n\n `You\u2019re ready to use Docker Compose on Linux.\n\nYou can also use `pip` to install Compose from its Python package. But we don\u2019t want to waste pages showing every possible installation method. Enough is enough, time to move on!\n\n#### Compose files\n\nCompose uses YAML files to define multi-service applications. YAML is a subset of JSON, so you can also use JSON. However, all of the examples in this chapter will be YAML.\n\nThe default name for the Compose YAML file is `docker-compose.yml`. However, you can use the `-f` flag to specify custom filenames.\n\nThe following example shows a very simple Compose file that defines a small Flask app with two services (`web-fe` and `redis`). The app is a simple web server that counts the number of visits and stores the value in Redis. We\u2019ll call the app `counter-app` and use it as the example application for the rest of the chapter.\n\n```\nversion: \"3.5\"\nservices:\n  web-fe:\n    build: .\n    command: python app.py\n    ports:\n      - target: 5000\n        published: 5000\n    networks:\n      - counter-net\n    volumes:\n      - type: volume\n        source: counter-vol\n        target: /code\n  redis:\n    image: \"redis:alpine\"\n    networks:\n      counter-net:\n\nnetworks:\n  counter-net:\n\nvolumes:\n  counter-vol: \n```\n\n `We\u2019ll skip through the basics of the file before taking a closer look.\n\nThe first thing to note is that the file has 4 top-level keys:\n\n*   `version`\n*   `services`\n*   `networks`\n*   `volumes`\n\nOther top-level keys exist, such as `secrets` and `configs`, but we\u2019re not looking at those right now.\n\nThe `version` key is mandatory, and it\u2019s always the first line at the root of the file. This defines the version of the Compose file format (basically the API). You should normally use the latest version.\n\nIt\u2019s important to note that the `versions` key does not define the version of Docker Compose or the Docker Engine. For information regarding compatibility between versions of the Docker Engine, Docker Compose, and the Compose file format, google \u201cCompose file versions and upgrading\u201d.\n\nFor the remainder of this chapter we\u2019ll be using version 3 or higher of the Compose file format.\n\nThe top-level `services` key is where we define the different application services. The example we\u2019re using defines two services; a web front-end called `web-fe`, and an in-memory database called `redis`. Compose will deploy each of these services as its own container.\n\nThe top-level `networks` key tells Docker to create new networks. By default, Compose will create `bridge` networks. These are single-host networks that can only connect containers on the same host. However, you can use the `driver` property to specify different network types.\n\nThe following code can be used in your Compose file to create a new *overlay* network called `over-net` that allows standalone containers to connect to it (`attachable`).\n\n```\n`networks``:`\n  `over``-``net``:`\n  `driver``:` `overlay`\n  `attachable``:` `true` \n```\n\n `The top-level `volumes` key is where we tell Docker to create new volumes.\n\n##### Our specific Compose file\n\nThe example file we\u2019ve listed uses the Compose v3.5 file format, defines two services, defines a network called counter-net, and defines a volume called counter-vol.\n\nMost of the detail is in the `services` section, so let\u2019s take a closer look at that.\n\nThe services section of our Compose file has two second-level keys:\n\n*   web-fe\n*   redis\n\nEach of these defines a service in the app. It\u2019s important to understand that Compose will deploy each of these as a container, and it will use the name of the keys as part of the container names. In our example, we\u2019ve defined two keys; `web-fe` and `redis`. This means Compose will deploy two containers, one will have `web-fe` in its name and the other will have `redis`.\n\nWithin the definition of the `web-fe` service, we give Docker the following instructions:\n\n*   `build: .` This tells Docker to build a new image using the instructions in the `Dockerfile` in the current directory (`.`). The newly built image will be used to create the container for this service.\n*   `command: python app.py` This tells Docker to run a Python app called `app.py` as the main app in the container. The `app.py` file must exist in the image, and the image must contain Python. The Dockerfile takes care of both of these requirements.\n*   `ports:` Tells Docker to map port 5000 inside the container (`-target`) to port 5000 on the host (`published`). This means that traffic sent to the Docker host on port 5000 will be directed to port 5000 on the container. The app inside the container listens on port 5000.\n*   `networks:` Tells Docker which network to attach the service\u2019s container to. The network should already exist, or be defined in the `networks` top-level key. If it\u2019s an overlay network, it will need to have the `attachable` flag so that standalone containers can be attached to it (Compose deploys standalone containers instead of Docker Services).\n*   `volumes:` Tells Docker to mount the counter-vol volume (`source:`) to `/code` (\u2018target:\u2019) inside the container. The `counter-vol` volume needs to already exist, or be defined in the `volumes` top-level key at the bottom of the file.\n\nIn summary, Compose will instruct Docker to deploy a single standalone container for the `web-fe` service. It will be based on an image built from a Dockerfile in the same directory as the Compose file. This image will be started as a container and run `app.py` as its main app. It will expose itself on port 5000 on the host, attach to the `counter-net` network, and mount a volume to `/code`.\n\n> **Note:** Technically speaking, we don\u2019t need the `command: python app.py` option. This is because the application\u2019s Dockerfile already defines `python app.py` as the default app for the image. However, we\u2019re showing it here so you know how it works. You can also use it to override CMD instructions set in Dockerfiles.\n\nThe definition of the `redis` service is simpler:\n\n*   `image: redis:alpine` This tells Docker to start a standalone container called `redis` based on the `redis:alpine` image. This image will be pulled from Docker Hub.\n*   `networks:` The `redis` container will be attached to the `counter-net` network.\n\nAs both services will be deployed onto the same `counter-net` network, they will be able to resolve each other by name. This is important as the application is configured to communicate with the redis service by name.\n\nNow that we understand how the Compose file works, let\u2019s deploy it!\n\n#### Deploying an app with Compose\n\nIn this section, we\u2019ll deploy the app defined in the Compose file from the previous section. To do this, you\u2019ll need the following 4 files from https://github.com/nigelpoulton/counter-app:\n\n*   Dockerfile\n*   app.py\n*   requirements.txt\n*   docker-compose.yml\n\nClone the Git repo locally.\n\n```\n$ git clone https://github.com/nigelpoulton/counter-app.git\n\nCloning into `'counter-app'`...\nremote: Counting objects: `9`, `done`.\nremote: Compressing objects: `100`% `(``8`/8`)`, `done`.\nremote: Total `9` `(`delta `1``)`, reused `5` `(`delta `0``)`, pack-reused `0`\nUnpacking objects: `100`% `(``9`/9`)`, `done`.\nChecking connectivity... `done`. \n```\n\n `Cloning the repo will create a new sub-directory called `counter-app`. This will contain all of the required files and will be considered your *build context*. Compose will also use the name of the directory (`counter-app`) as your project name. We\u2019ll see this later, but Compose will pre-pend all resource names with `counter-app_`.\n\nChange into the `counter-app` directory and check the files are present.\n\n```\n$ `cd` counter-app\n$ ls\napp.py  docker-compose.yml  Dockerfile  requirements.txt ... \n```\n\n `Let\u2019s quickly describe each file:\n\n*   `app.py` is the application code (a Python Flask app)\n*   `docker-compose.yml` is the Docker Compose file that describes how Docker should deploy the app\n*   `Dockerfile` describes how to build the image for the `web-fe` service\n*   `requirements.txt` lists the Python packages required for the app\n\nFeel free to inspect the contents of each file.\n\nThe `app.py` file is obviously the core of the application. But `docker-compose.yml` is the glue that sticks all the app components together.\n\nLet\u2019s use Compose to bring the app up. You must run the all of the following commands from within the `counter-app` directory that you just cloned from GitHub.\n\n```\n$ docker-compose up `&`\n\n`[``1``]` `1635`\nCreating network `\"counterapp_counter-net\"` with the default driver\nCreating volume `\"counterapp_counter-vol\"` with default driver\nPulling redis `(`redis:alpine`)`...\nalpine: Pulling from library/redis\n1160f4abea84: Pull `complete`\na8c53d69ca3a: Pull `complete`\n<Snip>\nweb-fe_1  `|`  * Debugger PIN: `313`-791-729 \n```\n\n `It\u2019ll take a few seconds for the app to come up, and the output can be quite verbose.\n\nWe\u2019ll step through what happened in a second, but first let\u2019s talk about the `docker-compose` command.\n\n`docker-compose up` is the most common way to bring up a Compose app (we\u2019re calling a multi-container app defined in a Compose file a *Compose app*). It builds all required images, creates all required networks and volumes, and starts all required containers.\n\nBy default, `docker-compose up` expects the name of the Compose file to `docker-compose.yml` or `docker-compose.yaml`. If your Compose file has a different name, you need to specify it with the `-f` flag. The following example will deploy an application from a Compose file called `prod-equus-bass.yml`\n\n```\n$ docker-compose -f prod-equus-bass.yml up \n```\n\n `It\u2019s also common to use the `-d` flag to bring the app up in the background. For example:\n\n```\ndocker-compose up -d\n\n--OR--\n\ndocker-compose -f prod-equus-bass.yml up -d \n```\n\n `Our example brought the app up in the foreground (we didn\u2019t use the `-d` flag), but we used the `&` to give us the terminal window back. This is not normal, but it will output logs directly in our terminal window which we\u2019ll use later.\n\nNow that the app is built and running, we can use normal `docker` commands to view the images, containers, networks, and volumes that Compose created.\n\n```\n$ docker image ls\nREPOSITORY          TAG         IMAGE ID    CREATED         SIZE\ncounterapp_web-fe   latest      `96`..6ff9e   `3` minutes ago   `95`.9MB\npython              `3`.4-alpine  `01`..17a02   `2` weeks ago     `85`.5MB\nredis               alpine      ed..c83de   `5` weeks ago     `26`.9MB \n```\n\n `We can see that three images were either built or pulled as part of the deployment.\n\nThe `counterapp_web-fe:latest` image was created by the `build: .` instruction in the `docker-compose.yml` file. This instruction caused Docker to build a new image using the Dockerfile in the same directory. It contains the application code for the Python Flask web app, and was built from the `python:3.4-alpine` image. See the contents of the `Dockerfile` for more information.\n\n```\nFROM python:3.4-alpine           << Base image\nADD . /code                      << Copy app into image\nWORKDIR /code                    << Set working directory\nRUN pip install -r requirements.txt  << install requirements\nCMD [\"python\", \"app.py\"]         << Set the default app \n```\n\n `I\u2019ve added comments to the end of each line to help explain. They must be removed before deploying the app.\n\nNotice how Compose has named the newly built image as a combination of the project name (counter-app), and the resource name as specified in the Compose file (web-fe). Compose has removed the dash (`-`) from the project name. All resources deployed by Compose will follow this naming convention.\n\nThe `redis:alpine` image was pulled from Docker Hub by the `image: \"redis:alpine\"` instruction in the `.Services.redis` section of the Compose file.\n\nThe following container listing shows two containers. The name of each is prefixed with the name of the project (name of the working directory). Also, each one has a numeric suffix that indicates the instance number \u2014 this is because Compose allows for scaling.\n\n```\n$ docker container ls\nID    COMMAND           STATUS    PORTS                   NAMES\n`12`..  `\"python app.py\"`   Up `2` min  `0`.0.0.0:5000->5000/tcp  counterapp_web-fe_1\n`57`..  `\"docker-entry..\"`  Up `2` min  `6379`/tcp                counterapp_redis_1 \n```\n\n `The `counterapp_web-fe` container is running the application\u2019s web front end. This is running the `app.py` code and is mapped to port `5000` on all interfaces on the Docker host. We\u2019ll connect to this in just a second.\n\nThe following network and volume listings show the `counterapp_counter-net` and `counterapp_counter-vol` networks and volumes.\n\n```\n$ docker network ls\nNETWORK ID     NAME                     DRIVER    SCOPE\n1bd949995471   bridge                   bridge    `local`\n40df784e00fe   counterapp_counter-net   bridge    `local`\nf2199f3cf275   host                     host      `local`\n67c31a035a3c   none                     null      `local`\n\n$ docker volume ls\nDRIVER     VOLUME NAME\n<Snip>\n`local`      counterapp_counter-vol \n```\n\n `With the application successfully deployed, you can point a web browser at your Docker host on port `5000` and see the application in all its glory.\n\n![](images/figure9-1.png)\n\nPretty impressive ;-)\n\nHitting your browser\u2019s refresh button will cause the counter to increment. Feel free to inspect the app (`app.py`) to see how the counter data is stored in the Redis back-end.\n\nIf you brought the application up using the `&`, you will be able to see the `HTTP 200` response codes being logged in the terminal window. These indicate successful requests, and you\u2019ll see one for each time you load the web page.\n\n```\nweb-fe_1  | 172.18.0.1 - - [09/Jan/2018 11:13:21] \"GET / HTTP/1.1\" 200 -\nweb-fe_1  | 172.18.0.1 - - [09/Jan/2018 11:13:33] \"GET / HTTP/1.1\" 200 - \n```\n\n `Congratulations. You\u2019ve successfully deployed a multi-container application using Docker Compose!\n\n#### Managing an app with Compose\n\nIn this section, we\u2019ll see how to start, stop, delete, and get the status of applications being managed by Docker Compose. We\u2019ll also see how the volume we\u2019re using can be used to directly inject updates to the app\u2019s web front-end.\n\nAs the application is already up, let\u2019s see how to bring it down. To do this, replace the `up` sub-command with `down`.\n\n```\n$ docker-compose down\n `1`. Stopping counterapp_redis_1  ...\n `2`. Stopping counterapp_web-fe_1 ...\n `3`. redis_1   `|` `1`:signal-handler Received SIGTERM scheduling shutdown...\n `4`. redis_1   `|` `1`:M `09` Jan `11`:16:00.456 `# User requested shutdown...`\n `5`. redis_1   `|` `1`:M `09` Jan `11`:16:00.456 * Saving the final RDB snap...\n `6`. redis_1   `|` `1`:M `09` Jan `11`:16:00.463 * DB saved on disk\n `7`. Stopping counterapp_redis_1  ... `done`\n `8`. counterapp_redis_1 exited with code `0`\n `9`. Stopping counterapp_web-fe_1 ... `done`\n`10`. Removing counterapp_redis_1  ... `done`\n`11`. Removing counterapp_web-fe_1 ... `done`\n`12`. Removing network counterapp_counter-net\n`13`. `[``1``]`+  Done          docker-compose up \n```\n\n `Because we started the app with the `&`, it\u2019s running in the foreground. This means we get a verbose output to the terminal, giving us an excellent insight into how things work. Let\u2019s step through what each line is telling us.\n\nLines 1 and 2 are stopping the two services. These are the `web-fe` and `redis` services defined in the Compose file.\n\nLine 3 shows that the `stop` instruction sends a `SIGTERM` signal. This is sent to the PID 1 process in each container. Lines 4-6 show the Redis container gracefully handling the signal and shutting itself down. Lines 7 and 8 report the success of stop operation.\n\nLine 9 shows the `web-fe` service successfully stopping.\n\nLines 10 and 11 show the stopped services being removed.\n\nLine 12 shows the `counter-net` network being removed, and line 13 shows the `docker-compose up` process exiting.\n\nIt\u2019s important to note that the `counter-vol` volume was **not** deleted. This is because volumes are intended to be long-term persistent data stores. As such, their lifecycle is entirely decoupled from the containers they serve. Running a `docker volume ls` will show that the volume is still present on the system. If you\u2019d written any data to the volume it would still exist.\n\nAlso, any images that were built or pulled as part of the `docker-compose up` operation will still remain on the system. This means future deployments of the app will be faster.\n\nLet\u2019s look at a few other `docker-compose` sub-commands.\n\nUse the following command to bring the app up again, but this time in the background.\n\n```\n$ docker-compose up -d\nCreating network `\"counterapp_counter-net\"` with the default driver\nCreating counterapp_redis_1  ... `done`\nCreating counterapp_web-fe_1 ... `done` \n```\n\n `See how the app started much faster this time \u2014 the counter-vol volume already exists, and no images needed building or pulling.\n\nShow the current state of the app with the `docker-compose ps` command.\n\n```\n$ docker-compose ps\nName                  Command               State   Ports\n--------------------------------------------------------------------------\ncounterapp_redis_1    docker-entrypoint...  Up      `6379`/tcp\ncounterapp_web-fe_1   python app.py         Up      `0`.0.0.0:5000->5000/tcp \n```\n\n `We can see both containers, the commands they are running, their current state, and the network ports they are listening on.\n\nUse the `docker-compose top` command to list the processes running inside of each service (container).\n\n```\n$ docker-compose top\ncounterapp_redis_1\nPID     USER     TIME     COMMAND\n------------------------------------\n`843`   dockrema   `0`:00   redis-server\n\ncounterapp_web-fe_1\nPID    USER   TIME             COMMAND\n-------------------------------------------------\n`928`    root   `0`:00   python app.py\n`1016`   root   `0`:00   /usr/local/bin/python app.py \n```\n\n `The PID numbers returned are the PID numbers as seen from the Docker host (not from within the containers).\n\nUse the `docker-compose stop` command to stop the app without deleting its resources. Then show the status of the app with `docker-compose ps`.\n\n```\n$ docker-compose stop\nStopping counterapp_web-fe_1 ... `done`\nStopping counterapp_redis_1  ... `done`\n\n$ docker-compose ps\nName                  Command                      State\n---------------------------------------------------------\ncounterapp_redis_1    docker-entrypoint.sh redis   Exit `0`\ncounterapp_web-fe_1   python app.py                Exit `0` \n```\n\n `As we can see, stopping a Compose app does not remove the application definition from the system. It just stops the app\u2019s containers. You can verify this with the `docker container ls -a` command.\n\nYou can delete a stopped Compose app with the `docker-compose rm` command. This will delete the containers and networks the app is using, but it will not delete volumes or images. Nor will it delete the application source code (`app.py`, `Dockerfile`, `requirements.txt`, and `docker-compose.yml`) in your project directory.\n\nRestart the app with the `docker-compose restart` command.\n\n```\n$ docker-compose restart\nRestarting counterapp_web-fe_1 ... `done`\nRestarting counterapp_redis_1  ... `done` \n```\n\n `Verify the operation.\n\n```\n$ docker-compose ps\nName                  Command               State   Ports\n--------------------------------------------------------------------------\ncounterapp_redis_1    docker-entrypoint...  Up      `6379`/tcp\ncounterapp_web-fe_1   python app.py         Up      `0`.0.0.0:5000->5000/tcp \n```\n\n `Use the `docker-compose down` command to **stop and delete** the app with a single command.\n\n```\n$ docker-compose down\nStopping counterapp_web-fe_1 ... `done`\nStopping counterapp_redis_1  ... `done`\nRemoving counterapp_web-fe_1 ... `done`\nRemoving counterapp_redis_1  ... `done`\nRemoving network counterapp_counter-net \n```\n\n `The app is now deleted. Only its images, volumes and source code remain.\n\nLet\u2019s deploy the app one last time and see its volume in action.\n\n```\n$ docker compose up -d\nCreating network `\"counterapp_counter-net\"` with the default driver\nCreating counterapp_redis_1  ... `done`\nCreating counterapp_web-fe_1 ... `done` \n```\n\n `If you look in the Compose file, you\u2019ll see that we\u2019re defing a new volume called `counter-vol` and mounting it in to the `web-fe` service at `/code`.\n\n```\n`services``:`\n  `web``-``fe``:`\n  `<``Snip``>`\n    `volumes``:`\n      `-` `type``:` `volume`\n        `source``:` `counter``-``vol`\n        `target``:` `/``code`\n`<``Snip``>`\n`volumes``:`\n  `counter``-``vol``:` \n```\n\n `The first time we deployed the app, Compose checked to see if a volume already existed with this name. It did not, so it created it. You can see it with the `docker volume ls` command.\n\n```\n$ docker volume ls\nRIVER              VOLUME NAME\n`local`               counterapp_counter-vol \n```\n\n `It\u2019s also worth knowing that Compose builds networks and volumes **before** deploying services. This makes sense, as they are lower-level infrastructure objects that are consumed by services (containers). The following snippet shows Compose creating the network and volume as its first two tasks (even before building and pulling images).\n\n```\n$ docker-compose up -d\n\nCreating network `\"counterapp_counter-net\"` with the default driver\nCreating volume `\"counterapp_counter-vol\"` with default driver\nPulling redis `(`redis:alpine`)`...\n<Snip> \n```\n\n `If we take another look at the service definition for `web-fe`, we\u2019ll see that it\u2019s mounting the counter-app volume into the service\u2019s container at `/code`. We can also see from the Dockerfile that `/code` is where the app is installed and executed from. Net result, our app code resides on a Docker volume.\n\n![](images/figure9-2.png)\n\nThis all means we can make changes to files in the volume, from the host side, and have them reflected immediately in the app. Let\u2019s see it.\n\nThe next few steps will walk through the following process. We\u2019ll edit the `app.py` file in the project\u2019s working directory so that the app will display different text in the web browser. We\u2019ll copy updated app to the volume on the Docker host. We\u2019ll refresh the app\u2019s web page to see the updated text. This will work because whatever you write to the location of the volume on the Docker host will immediately appear in the volume in the container.\n\nUse you favourite text editor to edit the `app.py` file in the projects working directory. We\u2019ll use `vim` in the example.\n\n```\n$ vim ~/counter-app/app.py \n```\n\n `Change text between the double quote marks (\u201c\u201d) on line 22\\. The line starts with `return \"What's up...\"`. Enter any text you like, as long as it\u2019s within the double-quote marks, and save your changes.\n\nNow that we\u2019ve updated the app, we need to copy it into the volume on the Docker host. Each Docker volume is exposed at a location within the Docker host\u2019s filesystem, as well as a mount point in one or more containers. Use the following `docker volume inspect` command to find where the volume is exposed on the Docker host.\n\n```\n$ docker volume inspect counterapp_counter-vol `|` grep Mount\n\n`\"Mountpoint\"`: `\"/var/lib/docker/volumes/counterapp_counter-vol/_data\"`, \n```\n\n `Copy the updated app file to the volume\u2019s mount point on your Docker host. This will make it appear in the `web-fe` container at `/code`. The operation will overwrite the existing `/code/app.py` file in the container.\n\n```\n$ cp ~/counterapp/app.py `\\`\n  /var/lib/docker/volumes/counterapp_counter-vol/_data/app.py \n```\n\n `The updated app file is now on the container. Connect to the app to see your change. You can do this by pointing your web browser to the IP of your Docker host on port 5000.\n\nFigure 9.3 shows the updated app.\n\n![](images/figure9-3.png)\n\nObviously you wouldn\u2019t do this in production, but it\u2019s a real time-saver in development.\n\nCongratulations! You\u2019ve deployed and managed a simple multi-container app using Docker Compose.\n\nBefore reminding ourselves of the major commands we learned, it\u2019s important to understand that this was a very simple example. Docker Compose is capable of deploying and managing far more complex applications.\n\n### Deploying apps with Compose - The commands\n\n*   `docker-compose up` is the command we use to deploy a Compose app. It expects the Compose file to be called `docker-compose.yml` or `docker-compose.yaml`, but you can specify a custom filename with the `-f` flag. It\u2019s common to start the app in the background with the `-d` flag.\n*   `docker-compose stop` will stop all of the containers in a Compose app without deleting them from the system. The app can be easily restarted with `docker-compose restart`.\n*   `docker-compose rm` will delete a stopped Compose app. It will delete containers and networks, but it will not delete volumes and images.\n*   `docker-compose restart` will restart a Compose app that has been stopped with `docker-compose stop`. If you have made changes to your Compose app since stopping it, these changes will **not** appear in the restarted app. You will need to re-deploy the app to get the changes.\n*   `docker-compose ps` will list each container in the Compose app. It shows current state, the command each one is running, and network ports.\n*   `docker-compose down` will stop and delete a running Compose app. It deletes containers and networks, but not volumes and images.\n\n### Chapter Summary\n\nIn this chapter, we learned how to deploy and manage a multi-container application using Docker Compose.\n\nDocker Compose is a Python application that we install on top of the Docker Engine. It lets us define multi-container apps in a single declarative configuration file and deploy it with a single command.\n\nCompose files can be YAML or JSON, and they define all of the containers, networks, volumes, and secrets that an application requires. We then feed the file to the `docker-compose` command line tool, and Compose instructs Docker to deploy it.\n\nOnce the app is deployed, we can manage its entire lifecycle using the many `docker-compose` sub-commands.\n\nWe also saw how volumes can be used to mount changes directly into containers.\n\nDocker Compose is very popular with developers, and the Compose file is an excellent source of application documentation \u2014 it defies all the services that make up the app, the images they use, ports they expose, networks and volumes they use, and much more. As such, it can help bridge the gap between dev and ops. You should also treat your Compose files as if they were code. This means, among other things, storing them in source control repos.````", "`````````````````````````````"]