- en: Chapter 3. User-Defined Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。用户定义的网络
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下配方：
- en: Viewing the Docker network configuration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Docker网络配置
- en: Creating user-defined networks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户定义的网络
- en: Connecting containers to networks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器连接到网络
- en: Defining a user-defined bridge network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义用户定义的桥接网络
- en: Creating a user-defined overlay network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户定义的覆盖网络
- en: Isolating networks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离网络
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Earlier versions of Docker relied on a mostly static network model, which worked
    relatively well for most container networking needs. However, if you wanted to
    do something different, you weren't left with many options. For instance, you
    could tell Docker to deploy containers to a different bridge, but there wasn't
    a strong integration point between Docker and that network. With the introduction
    of user-defined networking in Docker 1.9, the game has changed. You can now create
    and manage bridge and multi-host networks directly through the Docker engine.
    In addition, the door has also been opened for third-party network plugins to
    integrate with Docker through libnetwork and its **Container Network Model** (**CNM**)
    model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的Docker依赖于一个基本静态的网络模型，这对大多数容器网络需求来说工作得相当好。然而，如果您想做一些不同的事情，您就没有太多选择了。例如，您可以告诉Docker将容器部署到不同的桥接，但Docker和该网络之间没有一个强大的集成点。随着Docker
    1.9中用户定义的网络的引入，游戏已经改变了。您现在可以直接通过Docker引擎创建和管理桥接和多主机网络。此外，第三方网络插件也可以通过libnetwork及其**容器网络模型**（**CNM**）模型与Docker集成。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CNM is Docker's model for defining a container network model. In [Chapter 7](ch07.html
    "Chapter 7. Working with Weave Net"), *Working with Weave Net*, we'll examine
    a third-party plugin (Weave) that can integrate as a Docker driver. The focus
    in this chapter will be on the default network drivers natively included with
    a Docker engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CNM是Docker用于定义容器网络模型的模型。在[第7章](ch07.html“第7章。使用Weave Net”)中，*使用Weave Net*，我们将研究一个第三方插件（Weave），它可以作为Docker驱动程序集成。本章的重点将放在Docker引擎中默认包含的网络驱动程序上。
- en: The move to a driver-based model symbolizes a great change in Docker networking.
    In addition to defining new networks, you're now also given the ability to connect
    and disconnect container interfaces dynamically. This inherent flexibility opens
    the door to many new possibilities to connect containers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 转向基于驱动程序的模型象征着Docker网络的巨大变化。除了定义新网络，您现在还可以动态连接和断开容器接口。这种固有的灵活性为连接容器打开了许多新的可能性。
- en: Viewing the Docker network configuration
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Docker网络配置
- en: 'As mentioned, defining and managing networks can now be done directly through
    Docker with the addition of the `network` subcommand. The `network` command provides
    you with all the options you need to build networks and connect containers to
    them:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，现在可以通过添加`network`子命令直接通过Docker定义和管理网络。`network`命令为您提供了构建网络并将容器连接到网络所需的所有选项：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this recipe, we'll learn how to view defined Docker networks as well as inspect
    them for specific details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何查看定义的Docker网络以及检查它们的具体细节。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The `docker network` subcommand was introduced in Docker 1.9, so you'll need
    a Docker host running at least that version. In our examples, we'll be using Docker
    version 1.12\. You'll also want to have a good understanding of your current network
    layout, so you can follow along as we inspect the current configuration. It is
    assumed that each Docker host is in its native configuration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network`子命令是在Docker 1.9中引入的，因此您需要运行至少该版本的Docker主机。在我们的示例中，我们将使用Docker版本1.12。您还需要对当前网络布局有很好的了解，这样您就可以跟着我们检查当前的配置。假设每个Docker主机都处于其本机配置中。'
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The first thing we want to do is figure out what networks Docker thinks are
    already defined. This can be done using the `network ls` subcommand:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是弄清楚Docker认为已经定义了哪些网络。这可以使用`network ls`子命令来完成：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, Docker shows that we have three different networks already defined.
    To view more information about a network, we can use the `network inspect` subcommand
    to retrieve specifics about the network definition as well as its current state.
    Let's take a close look at each defined network.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Docker显示我们已经定义了三种不同的网络。要查看有关网络的更多信息，我们可以使用`network inspect`子命令检索有关网络定义及其当前状态的详细信息。让我们仔细查看每个定义的网络。
- en: Bridge
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bridge
- en: 'The bridge network represents the `docker0` bridge that the Docker engine creates
    by default:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络代表Docker引擎默认创建的`docker0`桥：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output from the `inspect` command shows us a wealth of information about
    the defined network:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect`命令的输出向我们展示了关于定义网络的大量信息：'
- en: '`Driver`: In this case, we can see that the network bridge implements the `Driver`
    bridge. Although this may seem obvious, it''s important to call out that all network
    functionality, including native functionality, is implemented through drivers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver`：在这种情况下，我们可以看到网络桥实现了`Driver`桥。尽管这似乎是显而易见的，但重要的是要指出，所有网络功能，包括本机功能，都是通过驱动程序实现的。'
- en: '`Subnet`: In this case, the `subnet` is the default we expect from the `docker0`
    bridge, `172.17.0.1/16`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`子网`：在这种情况下，`子网`是我们从`docker0`桥预期的默认值，`172.17.0.1/16`。'
- en: '`bridge.default_bridge`: A value of `true` implies that Docker will provision
    all containers to this bridge unless told otherwise. That is, if you start a container
    without specifying a network (`--net`), the container will end up on this bridge.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge.default_bridge`：值为`true`意味着Docker将为所有容器提供此桥，除非另有规定。也就是说，如果您启动一个没有指定网络（`--net`）的容器，该容器将最终出现在此桥上。'
- en: '`bridge.host_binding_ipv4`: By default, this will be set to `0.0.0.0` or all
    interfaces. As we saw in [Chapter 2](ch02.html "Chapter 2. Configuring and Monitoring
    Docker Networks"), *Configuring and Monitoring Docker Networks*, we can tell Docker
    at a service level to limit this by passing the `--ip` flag as a Docker option
    to the service.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge.host_binding_ipv4`：默认情况下，这将设置为`0.0.0.0`或所有接口。正如我们在[第2章](ch02.html "第2章
    配置和监控Docker网络")中所看到的，*配置和监控Docker网络*，我们可以通过将`--ip`标志作为Docker选项传递给服务，告诉Docker在服务级别限制这一点。'
- en: '`bridge.name`: As we suspected, this network represents the `docker0` bridge.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge.name`：正如我们所怀疑的，这个网络代表`docker0`桥。'
- en: '`driver.mtu`: By default, this will be set to `1500`. As we saw in [Chapter
    2](ch02.html "Chapter 2. Configuring and Monitoring Docker Networks"), *Configuring
    and Monitoring Docker Networks*, we can tell Docker at a service level to change
    **MTU** (**Maximum Transmission Unit**) by passing the `--mtu` flag as a Docker
    option to the service.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver.mtu`：默认情况下，这将设置为`1500`。正如我们在[第2章](ch02.html "第2章 配置和监控Docker网络")中所看到的，*配置和监控Docker网络*，我们可以通过将`--mtu`标志作为Docker选项传递给服务，告诉Docker在服务级别更改**MTU**（最大传输单元）。'
- en: None
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无
- en: 'The `none` network represents just what it says, nothing. The `none` mode is
    used when you wish to define a container with absolutely no network definition.
    After inspecting the network, we can see that there isn''t much there as far as
    a network definition is concerned:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`网络表示的就是它所说的，什么也没有。当您希望定义一个绝对没有网络定义的容器时，可以使用`none`模式。检查网络后，我们可以看到就网络定义而言，没有太多内容：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, `Driver` is represented by `null`, implying that this isn't
    a `Driver` for this network at all. There are a few use cases for the `none` network
    mode and we'll cover those later on when we talk about connecting and disconnecting
    containers to defined networks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Driver`由`null`表示，这意味着这根本不是这个网络的`Driver`。`none`网络模式有一些用例，我们将在稍后讨论连接和断开连接到定义网络的容器时进行介绍。
- en: Host
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机
- en: 'The *host* network represents the host mode we saw in [Chapter 2](ch02.html
    "Chapter 2. Configuring and Monitoring Docker Networks"), *Configuring and Monitoring
    Docker Networks*, where a container was bound directly to the Docker host''s own
    network interfaces. By taking a closer look, we can see that much like the `none`
    network, there isn''t much defined for this network:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*host*网络代表我们在[第2章](ch02.html "第2章。配置和监视Docker网络")中看到的主机模式，*配置和监视Docker网络*，在那里容器直接绑定到Docker主机自己的网络接口。通过仔细观察，我们可以看到，与`none`网络一样，对于这个网络并没有太多定义。'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although the host network certainly does more than the `none` mode, it wouldn't
    appear so from inspecting its definition. The key difference here is that this
    network uses the host `Driver`. As this network type uses the existing host's
    network interfaces, we don't need to define any of that as part of the network.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管主机网络肯定比`none`模式做得更多，但从检查其定义来看，似乎并非如此。这里的关键区别在于这个网络使用主机`Driver`。由于这种网络类型使用现有主机的网络接口，我们不需要将其作为网络的一部分进行定义。
- en: 'When using the `network ls` command, you can pass additional parameters to
    further filter or alter the output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`network ls`命令时，可以传递附加参数以进一步过滤或更改输出：
- en: '`--quiet` (`-q`): This only shows the numeric network IDs'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--quiet`（`-q`）：仅显示数字网络ID'
- en: '`--no-trunc`: This prevents the command from automatically truncating the network
    ID in the output that allows you to see the full network ID'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-trunc`：这可以防止命令自动截断输出中的网络ID，从而使您可以看到完整的网络ID'
- en: '`--filter` (`-f`): This filters the output based on either network ID, network
    name, or by network definition (built-in or user-defined)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--filter`（`-f`）：根据网络ID、网络名称或网络定义（内置或用户定义）对输出进行过滤'
- en: 'For example, we can show all user-defined networks with this filter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下过滤器显示所有用户定义的网络：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or we can show all networks with a network ID that contains `158`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以显示所有包含`158`的网络ID的网络：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating user-defined networks
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户定义的网络
- en: As we've seen so far, there are at least two different network drivers that
    are inherently part of every Docker installation, bridge, and host. In addition
    to those two, while not defined initially because of prerequisites, there is another
    `Driver` overlay that is available out-of-the-box as well. Later recipes in this
    chapter will cover specifics regarding the bridge and overlay drivers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，每个Docker安装都有至少两种不同的网络驱动程序，即桥接和主机。除了这两种之外，由于先决条件而没有最初定义，还有另一个`Driver`叠加，也可以立即使用。本章的后续内容将涵盖有关桥接和叠加驱动程序的具体信息。
- en: Because it wouldn't make sense to create another iteration of the host network
    using the host `Driver`, the built-in user-defined networks are limited to the
    bridge and overlay drivers. In this recipe, we'll show you the basics of creating
    a user-defined network as well as options that are relevant to the `network create`
    and `network rm` Docker subcommands.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用主机`Driver`创建另一个主机网络的迭代没有意义，所以内置的用户定义网络仅限于桥接和叠加驱动程序。在本教程中，我们将向您展示创建用户定义网络的基础知识，以及与`network
    create`和`network rm` Docker子命令相关的选项。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `docker network` subcommand was introduced in Docker 1.9, so you'll need
    a Docker host running at least that version. In our examples, we'll be using Docker
    version 1.12\. You'll also want to have a good understanding of your current network
    layout, so you can follow along as we inspect the current configuration. It is
    assumed that each Docker host is in its native configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network`子命令是在Docker 1.9中引入的，因此您需要运行至少该版本的Docker主机。在我们的示例中，我们将使用Docker版本1.12。您还需要对当前网络布局有很好的了解，以便在我们检查当前配置时能够跟随。假定每个Docker主机都处于其本机配置中。'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Warning: Creating network interfaces on a Linux host must be done with caution.
    Docker will do its best to prevent you from shooting yourself in the foot, but
    you must have a good idea of your network topology before defining new networks
    on a Docker host. A common mistake to avoid is to define a new network that overlaps
    with other subnets in your network. In the case of remote administration, this
    can cause host and container connectivity issues.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在Linux主机上创建网络接口必须谨慎进行。Docker将尽力防止您自找麻烦，但在定义Docker主机上的新网络之前，您必须对网络拓扑有一个很好的了解。要避免的一个常见错误是定义与网络中其他子网重叠的新网络。在远程管理的情况下，这可能会导致主机和容器之间的连接问题。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Networks are defined by using the `network create` subcommand, which has the
    following options:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是通过使用`network create`子命令来定义的，该命令具有以下选项：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s spend a little time discussing what each of these options means:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间讨论每个选项的含义：
- en: '`aux-address`: This allows you to define IP addresses that Docker should not
    assign to containers when they are spawned. These are the equivalent of IP reservations
    in a DHCP scope.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aux-address`：这允许您定义Docker在生成容器时不应分配的IP地址。这相当于DHCP范围中的IP保留。'
- en: '`Driver`: Which `Driver` the network implements. The built-in options include
    bridge and overlay, but you can also use third-party drivers as well.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver`：网络实现的`Driver`。内置选项包括bridge和overlay，但您也可以使用第三方驱动程序。'
- en: '`gateway`: The Gateway for the network. If not specified, Docker will assume
    that it is the first available IP address in the subnet.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateway`：网络的网关。如果未指定，Docker将假定它是子网中的第一个可用IP地址。'
- en: '`internal`: This option allows you to isolate networks and is covered in greater
    detail later in this chapter.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal`：此选项允许您隔离网络，并将在本章后面更详细地介绍。'
- en: '`ip-range`: This allows you to specify a smaller subnet of the defined network
    subnet to use for container addressing.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip-range`：这允许您指定用于容器寻址的已定义网络子网的较小子网。'
- en: '`ipam-driver`: In addition to consuming third-party network drivers, you can
    also leverage third-party IPAM drivers. For the purposes of this book, we''ll
    be focusing mostly on the default or built-in IPAM `Driver`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipam-driver`：除了使用第三方网络驱动程序外，您还可以利用第三方IPAM驱动程序。对于本书的目的，我们将主要关注默认或内置的IPAM`Driver`。'
- en: '`ipv6`: This enables IPv6 networking on the network.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipv6`：这在网络上启用IPv6网络。'
- en: '`label`: This allows you to specify additional information about the network
    that will be stored as metadata.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这允许您指定有关网络的其他信息，这些信息将被存储为元数据。'
- en: '`ipam-opt`: This allows you to specify options to pass to the IPAM `Driver`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipam-opt`：这允许您指定要传递给IPAM`Driver`的选项。'
- en: '`opt`: This allows you to specify options that can be passed to the network
    `Driver`. Specific options for each built-in `Driver` will be discussed in the
    relevant recipes.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt`：这允许您指定可以传递给网络`Driver`的选项。将在相关的配方中讨论每个内置`Driver`的特定选项。'
- en: '`subnet`: This defines the subnet associated with the network type you are
    creating.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet`：这定义了与您正在创建的网络类型相关联的子网。'
- en: 'You might notice some overlap here between some of the settings we can define
    at a service level for Docker networking and the user-defined options listed in
    the preceding term list. Examining the options, you may be tempted to compare
    the following configuration flags:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到这里一些重叠，即Docker网络的服务级别可以定义的一些设置与前面列出的用户定义选项之间。检查这些选项时，您可能会想要比较以下配置标志：
- en: '![How to do it…](graphics/B05453_03_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](graphics/B05453_03_01.jpg)'
- en: While these settings are largely equivalent, they are not all identical. The
    only two that act in the exact same fashion are `--fixed-cidr` and `ip-range`.
    Both of those options, define a smaller subnetwork of the larger master network
    to be used for container IP addressing. The other two options are similar, but
    not identical.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些设置在很大程度上是等效的，但它们并不完全相同。唯一完全相同的是`--fixed-cidr`和`ip-range`。这两个选项都定义了一个较大主网络的较小子网络，用于容器IP寻址。另外两个选项是相似的，但并不相同。
- en: In the case of the service options, `--bip` applies to the `docker0` bridge
    and `--default-gateway` applies to the containers themselves. On the user-defined
    side, the `--subnet` and the `--gateway` option, apply directly to the network
    construct being defined (in this comparison, a bridge). Recall that the `--bip`
    option expects to receive an IP address in a network, not the network itself.
    Having the bridge IP defined in this manner covers both the subnet as well as
    the gateway, which are defined separately when defining a user-defined network.
    That being said, the service definition is a little more flexible in that it allows
    you to define both the interface of the bridge as well as the gateway assigned
    to containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务选项的情况下，`--bip`适用于`docker0`桥接口，`--default-gateway`适用于容器本身。在用户定义方面，`--subnet`和`--gateway`选项直接适用于正在定义的网络构造（在此比较中是一个桥接）。请记住，`--bip`选项期望接收一个网络中的IP地址，而不是网络本身。以这种方式定义桥接IP地址既覆盖了子网，也覆盖了网关，这在定义用户定义网络时是分开定义的。也就是说，服务定义在这方面更加灵活，因为它允许您定义桥接的接口以及分配给容器的网关。
- en: 'Keeping with the theme of having sane defaults, none of these options are actually
    required to create a user-defined network. You can create your first user-defined
    network by just giving it a name:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 保持合理的默认设置主题，实际上并不需要这些选项来创建用户定义网络。您可以通过只给它一个名称来创建您的第一个用户定义网络：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon inspection, we can see what Docker uses for defaults:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经过检查，我们可以看到Docker使用的默认设置：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Docker assumes that if you don't specify a `Driver` that you'd like to create
    a network using the bridge `Driver`. It also automatically chooses and assigns
    a subnet for this bridge if you don't define one when you create the network.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker假设如果您没有指定`Driver`，那么您想要使用桥接`Driver`创建网络。如果您在创建网络时没有定义子网，它还会自动选择并分配一个子网给这个桥接。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is always advisable that you specify subnets for network, you create. As
    we'll see later on, not all network topologies rely on hiding the container networks
    behind the host interfaces. In those cases, defining a routable non-overlapping
    subnet will be a necessity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建网络时，建议您为网络指定子网。正如我们将在后面看到的，不是所有的网络拓扑都依赖于将容器网络隐藏在主机接口后面。在这些情况下，定义一个可路由的不重叠子网将是必要的。
- en: It also automatically selects the first useable IP address for the Subnet as
    the gateway. Because we didn't define any options specific to the `Driver`, the
    network has none but again, there are defaults that are used in this case. Those
    will be discussed in the recipes related to each specific `Driver`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会自动选择子网的第一个可用IP地址作为网关。因为我们没有为`Driver`定义任何选项，所以网络没有，但在这种情况下会使用默认值。这些将在与每个特定`Driver`相关的配方中讨论。
- en: 'Networks that are empty, that is, they have no active endpoints, may be deleted
    using the `network rm` command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 空的网络，即没有活动端点的网络，可以使用 `network rm` 命令删除：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One other item that's worth noting here is that Docker makes user-defined networks
    persistent. In most cases, any Linux network constructs that are manually defined
    are lost when the system reboots. Docker records the network configuration and
    takes care of replaying it back when the Docker service restarts. This is a huge
    advantage to building the networks through Docker rather than on your own.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的另一项是，Docker 使用户定义的网络持久化。在大多数情况下，手动定义的任何 Linux 网络结构在系统重新启动时都会丢失。Docker
    记录网络配置并在 Docker 服务重新启动时负责回放。这对于通过 Docker 而不是自己构建网络来说是一个巨大的优势。
- en: Connecting containers to networks
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接容器到网络
- en: While having the ability to create your own networks is a huge leap forward,
    it means nothing without a means to connect containers to it. In previous versions
    of Docker, this was traditionally done during container runtime by passing the
    `--net` flag specifying which network the container should use. While this is
    certainly still the case, the `docker network` subcommand also allows you to connect
    and disconnect running containers to existing networks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有创建自己网络的能力是一个巨大的进步，但如果没有一种方法将容器连接到网络，这就毫无意义。在以前的 Docker 版本中，这通常是在容器运行时通过传递
    `--net` 标志来完成的，指定容器应该使用哪个网络。虽然这仍然是这种情况，但 `docker network` 子命令也允许您将正在运行的容器连接到现有网络或从现有网络断开连接。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `docker network` subcommand was introduced in Docker 1.9, so you'll need
    a Docker host running at least that version. In our examples, we'll be using Docker
    version 1.12\. You'll also want to have a good understanding of your current network
    layout, so you can follow along as we inspect the current configuration. It is
    assumed that each Docker host is in its native configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network` 子命令是在 Docker 1.9 中引入的，因此您需要运行至少该版本的 Docker 主机。在我们的示例中，我们将使用
    Docker 版本 1.12。您还需要对当前网络布局有很好的了解，这样您就可以在我们检查当前配置时跟上。假设每个 Docker 主机都处于其本机配置中。'
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Connecting and disconnecting containers is done via the `network connect` and
    `network disconnect` subcommands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `network connect` 和 `network disconnect` 子命令来连接和断开连接容器：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s review what our options are for connecting containers to networks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下连接容器到网络的选项：
- en: '**Alias**: This allows you to define an alias for container name resolution
    in the network you are connecting the container to. We''ll talk more about this
    in [Chapter 5](ch05.html "Chapter 5. Container Linking and Docker DNS"), *Container
    Linking and Docker DNS*, where we discuss DNS and linking.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别名**：这允许您在连接容器的网络中为容器名称解析定义别名。我们将在[第 5 章](ch05.html "第 5 章。容器链接和 Docker DNS")中更多地讨论这一点，*容器链接和
    Docker DNS*，在那里我们将讨论 DNS 和链接。'
- en: '**IP**: This defines an IP address to be used for the container. This will
    work so long as the IP address is not currently in use. Once allocated, it will
    remain reserved as long as the container is running or paused. Stopping the container
    will remove the reservation.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP**：这定义了要用于容器的 IP 地址。只要 IP 地址当前未被使用，它就可以工作。一旦分配，只要容器正在运行或暂停，它就会保留。停止容器将删除保留。'
- en: '**IP6**: This defines an IPv6 address to be used for the container. The same
    allocation and reservation requirements that applied to the IPv4 address also
    apply to the IPv6 address.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP6**：这定义了要用于容器的 IPv6 地址。适用于 IPv4 地址的相同分配和保留要求也适用于 IPv6 地址。'
- en: '**Link**: This allows you to specify a link to another container. We''ll talk
    more about this in [Chapter 5](ch05.html "Chapter 5. Container Linking and Docker
    DNS"), *Container Linking and Docker DNS*, where we discuss DNS and linking.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Link**：这允许您指定与另一个容器的链接。我们将在[第5章](ch05.html "第5章 容器链接和Docker DNS")中更多地讨论这个问题，*容器链接和Docker
    DNS*，在那里我们将讨论DNS和链接。'
- en: 'Once a `network connect` request is sent, Docker handles all the configuration
    required in order for the container to start using the new interface. Let''s take
    a look at a quick example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发送了`network connect`请求，Docker会处理所有所需的配置，以便容器开始使用新的接口。让我们来看一个快速的例子：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the above output we started a simple container without specifying any network-related
    configuration. The result is the container being mapped to the `docker0` bridge.
    Now let''s try connecting this container to the network we created in the previous
    recipe, `mynetwork`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，我们启动了一个简单的容器，没有指定任何与网络相关的配置。结果是容器被映射到了`docker0`桥接。现在让我们尝试将这个容器连接到我们在上一个示例中创建的网络`mynetwork`：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the container now has an IP interface on the network `mynetwork`.
    If we now once again inspect the network, we should see a container association:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，容器现在在`mynetwork`网络上有一个IP接口。如果我们现在再次检查网络，我们应该看到一个容器关联：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Networks can be disconnected just as easily. For instance, we can now remove
    the container from the `docker0` bridge by removing it from the bridge network:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 网络也可以很容易地断开连接。例如，我们现在可以通过将容器从桥接网络中移除来从`docker0`桥接中移除容器：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s interesting to point out that Docker also takes care of ensuring container
    connectivity when you connect and disconnect networks from the containers. For
    instance, before disconnecting the container from the bridge network, the default
    Gateway of the container was still out of the `docker0` bridge:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Docker还负责确保在连接和断开容器与网络时容器的连通性。例如，在将容器从桥接网络断开连接之前，容器的默认网关仍然在`docker0`桥接之外：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This makes sense as we wouldn''t want to interrupt container connectivity while
    connecting the container to a new network. However, once we remove the network
    hosting the default gateway by disconnecting the interface to the bridge network,
    we see that Docker updates the default gateway to the remaining interface out
    of the `mynetwork` bridge:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，因为我们不希望在将容器连接到新网络时中断容器的连接。然而，一旦我们通过断开与桥接网络的接口来移除托管默认网关的网络，我们会发现Docker会将默认网关更新为`mynetwork`桥接的剩余接口：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This ensures that the container has connectivity regardless of which network
    it's connected to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了无论连接到哪个网络，容器都具有连通性。
- en: 'Finally, I want to point out an interesting aspect of the `none` network type
    when you are connecting and disconnecting containers to networks. As I mentioned
    earlier, the `none` network type tells Docker to not assign the container to any
    networks. This however, does not mean just initially, it''s a configuration state
    telling Docker that the container should not have any networks associated with
    it. For instance, assume we start the following container with a network of `none`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想指出连接和断开容器与网络时`none`网络类型的一个有趣方面。正如我之前提到的，`none`网络类型告诉Docker不要将容器分配给任何网络。然而，这并不仅仅意味着最初，它是一个配置状态，告诉Docker容器不应该与任何网络关联。例如，假设我们使用`none`网络启动以下容器：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the container doesn''t have any network interfaces besides
    its loopback. Now, let''s try and connect this container to a new network:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了回环接口之外，容器没有任何网络接口。现在，让我们尝试将这个容器连接到一个新的网络：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Docker is telling us that this container was defined to have no networks and
    is preventing us from connecting the container to any network. If we inspect the
    `none` network, we can see that this container is in fact attached to it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Docker告诉我们，这个容器被定义为没有网络，并且阻止我们将容器连接到任何网络。如果我们检查“none”网络，我们可以看到这个容器实际上附加到它上面：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to connect this container to a new network, we first have to disconnect
    it from the `none` network:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个容器连接到一个新的网络，我们首先必须将其与“none”网络断开连接：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you disconnect it from the `none` network, you are free to connect it to
    any other defined network.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将其与“none”网络断开连接，您就可以自由地将其连接到任何其他定义的网络。
- en: Defining a user-defined bridge network
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户定义的桥接网络
- en: Through the use of the bridge `Driver`, users can provision custom bridges to
    connect to containers. You can create as many as you like with the only real limitation
    being that you must use unique IP addressing on each bridge. That is, you can't
    overlap with existing subnets that are already defined on other network interfaces.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用桥接`Driver`，用户可以提供自定义桥接以连接到容器。您可以创建尽可能多的桥接，唯一的限制是您必须在每个桥接上使用唯一的IP地址。也就是说，您不能与已在其他网络接口上定义的现有子网重叠。
- en: In this recipe, we'll learn how to define a user-defined bridge as well as some
    of the unique options available to you during its creation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何定义用户定义的桥接，以及在创建过程中可用的一些独特选项。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `docker network` subcommand was introduced in Docker 1.9, so you'll need
    a Docker host running at least that version. In our examples, we'll be using Docker
    version 1.12\. You'll also want to have a good understanding of your current network
    layout, so you can follow along as we inspect the current configuration. It is
    assumed that each Docker host is in its native configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network`子命令是在Docker 1.9中引入的，因此您需要运行至少该版本的Docker主机。在我们的示例中，我们将使用Docker版本1.12。您还需要对当前网络布局有很好的了解，这样您就可以跟着我们检查当前的配置。假设每个Docker主机都处于其本机配置中。'
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the previous recipe, we talked about the process for defining a user-defined
    network. While the options discussed there are relevant to all network types,
    we can pass other options to the `Driver` our network implements by passing the
    `--opt` flag. Let''s quickly review the options that are available with the bridge
    `Driver`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们讨论了定义用户定义网络的过程。虽然那里讨论的选项适用于所有网络类型，但我们可以通过传递`--opt`标志将其他选项传递给我们的网络实现的`Driver`。让我们快速回顾一下与桥接`Driver`可用的选项：
- en: '`com.docker.network.bridge.name`: This is the name you wish to give to the
    bridge.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.name`：这是您希望给桥接的名称。'
- en: '`com.docker.network.bridge.enable_ip_masquerade`: This instructs the Docker
    host to hide or masquerade all containers in this network behind the Docker host''s
    interfaces if the container attempts to route off the local host .'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.enable_ip_masquerade`：这指示Docker主机在容器尝试路由离开本地主机时，隐藏或伪装该网络中所有容器在Docker主机接口后面。'
- en: '`com.docker.network.bridge.enable_icc`: This turns on or off **Inter-Container
    Connectivity** (**ICC**) mode for the bridge. This feature is covered in greater
    detail in [Chapter 6](ch06.html "Chapter 6. Securing Container Networks"), *Securing
    Container Networks*.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.enable_icc`：这为桥接打开或关闭**容器间连接**（**ICC**）模式。这个功能在[第6章](ch06.html
    "第6章。保护容器网络") *保护容器网络*中有更详细的介绍。'
- en: '`com.docker.network.bridge.host_binding_ipv4`: This defines the host interface
    that should be used for port binding.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.bridge.host_binding_ipv4`：这定义了应该用于端口绑定的主机接口。'
- en: '`com.docker.network.driver.mtu`: This sets MTU for containers attached to this
    bridge.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.docker.network.driver.mtu`：这为连接到这个桥接的容器设置MTU。'
- en: These options can be directly compared with the options we define under the
    Docker service to make changes to the default `docker0` bridge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以直接与我们在Docker服务下定义的选项进行比较，以更改默认的`docker0`桥。
- en: '![How to do it…](graphics/B05453_03_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: 如何做到这一点...
- en: The preceding table compares the service-level settings that impact the `docker0`
    bridge to the settings available to you as part of defining a user-defined bridge
    network. It also lists the default setting used if the setting is not specified
    in either case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上表比较了影响`docker0`桥的服务级设置与您在定义用户定义的桥接网络时可用的设置。它还列出了在任一情况下如果未指定设置，则使用的默认设置。
- en: 'Between the Driver-specific options and the generic options that are part of
    the `network create` subcommand, we have quite a bit of flexibility when defining
    container networks. Let''s walk through a couple of quick examples of building
    user-defined bridges:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义容器网络时，通过驱动程序特定选项和`network create`子命令的通用选项，我们在定义容器网络时具有相当大的灵活性。让我们通过一些快速示例来构建用户定义的桥接。
- en: Example 1
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding `network create` statement defines a network with the following
    characteristics:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`network create`语句定义了具有以下特征的网络：
- en: A user-defined network of type `bridge`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`bridge`的用户定义网络
- en: A `subnet` of `10.15.20.0/24`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`子网`为`10.15.20.0/24`
- en: A `gateway` or bridge IP interface of `10.15.20.1`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`网关`或桥接IP接口为`10.15.20.1`
- en: 'Two reserved addresses: `10.15.20.2` and `10.15.20.3`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个保留地址：`10.15.20.2`和`10.15.20.3`
- en: A port binding interface of `10.10.10.101` on the host
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机上的端口绑定接口为`10.10.10.101`
- en: A Linux interface name of `linuxbridge1`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`linuxbridge1`的Linux接口名称
- en: A Docker network name of `testbridge1`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`testbridge1`的Docker网络
- en: Keep in mind that some of these options are included for example purpose only.
    Practically, we don't need to define the `Gateway` for the network `Driver` in
    the preceding example since the defaults will cover us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，其中一些选项仅用于示例目的。实际上，在前面的示例中，我们不需要为网络驱动程序定义“网关”，因为默认设置将覆盖我们。
- en: 'If we create the earlier-mentioned network upon inspection, we should see the
    attributes we defined:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在检查后创建了前面提到的网络，我们应该看到我们定义的属性：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The options you pass to the network are not validated. That is, if you misspell
    `host_binding` as `host_bniding`, Docker will still let you create the network,
    and the option will get defined; however, it won't work.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给网络的选项不会得到验证。也就是说，如果您将`host_binding`拼错为`host_bniding`，Docker仍然会让您创建网络，并且该选项将被定义；但是，它不会起作用。
- en: Example 2
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例2
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding `network create` statement defines a network with the following
    characteristics:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`network create`语句定义了具有以下特征的网络：
- en: A user-defined network of type `bridge`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`bridge`的用户定义网络
- en: A `subnet` of `192.168.50.0/24`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`子网`为`192.168.50.0/24`
- en: A `gateway` or bridge IP interface of `192.168.50.1`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`网关`或桥接IP接口为`192.168.50.1`
- en: A container network range of `192.168.50.128/25`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容器网络范围为`192.168.50.128/25`
- en: IP masquerade on the host turned off
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机上的IP伪装关闭
- en: A Docker network named `testbridge2`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`testbridge2`的Docker网络
- en: 'As stated in Example 1, we don''t need to define the driver type if we''re
    creating a bridge network. In addition, if we''re OK with the gateway being the
    first available IP in the container defined subnet, we can exclude that from the
    definition as well. Inspecting this network after creation should show us results
    similar to this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例1所述，如果我们创建桥接网络，则无需定义驱动程序类型。此外，如果我们可以接受网关是容器定义子网中的第一个可用IP，我们也可以将其从定义中排除。创建后检查此网络应该显示类似于这样的结果：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a user-defined overlay network
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户定义的覆盖网络
- en: While the ability to create your own bridge is certainly appealing, your scope
    is still limited to that of a single Docker host. The overlay network `Driver`
    aims to solve that by allowing you to extend one or more subnets across multiple
    Docker hosts using an overlay network. Overlay networks are a means to build isolated
    networks on top of existing networks. In this case, the existing network provides
    transport for the overlay and is often named the **underlay network**. The overlay
    `Driver` implements what Docker refers to as multi-host networking.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建自己的桥接能力确实很吸引人，但你的范围仍然局限于单个Docker主机。覆盖网络`Driver`旨在通过允许您使用覆盖网络在多个Docker主机上扩展一个或多个子网来解决这个问题。覆盖网络是在现有网络之上构建隔离网络的一种手段。在这种情况下，现有网络为覆盖提供传输，并且通常被称为**底层网络**。覆盖`Driver`实现了Docker所谓的多主机网络。
- en: In this recipe, we'll learn how to configure the prerequisites for the overlay
    `Driver` as well as deploy and validate overlay-based networks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何配置覆盖`Driver`的先决条件，以及部署和验证基于覆盖的网络。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Throughout the following examples, we''ll be using this lab topology:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用这个实验室拓扑：
- en: '![Getting ready](graphics/B05453_03_03.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](graphics/B05453_03_03.jpg)'
- en: 'The topology consists of a total of four Docker host''s two of which are in
    the `10.10.10.0/24` subnet and the other two are in the `192.168.50.0/24` subnet.
    As we walk through this recipe, the hosts shown in the diagram will play the following
    roles:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑结构由总共四个Docker主机组成，其中两个位于`10.10.10.0/24`子网，另外两个位于`192.168.50.0/24`子网。当我们按照这个示例进行操作时，图中显示的主机将扮演以下角色：
- en: '`docker1`: Docker host serving a Consul **key-value store**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker1`：作为Consul**键值存储**提供服务的Docker主机'
- en: '`docker2`: Docker host participating in overlay networks'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker2`：参与覆盖网络的Docker主机'
- en: '`docker3`: Docker host participating in overlay networks'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker3`：参与覆盖网络的Docker主机'
- en: '`docker4`: Docker host participating in overlay networks'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker4`：参与覆盖网络的Docker主机'
- en: As mentioned earlier, the overlay `Driver` isn't instantiated by default. This
    is because there are several prerequisites required for the overlay `Driver` to
    work.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，覆盖`Driver`不是默认实例化的。这是因为覆盖`Driver`需要满足一些先决条件才能工作。
- en: A key-value store
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个键值存储
- en: Since we're now dealing with a distributed system, Docker needs a place to store
    information about the overlay network. To do this, Docker uses a key-value store
    and supports Consul, etcd, and ZooKeeper for this purpose. It will store information
    that requires consistency across all the nodes such as IP address allocations,
    network IDs, and container endpoints. In our examples, we'll be deploying Consul.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处理的是一个分布式系统，Docker需要一个地方来存储关于覆盖网络的信息。为此，Docker使用一个键值存储，并支持Consul、etcd和ZooKeeper。它将存储需要在所有节点之间保持一致性的信息，如IP地址分配、网络ID和容器端点。在我们的示例中，我们将部署Consul。
- en: 'As luck would have it, Consul can be deployed as a Docker container itself:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 侥幸的是，Consul本身可以作为一个Docker容器部署：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running this image will start a single instance of the Consul key-value store.
    A single instance is all we need for basic lab testing. In our case, we'll start
    this image on the host `docker1`. All the Docker hosts that participate in the
    overlay must have reachability to the key-value store across the network.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个镜像将启动一个Consul键值存储的单个实例。一个单个实例就足够用于基本的实验测试。在我们的情况下，我们将在主机`docker1`上启动这个镜像。所有参与覆盖的Docker主机必须能够通过网络访问键值存储。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Running Consul with a single cluster member should only be done for demonstration
    purposes. You need at least three cluster members to have any sort of failure
    tolerance. Make sure that you research the key-value store you decide to deploy
    and understand its configuration and failure tolerances.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在演示目的下才应该使用单个集群成员运行Consul。您至少需要三个集群成员才能具有任何故障容忍性。确保您研究并了解您决定部署的键值存储的配置和故障容忍性。
- en: Linux kernel version of 3.16
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux内核版本为3.16
- en: 'Your Linux kernel version needs to be 3.16 or greater. You can check your current
    kernel version with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Linux内核版本需要是3.16或更高。您可以使用以下命令检查当前的内核版本：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open ports
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开端口
- en: 'Docker hosts must be able to talk to each other using the following ports:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Docker主机必须能够使用以下端口相互通信：
- en: TCP and UDP `7946` (Serf)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP和UDP `7946`（Serf）
- en: UDP `4789` (VXLAN)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP `4789`（VXLAN）
- en: TCP `8500` (Consul key-value store)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP `8500`（Consul键值存储）
- en: Docker service configuration options
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker服务配置选项
- en: 'All the hosts that are participating in the overlay need access to the key-value
    store. To tell them where it is, we define a couple of service-level options:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 参与覆盖的所有主机都需要访问键值存储。为了告诉它们在哪里，我们定义了一些服务级选项：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The cluster-store variable defines where the key-value store is. In our case,
    it's a container running on the host `docker1` (`10.10.10.101`). We also need
    to enable the `cluster-advertise` feature and pass it an interface and port. This
    configuration relates more to using a Swarm cluster, but the flag is also used
    as part of enabling multi-host networking. That being said, you need to pass it
    a valid interface and a port. In this case, we use the host physical interface
    and port `0`. In our example, we'll add these options to hosts `docker2`, `docker3`,
    and `docker4` as those are the hosts we'll have participating in the overlay network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: cluster-store变量定义了键值存储的位置。在我们的情况下，它是在主机`docker1`（`10.10.10.101`）上运行的容器。我们还需要启用`cluster-advertise`功能并传递一个接口和端口。这个配置更多地涉及使用Swarm集群，但该标志也作为启用多主机网络的一部分。也就是说，您需要传递一个有效的接口和端口。在这种情况下，我们使用主机物理接口和端口`0`。在我们的示例中，我们将这些选项添加到主机`docker2`，`docker3`和`docker4`上，因为这些是参与覆盖网络的主机。
- en: 'After adding the option, reload the `systemd` configuration and restart the
    Docker service. You can verify that Docker has accepted the command by checking
    the output of the `docker info` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 添加选项后，重新加载`systemd`配置并重新启动Docker服务。您可以通过检查`docker info`命令的输出来验证Docker是否接受了该命令：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now that we''ve met the prerequisites for using the overlay `Driver`, we can
    deploy our first user-defined overlay network. Defining a user-defined overlay
    network follows much the same process as that of defining a user-defined bridge
    network. For instance, let''s configure our first overlay network using this command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经满足了使用覆盖`Driver`的先决条件，我们可以部署我们的第一个用户定义的覆盖网络。定义用户定义的覆盖网络遵循与定义用户定义的桥网络相同的过程。例如，让我们使用以下命令配置我们的第一个覆盖网络：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Much like with user-defined bridges, we don't have to enter much information
    to create our first overlay network. In fact, the only difference here is that
    we have to specify the `Driver` as type overlay because the default `Driver` type
    is bridge. Once we enter the command, we should be able to see the network defined
    on any node participating in overlay networking.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用户定义的桥一样，我们不必输入太多信息来创建我们的第一个覆盖网络。事实上，唯一的区别在于我们必须将`Driver`指定为覆盖类型，因为默认的`Driver`类型是桥接。一旦我们输入命令，我们应该能够在参与覆盖网络的任何节点上看到定义的网络。
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The host `docker2` pushes the network configuration into the store when it creates
    the network. Now all the hosts can see the new network since they're all reading
    and writing data to and from the same key-value store. Once the network is created,
    any node participating in the overlay (configured with the correct service-level
    options) can view, connect containers to, and delete the overlay network.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机`docker2`创建网络时，它将网络配置推送到存储中。现在所有主机都可以看到新的网络，因为它们都在读写来自同一个键值存储的数据。一旦网络创建完成，任何参与覆盖的节点（配置了正确的服务级选项）都可以查看、连接容器到并删除覆盖网络。
- en: 'For instance, if we go to host `docker4`, we can delete the network that we
    created on host `docker2` initially:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们去到主机`docker4`，我们可以删除最初在主机`docker2`上创建的网络：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's now define a new overlay with a little more configuration. Unlike the
    user-defined bridge, the overlay `Driver` does not currently support any additional
    options being passed to it during creation with the `--opt` flag. That being said,
    the only options that we can configure on overlay type networks are those that
    are part of the `network create` subcommand.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用更多的配置来定义一个新的覆盖。与用户定义的桥接不同，覆盖`Driver`目前不支持在创建时使用`--opt`标志传递任何附加选项。也就是说，我们可以在覆盖类型网络上配置的唯一选项是`network
    create`子命令的一部分。
- en: '`aux-address`: As with the user-defined bridge, this command allows you to
    define IP addresses that Docker should not assign to containers when they are
    spawned.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aux-address`：与用户定义的桥接一样，这个命令允许您定义Docker在生成容器时不应分配的IP地址。'
- en: '`gateway`: Although you can define a gateway for the network, and if you don''t,
    Docker will do it for you, this isn''t actually used in overlay networks. That
    is, there is no interface that this IP address gets assigned to.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateway`：虽然您可以为网络定义一个网关，如果您不这样做，Docker会为您做这个，但实际上在覆盖网络中并不使用这个。也就是说，没有接口会被分配这个IP地址。'
- en: '`internal`: This option allows you to isolate networks and is covered in greater
    detail later in this chapter.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal`：此选项允许您隔离网络，并在本章后面更详细地介绍。'
- en: '`ip-range`: Allows you to specify a smaller subnet of the defined network subnet
    to use for container addressing.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip-range`：允许您指定一个较小的子网，用于容器寻址。'
- en: '`ipam-driver`: In addition to consuming third-party network drivers, you can
    also leverage third-party IPAM drivers. For the purposes of this book we''ll be
    focusing mostly on the default or built-in IPAM driver.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipam-driver`：除了使用第三方网络驱动程序，您还可以利用第三方IPAM驱动程序。在本书中，我们将主要关注默认或内置的IPAM驱动程序。'
- en: '`ipam-opt`: This allows you to specify options to pass to the IPAM driver.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipam-opt`：这允许您指定要传递给IPAM驱动程序的选项。'
- en: '`subnet`: This defines the subnet associated with the network type you are
    creating.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet`：这定义了与您创建的网络类型相关联的子网。'
- en: 'Let''s redefine the network `myoverlay` on the host `docker4`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在主机`docker4`上重新定义网络`myoverlay`：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, we define the network with the following attributes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用以下属性定义网络：
- en: A `subnet` of `172.16.16.0/24`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`subnet`为`172.16.16.0/24`
- en: A reserved or auxiliary address of `172.16.16.2` (Recall that Docker will allocate
    a Gateway IP to be the first IP in the subnet despite the fact that it's not actually
    being used. In this case, this means that `.1` and `.2` are technically reserved
    at this point.)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个保留或辅助地址为`172.16.16.2`（请记住，Docker将分配一个网关IP作为子网中的第一个IP，尽管实际上并没有使用。在这种情况下，这意味着`.1`和`.2`在这一点上在技术上是保留的。）
- en: A container assignable IP range of `172.16.16.128/25`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可分配的容器IP范围为`172.16.16.128/25`
- en: A name of `myoverlay`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`myoverlay`的网络
- en: 'As before, this network is now available for consumption on all three hosts
    participating in the overlay configuration. Let''s now define our first container
    on the overlay network from host `docker2`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，这个网络现在可以在参与覆盖配置的三个主机上使用。现在让我们从主机`docker2`上的覆盖网络中定义我们的第一个容器：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we ask the host to start a container named `web1` and attach it to the
    network `myoverlay`. Let''s now inspect the container''s IP interface configuration:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求主机启动一个名为`web1`的容器，并将其连接到网络`myoverlay`。现在让我们检查容器的IP接口配置：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Surprisingly, the container has two interfaces. The `eth0` interface is attached
    to the network associated with the overlay network `myoverlay`, but `eth1` is
    associated with a new network `172.18.0.0/16`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，容器有两个接口。`eth0`接口连接到与覆盖网络`myoverlay`相关联的网络，但`eth1`与一个新网络`172.18.0.0/16`相关联。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You've likely noticed by this point that the name of the interfaces within the
    container use VETH pair naming syntax. Docker uses VETH pairs to connect containers
    to bridges and configures the container IP address directly on the container side
    interface. This will be covered extensively in [Chapter 4](ch04.html "Chapter 4. Building
    Docker Networks"), *Building Docker Networks*, where we walk through the details
    of how Docker attaches containers to the network.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到容器中的接口名称使用VETH对命名语法。Docker使用VETH对将容器连接到桥接，并直接在容器侧接口上配置容器IP地址。这将在[第4章](ch04.html
    "第4章。构建Docker网络")中进行详细介绍，*构建Docker网络*，在这里我们将详细介绍Docker如何将容器连接到网络。
- en: 'To figure out where it''s attached, let''s try and find the other end of the
    VETH pair that the container''s `eth1` interface attaches to. As shown in [Chapter
    1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux Networking Constructs*,
    we could use `ethtool` to look up the `interface ID` for a VETH pairs peer. However,
    there''s an easier way to do this when looking at user-defined networks. Notice
    in the preceding output that the VETH pair name has a syntax of:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出它连接到哪里，让我们试着找到容器的`eth1`接口连接到的VETH对的另一端。如[第1章](ch01.html "第1章。Linux网络构造")所示，*Linux网络构造*，我们可以使用`ethtool`来查找VETH对的对等`接口ID`。然而，当查看用户定义的网络时，有一种更简单的方法可以做到这一点。请注意，在前面的输出中，VETH对的名称具有以下语法：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As luck would have it, the number shown after `if` is the `interface ID` of
    the other side of the VETH pair. So, in the preceding output, we see that the
    `eth1` interface''s matching interface has an `interface ID` of `11`. Looking
    at the local Docker host, we can see that we have an interface `11` defined and
    that its `peer interface ID` is `10`, which matches `interface ID` in the container:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`if`后面显示的数字是VETH对的另一端的`接口ID`。因此，在前面的输出中，我们看到`eth1`接口的匹配接口具有`接口ID`为`11`。查看本地Docker主机，我们可以看到我们定义了一个接口`11`，它的`对等接口ID`是`10`，与容器中的`接口ID`匹配。
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice that this end of the VETH pair (`interface ID 11`) has a master named
    `docker_gwbridge`. That is, this end of the VETH pair is part of the bridge `docker_gwbridge`.
    Let''s look at the networks defined on the Docker host again:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，VETH对的这一端（`接口ID 11`）有一个名为`docker_gwbridge`的主机。也就是说，VETH对的这一端是桥接`docker_gwbridge`的一部分。让我们再次查看Docker主机上定义的网络：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In addition to our overlay network, there''s also a new user-defined bridge
    of the same name. If we inspect this bridge, we see our container is connected
    to it as expected and the network has some options defined:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的覆盖网络，还有一个同名的新用户定义桥接。如果我们检查这个桥接，我们会看到我们的容器按预期连接到它，并且网络定义了一些选项：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, ICC mode for this bridge is disabled. ICC prevents containers
    on the same network bridge from communicating directly with each other. But what
    is the purpose of this bridge and why are containers spawned on the `myoverlay`
    network being attached to it?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，此桥的ICC模式已禁用。ICC防止同一网络桥上的容器直接通信。但是这个桥的目的是什么，为什么生成在`myoverlay`网络上的容器被连接到它上面呢？
- en: 'The `docker_gwbridge` network is the solution to external container connectivity
    for overlay connected containers. Overlay networks can be thought of as layer
    2 network segments. You can attach multiple containers to them and anything on
    that network can talk across the local network segment. However, this doesn''t
    allow the container to talk to resources off the network. This limits Docker''s
    ability to access container resources through published ports as well as the container''s
    ability to talk to the outside network. If we examine the container''s routing
    configuration, we can see that its default gateway points to the interface of
    the `docker_gwbridge`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker_gwbridge`网络是用于覆盖连接的容器的外部容器连接的解决方案。覆盖网络可以被视为第2层网络段。您可以将多个容器连接到它们，并且该网络上的任何内容都可以跨越本地网络段进行通信。但是，这并不允许容器与网络外的资源通信。这限制了Docker通过发布端口访问容器资源的能力，以及容器与外部网络通信的能力。如果我们检查容器的路由配置，我们可以看到它的默认网关指向`docker_gwbridge`的接口：'
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This coupled with the fact that the `docker_gwbridge` has IP masquerading enabled
    means that the container can still talk to the outside network:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上`docker_gwbridge`启用了IP伪装的事实，这意味着容器仍然可以与外部网络通信：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As with the default bridge network, containers will hide behind their Docker
    host IP interface if they attempt to route through to reach the outside network.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认桥网络一样，如果容器尝试通过路由到达外部网络，它们将隐藏在其Docker主机IP接口后面。
- en: 'It also means that since I published ports on this container using the `-P`
    flag that Docker has published those ports using `docker_gwbridge`. We can verify
    the ports were published by using the `docker port` subcommand:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，由于我使用`-P`标志在此容器上发布了端口，Docker已经使用`docker_gwbridge`发布了这些端口。我们可以使用`docker
    port`子命令来验证端口是否已发布：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And verify that port is published on the `docker_gwbridge` by checking the
    netfilter rules with `iptables`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`iptables`检查netfilter规则来验证端口是否在`docker_gwbridge`上发布：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see in the preceding output, Docker is using the container's interface
    on the `docker_gwbridge` to provide port publishing to the Docker host's interfaces.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出中所看到的，Docker正在使用`docker_gwbridge`上的容器接口来为Docker主机的接口提供端口发布。
- en: 'At this point, our container topology looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的容器拓扑如下：
- en: '![How to do it…](graphics/B05453_03_04.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_03_04.jpg)'
- en: Adding a container to an overlay network automatically created the bridge `docker_gwbridge`,
    which is used for container connectivity onto and off the host. The `myoverlay`
    overlay network is used only for connectivity related to the defined `subnet`,
    `172.16.16.0/24`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器添加到覆盖网络会自动创建桥`docker_gwbridge`，用于容器连接到主机以及离开主机。`myoverlay`覆盖网络仅用于与定义的`subnet`，`172.16.16.0/24`相关的连接。
- en: 'Let''s now start two more containers, one on the host `docker3` and another
    on the host `docker4`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动另外两个容器，一个在主机`docker3`上，另一个在主机`docker4`上：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that, when I attempt to run the same container on both hosts, Docker
    tells me that the container `web2` already exists. Docker won't allow you to run
    a container with the same name on the same overlay network. Recall that Docker
    is storing information related to each container on the overlay in the key-value
    store. Using unique names becomes important when we start talking about Docker
    name resolution.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我尝试在两个主机上运行相同的容器时，Docker告诉我容器`web2`已经存在。Docker不允许您在同一覆盖网络上以相同的名称运行容器。请回想一下，Docker正在将与覆盖中的每个容器相关的信息存储在键值存储中。当我们开始讨论Docker名称解析时，使用唯一名称变得很重要。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice at this point that the containers can resolve each other by name.
    This is one of the really powerful features that come along with user-defined
    networks. We'll talk about this in much more detail in [Chapter 5](ch05.html "Chapter 5. Container
    Linking and Docker DNS"), *Container Linking and Docker DNS*, where we discuss
    DNS and linking.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此时您可能会注意到容器可以通过名称解析彼此。这是与用户定义的网络一起提供的非常强大的功能之一。我们将在[第5章](ch05.html "第5章. 容器链接和Docker
    DNS")中更详细地讨论这一点，*容器链接和Docker DNS*，在那里我们将讨论DNS和链接。
- en: 'Restart the container on `docker4` with a unique name:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用唯一名称在`docker4`上重新启动容器：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we have three containers running, one on each host participating in the
    overlay. Let''s take a brief moment to visualize what''s going on here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个容器在运行，每个主机上都有一个参与覆盖。让我们花点时间来想象这里发生了什么：
- en: '![How to do it…](graphics/B05453_03_05.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_03_05.jpg)'
- en: I've removed the host and underlay networking on the diagram to make this easier
    to read. As described, each container has two IP network interfaces. One IP address
    is on the shared overlay network and is in the `172.16.16.128/25` network. The
    other is on the bridge `docker_gwbridge` and is the same on each host. Since the
    `docker_gwbridge` lives on each host independently, there is no need to have unique
    addressing for this interface. The container interface on that bridge serves only
    as a means for the container to talk to the outside network. That is, every container
    on the same host, which has a network interface on an overlay type network, will
    receive an IP address on this same bridge.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在图表上删除了主机和底层网络，以便更容易阅读。如描述的那样，每个容器都有两个IP网络接口。一个IP地址位于共享的覆盖网络上，位于`172.16.16.128/25`网络中。另一个位于桥接`docker_gwbridge`上，每个主机上都是相同的。由于`docker_gwbridge`独立存在于每个主机上，因此不需要为此接口设置唯一的地址。该桥上的容器接口仅用作容器与外部网络通信的手段。也就是说，位于相同主机上的每个容器，在覆盖类型网络上都会在同一桥上接收一个IP地址。
- en: You might be wondering if this raises a security concern since all containers
    with overlay networks, regardless of which they are connected to, will also have
    an interface on a shared bridge (`docker_gwbridge`). Recall earlier that I pointed
    out that the `docker_gwbridge` had ICC mode disabled. This means that, while many
    containers can be deployed to the bridge, none of them can actually communicate
    directly with each other through their IP interfaces on that bridge. We'll talk
    much more about this in [Chapter 6](ch06.html "Chapter 6. Securing Container Networks"),
    *Securing Container Networks*, where we discuss container security, but for now
    know that ICC prevents ICC from occurring on the shared bridge.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这是否会引起安全问题，因为所有连接到覆盖网络的容器，无论连接到哪个网络，都会在共享桥上（`docker_gwbridge`）上有一个接口。请回想一下之前我指出过`docker_gwbridge`已禁用了ICC模式。这意味着，虽然可以将许多容器部署到桥上，但它们都无法通过桥上的IP接口直接与彼此通信。我们将在[第6章](ch06.html
    "第6章. 容器网络安全")中更详细地讨论这一点，*容器网络安全*，在那里我们将讨论容器安全，但现在知道ICC可以防止在共享桥上发生ICC。
- en: Containers on the overlay network believe that they are on the same network
    segment, or are layer 2 adjacent to each other. Let's prove this by connecting
    to the web service on container `web2` from container `web1`. Recall that when
    we provisioned the container `web2`, we did not ask it to publish any ports.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在覆盖网络上相信它们在同一网络段上，或者彼此相邻的第2层。让我们通过从容器`web1`连接到容器`web2`上的web服务来证明这一点。回想一下，当我们配置容器`web2`时，我们没有要求它发布任何端口。
- en: 'As with other Docker network constructs, containers connected to the same overlay
    network can talk directly to each other on any port in which they have a service
    bound to without the need to publish the port:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Docker网络构造一样，连接到同一覆盖网络的容器可以直接在它们绑定服务的任何端口上相互通信，而无需发布端口：
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to remember that the Docker host has no direct means to connect
    to the overlay connected containers. With the bridge network type this was feasible
    because the host had an interface on the bridge, in the case of overlay type networks,
    this interface does not exist.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Docker主机没有直接连接到覆盖连接的容器的手段。对于桥接网络类型，这是可行的，因为主机在桥接上有一个接口，在覆盖类型网络的情况下，这个接口是不存在的。
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we can successfully access the web server running in container
    `web2` from container `web1`. Not only are these containers on totally different
    hosts, but the hosts themselves are on totally different subnets. This type of
    communication was only available previously when both containers sat on the same
    host, and were connected to the same bridge. We can prove that the containers
    believe themselves to be layer 2 adjacent by checking the ARP and MAC entries
    on each respective container:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以成功地从容器`web1`访问运行在容器`web2`中的web服务器。这些容器不仅位于完全不同的主机上，而且主机本身位于完全不同的子网上。这种类型的通信以前只有在两个容器坐在同一主机上，并连接到同一个桥接时才可用。我们可以通过检查每个相应容器上的ARP和MAC条目来证明容器相信自己是第2层相邻的：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can see that the container has an ARP entry from the remote container specifying
    its IP address as well as its MAC address. If the containers were not on the same
    network, the container `web1` would not have an ARP entry for `web2`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到容器有一个ARP条目，来自远程容器，指定其IP地址以及MAC地址。如果容器不在同一网络上，容器`web1`将不会有`web2`的ARP条目。
- en: 'We can verify that we have local connectivity between all three containers
    from container `web2-2` on host `docker4`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证我们从`docker4`主机上的`web2-2`容器对所有三个容器之间的本地连接性：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we know the overlay works, let''s talk about how it''s implemented.
    The mechanism used for overlay transport is VXLAN. We can see the container-generated
    packets as they traverse the underlay network by looking at a packet capture taken
    on the physical network:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道覆盖网络是如何工作的，让我们谈谈它是如何实现的。覆盖传输所使用的机制是VXLAN。我们可以通过查看在物理网络上进行的数据包捕获来看到容器生成的数据包是如何穿越底层网络的。
- en: '![How to do it…](graphics/B05453_03_06.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_03_06.jpg)'
- en: 'In the preceding screenshot of a packet taken from the capture, I want to call
    out a couple of items:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在从捕获中获取的数据包的前面的屏幕截图中，我想指出一些项目：
- en: The outer IP packet is sourced from the `docker2` host (`10.10.10.102`) and
    destined to the `docker3` host (`192.168.50.101`).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部IP数据包源自`docker2`主机（`10.10.10.102`），目的地是`docker3`主机（`192.168.50.101`）。
- en: We can see that outer IP packet is UDP and is detected as being VXLAN encapsulation.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到外部IP数据包是UDP，并且被检测为VXLAN封装。
- en: The **VNI** (**VXLAN Network Identifier**) or segment ID is `260`. VNI is unique
    per subnet.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VNI**（VXLAN网络标识符）或段ID为`260`。VNI在每个子网中是唯一的。'
- en: The inner frame has a layer 2 and layer 3 header. The layer 2 header has a destination
    MAC addresses of container `web2` as shown earlier. The IP packet shows a source
    of container `web1` and a destination of container `web2`.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部帧具有第 2 层和第 3 层标头。第 2 层标头具有容器 `web2` 的目标 MAC 地址，如前所示。IP 数据包显示了容器 `web1` 的源和容器
    `web2` 的目标。
- en: The Docker hosts encapsulate the overlay traffic using their own IP interface
    and send it across the underlay network to the destination Docker host. Information
    from the key-value store is used to determine what host a given container is on
    in order for the VXLAN encapsulation to send the traffic to the right host.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 主机使用自己的 IP 接口封装覆盖流量，并通过底层网络将其发送到目标 Docker 主机。来自键值存储的信息用于确定给定容器所在的主机，以便
    VXLAN 封装将流量发送到正确的主机。
- en: 'You might now be wondering where all the configuration for this VXLAN overlay
    is. At this point, we haven''t seen any configuration that actually talks about
    VXLAN or tunneling. To provide VXLAN encapsulation, Docker creates what I refer
    to as an *overlay namespace* for each user-defined overlay network. As we saw
    in [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux Networking
    Constructs*, you can use the `ip netns` tool to interact with the network namespace.
    However, since Docker stores their network namespaces in a nondefault location,
    we won''t be able to see any of the namespaces using the `ip netns` tool. By default,
    namespaces are stored in `/var/run/netns`. The problem is that Docker stores its
    network namespaces in `/var/run/docker/netns`, which means the `ip netns` tool
    is looking in the wrong place to see network namespaces created by Docker. As
    a work around to this issue, we can create a `symlink` that links `/var/run/docker/netns/`
    to `/var/run/nents` as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能想知道 VXLAN 覆盖的所有配置在哪里。到目前为止，我们还没有看到任何实际涉及 VXLAN 或隧道的配置。为了提供 VXLAN 封装，Docker
    为每个用户定义的覆盖网络创建了我所说的 *覆盖命名空间*。正如我们在[第 1 章](ch01.html "第 1 章。Linux 网络构造")中看到的 *Linux
    网络构造*，您可以使用 `ip netns` 工具与网络命名空间进行交互。然而，由于 Docker 将它们的网络命名空间存储在非默认位置，我们将无法使用 `ip
    netns` 工具查看任何由 Docker 创建的命名空间。默认情况下，命名空间存储在 `/var/run/netns` 中。问题在于 Docker 将其网络命名空间存储在
    `/var/run/docker/netns` 中，这意味着 `ip netns` 工具正在错误的位置查看由 Docker 创建的网络命名空间。为了解决这个问题，我们可以创建一个
    `symlink`，将 `/var/run/docker/netns/` 链接到 `/var/run/nents`，如下所示：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that there are two network namespace defined. The overlay namespace will
    be identified with the following syntax `x-<id>` where `x` is a random number.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，定义了两个网络命名空间。覆盖命名空间将使用以下语法进行标识 `x-<id>`，其中 `x` 是一个随机数。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The other namespace we see displayed in the output is associated with the container
    running on the host. In the next chapter, we'll be doing a deep dive on how these
    namespaces are created and used by Docker.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中看到的另一个命名空间与主机上运行的容器相关联。在下一章中，我们将深入探讨 Docker 如何创建和使用这些命名空间。
- en: 'So in our case, the overlay namespace is `2-4695c5484e`, but where did it come
    from? If we inspect the network configuration of this namespace, we''ll see that
    it has some unusual interfaces defined:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，覆盖命名空间是 `2-4695c5484e`，但它是从哪里来的呢？如果我们检查这个命名空间的网络配置，我们会看到它定义了一些不寻常的接口：
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These interfaces define the overlay network namespace I mentioned earlier.
    Earlier we saw that the container `web2-2` has two interfaces. The `eth1` interface
    was one end of a VETH pair with the other end placed on the `docker_gwbridge`.
    The VETH pair shown in the preceding overlay network namespace represents one
    side of the pair for the container''s `eth0` interface. We can prove this by matching
    up the sides of the VETH pair by `interface ID`. Notice that this end of the VETH
    pair shows the other end to have an `interface ID` of `12`. If we look at the
    container `web2-2`, we''ll see that its `eth0` interface has an ID of `12`. In
    turn, the container''s interface shows a pair ID of `13`, which matches the output
    we saw in the overlay namespace:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口定义了我之前提到的叠加网络命名空间。之前我们看到`web2-2`容器有两个接口。`eth1`接口是VETH对的一端，另一端放在`docker_gwbridge`上。在前面的叠加网络命名空间中显示的VETH对代表了容器`eth0`接口的一侧。我们可以通过匹配VETH对的一侧来证明这一点。请注意，VETH对的这一端显示另一端的`接口ID`为`12`。如果我们查看容器`web2-2`，我们会看到它的`eth0`接口的ID为`12`。反过来，容器的接口显示了一个ID为`13`的对ID，这与我们在叠加命名空间中看到的输出相匹配：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we know how the container''s overlay interface (`eth0`) is connected,
    we need to know how traffic headed into the overlay namespace gets encapsulated
    and sent to the other Docker hosts. This is done through the overlay namespace''s
    `vxlan1` interface. This interface has specific forwarding entries that describe
    all of the other endpoints on the overlay:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道容器的叠加接口（`eth0`）是如何连接的，我们需要知道进入叠加命名空间的流量是如何封装并发送到其他Docker主机的。这是通过叠加命名空间的`vxlan1`接口完成的。该接口具有特定的转发条目，描述了叠加中的所有其他端点：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice that we have two entries referencing a MAC address and a destination.
    The MAC address represents the MAC address of another container on the overlay,
    and the IP address is the Docker host in which the container lives. We can verify
    that by checking one of the other hosts:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有两个条目引用MAC地址和目的地。MAC地址表示叠加中另一个容器的MAC地址，IP地址是容器所在的Docker主机。我们可以通过检查其他主机来验证：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With this information, the overlay namespace knows that in order to reach that
    destination MAC address, it needs to encapsulate traffic in VXLAN and send it
    towards `10.10.10.102` (`docker2`).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，叠加命名空间就知道为了到达目的地MAC地址，它需要在VXLAN中封装流量并将其发送到`10.10.10.102`（`docker2`）。
- en: Isolating networks
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离网络
- en: User-defined networks can support what's referred to as internal mode. We saw
    this option in the earlier recipe about creating user-defined networks, but didn't
    spend much time discussing it. Using the `--internal` flag when creating a network
    prevents containers connected to the network from talking to any outside networks.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的网络可以支持所谓的内部模式。我们在早期关于创建用户定义网络的示例中看到了这个选项，但并没有花太多时间讨论它。在创建网络时使用`--internal`标志可以防止连接到网络的容器与任何外部网络通信。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `docker network` subcommand was introduced in Docker 1.9, so you'll need
    a Docker host running at least that version. In our examples, we'll be using Docker
    version 1.12\. You'll also want to have a good understanding of your current network
    layout so that you can follow along as we inspect the current configuration. It
    is assumed that each Docker host is in its native configuration.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network`子命令是在Docker 1.9中引入的，因此您需要运行至少该版本的Docker主机。在我们的示例中，我们将使用Docker版本1.12。您还需要对当前网络布局有很好的了解，以便在我们检查当前配置时能够跟上。假设每个Docker主机都处于其本机配置中。'
- en: How to do it…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Making a user-defined network internal is pretty straightforward, you just add
    the option `--internal` to the `network create` subcommand. Since a user-defined
    network can be of type bridge or type overlay, we should understand how Docker
    implements isolation in either case.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户定义的网络设置为内部网络非常简单，只需在`network create`子命令中添加`--internal`选项。由于用户定义的网络可以是桥接类型或覆盖类型，我们应该了解Docker如何在任何情况下实现隔离。
- en: Creating internal user-defined bridges
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建内部用户定义的桥接网络
- en: 'Define a user-defined bridge and pass it the `internal` flag, as well as the
    flag to give the bridge a custom name on the host. We can do this with this command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个用户定义的桥接并传递`internal`标志，以及在主机上为桥接指定自定义名称的标志。我们可以使用以下命令来实现这一点：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s take a look at the IP information that Docker assigned to the bridge:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下Docker分配给桥接的IP信息：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Taking this information, we now check and see what Docker has programmed in
    netfilter for this bridge. Let''s check the filter table and see:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在来检查一下Docker为这个桥接在netfilter中编程了什么。让我们检查过滤表并查看：
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, I'm using the `iptables-save` syntax to query the current rules.
    Sometimes, this can be more readable than looking at individual tables.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我正在使用`iptables-save`语法来查询当前的规则。有时，这比查看单个表更易读。
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we can see that Docker has added two rules. The first says that any traffic
    that is not sourced from the bridge subnet and is leaving the bridge interface
    should be dropped. This can be hard to comprehend, so it's easiest to think of
    this in terms of an example. Say that a host on your network `192.168.127.57`
    was trying to access something on this bridge. That flows source IP address would
    not be in the bridge subnet, which fulfills the first part of the rule. It would
    also be attempting to go out of (or onto) `mybridge1` meeting the second part
    of the rule. This rule effectively prevents all inbound communication.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Docker添加了两条规则。第一条规定，任何不是源自桥接子网并且正在离开桥接接口的流量应该被丢弃。这可能很难理解，所以最容易的方法是以一个例子来思考。假设您网络上的主机`192.168.127.57`正在尝试访问这个桥接上的某些内容。该流量的源IP地址不会在桥接子网中，这满足了规则的第一部分。它还将尝试离开（或进入）`mybridge1`，满足了规则的第二部分。这条规则有效地阻止了所有入站通信。
- en: The second rule looks for traffic that does not have a destination in the bridge
    subnet, and that has an ingress interface of the bridge `mybridge1`. In this case,
    a container might have an IP address of 172.19.0.5/16\. If it were attempting
    to talk off of it's local network, the destination would not be in the `172.19.0.0/16`
    which would match the first part of the rule. As it attempted to leave the bridge
    towards an external network, it would match the second part of the rule as it's
    coming into the `mybridge1` interface. This rule effectively prevents all outbound
    communication.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则寻找没有在桥接子网中具有目的地，并且具有桥接`mybridge1`的入口接口的流量。在这种情况下，容器可能具有IP地址172.19.0.5/16。如果它试图离开本地网络进行通信，目的地将不在`172.19.0.0/16`中，这将匹配规则的第一部分。当它试图离开桥接朝向外部网络时，它将匹配规则的第二部分，因为它进入`mybridge1`接口。这条规则有效地阻止了所有出站通信。
- en: Between these two rules, no traffic is allowed in or out of the bridge. This
    does not, however, prevent container-to-container connectivity between containers
    on the same bridge.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条规则之间，桥接内部不允许任何流量进出。但是，这并不妨碍在同一桥接上的容器之间的容器之间的连接。
- en: 'It should be noted that Docker will allow you to specify the publish (`-P`)
    flag when running containers against an internal bridge. However, no ports will
    ever get mapped:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，Docker允许您在针对内部桥接运行容器时指定发布（`-P`）标志。但是，端口将永远不会被映射：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Creating internal user-defined overlays
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建内部用户定义的覆盖网络
- en: 'Creating internal overlays follows the same process. We just pass the `--internal`
    flag to the `network create` subcommand. However, in the case of overlay networks,
    the isolation model is much simpler. We can create an internal overlay network
    as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内部覆盖遵循相同的过程。我们只需向`network create`子命令传递`--internal`标志。然而，在覆盖网络的情况下，隔离模型要简单得多。我们可以按以下方式创建内部覆盖网络：
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once created, it''s really no different than a non-internal overlay. The difference
    comes when we run containers on the internal overlay:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，它与非内部覆盖没有什么不同。区别在于当我们在内部覆盖上运行容器时：
- en: '[PRE59]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Checking the container interface configuration, we can see that the container
    only has one interface, which is a member of the overlay network (`192.10.10.0/24`).
    The interface that would normally connect the container to the `docker_gwbridge`
    (`172.18.0.0/16`) network for external connectivity is missing:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器接口配置，我们可以看到容器只有一个接口，它是覆盖网络（`192.10.10.0/24`）的成员。通常连接容器到`docker_gwbridge`（`172.18.0.0/16`）网络以进行外部连接的接口缺失：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Overlay networks are inherently isolated, hence, need for the `docker_gwbridge`.
    Not mapping a container interface to `docker_gwbridge` means that there's no way
    to talk in or out of the overlay network that provides the isolation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖网络本质上是隔离的，因此需要`docker_gwbridge`。不将容器接口映射到`docker_gwbridge`意味着没有办法在覆盖网络内部或外部进行通信。
