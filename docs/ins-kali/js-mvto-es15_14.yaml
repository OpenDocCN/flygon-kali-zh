- en: Chapter 2. Organizing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。组织代码
- en: In this chapter we'll look at how to organize JavaScript code into reusable,
    understandable chunks. The language itself doesn't lend itself well to this sort
    of modularization but a number of methods of organizing JavaScript code have emerged
    over the years. This chapter will argue for the need to break down code and then
    work through the methods of creating JavaScript modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何将JavaScript代码组织成可重用、可理解的块。语言本身并不适合这种模块化，但多年来出现了许多组织JavaScript代码的方法。本章将论证需要拆分代码，然后介绍创建JavaScript模块的方法。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Global scope
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局范围
- en: Objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Prototype inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承
- en: ECMAScript 2015 classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2015类
- en: Chunks of code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块
- en: The first thing anybody learns to program is the ubiquitous Hello World application.
    This simple application prints some variation of "hello world" to the screen.
    Depending on who you ask, the phrase hello world dates back to the early 1970s
    where it was used to demonstrate the B programming language or even to 1967 where
    it appears in a BCL programming guide. In such a simple application there is no
    need to worry about the structure of code. Indeed, in many programming languages,
    hello world needs no structure at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人学习编程的第一件事就是无处不在的Hello World应用程序。这个简单的应用程序将一些变体的“hello world”打印到屏幕上。根据不同的说法，hello
    world这个短语可以追溯到20世纪70年代初，当时它被用来演示B编程语言，甚至可以追溯到1967年，当时它出现在BCL编程指南中。在这样一个简单的应用程序中，无需担心代码的结构。事实上，在许多编程语言中，hello
    world根本不需要结构。
- en: 'For Ruby, it is as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ruby，它是这样的：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For JavaScript (via Node.js), it is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript（通过Node.js），它是这样的：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Programming modern computers was originally done using brutally simplistic techniques.
    Many of the first computers had problems they were attempting to solve hard-wired
    into them. They were not general purpose computing machines like the ones we have
    today. Instead they were built to solve just one problem such as decoding encrypted
    texts. Stored program computers were first developed in the late 1940s.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机编程最初是使用非常简单的技术进行的。许多最早的计算机在试图解决的问题中都存在硬连线。它们不像我们今天拥有的通用计算机那样。相反，它们是为了解决一个问题而构建的，比如解码加密文本。存储程序计算机最早是在1940年代末开发的。
- en: The languages used to program these computers were complicated at first, usually
    very closely tied to the binary. Eventually higher and higher-level abstractions
    were created to make programming more accessible. As these languages started to
    take shape through the 50s and 60s it quickly became apparent that there needed
    to be some way to divide up large blocks of code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最初用于编程这些计算机的语言起初非常复杂，通常与二进制密切相关。最终，越来越高级的抽象被创建出来，使得编程更加容易。随着这些语言在50年代和60年代开始形成，很快就显而易见需要一种方式来划分大块代码。
- en: In part this was simply to maintain the sanity of programmers who could not
    keep an entire, large program in their heads at any one time. However, creating
    reusable modules also allowed for code to be shared within an application and
    even between applications. The initial solution was to make use of statements,
    which jumped the flow control of the program from one place to another. For a
    number of years these GOTO statements were heavily relied upon. To a modern programmer
    who has been fed a continual stream of warnings about the use of GOTO statements
    this seems like insanity. However it was not until some years after the first
    programming languages emerged that structured programming grew to replace the
    GOTO syntax.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 部分原因是为了维护程序员的理智，他们无法一次记住整个大型程序。然而，创建可重用的模块也允许在应用程序内部甚至在应用程序之间共享代码。最初的解决方案是利用语句，它们可以将程序的流程从一个地方跳转到另一个地方。多年来，这些GOTO语句被大量依赖。对于一个不断受到有关使用GOTO语句的警告的现代程序员来说，这似乎是疯狂的。然而，直到第一批编程语言出现几年后，结构化编程才逐渐取代了GOTO语法。
- en: 'Structured programming is based on the Böhm-Jacopini theorem, which states
    that there is a rather large class of problems, the answer to which can be computed
    using three very simple constructs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程是基于Böhm-Jacopini定理的，该定理指出有一类问题的答案可以使用三个非常简单的结构来计算：
- en: Sequential execution of sub-programs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子程序的顺序执行
- en: Conditional execution of two sub-programs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子程序的条件执行
- en: Repeated execution of a sub-program until a condition is true
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复执行子程序，直到条件为真
- en: Astute readers will recognize these constructs as being the normal flow of execution,
    a branch or `if` statement, and a loop.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会认识到这些结构是正常的执行流程，一个分支或`if`语句，以及一个循环。
- en: Fortran was one of the earliest languages and was initially built without support
    for structured programming. However structured programming was soon adopted as
    it helped to avoid spaghetti code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran是最早的语言之一，最初没有支持结构化编程。然而，结构化编程很快被采纳，因为它有助于避免意大利面代码。
- en: Code in Fortran was organized into modules. Modules were loosely coupled collections
    of procedures. For those coming from a modern object oriented language, the closest
    concept might be that a module was like a class that contains only static methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran中的代码被组织成模块。模块是松散耦合的过程集合。对于那些来自现代面向对象语言的人来说，最接近的概念可能是模块就像一个只包含静态方法的类。
- en: Modules were useful for dividing code into logical groupings. However, it didn't
    provide for any sort of structure for the actual applications. The structure for
    object-oriented languages, that is classes and subclasses, can be traced to a
    1967 paper written by Ole-Johan Dahl and Kristen Nygaard. This paper would go
    on to form the basis of Simula-67, the first language with support for object
    oriented programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模块对于将代码分成逻辑分组非常有用。然而，它并没有为实际应用程序提供任何结构。面向对象语言的结构，即类和子类，可以追溯到Ole-Johan Dahl和Kristen
    Nygaard在1967年撰写的一篇论文。这篇论文将成为支持面向对象编程的第一种语言Simula-67的基础。
- en: While Simula-67 was the first language to have classes, the language most talked
    about in relation to early object oriented programming is Smalltalk. This language
    was developed behind closed doors at the famous Xerox **Palo Alto Research Center**
    (**PARC**) during the 1970s. it was released to the public in 1980 as Smalltalk-80
    (it seems like all historically relevant programming languages where prefixed
    with the year of release as a version number). What Smalltalk brought was that
    everything in the language was an object, even literal numbers like 3 could have
    operations performed on them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Simula-67是第一种具有类的语言，与早期面向对象编程相关的最受关注的语言是Smalltalk。这种语言是在著名的施乐帕洛阿尔托研究中心（PARC）在20世纪70年代闭门开发的。它于1980年作为Smalltalk-80发布给公众（似乎所有具有历史意义的编程语言都以发布年份作为版本号的前缀）。Smalltalk带来的是语言中的一切都是对象，甚至像3这样的文字数字也可以对它们进行操作。
- en: Almost every modern programming language has some concept of classes to organize
    code. Often these classes will fall into a higher-level structure commonly called
    a namespace or module. Through the use of these structures, even very large programs
    can be divided into manageable and understandable chunks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种现代编程语言都有一些类的概念来组织代码。通常，这些类会被归类到一个称为命名空间或模块的更高级结构中。通过使用这些结构，即使是非常庞大的程序也可以被分成可管理和可理解的块。
- en: Despite the rich history and obvious utility of classes and modules, JavaScript
    did not support them as first class constructs until just recently. To understand
    why, one has to simply look back at the history of JavaScript from [Chapter 1](part0081_split_000.html#2D7TI2-015e68c68a464f18a9559f448be84435
    "Chapter 1. Designing for Fun and Profit"), *Designing For Fun and Profit*, and
    realize that for its original purpose having such constructs would have been overkill.
    Classes were a part of the ill-fated ECMAScript 4 standard and they finally became
    part of the language with the release of the ECMAScript 2015 standard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类和模块具有丰富的历史和明显的实用性，但JavaScript直到最近才支持它们作为一流构造。要理解为什么，只需回顾一下JavaScript的历史，就会意识到对于其最初的目的，拥有这样的构造将是多余的。类是注定要失败的ECMAScript
    4标准的一部分，它们最终成为了ECMAScript 2015标准的一部分。
- en: In this chapter we'll explore some of the ways to recreate the well worn class
    structure of other modern programming languages in JavaScript.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些在JavaScript中重新创建其他现代编程语言中的经典类结构的方法。
- en: What's the matter with global scope anyway?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局作用域有什么问题呢？
- en: In browser based JavaScript every object you create is assigned to the global
    scope. For the browser, this object is simply known as **window**. It is simple
    to see this behavior in action by opening up the development console in your favorite
    browser.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于浏览器的JavaScript中，您创建的每个对象都分配给全局作用域。对于浏览器，这个对象简单地称为**window**。通过在您喜爱的浏览器中打开开发控制台，可以很容易地看到这种行为。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Opening the Development Console**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开开发控制台**'
- en: Modern browsers have, built into them, some very advanced debugging and auditing
    tools. To access them there is a menu item, which is located under **Tools** |
    **Developer Tools in Chrome** | **Tools** | **Web Developer in Firefox**, and
    directly under the menu as **F12 Developer Tools** in Internet Explorer. Keyboard
    shortcuts also exist for accessing the tools. On Windows and Linux, *F12* is standard
    and, on OSX, `Option` + `Command` + `I` is used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器内置了一些非常先进的调试和审计工具。要访问它们，有一个菜单项，位于**工具** | **Chrome中的开发者工具** | **工具** |
    **Firefox中的Web开发者**下，以及在Internet Explorer中直接位于菜单下的**F12开发者工具**。还存在用于访问工具的键盘快捷键。在Windows和Linux上，*F12*是标准的，在OSX上，使用`Option`
    + `Command` + `I`。
- en: Within the developer tools is a console window that provides direct access to
    the current page's JavaScript. This is a very handy place to test out small snippets
    of code or to access the page's JavaScript.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者工具中有一个控制台窗口，可以直接访问当前页面的JavaScript。这是一个非常方便的地方，可以测试小片段的代码或访问页面的JavaScript。
- en: 'Once you have the console open, enter the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开控制台，输入以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of this will be `hello world` printed to the console. By declaring
    words globally it is automatically attached to the top level container: window.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致“hello world”被打印到控制台。通过全局声明单词，它会自动附加到顶层容器：窗口。
- en: In Node.js the situation is somewhat different. Assigning a variable in this
    fashion will actually attach it to the current module. Not including the `var`
    object will attach the variable to the `global` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，情况有些不同。以这种方式分配变量实际上会将其附加到当前模块。不包括`var`对象将会将变量附加到`global`对象。
- en: For years you've likely heard that making use of global variables is a bad thing.
    This is because globals are very easily polluted by other code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，您可能听说过使用全局变量是一件坏事。这是因为全局变量很容易被其他代码污染。
- en: Consider a very commonly named variable such as `index`. It is likely that in
    any application of appreciable size that this variable name would be used in several
    places. When either piece of code makes use of the variable it will cause unexpected
    results in the other piece of code. It is certainly possible to reuse variables,
    and it can even be useful in systems with very limited memory such as embedded
    systems, but in most applications reusing variables to mean different things within
    a single scope is difficult to understand and a source of errors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个非常常见的变量名，比如`index`。在任何规模可观的应用程序中，这个变量名很可能会在多个地方使用。当任何一段代码使用这个变量时，它会导致另一段代码中的意外结果。重用变量是可能的，甚至在内存非常有限的系统中也可能有用，比如嵌入式系统，但在大多数应用程序中，在单个作用域内重用变量以表示不同的含义是难以理解的，也是错误的来源。
- en: Applications that make use global scoped variables also open themselves up to
    being attacked on purpose by other code. It is trivial to alter the state of global
    variables from other code, which could expose secrets like login information to
    attackers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局作用域变量的应用程序也容易受到其他代码的恶意攻击。很容易从其他代码改变全局变量的状态，这可能会使登录信息等机密信息暴露给攻击者。
- en: Finally global variables add a great deal of complexity to applications. Reducing
    the scope of variables to a small section of code allows developers to more easily
    understand the ways in which the variable is used. When the scope is global then
    changes to that variable may have an effect far outside of the one section of
    code. A simple change to a variable can cascade into the entire application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，全局变量给应用程序增加了很多复杂性。将变量的范围缩小到代码的一小部分可以让开发人员更容易地理解变量的使用方式。当范围是全局时，对该变量的更改可能会对代码的整个部分产生影响。对变量的简单更改可能会影响整个应用程序。
- en: As a general rule global variables should be avoided.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是应避免使用全局变量。
- en: Objects in JavaScript
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的对象
- en: 'JavaScript is an object oriented language but most people don''t make use of
    the object oriented features of it except in passing. JavaScript uses a mixed
    object model in that it has some primitives as well as objects. JavaScript has
    five primitive types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种面向对象的语言，但大多数人除了偶尔使用之外并不充分利用其面向对象的特性。JavaScript使用混合对象模型，它既有一些原始类型，也有对象。JavaScript有五种原始类型：
- en: undefined
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'null'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: boolean
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: string
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: number
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: 'Of these five, only two are what we would expect to be an object anyway. The
    other three, boolean, string, and number all have wrapped versions, which are
    objects: Boolean, String, and Number. They are distinguished by starting with
    uppercase. This is the same sort of model used by Java, a hybrid of objects and
    primitives.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中只有两种是我们本来期望的对象。其他三种，布尔值、字符串和数字都有包装版本，即对象：Boolean、String和Number。它们以大写字母开头进行区分。这是Java使用的相同类型的模型，即对象和原始类型的混合。
- en: JavaScript will also box and unbox the primitives as needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还将根据需要对原始值进行装箱和拆箱。
- en: 'In this code you can see the boxed and unboxed versions of JavaScript primitives
    at work:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，您可以看到JavaScript原始值的装箱和拆箱版本在起作用：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creating objects in JavaScript is trivial. This can be seen in this code for
    creating an object in JavaScript:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建对象是微不足道的。这可以在以下用于在JavaScript中创建对象的代码中看到：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because JavaScript is a dynamic language, adding properties to objects is also
    quite easy. This can be done even after the object has been created. This code
    creates the object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript是一种动态语言，所以向对象添加属性也非常容易。这甚至可以在对象创建后进行。这段代码创建了对象：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Objects contain both data and functionality. We''ve only seen the data part
    so far. Fortunately in JavaScript, functions are first class objects. Functions
    can be passed around and functions can be assigned to variables. Let''s try adding
    some functions to the object we''re creating in this code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对象包含数据和功能。到目前为止，我们只看到了数据部分。幸运的是，在JavaScript中，函数是一级对象。函数可以传递并且函数可以分配给变量。让我们尝试在这段代码中添加一些函数到我们正在创建的对象中：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This syntax is a bit painful, building up objects an assignment at a time.
    Let''s see if we can improve upon the syntax for creating objects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法有点痛苦，一次分配一个对象。让我们看看是否可以改进创建对象的语法：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This syntax seems, at least to me, to be a much cleaner, more traditional way
    of building objects. Of course it is possible to mix data and functionality in
    an object in this fashion:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法在我看来似乎是一种更清晰、更传统的构建对象的方式。当然，也可以以这种方式混合数据和功能：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a couple of things to note in this piece of code. The first is that
    the different items in the object are separated using a comma and not a semi-colon.
    Those coming from other languages such as C# or Java are likely to make this mistake.The
    next item of interest is that we need to make use of the `this` qualifier to address
    the `greeting` variable from within the `doThings` function. This would also be
    true if we had a number of functions within the object as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中有几点需要注意。首先，对象中的不同项使用逗号而不是分号分隔。来自其他语言（如C#或Java）的人可能会犯这个错误。下一个有趣的地方是，我们需要使用`this`限定符来从`doThings`函数内部访问`greeting`变量。如果我们在对象中有多个函数，这也是正确的，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `this` keyword behaves differently in JavaScript than you might expect coming
    from other C-syntax languages. `this` is bound to the owner of the function in
    which it is found. However, the owner of the function is sometimes not what you
    expect. In the preceding example `this` is bound to the `functionObject` object,
    however if the function were declared outside of an object this would refer to
    the global object. In certain circumstances, typically event handlers, this is
    rebound to the object firing the event.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字在JavaScript中的行为与您从其他C语法语言中所期望的不同。`this`绑定到它所在的函数的所有者。然而，函数的所有者有时并非您所期望的。在前面的示例中，`this`绑定到`functionObject`对象，但是如果函数在对象之外声明，这将指向全局对象。在某些情况下，通常是事件处理程序，`this`会重新绑定到触发事件的对象。'
- en: 'Let''s look at the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`this` takes on the value of target. Getting used to the value of `this` is,
    perhaps, one of the trickiest things in JavaScript.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`取目标的值。也许，适应`this`的值是JavaScript中最棘手的事情之一。'
- en: 'ECMAScript-2015 introduces the `let` keyword which can replace the `var` keyword
    for declaring variables. `let` uses block level scoping which is the scoping you''re
    likely to use from most languages. Let''s see an example of how they differ:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript-2015引入了`let`关键字，它可以替代`var`关键字来声明变量。`let`使用块级作用域，这是您可能会从大多数语言中使用的作用域。让我们看一个它们之间的区别的例子：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the var scoped version you can see that the variable lives on outside of
    the block. This is because behind the scenes the declaration of `varScoped` is
    hoisted to the beginning of the code block. With the `let` scoped version of the
    code `letScoped` is scoped just within the `for` loop so, once we leave the loop,
    `letScoped` is undefined. When given the option of using `let` or `var` we would
    tend to err on the side of always using `let`. There are some cases when you actually
    would want to use var scoping but they are few and far between.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用var作用域版本，您可以看到变量在块外部存在。这是因为在幕后，`varScoped`的声明被提升到代码块的开头。使用代码的`let`作用域版本，`letScoped`仅在`for`循环内部作用域，因此一旦离开循环，`letScoped`就变为未定义。在使用`let`或`var`的选项时，我们倾向于始终使用`let`。有些情况下，您实际上会希望使用var作用域，但这种情况很少。
- en: 'We have built up a pretty complete model of how to build objects within JavaScript.
    However, objects are not the same thing as classes. Objects are instances of classes.
    If we want to create multiple instances of our `functionObject` object we''re
    out of luck. Attempting to do so will result in an error. In the case of Node.js
    the error will be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个相当完整的模型，说明了如何在JavaScript中构建对象。但是，对象并不等同于类。对象是类的实例。如果我们想创建多个`functionObject`对象的实例，我们就没那么幸运了。尝试这样做将导致错误。在Node.js的情况下，错误将如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The stack trace here shows an error in a module called `repl`. This is the read-execute-print
    loop that is loaded by default when starting Node.js.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的堆栈跟踪显示了一个名为`repl`的模块中的错误。这是在启动Node.js时默认加载的读取-执行-打印循环。
- en: 'Each time that a new instance is required, the object must be reconstructed.
    To get around this we can define the object using a function as can be seen here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要新实例时，都必须重建对象。为了避免这种情况，我们可以使用函数来定义对象，如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This syntax allows for a constructor to be defined and for new objects to be
    created from this function. Constructors without return values are functions that
    are called as an object is created. In JavaScript the constructor actually returns
    the object created. You can even assign internal properties using the constructor
    by making them part of the initial function like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许定义构造函数，并从该函数创建新对象。没有返回值的构造函数是在创建对象时调用的函数。在JavaScript中，构造函数实际上返回创建的对象。您甚至可以通过将它们作为初始函数的一部分来使用构造函数来分配内部属性，如下所示：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Build me a prototype
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我建立一个原型
- en: 'As previously mentioned, there was, until recently, no support for creating
    true classes in JavaScript. While ECMAScript-2015 brings some syntactic sugar
    to classes, the underlying object system is still as it has been in the past,
    so it remains instructive to see how we would have created objects without this
    sugar. Objects created using the structure in the previous section have a fairly
    major drawback: creating multiple objects is not only time consuming but also
    memory intensive. Each object is completely distinct from other objects created
    in the same fashion. This means that the memory used to hold the function definitions
    is not shared between all instances. What is even more fun is that you can redefine
    individual instances of a class without changing all of the instances. This is
    demonstrated in this code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，直到最近，JavaScript中没有支持创建真正的类。虽然ECMAScript-2015为类带来了一些语法糖，但底层对象系统仍然与过去一样，因此了解如何在没有这些语法糖的情况下创建对象仍然是有益的。使用上一节中的结构创建的对象有一个相当大的缺点：创建多个对象不仅耗时，而且占用内存。每个对象与以相同方式创建的其他对象完全不同。这意味着用于保存函数定义的内存不在所有实例之间共享。更有趣的是，您可以重新定义类的单个实例，而不更改所有实例。这在下面的代码中有所体现：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Altering the functionality of a single instance or really of any already defined
    object in this fashion is known as **monkey** **patching**. There is some division
    over whether or not this is a good practice. It can certainly be useful when dealing
    with library code but it adds great confusion. It is generally considered better
    practice to extend the existing class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式更改单个实例或任何已定义对象的功能称为**monkey** **patching**。关于这是否是一种良好的做法存在一些分歧。在处理库代码时，它肯定是有用的，但会增加很大的混乱。通常认为最好的做法是扩展现有类。
- en: 'Without a proper class system JavaScript, of course, has no concept of inheritance.
    However, it does have a prototype. At the most basic level an object in JavaScript
    is an associative array of keys and values. Each property or function on an object
    is simply defined as part of this array. You can even see this in action by accessing
    members of an object using array syntax as is shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在没有适当的类系统的情况下，JavaScript没有继承的概念。但是，它确实有原型。在JavaScript中，对象在最基本的层面上是键和值的关联数组。对象上的每个属性或函数都简单地定义为此数组的一部分。您甚至可以通过使用数组语法访问对象的成员来看到这一点，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Accessing members of an object using array syntax can be a very handy way to
    avoid using the eval function. For instance, if I had the name of the function
    I wanted to call in a string called `funcName` and I wanted to call it on an object,
    `obj1`, then I could do so by doing `obj1[funcName]()` instead of using a potentially
    dangerous call to eval. Eval allows for arbitrary code to be executed. Allowing
    this on a page means that an attacker may be able to enter malicious scripts on
    other people's browsers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组语法访问对象的成员可以是一种非常方便的方法，可以避免使用eval函数。例如，如果我有一个名为`funcName`的字符串，我想在对象`obj1`上调用它，那么我可以通过`obj1[funcName]()`来实现，而不是使用可能危险的eval调用。Eval允许执行任意代码。在页面上允许这样做意味着攻击者可能能够在其他人的浏览器上输入恶意脚本。
- en: 'When an object is created, its definition is inherited from a prototype. Weirdly
    each prototype is also an object so even prototypes have prototypes. Well, except
    for the object which is the top-level prototype. The advantage to attaching functions
    to the prototype is that only a single copy of the function is created; saving
    on memory. There are some complexities to prototypes but you can certainly survive
    without knowing about them. To make use of a prototype you need to simply assign
    functions to it as is shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象时，其定义是从原型继承的。奇怪的是，每个原型也是一个对象，因此甚至原型也有原型。好吧，除了作为顶级原型的对象。将函数附加到原型的优势在于只创建一个函数的副本；节省内存。原型有一些复杂性，但您肯定可以在不了解它们的情况下生存。要使用原型，您只需将函数分配给它，如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One thing to note is that only the functions are assigned to the prototype.
    Instance variables such as `name` are still assigned to the instance. As these
    are unique to each instance there is no real impact on the memory usage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，只有函数分配给原型。例如`name`这样的实例变量仍然分配给实例。由于这些对每个实例都是唯一的，因此对内存使用没有真正影响。
- en: In many ways a prototypical language is more powerful than a class-based inheritance
    model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，原型语言比基于类的继承模型更强大。
- en: 'If you make a change to the prototype of an object at a later date then all
    the objects which share that prototype are updated with the new function. This
    removes some of the concerns expressed about monkey typing. An example of this
    behavior is shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在以后更改对象的原型，则共享该原型的所有对象都将使用新函数进行更新。这消除了关于猴子打字的一些担忧。此行为的示例如下：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When building up objects you should be sure to take advantage of the prototype
    object whenever possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '在构建对象时，应确保尽可能利用原型对象。 '
- en: 'Now we know about prototypes there is an alternative approach to building objects
    in JavaScript and that is to use the `Object.create` function. This is a new syntax
    introduced in ECMAScript 5\. The syntax is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了原型，JavaScript中构建对象的另一种方法是使用`Object.create`函数。这是ECMAScript 5中引入的新语法。语法如下：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The create syntax will build a new object based on the given prototype. You
    can also pass in a `propertiesObject` object that describes additional fields
    on the created object. These descriptors consist of a number of optional fields:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create`语法将基于给定原型构建一个新对象。您还可以传递一个`propertiesObject`对象，该对象描述了创建的对象上的其他字段。这些描述符包括许多可选字段：
- en: '`writable`: This dictates whether the field should be writable'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable`：这决定了字段是否可写'
- en: '`configurable`: This dictates whether the files should be removable from the
    object or support further configuration after creation'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurable`：这决定了字段是否应该从对象中移除或在创建后支持进一步配置'
- en: '`enumerable`: This dictates whether the property can be listed during an enumeration
    of the object''s properties'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可枚举的：这决定了属性在对象属性枚举期间是否可以被列出
- en: '`value`: This dictates the default value of the field'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这决定了字段的默认值'
- en: It is also possible to assign a `get` and `set` functions within the descriptor
    that act as getters and setters for some other internal property.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在描述符中分配`get`和`set`函数，这些函数充当其他内部属性的获取器和设置器。
- en: 'Using `object.create` for our castle we can build an instance using `Object.create`
    like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`object.create`为我们的城堡，我们可以像这样使用`Object.create`构建一个实例：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You''ll notice that we explicitly define the `name` field. `Object.create`
    bypasses the constructor so the initial assignment we described in the preceding
    code won''t be called. You might also notice that writeable is set to `false`.
    The result of this is that the reassignment of `name` to `Highgarden` has no effect.
    The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们明确定义了`name`字段。`Object.create`绕过了构造函数，因此我们在前面的代码中描述的初始赋值不会被调用。您可能还注意到`writeable`设置为`false`。其结果是对`name`的重新分配对`Highgarden`没有影响。输出如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inheritance
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the niceties of objects is that they can be built upon to create increasingly
    complex objects. This is a common pattern, which is used for any number of things.
    There is no inheritance in JavaScript because of its prototypical nature. However,
    you can combine functions from one prototype into another.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的一个好处是可以构建更复杂的对象。这是一种常见模式，用于任何数量的事情。JavaScript中没有继承，因为它是原型性的。但是，您可以将一个原型中的函数组合到另一个原型中。
- en: 'Let''s say that we have a base class called `Castle` and we want to customize
    it into a more specific class called `Winterfell`. We can do so by first copying
    all of the properties from the `Castle` prototype onto the `Winterfell` prototype.
    This can be done like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`Castle`的基类，并且我们想将其定制为一个更具体的类`Winterfell`。我们可以通过首先将所有属性从`Castle`原型复制到`Winterfell`原型上来实现这一点。可以这样做：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course this is a very painful way to build objects. You''re forced to know
    exactly which functions the base class has to copy them. It can be abstracted
    in a rather naïve fashion like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是构建对象的一种非常痛苦的方式。您被迫准确知道基类有哪些函数需要复制它们。可以像这样天真地抽象化：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you are into object diagrams this shows how **Winterfell** extends **Castle**
    in this diagram:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对对象图表感兴趣，这显示了**Winterfell**在此图表中如何扩展**Castle**：
- en: '![Inheritance](img/00038.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Inheritance](img/00038.jpeg)'
- en: 'This can be used quite simply as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简单地使用如下：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We say that this is naïve because it fails to take into account a number of
    potential failure conditions. A fully-fledged implementation is quite extensive.
    The jQuery library provides a function called `extend` which implements prototype
    inheritance in a robust fashion. It is about 50 lines long and deals with deep
    copies and null values. The function is used extensively, internally in jQuery
    but it can be a very useful function in your own code. We mentioned that prototype
    inheritance is more powerful than the traditional methods of inheritance. This
    is because it is possible to mix and match bits from many base classes to create
    a new class. Most modern languages only support single inheritance: a class can
    have only one direct parent. There are some languages with multiple inheritance
    however, it is a practice that adds a great deal of complexity when attempting
    to decide which version of a method to call at runtime. Prototype inheritance
    avoids many of these issues by forcing selection of a method at assembly time.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说这是天真的，因为它未考虑到许多潜在的失败条件。一个完整的实现非常复杂。jQuery库提供了一个名为`extend`的函数，它以健壮的方式实现了原型继承。它大约有50行代码，处理深层复制和空值。这个函数在jQuery内部被广泛使用，但它也可以成为你自己代码中非常有用的函数。我们提到原型继承比传统的继承方法更强大。这是因为可以从许多基类中混合和匹配位来创建一个新类。大多数现代语言只支持单一继承：一个类只能有一个直接的父类。有一些语言支持多重继承，然而，这是一种在运行时决定调用哪个版本方法时增加了很多复杂性的做法。原型继承通过在组装时强制选择方法来避免许多这些问题。
- en: Composing objects in this fashion permits taking properties from two or more
    different bases. There are many times when this can be useful. For example a class
    representing a wolf might take some of its properties from a class describing
    a dog and some from another class describing a quadruped.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组合对象允许从两个或更多不同的基类中获取属性。有许多时候这是很有用的。例如，表示狼的类可能从描述狗的类和描述四足动物的另一个类中获取一些属性。
- en: By using classes built in this way we can meet pretty much all of the requirements
    for constructing a system of classes including inheritance. However inheritance
    is a very strong form of coupling. In almost all cases it is better to avoid inheritance
    in favor of a looser form of coupling. This will allow for classes to be replaced
    or altered with a minimum impact on the rest of the system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方式构建的类，我们几乎可以满足构建类系统的所有要求，包括继承。然而，继承是一种非常强的耦合形式。在几乎所有情况下，最好避免继承，而选择一种更松散的耦合形式。这将允许类在对系统的其余部分影响最小的情况下被替换或更改。
- en: Modules
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Now that we have a complete class system it would be good to address the global
    namespace discussed earlier. Again there is no first class support for namespaces
    but we can easily isolate functionality to the equivalent of a namespace. There
    are a number of different approaches to creating modules in JavaScript. We'll
    start with the simplest and add some functionality as we go along.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完整的类系统，很好地解决了之前讨论过的全局命名空间问题。同样，虽然JavaScript没有对命名空间的一流支持，但我们可以很容易地将功能隔离到等同于命名空间的功能中。在JavaScript中有许多不同的创建模块的方法。我们将从最简单的方法开始，并随着进展逐渐添加一些功能。
- en: 'To start we simply need to attach an object to the global namespace. This object
    will contain our root namespace. We''ll name our namespace `Westeros`; the code
    simply looks like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需将一个对象附加到全局命名空间。这个对象将包含我们的根命名空间。我们将命名我们的命名空间为`Westeros`；代码看起来就像这样：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This object is, by default, attached to the top level object so we need not
    do anything more than that. A typical usage is to first check if the object already
    exists and use that version instead of reassigning the variable. This allows you
    to spread your definitions over a number of files. In theory you could define
    a single class in each file and then bring them all together as part of the build
    process before delivering them to the client or using them in an application.
    The short form of this is:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象默认附加到顶层对象，所以我们不需要做更多的事情。一个典型的用法是首先检查对象是否已经存在，并使用该版本而不是重新分配变量。这允许您将定义分散在多个文件中。理论上，您可以在每个文件中定义一个单独的类，然后在交付给客户端或在应用程序中使用它们之前，将它们作为构建过程的一部分汇总在一起。这个简写形式是：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have the object, it is simply a question of assigning our classes as
    properties of that object. If we continue to use the `Castle` object then it would
    look like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了对象，就只是简单地将我们的类分配为该对象的属性。如果我们继续使用`Castle`对象，那么它看起来会像这样：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to build a hierarchy of namespaces that is more than a single level
    deep, that too is easily accomplished, as seen in this code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要构建一个超过单层深度的命名空间层次结构，也很容易实现，就像这段代码中所示的那样：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This class can be instantiated and used in a similar way to previous examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以像之前的例子一样被实例化和使用：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Of course with JavaScript there is more than one way to build the same code
    structure. An easy way to structure the preceding code is to make use of the ability
    to create and immediately execute a function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用JavaScript有多种方法来构建相同的代码结构。构建前面的代码的一种简单方法是利用创建并立即执行函数的能力：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code seems to be a bit longer than the previous code sample but I find
    it easier to follow due to its hierarchical nature. We can create a new castle
    using them in the same structure as shown in the preceding code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码似乎比之前的代码示例要长一些，但由于其分层结构，我觉得更容易理解。我们可以按照前面的代码所示的结构来创建一个新的城堡：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inheritance using this structure is also relatively easily done. If we were
    to define a `BaseStructure` class which was to be in the ancestor of all structures,
    then making use of it would look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构进行继承也相对容易。如果我们定义了一个`BaseStructure`类，它是所有结构的祖先，那么使用它会是这样的：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You''ll note that the base structure is passed into the `Castle` object when
    the closure is evaluated. The highlighted line of code makes use of a helper method
    called `__extends`. This method is responsible for copying the functions over
    from the base prototype to the derived class. This particular piece of code was
    generated from a TypeScript compiler which also, helpfully, generated an `extends`
    method which looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包被评估时，基本结构被传递给`Castle`对象。高亮代码行使用了一个名为`__extends`的辅助方法。这个方法负责将函数从基本原型复制到派生类。这段特定的代码是由TypeScript编译器生成的，它还生成了一个看起来像这样的`extends`方法：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can continue the rather nifty closure syntax we''ve adopted for a class
    to implement an entire module. This is shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用我们为类采用的相当巧妙的闭包语法来实现整个模块。这在这里展示：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Within this structure you can see the same code for creating modules that we
    explored earlier. It is also relatively easy to define multiple classes inside
    a single module. This can be seen in this code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，你可以看到我们之前探讨过的创建模块的相同代码。在一个模块内部定义多个类也相对容易。这可以在这段代码中看到：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The highlighted code creates a second class inside of the module. It is also
    perfectly permissible to define one class in each file. Because the code checks
    to get the current value of `Westeros` before blindly reassigning it, we can safely
    split the module definition across multiple files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮代码在模块内创建了第二个类。在每个文件中定义一个类也是完全允许的。因为代码检查了获取`Westeros`当前值之后才盲目重新分配它，所以我们可以安全地将模块定义分成多个文件。
- en: The last line of the highlighted section shows exposing the class outside of
    the closure. If we want to make private classes that are only available within
    the module then we only need to exclude that line. This is actually known as the
    revealing module pattern. We only reveal the classes that need to be globally
    available. It is a good practice to keep as much functionality out of the global
    namespace as possible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分的最后一行显示了在闭包之外暴露类。如果我们想创建只在模块内部可用的私有类，那么我们只需要排除那一行。这实际上被称为揭示模块模式。我们只暴露需要全局可用的类。尽可能将功能保持在全局命名空间之外是一个很好的做法。
- en: ECMAScript 2015 classes and modules
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 2015类和模块
- en: 'We''ve seen so far that it is perfectly possible to build classes and even
    modules in pre ECMAScript -2015 JavaScript. The syntax is, obviously, a bit more
    involved than in a language such as C# or Java. Fortunately ECMAScript-2015, brings
    support for some syntactic sugar for making classes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到在ECMAScript-2015之前的JavaScript中完全可以构建类甚至模块。显然，语法比如C#或Java等语言更复杂。幸运的是，ECMAScript-2015为创建类提供了一些语法糖的支持：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'ECMAScript-2015 also brings a well thought out module system for JavaScript.
    There''s also syntactic sugar for creating modules which looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript-2015还为JavaScript带来了一个经过深思熟虑的模块系统。还有一些用于创建模块的语法糖，看起来像这样：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As modules can contain functions they can, of course, contain classes. ECMAScript-2015
    also defines a module import syntax and support for retrieving modules from remote
    locations. Importing a module looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块可以包含函数，当然也可以包含类。ECMAScript-2015还定义了一个模块导入语法和支持从远程位置检索模块。导入一个模块看起来像这样：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Some of this syntactic sugar is available in any environment which has full
    ECMAScript-2015 support. At the time of writing, all major browser vendors have
    very good support for the class portion of ECMAScript-2015 so there is almost
    no reason not to use it if you don't have to support ancient browsers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这种语法糖在任何具有完整ECMAScript-2015支持的环境中都是可用的。在撰写本文时，所有主要浏览器供应商对ECMAScript-2015的类部分都有很好的支持，因此如果不必支持古老的浏览器，几乎没有理由不使用它。
- en: Best practices and troubleshooting
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和故障排除
- en: In an ideal world everybody would get to work on greenfield projects where they
    can put in standards right from the get go. However that isn't the case. Frequently
    you may find yourself in a situation where you have a bunch of non-modular JavaScript
    code as part of a legacy system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，每个人都可以在绿地项目上工作，在那里他们可以从一开始就制定标准。然而，情况并非如此。经常情况下，你可能会发现自己处于一个遗留系统的一部分，有一堆非模块化的JavaScript代码的情况下。
- en: In these situations it may be advantageous to simply ignore the non-modular
    code until there is an actual need to upgrade it. Despite the popularity of JavaScript,
    much of the tooling for JavaScript is still immature making it difficult to rely
    on a compiler to find errors introduced by JavaScript refactoring. Automatic refactoring
    tools are also complicated by the dynamic nature of JavaScript. However, for new
    code, proper use of modular JavaScript can be very helpful to avoid namespace
    conflicts and improve testability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，忽略非模块化的代码直到真正需要升级它可能是有利的。尽管JavaScript很受欢迎，但JavaScript的许多工具仍然不够成熟，这使得很难依赖编译器来找出JavaScript重构引入的错误。自动重构工具也受到JavaScript动态特性的影响而变得复杂。然而，对于新代码，正确使用模块化的JavaScript可以非常有助于避免命名空间冲突并提高可测试性。
- en: How to arrange JavaScript is an interesting question. From a web perspective
    I have taken the approach of arranging my JavaScript in line with the web pages.
    So each page has an associated JavaScript file, which is responsible for the functionality
    of that page. In addition, components which are common between pages, say a grid
    control, are placed into a separate file. At compile time all the files are combined
    into a single JavaScript file. This helps strike a balance between having a small
    code file with which to work and reducing the number of requests to the server
    from the browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安排JavaScript是一个有趣的问题。从网页的角度来看，我采取了将我的JavaScript与网页进行对应的方法。因此，每个页面都有一个关联的JavaScript文件，负责该页面的功能。此外，页面之间共同的组件，比如一个网格控件，被放置在一个单独的文件中。在编译时，所有文件都被合并成一个单独的JavaScript文件。这有助于在工作时保持一个小的代码文件，并减少浏览器向服务器发送请求的次数。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It has been said that there are only two really hard things in computing science.
    What those issues are varies depending on who is speaking. Frequently it is some
    variation of cache invalidation and naming. How to organize your code is a large
    part of that naming problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说计算机科学中只有两件真正困难的事情。这些问题是什么取决于说话者。经常是一些与缓存失效和命名有关的变体。如何组织你的代码是命名问题的一个很大的部分。
- en: As a group we seem to have settled quite firmly on the idea of namespaces and
    classes. As we've seen, there is no direct support for either of these two concepts
    in JavaScript. However there are myriad ways to work around the problem, some
    of which actually provide more power than one would get through a traditional
    namespace/class system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个团体，我们似乎已经相当坚定地接受了命名空间和类的概念。正如我们所见，JavaScript中没有直接支持这两个概念。然而，有无数种方法可以解决这个问题，其中一些实际上提供的功能比传统的命名空间/类系统更强大。
- en: The primary concern with JavaScript is to avoid polluting the global namespace
    with a large number of similarly named, unconnected objects. Encapsulating JavaScript
    into modules is a key step on the road toward writing maintainable and reusable
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的主要问题是要避免用大量名称相似但不相关的对象污染全局命名空间。将JavaScript封装成模块是朝着编写可维护和可重用代码的关键步骤。
- en: As we move forward we'll see that many of the patterns which are quite complex
    arrangements of interfaces become far simpler in the land of JavaScript. Prototype-based
    inheritance, which seems difficult at the outset, is a tremendous tool for aiding
    in the simplification of design patterns.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的前进，我们会发现许多复杂的接口安排在JavaScript领域中变得简单得多。基于原型的继承，起初似乎很困难，但却是简化设计模式的巨大工具。
