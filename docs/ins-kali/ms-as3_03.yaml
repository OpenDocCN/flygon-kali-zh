- en: UI Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI开发
- en: In the previous chapter, we saw how Android Studio provides many invaluable
    tools for designing layouts quickly and simply. However, we only concerned ourselves
    with the design of static UIs. This, of course, is an essential first step, but
    our interfaces can, and should, be dynamic. And, according to material design
    guidelines, user interactions should be illustrated graphically using movement
    and color to intuitively demonstrate the action being performed, such as the ripple
    animations that result from tapping on a button.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到安卓工作室为快速简单地设计布局提供了许多宝贵的工具。然而，我们只关注了静态UI的设计。当然，这是一个必不可少的第一步，但我们的界面可以，也应该是动态的。根据材料设计指南，用户交互应该通过运动和颜色直观地展示，比如点击按钮时产生的涟漪动画。
- en: To see how this is done, we need to look at a practical example and start building
    a simple, but functional, application. But first, we will examine one or two more
    ways of applying the look and feel we want, and Android users expect, to our designs.
    This process is largely assisted by the use of support libraries, in particular,
    the AppCompat and Design libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何做到这一点，我们需要看一个实际的例子，并开始构建一个简单但功能的应用程序。但首先，我们将研究一两种应用我们想要的外观和感觉的方式，并且安卓用户期望将其应用到我们的设计中。这个过程在很大程度上得到了支持库的帮助，特别是AppCompat和Design库。
- en: We will begin the chapter by looking at how Android Studio facilitates the implementation
    of Material design with the material-based visual theme editor as well as the
    design support library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看安卓工作室如何通过基于材料的视觉主题编辑器和设计支持库来实现材料设计开始本章。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Generate material styles and themes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成材料样式和主题
- en: Use XML fonts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML字体
- en: Create XML font families
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建XML字体系列
- en: Use basic code completion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本代码完成
- en: Apply a coordinator layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用协调布局
- en: Coordinate design components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调设计组件
- en: Create a collapsing app bar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可折叠的应用栏
- en: Deploy raw resources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署原始资源
- en: Use the percent support library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用百分比支持库
- en: We saw in the previous chapter that, when sizing and moving the screen elements
    of a constraint layout using the design editor,  our views tend to stick to a
    particular set of dimensions. These are selected according to Material design
    guidelines. In case you are unaware, Material is a design language, stipulated
    by Google and based on traditional design and animation techniques, intended to
    clean up user interfaces by communicating the process through movement and position.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中看到，当使用设计编辑器调整约束布局的屏幕元素的大小和移动时，我们的视图往往会粘在一组特定的尺寸上。这些尺寸是根据Material设计指南选择的。如果您不知道，Material是一种设计语言，由谷歌规定，基于传统的设计和动画技术，旨在通过移动和位置来清理用户界面的过程。
- en: Material design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料设计
- en: Although Material design is by no means essential, and can be ignored entirely
    if you are developing full-screen apps such as games, which often come with their
    own design rules, it is nevertheless an elegant design paradigm and is widely
    recognized and understood by the user base.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Material设计并不是必不可少的，如果您正在开发全屏应用程序，比如游戏，它通常有自己的设计规则，可以完全忽略它，但它仍然是一种优雅的设计范式，并且被用户群广泛认可和理解。
- en: One very good reason for implementing Material is that many of its features,
    such as card views and sliding drawers, can be applied with great ease, thanks
    to the associated support libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实施材料的一个非常好的理由是，许多其特性，如卡片视图和滑动抽屉，都可以通过相关的支持库非常容易地应用。
- en: One of the first design decisions we need to take is what color scheme, or theme,
    we want to apply to our app. There are one or two material guidelines regarding
    the shade and contrast of our themes. Fortunately, Android Studio's Theme Editor
    makes generating material-compliant themes very simple indeed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一个设计决定之一是，我们想要将什么颜色方案或主题应用到我们的应用程序中。关于我们主题的色调和对比度，有一两个材料指南。幸运的是，安卓工作室的主题编辑器确实非常简单地生成符合材料的主题。
- en: Android styles
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓样式
- en: 'Graphical properties, such as background color, text size, and elevation, can
    all be set individually on any UI component. It often makes sense to group properties
    together into a style. Android stores such styles in the values directory as XML
    in the `styles.xml` file. An example of this is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图形属性，如背景颜色、文本大小和高程，都可以在任何UI组件上单独设置。将属性组合到一起成为一个样式通常是有意义的。安卓将这些样式存储在values目录中的`styles.xml`文件中的XML中。一个例子如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Styles, such as this, can be applied to views and widgets simply and without
    having to specify each property, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的样式可以简单地应用到视图和小部件上，而无需指定每个属性，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is quite possible to create any style from scratch by defining all its properties,
    but it is far more practical to take an existing style and modify only the properties
    we wish to change. This is done by setting the `parent` property, which can be
    seen in the preceding example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以通过定义所有属性来从头开始创建任何样式，但更实际的做法是从现有样式中继承并仅修改我们希望更改的属性。这是通过设置`parent`属性来完成的，可以在前面的例子中看到。
- en: 'We can also inherit from our own styles and without having to set a parent
    property, for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以继承自我们自己的样式，而无需设置父属性，例如：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Previously, we created a new resource file, but we could just as easily add
    a new `<style>` node to the existing `styles.xml` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个新的资源文件，但我们也可以将一个新的`<style>`节点添加到现有的`styles.xml`文件中。
- en: 'If you are new to Android Studio, you will have noticed the code completion
    drop-downs that appear as you are typing, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Android Studio的新手，您会注意到代码完成下拉框在您输入时出现，如下面的屏幕截图所示：
- en: '![](img/3d5fccfd-3aa0-40ec-90c3-dad520a25a92.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5fccfd-3aa0-40ec-90c3-dad520a25a92.png)'
- en: Code completion
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成
- en: 'This is an invaluable tool and we will look at it in more detail later on.
    For now, it is useful to know that code completion exists in three levels, as
    outlined briefly here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有价值的工具，我们将在稍后更详细地看一下。现在，知道代码完成存在三个级别是有用的，如此简要地概述：
- en: '**Basic**: *Ctrl* + Space; Displays possibilities for the next word.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本**：*Ctrl* + 空格; 显示下一个单词的可能性。'
- en: '**Smart**: *Ctrl*  + *Shift* + Space; Context-sensitive suggestions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能**：*Ctrl* + *Shift* + 空格; 上下文敏感建议。'
- en: '**Statement**: *Ctrl*  + *Shift* + *Enter*; Completes whole statements.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**：*Ctrl* + *Shift* + *Enter*; 完成整个语句。'
- en: Calling basic and smart code completion twice in a row will broaden the scope
    of suggestions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 连续两次调用基本和智能代码完成将扩大建议的范围。
- en: Creating and applying styles like this is a great way of fine-tuning an app's
    appearance without having to do a great deal of extra coding, but there are also
    times when we want to apply a look and feel to an entire application, and for
    this, we use themes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和应用这样的样式是微调应用程序外观的好方法，而无需进行大量额外的编码，但有时我们也希望将外观和感觉应用于整个应用程序，为此，我们使用主题。
- en: Material themes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料主题
- en: When creating an overall theme for an app, we have two opposing goals. On the
    one hand, we want our app to stand out from the others and be easily recognized;
    on the other, we want it to comply with the user's expectations of the platform and
    we want them to find the controls familiar and simple to use. The Theme Editor
    strikes a good compromise between individuality and conformity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序创建整体主题时，我们有两个相反的目标。一方面，我们希望我们的应用程序脱颖而出，并且容易被识别；另一方面，我们希望它符合用户对平台的期望，并且希望他们发现控件熟悉且简单易用。主题编辑器在个性和一致性之间取得了很好的折衷。
- en: 'At their simplest, material themes take two or three colors and apply these
    throughout an application to give it a consistent feel and this is probably the
    major benefit of using themes. The color selected as an accent will be used to
    color checkboxes and highlight text and is generally chosen to stand out and draw
    attention. Primary colors, on the other hand, will be applied to toolbars and,
    unlike the earlier versions of Android, to the status bar and navigation bar.
    For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，材料主题采用两种或三种颜色，并在整个应用程序中应用这些颜色，以使其具有一致的感觉，这可能是使用主题的主要好处。作为重点选择的颜色将用于着色复选框和突出显示文本，并且通常选择以突出显示并吸引注意。另一方面，主要颜色将应用于工具栏，并且与早期版本的Android不同，还将应用于状态栏和导航栏。例如：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This enables us to control the color scheme of the entire screen when our app
    is running, avoiding ugly clashes with any native controls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在应用程序运行时控制整个屏幕的颜色方案，避免与任何本机控件发生丑陋的冲突。
- en: The general rule of thumb for selecting these colors is to pick two shades of
    the same color for the primary values and a contrasting, but complementary, color
    for the accent. Google is a little more precise about which shades and which colors
    to use and there are no hard and fast rules to decide which colors contrast nicely
    with others. There are, however, some useful guidelines to help us, but first
    we will take a look at Google's material palette.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这些颜色的一般经验法则是选择主要值的两种色调和一个对比但互补的颜色作为重点。谷歌对要使用哪些色调和颜色更加精确，没有硬性规定来决定哪些颜色与其他颜色搭配得好。然而，有一些有用的指南可以帮助我们，但首先我们将看一下谷歌的材料调色板。
- en: The Theme Editor
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题编辑器
- en: 'Google prescribes a series of 20 different hues to be used in Android apps
    and Material design web pages. Each hue comes in ten shades, as seen in the following
    examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌规定在Android应用程序和Material设计网页中使用20种不同的色调。每种色调有十种阴影，如下例所示：
- en: '![](img/79d9278b-aebe-4f18-955e-a21a060a34e0.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d9278b-aebe-4f18-955e-a21a060a34e0.png)'
- en: Material palettes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 材料调色板
- en: The full palette along with downloadable swatches can be found at: [material.io/guidelines/style/color.html#color-color-palette](http://material.io/guidelines/style/color.html#color-color-palette).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的调色板以及可下载的样本可以在以下网址找到：[material.io/guidelines/style/color.html#color-color-palette](http://material.io/guidelines/style/color.html#color-color-palette)。
- en: Material guidelines recommend that we use shades of 500 and 700 for our primary
    and dark primary colors and 100 for the accent. Fortunately, we do not have to
    concern ourselves overly with these numbers, as there are tools to help us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 材料指南建议我们使用500和700的阴影作为我们的主要和深色主要颜色，以及100作为重点。幸运的是，我们不必过分关注这些数字，因为有工具可以帮助我们。
- en: The most useful of these tools is the Theme Editor. This is another graphical
    editor and can be accessed from the main menu with Tools | Android | Theme Editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中最有用的是主题编辑器。这是另一个图形编辑器，可以从主菜单中的工具 | Android | 主题编辑器中访问。
- en: Once you open the Theme Editor, you will see that it is divided into two sections.
    To the right, we have a list of color properties, and to the left, a panel displaying
    the effect these selections have on various interface components, giving us a
    handy preview and the opportunity to try out all the manner of combinations quickly
    and intuitively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开主题编辑器，您将看到它分为两个部分。右侧是颜色属性列表，左侧是显示这些选择对各种界面组件的影响的面板，为我们提供了方便的预览和快速直观地尝试各种组合的机会。
- en: As you can see, there are more than just two primary colors and an accent. There
    are in fact 12, covering text and background colors, as well as alternatives for
    both dark and light themes. These are set, by default, to those of the parent
    theme declared in the `styles.xml` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，不仅有两种主要颜色和一个重点。实际上有12种，涵盖文本和背景颜色，以及深色和浅色主题的替代方案。这些默认设置为`styles.xml`文件中声明的父主题的颜色。
- en: 'To quickly set up a customized material theme, follow the steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速设置自定义材料主题，请按照以下步骤进行：
- en: Start a new Studio project or open one that you wish to apply a theme to.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的Studio项目或打开一个您希望应用主题的项目。
- en: Open the Theme Editor from the Tools | Android menu.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具 | Android菜单中打开主题编辑器。
- en: Select the solid color block to the left of the colorPrimary field.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择colorPrimary字段左侧的实色块。
- en: '![](img/3fb9816f-7996-405a-8e58-b72b5db26543.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb9816f-7996-405a-8e58-b72b5db26543.png)'
- en: Select one of the solid color blocks in the lower right corner of the Resources
    dialog and click OK.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源对话框的右下角选择一个纯色块，然后单击“确定”。
- en: Open the dialog for colorPrimaryDark and select the only suggested block on
    the right-hand side below the color selection options. It will be the same hue
    with a shade of 700.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开colorPrimaryDark对话框，然后在右侧的颜色选择选项下选择唯一的建议块。它将是相同的色调，但是700的阴影。
- en: Select the Accent property and then choose from one of the suggested colors.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择重点属性，然后从建议的颜色中选择一个。
- en: These choices can be immediately seen in the preview pane on the left-hand side
    of the editor and also from the Layout Editor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择可以立即在编辑器左侧的预览窗格中看到，也可以从布局编辑器中看到。
- en: As you can see, these colors are not declared directly but rather are references
    to the values specified in the `values/colors.xml` file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些颜色并不是直接声明的，而是引用了“values/colors.xml”文件中指定的值。
- en: Not only does the editor help create material themes by suggesting acceptable
    colors, it also helps if we want to select a color of our own choice. Clicking
    anywhere on the color table in the Select Resource window will produce a prompt
    to select closest material color.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器不仅帮助通过建议可接受的颜色来创建材料主题，还可以帮助我们选择自己选择的颜色。在“选择资源”窗口的颜色表中的任何位置单击都会提示选择最接近的材料颜色。
- en: 'When it comes to selecting appropriate colors for the accent, there are several
    schools of thought. According to color theory, there are several ways to create
    a harmonic complement to any color using a color wheel, such as the following
    one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择重点颜色时，有几种思路。根据色彩理论，可以使用色轮创建与任何颜色和谐互补色的几种方法，例如以下色轮：
- en: '![](img/cdbe5c7e-21de-4645-b7c7-c7d5bcdc50d2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdbe5c7e-21de-4645-b7c7-c7d5bcdc50d2.png)'
- en: A RYB color wheel displaying harmonic complements
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RYB色轮显示和谐互补色
- en: The simplest way to calculate an harmonic color is to take the one opposite
    to ours on the wheel (known as the direct complement). However, those of artistic
    vision consider this somewhat obvious and lacking in subtlety, and prefer what
    is known as a split complement. This equates to selecting from those colors that
    closely neighbor the direct complement, as shown previously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和谐颜色的最简单方法是取色轮上与我们相对的颜色（称为直接互补色）。然而，具有艺术视野的人认为这有些显而易见，缺乏微妙之处，并更喜欢所谓的分裂互补色。这意味着从那些与直接互补色紧密相邻的颜色中进行选择，如前所示。
- en: The Theme Editor suggests several split complements beneath the color selector
    when the accent color is being selected. However, it also suggests analogous harmonies.
    These are colors that lie close to the original, and although they look nice together,
    these are not good choices for an accent, as there is little contrast and the
    user may well miss important hints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择重点颜色时，主题编辑器在颜色选择器下方建议几种分裂互补色。然而，它也建议类似的和谐色。这些颜色与原色接近，虽然看起来很好，但不适合作为重点颜色的选择，因为对比度小，用户可能会错过重要的提示。
- en: 'There is a very pleasing JetBrains plugin available that will apply a material
    theme to the IDE itself. It can be found at: [plugins.jetbrains.com/androidstudio/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常令人愉悦的JetBrains插件可用，可以将材料主题应用于IDE本身。它可以在以下网址找到：[plugins.jetbrains.com/androidstudio/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui)。
- en: As we have just seen, the Theme Editor is very helpful when it comes to generating
    material themes. There is also a growing number of online tools that generate
    complete XML material themes with a few clicks. MaterialUps can be found at: [www.materialpalette.com](http://www.materialpalette.com).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，主题编辑器在生成材料主题时非常有帮助。还有越来越多的在线工具可以通过几次点击生成完整的XML材料主题。MaterialUps可以在以下网址找到：[www.materialpalette.com](http://www.materialpalette.com)。
- en: 'This will produce the following `colors.xml` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下“colors.xml”文件：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At first sight, this looks like a quick way to select many of a theme''s properties,
    but if you look at the text colors, you will see that they are shades of gray.
    According to Material design guidelines, this is incorrect, and the alpha channel
    should be used to create shades using transparency. This makes no difference when
    the text is on a plain background, but when placed over imagery grayscale text
    can be harder to read particularly the lighter shades, as demonstrated here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来像是选择主题属性的快速方法，但是如果查看文本颜色，你会发现它们是灰色的阴影。根据材料设计指南，这是不正确的，应该使用alpha通道使用透明度创建阴影。当文本放在纯色背景上时，这没有什么区别，但当放在图像上时，灰度文本可能更难阅读，特别是浅色阴影，如此所示：
- en: '![](img/c741db61-a0df-40d4-9a33-0cb0cc0293d1.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c741db61-a0df-40d4-9a33-0cb0cc0293d1.png)'
- en: Grayscale vs transparency
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度与透明度
- en: Android themes allow us to define the appearance of our applications in terms
    of colors, but often we will want to do more than just customize the color of
    our text, and being able to include fonts in a similar way to other resources
    is a recent and extremely useful addition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Android主题允许我们以颜色的形式定义应用程序的外观，但通常我们希望做的不仅仅是自定义文本的颜色，能够以与其他资源类似的方式包含字体是最近非常有用的补充。
- en: XML fonts
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML字体
- en: As of API level 26, it has been possible to include fonts in a project as XML
    resources in the `res` directory. This feature has simplified the task of using
    nondefault fonts in an application as well as bringing the process into line with
    other resource management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别26开始，可以将字体作为XML资源包含在“res”目录中。这一特性简化了在应用程序中使用非默认字体的任务，并使该过程与其他资源管理保持一致。
- en: 'Adding XML fonts is remarkably simple, as the following exercise demonstrates:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加XML字体非常简单，如下练习所示：
- en: Right-click on the `res` directory and select New | Android resource directory.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“res”目录，然后选择“新建|Android资源目录”。
- en: Select font from the Resource type drop-down and click on OK.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源类型下拉菜单中选择字体，然后单击“确定”。
- en: Right-click on the newly created font folder and select Show in Explorer.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的字体文件夹，然后选择在资源管理器中显示。
- en: Rename your font files so that they only contain permissible characters. For
    example, `times_new_roman.ttf` not `TimesNewRoman.ttf`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名您的字体文件，使其只包含可允许的字符。例如，`times_new_roman.ttf`而不是`TimesNewRoman.ttf`。
- en: Place your selected fonts in the font directory.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所选字体放入字体目录中。
- en: These can now be previewed directly from the editor.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以直接从编辑器中预览这些。
- en: '![](img/6bb1077d-554b-40f9-b5f3-b89139305ce1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bb1077d-554b-40f9-b5f3-b89139305ce1.png)'
- en: XML fonts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: XML字体。
- en: 'Using these fonts in a layout is even simpler than adding them as resources.
    Simply use the `fontFamily` attribute, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局中使用这些字体甚至比将它们添加为资源更简单。只需使用`fontFamily`属性，如下所示：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When working with fonts, it is common to want to emphasize words in various
    ways, such as using a bolder typeface or italicizing text. Rather than relying
    on a separate font for each of these versions, it is more convenient to be able
    to refer to font groups, or families. Simply right-click on your `font` folder
    and select New | Font resource file. This will create an empty font family file,
    which can then be filled out along the following lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字体时，通常希望以各种方式强调单词，比如使用更粗的字体或使文本变斜体。与其为每个版本依赖不同的字体，更方便的做法是能够引用字体组或字体系列。只需右键单击您的`font`文件夹，然后选择新建|字体资源文件。这将创建一个空的字体系列文件，然后可以按照以下方式填写：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is, of course, a lot more to a design language than selecting the right
    colors and fonts. There are conventions regarding spacing and proportion and,
    usually, a number of specially designed screen components. In the case of material,
    these components take the form of widgets and layouts, such as FABs and sliding
    drawers. These do not come as part of the native SDK but are included in the design
    support library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，设计语言远不止于选择正确的颜色和字体。关于间距和比例有惯例，通常还有一些特别设计的屏幕组件。在材料的情况下，这些组件采用小部件和布局的形式，例如FAB和滑动抽屉。这些不是作为原生SDK的一部分提供的，而是包含在设计支持库中。
- en: The design library
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计库
- en: As mentioned, the design support library provides widgets and views commonly
    found in material apps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，设计支持库提供了在材料应用程序中常见的小部件和视图。
- en: 'As you will know, the design library, like other support libraries, needs to
    be included as a gradle dependency in the module level `build.gradle` file, as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，设计库和其他支持库一样，需要在模块级`build.gradle`文件中作为gradle依赖项包含，如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although it is always useful to understand how things are done, there is, in
    fact, a great shortcut for adding a support library as a project dependency. Open
    the Project Structure dialog from the File menu, and select your module and the
    Dependencies tab.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解事情是如何做的总是有用的，但实际上，有一个很好的快捷方式可以将支持库添加为项目依赖项。从文件菜单中打开项目结构对话框，然后选择您的模块和依赖项选项卡。
- en: '![](img/27b24fa4-b5ac-4490-937b-f8f2fced5073.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27b24fa4-b5ac-4490-937b-f8f2fced5073.png)'
- en: The project structure dialog
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构对话框
- en: You can select the library you are after by clicking on the Add icon in the
    top right corner and selecting Library dependency from the drop-down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击右上角的添加图标并从下拉菜单中选择库依赖项来选择您想要的库。
- en: The project structure dialog can be summoned with the *Ctrl* + *Alt* + *Shift*
    + *S* keys.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*Ctrl* + *Alt* + *Shift* + *S*键来召唤项目结构对话框。
- en: There are two other advantages to using this method. Firstly, the IDE will automatically
    rebuild the project, and secondly, it will always import the most recent revision.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法还有另外两个优点。首先，IDE将自动重建项目，其次，它将始终导入最新的修订版本。
- en: Many developers preempt future revisions by using a plus sign, as follows: `compile
    'com.android.support:design:25.1.+'`. This has the effect of applying future minor
    revisions. However, it is not always guaranteed to work and can cause crashes,
    and it is wiser to keep versions up-to-date manually, even if this means publishing
    more updates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员通过使用加号来预防未来的修订，如下所示：`compile 'com.android.support:design:25.1.+'`。这样可以应用未来的次要修订。但是，这并不总是保证有效，并且可能会导致崩溃，因此最好手动保持版本最新，即使这意味着发布更多更新。
- en: As well as importing the design library, if you are planning on developing a
    material app, you will most likely want the `CardView` and `RecyclerView` libraries
    as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入设计库之外，如果您计划开发材料应用程序，您很可能还需要`CardView`和`RecyclerView`库。
- en: The best way to find your way around the IDE is to work through a practical
    example. Here, we will put together a simple weather app. It won't be at all complex,
    but it will take us through each stage of application development and it will
    adhere to the Material design guidelines.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉IDE的最佳方法是通过实际示例进行操作。在这里，我们将制作一个简单的天气应用程序。它不会很复杂，但它将带领我们完成应用程序开发的每个阶段，并且将遵循材料设计准则。
- en: The coordinator layout
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调布局
- en: The design library provides three layout classes. There is one for designing
    tabular activities and one for toolbars, but the most important layout is `CoordinatorLayout`,
    which acts as a material-aware container, automatically performing many material
    tricks, such as expanding headers when a user scrolls to the top of a list or
    ensuring a FABs slides out of the way when a snack bar pops up over it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设计库提供了三个布局类。有一个用于设计表格活动，一个用于工具栏，但最重要的布局是`CoordinatorLayout`，它充当材料感知容器，自动执行许多材料技巧，例如当用户滚动到列表顶部时扩展标题，或者在弹出的小吃栏出现时确保FAB滑出。
- en: 'The coordinator layout should be placed as the root layout of an activity and
    would typically look like the following lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协调布局应放置在活动的根布局中，并且通常看起来像以下行：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The property `fitsSystemWindows` is particularly useful, as it sets the status
    bar to partially transparent. This allows our design to dominate native controls
    without hiding them completely as well as avoiding any clashes with system colors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`fitsSystemWindows`特别有用，因为它将状态栏设置为部分透明。这样可以使我们的设计主导本机控件，而不会完全隐藏它们，同时避免与系统颜色发生冲突。
- en: '![](img/bb5d710f-3e6e-4f7f-b6cb-129f809aedd1.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb5d710f-3e6e-4f7f-b6cb-129f809aedd1.png)'
- en: Drawing behind the status bar
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态栏后面绘制
- en: It is also possible to combine `fitsSystemWindows` with our own choice of color
    using `colorPrimaryDark` to assign the status bar color.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`colorPrimaryDark`来分配状态栏的颜色，将`fitsSystemWindows`与我们自己选择的颜色结合起来。
- en: The navigation bar's color can also be changed with the `navigationBarColor`
    attribute but this is not advisable, as devices with soft navigation controls
    are becoming rarer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏的颜色也可以使用`navigationBarColor`属性进行更改，但这并不建议，因为具有软导航控件的设备正在变得越来越少。
- en: '`CoordinatorLayout` is very similar to `FrameLayout` with one important exception.
    The coordinator layout can take direct control of its children using the `CoordinatorLayout.Behavior`
    class. The best way to see how this works is with an example.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoordinatorLayout`与`FrameLayout`非常相似，但有一个重要的例外。协调布局可以使用`CoordinatorLayout.Behavior`类直接控制其子项。最好的方法是通过一个例子来看看它是如何工作的。'
- en: Snackbars and Floating Action Buttons
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snackbar和浮动操作按钮
- en: Snackbars and **Floating Action Buttons**(**FABs**) are two of the most recognizable
    material widgets. Although not entirely replacing the toast widget, snackbars
    offer a more sophisticated form of activity notification, allowing controls and
    media rather than just text, which was the case for toasts. FABs perform the same
    function as conventional buttons but use their position to indicate their function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Snackbar和**浮动操作按钮**（**FABs**）是最具代表性的Material小部件之一。尽管它并不完全取代toast小部件，但Snackbar提供了一种更复杂的活动通知形式，允许控件和媒体而不仅仅是文本，而这是toast的情况。FABs执行与传统按钮相同的功能，但使用它们的位置来指示它们的功能。
- en: 'Without a coordinator layout to control behavior, `Snackbar` rising from the
    bottom of the screen would obscure any views or widgets behind it. It would be
    far preferable if the widget were to slide gracefully out of the way, something
    you will have seen often in well designed material apps. The following exercise
    explains how this is done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有协调布局来控制行为，`Snackbar`从屏幕底部升起会遮挡其后的任何视图或小部件。如果小部件能够优雅地滑出去，这将更可取，这是你在设计良好的Material应用中经常看到的情况。以下练习解释了如何实现这一点：
- en: Start a new project in Android Studio.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中开始一个新项目。
- en: 'Replace the root layout of the main activity with `CoordinatorLayout` here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里用`CoordinatorLayout`替换主活动的根布局：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following button:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下按钮：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is followed by `Snackbar`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着是`Snackbar`：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the main activity Java file and extend the class declaration to implement
    a click listener, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开主活动的Java文件，并扩展类声明以实现点击监听器，如下所示：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate an error and a red light bulb (known as a quick fix) will
    appear.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个错误，然后会出现一个红色的灯泡（称为快速修复）。
- en: '![](img/9d50dbb5-d39a-4ab4-a132-302acbc0fa43.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d50dbb5-d39a-4ab4-a132-302acbc0fa43.png)'
- en: Quick fix
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复
- en: Select Implement methods to add `OnClickListener`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择实现方法以添加`OnClickListener`。
- en: 'Add the following fields to the class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下字段：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create references for these components in the `onCreate()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中为这些组件创建引用：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Associate the button with the listener, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮与监听器关联，如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then complete the listener method, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按照以下方式完成监听器方法：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code can now be tested on an emulator or a real device. Clicking the button
    will display `Snackbar` temporarily, sliding the FAB out of the way as it does
    so.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在模拟器或真实设备上测试这段代码。单击按钮将临时显示`Snackbar`，并将FAB滑开以便显示。
- en: '`Snackbar`, in the previous demonstration, behaves exactly like a toast, but
    `Snackbar` is `ViewGroup` and not a view like the toast; as a layout, it can act
    as a container. To see how this is done, replace the previous listener method
    with the one here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Snackbar`在之前的演示中的行为与toast完全相同，但`Snackbar`是`ViewGroup`而不是像toast那样的视图；作为布局，它可以充当容器。要查看如何实现这一点，请用以下方法替换之前的监听器方法：'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The way the FAB moves out of the way of `Snackbar` is handled automatically
    by the parent coordinator layout, and this is the case for all design library
    widgets and ViewGroups. We will see shortly how we have to define our own behaviors
    when including native views, such as text views and images. We can also customize
    design component behavior, but first, we will take a look at the other design
    library components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: FAB如何在`Snackbar`的遮挡下自动移开是由父协调布局自动处理的，对于所有设计库小部件和ViewGroups都是如此。我们很快将看到，当包含原生视图时，如文本视图和图像，我们必须定义自己的行为。我们也可以自定义设计组件的行为，但首先我们将看一下其他设计库组件。
- en: Collapsing app bars
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可折叠的应用栏
- en: Another well recognized Material design feature is the collapsing toolbar. This
    generally contains a relevant image and a title. This type of toolbar will fill
    a large proportion of the screen when the user scrolls to the top of the content,
    it handily tucks itself out of the way when the user wishes to view more content
    and scrolls down. This component serves a useful purpose, as it provides a great
    branding opportunity and a chance for our app to stand out visually, but it does
    so without using up valuable screen real estate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广为人知的Material设计特性是可折叠的工具栏。通常包含相关的图片和标题。当用户滚动到内容顶部时，这种类型的工具栏将填充屏幕的大部分空间，当用户希望查看更多内容并向下滚动时，它会巧妙地躲开。这个组件有一个有用的目的，它提供了一个很好的品牌机会，让我们的应用在视觉上脱颖而出，但它不会占用宝贵的屏幕空间。
- en: '![](img/e8444936-2ecf-4ca5-a266-7ad55a6728c6.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8444936-2ecf-4ca5-a266-7ad55a6728c6.png)'
- en: A collapsing app bar
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可折叠的应用栏
- en: 'The best way to see how this is constructed is to examine the XML code behind
    it. Follow the steps to recreate it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看它的构造方式最好的方法是查看其背后的XML代码。按照以下步骤重新创建它：
- en: 'Start a new Android Studio project. We will be creating the following layout:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中开始一个新的项目。我们将创建以下布局：
- en: '![](img/749cc7ea-4917-435a-8ed7-2aa1454447a0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/749cc7ea-4917-435a-8ed7-2aa1454447a0.png)'
- en: Project component tree
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 项目组件树
- en: First open the `styles.xml` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`styles.xml`文件。
- en: 'Ensure that the parent theme speculates no action bar, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保父主题不包含操作栏，如下所示：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following line if you want a translucent status bar:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要使用半透明状态栏，请添加以下行：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As before, create a layout file with `CoordinatorLayout` at its root.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，创建一个以`CoordinatorLayout`为根的布局文件。
- en: 'Next, nest the following `AppBarLayout`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，嵌套以下`AppBarLayout`：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside this, add `CollapsingToolbarLayout`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，添加`CollapsingToolbarLayout`：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the toolbar, add these two widgets:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中，添加这两个小部件：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Beneath `AppBarLayout`, place `NestedScrollView` and `TextView`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppBarLayout`下面，放置`NestedScrollView`和`TextView`：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally add an FAB:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加一个FAB：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you now test this on a device or emulator, you will see that the toolbar
    collapses and expands automatically, without any programming, and this is the
    beauty of the design library. To code this type of behavior without it would be
    a lengthy and often difficult process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在在设备或模拟器上测试这个，你会看到工具栏会自动折叠和展开，无需任何编程，这就是设计库的美妙之处。要在没有它的情况下编写这种行为将是一个漫长而常常困难的过程。
- en: Most of the preceding XML is self-explanatory, but there are one or two points
    that are worth glancing at.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的大部分XML都是不言自明的，但有一两个点值得一看。
- en: Raw text resources
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始文本资源
- en: To demonstrate the scrolling behavior, the string used in the preceding text
    view was a lengthy one. This was placed in the `strings.xml` file, and although
    this works perfectly well, it is not an elegant way to manage lengthy texts. This
    kind of text is better dealt with as a text file resource that can be read at
    runtime.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示滚动行为，前面文本视图中使用了一个较长的字符串。这个字符串放在了`strings.xml`文件中，虽然这样做完全没有问题，但并不是管理长文本的优雅方式。这种文本最好作为可以在运行时读取的文本文件资源来处理。
- en: 'The following steps demonstrate how this is done:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何做到这一点：
- en: Prepare a plain text file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个纯文本文件。
- en: Create a directory named `raw` inside the `res` directory of your project by
    right-clicking on the `res` folder in the project explorer and selecting `New
    | Directory`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击项目资源管理器中的`res`文件夹并选择`New | Directory`来创建一个名为`raw`的目录。
- en: Add the text file to this directory.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本文件添加到此目录。
- en: Project directories can be opened quickly from the explorer context menu.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从资源管理器上下文菜单快速打开项目目录。
- en: 'Open the java activity with the text view you wish to populate and add this
    function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包含要填充文本视图的java活动，并添加此函数：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, add this code to the `onCreate()` method:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将此代码添加到`onCreate()`方法中：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The other point in the preceding demonstration is the use of a hardcoded value
    for the height of the expanded toolbar, that is, `android:layout_height="300dp"`.
    This works just fine on the model it was tested on but to achieve the same effect
    on all screen types could involve creating a large number of alternative layouts.
    One simpler solution is to only recreate the `dimens` folder, which can be simply
    copied and pasted, for example, `dimens-hdpi`, and edit only the appropriate value.
    One could even create a separate file containing just this value. Another way
    to combat this is with a support library designed for just this kind of situation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的演示中，另一个要点是在扩展工具栏的高度上使用了硬编码值，即`android:layout_height="300dp"`。这在被测试的模型上运行得很好，但要在所有屏幕类型上实现相同的效果可能需要创建大量的替代布局。一个更简单的解决方案是只重新创建`dimens`文件夹，例如，可以简单地复制和粘贴`dimens-hdpi`，然后只编辑适当的值。甚至可以创建一个单独的文件来包含这个值。另一种解决这个问题的方法是使用专为这种情况设计的支持库。
- en: The percent library
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百分比库
- en: 'The percent support library offers just two layout classes `PercentRelativeLayout`
    and `PercentFrameLayout`. It needs to be added to the gradle build file as a dependency,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比支持库只提供了两个布局类`PercentRelativeLayout`和`PercentFrameLayout`。需要将其添加到gradle构建文件中作为依赖项，如下所示：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To recreate the layout in the previous section, we need to place `AppBarLayout`
    inside `PercentRelativeLayout`. We can then use a percentage value to set the
    maximum height of our app bar, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建上一节中的布局，我们需要将`AppBarLayout`放在`PercentRelativeLayout`中。然后我们可以使用百分比值来设置我们应用栏的最大高度，如下所示：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method saves us having to create a large number of alternative layouts
    to reproduce the same effect across numerous devices, although it will always
    be necessary to generate more than one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法节省了我们不得不创建大量替代布局来在众多设备上复制相同效果的麻烦，尽管总是需要生成多个。
- en: Another effective way of achieving this uniformity is to create our image drawables
    so that they are the exact height we require in dp and set the layout height in
    XML as `wrap_content`. All we need to do then is create an image for each desired
    designated resource directory, something we were very likely to do anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种统一性的另一种有效方法是创建我们的图像可绘制对象，使其在dp中具有所需的确切高度，并在XML中将布局高度设置为`wrap_content`。然后我们只需要为每个所需的指定资源目录创建一个图像，这是我们很可能会做的事情。
- en: Together, the preceding tools make designing material interfaces simple and
    intuitive, and also provide ways to cut down on the amount of time it takes to
    prepare layouts for the bewildering array of devices available to the user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，前面的工具使得设计材料界面变得简单直观，并提供了减少为用户提供的令人困惑的设备准备布局所需的时间的方法。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built on the work of the previous chapter and explored how
    more sophisticated layouts can be easily constructed using the coordinator layout
    and its associated library, which does a great deal of the work for us such as
    automating collapsing toolbars and preventing overlapping widgets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在上一章的基础上探讨了如何使用协调布局及其相关库来轻松构建更复杂的布局，这些库可以为我们做很多工作，比如自动折叠工具栏和防止小部件重叠。
- en: We concluded the chapter by exploring another invaluable design library, the
    percent library, which can solve a multitude of design problem when developing
    for very different screen sizes and shapes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过探讨另一个宝贵的设计库——百分比库来结束了本章，它可以在开发针对非常不同的屏幕尺寸和形状时解决大量的设计问题。
- en: The next chapter will expand on this one by exploring more dynamic elements
    for interface development, such as screen rotation, developing for wearables,
    and reading sensors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在本章的基础上扩展，探讨更多用于界面开发的动态元素，如屏幕旋转、为可穿戴设备开发和读取传感器。
