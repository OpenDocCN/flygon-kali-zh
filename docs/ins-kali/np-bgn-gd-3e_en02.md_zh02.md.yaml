- en: Chapter 2. Beginning with NumPy Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：从 NumPy 基本原理开始
- en: '*After installing NumPy and getting some code to work, it''s time to cover
    NumPy basics.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 NumPy 并使一些代码正常工作之后，该介绍 NumPy 的基础知识了。
- en: 'The topics we shall cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍的主题如下：
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Array types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型
- en: Type conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Array creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组创建
- en: Indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Shape manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状操作
- en: Before we start, let me make a few remarks about the code examples in this chapter.
    The code snippets in this chapter show input and output from several IPython sessions.
    Recall that IPython was introduced in [Chapter 1](ch01.html "Chapter 1. NumPy
    Quick Start"), *NumPy Quick Start*, as the interactive Python shell of choice
    for scientific computing. The advantages of IPython are the `--pylab` switch that
    imports many scientific computing Python packages, including NumPy, and the fact
    that it is not necessary to explicitly call the `print()` function to display
    variable values. Other features include easy parallel computation and the notebook
    interface in the form of a persistent worksheet in a web browser.
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我对本章中的代码示例进行一些说明。 本章中的代码段显示了几个 IPython 会话的输入和输出。 回想一下，在第一章， “NumPy
    快速入门”中引入了 IPython，它是科学计算选择的交互式 Python shell。 IPython 的优点是`--pylab`开关可以导入许多科学计算
    Python 包，包括 NumPy，并且不需要显式调用`print()`函数来显示变量值。 其他功能还包括轻松的并行计算和 Web 浏览器中持久工作表形式的笔记本界面。
- en: However, the source code delivered alongside the book is a regular Python code
    that uses `import` and `print` statements.
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，本书随附的源代码是使用`import`和`print`语句的常规 Python 代码。
- en: NumPy array object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组对象
- en: 'NumPy has a multidimensional array object called `ndarray`. It consists of
    two parts:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有一个名为`ndarray`的多维数组对象。 它由两部分组成：
- en: The actual data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际数据
- en: Some metadata describing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些描述数据的元数据
- en: The majority of array operations leave the raw data untouched. The only aspect
    that changes is the metadata.
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数组操作都保持原始数据不变。 更改的唯一方面是元数据。
- en: In the previous chapter, we have already learned how to create an array using
    the `arange()` function. Actually, we created a one-dimensional array that contained
    a set of numbers. The `ndarray` object can have more than one dimension.
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经学习了如何使用`arange()`函数创建数组。 实际上，我们创建了一个包含一组数字的一维数组。 `ndarray`对象可以具有多个维度。
- en: The NumPy array is in general homogeneous (there is a special array type that
    is heterogeneous as described in the *Time for action – creating a record data
    type* section)—the items in the array have to be of the same type. The advantage
    is that, if we know that the items in the array are of the same type, it is easy
    to determine the storage size required for the array.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组通常是同质的（“实战时间：创建记录数据类型”部分中介绍了一种异类的特殊数组类型）—数组中的项目必须是同一类型。 好处是，如果我们知道数组中的项目属于同一类型，则很容易确定数组所需的存储大小。
- en: NumPy arrays are indexed starting from 0, just like in Python. Data types are
    represented by special objects. We will discuss these objects comprehensively
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组从 0 开始索引，就像在 Python 中一样。 数据类型由特殊对象表示。 我们将在本章中全面讨论这些对象。
- en: 'Let''s create an array with the `arange()` function again. Get the data type
    of an array using the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用`arange()`函数创建一个数组。 使用以下代码获取数组的数据类型：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The data type of array `a` is `int64` (at least on my machine), but you may
    get `int32` as output if you are using 32-bit Python. In both the cases, we are
    dealing with integers (64-bit or 32-bit). Besides the data type of an array, it
    is important to know its shape.
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`a`的数据类型为`int64`（至少在我的机器上），但是如果使用 32 位 Python，则可能会得到`int32`作为输出。 在这两种情况下，我们都处理整数（64
    位或 32 位）。 除了数组的数据类型外，了解其形状也很重要。
- en: 'In [Chapter 1](ch01.html "Chapter 1. NumPy Quick Start"), *NumPy Quick Start*,
    we demonstrated how to create a vector (actually, a one-dimensional NumPy array).
    A vector is commonly used in mathematics, but most of the time, we need higher
    dimensional objects. Determine the shape of the vector we created a few minutes
    ago. The following code is an example of creating a vector:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章， “NumPy 快速入门”中，我们演示了如何创建向量（实际上是一维 NumPy 数组）。 向量通常用于数学中，但是大多数时候，我们需要更高维的对象。
    确定我们在几分钟前创建的向量的形状。 以下代码是创建向量的示例：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the vector has five elements with values ranging from `0` to
    `4`. The shape attribute of the array is a tuple, in this case a tuple of 1 element,
    which contains the length in each dimension.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，向量具有五个元素，其值范围从`0`到`4`。 数组的`shape`属性是一个元组，在这种情况下为 1 个元素的元组，其中包含每个维度的长度。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A **tuple** in Python is an immutable (it can't change) sequence of values.
    Once tuples are created, we are not allowed to change the values of tuple elements
    or append new elements. This makes tuples safer than lists because you can't mutate
    them by accident. A common use case for tuples is as return value of functions.
    For more examples, have a look at the *Introducing Tuples* section of [Chapter
    3](ch03.html "Chapter 3. Getting Familiar with Commonly Used Functions"), *Dive
    into Python,* available at [http://www.diveintopython.net/native_data_types/tuples.html](http://www.diveintopython.net/native_data_types/tuples.html).
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的**元组**是一个不变的（不能更改）值序列。 创建元组后，不允许我们更改元组元素的值或追加新元素。 这使元组比列表更安全，因为您不能偶然对其进行突变。
    元组的常见用例是作为函数的返回值。 有关更多示例，请查看第三章的“元组介绍”部分，可在[`diveintopython.net/native_data_types/tuples.html`](http://www.diveintopython.net/native_data_types/tuples.html)
    上获得。
- en: Time for action – creating a multidimensional array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：创建多维数组
- en: 'Now that we know how to create a vector, we are ready to create a multidimensional
    NumPy array. After we create the array, we will again want to display its shape:'
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何创建向量，就可以创建多维 NumPy 数组了。 创建数组后，我们将再次想要显示其形状：
- en: 'Create a two-by-two array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`2x2`数组：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Show the array shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示数组形状：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We created a two-by-two array with the `arange()` and `array()` functions we
    have come to trust and love. Without any warning, the `array()` function appeared
    on the stage.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用值得信赖和喜爱的`arange()`和`array()`函数创建了一个`2 x 2`的数组。 没有任何警告，`array()`函数出现在舞台上。
- en: 'The `array()` function creates an array from an object that you give to it.
    The object needs to be array-like, for instance, a Python list. In the preceding
    example, we passed in a list of arrays. The object is the only required argument
    of the `array()` function. NumPy functions tend to have a lot of optional arguments
    with predefined defaults. View the documentation for this function from the IPython
    shell with the `help()` function given here:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()`函数根据您提供给它的对象创建一个数组。 该对象必须是类似数组的，例如 Python 列表。 在前面的示例中，我们传入了一个数组列表。
    该对象是`array()`函数的唯一必需参数。 NumPy 函数倾向于具有许多带有预定义默认值的可选参数。 在 IPython shell 中使用此处提供的`help()`函数查看此函数的文档：'
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or use the following shorthand:'
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用以下速记：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Of course, you can substitute `array` in this example with another NumPy function
    you are interested in.
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在此示例中将`array`替换为您感兴趣的另一个 NumPy 函数。
- en: Pop quiz – the shape of ndarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验：`ndarray`的形状
- en: Q1\. How is the shape of an `ndarray` stored?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. `ndarray`的形状如何存储？
- en: It is stored in a comma-separated string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它存储在逗号分隔的字符串中。
- en: It is stored in a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它存储在列表中。
- en: It is stored in a tuple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它存储在元组中。
- en: Have a go hero – create a three-by-three array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：创建三乘三的数组
- en: It shouldn't be too hard now to create a three-by-three array. Give it a go
    and check whether the array shape is as expected.
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个三乘三的数组应该不难  。 试试看，检查数组形状是否符合预期。
- en: Selecting elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择元素
- en: 'From time to time, we will want to select a particular element of an array.
    We will take a look at how to do this, but, first, create a two-by-two array again:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时需要选择数组的特定元素。 我们将看一下如何执行此操作，但是，首先，再次创建一个`2 x 2`数组：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The array was created this time by passing a list of lists to the `array()`
    function. We will now select one by one each item of the matrix. Remember, the
    indices are numbered starting from `0:`
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是通过将列表列表传递给`array()`函数来创建数组的。 现在，我们将逐一选择矩阵的每个项目。 请记住，索引从`0:`开始编号
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, selecting elements of the array is pretty simple. For the array
    `a`, we just use the notation `a[m,n]`, where `m` and `n` are the indices of the
    item in the array (the array can have even more dimensions than in this example).
    This screenshot shows a simple example of an array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，选择数组的元素非常简单。 对于数组`a`，我们只使用符号`a[m,n]`，其中`m`和`n`是数组中该项的索引（数组的维数比本示例中的还要多）。
    此屏幕快照显示了一个简单的数组示例：
- en: '![Selecting elements](img/4154_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![选择元素](img/4154_02_01.jpg)'
- en: NumPy numerical types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy 数值类型
- en: Python has an integer type, a float type, and a complex type; however, this
    is not enough for scientific computing and, for this reason, NumPy has a lot more
    data types with varying precision, dependent on memory requirements.
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有整数类型，浮点类型和复杂类型； 但是，这还不足以进行科学计算，因此，NumPy 拥有更多的数据类型  ，它们的精度取决于存储要求。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Integers represent whole numbers, such as -1, 0, and 1\. Floating-point numbers
    correspond to real numbers as used in mathematics, for example, fractions or irrational
    numbers such as *pi*. Because of the way computers work, we are able to represent
    integers exactly, but floating-point numbers are approximated. Complex numbers
    can have an imaginary component usually denoted with *i* or *j*. By definition,
    *i* is the square root of -1\. For instance, 2.5 + 3.7i is a complex number (for
    more information, refer to [https://www.khanacademy.org/math/precalculus/imaginary_complex_precalc](https://www.khanacademy.org/math/precalculus/imaginary_complex_precalc)).
  prefs: []
  type: TYPE_NORMAL
  zh: 整数代表整数，例如 -1、0 和 1。浮点数对应于数学中使用的实数，例如分数或无理数，例如`pi`。 由于计算机的工作方式，我们能够精确地表示整数，但是浮点数是近似值。
    复数可以具有通常用`i`或`j`表示的虚部。 根据定义，`i`是 -1 的平方根。 例如，`2.5 + 3.7i`是一个复数（有关更多信息，请参阅[`www.khanacademy.org/math/precalculus/imaginary_complex_precalc`](https://www.khanacademy.org/math/precalculus/imaginary_complex_precalc)）。
- en: 'In practice, we need even more types with varying precision and, therefore,
    different memory size of the type. The majority of the NumPy numerical types end
    with a number. This number indicates the number of bits associated with the type.
    The following table (adapted from the NumPy user guide) gives an overview of NumPy
    numerical types:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们甚至需要更多具有不同精度的类型，因此，该类型的内存大小也有所不同。 大多数 NumPy 数值类型都以数字结尾。 该数字表示与该类型关联的位的数目。
    下表（根据 NumPy 用户指南改编）概述了 NumPy 数值类型：
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bool` | Boolean (`True` or `False`) stored as a bit |'
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔（`True`或`False`）存储为位 |'
- en: '| `inti` | Platform integer (normally either `int32` or `int64`) |'
  prefs: []
  type: TYPE_TB
  zh: '| `inti` | 平台整数（通常为`int32`或`int64`） |'
- en: '| `int8` | Byte (-128 to 127) |'
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 字节（-128 至 127） |'
- en: '| `int16` | Integer (-32768 to 32767) |'
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 整数（-32768 至 32767） |'
- en: '| `int32` | Integer (-2 ** 31 to 2 ** 31 -1) |'
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 整数（`-2 ** 31`到`2 ** 31 -1`） |'
- en: '| `int64` | Integer (-2 ** 63 to 2 ** 63 -1) |'
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 整数（`-2 ** 63`到`2 ** 63 -1`） |'
- en: '| `uint8` | Unsigned integer (0 to 255) |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 无符号整数（0 到 255） |'
- en: '| `uint16` | Unsigned integer (0 to 65535) |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 无符号整数（0 到 65535） |'
- en: '| `uint32` | Unsigned integer (0 to 2 ** 32 - 1) |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 无符号整数（0 到`2 ** 32-1`） |'
- en: '| `uint64` | Unsigned integer (0 to 2 ** 64 - 1) |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 无符号整数（0 到`2 ** 64-1`） |'
- en: '| `float16` | Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `float16` | 半精度浮点数：符号位，5 位指数，10 位尾数 |'
- en: '| `float32` | Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 单精度浮点数：符号位，8 位指数，23 位尾数 |'
- en: '| `float64` or `float` | Double precision float: sign bit, 11 bits exponent,
    52 bits mantissa |'
  prefs: []
  type: TYPE_TB
  zh: '| `float64`或`float` | 双精度浮点数：符号位，11 位指数，52 位尾数 |'
- en: '| `complex64` | Complex number, represented by two 32-bit floats (real and
    imaginary components) |'
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | 复数，由两个 32 位浮点数表示（实部和虚部） |'
- en: '| `complex128` or `complex` | Complex number, represented by two 64-bit floats
    (real and imaginary components) |'
  prefs: []
  type: TYPE_TB
  zh: '| `complex128`或`complex` | 复数，由两个 64 位浮点数表示（实部和虚部） |'
- en: 'For floating-point types, we can request information with the `finfo()` function
    given here:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点类型，我们可以使用此处提供的`finfo()`函数来请求信息：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each data type, there exists a corresponding conversion function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种数据类型，都有一个对应的转换函数：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Many functions have a data type argument, which is often optional:'
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数都有一个数据类型参数，该参数通常是可选的：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is important to know that you are not allowed to convert a complex number
    into an integer or float. Trying to do that triggers a `TypeError`, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道您不允许将复数转换为整数或浮点数。 尝试执行触发`TypeError`的  ，如以下屏幕截图所示：
- en: '![NumPy numerical types](img/4154_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![NumPy 数值类型](img/4154_02_05.jpg)'
- en: The same goes for conversion of a complex number into a float.
  prefs: []
  type: TYPE_NORMAL
  zh: 将复数转换为浮点数也是如此。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An exception in Python is an abnormal condition, which we usually try to avoid.
    A `TypeError` is a Python built-in exception, occurring when we specify the wrong
    type for an argument.
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的异常是一种异常情况，我们通常会尝试避免这种情况。 `TypeError`是 Python 内置的异常，当我们为参数指定错误的类型时发生。
- en: The `j` part is the imaginary coefficient of the complex number. However, you
    can convert a float in to a complex number, for instance, `complex(1.0)`.
  prefs: []
  type: TYPE_NORMAL
  zh: '`j`部分是复数的虚数系数。 但是，您可以将浮点数转换为复数，例如`complex(1.0)`。'
- en: Data type objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型对象
- en: '**Data** **type** **objects** are instances of the `numpy.dtype` class. Once
    again, arrays have a data type. To be precise, every element in a NumPy array
    has the same data type. The data type object can tell you the size of the data
    in bytes. The size in bytes is given by the `itemsize` attribute of the `dtype`
    class:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型对象**是`numpy.dtype`类。 再次，数组具有数据类型。 确切地说，NumPy 数组中的每个元素都具有相同的数据类型。 数据类型对象可以告诉您数据的大小（以字节为单位）。
    以字节为单位的大小由`dtype` 类的`itemsize`属性给出：'
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Character codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符代码
- en: '**Character** **codes** are included for backward compatibility with Numeric.
    Numeric is the predecessor of NumPy. Their use is not recommended, but the codes
    are provided here because they pop up in several places. We should instead use
    the `dtype` objects. The table shows the character codes:'
  prefs: []
  type: TYPE_NORMAL
  zh: 包括**字符代码**是为了与数字向后兼容。 数字是 NumPy 的前身。 虽然不建议使用，但此处提供代码，因为它们会在多个位置出现。 相反，我们应该使用`dtype`对象。
    下表显示了字符代码：
- en: '| Type | Character code |'
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 字符码 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integer | `i` |'
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `i` |'
- en: '| Unsigned integer | `u` |'
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整数 | `u` |'
- en: '| Single precision float | `f` |'
  prefs: []
  type: TYPE_TB
  zh: '| 单精度浮点 | `f` |'
- en: '| Double precision float | `d` |'
  prefs: []
  type: TYPE_TB
  zh: '| 双精度浮点 | `d` |'
- en: '| Boolean | `b` |'
  prefs: []
  type: TYPE_TB
  zh: '| 布尔型 | `b` |'
- en: '| Complex | `D` |'
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `D` |'
- en: '| String | `S` |'
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `S` |'
- en: '| Unicode | `U` |'
  prefs: []
  type: TYPE_TB
  zh: '| Unicode | `U` |'
- en: '| Void | `V` |'
  prefs: []
  type: TYPE_TB
  zh: '| 无 | `V` |'
- en: 'Look at the following code to create an array of single precision floats:'
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码以创建单精度浮点数数组：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Likewise this creates an array of complex numbers.
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这将创建一个复数数组。
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The dtype constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dtype`构造器'
- en: Python classes have functions, which are called **methods**, if they belong
    to a class. Some of these methods are special and used to create new objects.
    These specialized methods are called **constructors**.
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类具有函数，如果它们属于一个类，则这些函数称为**方法**。 其中某些方法是特殊的，  用于创建新对象。 这些专门方法称为**构造器**。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Python classes at [https://docs.python.org/2/tutorial/classes.html](https://docs.python.org/2/tutorial/classes.html).
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[`docs.python.org/2/tutorial/classes.html`](https://docs.python.org/2/tutorial/classes.html)上阅读有关 Python 类的更多信息。
- en: 'We have a variety of ways to create data types. Take the case of floating point
    data:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种创建数据类型的方法。 以浮点数据为例：
- en: 'Use the general Python float:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用的 Python 浮点数：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Specify a single precision float with a character code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用字符代码指定一个单精度浮点数：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use a double precision float character code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双精度浮点字符代码：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can give the data type constructor a two-character code. The first character
    signifies the type and the second character is a number specifying the number
    of bytes in the type (the numbers 2, 4, and 8 correspond to 16, 32, and 64-bit
    floats):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以给数据类型构造器一个两个字符的代码。 第一个字符表示类型，第二个字符是一个数字，用于指定类型中的字节数（数字 2、4 和 8 对应于 16、32
    和 64 位浮点数）：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A listing of all full data type names can be found with the `sctypeDict.keys()`
    function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sctypeDict.keys()`函数找到所有完整数据类型名称的列表：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The dtype attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dtype`属性'
- en: 'The `dtype` class has a number of useful attributes. For example, get information
    about the character code of a data type through the attributes of `dtype`:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`类具有许多有用的属性。 例如，通过`dtype`的属性获取有关数据类型的字符代码的信息：'
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The type attribute corresponds to the type of object of the array elements:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`属性对应于数组元素的对象类型：'
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `str` attribute of the `dtype` class gives a string representation of the
    data type. It starts with a character representing **endianness**, if appropriate,
    then a character code, followed by a number corresponding to the number of bytes
    that each array item requires. Endianness, here, refers to the way bytes are ordered
    within a 32- or 64-bit word. In big-endian order, the most significant byte is
    stored first, indicated by `>`. In little-endian order, the least significant
    byte is stored first, indicated by `<`:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`类的`str`属性给出了数据类型的字符串表示形式。 它以代表**字节序**的字符开头（如果合适），然后是一个字符代码，后跟一个与每个数组项所需的字节数相对应的数字。
    字节序在这里指  ，即在 32 位或 64 位字中对字节进行排序的方式。 按照大端顺序，最高有效字节先存储，由`>`指示。 以低字节序排列，最低有效字节先存储，由`<`指示：'
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Time for action – creating a record data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：创建记录数据类型
- en: 'The record data type is a heterogeneous data type—think of it as representing
    a row in a spreadsheet or a database. To give an example of a record data type,
    we will create a record for a shop inventory. The record contains the name of
    the item, a 40-character string, the number of items in the store represented
    by a 32-bit integer, and, finally, a price represented by a 32-bit float. These
    consecutive steps show how to create a record data type:'
  prefs: []
  type: TYPE_NORMAL
  zh: 记录数据类型是一种异构数据类型，可以认为它代表电子表格或数据库中的一行。 为了提供记录数据类型的示例，我们将为商店股票创建一条记录。 记录包含商品名称，40
    个字符的字符串，商店中商品的数量（由 32 位整数表示）以及最后由 32 位浮点数表示的价格。 这些连续的步骤显示了如何创建记录数据类型：
- en: 'Create the record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建记录：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'View the type (we can view the type of a field as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看类型（我们也可以查看字段的类型）：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you don''t give the `array()` function a data type, it will assume that
    it is dealing with floating point numbers. To create the array now, we really
    have to specify the data type; otherwise, we will get a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不为`array()`函数提供数据类型，则将假定它正在处理浮点数。 现在要创建数组，我们实际上必须指定数据类型； 否则，我们将获得`TypeError`：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We created a record data type, which is a heterogeneous data type. The record
    contained a name as a character string, a number as an integer, and a price represented
    by a float. The code for this example can be found in the `record.py` file in
    this book's code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个记录数据类型，它是一个异构数据类型。 该记录包含一个名称，该名称为字符串，数字为整数，以及以浮点数表示的价格。 该示例的代码可以在本书代码捆绑中的`record.py`文件中找到。
- en: One-dimensional slicing and indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一维切片和索引
- en: 'Slicing of one-dimensional NumPy arrays works just like slicing of Python lists.
    Select a piece of an array from index `3` to `7` that extracts the elements `3`
    through `6`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 一维 NumPy 数组的切片就像 Python 列表的切片一样工作。 从索引`3`到`7`中选择一个数组  ，该数组提取元素`3`至`6`：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Select elements from index `0` to `7` with step 2 as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 通过步骤 2 从索引`0`到`7`中选择元素，如下所示：
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, as in Python, use negative indices and reverse the array with this
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与 Python 中一样，使用负索引并使用以下代码片段反转数组：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Time for action – slicing and indexing multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：切片和索引多维数组
- en: The `ndarray` class supports slicing over multiple dimensions. For convenience,
    we refer to many dimensions at once, with an ellipsis.
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray`类支持在多个维度上切片。 为了方便  ，我们一次用省略号指代许多尺寸。'
- en: 'To illustrate, create an array with the `arange()` function and reshape it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这一点，请使用`arange()`函数创建一个数组并调整其形状：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The array `b` has `24` elements with values `0` to `23` and we reshaped it to
    be a two-by-three-by-four, three-dimensional array. We can visualize this as a
    two-story building with 12 rooms on each floor, 3 rows and 4 columns (alternatively
    we can think of it as a spreadsheet with sheets, rows, and columns). As you have
    probably guessed, the `reshape()` function changes the shape of an array. We give
    it a tuple of integers, corresponding to the new shape. If the dimensions are
    not compatible with the data, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`b`具有`24`元素，其值从`0`至`23`，我们将其重构为`2×3×4`的三维数组。 我们可以将其可视化为一个两层楼的架构，每层有 12 个房间，3
    行和 4 列（或者我们可以将其视为包含工作表，行和列的电子表格）。 您可能已经猜到了，`reshape()`函数会更改数组的形状。 我们给它一个整数元组，对应于新的形状。
    如果维度与数据不兼容，则会引发异常。
- en: 'We can select a single room using its three coordinates, namely, the floor,
    column, and row. For example, the room on the first floor, in the first row, and
    in the first column (we can have floor 0 and room 0—it''s just a matter of convention)
    can be represented by the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用其三个坐标（即楼层，列和行）选择一个房间。 例如，可以表示行和第一列中的房间（我们可以有 0 层，房间 0，这只是一个惯例）。 由以下各项组成：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we don''t care about the floor, but still want the first column and row,
    we replace the first index by a**:** (**colon**) because we just need to specify
    the floor number and omit the other indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不在乎楼层，但仍然想要第一列和第一行，则将第一个索引替换为`a:`（**冒号**），因为我们只需要指定楼层号并省略其他指标：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Select the first floor in this code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此代码中的第一层：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also write this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样写：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An ellipsis (…) replaces multiple colons, so, the preceding code is equivalent
    to this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号（...）替换了多个冒号，因此，前面的代码等效于此：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Furthermore, get the second row on the first floor:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第一层获得第二行：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Using steps to slice**: Furthermore, also select every second element of
    this selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带有步长的切片**：此外，还要选择此选择的每隔一个元素：'
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Using an ellipsis to slice**: If we want to select all the rooms on both
    floors that are in the second column, regardless of the row, type this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带有省略号的切片**：如果我们要选择第二列中两层的所有房间，而不管是哪一行，请键入以下代码：'
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, select all the rooms on the second row, regardless of floor and
    column, by writing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过编写以下代码段，选择第二行中的所有房间，而不管楼层和列如何：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we want to select rooms on the ground floor second column, then type this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在第一层第二栏中选择房间，请输入以下内容：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Using negative indices**: If we want to select the first floor, last column,
    then type the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用负索引**：如果我们要选择第一层，最后一列，然后输入以下代码段：'
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we want to select rooms on the ground floor, last column reversed, then
    type the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要选择一楼的房间，则将最后一列颠倒过来，然后输入以下代码片段：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Select every second element of that slice as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 选择该片的第二个元素，如下所示：
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The command that reverses a one-dimensional array puts the top floor following
    the ground floor as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 反转一维数组的命令将起始放到末尾，如下所示：
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We sliced a multidimensional NumPy array using several different methods. The
    code for this example can be found in the `slicing.py` file in this book's code
    bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用几种不同的方法对多维 NumPy 数组进行了切片。 该示例的代码可以在本书代码捆绑中的`slicing.py`文件中找到。
- en: Time for action – manipulating array shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：处理数组形状
- en: We already learned about the `reshape()` function. Another recurring task is
    flattening of arrays. When we flatten multidimensional NumPy arrays, the result
    is a one-dimensional array with the same data.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了`reshape()`函数。 另一个重复执行的任务是将数组展平。 展平多维 NumPy 数组时，结果是具有相同数据的一维数组。
- en: '**Ravel**: Accomplish this with the `ravel()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**展开（`ravel`）**：使用`ravel()`函数完成：'
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Flatten**: The appropriately named function, `flatten()` does the same as
    `ravel()`, but `flatten()` always allocates new memory whereas `ravel()` might
    return a view of the array. A view is a way to share an array, but you need to
    be careful with views because modifying the view affects the underlying array,
    and therefore this impacts other views. An array copy is safer; however, it uses
    more memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**展开（`flatten`）**：适当的命名函数`flatten()`与`ravel()`相同，但`flatten()`总是分配新的内存，而`ravel()`可能会返回数组的视图。
    视图是共享数组的一种方法，但是您需要对视图小心  ，因为修改视图会影响基础数组，因此会影响其他视图。 数组副本更安全； 但是，它使用更多的内存：'
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Setting the shape with a tuple**: Besides the `reshape()` function, we can
    also set the shape directly with a tuple, which is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用元组设置形状**：除了`reshape()`函数外，我们还可以直接使用元组设置形状，如下所示：'
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, this changes the array directly. Now, we have a six-by-four
    array.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这将直接更改数组。 现在，我们有了一个六乘四的数组。
- en: '**Transpose**: In linear algebra, it is common to transpose matrices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转置**：在线性代数中，转置矩阵很常见。'
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linear algebra is a branch of mathematics dealing among others with **matrices**.
    Matrices are the two-dimensional equivalent of vectors and contain numbers in
    a rectangular or square grid. Transposing a matrix entails flipping the matrix
    in such a manner that the matrix rows become the matrix columns and vice versa.
    Khan Academy has a course on linear algebra, which includes transposing matrices
    at [https://www.khanacademy.org/math/linear-algebra/matrix_transformations/matrix_transpose/v/linear-algebra-transpose-of-a-matrix](https://www.khanacademy.org/math/linear-algebra/matrix_transformations/matrix_transpose/v/linear-algebra-transpose-of-a-matrix).
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是数学的一个分支，其中涉及**矩阵**。 矩阵是向量的二维等效项，并且包含矩形或正方形网格中的数字。 转置矩阵需要以使矩阵行变为矩数组的方式翻转矩阵，反之亦然。
    可汗学院开设了关于线性代数的课程，其中包括矩阵中的转置矩阵，位于[`www.khanacademy.org/math/linear-algebra/matrix_transformations/matrix_transpose/v/linear-algebra-transpose-of-a-matrix`](https://www.khanacademy.org/math/linear-algebra/matrix_transformations/matrix_transpose/v/linear-algebra-transpose-of-a-matrix)。
- en: 'We can do this too using the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下代码来做到这一点：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Resize**: The `resize()` method works just like the `reshape()` function,
    but modifies the array it operates on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整大小**：`resize()`方法的作用与`reshape()`函数相同，但是修改了它在数组上执行的操作：'
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We manipulated the shapes of NumPy arrays using the `ravel()` function, the
    `flatten()` function, the `reshape()` function, and the `resize()` method, as
    explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ravel()`函数，`flatten()`函数，`reshape()`函数和`resize()`方法操纵 NumPy 数组的形状，如下表所示：
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ravel()` | This function returns a one-dimensional array with the same data
    as the input array and doesn''t always return a copy |'
  prefs: []
  type: TYPE_TB
  zh: '| `ravel()` | 此函数返回一维数组，其数据与输入数组相同，并不总是返回副本 |'
- en: '| `flatten()` | This is a method of `ndarra` `y`, which flattens arrays and
    always returns a copy of the array |'
  prefs: []
  type: TYPE_TB
  zh: '| `flatten()` | 这是`ndarray`的方法，它会展平数组并始终返回数组的副本 |'
- en: '| `reshape()` | This function modifies the shape of an array |'
  prefs: []
  type: TYPE_TB
  zh: '| `reshape()` | 此函数修改数组的形状 |'
- en: '| `resize()` | This function changes the shape of an array and adds copies
    of the input array if necessary |'
  prefs: []
  type: TYPE_TB
  zh: '| `resize()` | 此函数更改数组的形状，并在必要时添加输入数组的副本 |'
- en: The code for this example is in the `shapemanipulation.py` file in this book's
    code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的代码在本书代码捆绑的`shapemanipulation.py`文件中。
- en: Stacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆叠
- en: Arrays can be stacked horizontally, depth wise, or vertically. We can use, for
    that purpose, the `vstack()`, `dstack()`, `hstack()`, `column_stack()`, `row_stack()`,
    and `concatenate()` functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以水平，深度或垂直堆叠。 为此，我们可以使用`vstack()`，`dstack()`，`hstack()`，`column_stack()`，`row_stack()`和`concatenate()`函数。
- en: Time for action – stacking arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：堆叠数组
- en: 'First, set up some arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一些数组：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Horizontal** **stacking**: Starting with horizontal stacking, form a tuple
    of the `ndarray` objects and give it to the `hstack()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**水平堆叠**：从水平堆叠开始，形成一个`ndarray`对象的元组，并将其提供给`hstack()`函数，如下所示：'
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Achieve the same with the `concatenate()` function as follows (the axis argument
    here is equivalent to axes in a Cartesian coordinate system and corresponds to
    the array dimensions):'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concatenate()`函数可以达到以下效果（此处的`axis`参数等效于笛卡尔坐标系中的轴，并且对应于数组尺寸）：
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This image shows horizontal stacking with the `concatenate()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了`concatenate()`函数的水平堆叠：
- en: '![Time for action – stacking arrays](img/4154_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：堆叠数组](img/4154_02_02.jpg)'
- en: '**Vertical** **stacking**: With vertical stacking, again, a tuple is formed.
    This time, it is given to the `vstack()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直堆叠**：通过垂直堆叠，再次形成元组。 这次，它被赋予`vstack()`函数，如下所示：'
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `concatenate()` function produces the same result with the axis set to
    0\. This is the default value for the `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatenate()`函数在将轴设置为 0 时产生相同的结果。这是`axis`参数的默认值：'
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following diagram shows vertical stacking with `concatenate()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了具有`concatenate()`函数的垂直堆叠：
- en: '![Time for action – stacking arrays](img/4154_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：堆叠数组](img/4154_02_03.jpg)'
- en: '**Depth** **stacking**: Additionally, depth-wise stacking using `dstack()`
    and a tuple stacks a list of arrays along the third axis (depth). For instance,
    stack two-dimensional arrays of image data on top of each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**深度堆叠**：另外，使用`dstack()`和元组的深度堆叠，沿第三个轴（深度）堆叠了数组的列表。 例如，将图像数据的二维数组彼此堆叠在一起：'
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Column** **stacking**: Stack the one-dimensional arrays with the `column_stack()`
    function column-wise as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列堆叠**：使用`column_stack()`函数按列将一维数组堆叠如下：'
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Two-dimensional arrays are stacked the way `hstack()` stacks them:'
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组以`hstack()`的方式堆叠：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Yes, you guessed it right! We compared two arrays with the `==` operator.
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您猜对了！ 我们用`==`运算符比较了两个数组。
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **==** operator is used in Python to compare for equality. When applied
    to NumPy arrays, the operator performs element-wise comparisons. For more information
    about the Python comparison operators, have a look at [http://www.pythonlearn.com/html-009/book004.html](http://www.pythonlearn.com/html-009/book004.html).
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符用于比较 Python 对象是否相等。 当应用于 NumPy 数组时，运算符将执行逐元素比较。 有关 Python 比较运算符的更多信息，请查看[`www.pythonlearn.com/html-009/book004.html`](http://www.pythonlearn.com/html-009/book004.html)。'
- en: '**Row** **stacking**: NumPy, of course, also has a function that does row-wise
    stacking. It is called `row_stack()`, and, for one-dimensional arrays, it just
    stacks the arrays in rows into a two-dimensional array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行堆叠**：NumPy 当然也具有执行行堆叠的函数。 它称为`row_stack()`，对于一维数组，它只是将行中的数组堆叠为二维数组：'
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `row_stack()` function results for two-dimensional arrays are equal to,
    yes, exactly, the `vstack()` function results:'
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组的`row_stack()`函数结果等于`vstack()`函数结果：
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We stacked arrays horizontally, depth wise, and vertically. We used the `vstack()`,
    `dstack()`, `hstack()`, `column_stack()`, `row_stack()`, and `concatenate()` functions
    as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们水平，深度和垂直堆叠数组。 我们使用了`vstack()`，`dstack()`，`hstack()`，`column_stack()`，`row_stack()`和`concatenate()`函数，如下表所示：
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `vstack()` | This function stacks arrays vertically |'
  prefs: []
  type: TYPE_TB
  zh: '| `vstack()` | 此函数垂直堆叠数组 |'
- en: '| `dstack()` | This function stacks arrays depth-wise along the third axis
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `dstack()` | 此函数沿第三轴深度堆叠数组 |'
- en: '| `hstack()` | This function stacks arrays horizontally |'
  prefs: []
  type: TYPE_TB
  zh: '| `hstack()` | 此函数水平堆叠数组 |'
- en: '| `column_stack()` | This function stacks one-dimensional arrays as columns
    to create a two-dimensional array |'
  prefs: []
  type: TYPE_TB
  zh: '| `column_stack()` | 此函数将一维数组堆叠为列以创建二维数组 |'
- en: '| `row_stack()` | This function stacks array vertically |'
  prefs: []
  type: TYPE_TB
  zh: '| `row_stack()` | 此函数垂直堆叠数组 |'
- en: '| `concatenate()` | This function concatenates a list or a tuple of arrays
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `concatenate()` | 此函数连接数组的列表或元组 |'
- en: The code for this example is in the `stacking.py` file in this book's code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码在本书的代码包的`stacking.py`文件中。
- en: Splitting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割
- en: Arrays can be split vertically, horizontally, or depth wise. The functions involved
    are `hsplit()`, `vsplit()`, `dsplit()`, and `split()`. We can either split into
    arrays of the same shape or indicate the position after which the split should
    occur.
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在垂直，水平或深度方向拆分数组。 涉及的函数是`hsplit()`，`vsplit()`，`dsplit()`和`split()`。 我们既可以拆分为相同形状的数组，也可以指示拆分之后应该发生的位置。
- en: Time for action – splitting arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：分割数组
- en: 'The following steps demonstrate arrays splitting:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了数组的拆分：
- en: '**Horizontal** **splitting**: The ensuing code splits an array along its horizontal
    axis into three pieces of the same size and shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**水平分割**：随后的代码将数组沿水平轴分割为三个大小和形状相同的片段：'
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Compare it with a call of the `split()` function, with extra parameter `axis=1`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 将它与带有附加参数`axis=1`的`split()`函数调用进行比较：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Vertical** **splitting**: `vsplit()` splits along the vertical axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直分割**：`vsplit()`沿垂直轴分割：'
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `split()` function, with `axis=0`, also splits along the vertical axis:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()`函数和`axis=0`也沿垂直轴分割：'
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Depth-wise splitting**: The `dsplit()` function, unsurprisingly, splits depth-wise.
    Create an array of rank 3 first before splitting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**深度分割**：`dsplit()`函数毫不奇怪地是深度拆分。 分割前先创建一个排列为 3 的数组：'
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We split arrays using the `hsplit()`, `vsplit()`, `dsplit()`, and `split()`
    functions. These functions differ in the axis along which the split occurs. The
    code for this example is in the `splitting.py` file in this book's code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hsplit()`，`vsplit()`，`dsplit()`和`split()`函数拆分数组。 这些功能拆分的轴是不同的。 该示例的代码在本书代码捆绑的`splitting.py`文件中。
- en: Array attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组属性
- en: 'Besides the `shape` and `dtype` attributes, `ndarray` has a number of other
    attributes, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`shape`，和`dtype`属性外，`ndarray`还有许多其他属性，如下表所示：
- en: 'The `ndim` attribute gives the number of dimensions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndim`属性提供了维度数：'
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `size` attribute contains the number of elements. This is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`属性包含元素数。 如下所示：'
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `itemsize` attribute gives the number of bytes for each element in the
    array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemsize`属性提供数组中每个元素的字节数：'
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you want the total number of bytes the array requires, you can have a look
    at `nbytes`. This is just a product of the `itemsize` and `size` attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要数组所需的字节总数，可以查看`nbytes`。 这只是`itemsize`和`size`属性的乘积：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `T` attribute has the same effect as the `transpose()` function, which
    is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`属性具有`transpose()`函数的相同效果，如下所示：'
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the array has a rank lower than 2, we will just get a view of the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组的等级低于 2，我们将只获得数组的视图：
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Complex numbers in NumPy are represented by `j.` For example, create an array
    with complex numbers as in the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的复数用`j.`表示。例如，创建具有复数的数组，如以下代码所示：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `real` attribute gives us the real part of the array, or the array itself
    if it only contains real numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`属性为我们提供了数组的实部，或者如果数组仅包含实数，则为数组本身：'
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `imag` attribute contains the imaginary part of the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imag`属性包含数组的虚部：'
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the array contains complex numbers, then the data type is automatically
    also complex:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组包含复数，则数据类型也将自动变为复数：
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `flat` attribute returns a `numpy.flatiter` object. This is the only way
    to acquire a `flatiter`—we do not have access to a `flatiter` constructor. The
    flat iterator enables us to loop through an array as if it is a flat array, as
    shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flat`属性返回一个`numpy.flatiter`对象。 这是获取`flatiter`的唯一方法-我们无权访问`flatiter`构造器。 平面迭代器使我们能够像遍历平面数组一样遍历数组，如以下示例所示：'
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'It is possible to get an element directly with the `flatiter` object:'
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接通过`flatiter`对象获取元素：
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And, it is also possible to directly get multiple elements:'
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，还可以直接获取多个元素：
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `flat` attribute is settable. Setting the value of the `flat` attribute
    leads to overwriting the values of the whole array:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat`属性是可设置的。 设置`flat`属性的值会导致覆盖整个数组的值：'
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Or, it can also lead to overwriting the values of selected elements:'
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可能导致覆盖所选元素的值：
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following diagram shows the different types of attributes of the `ndarray`
    class:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`ndarray`类的不同类型的属性：
- en: '![Array attributes](img/4154_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![数组属性](img/4154_02_04.jpg)'
- en: Time for action – converting arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：转换数组
- en: 'Convert a NumPy array to a Python list with the `tolist()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tolist()`函数将 NumPy 数组转换为 Python 列表：
- en: 'Convert to a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换为列表：
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `astype()` function converts the array to an array of the specified type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`astype()`将数组转换为指定类型的数组：
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are losing the imaginary part when casting from the NumPy complex type (not
    the plain vanilla Python one) to `int`. The `astype()` function also accepts the
    name of a type as a string.
  prefs: []
  type: TYPE_NORMAL
  zh: 从 NumPy 复杂类型（而不是普通的 Python 版本）转换为`int`时，我们将丢失虚部。 `astype()`函数还接受类型名称作为字符串。
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: It won't show any warning this time because we used the proper data type.
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不会显示任何警告，因为我们使用了正确的数据类型。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We converted NumPy arrays to a list and to arrays of different data types. The
    code for this example is in the `arrayconversion.py` file in this book's code
    bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 NumPy 数组转换为列表和不同数据类型的数组。 该示例的代码在本书代码捆绑的`arrayconversion.py`文件中。
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned a lot about NumPy fundamentals: data types and
    arrays. Arrays have several attributes describing them. You learned that one of
    these attributes is the data type, which, in NumPy, is represented by a fully-fledged
    object.'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了很多有关 NumPy 的基础知识：数据类型和数组。 数组有几个描述它们的属性。 您了解到这些属性之一是数据类型，在 NumPy 中，数据类型由完整的对象表示。
- en: NumPy arrays can be sliced and indexed in an efficient manner, just like Python
    lists. NumPy arrays have the added ability of working with multiple dimensions.
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 列表一样，可以以高效的方式对 NumPy 数组进行切片和索引。 NumPy 数组具有处理多个维度的附加功能。
- en: The shape of an array can be manipulated in many ways—stacking, resizing, reshaping,
    and splitting. A great number of convenience functions for shape manipulation
    were demonstrated in this chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状可以通过多种方式进行操作-堆叠，调整大小，调整形状和拆分。 本章演示了许多用于形状处理的便捷函数。
- en: Having learned about the basics, it's time to move on to the study of commonly
    used functions in [Chapter 3](ch03.html "Chapter 3. Getting Familiar with Commonly
    Used Functions"), *Getting Familiar with Commonly Used Functions*, which includes
    basic statistical and mathematical functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了基础知识之后，是时候进入第三章，“熟悉常用函数”了，其中包括了基本函数。 统计和数学函数。
