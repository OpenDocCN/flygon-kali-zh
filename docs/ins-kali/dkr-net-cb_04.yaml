- en: Chapter 4. Building Docker Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。构建Docker网络
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下教程：
- en: Manually networking containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动网络容器
- en: Specifying your own bridge
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定自己的桥
- en: Using an OVS bridge
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OVS桥
- en: Using an OVS bridge to connect Docker hosts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OVS桥连接Docker主机
- en: OVS and Docker together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OVS和Docker一起
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As we've seen in earlier chapters, Docker does a great job of handling many
    container networking needs. However, this does not limit you to using only Docker-provided
    network elements to connect containers. So while Docker can facilitate the networking
    for you, you can also connect containers manually. The drawback to this approach
    is that Docker becomes unaware of the network state of the container because it
    wasn't involved in network provisioning. As we'll see in [Chapter 7](ch07.html
    "Chapter 7. Working with Weave Net"), *Working with Weave Net*, Docker now also
    supports custom or third-party network drivers that help bridge the gap between
    native Docker and third-party or custom container network configurations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中看到的，Docker在处理许多容器网络需求方面做得很好。然而，这并不限制您只能使用Docker提供的网络元素来连接容器。因此，虽然Docker可以为您提供网络，但您也可以手动连接容器。这种方法的缺点是Docker对容器的网络状态不知情，因为它没有参与网络配置。正如我们将在[第7章](ch07.html
    "第7章。使用Weave Net") *使用Weave Net*中看到的，Docker现在也支持自定义或第三方网络驱动程序，帮助弥合本机Docker和第三方或自定义容器网络配置之间的差距。
- en: Manually networking containers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动网络容器
- en: In [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux Networking
    Constructs* and [Chapter 2](ch02.html "Chapter 2. Configuring and Monitoring Docker
    Networks"), *Configuring and Monitoring Docker Networks*, we reviewed common Linux
    network constructs as well as covered the Docker native options for container
    networking. In this recipe, we'll walk through how to manually network a container
    the same way that Docker does in the default bridge network mode. Understanding
    how Docker handles networking provisioning for containers is a key building block
    in understanding non-native options for container networking.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。Linux网络构造") *Linux网络构造*和[第2章](ch02.html "第2章。配置和监视Docker网络")
    *配置和监视Docker网络*中，我们回顾了常见的Linux网络构造，以及涵盖了Docker容器网络的本机选项。在这个教程中，我们将演示如何手动网络连接容器，就像Docker在默认桥接网络模式下所做的那样。了解Docker如何处理容器的网络配置是理解容器网络的非本机选项的关键构建块。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. In order to view and manipulate networking settings,
    you''ll want to ensure that you have the `iproute2` toolset installed. If not
    present on the system, it can be installed by using the command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将演示在单个Docker主机上的配置。假设这个主机已经安装了Docker，并且Docker处于默认配置。为了查看和操作网络设置，您需要确保已安装`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to manually provision a container''s network, we need to explicitly
    tell Docker not to provision a container''s network at runtime. To do this, we
    run a container using a network mode of `none`. For instance, we can start one
    of the web server containers without any network configuration by using this syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动配置容器的网络，我们需要明确告诉Docker在运行时不要配置容器的网络。为此，我们使用`none`网络模式来运行容器。例如，我们可以使用以下语法启动一个没有任何网络配置的web服务器容器：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the container starts, we can check its network configuration using the
    `docker exec` subcommand:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，我们可以使用`docker exec`子命令来检查其网络配置：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the container doesn''t have any interfaces defined besides
    its local loopback interface. At this point, there is no means to connect to the
    container. What we''ve done is essentially created a container in a bubble:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，除了本地环回接口之外，容器没有定义任何接口。此时，没有办法连接到容器。我们所做的实质上是在一个气泡中创建了一个容器：
- en: '![How to do it…](graphics/B05453_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_01.jpg)'
- en: Because we're aiming to mimic the default network configuration, we now need
    to find a way to connect the container `web1` to the `docker0` bridge and assign
    it an IP address from within the bridges IP allocation (`172.17.0.0/16`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的目标是模拟默认的网络配置，现在我们需要找到一种方法将容器`web1`连接到`docker0`桥，并从桥的IP分配（`172.17.0.0/16`）中分配一个IP地址给它。
- en: That being said, the first thing we need to do is create the interfaces that
    we'll use to connect the container to the `docker0` bridge. As we saw in [Chapter
    1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux Networking Constructs*,
    Linux has a networking component named **Virtual Ethernet** (**VETH**) pairs,
    which will work well for this purpose. One end of the interface will connect to
    the `docker0` bridge and the other end will connect to the container.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们需要做的第一件事是创建我们将用来连接容器到`docker0`桥的接口。正如我们在[第1章](ch01.html "第1章。Linux网络构造")中看到的，*Linux网络构造*，Linux有一个名为**虚拟以太网**（**VETH**）对的网络组件，这对于此目的非常有效。接口的一端将连接到`docker0`桥，另一端将连接到容器。
- en: 'Let''s start by creating our VETH pair:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建VETH对开始：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As expected, we now have two interfaces that are directly associated with each
    other. Let''s now bind one end to the `docker0` bridge and turn up the interface:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，现在我们有两个直接关联的接口。现在让我们将其中一个端口绑定到`docker0`桥上并启用该接口：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The state of the interface at this point will show as `LOWERLAYERDOWN`. This
    is because the other end of the interface is unbound and still in a down state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此时接口的状态将显示为`LOWERLAYERDOWN`。这是因为接口的另一端未绑定，仍处于关闭状态。
- en: The next step is to connect the other end of the VETH pair to the container.
    This is where things get interesting. Docker creates each container in its own
    network namespace. This means the other end of the VETH pair needs to land in
    the container's network namespace. The trick is determining what the container's
    network namespace is. The namespace for a given container can be located in two
    different ways.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将VETH对的另一端连接到容器。这就是事情变得有趣的地方。Docker会在自己的网络命名空间中创建每个容器。这意味着VETH对的另一端需要落入容器的网络命名空间。关键是确定容器的网络命名空间是什么。可以通过两种不同的方式找到给定容器的命名空间。
- en: 'The first way relies on correlating the container''s **process ID** (**PID**)
    to a defined network namespace. It''s more involved than the second method but
    gives you some good background as to some of the internals of network namespaces.
    As you might recall from [Chapter 3](ch03.html "Chapter 3. User-Defined Networks"),
    *User-Defined Networks*, by default we can''t use the command-line tool `ip netns`
    to view Docker-created namespaces. In order to view them, we need to create a
    symlink that ties the location of where Docker stores its network namespaces (`/var/run/docker/netns`),
    to the location that `ip netns` is looking (`/var/run/netns`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法依赖于将容器的**进程ID**（**PID**）与已定义的网络命名空间相关联。它比第二种方法更复杂，但可以让您了解一些网络命名空间的内部情况。您可能还记得[第3章](ch03.html
    "第3章。用户定义的网络")中所述，默认情况下，我们无法使用命令行工具`ip netns`查看Docker创建的命名空间。为了查看它们，我们需要创建一个符号链接，将Docker存储其网络命名空间的位置（`/var/run/docker/netns`）与`ip
    netns`正在查找的位置（`/var/run/netns`）联系起来。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now if we attempt to list the namespaces, we should see at least one listed
    in the return:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试列出命名空间，我们应该至少看到一个列在返回中：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But how do we know that this is the namespace associated with this container?
    To make that determination, we first need to find the PID of the container in
    question. We can retrieve this information by inspecting the container:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们怎么知道这是与此容器关联的命名空间呢？要做出这一决定，我们首先需要找到相关容器的PID。我们可以通过检查容器来检索这些信息：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have PID, we can use the `ip netns identify` subcommand to find
    the network namespace name from the PID:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了PID，我们可以使用`ip netns identify`子命令从PID中找到网络命名空间的名称：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you choose to use the second method, make sure that you create the symlink
    so that `ip netns` works for later steps.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您选择使用第二种方法，请确保创建符号链接，以便`ip netns`在后续步骤中起作用。
- en: 'The second way to find a container network namespace is much easier. We can
    simply inspect and reference the container''s network configuration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 找到容器网络命名空间的第二种方法要简单得多。我们可以简单地检查和引用容器的网络配置：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the field named `SandboxKey`. You'll notice the file path references
    the location where we said that Docker stores its network namespaces. The filename
    referenced in this path is the name of the container's network namespace. Docker
    refers to network namespaces as sandboxes, hence the naming convention used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名为`SandboxKey`的字段。您会注意到文件路径引用了我们说过Docker存储其网络命名空间的位置。此路径中引用的文件名是容器的网络命名空间的名称。Docker将网络命名空间称为沙盒，因此使用了这种命名约定。
- en: 'Now that we have the network namespace name we can build the connectivity between
    the container and the `docker0` bridge. Recall that VETH pairs can be used to
    connect network namespaces together. In this example, we''ll be placing the container
    end of the VETH pair in the container''s network namespace. This will bridge the
    container into the default network namespace on the `docker0` bridge. To do this,
    we''ll first move the container end of the VETH pair into the namespace we discovered
    earlier:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了网络命名空间名称，我们可以在容器和`docker0`桥之间建立连接。回想一下，VETH对可以用来连接网络命名空间。在这个例子中，我们将把VETH对的容器端放在容器的网络命名空间中。这将把容器桥接到`docker0`桥上的默认网络命名空间中。为此，我们首先将VETH对的容器端移入我们之前发现的命名空间中：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can validate the VETH pair is in the namespace using the `docker exec` subcommand:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker exec`子命令验证VETH对是否在命名空间中：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this point, we''ve successfully bridged the container and the default namespace
    together using a VETH pair, so our connectivity now looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已成功地使用VETH对将容器和默认命名空间连接在一起，因此我们的连接现在看起来像这样：
- en: '![How to do it…](graphics/B05453_04_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_02.jpg)'
- en: However, the container `web1` is still lacking any kind of IP connectivity since
    it has not yet been allocated a routable IP address. Recall in [Chapter 1](ch01.html
    "Chapter 1. Linux Networking Constructs"), *Linux Networking Constructs*, we saw
    that a VETH pair interface can be assigned an IP address directly. To give the
    container a routable IP address, Docker simply allocates an unused IP address
    from the `docker0` bridge subnet to the container end of the VETH pair.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，容器 `web1` 仍然缺乏任何类型的 IP 连通性，因为它尚未被分配可路由的 IP 地址。回想一下，在[第 1 章](ch01.html "第
    1 章。Linux 网络构造")中，*Linux 网络构造*，我们看到 VETH 对接口可以直接分配 IP 地址。为了给容器分配一个可路由的 IP 地址，Docker
    简单地从 `docker0` 桥的子网中分配一个未使用的 IP 地址给 VETH 对的容器端。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IPAM is a huge advantage of allowing Docker to manage your container networking
    for you. Without IPAM, you'll need to track allocations on your own and make sure
    that you don't assign any overlapping IP addresses.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IPAM 是允许 Docker 为您管理容器网络的巨大优势。没有 IPAM，你将需要自己跟踪分配，并确保你不分配任何重叠的 IP 地址。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, we could turn up the interface and we should have reachability
    to the container from the host. But before we do that let''s make things a little
    cleaner by renaming the `container_end` VETH pair to just `eth0`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以启用接口，我们应该可以从主机到容器的可达性。但在这样做之前，让我们通过将 `container_end` VETH 对重命名为 `eth0`
    来使事情变得更清晰一些：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can turn up the newly named `eth0` interface, which is the container
    side of the VETH pair:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启用新命名的 `eth0` 接口，这是 VETH 对的容器端：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we check from the host, we should now have reachability to the container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从主机检查，现在我们应该可以到达容器：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the connectivity in place, our topology now looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 连接已经建立，我们的拓扑现在看起来是这样的：
- en: '![How to do it…](graphics/B05453_04_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤…](graphics/B05453_04_03.jpg)'
- en: So, while we have IP connectivity, it's only for hosts on the same subnet. The
    last remaining piece would be to solve for container connectivity at the host
    level. For outbound connectivity the host hides the container's IP address behind
    the host's interface IP addresses. For inbound connectivity, in the default network
    mode, Docker uses port mappings to map a random high port on the Docker host's
    NIC to the container's exposed port.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们有 IP 连通性，但只限于相同子网上的主机。最后剩下的问题是解决主机级别的容器连通性。对于出站连通性，主机将容器的 IP 地址隐藏在主机接口
    IP 地址的后面。对于入站连通性，在默认网络模式下，Docker 使用端口映射将 Docker 主机的 NIC 上的随机高端口映射到容器的暴露端口。
- en: 'Solving for outbound in this case is as simple as giving the container a default
    route pointing at the `docker0` bridge and ensuring that you have a netfilter
    masquerade rule that will cover this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下解决出站问题就像给容器指定一个指向 `docker0` 桥的默认路由，并确保你有一个 netfilter masquerade 规则来覆盖这个一样简单：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you''re using the `docker0` bridge as we did in this example, you won''t
    need to add a custom netfilter masquerade rule. This is because the default masquerade
    rule already covers the entire subnet of the `docker0` bridge:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我们在这个例子中使用 `docker0` 桥，你就不需要添加自定义 netfilter masquerade 规则。这是因为默认的伪装规则已经覆盖了整个
    `docker0` 桥的子网：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For inbound services, we''ll need to create a custom rule that uses **Network
    Address Translation** (**NAT**) to map a random high port on the host to the exposed
    service port in the container. We could do that with a rule like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于入站服务，我们需要创建一个自定义规则，使用**网络地址转换**（**NAT**）将主机上的随机高端口映射到容器中暴露的服务端口。我们可以使用以下规则来实现：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we NAT the port `32799` on the host interface to port `80` on
    the container. This will allow systems on the outside network to access the web
    server running in `web1` via the Docker host's interface on port `32799`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将主机接口上的端口`32799`进行NAT转发到容器上的端口`80`。这将允许外部网络上的系统通过Docker主机的接口访问在`web1`上运行的Web服务器，端口为`32799`。
- en: 'In the end, we have successfully replicated what Docker provides in the default
    network mode:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们成功地复制了Docker在默认网络模式下提供的内容：
- en: '![How to do it…](graphics/B05453_04_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](graphics/B05453_04_04.jpg)'
- en: This should give you some appreciation for what Docker does behind the scenes.
    Keeping track of container IP addressing, port allocations for published ports,
    and the `iptables` rule set are three of the major things that Docker tracks on
    your behalf. Given the ephemeral nature of containers, this would be almost impossible
    to do manually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让您对Docker在幕后所做的事情有所了解。跟踪容器IP地址、发布端口的端口分配以及`iptables`规则集是Docker代表您跟踪的三个主要事项。鉴于容器的短暂性质，手动完成这些工作几乎是不可能的。
- en: Specifying your own bridge
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定您自己的桥接
- en: In the majority of network scenarios, Docker relies heavily on the `docker0`
    bridge. The `docker0` bridge is created automatically when the Docker engine service
    is started and is the default connection point for any containers spawned by the
    Docker service. We also saw in earlier recipes that it was possible to modify
    some of this bridge's attributes at a service level. In this recipe, we'll show
    you how to tell Docker to use a different bridge entirely.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络场景中，Docker严重依赖于`docker0`桥。`docker0`桥是在启动Docker引擎服务时自动创建的，并且是Docker服务生成的任何容器的默认连接点。我们在之前的配方中也看到，可以在服务级别修改这个桥的一些属性。在这个配方中，我们将向您展示如何告诉Docker使用完全不同的桥接。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. In order to view and manipulate networking settings,
    you''ll want to ensure that you have the `iproute2` toolset installed. If not
    present on the system, it can be installed using the command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将演示在单个Docker主机上的配置。假设这个主机已经安装了Docker，并且Docker处于默认配置状态。为了查看和操作网络设置，您需要确保安装了`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Much like any of the other service level parameters, specifying a different
    bridge for Docker to use is done through updating the systemd drop-in file we
    showed you how to create in [Chapter 2](ch02.html "Chapter 2. Configuring and
    Monitoring Docker Networks"), *Configuring and Monitoring Docker Networks*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他服务级参数一样，指定Docker使用不同的桥接是通过更新我们在[第2章](ch02.html "第2章。配置和监控Docker网络")中向您展示如何创建的systemd
    drop-in文件来完成的，*配置和监控Docker网络*。
- en: 'Before we specify the new bridge, let''s first make sure that there are no
    containers running, stop the Docker service, and delete the `docker0` bridge:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定新桥之前，让我们首先确保没有正在运行的容器，停止Docker服务，并删除`docker0`桥：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, the default `docker0` bridge has been deleted. Now, let's create
    a new bridge for Docker to use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，默认的`docker0`桥已被删除。现在，让我们为Docker创建一个新的桥接。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren't familiar with the `iproute2` command-line tool please refer to
    the examples in [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`iproute2`命令行工具，请参考[第1章](ch01.html "第1章。Linux网络构造")中的示例，*Linux网络构造*。
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We first created a bridge named `mybridge1`, then gave it an IP address of
    `10.11.12.1/24`, and finally turned up the interface. At this point, the interface
    is up and reachable. We can now tell Docker to use this bridge as its default
    bridge. To do this, edit the systemd drop-in file for Docker and make sure that
    the last line reads as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个名为`mybridge1`的桥接，然后给它分配了IP地址`10.11.12.1/24`，最后启动了接口。此时，接口已经启动并可达。现在我们可以告诉Docker使用这个桥接作为其默认桥接。要做到这一点，编辑Docker的systemd
    drop-in文件，并确保最后一行如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now save the file, reload the systemd configuration, and start the Docker service:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，重新加载systemd配置，并启动Docker服务：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now if we start a container, we should see it assigned to the bridge `mybridge1`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动一个容器，我们应该看到它被分配到桥接`mybridge1`上：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that the `docker0` bridge was not created when the service was started.
    Also, notice that we see one side of a VETH pair in the default namespace whose
    master interface is `mybridge1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在服务启动时并未创建`docker0`桥接。还要注意，我们在默认命名空间中看到了一个VETH对的一端，其主接口为`mybridge1`。
- en: 'Using what we learned from the first recipe in this chapter, we can also confirm
    that the other end of the VETH pair is in the container''s network namespace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们从本章第一个配方中学到的知识，我们还可以确认VETH对的另一端在容器的网络命名空间中：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can tell this is a VETH pair because it uses the `<interface>@<interface>`
    naming syntax. And if we compare the VETH pair interface numbers, we can see that
    these two are a match with the host side of the VETH pair, having an index of
    `22` connecting to the container side of the VETH pair with an index of `21`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看出这是一个VETH对，因为它使用`<interface>@<interface>`的命名语法。如果我们比较VETH对接口的编号，我们可以看到这两个与VETH对的主机端匹配，索引为`22`连接到VETH对的容器端，索引为`21`。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll probably notice that I flip between using the `ip netns exec` and `docker
    exec` commands to execute commands inside a container. The point of that is not
    to be confusing but rather to show what Docker is doing on your behalf. It should
    be noted that, in order to use the `ip netns exec` syntax, you need the symlink
    in place that we demonstrated in an earlier recipe. Using the `ip netns exec`
    is only required when you're manually configuring namespaces.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我在使用`ip netns exec`和`docker exec`命令在容器内执行命令时来回切换。这样做的目的不是为了混淆，而是为了展示Docker代表您在做什么。需要注意的是，为了使用`ip
    netns exec`语法，您需要在我们在早期配方中演示的位置放置符号链接。只有在手动配置命名空间时才需要使用`ip netns exec`。
- en: 'If we look at the network configuration of the container, we can see that Docker
    has assigned it an IP address within the range of the `mybridge1` subnet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看容器的网络配置，我们可以看到Docker已经为其分配了`mybridge1`子网范围内的IP地址：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Docker is now also keeping track of IP allocations for the bridge as it allocates
    container IP addresses. IP address management is a large understated value that
    Docker provides in the container network space. Mapping IP addresses to containers
    and managing that on your own would be a significant undertaking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Docker也在为桥接分配IP地址时跟踪IP分配。IP地址管理是Docker在容器网络空间提供的一个重要价值。将IP地址映射到容器并自行管理将是一项重大工作。
- en: 'The last piece of this would be handling the NAT configuration for the container.
    Since the `10.11.12.0/24` space is not routable, we''ll need to hide or masquerade
    the container''s IP address behind a physical interface on the Docker host. Luckily,
    so long as Docker is managing the bridge for you, Docker still takes care of making
    the appropriate netfilter rules. We can make sure that this is in place by inspecting
    the netfilter ruleset:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分将是处理容器的NAT配置。由于`10.11.12.0/24`空间不可路由，我们需要隐藏或伪装容器的IP地址在Docker主机上的物理接口后面。幸运的是，只要Docker为您管理桥，Docker仍然会负责制定适当的netfilter规则。我们可以通过检查netfilter规则集来确保这一点：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, since we exposed ports on the container with the `-P` flag, the
    inbound NAT has also been allocated. We can see this NAT translation as well in
    the DOCKER chain of the same preceding output. In summary, as long as you're using
    a Linux bridge, Docker will handle the entire configuration for you just as it
    did with the `docker0` bridge.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们使用`-P`标志在容器上暴露端口，入站NAT也已分配。我们还可以在相同的输出中看到这个NAT转换。总之，只要您使用的是Linux桥，Docker将像使用`docker0`桥一样为您处理整个配置。
- en: Using an OVS bridge
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OVS桥
- en: For users that are looking for additional features, **OpenVSwitch** (**OVS**)
    is becoming a popular replacement for the native Linux bridge. OVS offers a dramatic
    enhancement to the Linux bridge at the cost of a slightly higher level of complexity.
    For instance, an OVS bridge cannot be managed directly by the `iproute2` toolset
    we have been using up to this point and requires its own command-line management
    tools. However, if you're looking for features that don't exist on the Linux bridge,
    OVS is likely your best choice. Docker cannot natively manage an OVS bridge, so
    using one requires that you build the connectivity between the bridge and the
    container manually. That is, we can't just tell the Docker service to use an OVS
    bridge rather than the default `docker0` bridge. In this recipe, we'll show how
    to install, configure, and connect containers directly to an OVS bridge in place
    of the standard `docker0` bridge.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于寻找额外功能的用户来说，OpenVSwitch（OVS）正在成为本地Linux桥的流行替代品。OVS在略微更高的复杂性的代价下，为Linux桥提供了显著的增强。例如，OVS桥不能直接由我们到目前为止一直在使用的`iproute2`工具集进行管理，而是需要自己的命令行管理工具。然而，如果您正在寻找在Linux桥上不存在的功能，OVS很可能是您的最佳选择。Docker不能本地管理OVS桥，因此使用OVS桥需要手动建立桥和容器之间的连接。也就是说，我们不能只是告诉Docker服务使用OVS桥而不是默认的`docker0`桥。在本教程中，我们将展示如何安装、配置和直接连接容器到OVS桥，以取代标准的`docker0`桥。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. In order to view and manipulate networking settings
    you''ll want to ensure that you have the `iproute2` toolset installed. If not
    present on the system, it can be installed using the command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示在单个Docker主机上的配置。假设该主机已安装了Docker，并且Docker处于默认配置。为了查看和操作网络设置，您需要确保已安装`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The first step we''ll need to perform is to install OVS on our Docker host.
    To do this, we can pull down the OVS package directly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的第一步是在我们的Docker主机上安装OVS。为了做到这一点，我们可以直接拉取OVS包：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As mentioned earlier, OVS has its own command-line toolset and one of the tools
    is named `ovs-vsctl`, which is used to directly manage OVS bridges. More specifically,
    `ovs-vsctl` is used to view and manipulate the OVS configuration database. To
    ensure that OVS gets installed correctly, we can run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OVS有自己的命令行工具集，其中一个工具被命名为`ovs-vsctl`，用于直接管理OVS桥。更具体地说，`ovs-vsctl`用于查看和操作OVS配置数据库。为了确保OVS正确安装，我们可以运行以下命令：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This returns the OVS version number and verifies that we have communication
    to OVS. The next thing we want to do is to create an OVS bridge. To do it, we''ll
    once again use the `ovs-vsctl` command-line tool:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回OVS版本号，并验证我们与OVS的通信。我们接下来要做的是创建一个OVS桥。为了做到这一点，我们将再次使用`ovs-vsctl`命令行工具：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command will add an OVS bridge named `ovs_bridge`. Once created, we can
    view the bridge interface just like we did any other network interface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将添加一个名为`ovs_bridge`的OVS桥。创建后，我们可以像查看任何其他网络接口一样查看桥接口：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, to view any bridge-specific information, we''ll once again need to
    rely on the `ocs-vsctl` command-line tool. We can see information about the bridge
    using the `show` subcommand:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要查看任何特定于桥的信息，我们将再次需要依赖`ocs-vsctl`命令行工具。我们可以使用`show`子命令查看有关桥的信息：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Assigning the OVS bridge an IP address and changing its state can once again
    be done using the more familiar `iproute2` tools:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为OVS桥分配IP地址并更改其状态可以再次使用更熟悉的`iproute2`工具完成：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once up, the interface acts much like any other bridge interface. We can see
    the IP interface is up and the local host can access it directly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，接口就像任何其他桥接口一样。我们可以看到IP接口已经启动，本地主机可以直接访问它：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next thing we want to do is to create our VETH pair that we''ll use to
    connect a container to the OVS bridge:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是创建我们将用来连接容器到OVS桥的VETH对：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once created, we need to add the OVS end of the VETH pair to the OVS bridge.
    This is one of the big areas where OVS differs from a standard Linux bridge. Each
    connection to OVS is in the form of a port. This is a much stronger imitation
    of a physical switch than what the Linux bridge provides. Once again, because
    we''re interacting directly with the OVS bridge, we''ll need to use the `ovs-vsctl`
    command-line tool:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们需要将VETH对的OVS端添加到OVS桥上。这是OVS与标准Linux桥有很大区别的地方之一。每个连接到OVS的都是以端口的形式。这比Linux桥提供的更像是物理交换机。再次强调，因为我们直接与OVS桥交互，我们需要使用`ovs-vsctl`命令行工具：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once added, we can query the OVS to see all the bridge''s ports:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，我们可以查询OVS以查看所有桥接口的端口：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you examine the defined interfaces, you''ll see that the OVS end of the
    VETH pair lists `ovs-system` as its master:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查定义的接口，您会看到VETH对的OVS端将`ovs-system`列为其主机：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Without getting into too much detail, this is expected. The `ovs-system` interface
    represents the OVS data path. For now, just know that this is the expected behavior.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不要深入细节，这是预期的。`ovs-system`接口代表OVS数据路径。现在，只需知道这是预期的行为即可。
- en: 'Now that the OVS end is completed, we need to focus on the container end. The
    first step here will be to start a container without any network configuration.
    Next, we''ll follow the same steps we did earlier to manually connect a container
    namespace to the other end of a VETH pair:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在OVS端已经完成，我们需要专注于容器端。这里的第一步将是启动一个没有任何网络配置的容器。接下来，我们将按照之前的步骤手动连接容器命名空间到VETH对的另一端：
- en: 'Start the container:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动容器：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Find the containers network namespace:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找容器的网络命名空间：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Move the container end of the VETH pair into that namespace:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将VETH对的容器端移入该命名空间：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Rename the VETH interface to `eth0`:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将VETH接口重命名为`eth0`：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Set `eth0` interface''s IP address to a valid IP in that subnet:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`eth0`接口的IP地址设置为该子网中的有效IP：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Bring the container-side interface up
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动容器端的接口
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Bring the OVS side of the VETH pair up:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动VETH对的OVS端：
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, the container is successfully connected to the OVS and reachable
    through the host:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，容器已成功连接到OVS，并可以通过主机访问：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to dig a little deeper into OVS, we can examine the switches'' MAC
    address table by using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更深入地了解OVS，可以使用以下命令查看交换机的MAC地址表：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice the MAC address that it learned on port `1`. But what is port `1`? To
    look at all of the ports for a given OVS you can use this command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它在`port 1`上学到的MAC地址。但`port 1`是什么？要查看给定OVS的所有端口，可以使用以下命令：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we can see that `port 1` is the OVS bridge that we provisioned and what
    we attached the OVS end of the VETH pair to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`port 1`是我们预配的OVS桥，我们将VETH对的OVS端连接到了这里。
- en: 'As we can see, the amount of work required to make the connection to OVS can
    be extensive. Luckily, there are some great tools out there that can help make
    this a lot easier. One of the more notable tools was built by Jérôme Petazzoni
    and is named **Pipework**. It''s available on GitHub at the following URL:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，连接到OVS所需的工作量可能很大。幸运的是，有一些很棒的工具可以帮助我们简化这个过程。其中一个比较显著的工具是由Jérôme Petazzoni开发的，名为**Pipework**。它可以在GitHub上找到，网址如下：
- en: '[https://github.com/jpetazzo/pipework](https://github.com/jpetazzo/pipework)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jpetazzo/pipework](https://github.com/jpetazzo/pipework)'
- en: If we use Pipework to plumb the connections to OVS, and assume that the bridge
    is already created, we can take the number of steps required to connect the container
    to the bridge from `6` to `1`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Pipework来连接到OVS，并假设桥已经创建，我们可以将连接容器到桥所需的步骤从`6`减少到`1`。
- en: 'To use Pipework, you must first download it from GitHub. This can be done by
    using the Git client:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Pipework，必须先从GitHub上下载它。可以使用Git客户端完成这一步：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To demonstrate using Pipework, let''s start a new container named `web2` without
    any network configuration:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用Pipework，让我们启动一个名为`web2`的新容器，没有任何网络配置：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, all we have to do to connect this container to our existing OVS bridge
    is to run the following command, which specifies the name of the OVS bridge ,
    the container name, and the IP address we wish to assign to the container:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做的就是将这个容器连接到我们现有的OVS桥上，只需运行以下命令，指定OVS桥的名称、容器名称和我们希望分配给容器的IP地址：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Pipework takes care of all the leg work for us including resolving the container
    name to a network namespace, creating a unique VETH pair, properly placing the
    ends of the VETH pair in the container and on the specified bridge, and assigning
    the container an IP address.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Pipework会为我们处理所有的工作，包括将容器名称解析为网络命名空间，创建一个唯一的VETH对，正确地将VETH对的端点放在容器和指定的桥上，并为容器分配一个IP地址。
- en: 'Pipework can also help us add additional interfaces to a container on the fly.
    Considering that we started this container with a network mode of `none`, the
    container currently only has a connection to the OVS based on the first Pipework
    configuration. However, we can add the connection to the `docker0` bridge back
    by using Pipework as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Pipework还可以帮助我们在运行时为容器添加额外的接口。考虑到我们以`none`网络模式启动了这个容器，容器目前只有根据第一个Pipework配置连接到OVS。然而，我们也可以使用Pipework将连接添加回`docker0`桥：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The syntax is similar, but in this case we specify the interface name we wanted
    to use (`eth0`) and also add a gateway for the interface of `172.17.0.1`. This
    will allow the container to use the `docker0` bridge as a default gateway and,
    in turn, allow it outbound access using the default Docker masquerade rule. We
    can verify the configuration is present in the container with a couple, `docker
    exec` commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 语法类似，但在这种情况下，我们指定了要使用的接口名称（`eth0`），并为`172.17.0.1`的接口添加了一个网关。这将允许容器使用`docker0`桥作为默认网关，并且允许它使用默认的Docker伪装规则进行出站访问。我们可以使用一些`docker
    exec`命令验证配置是否存在于容器中：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So while Pipework can make a lot of this manual work easier, you should always
    look to see if Docker has a native means to provide the network connectivity you're
    looking for. Having Docker manage your container network connectivity has lots
    of benefits including automatic IPAM allocations and netfilter configuration for
    inbound and outbound connectivity to your containers. Many of these non-native
    configurations already have third-party Docker network plugins in the works that
    will allow you to leverage them seamlessly from Docker.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然Pipework可以使许多这些手动工作变得更容易，但您应该始终查看Docker是否有本机手段来提供您正在寻找的网络连接。让Docker管理您的容器网络连接具有许多好处，包括自动IPAM分配和用于入站和出站连接的netfilter配置。许多这些非本机配置已经有第三方Docker网络插件在进行中，这将允许您无缝地利用它们从Docker中。
- en: Using an OVS bridge to connect Docker hosts
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OVS桥连接Docker主机
- en: The previous recipe showed how we can use OVS in place of a standard Linux bridge.
    This, by itself, isn't very interesting since it doesn't do a lot more than a
    standard Linux bridge can. What may be interesting is using some of the more advanced
    features of OVS in conjunction with your Docker containers. For instance, once
    the OVS bridges are created, it's rather trivial to provision GRE tunnels between
    two distinct Docker hosts. This would allow any containers connected to either
    Docker host to talk directly to each other. In this recipe, we'll discuss the
    configuration required to connect two Docker hosts using an OVS provided GRE tunnel.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个教程展示了我们如何可以使用OVS来代替标准的Linux桥。这本身并不是很有趣，因为它并没有比标准的Linux桥做更多的事情。可能有趣的是，与您的Docker容器一起使用OVS的一些更高级的功能。例如，一旦创建了OVS桥，就可以相当轻松地在两个不同的Docker主机之间配置GRE隧道。这将允许连接到任一Docker主机的任何容器直接彼此通信。在这个教程中，我们将讨论使用OVS提供的GRE隧道连接两个Docker主机所需的配置。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, this recipe is for the purpose of example only. This behavior is already
    supported by Docker's user-defined overlay network type. If for some reason you
    need to use GRE rather than VXLAN, this might be a suitable alternative. As always,
    make sure that you use any Docker native networking constructs before you start
    customizing your own. It will save you a lot of headache down the road!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个教程仅用于举例说明。这种行为已经得到Docker的用户定义的覆盖网络类型的支持。如果出于某种原因，您需要使用GRE而不是VXLAN，这可能是一个合适的替代方案。与往常一样，在开始自定义之前，请确保您使用任何Docker本机网络构造。这将为您节省很多麻烦！
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be demonstrating the configuration on two Docker hosts.
    The hosts need to be able to talk to each other across the network. It is assumed
    that hosts have Docker installed and that Docker is in its default configuration.
    In order to view and manipulate networking settings, you''ll want to ensure that
    you have the `iproute2` toolset installed. If not present on the system, it can
    be installed by using the command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将演示在两个Docker主机上的配置。这些主机需要能够在网络上相互通信。假设主机已经安装了Docker，并且Docker处于默认配置。为了查看和操作网络设置，您需要确保已安装了`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: For the purpose of this recipe, we'll start by assuming a base configuration
    on both hosts used in this example. That is, each host only has Docker installed,
    and its configuration is unchanged from the default.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我们将假设在本例中使用的两台主机上有一个基本配置。也就是说，每台主机只安装了Docker，并且其配置与默认配置相同。
- en: 'The topology we''ll use will look like what''s shown in the following image.
    Two Docker hosts on two distinct subnets:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的拓扑将如下图所示。两个不同子网上的两个Docker主机：
- en: '![How to do it…](graphics/B05453_04_05.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_05.jpg)'
- en: 'The goal of this configuration will be to provision OVS on each host, connect
    the containers to the OVS, and then connect the two OVS switches together to allow
    OVS-to-OVS direct communication over GRE. We''ll follow these steps on each host
    to accomplish this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置的目标是在每台主机上配置OVS，将容器连接到OVS，然后将两个OVS交换机连接在一起，以允许通过GRE进行OVS之间的直接通信。我们将在每台主机上按照以下步骤来实现这一目标：
- en: Install OVS.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装OVS。
- en: Add an OVS bridge named `ovs_bridge`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ovs_bridge`的OVS桥。
- en: Assign that bridge an IP address.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该桥分配一个IP地址。
- en: Run a container with its network mode set to `none`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个网络模式设置为`none`的容器。
- en: Use Pipework to connect that container to the OVS bridge (it is assumed that
    you have Pipework installed on each host. If you do not, please refer to the previous
    recipe for installation steps).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Pipework将该容器连接到OVS桥（假设每台主机上都安装了Pipework。如果没有，请参考之前的安装步骤）。
- en: Build a GRE tunnel to the other host using OVS.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OVS在另一台主机上建立一个GRE隧道。
- en: 'Let''s start the configuration on the first host `docker1`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一台主机`docker1`开始配置：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, you should have a container up and running. You should be able
    to reach the container from the local Docker host:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该有一个正在运行的容器。您应该能够从本地Docker主机访问该容器：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s perform a similar configuration on the second host `docker3`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在第二台主机`docker3`上执行类似的配置：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This completes the configuration of the second host. Ensure that you have connectivity
    to the `web2` container running on the local host:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了对第二台主机的配置。确保您可以连接到本地主机上运行的`web2`容器：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At this point, our topology looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的拓扑看起来是这样的：
- en: '![How to do it…](graphics/B05453_04_06.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_06.jpg)'
- en: 'If our goal is to allow the container `web1` to talk directly to the container
    `web2`, we would have two options. First, since Docker is unaware of the OVS switch,
    it is not attempting to apply netfilter rules based on containers connected to
    it. That being said, with the correct routing configuration, the two containers
    could natively route to each other. However, even in this trivial example, that
    would be a lot of configuration. Since we''re sharing a common subnet between
    the two hosts (as Docker does even in its default mode), the configuration becomes
    less than trivial. To make this work, you would need to do the following things:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是允许容器`web1`直接与容器`web2`通信，我们将有两个选项。首先，由于Docker不知道OVS交换机，它不会尝试根据连接到它的容器应用netfilter规则。也就是说，通过正确的路由配置，这两个容器可以直接路由到彼此。然而，即使在这个简单的例子中，这也需要大量的配置。由于我们在两台主机之间共享一个公共子网（就像Docker在默认模式下一样），配置变得不那么简单。为了使其工作，您需要做以下几件事：
- en: Add routes into each container telling them that the specific `/32` route for
    the other container lived off subnet. This is because each container believes
    that the entire `10.11.12.0/24` network is local since they both have an interface
    on that network. You would need a prefix more specific (smaller) than `/24` to
    force the container to route to reach the destination.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个容器中添加路由，告诉它们另一个容器的特定`/32`路由位于子网之外。这是因为每个容器都认为整个`10.11.12.0/24`网络是本地的，因为它们都在该网络上有一个接口。您需要一个比`/24`更具体（更小）的前缀来强制容器路由以到达目的地。
- en: Add routes on each Docker host telling them that the specific `/32` route for
    the other containers lived off subnet. Again, this is because each host believes
    that the entire `10.11.12.0/24` network is local since they both have an interface
    on that network. You would need a prefix more specific (smaller) than `/24` to
    force the host to route to reach the destination.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Docker主机上添加路由，告诉它们另一个容器的特定`/32`路由位于子网之外。同样，这是因为每个主机都认为整个`10.11.12.0/24`网络是本地的，因为它们都在该网络上有一个接口。您需要一个比`/24`更具体（更小）的前缀来强制主机路由以到达目的地。
- en: Add routes on the multilayer switch, so it knows that `10.11.12.100` is reachable
    via `10.10.10.101` (`docker1`) and `10.11.12.200` is reachable via `192.168.50.101`
    (`docker3`).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多层交换机上添加路由，以便它知道`10.11.12.100`可以通过`10.10.10.101`（`docker1`）到达，`10.11.12.200`可以通过`192.168.50.101`（`docker3`）到达。
- en: 'Now imagine if you were working with a real network and had to add those routes
    on every device in the path. The second, and better, option is to create a tunnel
    between the two OVS bridges. This would prevent the network from ever seeing the
    `10.11.12.0/24` traffic, which means it doesn''t need to know how to route it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果你正在处理一个真实的网络，并且必须在路径上的每个设备上添加这些路由。第二个，也是更好的选择是在两个OVS桥之间创建隧道。这将阻止网络看到`10.11.12.0/24`的流量，这意味着它不需要知道如何路由它：
- en: '![How to do it…](graphics/B05453_04_07.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_07.jpg)'
- en: Fortunately for us, this configuration is easy to do with OVS. We simply add
    another OVS port of type GRE and specify the other Docker host as the remote tunnel
    destination.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于我们来说，这个配置在OVS上很容易实现。我们只需添加另一个类型为GRE的OVS端口，并指定另一个Docker主机作为远程隧道目的地。
- en: 'On the host `docker1`, build the GRE tunnel as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机`docker1`上，按以下方式构建GRE隧道：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the host `docker3`, build the GRE tunnel as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机`docker3`上，按以下方式构建GRE隧道：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'At this point, the two containers should be able to communicate with one another
    directly:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，两个容器应该能够直接相互通信：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As a final proof that this is traversing the GRE tunnel, we can run `tcpdump`
    on one of the host''s physical interfaces while doing a ping test between the
    containers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终证明这是通过GRE隧道传输的，我们可以在主机的一个物理接口上运行`tcpdump`，同时在容器之间进行ping测试：
- en: '![How to do it…](graphics/B05453_04_08.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_08.jpg)'
- en: OVS and Docker together
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OVS和Docker一起
- en: 'The recipes until this point have shown several possibilities for what''s possible
    when manually configuring Docker networks. Although these are all possible solutions,
    they all require a fair amount of manual intervention and configuration and are
    not easily consumable in their current form. If we use the previous recipe as
    an example, there are a few notable drawbacks:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些配方展示了手动配置Docker网络时可能出现的几种可能性。尽管这些都是可能的解决方案，但它们都需要大量的手动干预和配置，并且在它们当前的形式下不容易消化。如果我们以前的配方作为例子，有一些显著的缺点：
- en: You are responsible for keeping track of IP allocations on the containers increasing
    your risk of assigning conflicting IP addresses to different containers
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您负责跟踪容器上的IP分配，增加了将不同容器分配冲突的风险
- en: There is no dynamic port mapping or inherent outbound masquerading to facilitate
    communication between a container and the rest of the network
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有动态端口映射或固有的出站伪装来促进容器与网络的通信。
- en: While we used Pipework to lessen the configuration burden, there was still a
    fair amount of manual configuration that needed to be done to connect a container
    to the OVS bridge
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们使用了Pipework来减轻配置负担，但仍然需要进行相当多的手动配置才能将容器连接到OVS桥接器。
- en: The majority of the configuration would not persist through a host reboot by
    default
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数配置默认情况下不会在主机重启后持久化。
- en: This being said, using what we've learned so far, there is a different way that
    we can leverage the GRE capability of OVS while still using Docker to manage container
    networking. In this recipe, we'll review that solution as well as describe how
    to make it a more persistent solution that will survive a host reboot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，根据我们迄今所学到的知识，我们可以利用OVS的GRE功能的另一种方式，同时仍然使用Docker来管理容器网络。在这个示例中，我们将回顾这个解决方案，并描述如何使其成为一个更持久的解决方案，可以在主机重启后仍然存在。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, this recipe is for the purpose of example only. This behavior is already
    supported by Docker's user-defined overlay network type. If for some reason, you
    need to use GRE rather than VXLAN, this might be a suitable alternative. As always,
    make sure that you use any Docker native networking constructs before you start
    customizing your own. It will save you a lot of headache down the road!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个示例仅用于举例说明。这种行为已经得到Docker的用户定义的覆盖网络类型的支持。如果出于某种原因，您需要使用GRE而不是VXLAN，这可能是一个合适的替代方案。与以往一样，在开始自定义之前，请确保使用任何Docker原生网络构造。这将为您节省很多麻烦！
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be demonstrating the configuration on two Docker hosts.
    The hosts need to be able to talk to each other across the network. It is assumed
    that hosts have Docker installed and that Docker is in its default configuration.
    In order to view and manipulate networking settings, you''ll want to ensure that
    you have the `iproute2` toolset installed. If not present on the system, it can
    be installed using the command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示在两个Docker主机上的配置。这些主机需要能够通过网络相互通信。假设主机已安装了Docker，并且Docker处于默认配置状态。为了查看和操作网络设置，您需要确保已安装了`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要具有根级别的访问权限。
- en: How to do it…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Using the previous recipe for inspiration, our new topology will look similar,
    but will have one significant difference:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 受到上一个示例的启发，我们的新拓扑将看起来类似，但有一个重要的区别：
- en: '![How to do it…](graphics/B05453_04_09.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_04_09.jpg)'
- en: You'll notice that each host now has a Linux bridge named `newbridge`. We're
    going to tell Docker to use this bridge rather than the `docker0` bridge for default
    container connectivity. This means that we're only using OVS for its GRE capabilities
    turning it into a slave to `newbridge`. Using a Linux bridge for container connectivity
    means that Docker is able to do IPAM for us as well as handle inbound and outbound
    netfilter rules. Using a bridge other than `docker0` has more to do with configuration
    than usability, as we'll see shortly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到每个主机现在都有一个名为`newbridge`的Linux桥。我们将告诉Docker使用这个桥而不是`docker0`桥来进行默认容器连接。这意味着我们只是使用OVS的GRE功能，将其变成`newbridge`的从属。使用Linux桥进行容器连接意味着Docker能够为我们进行IPAM，并处理入站和出站netfilter规则。使用除`docker0`之外的桥接器更多是与配置有关，而不是可用性，我们很快就会看到。
- en: 'We''re going to once again start the configuration from scratch assuming that
    each host only has Docker installed in its default configuration. The first thing
    we want to do is to configure the two bridges we''ll be using on each host. We''ll
    start with the host `docker1`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从头开始配置，假设每个主机只安装了Docker的默认配置。我们要做的第一件事是配置每个主机上将要使用的两个桥接。我们将从主机`docker1`开始：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At this point, we have both an OVS bridge as well as a standard Linux bridge
    configured on the host. To finish up the bridge configuration, we need to create
    the GRE interface on the OVS bridge and then bind the OVS bridge to the Linux
    bridge:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们在主机上配置了OVS桥和标准Linux桥。为了完成桥接配置，我们需要在OVS桥上创建GRE接口，然后将OVS桥绑定到Linux桥上。
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that the bridge configuration is complete, we can tell Docker to use `newbridge`
    as its default bridge. We do that by editing the systemd drop-in file and adding
    the following options:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在桥接配置已经完成，我们可以告诉Docker使用`newbridge`作为其默认桥接。我们通过编辑systemd drop-in文件并添加以下选项来实现这一点：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that, in addition to telling Docker to use a different bridge, I'm also
    telling Docker to only allocate container IP addressing from `10.11.12.128/26`.
    When we configure the second Docker host (`docker3`), we'll tell Docker to only
    assign container IP addressing from `10.11.12.192/26`. This is a hack, but it
    prevents the two Docker hosts from issues overlapping IP addresses without having
    to be aware of what the other host has already allocated.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了告诉Docker使用不同的桥接之外，我还告诉Docker只从`10.11.12.128/26`分配容器IP地址。当我们配置第二个Docker主机（`docker3`）时，我们将告诉Docker只从`10.11.12.192/26`分配容器IP地址。这是一个技巧，但它可以防止两个Docker主机在不知道对方已经分配了什么IP地址的情况下出现重叠的IP地址问题。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 3](ch03.html "Chapter 3. User-Defined Networks"), *User-Defined Networks*,
    demonstrated that the native overlay network gets around this by tracking IP allocations
    between all hosts that participate in the overlay network.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户定义网络")，“用户定义网络”表明，本地覆盖网络通过跟踪参与覆盖网络的所有主机之间的IP分配来解决了这个问题。'
- en: 'To make Docker use the new options, we need to reload the system configuration
    and restart the Docker service:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Docker使用新的选项，我们需要重新加载系统配置并重新启动Docker服务：
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And finally, start a container without specifying a network mode:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动一个容器而不指定网络模式：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As expected, the first container we ran gets the first available IP address
    in the `10.11.12.128/26` network. Now, let''s move on to configuring the second
    host `docker3`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们运行的第一个容器获得了`10.11.12.128/26`网络中的第一个可用IP地址。现在，让我们继续配置第二个主机`docker3`：
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'On this host, tell Docker to use the following options by editing the systemd
    drop-in file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主机上，通过编辑systemd drop-in文件，告诉Docker使用以下选项：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Reload the system configuration and restart the Docker service:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载系统配置并重新启动Docker服务：
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now spin up a container on this host:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这个主机上启动一个容器：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'At this point, each container should be able to talk to the other across the
    GRE tunnel:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，每个容器应该能够通过GRE隧道相互通信：
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In addition, each host still has all the benefits Docker provides through IPAM,
    publishing ports, and container masquerading for outbound access.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个主机仍然可以通过IPAM、发布端口和容器伪装来获得Docker提供的所有好处，以便进行出站访问。
- en: 'We can verify port publication:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证端口发布：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And we can verify outbound access through the default Docker masquerade rule:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过默认的Docker伪装规则验证出站访问：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The last advantage to this setup is that we can easily make it persist through
    host reboots. The only configuration that will need to be recreated will be the
    configuration for the Linux bridge `newbridge` and the connection between `newbridge`
    and the OVS bridge. To make this persistent, we can add the following configuration
    in each host's network configuration file (`/etc/network/interfaces`).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的最后一个优点是我们可以很容易地使其在主机重启后保持。唯一需要重新创建的配置将是Linux桥接`newbridge`和`newbridge`与OVS桥接之间的连接的配置。为了使其持久化，我们可以在每个主机的网络配置文件(`/etc/network/interfaces`)中添加以下配置。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ubuntu will not process bridge-related configuration in the interface's file
    unless you have the bridge utilities package installed on the host.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在主机上安装了桥接实用程序包，否则Ubuntu不会处理与桥接相关的接口文件中的配置。
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Host `docker1`:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机`docker1`：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Host `docker3`:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机`docker3`：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: By putting the `newbridge` configuration information into the network start
    script, we accomplish two tasks. First, we create the bridge that Docker is expecting
    to use before the actual Docker service starts. Without this, the Docker service
    would fail to start because it couldn't find the bridge. Second, this configuration
    allows us to bind the OVS to `newbridge` at the same time that the bridge is created
    by specifying the bridge's `bridge_ports`. Because this configuration was done
    manually before through the `ip link` command, the binding would not persist through
    a system reboot.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将`newbridge`配置信息放入网络启动脚本中，我们完成了两项任务。首先，在实际Docker服务启动之前，我们创建了Docker期望使用的桥接。如果没有这个，Docker服务将无法启动，因为它找不到这个桥接。其次，这个配置允许我们通过指定桥接的`bridge_ports`在创建桥接的同时将OVS绑定到`newbridge`上。因为这个配置之前是通过`ip
    link`命令手动完成的，所以绑定不会在系统重启后保持。
