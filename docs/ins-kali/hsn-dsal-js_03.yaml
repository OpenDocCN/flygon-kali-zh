- en: Using Sets and Maps for Faster Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合和映射加速应用程序
- en: '**Sets** and **maps** are two notoriously simple-looking data structures, that
    have been standardized in the latest version of ES6.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**和**映射**是两种看似简单的数据结构，在最新版本的ES6中已经标准化。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why do we need sets and maps?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要集合和映射？
- en: When and how to use sets and maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何使用集合和映射
- en: ES6 API of sets and maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6中集合和映射的API
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: A performance comparison
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能比较
- en: Exploring the origin of sets and maps
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索集合和映射的起源
- en: Before we try and understand how to use sets and maps in real-world applications,
    it is more meaningful to understand the origin of sets and maps and why we need
    them in JavaScript in the first place.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们试图了解如何在现实世界的应用程序中使用集合和映射之前，更有意义的是了解集合和映射的起源，以及为什么我们首先需要它们在JavaScript中。
- en: 'Traditional arrays, until ES5, did not support a few major features, that developers
    usually want to leverage:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 直到ES5之前，传统数组不支持开发人员通常想要利用的一些主要功能：
- en: Acknowledging that it contains a particular element
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承认它包含一个特定的元素
- en: Adding new elements without having duplicates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新元素而不产生重复。
- en: 'This led to developers implementing their own versions of sets and maps,which
    were available in other programming languages. A common implementation of a set
    and map using JavaScript''s `Object` is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致开发人员实现了自己的集合和映射版本，这在其他编程语言中是可用的。使用JavaScript的`Object`来实现集合和映射的常见方法如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although a lot of prototype headaches can be avoided by using`Object.create`to
    create the set or map*, *it still does not resolve the fact that the main `Key`that
    is being held can only be a `string` because `Object`only allows keys as strings,
    so we could unintentionally end up with values overwriting each other:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`Object.create`创建集合或映射可以避免很多原型问题，但它仍然不能解决一个问题，那就是主要的`Key`只能是一个`string`，因为`Object`只允许键为字符串，所以我们可能会无意中得到值互相覆盖：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Analyzing set and map types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析集合和映射类型
- en: Before actually using sets and maps,we will need to understand when and where
    we need to use them. Each data structure whether native or custom has its own
    strengths and weaknesses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用集合和映射之前，我们需要了解何时以及何地需要使用它们。每种数据结构，无论是原生的还是自定义的，都有其自己的优势和劣势。
- en: Not only is it important to utilize these strengths, it's much more important
    to avoid their weaknesses. To understand some of these, we will explore set and
    map types and why they are needed and where to employ them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些优势是非常重要的，更重要的是避免它们的弱点。为了理解其中一些弱点，我们将探讨集合和映射类型，以及它们为何需要以及在哪里使用。
- en: 'There are primarily four different set and map types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有四种不同的集合和映射类型：
- en: '**Map**: A key-value pair in which the key can either be an `Object` or a primitive
    and can hold any arbitrary value.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：一个键值对，其中键可以是一个`Object`或一个原始值，可以容纳任意值。'
- en: '**WeakMap**: A key-value pair in which the key can only be an `Object` and
    can hold any arbitrary value. The Keys are weakly referenced; this means that
    they are not prevented from being garbage-collected if not in use.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WeakMap**：一个键值对，其中键只能是一个`Object`，可以容纳任意值。键是弱引用的；这意味着如果不使用，它们不会被阻止被垃圾回收。'
- en: '**Set**: Data type that allows a user to store unique values of any type.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：允许用户存储任何类型的唯一值的数据类型。'
- en: '**WeakSet**: Similar to set, but maintains a weak reference.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WeakSet**：类似于集合，但维护一个弱引用。'
- en: How weak is WeakMap?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WeakMap有多弱？
- en: By now, we all know what a map is and how to add keys and values, at least in
    theory. However, how do you determine when to use a map and when to use a `WeakMap`?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们都知道什么是映射，以及如何添加键和值，至少在理论上。然而，如何确定何时使用映射，何时使用`WeakMap`呢？
- en: Memory management
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: 'The official definition of a `WeakMap` as per MDN ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap))
    is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MDN的官方定义([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap))，`WeakMap`的官方定义如下：
- en: The WeakMap object is a collection of key/value pairs in which the keys are
    weakly referenced. The keys must be objects and the values can be arbitrary values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap对象是一个键/值对的集合，其中键是弱引用。键必须是对象，值可以是任意值。
- en: The key emphasis is on *weakly referenced. *
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重点在于*弱引用*。
- en: Before comparing `Map` and `WeakMap`*,* it is crucial to understand when to
    use a particular data structure. If you need to know the keys of the collection
    at any time or if you need to iterate over your collection, then you will need
    to use a `Map` over a `WeakMap` because keys are not enumerable, that is, you
    cannot get a list of the keys available in the latter, as it only maintains a
    weak reference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较`Map`和`WeakMap`之前，了解何时使用特定的数据结构是至关重要的。如果您需要随时知道集合的键，或者需要遍历集合，那么您将需要使用`Map`而不是`WeakMap`，因为键是不可枚举的，也就是说，您无法获得后者中可用键的列表，因为它只维护了一个弱引用。
- en: 'So, naturally, the preceding statement should raise two questions in your mind:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自然而然地，前面的陈述应该在你的脑海中引起两个问题：
- en: What happens if I always use a map?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我总是使用映射会发生什么？
- en: Nothing really, life goes on. You may or may not end up with memory leaks, depending
    on how well you have used your map. For the most part, you will be fine.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没什么，生活还在继续。你可能会或可能不会遇到内存泄漏，这取决于你如何使用你的映射。在大多数情况下，你会没事的。
- en: What is a weak reference?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是弱引用？
- en: 'A weak reference is something that allows everything an object refers to be
    garbage-collected in the event all the referrers are removed. Confused? Good.
    Let''s take a look at the following example to understand it better:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱引用是一种允许对象引用的所有内容在所有引用者被移除时被垃圾回收的东西。困惑吗？很好。让我们看下面的例子来更好地理解它：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We all know that the IIFE is primarily used so that we can immediately execute
    a function and remove its scope so that we can avoid memory leaks. In this case,
    although we have wrapped the `key` and map setter in an IIFE, the `key`does not
    get garbage-collected because internally the `Map`still holds a reference to the
    `key` and its value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道IIFE主要用于立即执行函数并删除其作用域，以避免内存泄漏。在这种情况下，尽管我们已经将`key`和地图设置器包装在IIFE中，但`key`并没有被垃圾回收，因为在内部`Map`仍然保留对`key`及其值的引用：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the same code is written with a `WeakMap`*, *once the IIFE is executed,
    the key and the value of that key are removed from memory because the key is taken
    out of scope; this helps to keep memory usage to a minimum.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`WeakMap`*编写相同的代码时，*一旦执行IIFE，键和该键的值将从内存中删除，因为键已经超出了作用域；这有助于将内存使用量保持在最低水平。
- en: API differences
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API差异
- en: 'The API for `Map` and `WeakMap` is very similar when it comes to standard operations,
    such as `set()` and `get()`. This makes the API very straightforward and contains
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准操作方面，`Map`和`WeakMap`的API非常相似，例如`set()`和`get()`。这使得API非常直观，并包括以下内容：
- en: '`Map.prototype.size`: Returns the size of the map; not available on typical
    objects unless you loop and count'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.size`：返回地图的大小；在典型对象上不可用，除非您循环并计数'
- en: '`Map.prototype.set`: Sets a value for a given key and returns the entire new
    map'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.set`：为给定键设置值并返回整个新地图'
- en: '`Map.prototype.get`: Gets a value for a given key and returnsundefined if not
    found'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.get`：获取给定键的值，如果未找到则返回undefined'
- en: '`Map.prototype.delete`: Deletes a value for a given key and returns `true`
    if deletion was successful, otherwise `false`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.delete`：删除给定键的值并在删除成功时返回`true`，否则返回`false`'
- en: '`Map.prototype.has`: Checks the map for the presence of an element with the
    key provided; returns boolean'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.has`：检查地图中是否存在具有提供的键的元素；返回布尔值'
- en: '`Map.prototype.clear`: Clears the map; returns nothing'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.clear`：清除地图；返回空'
- en: '`Map.prototype.forEach`: Loops over the map and gives access to each element'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.forEach`：循环遍历地图并访问每个元素'
- en: '`Map.prototype.entries`: Returns an iterator on which you can apply the `next()`
    method to get the value of the next element in `Map`, for example, `mapIterator.next().value`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.entries`：返回一个迭代器，您可以在其上应用`next()`方法以获取`Map`中下一个元素的值，例如`mapIterator.next().value`'
- en: '`Map.prototype.keys`: Similar to `entries`*;* returns an iterator that can
    be used to get access to the next value'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.keys`：类似于`entries`*；*返回一个迭代器，可用于访问下一个值'
- en: '`Map.prototype.values`: Similar to `key`; returns access to values'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.values`：类似于`key`；返回对值的访问'
- en: The main difference comes in when accessing anything related to keys and the
    values for a `WeakMap`*. *As described earlier, because of the enumeration challenge
    in case of the `WeakMap`, methods such as `size()`, `forEach()`, `entries()`,
    `keys()`, and `values()` are not available in  `WeakMap`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于访问与`WeakMap`*相关的键和值的任何内容。*如前所述，由于在`WeakMap`的情况下存在枚举挑战，因此诸如`size()`、`forEach()`、`entries()`、`keys()`和`values()`等方法在`WeakMap`中不可用。
- en: Sets versus WeakSets
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合与WeakSets
- en: Now, we understand the fundamental meaning of weakin the term `WeakMap` or `WeakSet`*. *It
    is not very complex to predict how sets work and how `WeakSet` differs from them.
    Let's take a quick look at the functional difference and then move on to the API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解了`WeakMap`或`WeakSet`*中weak*一词的基本含义。预测集合的工作方式以及`WeakSet`与其不同并不是非常复杂。让我们快速看一下功能差异，然后转向API。
- en: Understanding WeakSets
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解WeakSets
- en: '`WeakSet` is very similar to `WeakMap`; the values that a `WeakSet` can hold
    are only objects and cannot be primitives just like in the case of a `WeakMap`.
    The `WeakSets` are also not enumerable, so you do not have direct access to the
    values available inside the set.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet`与`WeakMap`非常相似；`WeakSet`可以容纳的值只能是对象，不能是原始值，就像`WeakMap`的情况一样。`WeakSets`也不可枚举，因此您无法直接访问集合中可用的值。'
- en: 'Let''s create a small example and understand the difference between a `Set`
    and a `WeakSet`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小例子，了解`Set`和`WeakSet`之间的区别：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One important thing to note is that `WeakSet` does not accept primitives and
    can only accept objects similar to the `WeakMap` keys.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要注意的是`WeakSet`不接受原始值，只能接受与`WeakMap`键类似的对象。
- en: 'The output of the preceding code is as follows, which is what was expected
    from the `WeakSet`. `WeakSet` does not retain elements beyond the lifespan of
    the variables that were holding them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下，这是从`WeakSet`中预期的。`WeakSet`不会保留元素超出持有它们的变量的寿命：
- en: '![](assets/ccaeefe6-894e-48df-bc1b-b094d0e96b30.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ccaeefe6-894e-48df-bc1b-b094d0e96b30.png)'
- en: As expected, the `WeakSet` is empty once the IIFE is terminated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，一旦IIFE终止，`WeakSet`就为空了。
- en: The API difference
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API差异
- en: 'The API difference as documented in `WeakMap` case of maps is pretty close
    to what you can find for Sets as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeakMap`地图的情况下，文档中记录的API差异与集合的情况非常接近：
- en: '`Set.prototype.size`: Returns the size of the set'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.size`：返回集合的大小'
- en: '`Set.prototype.add`: Adds a value for a given element and returns the entire
    new set'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.add`：为给定元素添加值并返回整个新集合'
- en: '`Set.prototype.delete`: Deletes an element and returns `true` if delete was
    successful, otherwise `false`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.delete`：删除一个元素并在删除成功时返回`true`，否则返回`false`'
- en: '`Set.prototype.has`: Checks the set for the presence of an element and returns
    a Boolean'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.has`：检查集合中是否存在元素并返回布尔值'
- en: '`Set.prototype.clear`: Clears the set and returns nothing'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.clear`：清除集合并返回空'
- en: '`Set.prototype.forEach`: Loops over the set and gives access to each element'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.forEach`：循环遍历集合并访问每个元素'
- en: '`Set.prototype.values`: Returns an iterator, which can be used to get access
    to the next value'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.values`：返回一个迭代器，可用于访问下一个值'
- en: '`Set.prototype.keys`: Similar to values—returns access to values in the set'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.keys`：类似于values—返回对集合中值的访问'
- en: '`WeakSet`, on the other hand, does not contain the `forEach()`*,* `keys()`,
    and `values()` methods for reasons discussed previously.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`WeakSet`不包含`forEach()`、`keys()`和`values()`方法，原因在先前讨论过。
- en: Use cases
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Before we start off with use cases, let's create a base application, that will
    be reused for each of the examples just like we did in [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用用例之前，让我们创建一个基础应用程序，它将像我们在[第1章](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml)中所做的那样，为每个示例重复使用。
- en: 'The following section is a quick recap of creating a base Angular application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分是创建基本 Angular 应用程序的快速回顾：
- en: Creating an Angular application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Angular 应用程序
- en: Before moving on to the individual use cases, we will first create the Angular
    application which will work as the base for our examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入个别用例之前，我们将首先创建 Angular 应用程序，这将作为我们示例的基础。
- en: 'Follow the given commands to get up and running with the application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的命令启动应用程序：
- en: 'Install the Angular CLI:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Angular CLI：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new project in the folder of your choice by running the following
    command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令在您选择的文件夹中创建一个新项目：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After these two steps, you should be able to see the new project created and
    all the corresponding node modules installed and ready to go.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这两个步骤后，您应该能够看到新创建的项目以及所有相应的节点模块已安装并准备就绪。
- en: 'To run your application, run the following command from a Terminal:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行您的应用程序，请从终端运行以下命令：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating custom keyboard shortcuts for your application
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的应用程序创建自定义键盘快捷键
- en: In most cases, creating a web application means having a beautiful UI with unobstructed
    data. You want your user to have a fluid experience without having to go through
    the hassle of clicking through multiple pages, which can become quite a hassle
    sometimes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，创建 Web 应用程序意味着拥有一个美观的 UI 和无障碍的数据。您希望用户能够流畅地体验，而不必通过点击多个页面来解决问题，有时这可能会变得相当麻烦。
- en: Take any IDE, for example. As useful as they are and as easy as they make our
    lives on a day-to-day basis, imagine not having simple shortcuts in them, such
    as code indentation. Sorry for the scare, but it is true that having minor details
    like these can make the user experience very fluid, making users come back for
    more.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 拿任何IDE来说吧。尽管它们非常有用，而且在日常生活中非常方便，但想象一下如果它们没有简单的快捷方式，比如代码缩进。抱歉吓到你了，但事实上，像这样的细节可以使用户体验非常流畅，让用户愿意再次使用。
- en: 'Let''s now create a simple set of keyboard shortcuts that you can provide to
    your application to make things a lot easier for your end user. To create this,
    you will need the following things:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一组简单的键盘快捷键，您可以为您的应用程序提供，以使最终用户的操作变得更加简单。要创建这个，您需要以下东西：
- en: A web application (we created one earlier)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Web 应用程序（我们之前创建了一个）
- en: A set of features, which you want to be able to control with the keyboard
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组您希望能够使用键盘控制的功能
- en: An implementation simple enough to make adding new features to it very simple
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个足够简单的实现，使得向其添加新功能非常简单
- en: If you remember the *custom back button *from [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*, we are going to create an
    application that is something similar. Let's quickly put together the example
    application again. For detailed instructions, you can follow the same example (Creating
    an Angular Application) from [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得来自[第1章](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml)的*自定义返回按钮*，我们将创建一个类似的应用程序。让我们快速再次组合示例应用程序。有关详细说明，您可以按照相同的示例（创建
    Angular 应用程序）从[第1章](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml)中进行。
- en: Creating an Angular application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Angular 应用程序
- en: 'Create the application:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create multiple states (About, Dashboard, Home, and Profile) with basic templates
    under `src/pages` folder:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/pages`文件夹下创建多个状态（About、Dashboard、Home 和 Profile）并添加基本模板：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the routing for that state under `<component_name>.routing.ts`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<component_name>.routing.ts`下创建该状态的路由：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the new `routes` and `Components` to the application''s main routing file
    `app.routing.ts` next to `app.module.ts`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.routing.ts`文件中添加新的`routes`和`Components`到应用程序的主路由文件`app.module.ts`旁边：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Register the routes with your application using `RouterModule` and declare
    your `navigatableComponents`in the `app.module.ts` file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RouterModule`注册应用程序的路由，并在`app.module.ts`文件中声明您的`navigatableComponents`：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the HTML template to load the four routes in `app.component.html`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 HTML 模板以在`app.component.html`中加载四个路由：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you have performed all the steps listed previously, run the following
    command in your Terminal; the web app should be up-and-running with four states
    for you to toggle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了之前列出的所有步骤，请在终端中运行以下命令；Web 应用程序应该已经运行，并具有四个状态供您切换：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating states with keymap
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 keymap 创建状态
- en: So far, what we have declared in the states (or routes) is the path and the
    component that we want to go with them. What Angular does allow us to do is add
    a new property called **data**to the route configuration. This allows us to add
    any data that we would like regarding any route. In our case, it works out very
    well because we want to be able to toggle routes based on the keys a user presses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在状态（或路由）中我们声明的是路径和我们想要与其一起使用的组件。Angular 允许我们添加一个名为**data**的新属性到路由配置中。这允许我们添加关于任何路由的任何数据。在我们的情况下，这非常有效，因为我们希望能够根据用户按下的键来切换路由。
- en: 'So, let''s take an example route that we have defined previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们以前定义的一个示例路由为例：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will now modify this and add the new `data` property to the route configuration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将修改这个，并在路由配置中添加新的`data`属性：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that we have added a property called `keymap` and its value `ctrl+h`;
    we will do the same for all the other routes defined as well. One important thing
    to nail down in the very beginning is the anchor key (`ctrl`, in this case) that
    is going to be used alongside a secondary identifying key (`h` for the home route).
    This really helps filter down key presses that the user may making within your
    application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们添加了一个名为`keymap`的属性及其值`ctrl+h`；我们也将对所有其他定义的路由执行相同的操作。在一开始要确定的一个重要事项是锚键（在这种情况下是`ctrl`），它将与次要的标识键（在这里是`h`代表主页路由）一起使用。这真的有助于过滤用户在应用程序中可能进行的按键。
- en: Once we have the keymaps associated with each of the routes, we can register
    all of these keymaps when the app loads and then start tracking user activity
    to determine whether they have selected any of our predefined keymaps.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将每个路由与键映射关联起来，我们就可以在应用程序加载时注册所有这些键映射，然后开始跟踪用户活动，以确定他们是否选择了我们预定义的键映射中的任何一个。
- en: To register the keymaps, in the `app.component.ts`file, we will first define
    the `Map` in which we are going to hold all the data and then extract the data
    from the routes before adding it to `Map`*:*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册键映射，在`app.component.ts`文件中，我们将首先定义我们将保存所有数据的`Map`，然后从路由中提取数据，然后将其添加到`Map`中：*：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the data is added to the `keyMap`, we will need to listen to user interactions
    and determine where the user wants to navigate. To do that, we can use the `@HostListener` decorator
    provided by Angular, listen for any keypress events, and then filter item down
    based on the application''s requirements, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被添加到`keyMap`中，我们将需要监听用户交互，并确定用户想要导航到哪里。为此，我们可以使用Angular提供的`@HostListener`装饰器，监听任何按键事件，然后根据应用程序的要求过滤项目，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There we have it! We can now define and navigate to routes easily whenever a
    user makes a keypress. However, before we move on, we will need to take another
    perspective here to understand the next step. Consider you are the end user and
    not the developer. How do you know what the bindings are? What do you do when
    you want to bind not just the routes on a page but also the buttons? How do you
    know whether you are pressing the wrong keys?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地定义和导航到路由，每当用户进行按键时。然而，在我们继续之前，我们需要换个角度来理解下一步。考虑一下，你是最终用户，而不是开发人员。你怎么知道绑定是什么？当你想要绑定页面上的路由以及按钮时，你该怎么办？你怎么知道自己是否按错了键？
- en: All of this can be fixed with a very simple UX review of what we have so far
    and what we need instead. One thing that is clear is that we need to show the
    user what they are selecting so that they do not keep pounding our application
    with incorrect key combinations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过对我们目前的情况进行非常简单的UX审查来解决，以及我们需要的东西。很明显，我们需要向用户显示他们正在选择的内容，以便他们不会用错误的键组合不断地攻击我们的应用程序。
- en: First, to inform our users of what they can select, let's modify the navigation
    in such a way that the first character of each of the route names is highlighted.
    Let's also create a variable to hold the value that the user is selecting, display
    that on the UI, and clear it out after a few milliseconds.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了告知用户他们可以选择什么，让我们修改导航，以便每个路由名称的第一个字符被突出显示。让我们还创建一个变量来保存用户选择的值，在UI上显示它，并在几毫秒后清除它。
- en: 'We can modify our `app.component.scss`to that effect, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的`app.component.scss`文件，如下所示：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our template gets an addition at the very end to show the key the user has
    pressed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板在最后增加了一个内容，显示用户按下的键：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our `app.component.ts` in its final form is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.component.ts`最终形式如下：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way, the user is always informed of their options and what they are selecting,
    making the overall usability of your application a lot higher.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用户总是知道他们的选择，使您的应用程序的整体可用性更高。
- en: '![](assets/bd9059e2-55a9-491f-af36-38ca734c80db.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd9059e2-55a9-491f-af36-38ca734c80db.png)'
- en: Irrespective of what the user selects, they will always see their selection
    at the bottom-right side of the screen as long as the *Ctrl* key is pressed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用户选择什么，只要按住*Ctrl*键，他们总是会在屏幕的右下角看到他们的选择。
- en: Activity tracking and analytics for web applications
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序的活动跟踪和分析
- en: Whenever someone mentions analytics, especially for web applications, the first
    thing that usually comes to mind is something such as Google analytics or new
    relic. Although they do an amazing job at collecting analytics, such as page views
    and custom events, these tools keep the data with them and do not let you download/export
    the raw data. It becomes necessary to build your own custom modules to track user
    actions and activity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人提到分析，特别是针对网络应用程序时，通常首先想到的是像Google分析或新的遗迹之类的东西。尽管它们在收集页面浏览和自定义事件等分析方面做得很好，但这些工具会将数据保留在它们那里，不允许您下载/导出原始数据。因此，有必要构建自己的自定义模块来跟踪用户操作和活动。
- en: Activity tracking and analytics are complex and can quickly get out of hand
    with growing application size. In this use case, we will build a simple web application
    in which we will be tracking custom actions that a user is taking and lay down
    some groundwork for syncing application data with the server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 活动跟踪和分析是复杂的，随着应用程序规模的增长，很快就会失控。在这个用例中，我们将构建一个简单的网络应用程序，我们将跟踪用户正在进行的自定义操作，并为将应用程序数据与服务器同步打下一些基础。
- en: Before we jump into coding, let's discuss briefly what our approach is going
    to be and how we are going to take advantage of the Angular components that are
    available to us. In our application, we will build a basic form for the user,
    which they get to fill out and submit. As and when the user interacts with the
    different components available on the form, we will start tracking the user activity
    and then extract some custom data based on the events generated. This custom data
    is obviously going to change based on the application that is being built. For
    brevity, we will simply track the time of the event, the *x* and *y* coordinates,
    and custom values (if any).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们简要讨论一下我们的方法将是什么，以及我们将如何利用可用的Angular组件。在我们的应用程序中，我们将为用户构建一个基本表单，他们可以填写并提交。当用户与表单上可用的不同组件进行交互时，我们将开始跟踪用户活动，然后根据生成的事件提取一些自定义数据。这些自定义数据显然会根据正在构建的应用程序而改变。为简洁起见，我们将简单地跟踪事件的时间、*x*和*y*坐标以及自定义值（如果有）。
- en: Creating the Angular application
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Angular应用程序
- en: 'First, let''s create an Angular application like we did in the preceding use
    case:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个Angular应用程序，就像我们在前面的用例中所做的那样：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should create the app and it should be ready to go. Just go into your
    project folder and run the following command to see your app running:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该创建应用程序，并且应该准备就绪。只需进入您的项目文件夹并运行以下命令即可查看您的应用程序运行：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the application is up, we will include Angular material just so we can
    quickly have a nice form up and running. To install material in your Angular application,
    run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，我们将包含Angular材料，这样我们就可以快速拥有一个漂亮的表单。要在您的Angular应用程序中安装材料，请运行以下命令：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once `material` is installed, include the module of your choice in your main
    `app.module.js`*, *which, in this case, is going to be `MatInputModule `and `ReactiveFormsModule`
    because we will need them to create the forms. After this, your `app.module.js`
    will look something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`material`后，在主`app.module.js`*中包含您选择的模块*，在这种情况下，将是`MatInputModule`和`ReactiveFormsModule`，因为我们将需要它们来创建表单。之后，您的`app.module.js`将如下所示：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the application set up, we can set up our template, which
    is going to be fairly straightforward, so let us add the following template to
    our `app.component.html` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了应用程序，我们可以设置我们的模板，这将是非常简单的，所以让我们将以下模板添加到我们的`app.component.html`文件中：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a simple form with standard fields for user details; we will style
    it a little bit so that it''s centered on the page so we can update our `app.component.scss`
    file to contain our styles:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有用户详细信息标准字段的简单表单；我们将稍微调整它的样式，使其居中显示在页面上，因此我们可以更新我们的`app.component.scss`文件以包含我们的样式：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here''s the end result on the UI:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UI上的最终结果：
- en: '![](assets/aac34955-40d0-4a7a-b6b1-81464b9d5560.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aac34955-40d0-4a7a-b6b1-81464b9d5560.png)'
- en: Now that we have the form ready, we want an activity tracker, which is going
    to be extremely lightweight as we will be calling this quite frequently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好表单，我们需要一个活动跟踪器，这将非常轻量级，因为我们将经常调用它。
- en: A good practice is to have the tracker logic moved into a web worker; that way,
    your tracker will not take up the only available thread, thus freeing up your
    application from any extra load.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的做法是将跟踪逻辑移入Web Worker；这样，您的跟踪器将不会占用唯一可用的线程，从而使您的应用程序免受任何额外负载的影响。
- en: Before we actually start creating a web worker, we will need something to invoke
    our worker; for this, we will create a tracker service. Also, to make the worker
    includable in an Angular project, we will add it to the `scripts` option of the
    `.angular-cli.json` file, which will allow us to use this as an external script
    called `scripts.bundle.js `which is generated from the file `utils/tracker.js`
    by `webpack.`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际开始创建Web Worker之前，我们需要一些东西来调用我们的工作人员；为此，我们将创建一个跟踪器服务。此外，为了使工作人员可以包含在Angular项目中，我们将将其添加到`.angular-cli.json`文件的`scripts`选项中，这将允许我们将其用作外部脚本调用`scripts.bundle.js`，该脚本是由`webpack`从文件`utils/tracker.js`生成的。
- en: 'Let''s create a folder called `tracker` under a folder called `services`, then
    create a `tracker.service.ts` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`services`的文件夹下创建一个名为`tracker`的文件夹，然后创建一个`tracker.service.ts`文件：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nothing out of the ordinary here; we initialized the worker when we triggered
    the service and added an `addEvent()` method, which takes in a few parameters
    such as the name of the event (key), the event data (or parts of it), and custom
    values (if any). The rest of the logic we defer to the worker so that our application
    is seamless.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的；当我们触发服务并添加了`addEvent()`方法时，我们初始化了工作人员，该方法接受一些参数，如事件的名称（键）、事件数据（或其部分）和自定义值（如果有）。我们将其余的逻辑推迟到工作人员，以便我们的应用程序是无缝的。
- en: 'However, to trigger the constructor of the service, we will need to add the
    service to the providers of the main module. So, our `app.module.ts` now updates
    to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要触发服务的构造函数，我们需要将服务添加到主模块的提供者中。因此，我们的`app.module.ts`现在更新为以下内容：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Good, we now have the application bootstrapped and the worker set up. However,
    what is actually calling the `addEvent()` method to track these custom events?
    You can do one or both of the following things:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经启动了应用程序并设置好了工作人员。但是，实际上是什么在调用`addEvent()`方法来跟踪这些自定义事件的？您可以执行以下一项或两项操作：
- en: Inject the `TrackerService` into your component/service and call the `addEvent()`
    method with the right parameters
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`TrackerService`注入到您的组件/服务中，并使用正确的参数调用`addEvent()`方法
- en: Create a directive to capture clicks and sync data using the `addEvent()` method
    on the `TrackerService`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指令来捕获点击并使用`TrackerService`上的`addEvent()`方法同步数据
- en: 'We will take the second approach for this example as we have a form and do
    not want to add a click handler to each and every element. Let''s create a `directives` folder and
    another folder called `tracker`, which will contain our `tracker.directive.ts`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将采用第二种方法，因为我们有一个表单，不想为每个元素添加点击处理程序。让我们创建一个`directives`文件夹和另一个名为`tracker`的文件夹，其中将包含我们的`tracker.directive.ts`：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see that the directive is pretty lean; it injects the `TrackerService`
    and then triggers the `addEvent()` method on a click.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到指令非常简洁；它注入了`TrackerService`，然后在点击时触发`addEvent()`方法。
- en: 'To consume this, all we need is to add the directive to the input elements
    on the form that we created earlier, like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们只需要将指令添加到之前创建的表单的输入元素中，就像这样：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, when the user interacts with any field on the form, our worker is notified
    of the change, and it's now up to our worker to basically batch the events and
    save them on the server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户与表单上的任何字段进行交互时，我们的worker会收到更改通知，现在我们的worker基本上要批量处理事件并将其保存在服务器上。
- en: 'Let''s quickly recap what we have done so far:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们到目前为止所做的事情：
- en: We set up the worker and invoked it via the constructor of our `TrackerService`,
    which gets instantiated on app start.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了worker并通过我们的`TrackerService`的构造函数调用它，该构造函数在应用程序启动时实例化。
- en: 'We created a simple directive capable of detecting clicks, extracting event
    information, and passing it on to the `TrackerService` to be forwarded to our
    worker:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的指令，能够检测点击，提取事件信息，并将其传递给`TrackerService`，以便转发给我们的worker。
- en: '![](assets/0029140d-ddc4-4378-a13e-3bfb18339ba9.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0029140d-ddc4-4378-a13e-3bfb18339ba9.png)'
- en: The preceding screenshot shows the directory structure of the application so
    far.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了到目前为止应用程序的目录结构。
- en: Our next step will be to update our worker so that we can easily handle the
    data that is coming in and send it to the server based on whatever logic your
    application sees fit.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步将是更新我们的worker，以便我们可以轻松处理传入的数据，并根据应用程序的逻辑将其发送到服务器。
- en: 'Let''s break this worker under `utils/tracker.js` down into simple steps it''s
    made up of:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`utils/tracker.js`下的worker分解为简单的步骤：
- en: 'The worker receives the message from the `TrackerService`, and this message is
    then forwarded to be added to the master list of events:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工人从`TrackerService`接收消息，然后将该消息转发以添加到事件主列表中：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will do something different here by maintaining two lists, one for just the
    keys that are being saved and another that maps the keys to the collection of
    data that we are receiving.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过维护两个列表来做一些不同的事情，一个用于保存正在保存的键，另一个将键映射到我们正在接收的数据集合。
- en: 'The `addEvent()` method then decomposes the incoming data and stores it in
    a master list of items being collected to be synced up with the database:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addEvent()`方法然后分解传入的数据并将其存储在正在收集的项目的主列表中，以便与数据库同步：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will try to check whether the user has already interacted with the provided
    key's element. If that's true, we will just append it to the existing collection
    of events; otherwise, we will create a new one. This check is where we leverage
    setsand their extremely fast `has()` method, which we will explore in the next
    section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试检查用户是否已经与提供的键的元素进行了交互。如果是，我们将其追加到现有的事件集合中；否则，我们将创建一个新的事件集合。这个检查是我们利用集合及其极快的`has()`方法的地方，我们将在下一节中探讨。
- en: Apart from this, the only logic that we will need now is to sync this data with
    the server based on predetermined logic. As you can see, right now we are just
    doing this based on a random number but, of course, that is not recommended for
    a production application. What you can do instead is learn based on how much your
    user is interacting with the application, and sync accordingly. For some application
    tracking services, this is way too much, so they go with the simpler approach
    of either syncing at a regular interval (in the order of a few seconds) or syncing
    based on the payload size. You can take up any of these approaches as your application
    demands.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们现在唯一需要的逻辑是根据预定的逻辑将这些数据与服务器同步。正如你所看到的，现在我们只是基于一个随机数来做这个，但是，当然，这对于生产应用程序是不推荐的。相反，你可以根据用户与应用程序的交互程度来学习，并相应地进行同步。对于一些应用程序跟踪服务来说，这太多了，所以他们采用更简单的方法，要么按照固定的时间间隔进行同步（几秒钟的顺序），要么根据有效负载大小进行同步。你可以根据应用程序的需求采取任何这些方法。
- en: 'However, once you have that nailed down, everything is pretty straightforward:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你掌握了这一点，一切都很简单：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One peculiar thing to note here is the way we are transforming data to an array
    before we send it to the server. Could we have just passed the entire `sessionData` here?
    Perhaps, but it's a Map, which means the data is not accessible as-is and you
    would have to use `.entires()` or `.values()` to get an Iterator Object on which
    you can iterate to get the data from the map. Having worked with arrays a lot,
    it may seem a little backward to have to transform data before sending it to the
    server, but it's well worth the effort given the other benefits that Maps provide
    to our applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一件奇怪的事情是，在将数据发送到服务器之前，我们将数据转换为数组的方式。也许我们可以直接传递整个`sessionData`？也许，但它是一个Map，这意味着数据无法直接访问，你必须使用`.entires()`或`.values()`来获取一个迭代器对象，然后可以迭代地从地图中获取数据。虽然在处理数组时，需要在将数据发送到服务器之前转换数据似乎有点倒退，但考虑到Map为我们的应用程序提供的其他好处，这样做是非常值得的。
- en: 'Let''s now take a look at how it all comes together in our `tracker.js` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看在我们的`tracker.js`文件中如何将所有内容整合在一起：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can note in the preceding code, sets and mapssilently, yet effectively,
    change how we designed our application. Instead of having a simple array and an
    object, we will actually get to use some concrete data structures with fixed set
    of APIs, which allows us to simplify our application logic.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的代码中所注意到的，集合和映射悄然而有效地改变了我们设计应用程序的方式。我们不再只有一个简单的数组和一个对象，而是实际上可以使用一些具体的数据结构和一组固定的API，这使我们能够简化我们的应用程序逻辑。
- en: Performance comparison
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能比较
- en: 'In this section, we will compare the performance of sets and maps against their
    counterparts: arrays and objects. As mentioned in earlier chapters, the main goal
    of doing a comparison is not to know that the data structures are superior to
    their native counterparts but to understand their limitations and ensure that
    we make an informed decision when trying to use them.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较集合和映射与它们的对应物：数组和对象的性能。正如前几章所述，进行比较的主要目标不是要知道数据结构优于其本机对应物，而是要了解它们的局限性，并确保在尝试使用它们时做出明智的决定。
- en: It's very important to take benchmarks with a grain of salt. Benchmarking tools
    often use engines such as V8, which are built and optimized to run in a way that
    is very different from some other web-based engines. This may cause the results
    to be a little skewed based on the environment in which your application runs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要以一颗谷物的方式对待基准测试。基准测试工具通常使用诸如V8之类的引擎，这些引擎被构建和优化以以一种与其他一些基于Web的引擎非常不同的方式运行。这可能导致结果在应用程序运行的环境中有些偏差。
- en: 'We will need to do some initial set up to run our performance benchmark. To
    create a Node.js project, go to a Terminal and run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些初始设置来运行我们的性能基准测试。要创建一个Node.js项目，请转到终端并运行以下命令：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will set up an empty directory; now, go into the directory and run the
    `npm` initialization command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个空目录；现在，进入目录并运行`npm`初始化命令：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This step will ask you a series of questions, and all of them can be filled
    out or left blank, as you wish.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步将询问您一系列问题，所有问题都可以填写或留空，视您的意愿而定。
- en: 'Once the project is set up, next we will need the benchmarking tool, which
    we can install using `npm`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置好后，接下来我们将需要基准测试工具，我们可以使用`npm`安装它：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we are ready to start running some benchmark suites.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始运行一些基准测试套件。
- en: Sets and Arrays
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和数组
- en: 'Creating and running suites is very easy thanks to the `benchmark` tool. All
    we will need is to set up our `sets-arr.js` file, and we are good-to-go:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`benchmark`工具，创建和运行`suite`非常容易。我们只需要设置我们的`sets-arr.js`文件，然后就可以开始了：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see that the setup is pretty self-explanatory. Once we create the new
    `suite`, we set up some data for the initial load and then we can add our tests
    to the `suite`*:*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到设置非常简单明了。一旦创建了新的`suite`，我们为初始加载设置一些数据，然后可以将我们的测试添加到`suite`中：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To execute this `suite`, you can run the following command from a Terminal:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个`suite`，您可以从终端运行以下命令：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The results of the `suite` are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`suite`的结果如下：'
- en: '![](assets/7e351e82-f7b2-45cc-87a9-871f22b5b482.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e351e82-f7b2-45cc-87a9-871f22b5b482.png)'
- en: Note that the sets are a little faster than the arrays in this setup. Of course,
    the data that we are using in the tests can also cause variations in the results;
    you can try this out by switching between the data types that are being stored
    in the array and the set.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个设置中，集合比数组稍快。当然，我们在测试中使用的数据也会导致结果的变化；您可以通过在数组和集合中存储的数据类型之间切换来尝试一下。
- en: Maps and Objects
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射和对象
- en: 'We will have a similar setup for Maps and Objects in a file called `maps-obj.js`,
    which will give us something like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为`maps-obj.js`的文件中为映射和对象设置类似的设置，这将给我们类似以下的东西：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, to run this `suite`, run the following command on a Terminal:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行这个`suite`，请在终端上运行以下命令：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will give us the following result:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '![](assets/937b1b92-e459-4b9f-b9af-75dd595ea39c.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/937b1b92-e459-4b9f-b9af-75dd595ea39c.png)'
- en: You can see that the `Object` hugely outperforms the map and is clearly the
    better of the two here, but it does not provide the syntactical sugar and some
    features that the map is capable of.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`Object`在这里远远优于映射，并且显然是两者中更好的，但它不提供映射能够提供的语法糖和一些功能。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we delved into sets and maps, their weaker counterparts, and
    their APIs. Then, we used sets and maps in few real-world examples such as applications
    with keyboard shortcuts for navigation powered by sets and an application analytics
    tracker powered by sets and maps. Then, we concluded the chapter with a performance
    comparison between objects and arrays.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了集合和映射，它们的较弱对应物以及它们的API。然后，我们在一些真实世界的例子中使用了集合和映射，比如使用集合进行导航的应用程序的键盘快捷键和使用集合和映射进行应用程序分析跟踪器。然后，我们通过对象和数组之间的性能比较结束了本章。
- en: In the next chapter, we will be exploring trees and how we can leverage them
    to make our web applications faster with reduced code complexity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨树以及如何利用它们使我们的Web应用程序更快，代码复杂性更低。
