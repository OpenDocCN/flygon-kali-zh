- en: Improving Resilience Using Resilience4j
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Resilience4j改进弹性
- en: 'In this chapter, we will learn how to use Resilience4j to make our microservices
    more resilient, that is, how to mitigate and recover from errors. As we already
    discussed in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the *Circuit breaker* section, and [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud,* the *Resilience4j for improved resilience* section,
    a circuit breaker can be used to minimize the damage that a slow or not-responding
    downstream microservice can cause in a large-scale system landscape of synchronously
    communicating microservices. We will see how the circuit breaker in Resilience4j
    can be used together with a timeout and retry mechanism to prevent two—in my experience—of
    the most common error situations:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Resilience4j使我们的微服务更具弹性，即如何减轻和从错误中恢复。正如我们在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中已经讨论过，*微服务简介*，在*Circuit
    breaker*部分和[第8章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中，*Spring Cloud简介*，*Resilience4j用于改进弹性*部分，断路器可用于最小化慢或不响应的下游微服务在大规模系统中的损害。我们将看到Resilience4j中的断路器如何与超时和重试机制一起使用，以防止我经验中最常见的两种错误情况：
- en: Microservices that start to respond slowly or not at all
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始缓慢响应或根本不响应的微服务
- en: Requests that randomly fail from time to time, for example, due to temporary
    network problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶尔由于临时网络问题而随机失败的请求
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入Resilience4j断路器和重试机制
- en: Adding a circuit breaker and retry mechanism to the source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断路器和重试机制添加到源代码
- en: Trying out the circuit breaker and retry mechanism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试断路器和重试机制
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands that are described in this book are run on a MacBook Pro using
    macOS Mojave but should be straightforward to modify if you want to run them on
    another platform such as Linux or Windows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但如果您想在其他平台上运行它们，如Linux或Windows，应该很容易修改。
- en: No new tools need to be installed in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不需要安装新工具。
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行本书中描述的命令，请下载源代码到一个文件夹，并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下是一些示例命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.4, and Spring 5.1.6, that is, the latest available version of the Spring
    components at the time of writing this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用的是Spring Cloud 2.1.0，SR1（也称为**Greenwich**发布版），Spring
    Boot 2.1.4和Spring 5.1.6，即编写本章时Spring组件的最新可用版本。
- en: The `openjdk:12.0.2` base Docker image is used in all the Dockerfiles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Dockerfiles中都使用`openjdk:12.0.2`基础Docker镜像。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: api
- en: '`util`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: util
- en: '`microservices/product-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microservices/product-service
- en: '`microservices/review-service`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microservices/review-service
- en: '`microservices/recommendation-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microservices/recommendation-service
- en: '`microservices/product-composite-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microservices/product-composite-service
- en: '`spring-cloud/eureka-server`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-cloud/eureka-server
- en: '`spring-cloud/gateway`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-cloud/gateway
- en: '`spring-cloud/authorization-server`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-cloud/authorization-server
- en: '`spring-cloud/config-server`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-cloud/config-server
- en: The configuration files can be found in the config repository, `config-repo`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以在配置存储库`config-repo`中找到。
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter13` but
    in several cases have been edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例都来自于`$BOOK_HOME/Chapter13`中的源代码，但在几种情况下已经进行了编辑，以删除源代码的无关部分，如注释、导入和日志语句。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add resilience using Resilience4j, you can
    compare it with the source code for [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter12` and `$BOOK_HOME/Chapter13`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看本章中应用于源代码的更改，即查看使用Resilience4j添加弹性所需的内容，您可以将其与[第12章](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml)的源代码进行比较。您可以使用您喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter12`和`$BOOK_HOME/Chapter13`。
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Resilience4j断路器和重试机制
- en: 'Retries and circuit breakers are potentially useful in any synchronous communication
    between two software components, for example, microservices. Resilience4j can
    be used by all our microservices except for the edge server since Spring Cloud
    Gateway currently only supports the older circuit breaker, Netflix Hystrix. In
    this chapter, we will apply a circuit breaker and a retry mechanism in one place, in
    calls to the `product` service from the `product-composite` service. This is illustrated
    in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重试和断路器在任何两个软件组件之间的同步通信中都可能很有用，例如微服务。 Resilience4j可以被我们所有的微服务使用，除了边缘服务器，因为Spring
    Cloud Gateway目前只支持较旧的断路器Netflix Hystrix。在本章中，我们将在一个地方应用断路器和重试机制，在`product-composite`服务对`product`服务的调用中。如下图所示：
- en: '![](img/1242dd3a-010d-4a6d-8ce2-edc8fd88c290.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1242dd3a-010d-4a6d-8ce2-edc8fd88c290.png)'
- en: Note that the synchronous calls to the discovery and config servers from the
    other microservices are not shown in the preceding diagram (to make it easier
    to read).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，来自其他微服务对发现和配置服务器的同步调用未显示在上图中（以便更容易阅读）。
- en: Work is ongoing as this chapter was written to add an abstraction layer for
    circuit breakers in Spring Cloud, something Spring Cloud Gateway will probably
    be able to benefit from. For details, see [https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker](https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在编写本章时正在进行工作，以在Spring Cloud中为断路器添加一个抽象层，Spring Cloud Gateway可能会从中受益。有关详细信息，请参阅[https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker](https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker)。
- en: Introducing the circuit breaker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入断路器
- en: 'Let''s quickly revisit the state diagram for a circuit breaker from [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*,
    in the *Resilience4j for improved resilience* section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下[第8章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中的断路器状态图，*Spring Cloud简介*，在*用于改进弹性的Resilience4j*部分：
- en: '![](img/87b2c812-ab46-45fe-a6d7-0f06a030d556.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87b2c812-ab46-45fe-a6d7-0f06a030d556.png)'
- en: 'The key features of a circuit breaker are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的关键特性如下：
- en: If a circuit breaker detects too many faults, it will open its circuit, that
    is, not allow new calls.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果断路器检测到太多故障，它将打开其电路，即不允许新的调用。
- en: When the circuit is open, a circuit breaker will perform fast failure logic.
    This means that it doesn't wait for a new fault, for example, a timeout, to happen
    on subsequent calls. Instead, it directly redirects the call to a **fallback**
    **method**. The fallback method can apply various business logic to produce the
    best effort response. For example, a fallback method can return data from a local
    cache or simply return an immediate error message. This will prevent a microservice
    from getting unresponsive if the services it depends on stop responding normally.
    This is specifically useful under high load.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电路处于打开状态时，断路器将执行快速失败逻辑。这意味着它不会等待新的故障，例如超时，在后续调用中发生。相反，它直接将调用重定向到**fallback**
    **method**。回退方法可以应用各种业务逻辑来产生最佳的响应。例如，回退方法可以从本地缓存返回数据，或者简单地返回一个立即的错误消息。这将防止微服务在其依赖的服务停止正常响应时变得无响应。这在高负载下特别有用。
- en: After a while, the circuit breaker will be half-open*,* allowing new calls to
    see whether the issue that caused the failures is gone. If new failures are detected
    by the circuit breaker, it will open the circuit again and go back to the fast
    failure logic. Otherwise, it will close the circuit and go back to normal operation.
    This makes a microservice resilient to faults, a capability that is indispensable
    in a system landscape of microservices that communicate synchronously with each
    other!
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段时间后，断路器将变为半开状态，允许新的调用查看导致故障的问题是否已经消失。如果断路器检测到新的故障，它将再次打开电路并返回到快速失败逻辑。否则，它将关闭电路并返回到正常操作。这使得微服务对故障具有弹性，这是在微服务之间同步通信的系统环境中不可或缺的能力！
- en: 'Resilience4j exposes information about circuit breakers at runtime in a number
    of ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j以多种方式在运行时公开有关断路器的信息：
- en: The current state of a circuit breaker can be monitored using the microservice's actuator `health`
    endpoint, `/actuator/health`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用微服务的`actuator` `health`端点监视断路器的当前状态，`/actuator/health`。
- en: The circuit breaker also publishes events on an `actuator` endpoint, for example,
    state transitions, `/actuator/circuitbreakerevents`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器还会在`actuator`端点上发布事件，例如状态转换，`/actuator/circuitbreakerevents`。
- en: Finally, circuit breakers are integrated with Spring Boot's metrics system and
    can use it to publish metrics to monitoring tools such as Prometheus.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，断路器与Spring Boot的指标系统集成，并可以使用它将指标发布到监控工具，如Prometheus。
- en: We will try out the `health` and `event` endpoints in this chapter. In [Chapter
    20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*, we
    will see Prometheus in action and how it can collect metrics that are exposed
    by Spring Boot, for example, metrics from our circuit breaker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试`health`和`event`端点。在[第20章](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml)中，*监控微服务*，我们将看到Prometheus的运行方式，以及它如何收集Spring
    Boot公开的指标，例如我们的断路器的指标。
- en: 'To control the logic in a circuit breaker, Resilience4J can be configured using
    standard Spring Boot configuration files. We will use the following configuration
    parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制断路器中的逻辑，可以使用标准的Spring Boot配置文件配置Resilience4J。我们将使用以下配置参数：
- en: '`ringBufferSizeInClosedState`: Number of calls in a closed state, which are
    used to determine whether the circuit shall be opened.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInClosedState`：处于关闭状态的调用数量，用于确定电路是否应该打开。'
- en: '`failureRateThreshold`: The threshold, in percent, for failed calls that will
    cause the circuit to be opened.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureRateThreshold`：导致电路打开的失败调用的阈值，以百分比表示。'
- en: '`waitInterval`: Specifies how long the circuit stays in an open state, that
    is, before it transitions to the half-open state.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitInterval`：指定电路保持在打开状态的时间，即在转换到半开状态之前。'
- en: '`ringBufferSizeInHalfOpenState`: The number of calls in the half-open state
    that are used to determine whether the circuit shall be opened again or go back
    to the normal, closed state.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInHalfOpenState`：在半开状态下用于确定电路是否应再次打开或返回正常闭合状态的调用次数。'
- en: '`automaticTransitionFromOpenToHalfOpenEnabled`: Determines whether the circuit
    automatically will transition to half-open once the wait period is over or wait
    for the first call after the waiting period until it transitions to the half-open
    state.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automaticTransitionFromOpenToHalfOpenEnabled`：确定电路是否会在等待期结束后自动转换为半开状态，或者等待等待期后的第一次调用直到转换为半开状态。'
- en: '`ignoreExceptions`: Can be used to specify exceptions that should not be counted
    as faults. Expected business exceptions such as not found or invalid input are
    typical exceptions that the circuit breaker should ignore, that is, users that
    search for non-existing data or enter invalid input should not cause the circuit
    to open.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreExceptions`：可用于指定不应计为故障的异常。预期的业务异常，例如未找到或无效输入，是断路器应该忽略的典型异常，也就是说，搜索不存在的数据或输入无效的用户不应该导致电路打开。'
- en: Resilience4j keeps track of successful and failed calls when in the closed and
    half-open state using a ring buffer, hence the parameter names `ringBufferSizeInClosedState`
    and `ringBufferSizeInHalfOpenState`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j在闭合状态和半开状态时使用环形缓冲区跟踪成功和失败的调用，因此参数名称为`ringBufferSizeInClosedState`和`ringBufferSizeInHalfOpenState`。
- en: 'In this chapter, we will use the following settings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下设置：
- en: '`ringBufferSizeInClosedState = 5` and `failureRateThreshold = 50%`, meaning
    that if three or more of the last five calls are faults, then the circuit will
    open.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInClosedState = 5`和`failureRateThreshold = 50%`，这意味着如果最近五次调用中有三次或更多次故障，那么电路将打开。'
- en: '`waitInterval = 10000` and `automaticTransitionFromOpenToHalfOpenEnabled =
    true`, meaning that the circuit breaker will keep the circuit open for 10 seconds
    and then transition to the half-open state.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitInterval = 10000`和`automaticTransitionFromOpenToHalfOpenEnabled = true`，这意味着断路器将保持电路打开10秒，然后转换为半开状态。'
- en: '`ringBufferSizeInHalfOpenState = 3`, meaning that the circuit breaker will
    decide whether the circuit shall be opened or closed based on the three first
    calls after the circuit has transitioned to the half-open state. Since the `failureRateThreshold` parameters
    are set to 50%, the circuit will be open again if two or all three calls fail.
    Otherwise, the circuit will be closed.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInHalfOpenState = 3`，这意味着断路器将根据在半开状态下转换后的前三次调用来决定电路是打开还是关闭。由于`failureRateThreshold`参数设置为50%，如果两次或三次调用失败，电路将再次打开。否则，电路将关闭。'
- en: '`ignoreExceptions = InvalidInputException` and `NotFoundException`, meaning
    that our two business exceptions will not be counted as faults in the circuit
    breaker.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreExceptions = InvalidInputException`和`NotFoundException`，这意味着我们的两个业务异常不会被计为断路器中的故障。'
- en: Introducing the retry mechanism
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入重试机制
- en: The **retry** mechanism is very useful for random and infrequent faults, such
    as temporary network glitches. The retry mechanism can simply retry a failed request
    a number of times with a configurable delay between the attempts. One very important
    restriction on the use of the retry mechanism is that the services that it retries
    must be **idempotent**, that is, calling the service one or many times with the
    same request parameters gives the same result. For example, reading information
    is idempotent but creating information is typically not. You don't want a retry
    mechanism to accidentally create two orders just because the response from the
    first order's creation got lost in the network.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**重试**机制对于随机和偶发的故障非常有用，例如临时网络故障。重试机制可以简单地在尝试之间以可配置的延迟重试失败的请求多次。对于重试机制的使用有一个非常重要的限制，那就是它重试的服务必须是**幂等**的，也就是说，使用相同的请求参数一次或多次调用服务会得到相同的结果。例如，读取信息是幂等的，但创建信息通常不是。您不希望重试机制因为第一个订单创建的响应在网络中丢失而意外地创建两个订单。'
- en: 'Resilience4j exposes retry information in the same way as it does for circuit
    breakers when it comes to events and metrics but does not provide any health information.
    Retry events are accessible on the `actuator` endpoint, `/actuator/retryevents`. To
    control the retry logic, Resilience4J can be configured using standard Spring
    Boot configuration files. We will use the following configuration parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j在事件和指标方面与断路器一样公开重试信息，但不提供任何健康信息。重试事件可以在`actuator`端点`/actuator/retryevents`上访问。要控制重试逻辑，可以使用标准的Spring
    Boot配置文件配置Resilience4J。我们将使用以下配置参数：
- en: '`maxRetryAttempts`: Number of retries before giving up, including the first
    call'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxRetryAttempts`：放弃之前的重试次数，包括第一次调用'
- en: '`waitDuration`: Wait time before the next retry attempt'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitDuration`：下一次重试尝试之前的等待时间'
- en: '`retryExceptions`: A list of exceptions that shall trigger a retry'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryExceptions`：应触发重试的异常列表'
- en: 'In this chapter, we will use the following values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下值：
- en: '`maxRetryAttempts = 3`: We will make a maximum of two retry attempts.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxRetryAttempts = 3`：我们将最多重试两次。'
- en: '`waitDuration= 1000`: We will wait one second between retries.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitDuration= 1000`：我们将在重试之间等待一秒。'
- en: '`retryExceptions = InternalServerError`: We will only trigger retries on `InternalServerError`
    exceptions, that is, when HTTP requests respond with a 500 status code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryExceptions = InternalServerError`：我们只会在`InternalServerError`异常上触发重试，也就是说，当HTTP请求以500状态码响应时。'
- en: Be careful when configuring retry and circuit breaker settings so that, for
    example, the circuit breaker doesn't open the circuit before the intended number
    of retries have been completed!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置重试和断路器设置时要小心，例如，断路器在预期的重试次数完成之前不要打开电路！
- en: Adding a circuit breaker and retry mechanism to the source code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将断路器和重试机制添加到源代码中
- en: 'Before we add a circuit breaker and a retry mechanism to the source code, we
    will add code that makes it possible to force an error to occur—either a delay
    and/or a random fault. Next, we will add a circuit breaker to handle slow or not
    responding APIs, as well as a retry mechanism that can handle faults that happens
    randomly. Adding these features from Resilience4j follows the traditional Spring
    Boot way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向源代码添加断路器和重试机制之前，我们将添加代码，使其可能强制发生错误——延迟和/或随机故障。接下来，我们将添加一个断路器来处理慢速或无响应的API，以及一个重试机制，可以处理随机发生的故障。从Resilience4j添加这些功能遵循传统的Spring
    Boot方式：
- en: Add a starter dependency for Resilience4j in the build file.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建文件中添加Resilience4j的启动依赖项。
- en: Add annotations in the source code where the circuit breaker and retry mechanism
    shall be applied.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中添加断路器和重试机制应用的注释。
- en: Add configuration that controls the behavior of the circuit breaker and retry mechanism.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加控制断路器和重试机制行为的配置。
- en: Once we have the circuit breaker and retry mechanism in place, we will extend
    our test script, `test-em-all.bash`, with the tests of the circuit breaker.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们放置了断路器和重试机制，我们将扩展我们的测试脚本`test-em-all.bash`，测试断路器。
- en: Adding programmable delays and random errors
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可编程延迟和随机错误
- en: 'To be able to test our circuit breaker and retry mechanism, we need a way to
    control when errors happen. A simple way to achieve this is by adding optional
    query parameters in the API in order to retrieve a product and a composite product.
    The composite product API will simply pass on the parameters to the product API.
    The following query parameters have been added to the two APIs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的断路器和重试机制，我们需要一种控制错误发生的方法。实现这一点的一个简单方法是通过在API中添加可选的查询参数，以便检索产品和复合产品。复合产品API将简单地将参数传递给产品API。以下查询参数已添加到两个API中：
- en: '`delay`: Causes the `getProduct` API on the `product` microservice to delay
    its response. The parameter is specified in seconds. For example, if the parameter
    is set to `3`, it will cause a delay of three seconds before the response is returned.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：导致`product`微服务上的`getProduct` API延迟其响应。参数以秒为单位指定。例如，如果参数设置为`3`，它将导致在返回响应之前延迟三秒。'
- en: '`faultPercentage`: Causes the `getProduct` API on the `product` microservice to
    throw an exception randomly with the probability specified by the query parameter,
    from 0 to 100%. For example, if the parameter is set to `25`, it will cause every
    fourth call to the API, on average, to fail with an exception. It will return
    an HTTP error 500 internal server error in these cases.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`faultPercentage`：导致`product`微服务上的`getProduct` API以指定的查询参数概率随机抛出异常。例如，如果参数设置为`25`，平均每四次调用API将以异常失败。在这些情况下，它将返回HTTP错误500内部服务器错误。'
- en: Changes in the API definitions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API定义中的更改
- en: 'The two query parameters that we introduced previously, `delay` and `faultPercentage`,
    have been defined in the `api` project in the following two Java interfaces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前引入的两个查询参数`delay`和`faultPercentage`已在`api`项目中的以下两个Java接口中定义：
- en: '`se.magnus.api.composite.product.ProductCompositeService`:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.composite.product.ProductCompositeService`：'
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`se.magnus.api.core.product.ProductService`:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`：'
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Changes in the product composite microservice
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品复合微服务中的更改
- en: 'The `product-composite` microservice simply passes the parameters to the product
    API. The service implementation receives the API request and passes on the parameters
    to the integration component that makes the call to the product API:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite`微服务简单地将参数传递给产品API。服务实现接收API请求并将参数传递给进行产品API调用的集成组件：'
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类的调用：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类的调用：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changes in the product microservice
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品微服务中的更改
- en: 'The `product` microservice implements actual delay and random error generator
    in `se.magnus.microservices.core.product.services.ProductServiceImpl` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`微服务在`se.magnus.microservices.core.product.services.ProductServiceImpl`中实现了实际的延迟和随机错误生成器：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The delay function, `simulateDelay()`, uses the `Thread.sleep()` function to
    simulate a delay:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数`simulateDelay()`使用`Thread.sleep()`函数来模拟延迟：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The random error generator, `throwErrorIfBadLuck()`, creates a random number
    between `1` and `100` and throws an exception if it is higher or equal to the
    specified fault percentage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随机错误生成器`throwErrorIfBadLuck()`创建一个1到100之间的随机数，如果它大于或等于指定的故障百分比，则抛出异常：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding a circuit breaker
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加断路器
- en: As we mentioned previously, we need to add dependencies, annotations, and configuration.
    We also need to add some code for handling timeouts and fallback logic. We will
    see how to do this in the following sections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们需要添加依赖项、注释和配置。我们还需要添加一些代码来处理超时和回退逻辑。我们将在以下部分看到如何做到这一点。
- en: Adding dependencies to the build file
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建文件中添加依赖项
- en: 'To add a circuit breaker, we have to add dependencies to the appropriate Resilience4j
    libraries in the build file, `build.gradle`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加断路器，我们必须在构建文件`build.gradle`中添加适当的Resilience4j库的依赖项。
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the circuit breaker and timeout logic
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加断路器和超时逻辑
- en: 'The circuit breaker can be applied by annotating the method it is expected
    to protect with `@CircuitBreaker(name="nnn")`, which in this case is the `getProduct()`
    method in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`
    class. The circuit breaker is triggered by an exception, not by a timeout itself.
    To be able to trigger the circuit breaker after a timeout, we have to add code
    that generates an exception after a timeout. Using `WebClient`, which is based
    on Project Reactor, allows us to do that conveniently by using its `timeout(Duration)`
    method. The source code looks as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在预期保护的方法上注释`@CircuitBreaker(name="nnn")`来应用断路器，这在本例中是`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中的`getProduct()`方法。断路器是由异常触发的，而不是由超时本身触发的。为了在超时后触发断路器，我们必须添加代码，在超时后生成异常。使用基于Project
    Reactor的`WebClient`可以方便地通过使用其`timeout(Duration)`方法来实现。源代码如下：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The name of the circuit breaker, `"product"`, is used to identify the configuration
    that we will go through. The timeout parameter, `productServiceTimeoutSec`, is
    injected into the constructor as a configurable parameter value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的名称“product”用于识别我们将要经历的配置。超时参数`productServiceTimeoutSec`被注入到构造函数中作为可配置的参数值：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To activate the circuit breaker, the annotated method must be invoked as a
    Spring Bean. In our case, it''s the integration class that''s injected by Spring
    into the service implementation class and therefore used as a Spring Bean:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活断路器，必须调用带有注释的方法作为Spring Bean。在我们的情况下，它是由Spring注入到服务实现类中并因此用作Spring Bean的集成类：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding fast fail fallback logic
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加快速失败回退逻辑
- en: To be able to apply fallback logic when the circuit breaker is open, that is,
    when a request fast fails, we can catch an exception, `CircuitBreakerOpenException`,
    that is thrown by the circuit breaker when it is open and call a fallback method.
    This has to be done outside of the circuit breaker, that is, in the caller. In
    our case, it is the `product-composite` service's implementation that calls the
    integration class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在断路器打开时应用回退逻辑，也就是在请求快速失败时，我们可以捕获由断路器在打开时抛出的异常`CircuitBreakerOpenException`，并调用回退方法。这必须在断路器之外完成，也就是在调用者那里。在我们的情况下，是`product-composite`服务的实现调用集成类。
- en: 'Here, we use the `onErrorReturn` method to call the `getProductFallbackValue()` method
    when we catch `CircuitBreakerOpenException`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`onErrorReturn`方法在捕获`CircuitBreakerOpenException`时调用`getProductFallbackValue()`方法：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fallback logic can be based on `productId` lookup information on the product
    from alternative sources, for example, an internal cache. In our case, we return
    a hardcoded value unless `productId` is `13`; otherwise, we throw a not found
    exception:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回退逻辑可以基于从替代来源查找`productId`的信息，例如内部缓存。在我们的情况下，除非`productId`是`13`，否则我们返回一个硬编码的值；否则，我们抛出一个未找到的异常：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding configuration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Finally, the configuration of the circuit breaker is added to the `product-composite.yml` file
    in the config repository, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，断路器的配置被添加到配置存储库中的`product-composite.yml`文件中，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Most of the values in the configuration have already been described in *Introducing
    the circuit breaker* section, except for the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的大多数值已经在“介绍断路器”部分中进行了描述，除了以下内容：
- en: '`app.product-service.timeoutSec`: Used to configure the timeout we introduced
    previously. This is set to two seconds.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.product-service.timeoutSec`：用于配置我们之前介绍的超时。这被设置为两秒。'
- en: '`registerHealthIndicator`: Determines whether the circuit breaker shall display
    information in the `health` endpoint or not. This is set to `true`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerHealthIndicator`：确定断路器是否在`health`端点中显示信息。这被设置为`true`。'
- en: Adding a retry mechanism
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重试机制
- en: In the same way as for the circuit breaker, a retry mechanism is set up by adding
    dependencies, annotations, and configuration. The dependencies were added previously,
    so we only need to add the annotation and set up some configuration. We, however,
    also need to add some error handling logic due to retry-specific exceptions that
    the retry mechanism throws.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与断路器一样，通过添加依赖项、注释和配置来设置重试机制。依赖项已经添加，因此我们只需要添加注释并设置一些配置。然而，由于重试机制抛出的特定于重试的异常，我们还需要添加一些错误处理逻辑。
- en: Adding the retry annotation
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重试注释
- en: 'The retry mechanism can be applied to a method by annotating it with `@Retry(name="nnn")`,
    where `nnn` is the name of the configuration entry to be used for this method.
    See the *Adding configuration* section for details on the configuration. The method,
    in our case, is the same as it is for the circuit breaker, that is, `getProduct()` in
    the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制可以通过使用`@Retry(name="nnn")`对方法进行注释来应用到方法中，其中`nnn`是要用于此方法的配置条目的名称。有关配置的详细信息，请参见“添加配置”部分。在我们的情况下，该方法与断路器的方法相同，即`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中的`getProduct()`方法：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Handling retry-specific exceptions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理特定于重试的异常
- en: Exceptions that are thrown by a method annotated with `@Retry` can be wrapped
    by the retry mechanism with a `RetryExceptionWrapper` exception. To be able to
    handle the actual exception that the method threw, for example, to apply a fallback
    method when `CircuitBreakerOpenException` is thrown, the caller needs to add logic
    that unwraps `RetryExceptionWrapper` exceptions and replaces them with the actual
    exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Retry`注释的方法抛出的异常可以被重试机制包装为`RetryExceptionWrapper`异常。为了能够处理方法抛出的实际异常，例如在抛出`CircuitBreakerOpenException`时应用回退方法，调用者需要添加逻辑来解包`RetryExceptionWrapper`异常并用实际异常替换它们。
- en: 'In our case, it is the `getCompositeProduct` method in the `ProductCompositeServiceImpl`
    class that makes the call using the Project Reactor API for `Mono` objects. The
    `Mono` API has a convenient method, `onErrorMap`, that can be used to unwrap `RetryExceptionWrapper`
    exceptions. It is used in the `getCompositeProduct` method like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，是`ProductCompositeServiceImpl`类中的`getCompositeProduct`方法使用Project Reactor
    API进行调用，用于`Mono`对象。`Mono` API有一个方便的方法`onErrorMap`，可以用于解包`RetryExceptionWrapper`异常。它在`getCompositeProduct`方法中使用如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding configuration
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Configuration for the retry mechanism is added in the same way as it is for
    the circuit breaker, that is, in the `product-composite.yml` file in the config
    repository, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制的配置方式与断路器的配置方式相同，即在配置存储库的`product-composite.yml`文件中进行配置，如下所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The actual values were discussed in *Introducing the retry mechanism* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值在*介绍重试机制*部分进行了讨论。
- en: Adding automated tests
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自动化测试
- en: 'Automated tests for the circuit breaker have been added to the `test-em-all.bash` test
    script in a separate function, `testCircuitBreaker()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的自动化测试已添加到`test-em-all.bash`测试脚本中的一个单独函数`testCircuitBreaker()`中：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To be able to perform some of the required verifications, we need to have access
    to the `actuator` endpoints of the `product-composite` microservice, which are
    not exposed through the edge server. Therefore, we will access the `actuator`
    endpoints through a separate Docker container that will be attached to the internal
    network that was set up by Docker Compose for our microservices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行一些所需的验证，我们需要访问`product-composite`微服务的`actuator`端点，这些端点不通过边缘服务器公开。因此，我们将通过一个单独的Docker容器访问`actuator`端点，该容器将连接到Docker
    Compose为我们的微服务设置的内部网络。
- en: 'By default, the name of the network is based on the name of the folder where
    the Docker Compose file is placed. To avoid that uncertain dependency, an explicit
    network name, `my-network`, is defined in the `docker-compose` files. All container
    definitions have been updated to specify that they shall attach to the `my-network` network.
    The following is an example from `docker-compose.yml`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，网络的名称基于放置Docker Compose文件的文件夹的名称。为了避免这种不确定的依赖关系，在`docker-compose`文件中定义了一个显式的网络名称`my-network`。所有容器定义都已更新为指定它们将连接到`my-network`网络。以下是`docker-compose.yml`中的一个示例：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the container is attached to the internal network, it can access the `actuator`
    endpoints of the product composite without going through the edge server. We will
    use Alpine as our Docker image and use `wget` instead of `curl` since `curl` isn''t
    included in the Alpine distribution by default. For example, to be able to find
    out the state of the circuit breaker named `product` in the `product-composite`
    microservice, we can run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器连接到内部网络，可以访问产品组合的`actuator`端点，而无需通过边缘服务器。我们将使用Alpine作为我们的Docker镜像，并使用`wget`而不是`curl`，因为`curl`默认情况下不包含在Alpine发行版中。例如，为了能够找出名为`product`的断路器在`product-composite`微服务中的状态，我们可以运行以下命令：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The command is expected to return a value of `CLOSED`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令预计返回`CLOSED`的值。
- en: Since we have created the Docker container with the `--rm` flag, it will be
    stopped and destroyed by the Docker engine after the `wget` command completes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`--rm`标志创建了Docker容器，因此在`wget`命令完成后，Docker引擎将停止并销毁该容器。
- en: 'The test starts by doing exactly this, that is, verifying that the circuit
    breaker is closed before the tests are executed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试开始时首先进行这个验证，也就是说，在执行测试之前验证断路器是否关闭：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the test will force the circuit breaker to open up by running three commands
    in a row, all of which will fail on a slow response from the `product` service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试将通过连续运行三个命令来强制打开断路器，所有这些命令都将因`product`服务的响应缓慢而失败：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Quick repetition of the configuration**: The timeout of the `product` service
    is set to two seconds so that a delay of three seconds will cause a timeout. The
    circuit breaker is configured to evaluate the last five last calls when closed.
    The tests in the script that precede the circuit breaker-specific tests have already
    performed a couple of successful calls. The failure threshold is set to 50%, that
    is, three calls with a three-second delay is enough to open the circuit.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置的快速重复**：`product`服务的超时设置为两秒，因此三秒的延迟将导致超时。当关闭时，断路器配置为评估最后五次调用。在特定于断路器的测试之前的脚本中的测试已经执行了一些成功的调用。故障阈值设置为50%，也就是说，三次三秒的延迟调用足以打开断路器。'
- en: 'With the circuit open, we expect a fast failure, that is, we won''t need to
    wait for the timeout before we get a response. We also expect the `fallback` method
    to be called to return a best-effort response. This should also apply for a normal
    call, that is, without requesting a delay. This is verified with the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路打开的情况下，我们期望快速失败，也就是说，在获得响应之前我们不需要等待超时。我们还期望调用`fallback`方法返回最佳努力响应。这也适用于正常调用，也就是说，不需要请求延迟。这通过以下代码进行验证：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also verify that the simulated not found error logic works as expected
    in the fallback method, that is, the fallback method returns `404`, `NOT_FOUND`
    for product ID `13`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证模拟的未找到错误逻辑是否按预期在回退方法中工作，也就是说，回退方法返回`404`，`NOT_FOUND`，产品ID为`13`。
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As configured, the circuit breaker will change its state to half-open after
    `10` seconds. To be able to verify that, the test waits for `10` seconds:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据配置，断路器将在`10`秒后将其状态更改为半开。为了验证这一点，测试等待了`10`秒：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After verifying the expected state (half-closed), the test runs three normal
    requests to make the circuit breaker go back to its normal state, which is also
    verified:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证期望状态（半关闭）之后，测试运行了三个正常请求，使断路器恢复到正常状态，也进行了验证：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Quick repetition of the configuration:** The circuit breaker is configured
    to evaluate the first three calls when in the half-open state. Therefore, we need
    to run three requests where more than 50% are successful before the circuit is
    closed.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置的快速重复：** 断路器配置为在半开状态下评估前三个调用。因此，在电路关闭之前，我们需要运行三个请求，其中超过50%成功。'
- en: 'The test wraps up by using the `/actuator/circuitbreakerevents` actuator API,
    which is exposed by the circuit breaker to reveal internal events. It can, for
    example, be used to find out what state transitions the circuit breaker has performed.
    We expect the last three state transitions to be as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过使用`/actuator/circuitbreakerevents`执行器API来结束，该API由断路器公开以显示内部事件。例如，它可以用于查找断路器执行了哪些状态转换。我们期望最后三个状态转换如下：
- en: 'First state transitions: Closed to open'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个状态转换：关闭到打开
- en: 'Next state transitions: Open to half-closed'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个状态转换：打开到半开
- en: 'Last state transitions: Half-closed to closed'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的状态转换：半开到关闭
- en: 'This is verified by the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下代码进行验证：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `jq` expression, `circuitBreakerEvents[-1]`, means the last entry in the
    array of circuit breaker events, `[-2]`, is the second to last event, while `[-3
    ]` is the third to last event. Together, they are the three latest events, that
    is, the ones we are interested in. By default, Resilience4j keeps the last 100
    events per circuit breaker. This can be customized using the `eventConsumerBufferSize` configuration
    parameter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`表达式`circuitBreakerEvents[-1]`表示断路器事件数组中的最后一个条目，`[-2]`是倒数第二个事件，`[-3]`是倒数第三个事件。它们一起是最新的三个事件，也就是我们感兴趣的事件。默认情况下，Resilience4j每个断路器保留最后100个事件。可以使用`eventConsumerBufferSize`配置参数进行自定义。'
- en: We added quite a lot of steps to the test script, but with this, we can automatically
    verify that the expected basic behavior of our circuit breaker is in place. In
    the next section, we will try it out!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试脚本中添加了相当多的步骤，但通过这样，我们可以自动验证我们的断路器的基本预期行为是否存在。在下一节中，我们将尝试它！
- en: Trying out the circuit breaker and retry mechanism
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试断路器和重试机制
- en: 'Now, it''s time to try out the circuit breaker and retry mechanism. We will
    start, as usual, by building the Docker images and running the test script, `test-em-all.bash`.
    After that, we will run through the tests we described previously manually to
    ensure that we understand what''s going on! We will perform the following manual
    tests:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候尝试断路器和重试机制了。我们将像往常一样，通过构建Docker镜像并运行测试脚本`test-em-all.bash`来开始。之后，我们将手动运行我们之前描述的测试，以确保我们理解发生了什么！我们将执行以下手动测试：
- en: Happy days tests of the circuit breaker, that is, to verify that the circuit
    is closed under normal operations
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快乐的日子测试断路器，也就是验证在正常操作下电路是否关闭
- en: Negative tests of the circuit breaker, that is, to verify that the circuit opens
    up when things start to go wrong
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负面测试断路器，也就是验证当事情开始出错时电路是否打开
- en: Going back to normal operation, that is, to verify that the circuit goes back
    to its closed state once the problems are resolved
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复正常运行，也就是验证一旦问题解决，电路是否恢复到闭合状态
- en: Trying out the retry mechanism with random errors
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用随机错误的重试机制
- en: Building and running the automated tests
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行自动化测试
- en: 'In order to build and run the automated tests, we need to do the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和运行自动化测试，我们需要执行以下操作：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统架构，并使用以下命令运行通常的测试：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the test script prints out `Start Circuit Breaker tests!`, the tests we
    described previously are executed!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试脚本打印出`Start Circuit Breaker tests!`时，我们之前描述的测试将被执行！
- en: Verifying that the circuit is closed under normal operations
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证在正常操作下电路是否关闭
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用API之前，我们需要一个访问令牌。运行以下命令获取访问令牌：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Try a normal request and verify that it returns the HTTP response code `200`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试正常请求，并验证它返回HTTP响应代码`200`：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `-w "%{http_code}\n"` switch is used to print the HTTP return status. As
    long as the command returns `200`, we are not interested in the response body,
    and so we suppress it with the switch, that is, `-o /dev/null`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-w "%{http_code}\n"`开关来打印HTTP返回状态。只要命令返回`200`，我们就不关心响应主体，因此我们使用开关`-o /dev/null`来抑制它。
- en: 'Verify that the circuit breaker is closed using the `health` API:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`health` API验证断路器是否关闭：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它会以`CLOSED`响应。
- en: Forcing the circuit breaker to open when things go wrong
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当事情出错时，强制断路器打开
- en: 'Now, it''s time to make things go wrong! By that, I mean it''s time to try
    out some negative tests in order to verify that the circuit opens up when things
    start to go wrong. Call the API three times and direct the `product` service to
    cause a timeout on every call, that is, delay the response with `3` seconds. This
    should be enough to trip the circuit breaker:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让事情出错了！也就是说，是时候尝试一些负面测试，以验证当事情开始出错时电路是否打开。调用API三次，并指示`product`服务在每次调用时引发超时，也就是延迟响应`3`秒。这应该足以触发断路器：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We expect a response such as the following each time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望每次都会得到以下响应：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The circuit breaker is now open, so if you make a fourth attempt (within `waitInterval`,
    that is, `10` seconds), you will see a fast fail and the `fallback` method in
    action. You will get a response back immediately, instead of an error message
    once the timeout kicks in after `2` seconds:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器现在是打开的，所以如果你进行第四次尝试（在`waitInterval`内，也就是`10`秒内），你将看到快速失败和`fallback`方法的执行。在`2`秒后超时后，你将立即收到响应，而不是错误消息：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The response will come from the fallback method. This can be recognized by looking
    at the value in the name field, that is, `Fallback product2`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将来自备用方法。可以通过查看`name`字段中的值来识别，也就是`Fallback product2`。
- en: Fast fail and fallback methods are key capabilities of a circuit breaker!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败和备用方法是断路器的关键能力！
- en: Given our configuration with a wait time set to only 10 seconds requires you
    to be rather quick to be able to see fast fail and fallback methods in action!
    Once in a half-open state, you can always submit three new requests that cause
    a timeout, forcing the circuit breaker back to the open state, and then quickly
    try the fourth request. Then, you should get a fast fail response from the fallback
    method! You can also increase the wait time to a minute or two, but it can be
    rather boring to wait that amount of time before the circuit switches to the half-open
    state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的配置只设置了10秒的等待时间，你需要相当迅速才能看到快速失败和备用方法的运行！一旦处于半开状态，你可以随时提交三个导致超时的新请求，将断路器强制切换到打开状态，然后迅速尝试第四个请求。然后，你应该会从备用方法得到一个快速失败的响应！你也可以将等待时间增加到一两分钟，但在断路器切换到半开状态之前等待那么长时间可能会相当无聊。
- en: 'Wait 10 seconds, for the circuit breaker to transition to half-open and then
    run the following command to verify that the circuit now is in a half-open state:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 等待10秒，让断路器转换到半开状态，然后运行以下命令以验证断路器现在处于半开状态：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Expect it to respond with `HALF_OPEN`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它会回应`HALF_OPEN`。
- en: Closing the circuit breaker again
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次关闭断路器
- en: Once the circuit breaker is in a half-open state, it waits for three calls to
    see whether it should open the circuit again or go back to normal, that is, close
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦断路器处于半开状态，它会等待三次调用，以确定是再次打开断路器还是恢复正常，也就是关闭它。
- en: 'Let''s submit three normal requests to close the circuit breaker:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交三个正常请求来关闭断路器：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'They should all response with `200`. Verify that the circuit is closed again
    by using the `health` API:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都应该回应`200`。通过使用`health` API验证电路是否再次关闭：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它会回应`CLOSED`。
- en: 'Wrap this up by listing the last three state transitions using the following
    command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令列出最后三个状态转换：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Expect it to respond with the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 期望它会回应以下命令：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This response tells us that we have taken our circuit breaker through a full
    lap of its state diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应告诉我们，我们已经让断路器通过了完整的状态图：
- en: From closed to open when an error starts to prevent requests from succeeding
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当错误开始阻止请求成功时，从关闭到打开
- en: From open to half-open to see whether the error is gone
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从关闭到半开，以查看错误是否消失
- en: From half-open to closed when the error is gone, that is, when we are back to
    normal operation
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当错误消失时，从半开到关闭，也就是当我们恢复正常操作时
- en: Trying out retries caused by random errors
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试由随机错误引起的重试
- en: Let's simulate that there is a – hopefully temporary – random issue with our
    `product` service or the communication with it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的`product`服务或与其通信存在一个（希望是暂时的）随机问题。
- en: 'We can do this by using the `faultPercent` parameter. If we set it to `25`,
    we expect every fourth request to fail. We hope that the retry mechanism will
    kick in to help us by automatically retrying the request. One way of noticing
    that the retry mechanism has kicked in is to measure the response time of the
    `curl` command. A normal response should take no more than 100 ms. Since we have
    configured the retry mechanism to wait one second (see the `waitDuration` parameter
    in the configuration of the preceding retry mechanism), we expect the response
    time to increase with one second per retry attempt. To force a random error to
    occur, run the following command a couple of times:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`faultPercent`参数来实现。如果我们将其设置为`25`，我们期望每四个请求中会有一个失败。我们希望重试机制会自动重试请求来帮助我们。注意到重试机制已经启动的一种方法是测量`curl`命令的响应时间。正常的响应不应超过100毫秒。由于我们已经配置了重试机制等待一秒（请参阅前面重试机制配置中的`waitDuration`参数），我们期望响应时间每次重试尝试都会增加一秒。为了强制发生随机错误，多次运行以下命令：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The command should respond with `200`, indicating that the request succeeded.
    A response time prefixed with `real`, for example, `real 0m0.078s` means that
    the response time was 0.078 s or 78 ms. A normal response, that is, without any
    retries, should look as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该回应`200`，表示请求成功。以`real 0m0.078s`为前缀的响应时间表示响应时间为0.078秒或78毫秒。正常的响应，也就是没有任何重试的情况，应该如下所示：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A response after one retry should look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一次重试后的响应应该如下所示：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The HTTP status code 200 indicates that the request has succeeded, even though
    it required one retry before succeeding!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码200表示请求成功，尽管在成功之前需要重试一次！
- en: 'After you have noticed a response time of one second, that is, the request
    required one retry to succeed, run the following command to see the last two retry
    events:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注意到一个一秒的响应时间，也就是请求需要重试一次才成功时，运行以下命令以查看最后两次重试事件：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should be able to see the failed request and the next successful attempt.
    The `creationTime` timestamps are expected to differ by one second. Expect a response
    such as the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到失败的请求和下一个成功的尝试。`creationTime`时间戳预计会相差一秒。期望得到以下响应：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you are really unlucky, you will get two faults in a row, and then you will
    get a response time of two seconds instead of one. If you repeat the preceding
    command, you will be able to see that the `numberOfAttempts` field is counted
    for each retry attempt, which is set to `2` in this case: `"numberOfAttempts":
    2`. If calls continue to fail, the circuit breaker will kick in and open its circuit,
    that is, subsequent calls will fast fail and the fallback method will be applied!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你非常不幸，你会连续两次出现故障，然后响应时间将变为两秒而不是一秒。如果重复前面的命令，你将能够看到`numberOfAttempts`字段对每次重试尝试进行计数，在这种情况下设置为`2`：`"numberOfAttempts":
    2`。如果调用继续失败，断路器将启动并打开其断路器，也就是后续调用将快速失败，并应用备用方法！'
- en: '**That''s it!**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**就是这样！**'
- en: Feel free to elaborate with the parameters in the configuration to learn about
    the circuit breaker and retry mechanisms better!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意详细说明配置参数，以更好地了解断路器和重试机制！
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen Resilience4j and its circuit breaker and retry
    mechanism in action.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了Resilience4j及其断路器和重试机制的实际应用。
- en: A circuit breaker can, using fast fail and `fallback` methods when it is open,
    prevent a microservice from becoming unresponsive if the synchronous services
    it depends on stop responding normally. A circuit breaker can also make a microservice
    resilient by allowing requests when it is half-open to see whether the failing
    service operates normally again and close the circuit if so.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器可以在打开时使用快速失败和`fallback`方法，防止微服务在其依赖的同步服务停止正常响应时变得无响应。断路器还可以通过在半开状态下允许请求来使微服务具有弹性，以查看失败的服务是否再次正常运行，并在如此时关闭断路器。
- en: A retry mechanism can retry requests that randomly fail from time to time, for
    example, due to temporary network problems. It is very important to only apply
    retry requests on idempotent services, that is, services that can handle that
    the same request is sent two or more times.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制可以重试偶尔失败的请求，例如由于临时网络问题。非常重要的是只在幂等服务上应用重试请求，即可以处理同一请求被发送两次或更多次的服务。
- en: Circuit breakers and retry mechanisms are implemented by following Spring Boot
    conventions, that is, declaring dependencies, and adding annotations and configuration.
    Resilience4j exposes information about its circuit breakers and retry mechanisms
    at runtime, using `actuator` endpoints for health, events, and metrics for circuit
    breakers and events and metrics for retries.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器和重试机制是通过遵循Spring Boot约定来实现的，即声明依赖项，并添加注释和配置。Resilience4j在运行时使用`actuator`端点公开有关其断路器和重试机制的信息，用于断路器的健康、事件和指标，以及用于重试的事件和指标。
- en: We have seen the usage of both endpoints for health and events in this chapter,
    but we will have to wait until [Chapter 20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml),
    *Monitoring Microservices*, before we use any of the metrics.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了健康和事件的两个端点的使用，但在使用任何指标之前，我们必须等到[第20章](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml)，*监控微服务*。
- en: In the next chapter, we will cover the last part of using Spring Cloud, where
    we will learn how to trace call chains through a set of cooperating microservices
    using Spring Cloud Sleuth and Zipkin. Head over to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*, to get started!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖使用Spring Cloud的最后部分，我们将学习如何使用Spring Cloud Sleuth和Zipkin跟踪一组合作微服务的调用链。转到[第14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)，*理解分布式跟踪*，开始学习吧！
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the states of a circuit breaker and how are they used?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器的状态是什么，它们如何使用？
- en: How can we handle timeout errors in the circuit breaker?
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理断路器中的超时错误？
- en: How can we apply fallback logic when a circuit breaker fast fails?
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当断路器快速失败时，我们如何应用备用逻辑？
- en: How can a retry mechanism and a circuit breaker interfere with each other?
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试机制和断路器如何相互干扰？
- en: Provide an example of a service that you can't apply a retry mechanism for.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个无法应用重试机制的服务的示例。
