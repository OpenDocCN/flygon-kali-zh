["```java\nList<String> list = new ArrayList<>();\nlist.add(\"This \");\nlist.add(\"is \");\nlist.add(\"built \");\nlist.add(\"by \");\nlist.add(\"list.add()\");\nlist.forEach(System.out::print);\n```", "```java\nArrays.asList(\"This \", \"is \", \"created \", \"by \", \n              \"Arrays.asList()\").forEach(System.out::print);\n```", "```java\nSet<String> set = new HashSet<>();\nset.add(\"This \");\nset.add(\"is \");\nset.add(\"built \");\nset.add(\"by \");\nset.add(\"set.add() \");\nset.forEach(System.out::print);\n```", "```java\nnew HashSet<>(Arrays.asList(\"This \", \"is \", \"created \", \"by \", \n                            \"new HashSet(Arrays.asList()) \"))\n                            .forEach(System.out::print);\n```", "```java\nMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"This \");\nmap.put(2, \"is \");\nmap.put(3, \"built \");\nmap.put(4, \"by \");\nmap.put(5, \"map.put() \");\nmap.entrySet().forEach(System.out::print);\n```", "```java\nstatic <E> List<E> of()  //Returns list with zero elements\nstatic <E> List<E> of(E e1) //Returns list with one element\nstatic <E> List<E> of(E e1, E e2)  //etc\nstatic <E> List<E> of(E e1, E e2, E e3)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, \n                                        E e6, E e7, E e8)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, \n                                  E e6, E e7, E e8, E e9)\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, \n                            E e6, E e7, E e8, E e9, E e10)\nstatic <E> List<E> of(E... elements)\n```", "```java\nList.of(\"This \", \"is \", \"created \", \"by \", \"List.of()\")\n                                            .forEach(System.out::print);\nSystem.out.println();\nSet.of(\"This \", \"is \", \"created \", \"by \", \"Set.of() \")\n                                            .forEach(System.out::print);\nSystem.out.println();\nMap.of(1, \"This \", 2, \"is \", 3, \"built \", 4, \"by \", 5,\"Map.of() \")\n                                 .entrySet().forEach(System.out::print);\n```", "```java\nMap<K,V> ofEntries(Map.Entry<K,V>... entries)\n```", "```java\nMap.ofEntries(\n  entry(1, \"This \"),\n  entry(2, \"is \"),\n  entry(3, \"built \"),\n  entry(4, \"by \"),\n  entry(5, \"Map.ofEntries() \")\n).entrySet().forEach(System.out::print);\n```", "```java\nList<String> list = List.of(\"This \", \"is \", \"immutable\");\nlist.add(\"Is it?\");     //throws UnsupportedOperationException\nlist.set(1, \"is not \"); //throws UnsupportedOperationException\n```", "```java\nList<String> list = List.of(\"This \", \"is \", \"not \", \"created \", null);\n```", "```java\nSet<String> set = Set.of(\"a\", \"b\", \"c\");\n//set.remove(\"b\");  //UnsupportedOperationException\n//set.add(\"e\");     //UnsupportedOperationException\n//set = Set.of(\"a\", \"b\", \"c\", null); //NullPointerException\n\nMap<Integer, String> map = Map.of(1, \"one\", 2, \"two\", 3, \"three\");\n//map.remove(2);                    //UnsupportedOperationException\n//map.put(5, \"five \");              //UnsupportedOperationException\n//map = Map.of(1, \"one\", 2, \"two\", 3, null); //NullPointerException\n//map = Map.ofEntries(entry(1, \"one\"), null); //NullPointerException\n\n```", "```java\nList<Integer> list = Arrays.asList(1,2,3);\nlist = List.copyOf(list);\n//list.set(1, 0);     //UnsupportedOperationException\n//list.remove(1);     //UnsupportedOperationException\n\nSet<Integer> setInt = Set.copyOf(list);\n//setInt.add(42);       //UnsupportedOperationException\n//setInt.remove(3);  //UnsupportedOperationException\n\nSet<String> set = new HashSet<>(Arrays.asList(\"a\",\"b\",\"c\"));\nset = Set.copyOf(set);\n//set.add(\"d\");     //UnsupportedOperationException\n//set.remove(\"b\");  //UnsupportedOperationException\n\nMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one \");\nmap.put(2, \"two \");\nmap = Map.copyOf(map);\n//map.remove(2);          //UnsupportedOperationException\n//map.put(3, \"three \");    //UnsupportedOperationException\n\n```", "```java\nclass A{}\nclass B extends A{}\n\nList<A> listA = Arrays.asList(new B(), new B());\nSet<A> setA = new HashSet<>(listA);\n\nList<B> listB = Arrays.asList(new B(), new B());\nsetA = new HashSet<>(listB);\n\n//List<B> listB = Arrays.asList(new A(), new A()); //compiler error\n//Set<B> setB = new HashSet<>(listA);              //compiler error\n\n```", "```java\nList<Integer> list = Arrays.asList(1,2,3,4,5);\nlist.set(2, 0);\nlist.forEach(System.out::print);  //prints: 12045\n\nlist.forEach(i -> {\n  int j = list.get(2);\n  list.set(2, j + 1);\n});\nSystem.out.println();\nlist.forEach(System.out::print);   //prints: 12545\n```", "```java\nList.of(\"This\", \"is\", \"created\", \"by\", \"List.of().stream()\")\n                            .stream().forEach(System.out::print);\nSystem.out.println();\nSet.of(\"This\", \"is\", \"created\", \"by\", \"Set.of().stream()\")\n                            .stream().forEach(System.out::print);\nSystem.out.println();\nMap.of(1, \"This \", 2, \"is \", 3, \"built \", 4, \"by \", 5,\n                             \"Map.of().entrySet().stream()\")\n                 .entrySet().stream().forEach(System.out::print);\n```", "```java\nStream<T> stream(T[] array)\nStream<T> stream(T[] array, int startInclusive, int endExclusive)\n```", "```java\nString[] array = {\"That \", \"is \", \"an \", \"Arrays.stream(array)\"};\nArrays.stream(array).forEach(System.out::print);\nSystem.out.println();\nString[] array1 = { \"That \", \"is \", \"an \", \n                                    \"Arrays.stream(array,0,2)\" };\nArrays.stream(array1, 0, 2).forEach(System.out::print);\n```", "```java\nStream<T> of(T t)          //Stream of one element\nStream<T> ofNullable(T t)  //Stream of one element\n       // if not null. Otherwise, returns an empty Stream\nStream<T> of(T... values)\nStream<T> generate(Supplier<T> s)\nStream<T> iterate(T seed, UnaryOperator<T> f)\nStream<T> iterate(T seed, Predicate<T> hasNext, \n                           UnaryOperator<T> next)\n```", "```java\nString[] array = { \"That \", \"is \", \"a \", \"Stream.of(array)\" };\nStream.of(array).forEach(System.out::print); \nSystem.out.println();\nStream.of( \"That \", \"is \", \"a \", \"Stream.of(literals)\" )\n                                  .forEach(System.out::print);\n```", "```java\nStream.generate(() -> \"generated \")\n                           .limit(3).forEach(System.out::print);\nSystem.out.println();\nSystem.out.print(\"Stream.iterate().limit(10): \");\nStream.iterate(0, i -> i + 1)\n                          .limit(10).forEach(System.out::print);\nSystem.out.println();\nSystem.out.print(\"Stream.iterate(Predicate < 10): \");\nStream.iterate(0, i -> i < 10, i -> i + 1)\n                                    .forEach(System.out::print);\n```", "```java\nSystem.out.println(\"Files.list(dir): \");\nPath dir = FileSystems.getDefault()\n  .getPath(\"src/main/java/com/packt/cookbook/ch05_streams/\");\ntry(Stream<Path> stream = Files.list(dir)) {\n      stream.forEach(System.out::println);\n} catch (Exception ex){ \n      ex.printStackTrace(); \n}\n```", "```java\n  System.out.println(\"Files.lines().limit(3): \");\n  String file = \"src/main/java/com/packt/cookbook/\" +\n                              \"ch05_streams/Chapter05Streams.java\";\n  try(Stream<String> stream=Files.lines(Paths.get(file)).limit(3)){ \n       stream.forEach(l -> { \n            if( l.length() > 0 ) {\n                System.out.println(\"   \" + l); \n            }\n       });\n  } catch (Exception ex){ \n      ex.printStackTrace(); \n  }\n```", "```java\nStream<Path> find(Path start, int maxDepth, BiPredicate<Path, \n    BasicFileAttributes> matcher, FileVisitOption... options)\n```", "```java\nPath dir = FileSystems.getDefault()\n .getPath(\"src/main/java/com/packt/cookbook/ch05_streams/\");\nBiPredicate<Path, BasicFileAttributes> select = \n   (p, b) -> p.getFileName().toString().contains(\"Factory\");\ntry(Stream<Path> stream = Files.find(f, 2, select)){\n        stream.map(path -> path.getFileName())\n                              .forEach(System.out::println);\n} catch (Exception ex){ \n   ex.printStackTrace(); \n}\n```", "```java\n//1\nStream<T> peek(Consumer<T> action)\n//2\nStream<T> distinct()       //Returns stream of distinct elements\nStream<T> skip(long n)     //Discards the first n elements \nStream<T> limit(long n)    //Allows the first n elements to be processed \nStream<T> filter(Predicate<T> predicate)\nStream<T> dropWhile(Predicate<T> predicate) \nStream<T> takeWhile(Predicate<T> predicate)\n//3 \nStream<R> map(Function<T, R> mapper)\nIntStream mapToInt(ToIntFunction<T> mapper)\nLongStream mapToLong(ToLongFunction<T> mapper)\nDoubleStream mapToDouble(ToDoubleFunction<T> mapper)\n//4\nStream<R> flatMap(Function<T, Stream<R>> mapper)\nIntStream flatMapToInt(Function<T, IntStream> mapper)\nLongStream flatMapToLong(Function<T, LongStream> mapper)\nDoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)\n//5\nstatic Stream<T> concat(Stream<T> a, Stream<T> b) \n//6\nStream<T> sorted()\nStream<T> sorted(Comparator<T> comparator)\n```", "```java\n<R> Stream<R> flatMap(Function<? super T,\n                      ? extends Stream<? extends R>> mapper)\n```", "```java\n       int sum = Stream.of( 1,2,3,4,5,6,7,8,9 )\n                       .filter(i -> i % 2 != 0)\n                       .peek(i -> System.out.print(i))\n                       .mapToInt(Integer::intValue)\n                       .sum();\n       System.out.println(\"sum = \" + sum);\n```", "```java\nSystem.out.println(\"Files.lines().dropWhile().takeWhile():\");\nString file = \"src/main/java/com/packt/cookbook/\" + \n                        \"ch05_streams/Chapter05Streams.java\";\ntry(Stream<String> stream = Files.lines(Paths.get(file))){\n    stream.dropWhile(l -> \n                  !l.contains(\"dropWhile().takeWhile()\"))\n        .takeWhile(l -> !l.contains(\"} catc\" + \"h\"))\n        .forEach(System.out::println);\n} catch (Exception ex){ \n    ex.printStackTrace(); \n}   \n```", "```java\nStream.of( \"That \", \"is \", \"a \", \"Stream.of(literals)\" )\n              .map(s -> s.contains(\"i\"))\n              .forEach(System.out::println);\n```", "```java\nStream.of( \"That \", \"is \", \"a \", \"Stream.of(literals)\" )\n     .filter(s -> s.contains(\"Th\"))\n     .flatMap(s -> Pattern.compile(\"(?!^)\").splitAsStream(s))\n     .forEach(System.out::print);\n```", "```java\nStream.concat(Stream.of(4,5,6), Stream.of(1,2,3))\n                                  .forEach(System.out::print);\n```", "```java\nStream.of(Stream.of(4,5,6), Stream.of(1,2,3), Stream.of(7,8,9))\n .flatMap(Function.identity())\n .forEach(System.out::print);\n```", "```java\n//1\nlong count()                     //Returns total count of elements\n//2\nOptional<T> max(Comparator<T> c) //Returns max according to Comparator\nOptional<T> min(Comparator<T> c) //Returns min according to Comparator\n//3\nOptional<T> findAny()    //Returns any or empty Optional\nOptional<T> findFirst()  //Returns the first element or empty Optional \n//4\nboolean allMatch(Predicate<T> p)   //All elements match Predicate?\nboolean anyMatch(Predicate<T> p)   //Any element matches Predicate?\nboolean noneMatch(Predicate<T> p)  //No element matches Predicate?\n//5\nvoid forEach(Consumer<T> action)   //Apply action to each element \nvoid forEachOrdered(Consumer<T> action) \n//6\nOptional<T> reduce(BinaryOperator<T> accumulator) \nT reduce(T identity, BinaryOperator<T> accumulator) \nU reduce(U identity, BiFunction<U,T,U> accumulator, \n                                          BinaryOperator<U> combiner) \n//7\nR collect(Collector<T,A,R> collector) \nR collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, \n                                            BiConsumer<R,R> combiner) \n//8\nObject[] toArray() \nA[] toArray(IntFunction<A[]> generator)\n```", "```java\n    Stream.of(Stream.of(4,5,6), Stream.of(1,2,3), Stream.of(7,8,9))\n          .reduce(Stream::concat)\n          .orElseGet(Stream::empty)\n          .forEach(System.out::print);\n```", "```java\nStream.of(\"3\",\"2\",\"1\").parallel().forEach(System.out::print);\nSystem.out.println();\nStream.of(\"3\",\"2\",\"1\").parallel().forEachOrdered(System.out::print);\n```", "```java\n Stream.of( \"That \", \"is \", \"a \", null, \"Stream.of(literals)\" )\n       .map(Optional::ofNullable) \n       .filter(Optional::isPresent)\n       .map(Optional::get)\n       .map(String::toString)\n       .forEach(System.out::print);\n```", "```java\n int sum = Stream.of(1,2,3).reduce((p,e) -> p + e).orElse(0);\n System.out.println(\"Stream.of(1,2,3).reduce(acc): \" +sum);\n```", "```java\nint sum = Stream.of(1,2,3)\n        .reduce((p,e) -> {\n            System.out.println(p);   //prints: 1 3\n            return p + e;\n        })\n        .orElse(10);\nSystem.out.println(\"Stream.of(1,2,3).reduce(acc): \" + sum);\n```", "```java\nint sum = Stream.of(1,2,3).reduce(0, (p,e) -> p + e);\nSystem.out.println(\"Stream.of(1,2,3).reduce(0, acc): \" + sum);\n```", "```java\nString sum = Stream.of(1,2,3)\n    .reduce(\"\", (p,e) -> p + e.toString(), (x,y) -> x + \",\" + y);\nSystem.out.println(\"Stream.of(1,2,3).reduce(,acc,comb): \" + sum);\n\n```", "```java\nString sum = Stream.of(1,2,3).parallel()  \n    .reduce(\"\", (p,e) -> p + e.toString(), (x,y) -> x + \",\" + y);\nSystem.out.println(\"Stream.of(1,2,3).reduce(,acc,comb): \" + sum);\n```", "```java\nString sum = Stream.of(1,2,3)\n                   .map(i -> i.toString() + \",\")\n                   .reduce(\"\", (p,e) -> p + e);\nSystem.out.println(\"Stream.of(1,2,3).map.reduce(,acc): \" \n                   + sum.substring(0, sum.length()-1));\n\n```", "```java\nString sum = Stream.of(1,2,3).parallel()\n                   .map(i -> i.toString() + \",\")\n                   .reduce(\"\", (p,e) -> p + e);\nSystem.out.println(\"Stream.of(1,2,3).map.reduce(,acc): \" \n                   + sum.substring(0, sum.length()-1));\n\n```", "```java\nR collect(Collector<T,A,R> collector) \nR collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, \n                                            BiConsumer<R,R> combiner) \n```", "```java\npublic class Thing {\n  private int someInt;\n  public Thing(int i) { this.someInt = i; }\n  public int getSomeInt() { return someInt; }\n  public String getSomeStr() { \n    return Integer.toString(someInt); }\n} \n```", "```java\ndouble aa = Stream.of(1,2,3).map(Thing::new)\n              .collect(Collectors.averagingInt(Thing::getSomeInt));\nSystem.out.println(\"stream(1,2,3).averagingInt(): \" + aa);\n\nString as = Stream.of(1,2,3).map(Thing::new).map(Thing::getSomeStr)\n                                 .collect(Collectors.joining(\",\"));\nSystem.out.println(\"stream(1,2,3).joining(,): \" + as);\n\nString ss = Stream.of(1,2,3).map(Thing::new).map(Thing::getSomeStr)\n                       .collect(Collectors.joining(\",\", \"[\", \"]\"));\nSystem.out.println(\"stream(1,2,3).joining(,[,]): \" + ss);\n```", "```java\nObject[] toArray() \nA[] toArray(IntFunction<A[]> generator)\n```", "```java\n Object[] os = Stream.of(1,2,3).toArray();\n Arrays.stream(os).forEach(System.out::print);\n System.out.println();\n String[] sts = Stream.of(1,2,3)\n                      .map(i -> i.toString())\n                      .toArray(String[]::new);\n Arrays.stream(sts).forEach(System.out::print);\n```", "```java\nStream.of(1,2,3).toArray().forEach(System.out::print);\n```", "```java\nIntStream.range(1,3).forEach(System.out::print); //prints: 12\nLongStream.range(1,3).forEach(System.out::print); //prints: 12\nIntStream.rangeClosed(1,3).forEach(System.out::print);  // 123\nLongStream.rangeClosed(1,3).forEach(System.out::print); // 123\n\n```", "```java\nIntStream.range(3,3).forEach(System.out::print);\n                                                //prints:\nLongStream.range(3,3).forEach(System.out::print);      \n                                                //prints:\nIntStream.rangeClosed(3,3).forEach(System.out::print); \n                                                //prints: 3\nLongStream.rangeClosed(3,3).forEach(System.out::print);\n                                                //prints: 3\n\n```", "```java\nIntStream.range(3,1).forEach(System.out::print);        \nLongStream.range(3,1).forEach(System.out::print);       \nIntStream.rangeClosed(3,1).forEach(System.out::print);  \nLongStream.rangeClosed(3,1).forEach(System.out::print); \n\n```", "```java\nIntStream stream(int[] array)\nIntStream stream(int[] array, int startInclusive, \n int endExclusive)\nLongStream stream(long[] array)\nLongStream stream(long[] array, int startInclusive, \n                                           int endExclusive)\nDoubleStream stream(double[] array)\nDoubleStream stream(double[] array, int startInclusive, \n                                           int endExclusive)\n```", "```java\nint[] ai = {2, 3, 1, 5, 4};\nArrays.stream(ai)\n      .forEach(System.out::print);  //prints: 23154\nArrays.stream(ai, 1, 3)\n      .forEach(System.out::print);  //prints: 31\nlong[] al = {2, 3, 1, 5, 4};\nArrays.stream(al)\n       .forEach(System.out::print);  //prints: 23154\nArrays.stream(al, 1, 3)\n       .forEach(System.out::print);  //prints: 31\ndouble[] ad = {2., 3., 1., 5., 4.};\nArrays.stream(ad)\n  .forEach(System.out::print);  //prints: 2.03.01.05.04.0\nArrays.stream(ad, 1, 3)\n      .forEach(System.out::print);  //prints: 3.01.0\n\n```", "```java\ndouble[] ad = {2., 3., 1., 5., 4.};\nString res = Arrays.stream(ad).mapToObj(String::valueOf)\n                       .collect(Collectors.joining(\" \")); \nSystem.out.println(res);   //prints: 2.0 3.0 1.0 5.0 4.0\nres = Arrays.stream(ad, 1, 3).mapToObj(String::valueOf)\n                       .collect(Collectors.joining(\" \"));  \nSystem.out.println(res);               //prints: 3.0 1.0\n\n```", "```java\ndouble[] ad = {2., 3., 1., 5., 4.};\nString res = Arrays.stream(ad).boxed()\n                   .map(Object::toString)\n                   .collect(Collectors.joining(\" \")); \nSystem.out.println(res); //prints: 2.0 3.0 1.0 5.0 4.0\nres = Arrays.stream(ad, 1, 3).boxed()\n                     .map(Object::toString)\n                     .collect(Collectors.joining(\" \")); \nSystem.out.println(res); //prints: 3.0 1.0\n```", "```java\nIntStream.range(1, 3).asLongStream()\n              .forEach(System.out::print); //prints: 12\nIntStream.range(1, 3).asDoubleStream()\n .forEach(d -> System.out.print(d + \" \")); //prints: 1.0 2.0\nLongStream.range(1, 3).asDoubleStream()\n .forEach(d -> System.out.print(d + \" \")); //prints: 1.0 2.0\n\n```", "```java\n         int sum = IntStream.empty().sum();\n         System.out.println(sum);                   //prints: 0\n         sum = IntStream.range(1, 3).sum();\n         System.out.println(sum);                   //prints: 3\n         double av = IntStream.empty().average().orElse(0);\n         System.out.println(av);                   //prints: 0.0\n         av = IntStream.range(1, 3).average().orElse(0);\n         System.out.println(av);                   //prints: 1.5\n\n```", "```java\n        long suml = LongStream.range(1, 3).sum();\n        System.out.println(suml);                 //prints: 3\n        double avl = LongStream.range(1, 3).average().orElse(0);\n        System.out.println(avl);                  //prints: 1.5\n\n        double sumd = DoubleStream.of(1, 2).sum();\n        System.out.println(sumd);                 //prints: 3.0\n        double avd = DoubleStream.of(1, 2).average().orElse(0);\n        System.out.println(avd);                  //prints: 1.5\n\n```", "```java\n     IntSummaryStatistics iss = \n                    IntStream.empty().summaryStatistics();\n     System.out.println(iss);   //count=0, sum=0, \n       //min=2147483647, average=0.000000, max=-2147483648\n     iss = IntStream.range(1, 3).summaryStatistics();\n     System.out.println(iss);    //count=2, sum=3, min=1, \n                                 //average=1.500000, max=2\n\n     LongSummaryStatistics lss = \n                    LongStream.empty().summaryStatistics();\n     System.out.println(lss);  //count=0, sum=0, \n                               //min=9223372036854775807, \n               //average=0.000000, max=-9223372036854775808\n     lss = LongStream.range(1, 3).summaryStatistics();\n     System.out.println(lss);  //count=2, sum=3, min=1, \n                               //average=1.500000, max=2\n\n     DoubleSummaryStatistics dss = \n                   DoubleStream.empty().summaryStatistics();\n     System.out.println(dss);  //count=0, sum=0.000000, \n            //min=Infinity, average=0.000000, max=-Infinity\n     dss = DoubleStream.of(1, 2).summaryStatistics();\n     System.out.println(dss);  //count=2, sum=3.000000, \n             //min=1.000000, average=1.500000, max=2.000000\n\n```", "```java\n    System.out.println(Integer.MAX_VALUE); // 2147483647\n    System.out.println(Integer.MIN_VALUE); //-2147483648\n    System.out.println(Long.MAX_VALUE);    // 9223372036854775807\n    System.out.println(Long.MIN_VALUE);    //-9223372036854775808\n    System.out.println(Double.MAX_VALUE);  //1.7976931348623157E308\n    System.out.println(Double.MIN_VALUE);  //4.9E-324\n\n```", "```java\nIntSummaryStatistics iss = Stream.of(3, 1)\n        .collect(IntSummaryStatistics::new,\n                 IntSummaryStatistics::accept,\n                 IntSummaryStatistics::combine\n        );\nSystem.out.println(iss);  //count=2, sum=4, min=1, \n                          //average=2.000000, max=3\n\n```", "```java\nIntSummaryStatistics iss = Stream.of(3, 1)\n   .collect(IntSummaryStatistics::new,\n      IntSummaryStatistics::accept,\n      (r, r1) -> {\n        System.out.println(\"Combining...\");  //is not printing\n        r.combine(r1);\n      }\n   );\nSystem.out.println(iss); //count=2, sum=4, min=1, \n                          //average=2.000000, max=3\n```", "```java\nIntSummaryStatistics iss = Stream.of(3, 1)\n     .parallel()\n     .collect(IntSummaryStatistics::new,\n         IntSummaryStatistics::accept,\n         (r, r1) -> {\n             System.out.println(\"Combining...\");  //Now it prints!\n             r.combine(r1);\n         }\n     );\nSystem.out.println(iss); //count=2, sum=4, min=1, \n                          //average=2.000000, max=3\n```", "```java\nCollector<T, ?, IntSummaryStatistics> \n                   summarizingInt (ToIntFunction<T> mapper)\nCollector<T, ?, LongSummaryStatistics> \n                  summarizingLong(ToLongFunction<T> mapper)\nCollector<T, ?, DoubleSummaryStatistics> \n              summarizingDouble(ToDoubleFunction<T> mapper)\n```", "```java\nclass Person {\n    private int age;\n    private String name;\n    public Person(int age, String name) {\n        this.name = name;\n        this.age = age;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n}\n```", "```java\nIntSummaryStatistics iss = \n   Stream.of(new Person(30, \"John\"), new Person(20, \"Jill\"))\n         .collect(Collectors.summarizingInt(Person::getAge));\nSystem.out.println(iss);     //count=2, sum=50, min=20, \n                             //average=25.000000, max=30\n\n```", "```java\n                 R result = supplier.get();\n                 for (T element : this stream) {\n                    accumulator.accept(result, element);\n                 }\n                 return result;\n```", "```java\nclass Person {\n    private int age;\n    private String name;\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Person)) return false;\n        Person person = (Person) o;\n        return getAge() == person.getAge() &&\n                Objects.equals(getName(), person.getName());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getAge());\n    }\n    @Override\n    public String toString() {\n        return \"Person{name:\" + this.name + \",age:\" + this.age + \"}\";\n    }\n}\n```", "```java\n List<Person> list = \n    Stream.of(new Person(30, \"John\"), new Person(20, \"Jill\"))\n    .collect(ArrayList::new,\n             List::add,      //same as: (a,p)-> a.add(p),\n             List::addAll    //same as: (r, r1)-> r.addAll(r1)\n    );\n System.out.println(list);\n   //prints: [Person{name:John,age:30}, Person{name:Jill,age:20}]  \n```", "```java\n  List<Person> list = \n     Stream.of(new Person(30, \"John\"), new Person(20, \"Jill\"))\n           .collect(ArrayList::new,\n                    ArrayList::add,\n                    (r, r1)-> {\n                        System.out.println(\"Combining...\");\n                        r.addAll(r1);\n                    }\n           );\n  System.out.println(list1);  \n   //prints: [Person{name:John,age:30}, Person{name:Jill,age:20}]\n\n```", "```java\n List<Person> list = \n    Stream.of(new Person(30, \"John\"), new Person(20, \"Jill\"))\n          .parallel()\n          .collect(ArrayList::new,\n                   ArrayList::add,\n                   (r, r1)-> {\n                      System.out.println(\"Combining...\");\n                      r.addAll(r1);\n                   }\n          );\n  System.out.println(list1);  \n    //prints: [Person{name:John,age:30}, Person{name:Jill,age:20}]\n\n```", "```java\n Set<Person> set = \n   Stream.of(new Person(30, \"John\"), new Person(20, \"Jill\"))\n         .collect(HashSet::new,\n                  Set::add,      //same as: (a,p)-> a.add(p),\n                  Set::addAll    //same as: (r, r1)-> r.addAll(r1)\n         );\n System.out.println(set);  \n   //prints: [Person{name:John,age:30}, Person{name:Jill,age:20}]\n```", "```java\nlist.add(new Person(30, \"Bob\"));\nSystem.out.println(list);  //prints: [Person{name:John,age:30}, \n                           //         Person{name:Jill,age:20}, \n                           //         Person{name:Bob,age:30}]\nlist.set(1, new Person(15, \"Bob\"));\nSystem.out.println(list);  //prints: [Person{name:John,age:30}, \n                           //         Person{name:Bob,age:15}, \n                           //         Person{name:Bob,age:30}]\nset.add(new Person(30, \"Bob\"));\nSystem.out.println(set);   //prints: [Person{name:John,age:30}, \n                           //         Person{name:Jill,age:20}, \n                           //         Person{name:Bob,age:30}]\n```", "```java\n       List<Person> list = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"))\n                .collect(Collectors.toList());\n       System.out.println(list);  //prints: [Person{name:John,age:30}, \n                                  //         Person{name:Jill,age:20}]\n\n       Set<Person> set1 = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"))\n                .collect(Collectors.toSet());\n       System.out.println(set1); //prints: [Person{name:John,age:30}, \n                                            Person{name:Jill,age:20}]\n\n       Set<Person> set2 = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"), \n                                    new Person(30, \"John\"))\n                .collect(Collectors.toSet());\n        System.out.println(set2); //prints: [Person{name:John,age:30}, \n                                             Person{name:Jill,age:20}]\n        set2.add(new Person(30, \"Bob\"));\n        System.out.println(set2); //prints: [Person{name:John,age:30}, \n                                             Person{name:Jill,age:20}, \n                                             Person{name:Bob,age:30}]\n\n```", "```java\nLinkedList<Person> list = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"))\n        .collect(Collectors.toCollection(LinkedList::new));\nSystem.out.println(list);  //prints: [Person{name:John,age:30}, \n                            //        Person{name:Jill,age:20}]\n\nLinkedHashSet<Person> set = Stream.of(new Person(30, \"John\"), \n                                      new Person(20, \"Jill\"))\n        .collect(Collectors.toCollection(LinkedHashSet::new));\nSystem.out.println(set);  //prints: [Person{name:John,age:30}, \n                                     Person{name:Jill,age:20}]\n```", "```java\nList<Person> list = Stream.of(new Person(30, \"John\"), \n                              new Person(20, \"Jill\"))\n        .collect(Collectors.toUnmodifiableList());\nSystem.out.println(list);  //prints: [Person{name:John,age:30}, \n                           //         Person{name:Jill,age:20}]\n\nlist.add(new Person(30, \"Bob\"));  //UnsupportedOperationException\nlist.set(1, new Person(15, \"Bob\")); //UnsupportedOperationException\nlist.remove(new Person(30, \"John\")); //UnsupportedOperationException\n\nSet<Person> set = Stream.of(new Person(30, \"John\"), \n                            new Person(20, \"Jill\"))\n        .collect(Collectors.toUnmodifiableSet());\nSystem.out.println(set);  //prints: [Person{name:John,age:30}, \n                          //         Person{name:Jill,age:20}]\n\nset.add(new Person(30, \"Bob\"));  //UnsupportedOperationException\n\n```", "```java\nSet<Person> set = Stream.of(new Person(30, \"John\"), \n                            new Person(20, \"Jill\"))\n        .collect(Collectors.toUnmodifiableSet());\n\nPredicate<Person> filter = p -> set.contains(p);\n```", "```java\nclass Person {\n    private int age;\n    private String name;\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Person)) return false;\n        Person person = (Person) o;\n        return getAge() == person.getAge() &&\n                Objects.equals(getName(), person.getName());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getAge());\n    }\n    @Override\n    public String toString() {\n        return \"Person{name:\" + this.name + \",age:\" + this.age + \"}\";\n    }\n}\n```", "```java\nMap<String, Person> map = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"))\n        .collect(HashMap::new,\n                (m,p) -> m.put(p.getName(), p),\n                Map::putAll\n        );\nSystem.out.println(map); //prints: {John=Person{name:John,age:30}, \n                         //         Jill=Person{name:Jill,age:20}}\n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"))\n        .collect(HashMap::new,\n                (m,p) -> m.put(p.getName(), p.getAge()),\n                Map::putAll\n        );\nSystem.out.println(map);       //prints: {John=30, Jill=20}\n\n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"))\n      //.parallel()     //conversion to a parallel stream\n        .collect(HashMap::new,\n                (m,p) -> m.put(p.getName(), p.getAge()),\n                (m,m1) -> {\n                      System.out.println(\"Combining...\");\n                      m.putAll(m1);\n                }\n        );\nSystem.out.println(map);  //prints: {John=30, Jill=20}\n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"),\n                                     new Person(15, \"John\"))\n        .collect(HashMap::new,\n                (m,p) -> m.put(p.getName(), p.getAge()),\n                Map::putAll\n        );\nSystem.out.println(map);       //prints: {John=15, Jill=20}\n```", "```java\nBiConsumer<Map<String, List<Integer>>, Person> consumer = \n(m,p) -> {\n    List<Integer> list = m.get(p.getName());\n    if(list == null) {\n        list = new ArrayList<>(); \n        m.put(p.getName(), list);\n    }\n    list.add(p.getAge());\n};\nMap<String, List<Integer>> map = \n  Stream.of(new Person(30, \"John\"), \n            new Person(20, \"Jill\"), \n            new Person(15, \"John\"))\n        .collect(HashMap::new, consumer, Map::putAll);\nSystem.out.println(map);\n                   //prints: {John=[30, 15], Jill=[20]}\n\n```", "```java\nBiConsumer<Map<String, String>, Person> consumer2 = (m,p) -> {\n if(m.keySet().contains(p.getName())) {\n   m.put(p.getName(), m.get(p.getName()) + \",\" + p.getAge());\n } else {\n   m.put(p.getName(), String.valueOf(p.getAge()));\n }\n};\nMap<String, String> map = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"), \n                                    new Person(15, \"John\"))\n        .collect(HashMap::new, consumer, Map::putAll);\nSystem.out.println(map);    //prints: {John=30,15, Jill=20}\n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"))\n  .collect(Collectors.toMap(Person::getName, Person::getAge));\nSystem.out.println(map);     //prints: {John=30, Jill=20}\n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"),\n                                     new Person(15, \"John\"))\n.collect(Collectors.toMap(Person::getName, Person::getAge));\n\n```", "```java\nFunction<Person, List<Integer>> valueMapper = p -> {\n    List<Integer> list = new ArrayList<>();\n    list.add(p.getAge());\n    return list;\n};\nBinaryOperator<List<Integer>> mergeFunction = (l1, l2) -> {\n    l1.addAll(l2);\n    return l1;\n};\nMap<String, List<Integer>> map = \n   Stream.of(new Person(30, \"John\"), \n             new Person(20, \"Jill\"), \n             new Person(15, \"John\"))\n         .collect(Collectors.toMap(Person::getName, \n                           valueMapper, mergeFunction));\nSystem.out.println(map); \n                     //prints: {John=[30, 15], Jill=[20]}\n\n```", "```java\nFunction<Person, String> valueMapper = \n                        p -> String.valueOf(p.getAge());\nBinaryOperator<String> mergeFunction = \n                              (s1, s2) -> s1 + \",\" + s2;\nMap<String, String> map = \n  Stream.of(new Person(30, \"John\"), \n            new Person(20, \"Jill\"), \n            new Person(15, \"John\"))\n        .collect(Collectors.toMap(Person::getName, \n                           valueMapper, mergeFunction));\nSystem.out.println(map3);//prints: {John=30,15, Jill=20}\n```", "```java\nFunction<Person, String> valueMapper = \n                           p -> String.valueOf(p.getAge());\nBinaryOperator<String> mergeFunction = \n                                 (s1, s2) -> s1 + \",\" + s2;\nLinkedHashMap<String, String> map = \n   Stream.of(new Person(30, \"John\"), \n             new Person(20, \"Jill\"), \n             new Person(15, \"John\"))\n         .collect(Collectors.toMap(Person::getName, \n           valueMapper, mergeFunction, LinkedHashMap::new));\nSystem.out.println(map3);    //prints: {John=30,15, Jill=20} \n```", "```java\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                      new Person(20, \"Jill\"))\n        .collect(Collectors.toUnmodifiableMap(Person::getName, \n                                              Person::getAge));\nSystem.out.println(map);          //prints: {John=30, Jill=20}\n\nmap.put(\"N\", new Person(42, \"N\")); //UnsupportedOperationExc\nmap.remove(\"John\");                //UnsupportedOperationExc\n\nMap<String, Integer> map = Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"), \n                                     new Person(15, \"John\"))\n  .collect(Collectors.toUnmodifiableMap(Person::getName, \n    Person::getAge)); //IllegalStateExc: Duplicate key John\n\n```", "```java\nFunction<Person, List<Integer>> valueMapper = p -> {\n    List<Integer> list = new ArrayList<>();\n    list.add(p.getAge());\n    return list;\n};\nBinaryOperator<List<Integer>> mergeFunction = (l1, l2) -> {\n    l1.addAll(l2);\n    return l1;\n};\nMap<String, List<Integer>> map = \n    Stream.of(new Person(30, \"John\"), \n              new Person(20, \"Jill\"), \n              new Person(15, \"John\"))\n      .collect(Collectors.toUnmodifiableMap(Person::getName, \n                                valueMapper, mergeFunction));\nSystem.out.println(map); //prints: {John=[30, 15], Jill=[20]}\n```", "```java\nFunction<Person, String> valueMapper = \n                             p -> String.valueOf(p.getAge());\nBinaryOperator<String> mergeFunction = \n                                   (s1, s2) -> s1 + \",\" + s2;\nMap<String, String> map = Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"), \n                                    new Person(15, \"John\"))\n    .collect(Collectors.toUnmodifiableMap(Person::getName, \n                                valueMapper, mergeFunction));\nSystem.out.println(map);      //prints: {John=30,15, Jill=20}\n```", "```java\nConcurrentMap<String, Integer> map = \n                            Stream.of(new Person(30, \"John\"), \n                                      new Person(20, \"Jill\"))\n        .collect(Collectors.toConcurrentMap(Person::getName, \n                                            Person::getAge));\nSystem.out.println(map);          /prints: {John=30, Jill=20}\n\nmap.put(\"N\", new Person(42, \"N\")); //UnsupportedOperationExc\nmap.remove(\"John\");                //UnsupportedOperationExc\n\nConcurrentMap<String, Integer> map = \n                           Stream.of(new Person(30, \"John\"), \n                                     new Person(20, \"Jill\"), \n                                     new Person(15, \"John\"))\n  .collect(Collectors.toConcurrentMap(Person::getName, \n    Person::getAge)); //IllegalStateExc: Duplicate key John\n```", "```java\nFunction<Person, List<Integer>> valueMapper = p -> {\n    List<Integer> list = new ArrayList<>();\n    list.add(p.getAge());\n    return list;\n};\nBinaryOperator<List<Integer>> mergeFunction = (l1, l2) -> {\n    l1.addAll(l2);\n    return l1;\n};\nConcurrentMap<String, List<Integer>> map = \n  Stream.of(new Person(30, \"John\"), \n            new Person(20, \"Jill\"), \n            new Person(15, \"John\"))\n       .collect(Collectors.toConcurrentMap(Person::getName, \n                              valueMapper, mergeFunction));\nSystem.out.println(map);\n                       //prints: {John=[30, 15], Jill=[20]}\n```", "```java\nFunction<Person, String> valueMapper = \n                              p -> String.valueOf(p.getAge());\nBinaryOperator<String> mergeFunction = \n                                    (s1, s2) -> s1 + \",\" + s2;\nConcurrentMap<String, String> map = \n                          Stream.of(new Person(30, \"John\"), \n                                    new Person(20, \"Jill\"), \n                                    new Person(15, \"John\"))\n    .collect(Collectors.toConcurrentMap(Person::getName, \n                                 valueMapper, mergeFunction));\nSystem.out.println(map);       //prints: {John=30,15, Jill=20}\n```", "```java\nConcurrentSkipListMap<String, String> map = \n                             Stream.of(new Person(30, \"John\"), \n                                       new Person(20, \"Jill\"), \n                                       new Person(15, \"John\"))\n   .collect(Collectors.toConcurrentMap(Person::getName, \n     valueMapper, mergeFunction, ConcurrentSkipListMap::new));\nSystem.out.println(map4);      //prints: {Jill=20, John=30,15}\n```", "```java\nclass Person {\n    private int age;\n    private String name;\n    public Person(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Person)) return false;\n        Person person = (Person) o;\n        return getAge() == person.getAge() &&\n                Objects.equals(getName(), person.getName());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getAge());\n    }\n    @Override\n    public String toString() {\n        return \"Person{name:\" + this.name + \",age:\" + this.age + \"}\";\n    }\n}\n```", "```java\nclass Person2 {\n    private int age;\n    private String name, city;\n    public Person2(int age, String name, String city) {\n        this.age = age;\n        this.name = name;\n        this.city = city;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n    public String getCity() { return this.city; }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Person)) return false;\n        Person2 person = (Person2) o;\n        return getAge() == person.getAge() &&\n                Objects.equals(getName(), person.getName()) &&\n                Objects.equals(getCity(), person.getCity());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getAge(), getCity());\n    }\n    @Override\n    public String toString() {\n        return \"Person{name:\" + this.name + \",age:\" + this.age  + \n                                       \",city:\" + this.city + \"}\";\n    }\n}\n```", "```java\nenum City{\n    Chicago, Denver, Seattle\n}\n\nclass Person3 {\n    private int age;\n    private String name;\n    private City city;\n    public Person3(int age, String name, City city) {\n        this.age = age;\n        this.name = name;\n        this.city = city;\n    }\n    public int getAge() { return this.age; }\n    public String getName() { return this.name; }\n    public City getCity() { return this.city; }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Person)) return false;\n        Person3 person = (Person3) o;\n        return getAge() == person.getAge() &&\n                Objects.equals(getName(), person.getName()) &&\n                Objects.equals(getCity(), person.getCity());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getAge(), getCity());\n    }\n    @Override\n    public String toString() {\n        return \"Person{name:\" + this.name + \",age:\" + this.age  + \n                                       \",city:\" + this.city + \"}\";\n    }\n}\n```", "```java\nStream<Person> getStreamPerson() {\n    return Stream.of(new Person(30, \"John\"), \n                     new Person(20, \"Jill\"), \n                     new Person(20, \"John\"));\n}\nStream<Person2> getStreamPerson2(){\n    return Stream.of(new Person2(30, \"John\", \"Denver\"), \n                     new Person2(30, \"John\", \"Seattle\"), \n                     new Person2(20, \"Jill\", \"Seattle\"), \n                     new Person2(20, \"Jill\", \"Chicago\"), \n                     new Person2(20, \"John\", \"Denver\"),\n                     new Person2(20, \"John\", \"Chicago\"));\n}\nStream<Person3> getStreamPerson3(){\n    return Stream.of(new Person3(30, \"John\", City.Denver), \n                     new Person3(30, \"John\", City.Seattle),\n                     new Person3(20, \"Jill\", City.Seattle), \n                     new Person3(20, \"Jill\", City.Chicago),\n                     new Person3(20, \"John\", City.Denver),\n                     new Person3(20, \"John\", City.Chicago));\n}\n```", "```java\nMap<String, List<Person>> map = getStreamPerson()\n        .collect(Collectors.groupingBy(Person::getName));\nSystem.out.println(map);  \n               //prints: {John=[Person{name:John,age:30}, \n               //               Person{name:John,age:20}], \n               //         Jill=[Person{name:Jill,age:20}]}\n\n```", "```java\nMap<Integer, List<Person>> map = getStreamPerson()\n        .collect(Collectors.groupingBy(Person::getAge));\nSystem.out.println(map);  \n                //prints: {20=[Person{name:Jill,age:20}, \n                //             Person{name:John,age:20}], \n                //         30=[Person{name:John,age:30}]}\n```", "```java\nclass TwoStrings {\n    private String one, two;\n    public TwoStrings(String one, String two) {\n        this.one = one;\n        this.two = two;\n    }\n    public String getOne() { return this.one; }\n    public String getTwo() { return this.two; }\n    @Override\n    public boolean equals(Object o) {\n       if (this == o) return true;\n       if (!(o instanceof TwoStrings)) return false;\n       TwoStrings twoStrings = (TwoStrings) o;\n       return Objects.equals(getOne(), twoStrings.getOne()) \n           && Objects.equals(getTwo(), twoStrings.getTwo());\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(getOne(), getTwo());\n    }\n    @Override\n    public String toString() {\n        return \"(\" + this.one + \",\" + this.two + \")\";\n    }\n}\n```", "```java\nMap<TwoStrings, List<Person2>> map = getStreamPerson2()\n  .collect(Collectors.groupingBy(p -> \n            new TwoStrings(String.valueOf(p.getAge()), \n                                        p.getName())));\nSystem.out.println(map);  \n//prints: \n//   {(20,Jill)=[Person{name:Jill,age:20,city:Seattle}, \n//               Person{name:Jill,age:20,city:Chicago}], \n//    (20,John)=[Person{name:John,age:20,city:Denver}, \n//               Person{name:John,age:20,city:Chicago}], \n//    (30,John)=[Person{name:John,age:30,city:Denver}, \n//               Person{name:John,age:30,city:Seattle}]}\n\n```", "```java\nMap<String, Set<Person>> map = getStreamPerson()\n   .collect(Collectors.groupingBy(Person::getName, \n                                  Collectors.toSet()));\nSystem.out.println(map);  \n             //prints: {John=[Person{name:John,age:30}, \n             //               Person{name:John,age:20}], \n             //         Jill=[Person{name:Jill,age:20}]}\n\n```", "```java\nMap<String, Long> map = getStreamPerson()\n        .collect(Collectors.groupingBy(Person::getName, \n                                        Collectors.counting()));\nSystem.out.println(map);   //prints: {John=2, Jill=1}\n```", "```java\nStream.of(\"a\",\"b\",\"c\")\n      .map(s -> Function.identity()\n      .apply(s))\n      .forEach(System.out::print);  //prints: abc    \n```", "```java\nMap<Person, Long> map = Stream.of(new Person(30, \"John\"), \n                                  new Person(20, \"Jill\"), \n                                  new Person(30, \"John\"))\n        .collect(Collectors.groupingBy(Function.identity(), \n                                        Collectors.counting()));\nSystem.out.println(map);  //prints: {Person{name:Jill,age:20}=1, \n                          //         Person{name:John,age:30}=2}\n```", "```java\nMap<String, Double> map = getStreamPerson()\n        .collect(Collectors.groupingBy(Person::getName, \n                Collectors.averagingInt(Person::getAge)));\nSystem.out.println(map);  //prints: {John=25.0, Jill=20.0}\n```", "```java\nMap<String, List<Integer>> map = getStreamPerson()\n   .collect(Collectors.groupingBy(Person::getName, \n            Collectors.mapping(Person::getAge, \n                               Collectors.toList())));\nSystem.out.println(map);     \n                  //prints: {John=[30, 20], Jill=[20]}\n\n```", "```java\nMap<Integer, String> map = getStreamPerson()\n .collect(Collectors.groupingBy(Person::getAge, \n             Collectors.mapping(Person::getName, \n                            Collectors.joining(\",\"))));\nSystem.out.println(map);\n                     //prints: {20=Jill, John, 30=John}\n```", "```java\n\nMap<Integer, Map<String, String>> map = getStreamPerson2()\n  .collect(Collectors.groupingBy(Person2::getAge, \n           Collectors.groupingBy(Person2::getName, \n                  Collectors.mapping(Person2::getCity, \n                              Collectors.joining(\",\")))));\nSystem.out.println(map);  //prints: \n                          //   {20={John=Denver,Chicago, \n                          //        Jill=Seattle,Chicago}, \n                          //   30={John=Denver,Seattle}}\n```", "```java\nLinkedHashMap<String, Long> map = getStreamPerson()\n        .collect(Collectors.groupingBy(Person::getName, \n                                       LinkedHashMap::new, \n                                       Collectors.counting()));\nSystem.out.println(map);  //prints: {John=2, Jill=1}\n```", "```java\nEnumMap<City, List<Person3>> map = getStreamPerson3()\n        .collect(Collectors.groupingBy(Person3::getCity, \n                            () -> new EnumMap<>(City.class), \n                                      Collectors.toList()));\nSystem.out.println(map);  \n //prints: {Chicago=[Person{name:Jill,age:20,city:Chicago},  \n //                  Person{name:John,age:20,city:Chicago}], \n //          Denver=[Person{name:John,age:30,city:Denver}, \n //                  Person{name:John,age:20,city:Denver}], \n //         Seattle=[Person{name:Jill,age:20,city:Seattle}, \n //                  Person{name:John,age:30,city:Seattle}]}\n\n```", "```java\nEnumMap<City, Map<Integer, String>> map = getStreamPerson3()\n   .collect(Collectors.groupingBy(Person3::getCity, \n                   () -> new EnumMap<>(City.class), \n             Collectors.groupingBy(Person3::getAge, \n             Collectors.mapping(Person3::getName, \n                                Collectors.joining(\",\")))));\nSystem.out.println(map);  \n                       //prints: {Chicago={20=Jill,John}, \n                       //         Denver={20=John, 30=John}, \n                       //         Seattle={20=Jill, 30=John}}\n```", "```java\nConcurrentMap<String, List<Person>> map1 = \n   getStreamPerson().parallel()\n      .collect(Collectors.groupingByConcurrent(Person::getName));\nSystem.out.println(map1);  \n                     //prints: {John=[Person{name:John,age:30}, \n                     //               Person{name:John,age:20}], \n                     //         Jill=[Person{name:Jill,age:20}]}\n\nConcurrentMap<String, Double> map2 = \n   getStreamPerson().parallel()\n    .collect(Collectors.groupingByConcurrent(Person::getName,       \n                     Collectors.averagingInt(Person::getAge)));\nSystem.out.println(map2);      //prints: {John=25.0, Jill=20.0}\n\nConcurrentSkipListMap<String, Long> map3 = \n    getStreamPerson().parallel()\n       .collect(Collectors.groupingByConcurrent(Person::getName, \n           ConcurrentSkipListMap::new, Collectors.counting()));\nSystem.out.println(map3);        //prints: {Jill=1, John=2}\n\n```", "```java\nMap<Boolean, List<Person>> map = getStreamPerson()\n  .collect(Collectors.partitioningBy(p-> p.getName().contains(\"i\")));\nSystem.out.println(map);  //prints: {false=[Person{name:John,age:30}, \n                          //                Person{name:John,age:20}], \n                          //          true=[Person{name:Jill,age:20}]}\n```", "```java\nMap<Boolean, Long> map = getStreamPerson()\n  .collect(Collectors.partitioningBy(p-> p.getName().contains(\"i\"),  \n                                           Collectors.counting()));\nSystem.out.println(map);  //prints: {false=2, true=1}\n\n```", "```java\nMap<Boolean, List<Person>> map1 = getStreamPerson()\n   .collect(Collectors.groupingBy(p-> p.getName().contains(\"i\")));\nSystem.out.println(map); //prints: {false=[Person{name:John,age:30}, \n                          //               Person{name:John,age:20}], \n                          //         true=[Person{name:Jill,age:20}]}\n\nMap<Boolean, Long> map2 = getStreamPerson()\n     .collect(Collectors.groupingBy(p-> p.getName().contains(\"i\"),  \n                                          Collectors.counting()));\nSystem.out.println(map2);  //prints: {false=2, true=1}\n```", "```java\npublic interface Traffic {\n  void speedAfterStart(double timeSec, \n    int trafficUnitsNumber, SpeedModel speedModel, \n    BiPredicate<TrafficUnit, Double> limitTraffic,     \n    BiConsumer<TrafficUnit, Double> printResult);\n }\n```", "```java\ndouble timeSec = 10.0;\nint trafficUnitsNumber = 10;\n\nSpeedModel speedModel = (t, wp, hp) -> ...;\nBiConsumer<TrafficUnit, Double> printResults = (tu, sp) -> ...;\nBiPredicate<TrafficUnit, Double> limitSpeed = (tu, sp) -> ...;\n\nTraffic api = new TrafficImpl(Month.APRIL, DayOfWeek.FRIDAY, 17, \n                              \"USA\", \"Denver\", \"Main103S\");\napi.speedAfterStart(timeSec, trafficUnitsNumber, speedModel, \n                    limitSpeed, printResults);\n```", "```java\ndouble timeSec = 10.0;\nint trafficUnitsNumber = 10;\n\nSpeedModel speedModel = (t, wp, hp) -> ...;\nBiConsumer<TrafficUnit, Double> printResults = (tu, sp) -> ...;\nBiPredicate<TrafficUnit, Double> limitSpeed = (tu, sp) -> ...;\nList<TrafficUnit> trafficUnits = FactoryTraffic\n     .generateTraffic(trafficUnitsNumber, Month.APRIL, \n                      DayOfWeek.FRIDAY, 17, \"USA\", \"Denver\",\n                      \"Main103S\");\nfor(TrafficUnit tu: trafficUnits){\n  Vehicle vehicle = FactoryVehicle.build(tu);\n  vehicle.setSpeedModel(speedModel);\n  double speed = vehicle.getSpeedMph(timeSec);\n  speed = Math.round(speed * tu.getTraction());\n    if(limitSpeed.test(tu, speed)){\n      printResults.accept(tu, speed);\n    }\n  }\n```", "```java\nStream<TrafficUnit> stream = FactoryTraffic\n       .getTrafficUnitStream(trafficUnitsNumber, Month.APRIL,\n            DayOfWeek.FRIDAY, 17, \"USA\", \"Denver\", \"Main103S\");\n```", "```java\nStream<TrafficUnit>getTrafficUnitStream(int trafficUnitsNumber){\n  return FactoryTraffic.getTrafficUnitStream(trafficUnitsNumber,\n                       Month.APRIL, DayOfWeek.FRIDAY, 17, \"USA\", \n                                          \"Denver\", \"Main103S\");\n}\n```", "```java\ngetTrafficUnitStream(trafficUnitsNumber).map(tu -> {\n   Vehicle vehicle = FactoryVehicle.build(tu);\n   vehicle.setSpeedModel(speedModel);\n   return vehicle;\n})\n.map(v -> {\n   double speed = v.getSpeedMph(timeSec);\n   return Math.round(speed * tu.getTraction());\n})\n.filter(s -> limitSpeed.test(tu, s))\n.forEach(tuw -> printResults.accept(tu, s));\n```", "```java\nclass TrafficUnitWrapper {\n  private double speed;\n  private Vehicle vehicle;\n  private TrafficUnit trafficUnit;\n  public TrafficUnitWrapper(TrafficUnit trafficUnit){\n    this.trafficUnit = trafficUnit;\n  }\n  public TrafficUnit getTrafficUnit(){ return this.trafficUnit; }\n  public Vehicle getVehicle() { return vehicle; }\n  public void setVehicle(Vehicle vehicle) { \n    this.vehicle = vehicle; \n  }\n  public double getSpeed() { return speed; }\n  public void setSpeed(double speed) { this.speed = speed; }\n}\n```", "```java\ngetTrafficUnitStream(trafficUnitsNumber)\n  .map(TrafficUnitWrapper::new)\n  .map(tuw -> {\n       Vehicle vehicle = FactoryVehicle.build(tuw.getTrafficUnit());\n       vehicle.setSpeedModel(speedModel);\n       tuw.setVehicle(vehicle);\n       return tuw;\n   })\n  .map(tuw -> {\n       double speed = tuw.getVehicle().getSpeedMph(timeSec);\n       speed = Math.round(speed * tuw.getTrafficUnit().getTraction());\n       tuw.setSpeed(speed);\n       return tuw;\n  })\n  .filter(tuw -> limitSpeed.test(tuw.getTrafficUnit(),tuw.getSpeed()))\n  .forEach(tuw -> printResults.accept(tuw.getTrafficUnit(), \n                                                     tuw.getSpeed()));\n```", "```java\nclass TrafficUnitWrapper {\n  private double speed;\n  private Vehicle vehicle;\n  private TrafficUnit trafficUnit;\n  public TrafficUnitWrapper(TrafficUnit trafficUnit){\n    this.trafficUnit = trafficUnit;\n    this.vehicle = FactoryVehicle.build(trafficUnit);\n  }\n  public TrafficUnitWrapper setSpeedModel(SpeedModel speedModel) {\n    this.vehicle.setSpeedModel(speedModel);\n    return this;\n  }\n  pubic TrafficUnit getTrafficUnit(){ return this.trafficUnit; }\n  public Vehicle getVehicle() { return vehicle; }\n  public double getSpeed() { return speed; }\n  public TrafficUnitWrapper setSpeed(double speed) { \n    this.speed = speed;\n    return this; \n  }\n}\n```", "```java\ngetTrafficUnitStream(trafficUnitsNumber)\n  .map(TrafficUnitWrapper::new)\n  .map(tuw -> tuw.setSpeedModel(speedModel))\n  .map(tuw -> {\n       double speed = tuw.getVehicle().getSpeedMph(timeSec);\n       speed = Math.round(speed * tuw.getTrafficUnit().getTraction());\n       return tuw.setSpeed(speed);\n   })\n  .filter(tuw -> limitSpeed.test(tuw.getTrafficUnit(),tuw.getSpeed()))\n  .forEach(tuw -> printResults.accept(tuw.getTrafficUnit(), \n                                                     tuw.getSpeed()));\n```", "```java\nTrafficUnitWrapper calcSpeed(double timeSec) {\n   double speed = this.vehicle.getSpeedMph(timeSec);\n   this.speed = Math.round(speed * this.trafficUnit.getTraction());\n   return this;\n}\n```", "```java\ngetTrafficUnitStream(trafficUnitsNumber)\n   .map(TrafficUnitWrapper::new)\n   .map(tuw -> tuw.setSpeedModel(speedModel))\n   .map(tuw -> tuw.calcSpeed(timeSec))\n   .filter(tuw -> limitSpeed.test(tuw.getTrafficUnit(),\n                                                  tuw.getSpeed()))\n   .forEach(tuw -> printResults.accept(tuw.getTrafficUnit(),\n                                                  tuw.getSpeed()));\n```", "```java\nInteger[] trafficByLane(Stream<TrafficUnit> stream,\n       int trafficUnitsNumber, double timeSec, \n       SpeedModel speedModel, double[] speedLimitByLane) {\n   int lanesCount = speedLimitByLane.length;\n   Map<Integer, Integer> trafficByLane = stream\n     .limit(trafficUnitsNumber)\n     .map(TrafficUnitWrapper::new)\n     .map(tuw -> tuw.setSpeedModel(speedModel))\n     .map(tuw -> tuw.calcSpeed(timeSec))\n     .map(speed -> countByLane(lanesCount, \n                               speedLimitByLane, speed))\n     .collect(Collectors.groupingBy(CountByLane::getLane, \n           Collectors.summingInt(CountByLane::getCount)));\n   for(int i = 1; i <= lanesCount; i++){\n      trafficByLane.putIfAbsent(i, 0);\n   }\n   return trafficByLane.values()\n                       .toArray(new Integer[lanesCount]);\n}\n```", "```java\nprivate class CountByLane {\n  int count, lane;\n  private CountByLane(int count, int lane){\n    this.count = count;\n    this.lane = lane;\n  }\n  public int getLane() { return lane; }\n  public int getCount() { return count; }\n}\n```", "```java\nprivate static class TrafficUnitWrapper {\n  private Vehicle vehicle;\n  private TrafficUnit trafficUnit;\n  public TrafficUnitWrapper(TrafficUnit trafficUnit){\n    this.vehicle = FactoryVehicle.build(trafficUnit);\n    this.trafficUnit = trafficUnit;\n  }\n  public TrafficUnitWrapper setSpeedModel(SpeedModel speedModel) {\n    this.vehicle.setSpeedModel(speedModel);\n    return this;\n  }\n  public double calcSpeed(double timeSec) {\n    double speed = this.vehicle.getSpeedMph(timeSec);\n    return Math.round(speed * this.trafficUnit.getTraction());\n  }\n}\n```", "```java\nprivate CountByLane countByLane(int lanesNumber, \n                                   double[] speedLimit, double speed){\n  for(int i = 1; i <= lanesNumber; i++){\n     if(speed <= speedLimit[i - 1]){ \n        return new CountByLane(1, i);\n     }\n  }\n  return new CountByLane(1, lanesNumber);\n}\n```", "```java\nPredicate<TrafficUnit> limitTraffic = tu ->\n    tu.getVehicleType() == Vehicle.VehicleType.CAR\n    || tu.getVehicleType() == Vehicle.VehicleType.TRUCK;\n\ngetTrafficUnitStream(trafficUnitsNumber)\n   .filter(limitTraffic)\n   .map(TrafficUnitWrapper::new)\n   .map(tuw -> tuw.setSpeedModel(speedModel))\n   .map(tuw -> tuw.calcSpeed(timeSec))\n   .filter(tuw -> limitSpeed.test(tuw.getTrafficUnit(), \n                                            tuw.getSpeed()))\n   .forEach(tuw -> printResults.accept(tuw.getTrafficUnit(), \n                                           tuw.getSpeed()));\n```", "```java\nList.of(\"This \", \"is \", \"created \", \"by \",\n         \"List.of().stream()\").stream().forEach(System.out::print);\nSystem.out.println();\nList.of(\"This \", \"is \", \"created \", \"by \", \n          \"List.of().parallelStream()\")\n                      .parallelStream().forEach(System.out::print);\n```", "```java\nList<String> wordsWithI = new ArrayList<>();\nStream.of(\"That \", \"is \", \"a \", \"Stream.of(literals)\")\n      .parallel()\n      .filter(w -> w.contains(\"i\"))\n      .forEach(wordsWithI::add);\nSystem.out.println(wordsWithI);\nSystem.out.println();\n\nwordsWithI = Stream.of(\"That \", \"is \", \"a \", \"Stream.of(literals)\" )\n                   .parallel()\n                   .filter(w -> w.contains(\"i\"))\n                   .collect(Collectors.toList());\nSystem.out.println(wordsWithI);\n```"]