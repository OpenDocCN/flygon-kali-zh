- en: Chapter 9. Music Visualizer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 音乐可视化
- en: '*"See the music, hear the dance," said George Balanchine, famed Russian-born
    choreographer and father of the American ballet.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “'看音乐，听舞蹈'，”著名的俄罗斯裔编舞家、美国芭蕾舞之父乔治·巴兰钦说道。
- en: We won't attempt to raise the level of the art form, but still, maybe it'd be
    fun to visualize the playlists on our phones. In this project, we will create
    3D animated abstract graphics that dance to the beat of your music. You might
    be familiar with music visualizations in 2D, but what would it look like in VR?
    To get inspired, try Googling for images using the phrase *geometry wars*, the
    classic game for XBox, for example!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算提升艺术形式的水平，但或许将手机上的播放列表可视化会很有趣。在这个项目中，我们将创建3D动画抽象图形，以音乐的节奏起舞。您可能熟悉2D音乐可视化，但在VR中会是什么样子呢？要获得灵感，可以尝试使用短语*geometry
    wars*在Google上搜索图像，例如XBox的经典游戏！
- en: A visualizer app takes input from the Android audio system and displays visualizations.
    In this project, we will take advantage of the Android `Visualizer` class, which
    lets an app capture part of the currently playing audio, not the full fidelity
    music details but a lower quality audio content sufficient for visualizations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化应用程序从Android音频系统接收输入并显示可视化效果。在这个项目中，我们将利用Android的`Visualizer`类，让应用程序捕获当前播放音频的一部分，而不是完整的高保真音乐细节，而是足够进行可视化的低质量音频内容。
- en: 'In this project, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将：
- en: Set up the new project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新项目
- en: Build a Java class architecture named VisualizerBox
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建名为VisualizerBox的Java类架构
- en: Capture waveform data from the phone's audio player
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从手机音频播放器中捕获波形数据
- en: Build a geometric visualization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建几何可视化
- en: Build a texture-based visualization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于纹理的可视化
- en: Capture the FFT data and build an FFT visualization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获FFT数据并构建FFT可视化
- en: Add a trippy trails mode
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加迷幻轨迹模式
- en: Support multiple concurrent visualizations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个并发可视化
- en: The source code for this project can be found on the Packt Publishing website
    and on GitHub at [https://github.com/cardbookvr/visualizevr](https://github.com/cardbookvr/visualizevr)
    (with each topic as a separate commit).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的源代码可以在Packt Publishing网站和GitHub上找到，网址为[https://github.com/cardbookvr/visualizevr](https://github.com/cardbookvr/visualizevr)（每个主题作为单独的提交）。
- en: Setting up a new project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目
- en: 'To build this project, we''re going to use our RenderBox library created in
    [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You
    can use yours, or grab a copy from the downloadable files provided with this book
    or our GitHub repo (use the commit tagged `after-ch8`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch8](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch8)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final section, *Using RenderBox in future projects*, of [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. To create a new project, perform
    the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建此项目，我们将使用我们在[第5章](ch05.html "第5章 RenderBox引擎")中创建的RenderBox库，*RenderBox引擎*。您可以使用您自己的库，或者从本书提供的可下载文件或我们的GitHub存储库中获取副本（使用标记为`after-ch8`的提交
    - [https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch8](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch8)）。有关如何导入`RenderBox`库的更详细描述，请参阅[第5章](ch05.html
    "第5章 RenderBox引擎")的最后一节，*在未来项目中使用RenderBox*。要创建新项目，请执行以下步骤：
- en: With Android Studio opened, create a new project. Let's name it `VisualizeVR`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`VisualizeVR`，并针对**Android 4.4 KitKat (API
    19)**使用**空活动**。
- en: Create new modules for each of `renderbox`, `common`, and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`renderbox`、`common`和`core`包创建新模块，使用**文件**|**新建模块**|**导入.JAR/.AAR包**。
- en: Set the modules as dependencies for the app, using **File** | **Project Structure**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块设置为应用程序的依赖项，使用**文件**|**项目结构**。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[第2章](ch02.html "第2章 骨架硬纸板项目")中的说明编辑`build.gradle`文件，*骨架硬纸板项目*，以便编译针对SDK 22。
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，如前几章所述。
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainActivity`编辑为`class MainActivity extends CardboardActivity implements IRenderBox`，并实现接口方法存根（*Ctrl*
    + *I*）。
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续在`MainActivity`中定义`onCreate`方法。该类现在具有以下代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can add a cube to the scene, temporarily, to ensure that everything is
    set up properly. Add it to the `setup` method as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个立方体临时添加到场景中，以确保一切设置正确。将其添加到`setup`方法中，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you remember, a `Cube` is a `Component` that's added to a `Transform`. The
    `Cube` defines its geometry (for example, vertices). The `Transform` defines its
    position, rotation, and scale in 3D space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，`Cube`是添加到`Transform`的`Component`。`Cube`定义了其几何形状（例如，顶点）。`Transform`定义了其在3D空间中的位置、旋转和缩放。
- en: You should be able to click on **Run 'app'** with no compile errors, and see
    the cube and Cardboard split screen view on your Android device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在Android设备上单击**运行'app'**而没有编译错误，并看到立方体和硬纸板分屏视图。
- en: Capturing audio data
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获音频数据
- en: 'Using the Android `Visualizer` class ([http://developer.android.com/reference/android/media/audiofx/Visualizer.html](http://developer.android.com/reference/android/media/audiofx/Visualizer.html)),
    we can retrieve part of the audio data that is currently playing, at a specified
    sample rate. You can choose to capture data as waveform and/or frequency data:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android的`Visualizer`类（[http://developer.android.com/reference/android/media/audiofx/Visualizer.html](http://developer.android.com/reference/android/media/audiofx/Visualizer.html)），我们可以以指定的采样率检索当前播放的音频数据的一部分。您可以选择捕获波形和/或频率数据：
- en: '**Waveform**: This is an array of mono audio waveform bytes, or **pulse code
    modulation** (**PCM**) data, representing a sample series of audio amplitudes'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**波形**：这是表示音频振幅采样系列的单声道音频波形字节数组，或**脉冲编码调制**（**PCM**）数据'
- en: '**Frequency**: This is an array of **Fast Fourier Transform** (**FFT**) bytes,
    representing a sampling of audio frequencies'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：这是表示音频频率采样的**快速傅立叶变换**（**FFT**）字节数组'
- en: The data is limited to 8 bits, so it's not useful for playback but is sufficient
    for visualizations. You can specify the sampling rate, although it must be a power
    of two.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据限制为8位，因此对于播放而言并不有用，但对于可视化来说足够了。您可以指定采样率，尽管它必须是2的幂。
- en: Armed with this knowledge, we'll now go ahead and begin implementing an architecture
    that captures audio data and makes it available to visualization renderers that
    you can build.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，我们现在将继续实施一个架构，捕获音频数据并使其可用于您可以构建的可视化渲染器。
- en: A VisualizerBox architecture
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VisualizerBox架构
- en: Music visualizers often look really cool, especially at first. But after a time
    they may seem too repetitive, even boring. Therefore, in our design, we'll build
    the ability to queue up a number of different visualizations, and then, after
    a period of time, transition from one to the next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐可视化器通常看起来非常酷，尤其是一开始。但是一段时间后，它们可能会显得太重复，甚至无聊。因此，在我们的设计中，我们将构建一个能够排队一些不同可视化的能力，然后在一段时间后从一个切换到另一个。
- en: To begin our implementation, we'll define an architecture structure that will
    be expandable and let us develop new visualizations as we go along.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的实施，我们将定义一个可扩展的架构结构，让我们在开发新的可视化时能够扩展。
- en: 'However, even before that, we must ensure that the app has permission to use
    the Android audio features we need. Add the following directives to `AndroidManifest.xml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在那之前，我们必须确保应用程序有权限使用我们需要的Android音频功能。将以下指令添加到`AndroidManifest.xml`中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that the `RenderBox` library, first developed in [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine,* allows `MainActivity` to delegate
    much of the graphics and Cardboard VR work to the `RenderBox` class and associated
    classes (`Component`, `Material`, and so on). We will follow a similar design
    pattern here, built on top of `RenderBox`. `MainActivity` can instantiate specific
    visualizations and then delegate the work to the `VisualizerBox` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`RenderBox`库最初是在[第5章](ch05.html "第5章。RenderBox引擎")中开发的，*RenderBox引擎*，允许`MainActivity`将大部分图形和Cardboard
    VR工作委托给`RenderBox`类和相关类（`Component`，`Material`等）。我们将在此基础上构建一个类似的设计模式，建立在`RenderBox`之上。`MainActivity`可以实例化特定的可视化，然后将工作委托给`VisualizerBox`类。
- en: 'The `VisualizerBox` class will provide the callback functions to the Android
    `Visualizer` class. Let''s define a skeletal implementation of this first. Create
    a `VisualizerBox` Java class, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualizerBox`类将提供回调函数给Android的`Visualizer`类。让我们首先定义这个的骨架实现。创建一个`VisualizerBox`Java类，如下所示：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Integrate `VisualizerBox` into `MainActivity`, adding a `visualizerBox` variable
    at the top of the class. In `MainActivity`, add the following line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将`VisualizerBox`集成到`MainActivity`中，在类的顶部添加一个`visualizerBox`变量。在`MainActivity`中，添加以下行：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Initialize it in `onCreate`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中进行初始化：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, in `MainActivity`, call the corresponding version of each of the `IRenderBox`
    interface methods:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`MainActivity`中，调用每个`IRenderBox`接口方法的相应版本：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Good. Now we''ll set up `VisualizerBox` to let you build and use one or more
    visualizations. So, first let''s define the abstract `Visualization` class in
    the `Visualization.java` file, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在我们将设置`VisualizerBox`，让您构建和使用一个或多个可视化。因此，首先让我们在`Visualization.java`文件中定义抽象的`Visualization`类，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we have a mechanism to create a variety of visualization implementations
    for the app. Before we go ahead and start writing one of those, let''s also provide
    the integration with `VisualizerBox`. At the top of the `VisualizerBox` class,
    add a variable to the current `activeViz` object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个机制来为应用程序创建各种可视化实现。在我们继续编写其中一个之前，让我们还提供与`VisualizerBox`的集成。在`VisualizerBox`类的顶部，添加一个变量到当前的`activeViz`对象：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, call it from the interface methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从接口方法中调用它：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Of course, we're not even using the Android `Visualizer` class yet and not rendering
    anything on the screen. That'll come next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们甚至还没有使用Android的`Visualizer`类，也没有在屏幕上渲染任何东西。接下来会有。
- en: 'For now, let''s create a placeholder for a visualization. Create a new folder
    in your project named `visualizations`. Right-click on your Java code folder (for
    example, `java/com/cardbookvr/visualizevr/`), go to **New** | **Package**, and
    name it `visualizations`. Then, right click on the new `visualizations` folder,
    go to **New** | **Java Class**, and name it `BlankVisualization`. Then, define
    it as `extends Visualization` as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为可视化创建一个占位符。在项目中创建一个名为`visualizations`的新文件夹。右键单击您的Java代码文件夹（例如`java/com/cardbookvr/visualizevr/`），转到**新建**
    | **包**，并将其命名为`visualizations`。然后，右键单击新的`visualizations`文件夹，转到**新建** | **Java类**，并将其命名为`BlankVisualization`。然后，将其定义为`extends
    Visualization`，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll be able to use this as a template for specific visualizers. The purpose
    of each method is pretty self-explanatory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够将其用作特定可视化器的模板。每种方法的目的都相当不言自明：
- en: '`setup`: This initializes variables, transforms, and materials for the visualization'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`：这个方法初始化可视化的变量、转换和材料'
- en: '`preDraw`: This code is executed at the beginning of each frame; for example,
    using the current captured audio data'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preDraw`：此代码在每帧开始时执行；例如，使用当前捕获的音频数据'
- en: '`postDraw`: This code is executed at the end of each frame'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postDraw`：此代码在每帧结束时执行'
- en: Now let's add some meat to this skeleton.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给这个骨架添加一些内容。
- en: Waveform data capture
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 波形数据捕获
- en: 'As mentioned earlier, the Android `Visualizer` class lets us define callbacks
    to capture audio data. This data comes in two formats: waveform and FFT. We''ll
    add just the waveform data to the `VisualizerBox` class now.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Android的`Visualizer`类让我们定义回调来捕获音频数据。这些数据有两种格式：波形和FFT。我们现在将仅添加波形数据到`VisualizerBox`类中。
- en: 'First, define the variables that we''ll use for the captured audio data, as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义我们将用于捕获音频数据的变量，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the API, we can determine the minimum capture size available, and then
    use that as our capture sample size.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API，我们可以确定可用的最小捕获大小，然后将其用作我们的捕获样本大小。
- en: 'Then, initialize them in the constructor as follows. First, instantiate an
    Android `Visualizer`. Then set the capture size to use, and allocate our buffers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中初始化它们如下。首先，实例化一个Android`Visualizer`。然后设置要使用的捕获大小，并分配我们的缓冲区：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We want to use the minimum size for a variety of reasons. Firstly, it will be
    faster, and in VR, speed is paramount. Secondly, it organizes our FFT samples
    (as discussed later) into fewer buckets. This is helpful because each bucket catches
    more activity over a broader range of frequencies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望出于各种原因使用最小尺寸。首先，它会更快，而在虚拟现实中，速度至关重要。其次，它将我们的FFT样本（稍后讨论）组织成更少的桶。这很有帮助，因为每个桶可以在更广泛的频率范围内捕捉更多的活动。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we left a comment where we'll define the capture listener, and then
    set it in the visualizer. Make sure that you enable the visualizer as always listening.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在定义捕获监听器的地方留下了一个注释，然后在可视化器中设置它。确保你启用了可视化器作为始终监听。
- en: 'Let''s first write the `captureListener` object for waveform data only. We
    define and instantiate a new anonymous class that implements `Visualizer.OnDataCaptureListener`,
    and provide it with a function named `onWaveFormDataCapture`, which receives the
    wave form bytes and stores them for our `Visualization` code (forthcoming):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写仅用于波形数据的`captureListener`对象。我们定义并实例化一个实现`Visualizer.OnDataCaptureListener`的新匿名类，并为其提供一个名为`onWaveFormDataCapture`的函数，该函数接收波形字节并将其存储到我们的`Visualization`代码中（即将推出）：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interface still requires that we provide an `onFftDataCapture` method, but
    we're leaving it empty for the time being.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 界面仍然要求我们提供一个`onFftDataCapture`方法，但我们暂时将其留空。
- en: Now we're ready to add some graphics to this baby.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备为这个项目添加一些图形。
- en: A basic geometric visualization
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基本的几何可视化
- en: For our first visualization, we'll create a basic equalizer wave graphic. It'll
    be a rectangular block consisting of a series of cubes that are scaled according
    to the audio waveform data. We'll use the built-in `Cube` component already in
    the `RenderBox` library and its basic vertex color lighting material.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个可视化，我们将创建一个基本的均衡器波形图形。它将是一个由一系列根据音频波形数据进行缩放的立方体组成的矩形块。我们将使用内置的`Cube`组件，已经在`RenderBox`库中的基本顶点颜色照明材质。
- en: 'In the `visualizations/` folder, create a new Java class named `GeometricVisualization`
    and begin as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`visualizations/`文件夹中，创建一个名为`GeometricVisualization`的新的Java类，并开始如下：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the top of the class, declare a `Transform` array of cube transforms and
    the corresponding array for `RenderObjects`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的顶部，声明一个立方体变换的`Transform`数组和相应的`RenderObjects`数组：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, initialize them in the `setup` method. We''ll allocate the array of cubes,
    aligned and scaled as an adjacent set of blocks, creating a 3D representation
    of a wavy block. The setup method can be implemented as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`setup`方法中初始化它们。我们将分配立方体数组，对齐并缩放为相邻的一组块，创建一个波浪状块的3D表示。`setup`方法可以实现如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now on each frame, we just need to modify the height of each cube based on
    the current waveform data from the audio source (as obtained in `VisualizerBox`).
    Implement the `preDraw` method as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在每一帧上，我们只需要根据音频源中当前的波形数据（在`VisualizerBox`中获取）修改每个立方体的高度。实现`preDraw`方法如下：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also need to add a stub for the `postDraw` implementation. Then, instantiate
    the visualization and make it the active one. In `MainActivity`, at the end of
    `onCreate`, add the following line of code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`postDraw`实现添加一个存根。然后，实例化可视化并使其成为活动状态。在`MainActivity`中，在`onCreate`的末尾，添加以下代码行：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's all we need for now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要这些。
- en: 'Start playing some music on your phone. Then, run the app. You will see something
    like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机上播放一些音乐。然后运行应用程序。你会看到类似这样的东西：
- en: '![A basic geometric visualization](img/B05144_09_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![基本几何可视化](img/B05144_09_01.jpg)'
- en: As you can see, we kept the unit cube in the scene, as it helps clarify what's
    going on. Each audio datum is a thin "slice" (or a flattened cube) the height
    of which varies with the audio value. If you're looking at a colored version of
    the preceding screen image, you will notice that the colored faces of the visualization
    cubes are like solitary cubes since they use the same object and material to render.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在场景中保留了单位立方体，因为它有助于澄清发生了什么。每个音频数据都是一个薄的“切片”（或者是一个扁平的立方体），其高度随音频值的变化而变化。如果你正在查看前一个屏幕图像的彩色版本，你会注意到可视化立方体的彩色面就像孤立的立方体，因为它们使用相同的对象和材质进行渲染。
- en: This visualization is a very basic example of using audio waveform data to dynamically
    modify 3D geometry. Let your imagination run wild to create your own. The audio
    bytes can control any transform parameters, including scale, position, and rotation.
    Remember that we're in a 3D virtual reality space, and you can use all of it—move
    your stuff all round, up and down, and even behind you. We have a few basic primitive
    geometric shapes (a cube, sphere, plane, triangle, and so on). But you can also
    use the audio data to parametrically generate new shapes and models. Plus, you
    can even integrate the `ModelObject` class from the previous chapter to load interesting
    3D models!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化是使用音频波形数据动态修改3D几何的一个非常基本的例子。让你的想象力奔放，创造属于你自己的。音频字节可以控制任何变换参数，包括比例、位置和旋转。记住我们在一个3D虚拟现实空间中，你可以使用所有这些——把你的东西四处移动，上下移动，甚至在你的身后。我们有一些基本的原始几何形状（立方体、球体、平面、三角形等）。但你也可以使用音频数据来参数化生成新的形状和模型。此外，你甚至可以集成前一章的`ModelObject`类来加载有趣的3D模型！
- en: In the next topic, we'll take a look at how to use the audio waveform data in
    texture-based material shaders.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将看看如何在基于纹理的材质着色器中使用音频波形数据。
- en: 2D texture-based visualization
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于2D纹理的可视化
- en: The second visualization will also be a basic oscilloscope-type display of waveform
    data. However, previously, we used audio data to scale 3D slice cubes; this time,
    we'll render them all on a 2D plane using a shader that uses audio data as input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可视化也将是基本的示波器类型显示波形数据。然而，以前我们使用音频数据来缩放3D切片立方体；这一次，我们将使用一个着色器，在2D平面上渲染它们全部，使用音频数据作为输入。
- en: Our `RenderBox` library allows us to define new materials and shaders. In the
    previous projects, we built materials that use bitmap images for texture mapping
    onto the geometry as it's rendered. In this project, we'll paint the quad using
    the audio bytes array, using the byte value to control the position where we set
    a brighter color. (Note that the `Plane` class was added to `RenderBox` lib in
    [Chapter 7](ch07.html "Chapter 7. 360-Degree Gallery"), *360-Degree Gallery*.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`RenderBox`库允许我们定义新的材质和着色器。在以前的项目中，我们构建了使用位图图像进行纹理映射的材质，以便在渲染时将其渲染到几何图形上。在这个项目中，我们将使用音频字节数组来绘制四边形，使用字节值来控制设置更亮颜色的位置。（请注意，`Plane`类是在[第7章](ch07.html
    "第7章。360度画廊")中添加到`RenderBox`库中的，*360度画廊*。）
- en: Texture generator and loader
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理生成器和加载器
- en: 'First, let''s generate a texture structure to hold our texture data. In the
    `VisualizerBox` class, add the following method to set up the texture in GLES.
    We can''t use our normal texture pipeline, since it is designed to allocate a
    texture directly from image data. Our data is one-dimensional, so it may seem
    odd to use a `Texture2D` resource, but we''ll set the height to one pixel:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们生成一个纹理结构来保存我们的纹理数据。在`VisualizerBox`类中，添加以下方法来设置GLES中的纹理。我们不能使用我们正常的纹理流程，因为它是设计为直接从图像数据中分配纹理。我们的数据是一维的，所以使用`Texture2D`资源可能看起来有点奇怪，但我们将高度设置为一个像素：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then add the call to `setup`, including a static variable to hold the generated
    texture handle:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`setup`的调用，包括一个静态变量来保存生成的纹理句柄：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can populate the texture from audio byte data. In the Android `Visualizer`
    listener, add a call to `loadTexture` in the `onWaveFormDataCapture` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从音频字节数据中填充纹理。在Android的`Visualizer`监听器中，在`onWaveFormDataCapture`方法中添加一个`loadTexture`的调用：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's define `loadTexture` as follows. It copies the audio bytes into a new
    array buffer and hands it off to OpenGL ES with the `glBindTexture` and `glTexImage2D`
    calls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式定义`loadTexture`。它将音频字节复制到一个新的数组缓冲区，并将其传递给OpenGL ES，使用`glBindTexture`和`glTexImage2D`调用。
- en: '(Refer to [http://stackoverflow.com/questions/14290096/how-to-create-a-opengl-texture-from-byte-array-in-android](http://stackoverflow.com/questions/14290096/how-to-create-a-opengl-texture-from-byte-array-in-android).):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （参考[http://stackoverflow.com/questions/14290096/how-to-create-a-opengl-texture-from-byte-array-in-android](http://stackoverflow.com/questions/14290096/how-to-create-a-opengl-texture-from-byte-array-in-android)。）：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Waveform shaders
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 波形着色器
- en: Now it's time to write the shader programs that, among other things, will dictate
    the parameters and attributes that need to be set in the `Material` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写着色器程序了，这些程序将决定在`Material`类中需要设置的参数和属性，以及其他内容。
- en: If necessary, create a resources directory for the shaders, `res/raw/`. Then,
    create the `waveform_vertex.shader` and `waveform_fragment.shader` files. Define
    them as follows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，为着色器创建一个资源目录，`res/raw/`。然后，创建`waveform_vertex.shader`和`waveform_fragment.shader`文件。定义如下。
- en: The `waveform_vertex.shader` file is identical to the `unlit_tex_vertex` shader
    we were using. Strictly speaking, we can just reuse this file and specify its
    resource in the `createProgram` function, but it is good practice to define individual
    shader files unless you are explicitly following some sort of a pattern where
    you are using a number of variants on a given shader.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`waveform_vertex.shader`文件与我们之前使用的`unlit_tex_vertex`着色器相同。严格来说，我们可以重用这个文件，并在`createProgram`函数中指定它的资源，但是除非你明确遵循某种模式，否则最好定义单独的着色器文件。'
- en: 'File: `res/raw/waveform_vertex.shader`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/waveform_vertex.shader`：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For the `waveform_fragment` shader, we add variables for a solid color (`u_Color`)
    and threshold width (`u_Width`). And then, add a bit of logic to decide whether
    the *y* coordinate of the current pixel being rendered is within `u_Width` of
    the sample.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`waveform_fragment`着色器，我们添加了一个固定颜色（`u_Color`）和阈值宽度（`u_Width`）的变量。然后，添加一些逻辑来决定当前正在渲染的像素的*y*坐标是否在样本的`u_Width`范围内。
- en: 'File: `res/raw/waveform_fragment.shader`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/waveform_fragment.shader`
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Basic waveform material
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本波形材质
- en: 'Now we define the `Material` class for the shaders. Create a new Java class
    named `WaveformMaterial` and define it as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为着色器定义`Material`类。创建一个名为`WaveformMaterial`的新的Java类，并将其定义如下：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add material variables for the texture ID, border, width, and color. Then,
    add variables for the shader program reference and buffers, as shown in the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为纹理ID、边框、宽度和颜色添加材质变量。然后，添加着色器程序引用和缓冲区的变量，如下所示：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can add a constructor. As we saw earlier, it calls a `setupProgram`
    helper method that creates the shader program and obtains references to its parameters:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个构造函数。正如我们之前看到的，它调用了一个`setupProgram`辅助方法，该方法创建着色器程序并获取对其参数的引用：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Likewise, we add a `setBuffers` method to be called by the `RenderObject` component
    (`Plane`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们添加一个`setBuffers`方法，供`RenderObject`组件（`Plane`）调用：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the `draw` code, which will be called from the `Camera` component, to render
    the geometry prepared in the buffers (via `setBuffers`). The `draw` method looks
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`draw`代码，它将从`Camera`组件中调用，以渲染在缓冲区中准备的几何图形（通过`setBuffers`）。`draw`方法如下所示：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'One more thing; let''s provide a method to destroy an existing material:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事；让我们提供一个销毁现有材质的方法：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Waveform visualization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 波形可视化
- en: 'Now we can create a new visualization object. Under the `visualizations/` folder,
    create a new Java class named `WaveformVisualization` and define it as `extends
    Visualization`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的可视化对象。在`visualizations/`文件夹下，创建一个名为`WaveformVisualization`的新的Java类，并将其定义为`extends
    Visualization`：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare a variable for the `Plane` component we will create:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 声明我们将要创建的`Plane`组件的变量：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create it in the `setup` method as follows. Set the material to a new `WaveformMaterial`,
    and position it over towards the left:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中创建如下。将材质设置为新的`WaveformMaterial`，并将其位置设置为靠左：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now in `onCreate` of `MainActivity`, replace the previous visualization with
    this one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MainActivity`的`onCreate`中，用这个替换以前的可视化：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you run the project, you get a visualization like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行项目时，您会得到这样的可视化：
- en: '![Waveform visualization](img/B05144_09_02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![波形可视化](img/B05144_09_02.jpg)'
- en: FFT visualization
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFT可视化
- en: For the next visualization, we'll introduce the use of FFT data (instead of
    waveform data). As in the previous example, we'll dynamically generate a texture
    from the data and write a material and shaders to render it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个可视化，我们将引入使用FFT数据（而不是波形数据）。与前一个示例一样，我们将从数据动态生成纹理，并编写材质和着色器来渲染它。
- en: Capture the FFT audio data
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获FFT音频数据
- en: 'To begin with, we need to add that data capture to our `VisualizerBox` class.
    We will start by adding the variables we''ll need:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将数据捕获添加到我们的`VisualizerBox`类中。我们将首先添加我们需要的变量：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to allocate the FFT data arrays, and to do that we need to know their
    size. We can ask the Android `Visualizer` API how much data it''s capable of giving
    us. For now, we''ll choose the minimum size and then allocate the arrays as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分配FFT数据数组，并且为此我们需要知道它们的大小。我们可以询问Android `Visualizer` API它能够给我们多少数据。现在，我们将选择最小的大小，然后分配数组如下：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Capturing FFT data is similar to capturing waveform data. But we''ll do some
    preprocessing on it before saving it. According to the Android `Visualizer` API
    documentation, ([http://developer.android.com/reference/android/media/audiofx/Visualizer.html#getFft(byte[]](http://developer.android.com/reference/android/media/audiofx/Visualizer.html#getFft(byte[]))
    the `getFfT` function provides data specified as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获FFT数据类似于捕获波形数据。但是在保存之前，我们将对其进行一些预处理。根据Android `Visualizer` API文档，([http://developer.android.com/reference/android/media/audiofx/Visualizer.html#getFft(byte[]](http://developer.android.com/reference/android/media/audiofx/Visualizer.html#getFft(byte[]))
    `getFfT`函数提供以下指定的数据：
- en: The capture is an 8-bit magnitude FFT; the frequency range covered being 0 (DC)
    to half of the sampling rate returned by `getSamplingRate()`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获是8位幅度FFT；覆盖的频率范围是0（DC）到`getSamplingRate()`返回的采样率的一半
- en: The capture returns the real and imaginary parts of a number of frequency points
    equal to half of the capture size plus one
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获返回与捕获大小的一半加一相等的频率点的实部和虚部
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that only the real part is returned for the first point (DC) and the last
    point (*sampling frequency/2*).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有实部返回给第一个点（DC）和最后一个点（*采样频率/2*）。
- en: 'The layout in the returned byte array is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字节数组中的布局如下：
- en: '*n* is the capture size returned by `getCaptureSize()`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*是`getCaptureSize()`返回的捕获大小'
- en: '`Rfk` and `Ifk` are the real and imaginary parts of the *kth* frequency component,
    respectively'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rfk`和`Ifk`分别是第*k*频率分量的实部和虚部'
- en: 'If `Fs` is the sampling frequency returned by `getSamplingRate()`, the *kth*
    frequency is: *(k*Fs)/(n/2)*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Fs`是`getSamplingRate()`返回的采样频率，则第*k*频率为：*(k*Fs)/(n/2)*
- en: 'Likewise, we''ll prepare the incoming captured data into a normalized array
    of values between 0 and 255\. Our implementation is as follows. Add the `onFftDataCapture`
    declaration immediately after the `onWaveFormDataCapture` method (within the `OnDataCaptureListener`
    instance):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将把传入的捕获数据准备成一个在0到255之间的归一化值数组。我们的实现如下。在`OnDataCaptureListener`实例中的`onWaveFormDataCapture`方法之后立即添加`onFftDataCapture`声明：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that our algorithm uses a `MIN_THRESHOLD` value of 1.5 to filter out insignificant
    values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的算法使用`MIN_THRESHOLD`值为1.5来过滤掉不重要的值：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now in `setup()`, initialize `fftTexture` with a generated texture, as we do
    for the `audioTexture` variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`setup()`中，用生成的纹理初始化`fftTexture`，就像我们对`audioTexture`变量做的那样：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: FFT shaders
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFT着色器
- en: Now we need to write the shader programs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写着色器程序。
- en: If necessary, create a resources directory for the shaders, `res/raw/`. The
    `fft_vertex.shader` is identical to the `waveform_vertext.shader` created earlier,
    so you can just duplicate it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，为着色器创建一个资源目录`res/raw/`。`fft_vertex.shader`与之前创建的`waveform_vertext.shader`相同，因此可以直接复制它。
- en: For the `fft_fragment` shader, we add a bit of logic to decide whether the current
    coordinate is being rendered. In this case, we are not specifying a width and
    just rendering all pixels below the value. One way to look at the difference is
    that our waveform shader is a line graph (well, actually a scatterplot), and our
    FFT shader is a bar graph.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`fft_fragment`着色器，我们添加了一些逻辑来决定当前坐标是否正在渲染。在这种情况下，我们没有指定宽度，只是渲染所有低于该值的像素。从某种角度来看，我们的波形着色器是一条线图（实际上是一个散点图），而我们的FFT着色器是一个条形图。
- en: 'File: `res/raw/fft_fragment.shader`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/fft_fragment.shader`
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Basic FFT material
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本FFT材质
- en: The code for the `FFTMaterial` class is very similar to what we did for the
    `WaveformMaterial` class. So for brevity, just duplicate that file into a new
    one named `FFTMaterial.java`. And then, modify it as follows.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFTMaterial`类的代码与`WaveformMaterial`类的代码非常相似。因此，为了简洁起见，只需将该文件复制到一个名为`FFTMaterial.java`的新文件中。然后，修改如下。'
- en: 'Ensure that the class name and constructor method name now read as `FFTMaterial`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类名和构造方法名称现在读作`FFTMaterial`：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We decided to change the `borderColor` array to a different hue:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将`borderColor`数组更改为不同的色调：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `setupProgram`, ensure that you''re referencing the `R.raw.fft_vertex` and
    `R.raw.fft_fragment` shaders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setupProgram`中，确保您引用了`R.raw.fft_vertex`和`R.raw.fft_fragment`着色器：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, make sure that the appropriate shader-specific parameters are getting
    set. These shaders use `u_Color` (but not a `u_Width` variable):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保正在设置适当的特定于着色器的参数。这些着色器使用`u_Color`（但没有`u_Width`变量）：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, in the `draw` method, we''re going to draw with the `VisualizerBox.fftTexture`
    value (instead of `VisualizerBox.audioTexture`), so change the call to `GLES20.glBindTexture`
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`draw`方法中，我们将使用`VisualizerBox.fftTexture`值进行绘制（而不是`VisualizerBox.audioTexture`），因此将调用`GLES20.glBindTexture`更改如下：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Ensure that the `colorParam` parameter is set (but unlike the `WaveformMaterial`
    class, there is no width parameter here):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`colorParam`参数已设置（但与`WaveformMaterial`类不同，这里没有宽度参数）：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: FFT visualization
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFT可视化
- en: 'We can now add the visualization for the FFT data. In the `visualizations/`
    folder, duplicate the `WaveformVisualization.java` file into a new file named
    `FFTVisualization.java`. Ensure that it''s defined as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为FFT数据添加可视化。在`visualizations/`文件夹中，将`WaveformVisualization.java`文件复制到一个名为`FFTVisualization.java`的新文件中。确保它定义如下：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In its `setup` method, we''ll create a `Plane` component and texture it with
    the `FFTMaterial` class like this, (also note modifying the position and rotation
    values):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在它的`setup`方法中，我们将创建一个`Plane`组件，并使用`FFTMaterial`类对其进行纹理处理，如下所示（还要注意修改位置和旋转值）：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now in `onCreate` of `MainActivity`, replace the previous visualization with
    this one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MainActivity`的`onCreate`中，用这个替换以前的可视化：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you run the project, we get a visualization like this, rotated and positioned
    over to the right:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个项目时，我们得到了一个像这样的可视化，旋转并定位到右边：
- en: '![FFT visualization](img/B05144_09_03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![FFT可视化](img/B05144_09_03.jpg)'
- en: This simple example illustrates that FFT data separates spatial frequencies
    of the audio into discrete data values. Even without understanding the underlying
    mathematics (which is nontrivial), it's often sufficient to know that the data
    changes and flows in sync with the music. We used it here to drive a texture map.
    FFT can also be used like we used waveform data in the first example to drive
    attributes of 3D objects in the scene, including position, scale, and rotation,
    as well as parametrically defined geometry. In fact, it is generally a better
    data channel for such purposes. Each bar corresponds to an individual frequency
    range, so you can specify certain objects to respond to high frequencies versus
    low frequencies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了FFT数据将音频的空间频率分离成离散的数据值。即使不理解底层的数学（这是非常复杂的），通常只需要知道数据随着音乐的变化和流动。我们在这里使用它来驱动纹理映射。FFT也可以像我们在第一个例子中使用波形数据一样，用来驱动场景中3D对象的属性，包括位置、比例和旋转，以及参数化定义的几何形状。事实上，它通常是更好的数据通道。每个条形图对应一个单独的频率范围，因此您可以指定某些对象对高频率和低频率做出响应。
- en: Trippy trails mode
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迷幻轨迹模式
- en: 'If you are craving hallucinogenic simulations, we''ll introduce a "trippy trails
    mode" to our visualizations! The implementation is added to the `RenderBox` library
    itself. If you''re using the completed `RenderBox` library, then just toggle on
    the mode in your app. For example, in `setup()` of `MainActivity`, add the following
    line of code at the end:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渴望致幻的模拟，我们将在我们的可视化中引入一个“迷幻轨迹模式”！这个实现被添加到了`RenderBox`库本身。如果你正在使用已完成的`RenderBox`库，那么只需在你的应用程序中切换到这个模式。例如，在`MainActivity`的`setup()`中，在最后添加以下代码行：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To implement it in your copy of `RenderBox` library, open that project (in
    Android Studio). In the `Camera` class (the `components/Camera.java` file), add
    `public boolean trailsMode`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的`RenderBox`库的副本中实现它，打开Android Studio中的那个项目。在`Camera`类（`components/Camera.java`文件）中添加`public
    boolean trailsMode`：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, in `onDrawEye`, instead of erasing the screen for the new frame, we''ll
    draw a full screen quad over the entire frame, with alpha transparency, thus leaving
    behind a ghostly faded image of the last frame. Every subsequent frame is overdrawn
    by more semi-transparent black, causing them to fade out over time. Define a color
    value as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onDrawEye`中，我们不再擦除新帧的屏幕，而是在整个帧上绘制一个全屏四边形，带有alpha透明度，从而留下上一帧的幽灵般的淡化图像。每个后续帧都会被更多的半透明黑色覆盖，导致它们随着时间的推移而淡出。定义颜色值如下：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, modify `onDrawEye`, so it reads as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`onDrawEye`，使其如下所示：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `customClear` method skips the clear call, leaving behind the colors from
    the previous frame. Instead, it just draws a semitransparent full-screen black
    quad with transparency, slightly darkening the "old" image each frame. Before
    we can do this, the camera needs a shader program to draw the full screen solid
    color.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`customClear`方法跳过清除调用，保留上一帧的颜色。相反，它只是绘制一个半透明的全屏黑色四边形，略微变暗每一帧的“旧”图像。在我们这样做之前，相机需要一个着色器程序来绘制全屏的纯色。'
- en: '`fullscreen_solid_color_vertex.shader` is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullscreen_solid_color_vertex.shader` 如下所示：'
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`fullscreen_solid_color_fragment.shader` is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullscreen_solid_color_fragment.shader` 如下所示：'
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now back to the `Camera` component. We set up the program and define a full
    screen quad mesh, buffers, and other variables. First, we define the variables
    we''ll need:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`Camera`组件。我们设置程序并定义一个全屏四边形网格，缓冲区和其他变量。首先，我们定义我们需要的变量：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, define a method to set up the program:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义一个设置程序的方法：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define a method to allocate the buffers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个分配缓冲区的方法：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, call these from the `Camera` initializer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`Camera`初始化器中调用这些方法：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we can implement the `customClear` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`customClear`方法：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Rebuild the `RenderBox` module and copy the library file back to this `VisualizeVR`
    project. Don’t forget to set `trailsMode` to `true`!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建`RenderBox`模块，并将库文件复制回`VisualizeVR`项目。不要忘记将`trailsMode`设置为`true`！
- en: Now when you run the app, it looks trippy and cool!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行这个应用程序时，它看起来很迷幻和酷！
- en: '![Trippy trails mode](img/B05144_09_04.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![迷幻轨迹模式](img/B05144_09_04.jpg)'
- en: Multiple simultaneous visualizations
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个同时的可视化
- en: Now that we have a collection of visualizations, we can enhance the app to run
    more than one at a time and switch between them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一系列的可视化，我们可以增强应用程序，使其能够同时运行多个可视化，并在它们之间进行切换。
- en: 'To support multiple concurrent visualizations, replace the `activeViz` variable
    in `VisualizerBox` with a list of `visualizations`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个并发的可视化，用`visualizations`列表替换`VisualizerBox`中的`activeViz`变量。
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, cycle through the list in each of the `VisualizerBox` method that use
    it. We always want to set up all of them, but then only draw (`preDraw`, `postDraw`)
    the active ones:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在使用它的每个`VisualizerBox`方法中循环列表。我们总是希望设置所有这些，但只绘制（`preDraw`，`postDraw`）活动的可视化：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can control the scene in `MainActivity`. Modify the `MainActivity` class''s
    `onCreate` method to populate the `visualizations` list, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`MainActivity`中控制场景。修改`MainActivity`类的`onCreate`方法来填充`visualizations`列表，如下所示：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Run the project and we have a 3D scene full of visualizations!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，我们有一个充满可视化的3D场景！
- en: '![Multiple simultaneous visualizations](img/B05144_09_05.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![多个同时可视化](img/B05144_09_05.jpg)'
- en: Random visualizations
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机可视化
- en: We can switch between visualizations by adding and removing them over time.
    In the following example, we start with one active visualization and then every
    few seconds, toggle a random visualization on or off.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过随着时间的推移添加和删除可视化来在可视化之间切换。在以下示例中，我们从一个活动可视化开始，然后每隔几秒切换一个随机可视化。
- en: 'First, add an `activate` method to the abstract `Visualization` class, which
    takes a Boolean enabled parameter. The Boolean active variable is read-only:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在抽象的`Visualization`类中添加一个`activate`方法，它接受一个布尔类型的`enabled`参数。布尔类型的`active`变量是只读的：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Its implementation will depend on the specific visualization. `RenderBox` library
    provides an `enabled` flag that''s used when we render objects. The ones that
    instantiate a single `Plane` component are the easiest, such as `WaveformVisualization`
    and `FFTVisualization`. To each of these, add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现将取决于具体的可视化。`RenderBox`库提供了一个`enabled`标志，用于渲染对象。最容易的是那些实例化单个`Plane`组件的可视化，比如`WaveformVisualization`和`FFTVisualization`。对于这些，添加以下代码：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For the `GeometricVisualization` class, we can enable (and disable) each of
    the component cubes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GeometricVisualization`类，我们可以启用（和禁用）每个组件立方体：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now we can control this within the `MainActivity` class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`MainActivity`类中控制这个。
- en: 'Start with each of `visualizations` that are inactive. Add this initialization
    to `setup()` of `MainActivity`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从不活动的`visualizations`开始。将此初始化添加到`MainActivity`的`setup()`中：
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In `preDraw` of `MainActivity`, we''ll check the current time (using the `Time`
    class of `RenderBox` library) and toggle a random visualization after every 3
    seconds. First, add a few variables to the top of the class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`preDraw`中，我们将检查当前时间（使用`RenderBox`库的`Time`类），并在每3秒后切换一个随机可视化。首先，在类的顶部添加一些变量：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we can modify `preDraw` to check the time and modify the list of `visualizations`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`preDraw`来检查时间并修改`visualizations`列表：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A similar kind of time control structure (or delta time) can be used to implement
    many kinds of animation, such as changing the visualization object's position,
    rotation, and/or scale, or evolving the geometry itself over time.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的时间控制结构（或增量时间）可以用于实现许多种动画，比如改变可视化对象的位置、旋转和/或比例，或者随着时间的推移演变几何本身。
- en: Further enhancements
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的增强
- en: We hope that we've given you some tools to get you going with your own music
    visualizations. As we've suggested throughout this chapter, the options are infinite.
    Unfortunately, space prohibits us from having too much fun coding more and more
    stuff here.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们给了你一些工具，让你开始制作自己的音乐可视化。正如我们在本章中所建议的，选项是无限的。不幸的是，空间限制我们在这里编写更多有趣的代码。
- en: '**Animations**: We have applied the simplest transformations to each of our
    visualizations: a simple position, scale, and perhaps 90-degree rotations. Naturally,
    the position, rotation, and scale can be animated, that is, updated for each frame
    in coordination with the music, or independent of the music using `Time.deltaTime`.
    Stuff can be virtually flying all around you!'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：我们对每个可视化应用了最简单的变换：简单的位置、比例，也许是90度的旋转。当然，位置、旋转和比例可以进行动画处理，即与音乐协调更新每一帧，或者独立于音乐使用`Time.deltaTime`。东西可以在你周围虚拟飞来飞去！'
- en: '**Advanced textures and shaders**: Our shaders and data-driven textures are
    the most basic: fundamentally rendering a single color pixel corresponding to
    the audio byte value. The audio data can be fed into much more complex and interesting
    algorithms to generate new patterns and color and/or be used to morph preloaded
    textures.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级纹理和着色器**：我们的着色器和数据驱动纹理是最基本的：基本上渲染与音频字节值对应的单色像素。音频数据可以输入到更复杂和有趣的算法中，以生成新的图案和颜色，或者用于变形预加载的纹理。'
- en: '**Texture mapping**: The texture materials in the project are simply mapped
    onto a flat plane. Hey man, this is VR! Map the textures onto a photosphere or
    other geometry and totally immerse your users in it.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理映射**：项目中的纹理材料只是映射到一个平面上。嘿，伙计，这是虚拟现实！将纹理映射到一个全景照片或其他几何图形上，完全沉浸你的用户。'
- en: '**Render to texture**: Our trails mode looks alright for these visualizations,
    but will probably become a mess for anything sufficiently complex. Instead, you
    could use it exclusively within the surface of your textured planes. Setting up
    RTs is complex and beyond the scope of this book. Essentially, you introduce another
    camera to your scene, direct OpenGL to render subsequent draw calls to a new surface
    that you''ve created, and use that surface as the texture buffer for the objects
    you want to render it onto. RT is a powerful concept, enabling techniques such
    as reflection and in-game security cameras. Furthermore, you can apply transformations
    to the surface to make the trails appear to fly off into the distance, which is
    a popular effect among traditional visualizers such as MilkDrop ([https://en.wikipedia.org/wiki/MilkDrop](https://en.wikipedia.org/wiki/MilkDrop)).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染到纹理**：我们的轨迹模式对于这些可视化看起来还不错，但对于任何足够复杂的东西可能会变得一团糟。相反，您可以将其专门用于纹理平面的表面。设置RTs是复杂的，超出了本书的范围。基本上，您向场景引入另一个摄像机，指示OpenGL将后续绘制调用渲染到您创建的新表面，并将该表面用作要渲染到其上的对象的纹理缓冲区。RT是一个强大的概念，可以实现反射和游戏内安全摄像头等技术。此外，您可以对表面应用变换，使轨迹看起来飞向远处，这是传统可视化器（如MilkDrop）中的一种受欢迎的效果。'
- en: '**Parametric geometry**: Audio data can be used to drive the definition and
    rendering of 3D geometric models of varying complexity. Think of fractals, crystals,
    and 3D polyhedra. Take a look at Goldberg polyhedra (refer to [http://schoengeometry.com/](http://schoengeometry.com/))
    and Sacred geometry (refer to [http://www.geometrycode.com/sacred-geometry/](http://www.geometrycode.com/sacred-geometry/))
    for inspiration.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数几何**：音频数据可以用来驱动定义和渲染各种复杂度的3D几何模型。想想分形、晶体和3D多面体。参考Goldberg多面体（参考[http://schoengeometry.com/](http://schoengeometry.com/)）和神圣几何（参考[http://www.geometrycode.com/sacred-geometry/](http://www.geometrycode.com/sacred-geometry/)）以获取灵感。'
- en: A community invite
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区邀请
- en: We invite you to share your own visualizations with other readers of this book
    and the Cardboard community at large. One way to do this is via our GitHub repository.
    If you create a new visualization, submit it as a pull request to the project
    at [https://github.com/cardbookvr/visualizevr](https://github.com/cardbookvr/visualizevr),
    or create your own fork of the entire project!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们邀请您与本书的其他读者和Cardboard社区分享您自己的可视化效果。一种方法是通过我们的GitHub存储库。如果您创建了一个新的可视化效果，请将其作为拉取请求提交到项目[https://github.com/cardbookvr/visualizevr](https://github.com/cardbookvr/visualizevr)，或者创建您自己的整个项目的分支！
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a music visualizer that runs as a Cardboard VR application.
    We designed a general architecture that lets you define multiple visualizations,
    plug them into the app, and transition between them. The app uses the Android
    `Visualization` API to capture the waveform and FFT data from the phone's current
    audio player.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个作为Cardboard VR应用程序运行的音乐可视化器。我们设计了一个通用架构，让您可以定义多个可视化效果，将它们插入到应用程序中，并在它们之间进行过渡。该应用程序使用Android的`Visualization`
    API从手机当前的音频播放器中捕获波形和FFT数据。
- en: First, we defined the `VisualizerBox` class responsible for the activity and
    callback functions to the Android `Visualizer` API. Then, we defined an abstract
    `Visualization` class to implement a variety of visualizations. We then added
    waveform audio data capture to `VisualizerBox` and used it to parametrically animate
    a series of cubes to make a 3D wavy box. Next, we wrote a second visualizer; this
    time using waveform data to dynamically generate a texture that is rendered with
    material shader programs. And lastly, we captured the FFT audio data and used
    it for a third visualization. Then, we added more fun with a trippy trails mode
    and multiple concurrent visualizations that transition in and out randomly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了`VisualizerBox`类，负责与Android的`Visualizer` API的活动和回调函数。然后，我们定义了一个抽象的`Visualization`类来实现各种可视化效果。然后，我们将波形音频数据捕获到`VisualizerBox`中，并使用它来参数化地动画化一系列立方体，制作成一个3D波浪箱。接下来，我们编写了第二个可视化器；这次使用波形数据动态生成纹理，并使用材质着色器程序进行渲染。最后，我们捕获了FFT音频数据，并用它进行了第三个可视化。然后，我们增加了更多有趣的内容，比如迷幻轨迹模式和多个并发的可视化效果，随机进行过渡。
- en: We acknowledge that the visual examples are pretty simplistic, but hopefully
    they'll fuel your imagination. We challenge you to build your own 3D virtual reality
    music visualizations that perhaps utilize a combination of the techniques in this
    project as well as other things from this book.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承认，视觉示例非常简单，但希望它们能激发您的想象力。我们挑战您构建自己的3D虚拟现实音乐可视化，也许利用了这个项目中的技术以及本书中的其他内容。
- en: Onward to the future
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前往未来
- en: We hope you've enjoyed this introduction to and journey through Cardboard virtual
    reality development for Android. Throughout this book, we have explored the Google
    Cardboard Java SDK, OpenGL ES 2.0 graphics, and Android development in general.
    We touched on a number of VR best practices and saw the limitations of low-level
    graphics development on a mobile platform. Still, if you followed along, you've
    succeeded in implementing a reasonable general purpose library for 3D graphics
    and VR development. You created a wide variety of VR applications, including an
    app launcher, a Solar System simulation, a 360-degree media gallery, a 3D model
    viewer, and music visualizers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您喜欢这个介绍和通过Cardboard虚拟现实开发的旅程。在整本书中，我们探索了Google Cardboard Java SDK，OpenGL
    ES 2.0图形和Android开发。我们涉及了许多VR最佳实践，并看到了在移动平台上进行低级图形开发的局限性。但是，如果您跟随我们的步伐，您已经成功地实现了一个合理的通用3D图形和VR开发库。您创建了各种各样的VR应用程序，包括应用程序启动器、太阳系模拟、360度媒体画廊、3D模型查看器和音乐可视化器。
- en: Naturally, we expect the Cardboard Java SDK to change, evolve, and mature from
    this point forward. No one really knows what the future holds, perhaps not even
    Google. Yet here we are, at the precipice of a bold new future. The best way to
    predict the future is to help invent it. Now it's your turn!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们期待Cardboard Java SDK从此时开始发生变化、演变和成熟。没有人真正知道未来会发生什么，甚至包括谷歌在内。然而，我们现在站在一个崭新未来的悬崖边。预测未来的最好方法就是帮助创造它。现在轮到你了！
