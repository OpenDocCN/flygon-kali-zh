- en: Chapter 6. Rendering Graphics with OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用OpenGL ES渲染图形
- en: '*Let''s face the fact that one of the main interests of Android NDK is to write
    multimedia applications and games. Indeed, these programs consume lots of resources
    and need responsiveness. That is why one of the first available APIs (and almost
    the only one until recently) in Android NDK is an API for graphics: the **Open
    Graphics Library for Embedded Systems** (abbreviated as **OpenGL ES**).*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*让我们面对一个事实，Android NDK的主要兴趣之一是编写多媒体应用程序和游戏。事实上，这些程序消耗大量资源并需要响应性。这就是为什么Android
    NDK中最早可用的API之一（直到最近几乎是唯一的一个）是用于图形的API：**嵌入式系统图形库**（简称为**OpenGL ES**）*'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*OpenGL is a standard API created by Silicon Graphics and is now managed by
    the Khronos Group (see [http://www.khronos.org/](http://www.khronos.org/)). OpenGL
    provides a common interface for all standard **GPU**s (**Graphics Processing Unit**
    like your graphics card, and so on) on desktops. OpenGL ES is a derivative API
    available on many embedded platforms, such as Android or iOS. It is your best
    hope to write portable and efficient graphics code. OpenGL can render both 2D
    and 3D graphics.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*OpenGL是由Silicon Graphics创建的标准API，现在由Khronos Group管理（参见[http://www.khronos.org/](http://www.khronos.org/)）。OpenGL为桌面上所有标准**GPU**（如您的显卡等）提供了一个通用接口。OpenGL
    ES是许多嵌入式平台（如Android或iOS）上可用的衍生API。这是编写可移植和高效图形代码的最佳选择。OpenGL可以渲染2D和3D图形。*'
- en: 'There are three main releases of OpenGL ES currently supported by Android:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Android支持的OpenGL ES主要有三个版本：
- en: OpenGL ES 1.0 and 1.1 are supported on all Android devices (except 1.1, which
    is supported on a few very old devices). It offers an old school graphic API with
    a **fixed pipeline** (that is, a fixed set of configurable operations to transform
    and render geometry). Specification is not completely implemented, but most features
    are available. This could still be a good choice for simple 2D or 3D graphics
    or to port legacy OpenGL code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有Android设备都支持OpenGL ES 1.0和1.1（除了1.1，只有一些非常老的设备支持）。它提供了一个旧式的图形API，具有**固定管线**（即一组固定的可配置操作来转换和渲染几何图形）。规范并未完全实现，但大多数功能都可用。这仍然是简单的2D或3D图形的一个不错选择，或者用于移植传统的OpenGL代码。
- en: OpenGL ES 2 is supported on almost all phones nowadays, even older ones, starting
    from API Level 8\. It replaces the fixed pipeline with a modern programmable pipeline
    with **Vertex** and **Fragment Shaders**. It is a bit more complex but also more
    powerful. It is a good choice for the more complex 2D or 3D games, while still
    maintaining a very good compatibility. Note that OpenGL ES 1.X is frequently emulated
    by an OpenGL 2 implementation behind the scenes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在几乎所有的手机都支持OpenGL ES 2，甚至是旧的手机，从API级别8开始。它用现代可编程管线替换了固定管线，具有**顶点**和**片段着色器**。它更复杂但也更强大。对于更复杂的2D或3D游戏来说，这是一个很好的选择，同时仍然保持着很好的兼容性。请注意，OpenGL
    ES 1.X经常由OpenGL 2实现在幕后进行模拟。
- en: OpenGL ES 3.0 is available on modern devices starting from API Level 18, and
    OpenGL ES 3.1 is available starting from API Level 21 (not all devices at these
    API level may support it though). They bring a set of new improvements to GLES
    2 (**Texture Compression** as a standard feature, **Occlusion Queries, Instanced
    Rendering**, and others for 3.0, **Compute Shaders**, **Indirect Draw** commands,
    and others for 3.1) and a better compatibility with the desktop version of OpenGL.
    It is backward compatible with OpenGL ES 2.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0在API级别18及更高版本的现代设备上可用，OpenGL ES 3.1在API级别21及更高版本可用（尽管并非所有这些API级别的设备都支持它）。它们为GLES
    2带来了一系列新的改进（作为标准功能的纹理压缩、遮挡查询、实例化渲染等，适用于3.0版本，计算着色器、间接绘制命令等，适用于3.1版本），并且与OpenGL桌面版本更兼容。它向后兼容OpenGL
    ES 2。
- en: 'This chapter teaches you how to create some basic 2D graphics using OpenGL
    ES 2\. More specifically, you are going to discover how to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教你如何使用OpenGL ES 2创建一些基本的2D图形。更具体地说，你将发现如何：
- en: Initialize OpenGL ES
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化OpenGL ES
- en: Load a texture from a PNG file packaged in the assets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从打包在资产中的PNG文件中加载纹理
- en: Draw sprites using vertex and fragment shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器绘制精灵
- en: Render a particle effect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染一个粒子效果
- en: Adapt graphics to various resolutions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应各种分辨率的图形
- en: With OpenGL ES, and graphics in general, being a wide subject, this chapter
    covers only the basics to being with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于OpenGL ES和图形一般是一个广泛的主题，本章仅涵盖了基础知识。
- en: Initializing OpenGL ES
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化OpenGL ES
- en: The first step to create awesome 2D and 3D graphics is to initialize OpenGL
    ES. Although not terribly complex, this task requires some boilerplate code to
    bind a rendering context to an Android window. These pieces are glued together
    with the help of the **Embedded-System Graphics Library** (**EGL**), a companion
    API of OpenGL ES.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建令人惊叹的2D和3D图形的第一步是初始化OpenGL ES。虽然并不是非常复杂，但这项任务需要一些样板代码来将渲染上下文绑定到Android窗口。这些部分是通过**嵌入式系统图形库**（**EGL**）的帮助粘合在一起的，它是OpenGL
    ES的伴随API。
- en: For this first section, we are going to replace the raw drawing system implemented
    in the previous chapter with OpenGL ES. A black to white fading effect will demonstrate
    that the EGL initialization works properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将用OpenGL ES替换上一章中实现的原始绘图系统。一个从黑色到白色的渐变效果将证明EGL初始化工作正常。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part5`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part5`的名称提供。
- en: Time for action – initializing OpenGL ES
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-初始化OpenGL ES
- en: 'Let''s rewrite our `GraphicsManager` to initialize an OpenGL ES context:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们的`GraphicsManager`来初始化一个OpenGL ES上下文：
- en: 'Modify `jni/GraphicsManager.hpp` by performing the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下操作修改`jni/GraphicsManager.hpp`：
- en: Include `EGL/egl.h` to bind OpenGL ES to the Android platform and `GLES2/gl2.h`
    to render graphics
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括`EGL/egl.h`以将OpenGL ES绑定到Android平台和`GLES2/gl2.h`以渲染图形
- en: Add a method `stop()` to unbind the OpenGL rendering context and free graphics
    resources when you're leaving the activity
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在离开活动时，添加一个`stop()`方法来解绑OpenGL渲染上下文并释放图形资源
- en: 'Define `EGLDisplay`, `EGLSurface`, and `EGLContext` member variables, which
    represent handles to system resources, as shown here:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`EGLDisplay`，`EGLSurface`和`EGLContext`成员变量，它们表示对系统资源的句柄，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Reimplement `jni/GraphicsManager.cpp` by replacing the previous code based
    on Android raw graphics API with OpenGL-based code. Start by adding new members
    to the constructor initialization list:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用基于OpenGL的代码替换基于Android原始图形API的以前的代码，重新实现`jni/GraphicsManager.cpp`。首先，将新成员添加到构造函数初始化列表中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The hard work must be done in the method `start()`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 艰苦的工作必须在`start()`方法中完成：
- en: First, declare some variables. Note how EGL defines its own types and re-declares
    primitive types `EGLint` and `EGLBoolean` to favor platform independence.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，声明一些变量。请注意，EGL定义了自己的类型并重新声明了原始类型`EGLint`和`EGLBoolean`，以支持平台独立性。
- en: 'Then, define the needed OpenGL configuration in constant attribute lists. Here,
    we want OpenGL ES 2 and a 16 bit surface (5 bits for red, 6 bits for green, and
    5 bits for blue). We could also choose a 32 bit surface for better color fidelity
    (but less performance on some devices). The attribute lists are terminated by
    `EGL_NONE` sentinel:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在常量属性列表中定义所需的OpenGL配置。在这里，我们希望使用OpenGL ES 2和16位表面（5位红色，6位绿色，5位蓝色）。我们也可以选择32位表面以获得更好的颜色保真度（但在某些设备上性能较差）。属性列表以`EGL_NONE`标记终止：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Connect to the default **display**, that is, the Android main window, with
    `eglGetDisplay()` and `eglInitialize()`. Then, find an appropriate **framebuffer**
    (An OpenGL term referring to the rendering surface, and possibly additional buffers,
    such as **Z-buffer** or **Stencil** buffer) configuration with `eglChooseConfig()`
    as the display. Configurations are selected according to the requested attributes:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eglGetDisplay()`和`eglInitialize()`连接到默认的**显示**，即Android主窗口。然后，使用`eglChooseConfig()`在显示上找到一个合适的**帧缓冲区**（OpenGL术语，指渲染表面，可能还有其他缓冲区，如**Z缓冲区**或**模板**缓冲区）配置。根据请求的属性选择配置：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reconfigure the Android window with the selected configuration (retrieved with
    `eglGetConfigAttrib()`). This operation is Android-specific and performed with
    the Android `ANativeWindow` API.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eglGetConfigAttrib()`重新配置Android窗口以选择的配置。这个操作是特定于Android的，并且使用Android的`ANativeWindow`
    API执行。
- en: 'After that, create the display surface and the OpenGL context using the display
    and configuration selected previously. A context contains all data related to
    OpenGL state (enabled settings, disabled settings, and so on):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用之前选择的显示和配置创建显示表面和OpenGL上下文。上下文包含与OpenGL状态相关的所有数据（已启用的设置，已禁用的设置等）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Activate the created rendering context with `eglMakeCurrent()`. Finally, define
    the display viewport according to the surface attributes retrieved with `eglQuerySurface()`.
    The Z-buffer is not needed and can be disabled:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eglMakeCurrent()`激活创建的渲染上下文。最后，根据使用`eglQuerySurface()`检索到的表面属性定义显示视口。Z缓冲区是不需要的，可以禁用：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the application stops running, unbind the application from the Android
    window and release the EGL resources:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序停止运行时，取消与Android窗口的绑定并释放EGL资源：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*What just happened?*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We have initialized and connected both OpenGL ES and the Android native window
    system together with EGL. Thanks to this API, we have queried a display configuration
    that matches our expectations and creates a framebuffer to render our scene on.
    EGL is a standard API specified by the Khronos group (like OpenGL). Platforms
    often implement their own variant (haphazardly, EAGL on iOS and so on) so that
    the display window initialization remains OS-specific. Thus, portability is quite
    limited in practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初始化并连接了OpenGL ES和Android本机窗口系统以及EGL。由于这个API，我们已经查询了与我们期望相匹配的显示配置，并创建了一个帧缓冲区来渲染我们的场景。EGL是由Khronos组指定的标准API（就像OpenGL一样）。平台通常实现自己的变体（例如iOS上的EAGL等），因此显示窗口初始化保持特定于操作系统。因此，在实践中，可移植性非常有限。
- en: 'This initialization process results in the creation of an OpenGL context, which
    is the first step to enable the OpenGL graphics pipeline. Special care should
    be taken with OpenGL contexts, which are frequently lost on Android: when you''re
    leaving or going back to the home screen, when a call is received, when devices
    go to sleep, when you''re switching to another application, and so on. As a lost
    context becomes unusable, it is important to release graphics resources as soon
    as possible.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化过程会创建一个OpenGL上下文，这是启用OpenGL图形管道的第一步。OpenGL上下文需要特别小心，因为在Android上经常会丢失：当你离开或返回主屏幕时，当接到电话时，当设备进入休眠时，当你切换到另一个应用程序时等等。由于丢失的上下文变得无法使用，因此尽快释放图形资源非常重要。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The OpenGL ES specification supports the creation of multiple contexts for one
    display surface. This allows dividing rendering operations among threads or rendering
    to several windows. However, it is not well supported on Android hardware and
    should be avoided.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES规范支持为一个显示表面创建多个上下文。这允许在线程之间分割渲染操作或在多个窗口上进行渲染。但是，在Android硬件上支持不好，应该避免使用。
- en: OpenGL ES is now initialized but nothing will show up unless we start rendering
    some graphics on the display screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经初始化了OpenGL ES，但除非我们在显示屏上开始渲染一些图形，否则不会显示任何内容。
- en: Time for action – clearing and swapping buffers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-清除和交换缓冲区
- en: 'Let''s clear the display buffers with a color fading from black to white:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用从黑色到白色渐变的颜色清除显示缓冲区：
- en: While still being in `jni/GraphicsManager.cpp`, refresh the screen during each
    update step with `eglSwapBuffers()`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.cpp`中，仍然在每次更新步骤中使用`eglSwapBuffers()`刷新屏幕。
- en: 'To have a visual feedback, change the display background color gradually with
    the help of `glClearColor()` before erasing the Framebuffer with `glClear()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得视觉反馈，在使用`glClear()`擦除帧缓冲之前，使用`glClearColor()`逐渐改变显示背景颜色：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the `Android.mk` file to link `the EGL` and `GLESv2` libraries:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Android.mk`文件以链接`EGL`和`GLESv2`库：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Launch the application. If everything works fine, your device screen will progressively
    fade from black to white. Instead of clearing the display with a raw `memset()`,
    or setting pixels one by one as seen in the previous chapter, we invoke efficient
    OpenGL ES drawing primitives. Note that the effect appears only the first time
    the application starts because the clear color is stored in a static variable.
    To make it appear again, kill the application and relaunch it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序。如果一切正常，你的设备屏幕将逐渐从黑色变为白色。我们不是用原始的`memset()`清除显示，也不是像前一章中所见的逐个设置像素，而是调用高效的OpenGL
    ES绘图原语。请注意，效果只在应用程序第一次启动时出现，因为清除颜色存储在静态变量中。要再次出现，关闭应用程序并重新启动。
- en: Rendering a scene requires clearing the framebuffer and swapping the display
    buffer. The latter operation is triggered when `eglSwapBuffers()` is invoked.
    Swapping on Android is synchronized with the screen refresh rate to avoid image
    **Tearing**; this is a **VSync**. The refresh rate is variable depending on the
    device. A common value is 60 Hz but some devices have different refresh rates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染场景需要清除帧缓冲区并交换显示缓冲区。后者操作在调用`eglSwapBuffers()`时触发。在Android上，交换是与屏幕刷新率同步的，以避免图像**撕裂**；这就是**垂直同步**。刷新率因设备而异。常见值为60赫兹，但一些设备有不同的刷新率。
- en: Internally, rendering is performed on a back buffer which is swapped with the
    front buffer shown to the user. The front buffer becomes the back buffer and vice
    versa (the pointers are switched). This technique is more commonly referred to
    as **page flipping**. According to the driver implementation, the swapping chain
    can be extended with a third buffer. In this situation, we talk about **Triple
    Buffering**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，渲染是在一个后备缓冲区上执行的，该缓冲区与向用户显示的前缓冲区交换。前缓冲区变成后缓冲区，反之亦然（指针被切换）。这种技术更常被称为**页翻转**。根据驱动程序的实现，交换链可以扩展为第三个缓冲区。在这种情况下，我们谈论**三重缓冲**。
- en: Our OpenGL pipeline is now properly initialized and able to display graphics
    on the screen. However, you may still find this concept of "pipeline" a bit nebulous.
    Let's see what is hidden behind it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的OpenGL管线现在已经正确初始化，并能够在屏幕上显示图形。然而，你可能仍然觉得“管线”这个概念有点模糊。让我们看看它背后隐藏着什么。
- en: An insight into the OpenGL pipeline
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对OpenGL管线的了解
- en: 'We talk about pipeline because the graphics data goes through a series of steps
    in which it is transformed. The following diagram shows a simplified representation
    of the OpenGL ES 2 pipeline:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论管线，因为图形数据经历一系列步骤进行变换。下图显示了OpenGL ES 2管线的简化表示：
- en: '![An insight into the OpenGL pipeline](img/9645OS_06_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![对OpenGL管线的了解](img/9645OS_06_05.jpg)'
- en: '**Vertex Processing**: An input mesh of vertices, given as a **vertex buffer
    object** or a **vertex array**, is transformed vertex by vertex in a vertex shader.
    The vertex shader can, for example, move or rotate single vertices, project them
    onto the screen, adapt texture coordinates, compute lighting, and so on. It generates
    an output vertex that can be processed further in the pipe.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点处理**：输入的顶点网格，作为**顶点缓冲对象**或**顶点数组**给出，通过顶点着色器逐个顶点进行变换。例如，顶点着色器可以移动或旋转单个顶点，将它们投影到屏幕上，调整纹理坐标，计算光照等。它生成一个输出顶点，可以在管道中进一步处理。'
- en: '**Primitive Assembly**: Individual vertices are connected together into triangles,
    points, lines, and so on. More connection information is specified by the client
    code when the draw call is sent. It can take the form of an index buffer (each
    index points to a vertex through its rank) or a predefined rule, such as stripping
    or fanning. Transformations such as **back face culling** or **clipping** are
    done at this stage.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本组装**：单个顶点被连接成三角形、点、线等。当发送绘制调用时，客户端代码会指定更多的连接信息。它可以采用索引缓冲（每个索引通过其等级指向一个顶点）或预定义规则，如剥离或扇形。在这个阶段进行**背面剔除**或**裁剪**等变换。'
- en: '**Rasterization**: Primitives are interpolated into fragments, which is a term
    covering all the data associated with one pixel to render (such as color, normals,
    and so on). One fragment is related to one pixel. These fragments feed the fragment
    shader.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化**：基本图元被插值为片段，这是一个涵盖与要渲染的一个像素相关的所有数据的术语（如颜色、法线等）。一个片段与一个像素相关联。这些片段供给片段着色器。'
- en: '**Fragment Processing**: The fragment shader is a program which processes each
    fragment to compute the pixel to display. This is the stage where texture mapping,
    using the coordinates computed by the vertex shader and interpolated by the rasterizer,
    is applied. Different shading algorithms can be computed to render specific effects
    (for example, **Toon shading**).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段处理**：片段着色器是一个处理每个片段以计算要显示的像素的程序。这是纹理映射的阶段，使用顶点着色器计算的并由光栅化器插值的坐标。可以计算不同的着色算法来渲染特定效果（例如，**卡通着色**）。'
- en: '**Pixel Processing**: The fragment shader outputs pixels which have to be merged
    in the existing framebuffer (the rendering surface), where some pixels may be
    already drawn. Transparency effects or blending is applied at this stage.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素处理**：片段着色器输出的像素必须合并到现有的帧缓冲区（渲染表面），其中一些像素可能已经绘制。透明效果或混合在这个阶段应用。'
- en: The vertex and fragment shaders are programmable in the **GL Shading Language**
    (**GLSL**). They are available only in OpenGL ES 2 and 3\. OpenGL ES 1 provides
    a fixed function pipeline with a predefined set of possible transformations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器是可编程的**GL着色语言**（**GLSL**）。它们仅在OpenGL ES 2和3中可用。OpenGL ES 1提供了一个具有预定义一组可能变换的固定功能管线。
- en: This is only a brief overview of all the processing done by the OpenGL rendering
    pipeline. To find more information about it, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是OpenGL渲染管线所做的所有处理的简要概述。要了解更多信息，请查看OpenGL.org维基[http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview)。
- en: Loading textures using the Asset manager
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资产管理器加载纹理
- en: I guess you need something more consistent than just changing the screen color!
    But before showing awesome graphics in our application, we need to load some external
    resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你需要的东西比只是改变屏幕颜色要一致！但在我们的应用程序中显示出色的图形之前，我们需要加载一些外部资源。
- en: In this second part, we are going to load a texture into OpenGL ES thanks to
    the Android Asset manager, an API provided since NDK R5\. It allows programmers
    to access any resources stored in the `assets` folder in their project. Assets
    stored there are then packaged into the final APK archive during application compilation.
    Asset resources are considered as raw binary files that your application needs
    to interpret and access using their filename relative to the `assets` folder (a
    file `assets/mydir/myfile` can be accessed with `mydir/myfile` path). Files are
    available in the read-only mode and might be compressed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本第二部分中，我们将通过Android资产管理器将纹理加载到OpenGL ES中，这是自NDK R5以来提供的API。它允许程序员访问项目中存储在`assets`文件夹中的任何资源。然后，在应用程序编译期间，这些资产将打包到最终的APK存档中。资产资源被视为原始二进制文件，您的应用程序需要解释和使用它们的文件名相对于`assets`文件夹的路径（文件`assets/mydir/myfile`可以使用`mydir/myfile`路径访问）。文件以只读模式可用，并且可能已经压缩。
- en: If you have already written some Java Android application, then you know that
    Android also provides resources accessible through compile-time generated IDs
    inside the res project folder. This is not directly available on the Android NDK.
    Unless you are ready to use a JNI bridge, assets are the only way to package resources
    in your APK.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经编写过一些Java Android应用程序，那么您知道Android还提供了通过res项目文件夹内的编译时生成的ID访问的资源。这在Android
    NDK上不是直接可用的。除非您准备使用JNI桥接，否则资产是在APK中打包资源的唯一方式。
- en: We are now going to load a texture encoded in one of the most popular picture
    formats used nowadays, the **Portable Network Graphics** (**PNG**). For this,
    we are going to integrate **libpng** in a NDK module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要加载一个以目前最流行的图片格式之一**便携式网络图形**（**PNG**）编码的纹理。为此，我们将在NDK模块中集成**libpng**。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part6`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的结果项目名称为`DroidBlaster_Part6`。
- en: Time for action – reading assets with the Asset manager
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动-使用资产管理器读取资产
- en: 'Let''s create a class to read the Android asset files:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类来读取Android资产文件：
- en: Create `jni/Resource.hpp` to encapsulate the access to asset files. We are going
    to use the `AAsset` API defined in `android/asset_manager.hpp` (which is already
    included in `android_native_app_glue.h`).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Resource.hpp`来封装对资产文件的访问。我们将使用`android/asset_manager.hpp`中定义的`AAsset`
    API（已包含在`android_native_app_glue.h`中）。
- en: 'Declare the three main operations: `open()`, `close()`, and `read()`. We also
    need to retrieve the resource''s path in `getPath()`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 声明三个主要操作：`open()`，`close()`和`read()`。我们还需要在`getPath()`中检索资源的路径。
- en: 'The Android Asset management API entry point is an `AAsetManager` opaque structure.
    We can access asset files, represented by a second opaque structure `AAsset`,
    from it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Android资产管理API的入口点是一个`AAsetManager`不透明结构。我们可以从中访问资产文件，这些文件由第二个不透明结构`AAsset`表示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the class `Resource` in `jni/Resource.cpp`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Resource.cpp`中实现类`Resource`。
- en: 'The Asset manager is provided by the **Native App Glue** module in its `android_app->activity`
    structure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 资产管理器由**Native App Glue**模块提供，在其`android_app->activity`结构中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Asset manager opens assets with `AassetManager_open()`. This is the sole
    responsibility of this method, apart from listing folders. We use the default
    open mode `AASSET_MODE_UNKNOWN` (more about this soon):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资产管理器使用`AassetManager_open()`打开资产。除了列出文件夹之外，这是该方法的唯一责任。我们使用默认的打开模式`AASSET_MODE_UNKNOWN`（稍后会详细介绍）：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like files in classic applications, an opened asset must be closed when finished
    with `AAsset_close()` so that any resource allocated by the system is released:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与经典应用程序中的文件一样，打开的资产在完成后必须使用`AAsset_close()`关闭，以释放系统分配的任何资源：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the code operates on asset files with `AAsset_read()` to read data.
    This is quite similar to what you can find with the standard Posix file API. Here,
    we try to read the `pCount` data in a memory buffer and retrieve the amount of
    data that was effectively read (in case we reach the end of the asset):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代码使用`AAsset_read()`操作资产文件以读取数据。这与标准Posix文件API中的内容非常相似。在这里，我们尝试在内存缓冲区中读取`pCount`数据，并检索实际读取的数据量（以防我们达到资产的末尾）：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We have seen how to call the Android Asset API to read a file stored in the
    `assets` directory. Android assets are read-only and should be used to hold static
    assets only. The Android Asset API is defined in the `android/assert_manager.h`
    including file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何调用Android资产API来读取存储在`assets`目录中的文件。Android资产是只读的，应该用于仅保存静态资产。Android资产API定义在包括文件中`android/assert_manager.h`。
- en: More about the Asset Manager API
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关资产管理器API的更多信息
- en: 'The Android Asset manager provides a small set of method to access directories:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android资产管理器提供了一小组方法来访问目录：
- en: '`AAssetManager_openDir()` gives the possibility to explore an asset directory.
    Use it in conjunction with `AAssetDir_getNextFileName()` and `AAssetDir_rewind()`.
    An opened directory must be closed with `AAssetDir_close()`:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetManager_openDir()`使得可以探索资产目录。将其与`AAssetDir_getNextFileName()`和`AAssetDir_rewind()`一起使用。打开的目录必须使用`AAssetDir_close()`关闭：'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`AAssetDir_getNextFileName()` lists all the files available in the specified
    asset directory. One filename is returned each time you call it, or `NULL` is
    returned when all files have been listed:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_getNextFileName()`列出指定资产目录中所有可用的文件。每次调用它时都会返回一个文件名，或者在列出所有文件时返回`NULL`：'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`AAssetDir_rewind()` gives the possibility to restart the file iteration process
    with `AAssetDir_getNextFileName()` from the beginning of the process:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_rewind()`使得可以使用`AAssetDir_getNextFileName()`从过程的开始重新启动文件迭代过程：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`AAssetDir_close()` frees all the resources allocated when the directory has
    been opened. This method must be called in pair with `AAssetManager_openDir()`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_close()`释放打开目录时分配的所有资源。这个方法必须与`AAssetManager_openDir()`成对调用：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Files can be opened with an API similar to the POSIX file API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以使用类似于POSIX文件API的API打开：
- en: '`AAssetManager_open()` opens an asset file to read its content, retrieve its
    content as a buffer, or access its file descriptor. An opened asset must be closed
    with `AAsset_close()`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetManager_open()`打开一个资产文件以读取其内容，检索其内容作为缓冲区，或访问其文件描述符。打开的资产必须使用`AAsset_close()`关闭：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`AAsset_read()` attempts to read the requested number of bytes in the provided
    buffer. The number of bytes actually read is returned or a negative value is returned
    in case an error occurs:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_read()`尝试在提供的缓冲区中读取请求的字节数。返回实际读取的字节数，或者在发生错误时返回负值：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`AAsset_seek()` moves directly to the specified offset in the file, ignoring
    the previous data:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_seek()`直接移动到文件中指定的偏移量，忽略先前的数据：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AAsset_close()` closes the asset and frees all the resources allocated when
    the file has been opened. This method must be called in pair with `AAssetManager_open()`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_close()`关闭资产并释放打开文件时分配的所有资源。这个方法必须与`AAssetManager_open()`成对调用：'
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AAsset_getBuffer()` returns a pointer to a memory buffer containing the whole
    asset content or `NULL` if a problem occurs. The buffer might be memory mapped.
    Beware, as Android compresses some assets (depending on their extension) so that
    the buffer might not be directly readable:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_getBuffer()`返回一个指向包含整个资产内容的内存缓冲区的指针，如果出现问题，则返回`NULL`。缓冲区可能是内存映射的。请注意，由于Android压缩了一些资产（取决于它们的扩展名），因此缓冲区可能无法直接读取：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`AAsset_getLength()` gives the total asset size in bytes. This method might
    be useful to preallocate a buffer of the right size before reading an asset:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_getLength()`以字节为单位给出总资产大小。在读取资产之前，这个方法可能有用来预先分配正确大小的缓冲区：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Aasset_getRemainingLength()` is similar to `AAsset_getLength()` except that
    it does take into account the bytes already read:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aasset_getRemainingLength()`类似于`AAsset_getLength()`，只是它考虑了已经读取的字节数：'
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`AAsset_openFileDescriptor()` returns a raw Unix file descriptor. This is used
    in OpenSL to read a music file:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_openFileDescriptor()`返回一个原始的Unix文件描述符。这在OpenSL中用于读取音乐文件：'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`AAsset_isAllocated()` indicates if the buffer returned by the asset is memory
    mapped:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_isAllocated()`指示资产返回的缓冲区是否是内存映射的：'
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will see more about these methods in the subsequent chapters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中更多地了解这些方法。
- en: 'The modes available to open asset files are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开资产文件的可用模式是：
- en: '`AASSET_MODE_BUFFER`: This helps to perform fast small reads'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_BUFFER`：这有助于执行快速小读取'
- en: '`AASSET_MODE_RANDOM`: This helps to read chunks of data forward and backward'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_RANDOM`：这有助于向前和向后读取数据块'
- en: '`AASSET_MODE_STREAMING`: This helps to read data sequentially with occasional
    forward seeks'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_STREAMING`：这有助于顺序读取数据，并偶尔进行向前搜索'
- en: '`AASSET_MODE_UNKNOWN`: This helps to keep the system default settings'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_UNKNOWN`：这有助于保持系统默认设置'
- en: Most of the time `AASSET_MODE_UNKNOWN` will be the way to go.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，`AASSET_MODE_UNKNOWN`将是最佳选择。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Installing, large APK can be problematic even when they are deployed on an SD
    card (see the `installLocation` option in the Android manifest). Thus, a good
    strategy to deal with tons of megabytes of assets is to keep only the essential
    ones in your APK. Download the remaining files to the SD card at runtime or package
    them within a second APK.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装大型APK即使在部署在SD卡上时也可能会出现问题（请参见Android清单中的`installLocation`选项）。因此，处理大量MB级资产的一个好策略是只在APK中保留必要的资产。在运行时将其余文件下载到SD卡上，或者将它们打包到第二个APK中。
- en: Now that we have the PNG asset files to read, let's load them using `libpng`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有PNG资产文件要读取，让我们使用`libpng`加载它们。
- en: Time for action – compiling and embedding libpng module
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-编译和嵌入libpng模块
- en: Let's load an OpenGL texture from a PNG file in DroidBlaster.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从DroidBlaster中的PNG文件加载OpenGL纹理。
- en: Go to the website [http://www.libpng.org/pub/png/libpng.html](http://www.libpng.org/pub/png/libpng.html)
    and download the `libpng` source package (which is Version 1.6.10 in this book).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到网站[http://www.libpng.org/pub/png/libpng.html](http://www.libpng.org/pub/png/libpng.html)，并下载本书中提供的`libpng`源包（本书中的版本为1.6.10）。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original `libpng` 1.6.10 archive is provided with this book in the `Libraries/libpng`
    folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`libpng` 1.6.10存档与本书一起提供在`Libraries/libpng`文件夹中。
- en: Create a folder named `libpng` inside `$ANDROID_NDK/sources/`. Move all files
    from the `libpng` package into this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$ANDROID_NDK/sources/`内创建一个名为`libpng`的文件夹。将`libpng`包中的所有文件移动到其中。
- en: Copy the file `libpng/scripts/pnglibconf.h.prebuilt` into the root folder `libpng`
    with other source files. Rename it as `pnglibconf.h`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件`libpng/scripts/pnglibconf.h.prebuilt`复制到其他源文件的根文件夹`libpng`中。将其重命名为`pnglibconf.h`。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The folder `$ANDROID_NDK/sources` is a special folder considered as a module
    folder by default. It contains reusable libraries. See [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*, for
    more information.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹`$ANDROID_NDK/sources`是一个特殊的文件夹，默认情况下被视为模块文件夹。它包含可重用的库。有关更多信息，请参见[第9章](ch09.html
    "第9章。将现有库移植到Android")，“将现有库移植到Android”。
- en: 'Write the `$ANDROID_NDK/sources/libpng/Android.mk` file with the content given
    in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码编写`$ANDROID_NDK/sources/libpng/Android.mk`文件的内容：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, open `jni/Android.mk` in the `DroidBlaster` directory.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`DroidBlaster`目录中打开`jni/Android.mk`。
- en: 'Link and import `libpng` with the help of the `LOCAL_STATIC_LIBRARIES` and
    `import-module` directives. This is similar to what we have done with the Native
    App Glue module:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LOCAL_STATIC_LIBRARIES`和`import-module`指令链接和导入`libpng`。这类似于我们使用Native App
    Glue模块所做的事情：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*What just happened?*'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'In the previous chapter, we embedded the existing Native App Glue module to
    create a fully native application. This time we have created our first native
    reusable module to integrate `libpng`. Ensure that it works by compiling `DroidBlaster`.
    If you look at the **Console** view of the `libpng` source files, it should get
    compiled for each target platform. Note that NDK provides incremental compilation
    and will not recompile the already compiled sources:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们嵌入了现有的Native App Glue模块来创建一个完全本地的应用程序。这一次，我们创建了我们的第一个本地可重用模块来集成`libpng`。通过编译`DroidBlaster`来确保它能正常工作。如果你查看`libpng`源文件的**控制台**视图，它应该为每个目标平台进行编译。请注意，NDK提供了增量编译，并不会重新编译已经编译过的源文件：
- en: '![What just happened?](img/9645OS_06_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_06_01.jpg)'
- en: A native library module (here, `libpng`) is defined in a Makefile located at
    the root of its own directory. It is then referenced from another Makefile module,
    typically the application module (here `Droidblaster`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个本地库模块（这里是`libpng`）在其自己目录的Makefile中定义。然后从另一个Makefile模块引用它，通常是应用程序模块（这里是`Droidblaster`）。
- en: Here, the `libpng` library Makefile selects all the C files with the help of
    a custom macro `LS_C`. This macro is invoked from the `LOCAL_SRC_FILES` directive.
    We exclude `example.c` and `pngtest.c`, which are just test files, using the standard
    "Make" function `filter-out()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`libpng`库的Makefile使用自定义宏`LS_C`选择所有的C文件。这个宏是从`LOCAL_SRC_FILES`指令中调用的。我们使用标准的“Make”函数`filter-out()`排除了`example.c`和`pngtest.c`这两个测试文件。
- en: All the prerequisites include files that are made available to client modules
    with the directive `LOCAL_EXPORT_C_INCLUDES`, which refers to the source directory
    `LOCAL_PATH` here. The prerequisite libraries like `libzip` (option `-lz`) are
    also provided to the client modules using the `LOCAL_EXPORT_LDLIBS` directive
    this time. All directives containing the `_EXPORT_` term exports directives that
    are appended to the client module's own directives.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先决条件包括通过指令`LOCAL_EXPORT_C_INCLUDES`提供给客户端模块的文件，这里指的是源目录`LOCAL_PATH`。像`libzip`（选项`-lz`）这样的先决条件库也是使用`LOCAL_EXPORT_LDLIBS`指令提供给客户端模块的。所有包含`_EXPORT_`术语的指令都会导出附加到客户端模块自己指令的指令。
- en: For more information about Makefiles, directives, and standard functions, have
    a look at [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Makefile、指令和标准函数的更多信息，请参阅[第9章](ch09.html "第9章。将现有库移植到Android")*将现有库移植到Android*。
- en: Time for action – loading a PNG image
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-加载PNG图像
- en: 'Now that `libpng` is compiled, let''s read a real PNG file with it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`libpng`已经编译完成，让我们用它来读取一个真正的PNG文件：
- en: Edit `jni/GraphicsManager.hpp` and include the `Resource` header file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.hpp`并包含`Resource`头文件。
- en: 'Create a new structure named `TextureProperties` containing:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`TextureProperties`的新结构，其中包含：
- en: A resource representing the texture asset
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表纹理资源的资源
- en: An OpenGL texture identifier (which is a kind of handle)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个OpenGL纹理标识符（一种句柄）
- en: A width and a height
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个宽度和一个高度
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Append a method `loadTexture()` to the `GraphicsManager` to read a PNG and load
    it into an OpenGL texture.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`GraphicsManager`追加一个`loadTexture()`方法来读取PNG并将其加载到OpenGL纹理中。
- en: Textures are saved in an `mTextures` array to cache and finalize them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理保存在`mTextures`数组中以进行缓存和最终处理。
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Edit `jni/GraphicsManager.cpp` to include a new header named `png.h` and update
    the constructor initialization list:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.cpp`以包含一个名为`png.h`的新头文件，并更新构造函数初始化列表：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Free the texture-related resources when `GraphicsManager` stops using `glDeleteTetxures()`.
    This function can delete several textures at once, which explains why this method
    expects an ordinal and an array. But we will not use this possibility here:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`GraphicsManager`停止使用`glDeleteTetxures()`时释放与纹理相关的资源。这个函数可以一次删除多个纹理，这就解释了为什么这个方法需要一个序数和一个数组。但是我们这里不会使用这个可能性：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To be fully independent from the data source, `libpng` provides a mechanism
    to integrate custom-read operations. This takes the form of a callback and reads
    the requested quantity of data into a buffer provided by `libpng`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完全独立于数据源，`libpng`提供了一种集成自定义读取操作的机制。这采取了一个回调的形式，并将请求的数据量读入由`libpng`提供的缓冲区。
- en: 'Implement this callback in conjunction with the Android Asset API to access
    the read data from application assets. The asset file is read through a `Resource`
    instance given by `png_get_io_ptr()` as an untyped pointer. This pointer is going
    to be provided by us while setting up the callback function (using `png_set_read_fn()`).
    We will see how this is done in the next steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android Asset API一起实现此回调，以访问应用程序资产中的读取数据。通过`png_get_io_ptr()`给出的`Resource`实例读取资产文件作为一个无类型指针。这个指针将在设置回调函数时由我们提供（使用`png_set_read_fn()`）。我们将在接下来的步骤中看到如何做到这一点：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement `loadTexture()`. First, look for the `texture` in the cache. Textures
    are expensive in terms of memory and performance and should be managed with care
    (like all OpenGL resources in general):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`loadTexture()`。首先，在缓存中查找`texture`。纹理在内存和性能方面都很昂贵，应该小心管理（就像一般的OpenGL资源一样）：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you could not find the texture in the cache, let's read it. Define a few
    variables needed to read the PNG file first.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在缓存中找不到纹理，让我们来读取它。首先定义一些需要读取PNG文件的变量。
- en: 'Then, open the image using the `AAsset` API and check the image signature (the
    first 8 bytes of the file) to ensure that the file is a PNG (note that it might
    still be corrupted):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`AAsset` API打开图像并检查图像签名（文件的前8个字节），以确保文件是PNG格式（注意它可能仍然是损坏的）：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Allocate all the structures necessary to read a PNG image. After that, prepare
    reading operations by passing our `callback_readPng()`, implemented earlier in
    this tutorial, to `libpng`, along with our `Resource` reader. `Resource` pointer
    is the one retrieved in the callback with `png_get_io_ptr()`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配所有必要的结构来读取PNG图像。之后，通过将我们之前在本教程中实现的`callback_readPng()`传递给`libpng`，以及我们的`Resource`读取器，准备读取操作。`Resource`指针是在回调中使用`png_get_io_ptr()`检索到的。
- en: 'Also, set up error management with `setjmp()`. This mechanism allows jumping
    in code like a `goto` but through the call stack. If an error occurs, the control
    flow comes back at the point where `setjmp()` has been called first but enters
    the `if` block instead (here `goto ERROR`). This is the moment where we can provide
    the following script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还要使用`setjmp()`设置错误管理。这种机制允许通过调用堆栈跳转到代码，就像`goto`一样。如果发生错误，控制流将回到首次调用`setjmp()`的地方，但是进入`if`块（这里是`goto
    ERROR`）。这是我们可以提供以下脚本的时刻：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ignore the first 8 bytes from the signature, which have already been read,
    for file signatures with `png_set_sig_bytes()` and `png_read_info()`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`png_set_sig_bytes()`和`png_read_info()`为文件签名忽略已经读取的前8个字节：
- en: 'Start reading the PNG file header with `png_get_IHDR()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`png_get_IHDR()`开始读取PNG文件头：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The PNG files can be encoded in several formats: RGB, RGBA, 256 colors with
    a palette, grayscale, and so on. R, G, and B color channels can be encoded up
    to 16 bits. Hopefully, `libpng` provides transformation functions to decode unusual
    formats and transforms them into more classical RGB and luminance formats (with
    8 bits per channel, with or without an alpha channel).'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PNG文件可以以几种格式进行编码：RGB、RGBA、带调色板的256色、灰度等。R、G和B颜色通道可以编码高达16位。希望`libpng`提供转换函数来解码不寻常的格式，并将其转换为更经典的RGB和亮度格式（每个通道8位，带或不带alpha通道）。
- en: Select the right transformation using `png_set` functions. Transformations are
    validated with `png_read_update_info()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的转换使用`png_set`函数。转换通过`png_read_update_info()`进行验证。
- en: 'At the same time, select the corresponding OpenGL texture format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，选择相应的OpenGL纹理格式：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Allocate the necessary temporary buffer to hold image data and a second one
    with the address of each output image row for `libpng`. Note that the row order
    is inverted because OpenGL uses a different coordinate system (the first pixel
    is at bottom-left) than PNG (first pixel at top-left).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配必要的临时缓冲区来保存图像数据，以及第二个缓冲区，其中包含每个输出图像行的地址，用于`libpng`。请注意，行顺序是倒置的，因为OpenGL使用不同的坐标系统（第一个像素在左下角），而PNG（第一个像素在左上角）。
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, start reading the image content with `png_read_image()`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`png_read_image()`开始读取图像内容。
- en: 'Finally, when it''s finished, release all temporary resources:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当完成时，释放所有临时资源：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, when it''s finished, release all temporary resources:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当完成时，释放所有临时资源：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*What just happened?*'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Combining our native library module `libpng` with the Asset manager API gives
    us the power to load PNG files packaged in the assets directory. PNG is a relatively
    simple image format that is rather easy to integrate. In addition, it supports
    compression, which is good to limit the size of your APKs. Please note that once
    loaded, the PNG image buffer is uncompressed and can consume a lot of memory.
    So, release them as soon as you can. For detailed information about the PNG format,
    see [http://www.w3.org/TR/PNG/](http://www.w3.org/TR/PNG/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的本地库模块`libpng`与Asset管理器API结合使用，使我们能够加载打包在资产目录中的PNG文件。PNG是一种相对简单的图像格式，相对容易集成。此外，它支持压缩，这有助于限制APK的大小。请注意，一旦加载，PNG图像缓冲区将被解压缩，并且可能会占用大量内存。因此，请尽快释放它们。有关PNG格式的详细信息，请参见[http://www.w3.org/TR/PNG/](http://www.w3.org/TR/PNG/)。
- en: Now that our PNG image is loaded, we can generate an OpenGL texture from it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的PNG图像已加载，我们可以从中生成一个OpenGL纹理。
- en: Time for action – generating an OpenGL texture
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-生成OpenGL纹理
- en: 'The `image` buffer filled by `libpng` now contains raw texture data. The next
    step is to generate a texture from it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由`libpng`填充的`image`缓冲区现在包含原始纹理数据。下一步是从中生成纹理：
- en: Let's continue our previous method `which is GraphicsManager::loadTexture()`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续我们之前的方法`GraphicsManager::loadTexture()`。
- en: Generate a new texture identifier with `glGenTextures()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glGenTextures()`生成新的纹理标识符。
- en: Indicate that we are working on a texture with `glBindTexture()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glBindTexture()`指示我们正在处理纹理。
- en: 'Configure texture parameters with `glTexParameteri()` to specify the way a
    texture is filtered and wrapped. Use `GL_NEAREST`, as smoothing is not essential
    for a 2D game without zoom effects. Texture repetition is also not necessary and
    can be prevented with `GL_CLAMP_TO_EDGE`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glTexParameteri()`配置纹理参数，以指定纹理的过滤和包装方式。使用`GL_NEAREST`，因为在没有缩放效果的2D游戏中，平滑处理并不重要。纹理重复也不是必要的，并且可以使用`GL_CLAMP_TO_EDGE`来防止：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Push the image data into OpenGL texture with `glTexImage2D()`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glTexImage2D()`将图像数据推送到OpenGL纹理。
- en: This unbinds the texture to put OpenGL pipeline back in its previous state.
    This is not strictly necessary, but it helps to avoid configuration mistakes in
    future draw calls (that is, drawing with an unwanted texture).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将取消绑定纹理以将OpenGL管道恢复到先前的状态。这并不是严格必要的，但有助于避免未来绘图调用中的配置错误（即使用不需要的纹理进行绘制）。
- en: Finally, do not forget to free the temporary image buffer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记释放临时图像缓冲区。
- en: 'You can check that the texture has been created properly with `glGetError()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`glGetError()`检查纹理是否已正确创建：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, cache the `texture` before returning it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在返回之前缓存`texture`：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `jni/DroidBlaster.hpp`, include the `Resource` header and define two resources,
    of which one is for the ship and another is for the asteroids:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中，包括`Resource`头文件，并定义两个资源，其中一个是用于飞船，另一个是用于小行星：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Open `jni/DroidBlaster.cpp` and initialize the `texture` resources in the constructor.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/DroidBlaster.cpp`并在构造函数中初始化`texture`资源。
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To ensure that the code is working, load textures in `onActivate()`. The textures
    can be loaded only after OpenGL is initialized by `GraphicsManager`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保代码正常工作，在`onActivate()`中加载纹理。纹理只能在`GraphicsManager`初始化后加载：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Before running `DroidBlaster`, add `asteroid.png` and `ship.png` into the `droidblaster/assets`
    directory (create it if it's necessary).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`DroidBlaster`之前，将`asteroid.png`和`ship.png`添加到`droidblaster/assets`目录中（如果需要，创建它）。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The PNG files are provided with this book in the `DroidBlaster_Part6/assets`
    directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PNG文件在本书的`DroidBlaster_Part6/assets`目录中提供。
- en: '*What just happened?*'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Run the application and you should not see much difference. Indeed, we have
    loaded two PNG textures, but we are not actually rendering them. However, if you
    check the logs, you should see traces showing that the textures are properly loaded
    and retrieved from the cache, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你不应该看到太大的差异。事实上，我们已经加载了两个PNG纹理，但我们实际上并没有渲染它们。然而，如果你检查日志，你应该看到迹象表明纹理已经被正确加载并从缓存中检索出来，如下图所示：
- en: '![What just happened?](img/9645OS_06_04.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_06_04.jpg)'
- en: 'Textures in OpenGL are objects (in the OpenGL way) which are in the form of
    an array of memory allocated on the **Graphical Processing Unit** (**GPU**) to
    store specific data. Storing graphics data in the GPU memory provides faster memory
    access than if it was stored in the main memory, which is a bit like a cache on
    a CPU. This efficiency comes at a price: texture loading is costly and must be
    performed as much as possible during startup.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中的纹理是对象（以OpenGL方式），它们是在**图形处理单元**（GPU）上分配的内存数组，用于存储特定数据。将图形数据存储在GPU内存中比存储在主内存中提供了更快的内存访问，有点像CPU上的缓存。这种效率是有代价的：纹理加载是昂贵的，必须在启动时尽可能多地执行。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The pixels of a texture are named **Texels**. Texel is the contraction of "**Texture
    Pixel**". Textures, and thus Texels, are projected on 3D objects during scene
    rendering.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的像素被称为**纹素**。纹素是“纹理像素”的缩写。纹理，因此纹素，在场景渲染期间投影在3D对象上。
- en: More about textures
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于纹理的更多信息
- en: An important requirement to remember while dealing with textures is their dimensions;
    OpenGL textures must have a power of two dimensions (for example, 128 or 256 pixels).
    Other dimensions will fail on most devices. These dimensions ease a technique
    called **MIPmapping** (**Multum In Parvo** (**MIP**), which mean much in little).
    MIPmaps are smaller versions of the same texture (see the following figure) applied
    selectively depending on the rendered object distance. They increase performance
    and reduce aliasing artifacts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理纹理时要记住的一个重要要求是它们的尺寸；OpenGL纹理必须具有二次幂的尺寸（例如，128或256像素）。其他尺寸在大多数设备上都会失败。这些尺寸简化了一种称为MIP贴图（Multum
    In Parvo，意思是少中多）的技术。MIP贴图是相同纹理的较小版本（见下图），根据渲染对象的距离选择性地应用。它们提高了性能并减少了走样伪影。
- en: '![More about textures](img/9645OS_06_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![关于纹理的更多信息](img/9645OS_06_08.jpg)'
- en: 'The texture configuration is set with `glTexParameteri()`. They need to be
    specified at the texture creation time only. The following two main kinds of parameters
    can be applied:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理配置是使用`glTexParameteri()`设置的。它们只需要在纹理创建时指定。可以应用以下两种主要类型的参数：
- en: '**Texture Filtering** with `GL_TEXTURE_MAG_FILTER` and `GL_TEXTURE_MIN_FILTER`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GL_TEXTURE_MAG_FILTER`和`GL_TEXTURE_MIN_FILTER`进行**纹理过滤**。
- en: These parameters control the way texture magnification and minification are
    performed, that is, the processing applied when texture is respectively smaller
    or bigger than the rasterized primitive. Two values are possible in this, as shown
    in the next figure.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数控制纹理放大和缩小时的处理方式，也就是在纹理分别比光栅化的基元小或大时应用的处理。在这里有两个可能的值，如下图所示。
- en: '`GL_LINEAR` interpolates textures drawn onscreen based on the closest texel
    colors (also known as Bilinear filtering). This calculation results in a smooth
    effect.`GL_NEAREST` displays the closest texel color without any interpolation.
    This value gives slightly better performance than `GL_LINEAR`.![More about textures](img/9645OS_06_06.jpg)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_LINEAR`根据最接近的纹素颜色对屏幕上绘制的纹理进行插值（也称为双线性过滤）。这种计算会产生平滑的效果。`GL_NEAREST`显示最接近的纹素颜色，没有任何插值。这个值比`GL_LINEAR`稍微更好一些。![关于纹理的更多信息](img/9645OS_06_06.jpg)'
- en: There exist variants that can be used in conjunction with MIPmaps to indicate
    how to apply minification; some of these variants are `GL_NEAREST_MIPMAP_NEAREST`,
    `GL_LINEAR_MIPMAP_NEAREST`, `GL_NEAREST_MIPMAP_LINEAR` and `GL_LINEAR_MIPMAP_LINEAR`
    (this one is better known as **Trilinear filtering**).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 存在可以与MIP贴图一起使用的变体，用于指示如何应用缩小；其中一些变体是`GL_NEAREST_MIPMAP_NEAREST`，`GL_LINEAR_MIPMAP_NEAREST`，`GL_NEAREST_MIPMAP_LINEAR`和`GL_LINEAR_MIPMAP_LINEAR`（这个更为人所知的是**三线性过滤**）。
- en: '**Texture Wrapping** with `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GL_TEXTURE_WRAP_S`和`GL_TEXTURE_WRAP_T`进行**纹理包裹**。
- en: 'These parameters control the way textures are repeated when texture coordinates
    go outside the range [0.0, 1.0]. S represents the X axis and T, the Y axis. Their
    different naming is used to avoid any confusion with position coordinates. They
    are often referred to as U and V. The following figure shows some of the possible
    values and their effect:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数控制纹理在纹理坐标超出范围[0.0, 1.0]时的重复方式。S代表X轴，T代表Y轴。它们的不同命名是为了避免与位置坐标混淆。它们通常被称为U和V。下图显示了一些可能的值及其效果：
- en: '![More about textures](img/9645OS_06_07.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![关于纹理的更多信息](img/9645OS_06_07.jpg)'
- en: 'A few good practices to remember while dealing with textures are:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 处理纹理时要记住一些好的做法：
- en: Switching textures is an expensive operation, so avoid OpenGL pipeline state
    changes as much as possible (binding a new texture and changing an option with
    `glEnable()` are examples of state changes).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换纹理是一项昂贵的操作，因此尽量避免OpenGL管线状态的更改（绑定新纹理和使用`glEnable()`更改选项是状态更改的例子）。
- en: Textures are probably the most memory and bandwidth consuming resources. Consider
    using **compressed** texture formats to greatly improve performances. Sadly, texture
    compression algorithms are rather tied to the hardware.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理可能是最占用内存和带宽的资源。考虑使用**压缩**纹理格式来大大提高性能。遗憾的是，纹理压缩算法与硬件相当紧密相关。
- en: Create big textures to pack, as much data as you can, even from multiple objects.
    This is known as **Texture Atlas**. For example, if you look at the ship and asteroid
    texture, you will find that several sprite images are packed in them (we could
    even pack more):![More about textures](img/9645OS_06_09.jpg)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建大纹理来打包，尽可能多地包含数据，甚至来自多个对象。这被称为纹理集。例如，如果你看船和小行星的纹理，你会发现其中包含了几个精灵图像（我们甚至可以再多包装一些）：![关于纹理的更多信息](img/9645OS_06_09.jpg)
- en: This introduction to textures gives a slight overview of what OpenGL ES can
    achieve. For more information about texturing, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Texture](http://www.opengl.org/wiki/Texture).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这对纹理的介绍略微概述了OpenGL ES的功能。有关纹理的更多信息，请查看OpenGL.org维基网站[http://www.opengl.org/wiki/Texture](http://www.opengl.org/wiki/Texture)。
- en: Drawing 2D sprites
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制2D精灵
- en: 2D games are based on **sprites**, which are pieces of images composited onscreen.
    They can represent an object, a character, a static, or an animated element. Sprites
    can be displayed with a transparency effect using the alpha channel of an image.
    Typically, an image will contain several frames for a sprite, each frame representing
    a different animation step or different objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏基于**精灵**，它们是在屏幕上合成的图像片段。它们可以代表一个对象，一个角色，一个静态或一个动画元素。精灵可以使用图像的alpha通道显示透明效果。通常，一个图像会包含几个帧用于一个精灵，每个帧代表不同的动画步骤或不同的对象。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need a powerful multiplatform image editor, consider using **GNU Image
    Manipulation Program** (**GIMP**). This program is available on Windows, Linux,
    and Mac OS X, and is a powerful and open source. You can download it from [http://www.gimp.org/](http://www.gimp.org/).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个功能强大的多平台图像编辑器，请考虑使用**GNU图像处理程序**（**GIMP**）。该程序可在Windows、Linux和Mac OS
    X上使用，是一个功能强大且开源的程序。您可以从[http://www.gimp.org/](http://www.gimp.org/)下载它。
- en: Several techniques exist to draw sprites using OpenGL. One of these is called
    **Sprite Batch**. This is one of the most efficient ways to create 2D games with
    OpenGL ES 2\. It is based on a vertex array (stored in main memory) that is regenerated
    during each frame with all the sprites to render. Rendering is performed with
    the help of a simple vertex shader that projects 2D coordinates onto the screen
    and a fragment shader that outputs the raw sprite texture color.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL存在多种绘制精灵的技术。其中之一称为**精灵批处理**。这是使用OpenGL ES 2创建2D游戏的最有效方式之一。它基于一个顶点数组（存储在主内存中），在每一帧都会重新生成，其中包含所有要呈现的精灵。渲染是通过一个简单的顶点着色器来执行的，它将2D坐标投影到屏幕上，并且一个片段着色器输出原始精灵纹理颜色。
- en: We are now going to implement a sprite batch to render the ship and multiple
    asteroids onscreen in `DroidBlaster`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要在`DroidBlaster`中实现一个精灵批处理程序，以在屏幕上呈现飞船和多个小行星。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part7`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part7`的名称提供。
- en: Time for action – initializing OpenGL ES
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-初始化OpenGL ES
- en: 'Let''s now see how to implement a sprite batch in DroidBlaster:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在DroidBlaster中实现精灵批处理程序：
- en: 'Modify `jni/GraphicsManager.hpp`. Create the class `GraphicsComponent`, which
    defines a common interface for all rendering techniques starting with sprite batches.
    Define a few new methods such as:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`jni/GraphicsManager.hpp`。创建类`GraphicsComponent`，它定义了所有渲染技术的通用接口，从精灵批处理开始。定义一些新的方法，比如：
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getProjectionMatrix()`提供一个OpenGL矩阵，用于在屏幕上投影2D图形'
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadShaderProgram()`用于加载顶点和片段着色器，并将它们链接到OpenGL程序中'
- en: '`registerComponent()` which records a list of `GraphicsComponent` to initialize
    and render'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerComponent()`记录要初始化和呈现的`GraphicsComponent`列表'
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`RenderVertex`私有结构，表示单个精灵顶点的结构。
- en: 'Also, declare a few new member variables such as:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 还要声明一些新的成员变量，例如：
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mProjectionMatrix`用于存储正交投影（而不是3D游戏中使用的透视投影）。'
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mShaders`，`mShaderCount`，`mComponents`和`mComponentCount`用于跟踪所有资源。'
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics, as shown in the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，摆脱在上一章中用于呈现原始图形的所有`GraphicsElement`内容，如下所示：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, define a few new methods in `GraphicsManager`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`GraphicsManager`中定义一些新的方法：
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getProjectionMatrix()`提供一个OpenGL矩阵，用于在屏幕上投影2D图形'
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadShaderProgram()`用于加载顶点和片段着色器，并将它们链接到OpenGL程序中'
- en: '`registerComponent()` which records a list of GraphicsComponent to initialize
    and render'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerComponent()`记录要初始化和呈现的GraphicsComponent列表'
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`RenderVertex`私有结构，表示单个精灵顶点的结构。
- en: 'Also, declare a few new member variables such as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 还要声明一些新的成员变量，例如：
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mProjectionMatrix`用于存储正交投影（而不是3D游戏中使用的透视投影）。'
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mShaders`，`mShaderCount`，`mComponents`和`mComponentCount`用于跟踪所有资源。'
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，摆脱在上一章中用于呈现原始图形的所有`GraphicsElement`内容：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Open `jni/GraphicsManager.cpp`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/GraphicsManager.cpp`。
- en: Update the constructor initialization list and the destructor. Again, get rid
    of everything related to `GraphicsElement`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 更新构造函数初始化列表和析构函数。再次，摆脱与`GraphicsElement`有关的一切。
- en: 'Also implement `registerComponent()` in place of `registerElement()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 还要实现`registerComponent()`来替代`registerElement()`：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Amend `onStart()` to initialize the **Orthographic** projection matrix array
    with display dimensions (we will see how to compute matrices more easily using
    GLM in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*) and load components.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onStart()`，用显示尺寸初始化**正交**投影矩阵数组（我们将在[第9章](ch09.html "第9章。将现有库移植到Android")中看到如何使用GLM更轻松地计算矩阵，*将现有库移植到Android*），并加载组件。
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A projection matrix is a mathematical way to project 3D objects composing a
    scene into a 2D plane, which is the screen. In orthographic projection, a projection
    is perpendicular to the display surface. That means that an object has exactly
    the same size whether it is close or far away from the point of view. Orthographic
    projection is appropriate for 2D games. **Perspective** projection, in which objects
    look smaller the farther they are, is rather used for 3D games.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 投影矩阵是将场景中组成的3D对象投影到屏幕的2D平面的数学方法。在正交投影中，投影是垂直于显示表面的。这意味着一个对象无论离观察点多近或多远，大小都是完全相同的。正交投影适用于2D游戏。**透视**投影，即对象随着距离的增加而变小，更适用于3D游戏。
- en: For more information, have a look at [http://en.wikipedia.org/wiki/Graphical_projection](http://en.wikipedia.org/wiki/Graphical_projection).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅[http://en.wikipedia.org/wiki/Graphical_projection](http://en.wikipedia.org/wiki/Graphical_projection)。
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Free any resources loaded with `loadShaderProgram()` in `stop()`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stop()`中释放使用`loadShaderProgram()`加载的任何资源。
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Render any registered components in `update()` after the display is cleared
    but before it is refreshed:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清除显示但刷新之前，更新`update()`中注册的任何组件：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the new method `loadShader()`. Its role is to compile and load the given
    shaders passed as a human-readable GLSL program. To do so:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的方法`loadShader()`。它的作用是编译和加载作为可读GLSL程序传递的给定着色器。
- en: Generate a new vertex shader with `glCreateShader()`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCreateShader()`生成一个新的顶点着色器。
- en: Upload the vertex shader source into OpenGL with `glShaderSource()`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glShaderSource()`将顶点着色器源上传到OpenGL。
- en: Compile the shader with `glCompileShader()` and check the compilation status
    with `glGetShaderiv()`. The compilation errors can be read with `glGetShaderInfoLog()`.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCompileShader()`编译着色器，并使用`glGetShaderiv()`检查编译状态。编译错误可以用`glGetShaderInfoLog()`读取。
- en: 'Repeat the operation for the given fragment shader:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的片段着色器重复此操作：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once compiled, link the compiled vertex and fragment shaders together. To do
    so:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编译完成，将编译的顶点和片段着色器链接在一起。
- en: Create a program object with `glCreateProgram()`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCreateProgram()`创建一个程序对象。
- en: Specify the shaders to use `glAttachShader()`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要使用的着色器`glAttachShader()`。
- en: Link them together with `glLinkProgram()` to create the final program. Shader
    consistencies and compatibility with the hardware is checked at that point. The
    result can be checked with `glGetProgramiv()`.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glLinkProgram()`将它们链接在一起，创建最终程序。在这一点上，检查着色器的一致性和与硬件的兼容性。结果可以用`glGetProgramiv()`检查。
- en: Finally, get rid of the shaders as they are useless once linked in a program.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，摆脱着色器，因为它们在链接到程序后就没有用了。
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create `jni/Sprite.hpp`, which defines a class with all the necessary data to
    animate and draw a single sprite.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Sprite.hpp`，定义一个包含所有必要数据以动画和绘制单个精灵的类。
- en: Create a `Vertex` structure which defines the content of a sprite vertex. We
    need a 2D position and texture coordinates which delimit the sprite picture.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Vertex`结构，定义精灵顶点的内容。我们需要2D位置和界定精灵图片的纹理坐标。
- en: 'Then, define a few methods:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义一些方法：
- en: Sprite animation can be updated and retrieved with `setAnimation()` and `animationEnded()`.
    Location is publicly available for simplicity purposes.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵动画可以通过`setAnimation()`和`animationEnded()`进行更新和检索。位置是公开可用的，以简化目的。
- en: Give privileged access to a component that we are going to define later, named
    `SpriteBatch`. It can `load()` and `draw()` sprites.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为将要定义的组件`SpriteBatch`提供特权访问。它可以`load()`和`draw()`精灵。
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, define a few properties:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一些属性：
- en: A texture containing the sprite sheet and its corresponding resource
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含精灵表和其对应资源的纹理
- en: '**Sprite frame data**: `mWidth` and `mHeight`, horizontal, vertical, and total
    number of frames in `mFrameXCount`, `mFrameYCount`, and `mFrameCount`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵帧数据**：`mWidth` 和 `mHeight`，水平、垂直以及总帧数分别为 `mFrameXCount`、`mFrameYCount`
    和 `mFrameCount`'
- en: '**Animation data**: first and total number of frames of an animation in `mAnimStartFrame`
    and `mAnimFrameCount`, animation speed in `mAnimSpeed`, the currently shown frame
    in `mAnimFrame`, and a looping indicator in `mAnimLoop`:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画数据**：动画的第一帧和总帧数分别为`mAnimStartFrame`和`mAnimFrameCount`，动画速度为`mAnimSpeed`，当前显示的帧为`mAnimFrame`，循环指示器为`mAnimLoop`：'
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Write the `jni/Sprite.cpp` constructor and initialize the members to default
    values:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`jni/Sprite.cpp`构造函数，并将成员初始化为默认值：
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Frame information (horizontal, vertical, and total number of frames) needs
    to be recomputed in `load()` as texture dimensions are known only at load time:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帧信息（水平、垂直和总帧数）需要在`load()`中重新计算，因为纹理尺寸只在加载时才知道：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'An animation starts from a given in the sprite sheet and ends after a certain
    amount of frames, whose number changes according to speed. An animation can loop
    to restart from the beginning when it is over:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画从精灵表中的给定位置开始，并在一定数量的帧后结束，其数量根据速度而变化。动画可以循环，在结束时重新开始：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `draw()`, first update the frame to draw according to the sprite animation
    and the time spent since the last frame. What we need is the indices of the frame
    in the spritesheet:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw()`中，根据精灵动画和上一帧之间的时间更新要绘制的帧。我们需要的是精灵表中帧的索引：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A sprite is composed of four vertices drawn in an output array, `pVertices`.
    Each of these vertices is composed of a sprite position (`posX1`, `posY1`, `posX2`,
    `posY2`) and texture coordinates (`u1`, `u2`, `v1`, `v2`). Compute and generate
    these vertices dynamically in the memory buffer, `pVertices`, provided in the
    parameter. This memory buffer will be given later to OpenGL to render the sprite:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个精灵由四个顶点组成，绘制在一个输出数组`pVertices`中。每个顶点由一个精灵位置(`posX1`, `posY1`, `posX2`, `posY2`)和纹理坐标(`u1`,
    `u2`, `v1`, `v2`)组成。在提供的内存缓冲区`pVertices`中动态计算和生成这些顶点。这个内存缓冲区稍后将被提供给OpenGL来渲染精灵：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Specify `jni/SpriteBatch.hpp` with methods such as:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/SpriteBatch.hpp`中指定方法，例如：
- en: '`registerSprite()` to add a new sprite to draw'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerSprite()`以添加新的精灵进行绘制'
- en: '`load()` to initialize all the registered sprites'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`以初始化所有注册的精灵'
- en: '`draw()` to effectively render all the registered sprites'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw()`以有效地渲染所有注册的精灵'
- en: 'We are going to need member variables:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要成员变量：
- en: A set of sprites to draw in `mSprites` and `mSpriteCount`
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组要在`mSprites`和`mSpriteCount`中绘制的精灵
- en: '`mVertices`, `mVertexCount`, `mIndexes`, and `mIndexCount`, which define a
    vertex and an index buffer'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mVertices`，`mVertexCount`，`mIndexes`和`mIndexCount`，定义了一个顶点和一个索引缓冲区'
- en: A shader program identified by `mShaderProgram`
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`mShaderProgram`标识的着色器程序
- en: 'The vertex and fragment shader parameters are:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器参数是：
- en: '`aPosition`, which is one of the sprite corner positions.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aPosition`，是精灵角位置之一。'
- en: '`aTexture`, which is the sprite corner texture coordinate. It defines the sprite
    to display in the sprite sheet.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aTexture`，是精灵角纹理坐标。它定义了要在精灵表中显示的精灵。'
- en: '`uProjection`, is the orthographic projection matrix.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uProjection`，是正交投影矩阵。'
- en: '`uTexture`, contains the sprite picture.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTexture`，包含精灵图片。'
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Implement the `jni/SpriteBach.cpp` constructor to initialize the default values.
    The component must register with `GraphicsManager` to be loaded and rendered.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/SpriteBach.cpp`构造函数以初始化默认值。该组件必须向`GraphicsManager`注册以加载和渲染。
- en: In the destructor, the allocated sprites must be freed when the component is
    destroyed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数中，当组件被销毁时，必须释放分配的精灵。
- en: '[PRE64]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The index buffer is rather static. We can precompute its content when a sprite
    is registered. Each index points to a vertex in the vertex buffer (0 representing
    the very first vertex, 1 the 2nd, and so on). As a sprite is represented by 2
    triangles of 3 vertices (to form a quad), we need 6 indexes per sprite:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引缓冲区相当静态。我们可以在注册精灵时预先计算其内容。每个索引指向顶点缓冲区中的一个顶点（0表示第一个顶点，1表示第二个顶点，依此类推）。由于一个精灵由3个顶点的2个三角形（形成一个四边形），因此每个精灵需要6个索引：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Write the GLSL vertex and fragment shaders as constant strings.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GLSL顶点和片段着色器编写为常量字符串。
- en: 'The shader code is written inside a `main()` function similar to what can be
    coded in C. As any normal computer program, shaders require variables to process
    data: attributes (per-vertex data like the position), uniforms (global parameters
    per draw call), and varying (values interpolated per fragment like the texture
    coordinates).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器代码写在`main()`函数中，类似于C中的编码。与任何正常的计算机程序一样，着色器需要变量来处理数据：属性（每个顶点的数据，如位置），统一（每次绘制调用的全局参数）和varying（每个片段插值的值，如纹理坐标）。
- en: 'Here, texture coordinates are passed to the fragment shader in `vTexture`.
    The vertex position is transformed from a 2D vector to a 4D vector into a predefined
    GLSL variable `gl_Position`. The fragment shader retrieves interpolated texture
    coordinates in `vTexture`. This information is used as an index in the predefined
    function `texture2D()` to access the texture color. Color is saved in the predefined
    output variable `gl_FragColor`, which represents the final pixel:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，纹理坐标在`vTexture`中传递给片段着色器。顶点位置从2D向量转换为预定义的GLSL变量`gl_Position`中的4D向量。片段着色器在`vTexture`中检索插值的纹理坐标。这些信息被用作预定义函数`texture2D()`中的索引，以访问纹理颜色。颜色保存在预定义的输出变量`gl_FragColor`中，表示最终像素：
- en: '[PRE66]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Load the shader program and retrieve the shader attributes and uniform identifiers
    in `load()`. Then, initialize sprites, as shown in the following code:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载着色器程序并在`load()`中检索着色器属性和统一标识符。然后，初始化精灵，如下面的代码所示：
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Write `draw()`, which executes the OpenGL sprite rendering logic.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`draw()`，执行OpenGL精灵渲染逻辑。
- en: 'First, select the sprite shader and pass its parameters: the matrix and the
    texture uniforms:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先选择精灵着色器并传递其参数：矩阵和纹理统一：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, indicate to OpenGL how the position and UV coordinates are stored in
    the vertex buffer with `glEnableVertexAttribArray()` and `glVertexAttribPointer()`.
    These calls basically describe the `mVertices` structure. Note how vertex data
    is linked to shader attributes:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`glEnableVertexAttribArray()`和`glVertexAttribPointer()`指示OpenGL如何在顶点缓冲区中存储位置和UV坐标。这些调用基本上描述了`mVertices`的结构。注意顶点数据如何与着色器属性相关联：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Activate transparency using a blending function to draw sprites over the background,
    or other sprites:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合函数激活透明度，以在背景或其他精灵上绘制精灵：
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Tip
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information about the blending modes provided by OpenGL, have a look
    at [https://www.opengl.org/wiki/Blending](https://www.opengl.org/wiki/Blending).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenGL提供的混合模式的更多信息，请查看[https://www.opengl.org/wiki/Blending](https://www.opengl.org/wiki/Blending)。
- en: We can now start the rendering loop to render all sprites in a batch.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始渲染循环，以批处理的方式渲染所有精灵。
- en: 'The first outer loop basically iterates over textures. Indeed, the pipeline
    state changes in OpenGL are costly. Methods like `glBindTexture()` should be called
    as little as possible to guarantee performance:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个外部循环基本上是在纹理上进行迭代。实际上，OpenGL中的管道状态更改是昂贵的。应尽可能少地调用诸如`glBindTexture()`之类的方法，以保证性能：
- en: '[PRE71]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The inner loop generates vertices for all sprites with the same texture:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环为所有具有相同纹理的精灵生成顶点：
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Each time the texture changes, render the bunch of sprites with `glDrawElements()`.
    The vertex buffer specified earlier is combined with the index buffer given here
    to render the right sprites with the right texture. At this point, draw calls
    are sent to OpenGL, which executes the shader program:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次纹理更改时，使用`glDrawElements()`渲染一堆精灵。 之前指定的顶点缓冲区与此处给出的索引缓冲区结合在一起，以使用正确的纹理渲染正确的精灵。
    在这一点上，绘制调用被发送到OpenGL，后者执行着色器程序：
- en: '[PRE73]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When all sprites are rendered, restore the OpenGL state:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有精灵都被渲染后，恢复OpenGL状态：
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Update `jni/Ship.hpp` with the new sprite system. You can remove the previous
    `GraphicsElement` stuff:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的精灵系统更新`jni/Ship.hpp`。 您可以删除先前的`GraphicsElement`内容：
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The file `jni/Ship.cpp` does not change much apart from the `Sprite` type:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`jni/Ship.cpp`除了`Sprite`类型之外并没有太多改变：
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Include the new `SpriteBatch` component in `jni/DroidBlaster.hpp`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中包含新的`SpriteBatch`组件。
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In `jni/DroidBlaster.cpp`, define some new constants with animation properties.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`中，使用动画属性定义一些新的常量。
- en: Then, use the `SpriteBatch` component to register the ship and asteroids graphics.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`SpriteBatch`组件注册飞船和陨石图形。
- en: 'Remove the previous stuff related to `GraphicsElement` again:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 再次删除与“GraphicsElement”相关的先前内容：
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We do not need to load textures manually in `onActivate()` anymore. Sprites
    will handle this for us.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要在`onActivate()`中手动加载纹理。 精灵将为我们处理这个。
- en: 'Finally, release the graphic resources in `onDeactivate()`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`onDeactivate()`中释放图形资源：
- en: '[PRE79]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '*What just happened?*'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Launch DroidBlaster. You should now see an animated ship surrounded by frightening
    rotating asteroids:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 启动DroidBlaster。 您现在应该看到一个被恐怖的旋转陨石包围的动画飞船：
- en: '![What just happened?](img/9645OS_06_02.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_06_02.jpg)'
- en: In this part, we have seen how to draw a sprite efficiently with the help of
    the Sprite Batch technique. Indeed, a common cause of bad performance in OpenGL
    programs lies in state changes. Changing the OpenGL device state (for example,
    binding a new buffer or texture, changing an option with `glEnable()`, and so
    on) is a costly operation and should be avoided as much as possible. Thus, a good
    practice to maximize OpenGL performance is to order draw calls and change only
    the needed states.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们已经看到了如何利用精灵批处理技术有效地绘制精灵。 实际上，OpenGL程序性能不佳的一个常见原因在于状态更改。 更改OpenGL设备状态（例如，绑定新缓冲区或纹理，使用`glEnable()`更改选项等）是一项昂贵的操作，应尽量避免。
    因此，最大化OpenGL性能的一个良好实践是对绘制调用进行排序，并仅更改所需的状态。
- en: Tip
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One of the best OpenGL ES documentation is available from the Apple developer
    site at [https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/](https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果开发者网站上提供了一份最好的OpenGL ES文档，网址是[https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/](https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/)。
- en: But first, let's see more about the way OpenGL stores vertices in memory and
    the basics of OpenGL ES shaders.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们更多地了解OpenGL如何在内存中存储顶点以及OpenGL ES着色器的基础知识。
- en: Vertex Arrays versus Vertex Buffer Object
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点数组与顶点缓冲对象
- en: '**Vertex** **Arrays** (**VA**) and **Vertex Buffer Objects** (**VBO**) are
    the two main ways to manage vertices in OpenGL ES. Like with textures, multiple
    VAs/VBOs can be bound simultaneously to one vertex shader.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点数组**（**VA**）和**顶点缓冲对象**（**VBO**）是在OpenGL ES中管理顶点的两种主要方法。 与纹理一样，多个VA/VBO可以同时绑定到一个顶点着色器。'
- en: 'There are two main ways to manage vertices in OpenGL ES:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES中管理顶点的两种主要方法：
- en: In main memory (that is, in RAM), we talk about Vertex Arrays (abbreviated VA).
    Vertex arrays are transmitted from the CPU to the GPU for each draw call. As a
    consequence, they are slower to render, but also much easier to update. Thus,
    they are appropriate when a mesh of vertices is changing frequently. This explains
    the decision to use a vertex array to implement sprite batches; each sprite is
    updated each time a new frame is rendered (position, as well as texture coordinates,
    to switch to a new frame).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主内存（即RAM）中，我们谈论顶点数组（缩写为VA）。 顶点数组在每次绘制调用时从CPU传输到GPU。 因此，它们渲染速度较慢，但更新也更容易。 因此，当顶点网格频繁更改时，它们是合适的。
    这解释了使用顶点数组来实现精灵批处理的决定； 每次渲染新帧时，每个精灵都会更新（位置以及纹理坐标以切换到新帧）。
- en: In driver memory (generally in GPU memory or **VRAM**), we talk about **Vertex
    Buffers Objects**. Vertex buffers are faster to draw but more expensive to update.
    Thus, they are often used to render static data that never changes. You can still
    transform it with vertex shaders, which we are going to see in the next part.
    Note that some hints can be provided to the driver during initialization (`GL_DYNAMIC_DRAW`)
    to allow fast updates but at the price of more complex buffer management (that
    is, multiple buffering).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在驱动程序内存中（通常在GPU内存或VRAM中），我们谈论**顶点缓冲对象**。 顶点缓冲区绘制速度更快，但更新更昂贵。 因此，它们通常用于渲染永远不会更改的静态数据。
    您仍然可以使用顶点着色器对其进行转换，我们将在下一部分中看到。 请注意，在初始化期间可以向驱动程序提供一些提示（`GL_DYNAMIC_DRAW`），以允许快速更新，但代价是更复杂的缓冲区管理（即，多重缓冲）。
- en: 'After transformation, the vertices are connected together during the primitive
    assembly stage. They can be assembled in the following ways:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，顶点在原始组装阶段连接在一起。 它们可以以以下方式组装：
- en: As lists 3 by 3 (which can lead to vertex duplication), in fans, in strips,
    and so on; in which case, we use `glDrawArrays()`.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以3x3列表（可能导致顶点重复），以扇形，以条带等方式； 在这种情况下，我们使用`glDrawArrays()`。
- en: Using an index buffers which specifies 3 by 3, where vertices are connected
    together. Index buffers are often the best way to achieve better performance.
    Indices need to be sorted to favor caching. Indices are drawn with their associated
    VBO or VA using `glDrawElements()`.![Vertex Arrays versus Vertex Buffer Object](img/9645OS_06_10.jpg)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定3x3的索引缓冲区，其中顶点连接在一起。索引缓冲区通常是实现更好性能的最佳方式。需要对索引进行排序以支持缓存。使用`glDrawElements()`绘制与其关联的VBO或VA的索引。![顶点数组与顶点缓冲对象](img/9645OS_06_10.jpg)
- en: 'Some good practices to remember when you''re dealing with vertices are:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 处理顶点时要记住一些良好的实践：
- en: Pack as many vertices in each buffer as you can, even from multiple meshes.
    Indeed, switching from one set of vertices to another, either a VA or a VBO, is
    slow.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能多地将顶点打包到每个缓冲区中，即使来自多个网格。实际上，从一个顶点集切换到另一个顶点集，无论是VA还是VBO，都很慢。
- en: Avoid updating static vertex buffers at runtime.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在运行时更新静态顶点缓冲区。
- en: Make vertex structure the size of a power of 2 (in bytes) to favor data alignment.
    It is often preferred to pad data rather than to transmit unaligned data because
    of the way GPU processes it.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使顶点结构的大小为2的幂（以字节为单位），以支持数据对齐。通常更喜欢填充数据而不是传输不对齐的数据，因为GPU处理数据的方式。
- en: For more information about vertex management, have a look at the OpenGL.org
    wiki at [http://www.opengl.org/wiki/Vertex_Specification](http://www.opengl.org/wiki/Vertex_Specification)
    and [http://www.opengl.org/wiki/Vertex_Specification_Best_Practices](http://www.opengl.org/wiki/Vertex_Specification_Best_Practices).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有关顶点管理的更多信息，请查看OpenGL.org维基网站[http://www.opengl.org/wiki/Vertex_Specification](http://www.opengl.org/wiki/Vertex_Specification)和[http://www.opengl.org/wiki/Vertex_Specification_Best_Practices](http://www.opengl.org/wiki/Vertex_Specification_Best_Practices)。
- en: Rendering particle effects
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染粒子效果
- en: DroidBlaster needs a background to make it more pleasant-looking. As the action
    is located in space, what about a falling star to give an impression of speed?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: DroidBlaster需要一个背景，使其看起来更愉快。由于动作发生在太空中，那么加上一颗流星会给人一种速度的印象如何？
- en: Such an effect can be simulated in several ways. One possible choice consists
    of showing a particle effect, where each particle corresponds to a star. OpenGL
    provides such a feature through **Point** **Sprites**. A point sprite is a special
    kind of element that requires only one vertex to draw a sprite. Combined with
    a whole vertex buffer, many sprites can be drawn at the same time efficiently.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过几种方式模拟这种效果。一种可能的选择是显示一个粒子效果，其中每个粒子对应一个星星。OpenGL通过**Point** **Sprites**提供了这样的功能。点精灵是一种特殊的元素，只需要一个顶点来绘制一个精灵。结合整个顶点缓冲区，可以有效地同时绘制许多精灵。
- en: Point sprites are usable with vertex and fragment shaders. To be even more efficient,
    we can use their power to process particle movement directly inside the shaders.
    Thus, we will not need to regenerate the vertex buffer each time a particle changes,
    like we have to do with sprite batches.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵可与顶点和片段着色器一起使用。为了更有效，我们可以利用它们的能力直接在着色器内部处理粒子运动。因此，我们将不需要在粒子发生变化时每次重新生成顶点缓冲区，就像我们必须使用精灵批处理一样。
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part8`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part8`的名称提供。
- en: Time for action – rendering a star field
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-渲染星空
- en: 'Let''s now see how to apply this particle effect in `DroidBlaster`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在`DroidBlaster`中应用这种粒子效果：
- en: In `jni/GraphicsManager.hpp`, define a new method to load a vertex buffer.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.hpp`中，定义一个新方法来加载顶点缓冲区。
- en: 'Add an array to store vertex buffer resources:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个数组来存储顶点缓冲区资源：
- en: '[PRE80]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In `jni/GraphicsManager.cpp`, update the constructor initialization list and
    free vertex buffer resources in `stop()`:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.cpp`中，更新构造函数初始化列表，并在`stop()`中释放顶点缓冲区资源：
- en: '[PRE81]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create the new method `loadVertexBuffer()` to upload the data from the given
    memory location into an OpenGL vertex buffer. As opposed to the SpriteBatch example,
    which uses a dynamic vertex buffer in computer memory, the following vertex buffer
    is static and located in GPU memory. This makes it faster but quite inflexible
    too. To do so:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新方法`loadVertexBuffer()`，将给定内存位置的数据上传到OpenGL顶点缓冲区。与SpriteBatch示例相反，SpriteBatch示例在计算机内存中使用动态顶点缓冲区，而以下顶点缓冲区是静态的并位于GPU内存中。这使其更快，但也相当不灵活。为此：
- en: Generate a buffer identifier with `glGenBuffers()`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glGenBuffers()`生成缓冲区标识符。
- en: Indicate that we are working on a vertex buffer with `glBindBuffer()`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glBindBuffer()`指示我们正在处理顶点缓冲区。
- en: Push the vertex data from the given memory location into OpenGL vertex buffer
    with `glBufferData()`.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glBufferData()`将给定内存位置的顶点数据推送到OpenGL顶点缓冲区中。
- en: Unbind the vertex buffer to put OpenGL back in its previous state. This is not
    strictly necessary, like for textures, but it helps avoiding configuration mistakes
    in future draw calls.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消绑定顶点缓冲区以将OpenGL恢复到先前的状态。这不是严格必要的，就像纹理一样，但它有助于避免未来绘制调用中的配置错误。
- en: 'You can check that the vertex buffer has been created properly with `glGetError()`:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`glGetError()`检查顶点缓冲区是否已正确创建：
- en: '[PRE82]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Define the new `StarField` component in `jni/StarField.hpp`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/StarField.hpp`中定义新的`StarField`组件。
- en: Override `the GraphicsComponent` methods, as done previously.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖`GraphicsComponent`方法，就像以前一样。
- en: Define a specific `Vertex` structure with 3 coordinates `x`, `y`, and `z`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用3个坐标`x`，`y`和`z`定义特定的`Vertex`结构。
- en: A star field is characterized by the number of stars in `mStarCount` and a texture
    that represents a single one in `mTextureResource`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 星空的特征是`mStarCount`中的星星数量和代表单个星星的纹理`mTextureResource`。
- en: 'We will need some OpenGL resources: a vertex buffer, a texture, and a shader
    program with its variables:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些OpenGL资源：顶点缓冲区、纹理和着色器程序及其变量：
- en: '`aPosition`, which is the star position.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aPosition`是星星的位置。'
- en: '`uProjection`, which is the orthographic projection matrix.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uProjection`是正交投影矩阵。'
- en: '`uTime`, which is the total elapsed time given by `TimeManager`. This is necessary
    to simulate the movement of stars.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTime`是由`TimeManager`给出的总经过时间。这对于模拟星星的运动是必要的。'
- en: '`uHeight`, which is the height of the display. The stars are going to be recycled
    when they reach the screen boundaries.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uHeight`，这是显示的高度。当星星到达屏幕边界时，它们将被回收利用。'
- en: '`uTexture`, which contains the star picture.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTexture`，其中包含星星图片。'
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create `jni/StarField.cpp` and implement its constructor:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/StarField.cpp`并实现它的构造函数：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The star field logic is mostly implemented in the vertex shader. Each star,
    represented by a single vertex, is moved from top to bottom according to time,
    speed (which is constant), and star distance. The farther it is (distance being
    determined by the `z` vertex component), the slower it scrolls.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星星字段逻辑主要在顶点着色器中实现。每颗星星，由一个单独的顶点表示，根据时间、速度（恒定的）和星星距离从上到下移动。它离得越远（距离由`z`顶点分量确定），滚动得越慢。
- en: The GLSL function `mod`, which stands for modulo, resets the star position when
    it has reached the bottom of the screen. The final star position is saved in the
    predefined variable `gl_Position`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL函数`mod`代表取模，当星星位置到达屏幕底部时重置星星位置。最终星星位置保存在预定义变量`gl_Position`中。
- en: 'The star size on screen is also a function of its distance. The size is saved
    in the predefined variable `gl_PointSize` in pixel units:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的星星大小也是其距离的函数。大小以像素单位保存在预定义变量`gl_PointSize`中：
- en: '[PRE85]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The fragment shader is much simpler and only draws the star texture onscreen:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器要简单得多，只在屏幕上绘制星星纹理：
- en: '[PRE86]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the `load()` function, generate the vertex buffer with the help of the `loadVertexBuffer()`
    method implemented in `GraphicsManager`. Each star is represented by a single
    vertex. The position on screen and depth are generated randomly. Depth is determined
    on a [0.0, 1.0] scale. Once this is done, release the temporary memory buffer
    holding the star field data:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`load()`函数中，使用`GraphicsManager`中实现的`loadVertexBuffer()`方法生成顶点缓冲区。每颗星星由一个单独的顶点表示。屏幕上的位置和深度是随机生成的。深度是根据[0.0,
    1.0]范围确定的。一旦完成，释放临时内存缓冲区中保存星星字段数据：
- en: '[PRE87]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, load the `star` texture and generate the program from the shaders defined
    above. Retrieve their attribute and uniform identifiers:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载`star`纹理并从上面定义的着色器生成程序。检索它们的属性和统一标识符：
- en: '[PRE88]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, render the `star` field by sending the static vertex buffer, the texture,
    and the shader program together in one draw call. To do so:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在一个绘制调用中一起发送静态顶点缓冲区、纹理和着色器程序来渲染`star`字段。为此：
- en: Disable blending, that is, the management of transparency. Indeed, the star
    "particles" are small, sparse, and drawn over a black background.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用混合，也就是透明度的管理。实际上，星星“粒子”很小，稀疏，并且在黑色背景上绘制。
- en: Select the vertex buffer first with `glBindBuffer()`. This call is necessary
    when a static vertex buffer has been generated at load time.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先用`glBindBuffer()`选择顶点缓冲区。当在加载时生成了静态顶点缓冲区时，这个调用是必要的。
- en: Indicate how vertex data is structured with `glVertexAttribPointer()`, and to
    which shader attributes it relates with `glEnableVertexAttribArray()`. Note that
    the last parameter of `glVertexAttribPointer()` is not a pointer to a buffer this
    time but an index within the vertex buffer. Indeed, the vertex buffer is static,
    and in GPU memory, so we do not know its address.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`glVertexAttribPointer()`指示顶点数据的结构，用`glEnableVertexAttribArray()`指示它与哪个着色器属性相关。注意`glVertexAttribPointer()`的最后一个参数这次不是指向缓冲区的指针，而是顶点缓冲区内的索引。实际上，顶点缓冲区是静态的，在GPU内存中，所以我们不知道它的地址。
- en: Select the texture to draw with `glActiveTexture()` and `glBindTexture()`.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`glActiveTexture()`和`glBindTexture()`选择要绘制的纹理。
- en: Select the shader program with `glUseProgram()`.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`glUseProgram()`选择着色器程序。
- en: Bind the program parameters with `glUniform` function variants.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`glUniform`函数变体绑定程序参数。
- en: Finally, send the draw call to OpenGL with `glDrawArrays()`.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`glDrawArrays()`将绘制调用发送到OpenGL。
- en: 'You can then restore the OpenGL pipeline state:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以恢复OpenGL管线状态：
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In `jni/DroidBlaster.hpp`, define the new `StarField` component along with
    a new texture resource:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中，定义新的`StarField`组件以及一个新的纹理资源：
- en: '[PRE90]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Instantiate it in the `jni/DroidBlaster.cpp` constructor with `50` stars:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`构造函数中用`50`颗星星实例化它：
- en: '[PRE91]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Before running `DroidBlaster`, add `droidblaster/star.png` into the assets directory.
    These files are provided with this book in the `DroidBlaster_Part8/assets` directory.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`DroidBlaster`之前，将`droidblaster/star.png`添加到资产目录中。这些文件在本书的`DroidBlaster_Part8/assets`目录中提供。
- en: '*What just happened?*'
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Run `DroidBlaster`. The star field should look as shown in the following screenshot,
    when scrolling through the screen at a random pace:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`DroidBlaster`。当以随机速度滚动屏幕时，星空应该看起来如下截图所示：
- en: '![What just happened?](img/9645OS_06_03.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645OS_06_03.jpg)'
- en: 'All of these stars are rendered as point sprites, where each point represents
    a quad determined by:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些星星都被渲染为点精灵，其中每个点代表一个由以下确定的四边形：
- en: '**A position on screen**: The position represents the center of the point sprite'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕上的位置**：位置代表点精灵的中心'
- en: '**A point size**: The size defines implicitly the point sprite quad'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个点的大小**：大小隐式地定义了点精灵四边形'
- en: 'Point sprites are an interesting way to create particle effects, but, they
    have a few drawbacks, which are:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵是创建粒子效果的一种有趣的方式，但它们有一些缺点，包括：
- en: 'Their possible size is more or less limited depending on the hardware capabilities.
    You can find the maximum size by querying `GL_ALIASED_POINT_SIZE_RANGE` with `glGetFloatv()`;
    look at the following example for this:'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的可能大小更多或少取决于硬件能力。你可以通过使用`glGetFloatv()`查询`GL_ALIASED_POINT_SIZE_RANGE`来找到最大大小；看下面的例子：
- en: '[PRE92]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you draw bigger point sprites, you will notice that the particles are clipped
    (that is, masked) at their center and the whole sprite boundaries don't get out
    of screen.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你绘制更大的点精灵，你会注意到粒子在它们的中心被裁剪（也就是被遮罩），整个精灵边界不会超出屏幕。
- en: Thus, depending on your needs, it might be more appropriate to use classic vertices.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据你的需求，使用经典顶点可能更合适。
- en: Talking about vertices, you may have noticed that we have not created a vertex
    array but a vertex buffer object. Indeed, point sprites are evaluated completely
    in the vertex shader. This optimization allows us to use a static geometry (`glBufferData()`
    with the hint `GL_STATIC_DRAW`) which can be managed efficiently by the driver.
    Note that vertex buffer objects can also be marked as being subject to updates
    using the hint `GL_DYNAMIC_DRAW` (which means buffer will change frequently) or
    `GL_STREAM_DRAW` (which means buffer will be used once and thrown). The process
    of creating a VBO is similar to the process of creating any other kind of object
    in OpenGL, and involves generating a new identifier, selecting it, and finally
    uploading data in driver memory. If you understand this process, you understand
    the way OpenGL works.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到顶点，您可能已经注意到我们没有创建顶点数组，而是创建了顶点缓冲对象。事实上，点精灵完全在顶点着色器中进行评估。这种优化允许我们使用静态几何体（使用`glBufferData()`和提示`GL_STATIC_DRAW`）来有效地由驱动程序管理。请注意，顶点缓冲对象也可以使用提示`GL_DYNAMIC_DRAW`（表示缓冲区将经常更改）或`GL_STREAM_DRAW`（表示缓冲区将被使用一次然后丢弃）标记为需要更新。创建VBO的过程类似于在OpenGL中创建任何其他类型的对象的过程，涉及生成新标识符，选择它，最后在驱动程序内存中上传数据。如果您了解此过程，您就了解了OpenGL的工作方式。
- en: Programming shaders with GLSL
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GLSL编程着色器
- en: 'Shaders are written in GLSL, a (relatively) high-level programming language
    which allows defining functions (with in, out, and inout parameters), conditionals,
    loops, variables, arrays, structures, arithmetic operators, and so on. It abstracts
    as much as possible hardware specificities. GLSL allows the following kind of
    variables to be used:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是用GLSL编写的，这是一种（相对）高级的编程语言，允许定义函数（带有in、out和inout参数）、条件、循环、变量、数组、结构、算术运算符等等。它尽可能地抽象硬件特性。GLSL允许使用以下类型的变量：
- en: '| **attributes** | These contain per-vertex data, such as vertex position or
    texture coordinates. Only one vertex is processed each time the shader executes.
    |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| **attributes** | 这些包含每个顶点的数据，比如顶点位置或纹理坐标。每次着色器执行时只处理一个顶点。 |'
- en: '| **const** | It represents compile-time constants or read-only function parameters.
    |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| **const** | 它代表编译时常量或只读函数参数。 |'
- en: '| **uniforms** | These are a kind of global parameter that can be changed per
    primitive (that is, per draw call). It has the same value for a whole mesh. An
    example of this could be a model-view matrix (for a vertex shader) or a texture
    (for a fragment shader). |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| **uniforms** | 这些是一种全局参数，可以根据基元（即每次绘制调用）进行更改。对于整个网格，它具有相同的值。一个例子是模型视图矩阵（对于顶点着色器）或纹理（对于片段着色器）。'
- en: '| **varying** | These are per-pixel interpolated values computed according
    to the vertex shader output. They are an output parameter in vertex shaders and
    an input parameter in fragment shaders. In OpenGL ES 3, the "varying" parameters
    have a new syntax: `out` in a vertex shader and `in` in a pixel shader. |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| **varying** | 这些是根据顶点着色器输出计算的每像素插值值。它们是顶点着色器的输出参数，是片段着色器的输入参数。在OpenGL ES
    3中，“varying”参数有一个新的语法：在顶点着色器中是`out`，在像素着色器中是`in`。'
- en: 'The main types of parameters allowed to declare such variables are shown in
    the following table:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 允许声明此类变量的主要参数类型如下表所示：
- en: '| **void** | This is for function result only. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| **void** | 这仅用于函数结果。 |'
- en: '| **bool** | This is a boolean value. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **bool** | 这是一个布尔值。 |'
- en: '| **float** | This is a floating point value. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **float** | 这是一个浮点值。 |'
- en: '| **int** | This is a signed integer value. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| **int** | 这是一个有符号整数值。 |'
- en: '| **vec2, vec3, vec4** | This is a floating point vector. Vectors exist for
    other types such as `bvec` for booleans or `ivec` for signed integer. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| **vec2, vec3, vec4** | 这是浮点向量。还有其他类型的向量，比如`bvec`表示布尔值，`ivec`表示有符号整数。 |'
- en: '| **mat2, mat3, mat4** | These are 2x2, 3x3, and 4x4 floating point matrices.
    |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| **mat2, mat3, mat4** | 这些是2x2、3x3和4x4的浮点矩阵。 |'
- en: '| **sampler2D** | This gives access to 2D texture texels. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| **sampler2D** | 这可以访问2D纹理texels。 |'
- en: 'Note that the GLSL specification provides some predefined variables, such as
    the ones shown in the following table:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GLSL规范提供了一些预定义变量，例如下表中所示的变量：
- en: '| **highp vec4 gl_Position** | Vertex shader Output | This is the transformed
    vertex position. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| **highp vec4 gl_Position** | 顶点着色器输出 | 这是变换后的顶点位置。 |'
- en: '| **mediump float gl_PointSize** | Vertex shader Output | This is the size
    of a point sprite in pixels (more about this will be discussed in the next part).
    |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| **mediump float gl_PointSize** | 顶点着色器输出 | 这是点精灵的像素大小（关于这一点将在下一部分讨论）。 |'
- en: '| **mediump vec4 gl_FragCoord** | Fragment shader Input | These are the coordinates
    of the fragment within framebuffer. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| **mediump vec4 gl_FragCoord** | 片段着色器输入 | 这些是帧缓冲内片段的坐标。 |'
- en: '| **mediump vec4****gl_FragColor** | Fragment shader Output | This is the color
    to display for the fragment. |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| **mediump vec4****gl_FragColor** | 片段着色器输出 | 这是片段显示的颜色。 |'
- en: Numerous functions, mostly arithmetic, are also provided, such as `sin()`, `cos()`,
    `tan()`, `radians()`, `degrees()`, `mod()`, `abs()`, `floor()`, `ceil()`, `dot()`,
    `cross()`, `normalize()`, `texture2D()`, and so on.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了许多函数，主要是算术函数，比如`sin()`、`cos()`、`tan()`、`radians()`、`degrees()`、`mod()`、`abs()`、`floor()`、`ceil()`、`dot()`、`cross()`、`normalize()`、`texture2D()`等等。
- en: 'These are some of the best practices to remember while dealing with shaders:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理着色器时要记住的一些最佳实践：
- en: Do not compile or link shaders at runtime.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在运行时编译或链接着色器。
- en: Beware of different hardware that has different capabilities and, more specifically,
    a limited number of variables allowed.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注意不同的硬件具有不同的功能，特别是允许的变量数量有限。
- en: Find a good trade-off between performance and accuracy while defining precision
    specifiers (for example, `highp`, `medium`, or `lowp`). Do not hesitate to redefine
    them to get consistent behavior. Note that a `float` precision specifier should
    be defined in the GLES fragment shaders.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义精度限定符（例如`highp`、`medium`或`lowp`）时，要在性能和精度之间找到一个好的折衷方案。不要犹豫重新定义它们以获得一致的行为。请注意，在GLES片段着色器中应该定义`float`精度限定符。
- en: Avoid conditional branches as much as possible.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免条件分支。
- en: For more information, have a look at OpenGL.org wiki at [http://www.opengl.org/wiki/OpenGL_Shading_Language](http://www.opengl.org/wiki/OpenGL_Shading_Language),
    [http://www.opengl.org/wiki/Vertex_Shader](http://www.opengl.org/wiki/Vertex_Shader)
    and [http://www.opengl.org/wiki/Fragment_Shader](http://www.opengl.org/wiki/Fragment_Shader).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看[http://www.opengl.org/wiki/OpenGL_Shading_Language](http://www.opengl.org/wiki/OpenGL_Shading_Language)的OpenGL.org
    wiki，[http://www.opengl.org/wiki/Vertex_Shader](http://www.opengl.org/wiki/Vertex_Shader)和[http://www.opengl.org/wiki/Fragment_Shader](http://www.opengl.org/wiki/Fragment_Shader)。
- en: Beware, as the content of these pages is applicable to OpenGL but not necessarily
    to GLES.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些页面的内容适用于OpenGL，但不一定适用于GLES。
- en: Adapting graphics to various resolutions
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图形调整为各种分辨率
- en: A complex subject to handle while writing a game is the Android screen size
    fragmentation. Low-end phones have resolutions of a few hundred pixels, whereas
    some high-end devices provide resolutions of more than two thousand.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 编写游戏时处理的一个复杂主题是Android屏幕尺寸的碎片化。低端手机的分辨率为几百像素，而一些高端设备的分辨率超过两千。
- en: There exist several ways to handle various screen sizes. We can adapt graphic
    resources, use black bands around the screen, or apply and adapt responsive designs
    to games.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 处理各种屏幕尺寸的方法有几种。我们可以调整图形资源，在屏幕周围使用黑色条带，或者应用和调整响应式设计到游戏中。
- en: Another simple solution consists of rendering the game scene off-screen with
    a fixed size. The off-screen framebuffer is then copied onto the screen and scaled
    to an appropriate size. This *one size fits all* technique does not provide the
    best quality and might be a bit slow on low-end devices (especially if they have
    a lower resolution than the off-screen framebuffer). However, it is quite simple
    to apply.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的解决方案是使用固定大小在屏幕外渲染游戏场景。然后将屏幕外帧缓冲区复制到屏幕上，并缩放到适当的大小。这种“一刀切”的技术并不能提供最佳质量，并且在低端设备上可能有点慢（特别是如果它们的分辨率低于屏幕外帧缓冲区）。但是，这种方法非常简单易行。
- en: Note
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part9`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目名称为`DroidBlaster_Part9`。
- en: Time for action – adapting resolution with off-screen rendering
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动-使用屏幕外渲染调整分辨率的时间
- en: 'Let''s render the game scene off-screen:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在屏幕外渲染游戏场景：
- en: 'Change `jni/GraphicsManager.hpp`, followed by these steps:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`jni/GraphicsManager.hpp`，然后按照以下步骤进行：
- en: Define new getter methods for the screen width and height with their corresponding
    member variables
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为屏幕宽度和高度定义新的getter方法及其对应的成员变量
- en: 'Create a new function `initializeRenderBuffer()`, which creates an off-screen
    buffer to render the scene:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新函数`initializeRenderBuffer()`，它创建一个屏幕外缓冲区来渲染场景：
- en: '[PRE93]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'While still being in the same file, follow these steps:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，按照以下步骤进行：
- en: Declare a new `RenderVertex` structure with four components - `x`, `y`, `u`,
    and `v`
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个新的`RenderVertex`结构，具有四个组件-`x`，`y`，`u`和`v`
- en: 'Define the OpenGL resources necessary for the framebuffer, namely, the texture,
    the vertex buffer, the shader program, and its variables:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义帧缓冲所需的OpenGL资源，即纹理、顶点缓冲区、着色器程序及其变量：
- en: '[PRE94]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Update the `jni/GraphicsManager.cpp` constructor initialization list to initialize
    default values:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`jni/GraphicsManager.cpp`构造函数的初始化列表，以初始化默认值：
- en: '[PRE95]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Change `start()` method to save the display surface width and height respectively
    in `mScreenWidth` and `mScreenHeight`.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`start()`方法，将显示表面的宽度和高度分别保存在`mScreenWidth`和`mScreenHeight`中。
- en: 'Then, call `initializeRenderBuffer()`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`initializeRenderBuffer()`：
- en: '[PRE96]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Define a vertex and fragment shader for off-screen rendering. This is similar
    to what we have seen until now:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为屏幕外渲染定义顶点和片段着色器。这与我们到目前为止所见到的类似：
- en: '[PRE97]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In `initializeRenderBuffer()`, create a predefined array of a vertex that is
    going to be loaded into OpenGL. It represents a single quad with a full texture
    rendered on it.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initializeRenderBuffer()`中，创建一个将要加载到OpenGL中的预定义顶点数组。它代表一个带有完整纹理的单个四边形。
- en: Compute the new render height based on a fixed target width of `600` pixels.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 根据固定目标宽度为`600`像素计算新的渲染高度。
- en: 'Retrieve the current screen framebuffer from the location where the final scene
    is rendered using `glGetIntegerv()` and the special value `GL_FRAMEBUFFER_BINDING`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glGetIntegerv()`和特殊值`GL_FRAMEBUFFER_BINDING`从渲染最终场景的位置检索当前屏幕帧缓冲区：
- en: '[PRE98]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a texture for off-screen rendering, like we have seen previously. In
    `glTexImage2D()`, pass a `NULL` value as the last parameter to create only the
    surface without initializing its content:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于屏幕外渲染的纹理，就像我们之前看到的那样。在`glTexImage2D()`中，传递`NULL`值作为最后一个参数，只创建表面而不初始化其内容：
- en: '[PRE99]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Then, create an off-screen framebuffer with `glGenFramebuffers()`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`glGenFramebuffers()`创建一个屏幕外帧缓冲区。
- en: Attach the previous texture to it with `glBindFramebuffer()`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glBindFramebuffer()`将先前的纹理附加到其中。
- en: 'Terminate by restoring the device state:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 通过恢复设备状态来终止：
- en: '[PRE100]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the shader program used to render texture to screen and retrieve its
    attributes and uniforms:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于将纹理渲染到屏幕并检索其属性和统一的着色器程序：
- en: '[PRE101]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Do not forget to release allocated resources in `stop()` when the activity
    finishes:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当活动结束时，请不要忘记在`stop()`中释放分配的资源：
- en: '[PRE102]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, use the new off-screen framebuffer to render the scene. To do so,
    you need to:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用新的屏幕外帧缓冲区来渲染场景。为此，您需要：
- en: Select the framebuffer with `glBindFramebuffer()`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glBindFramebuffer()`选择帧缓冲区。
- en: 'Specify the rendering viewport, which has to match the off-screen framebuffer
    dimensions, as shown here:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 指定渲染视口，它必须与屏幕外帧缓冲区的尺寸匹配，如下所示：
- en: '[PRE103]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Once it's rendered, restore the normal screen framebuffer and the correct viewport
    dimensions.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染完成后，恢复正常的屏幕帧缓冲区和正确的视口尺寸。
- en: 'Then, select as a source the following parameters:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择以下参数作为源：
- en: The off-screen texture which is attached to the off-screen framebuffer
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到屏幕外帧缓冲区的屏幕外纹理
- en: The shader program, which does basically nothing apart from projecting vertices
    and scaling texture, on the screen framebuffer
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器程序基本上除了在屏幕帧缓冲区上投影顶点和缩放纹理之外什么也不做
- en: 'The vertex buffer, which contains a single quad with texture coordinates, as
    shown in the following code:'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个带有纹理坐标的单个四边形的顶点缓冲区，如下面的代码所示：
- en: '[PRE104]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Terminate by rendering the off-screen buffer into the screen.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将离屏缓冲区渲染到屏幕上来终止。
- en: 'You can then restore the device state again, like this:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以再次恢复设备状态，就像这样：
- en: '[PRE105]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '*What just happened?*'
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Launch the application on several devices. Every device should display a proportionally
    similar scene. Indeed, graphics are now rendered to an off-screen framebuffer
    attached to a texture. The result is then scaled according to the target screen
    resolution to provide the same experience across different devices. This simple
    and cheap solution comes with a price, which is that the low-end devices might
    suffer depending on the chosen fixed resolution, whereas high-end devices will
    look blurry.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在多台设备上启动应用程序。每台设备应该显示一个比例相似的场景。实际上，图形现在被渲染到一个附加到纹理的离屏帧缓冲区中。然后根据目标屏幕分辨率进行缩放，以在不同设备上提供相同的体验。这种简单而廉价的解决方案是有代价的，低端设备可能会受到固定分辨率选择的影响，而高端设备看起来会模糊。
- en: Note
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Handling various screen resolutions is one thing. Managing their various aspect
    ratios is another. Several solutions exist for this problem, such as using black
    stripes, stretching the screen, or defining a minimum and maximum displayable
    area with only the first one containing important information.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 处理各种屏幕分辨率是一回事。管理它们的各种纵横比是另一回事。针对这个问题存在几种解决方案，比如使用黑色条纹、拉伸屏幕，或者定义一个只包含重要信息的最小和最大可显示区域。
- en: More generally, the rendering of a scene off-screen is often referred to as
    **Render to Texture**. This technique is commonly used to implement shadows, reflection,
    or postprocessing effects. Mastering this technique is a key in implementing high
    quality games.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，离屏场景的渲染通常被称为**渲染到纹理**。这种技术通常用于实现阴影、反射或后处理效果。掌握这种技术是实现高质量游戏的关键。
- en: Summary
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: OpenGL, and graphics in general, is a complex and highly technical API. One
    book is not enough to cover it entirely, but drawing 2D graphics with textures
    and buffer objects opens the door to much more advanced stuff!
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL，以及图形一般，是一个复杂且高度技术化的API。一本书不足以完全涵盖它，但使用纹理和缓冲对象绘制2D图形为更高级的东西打开了大门！
- en: In more detail, you have learned how to initialize an OpenGL ES context and
    bind it to an Android window. Then, you have seen how to turn libpng into a module
    and load a texture from a PNG asset. We have used this texture and then combined
    it with vertex buffers and shaders to render sprites and particles. Finally, we
    have found a solution to the Android resolution fragmentation issue with a simple
    off-screen and scaling rendering technique.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，您已经学会了如何初始化OpenGL ES上下文并将其绑定到Android窗口。然后，您已经看到如何将libpng转换为模块并从PNG资源加载纹理。我们已经使用了这个纹理，然后将它与顶点缓冲区和着色器结合起来渲染精灵和粒子。最后，我们找到了一个解决Android分辨率碎片化问题的简单离屏和缩放渲染技术。
- en: 'OpenGL ES is a complex API that requires an in-depth understanding to get the
    best performance and quality. This is even true with OpenGL ES 3, which we have
    not covered here, that is available since Android KitKat. Do not hesitate to have
    a look at:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES是一个复杂的API，需要深入理解才能获得最佳性能和质量。即使是OpenGL ES 3，我们在这里没有涵盖，它自Android KitKat以来就可用。不要犹豫，看一看：
- en: The Openg ES and GLSL specification at [http://www.khronos.org/registry/gles/](http://www.khronos.org/registry/gles/)
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Openg ES和GLSL规范位于[http://www.khronos.org/registry/gles/](http://www.khronos.org/registry/gles/)
- en: The Android Developer website at [http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html)
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android开发者网站位于[http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html)
- en: With the knowledge acquired here, the road to OpenGL ES 2 or 3 is at a perfectly
    walkable distance! So now, let's discover how to reach the fourth dimension, the
    musical one, with OpenSL ES in our next chapter.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里获得的知识，到达OpenGL ES 2或3的道路就在眼前！所以现在，让我们在下一章中发现如何达到第四维，音乐维，使用OpenSL ES。
