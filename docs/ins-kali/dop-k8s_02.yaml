- en: DevOps with Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器的DevOps
- en: 'We are already familiar with a lot of DevOps tools that help us automate tasks
    and manage configuration at different stages of application delivery, but challenges
    still exist as applications become more micro and diverse. In this chapter, we
    will add another swiss army knife to our tool belt, namely Container. In doing
    so, we will seek to acquire the following skills:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了许多DevOps工具，这些工具帮助我们自动化任务并在应用程序交付的不同阶段管理配置，但随着应用程序变得更加微小和多样化，仍然存在挑战。在本章中，我们将向我们的工具箱中添加另一把瑞士军刀，即容器。这样做，我们将寻求获得以下技能：
- en: Container concepts and fundamentals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器概念和基础知识
- en: Running Docker applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Docker应用程序
- en: Building Docker applications with `Dockerfile`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Dockerfile`构建Docker应用程序
- en: Orchestrating multiple containers with Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose编排多个容器
- en: Understanding container
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器
- en: The key feature of container is isolation. In this section, we will elaborate
    how container achieves it and why it matters in the software development life
    cycle to help establish a proper understanding of this powerful tool.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的关键特性是隔离。在本节中，我们将详细阐述容器是如何实现隔离的，以及为什么在软件开发生命周期中这一点很重要，以帮助建立对这个强大工具的正确理解。
- en: Resource isolation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源隔离
- en: When an application launches, it consumes CPU time, occupies memory space, links
    to its dependent libraries, and may write to disk, transmit packets, and access
    other devices. Everything it uses up is a resource, and is shared by all the programs
    on the same host. The idea of container is to isolate resources and programs to
    separate boxes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它会消耗CPU时间，占用内存空间，链接到其依赖库，并可能写入磁盘，传输数据包，并访问其他设备。它使用的一切都是资源，并且被同一主机上的所有程序共享。容器的理念是将资源和程序隔离到单独的盒子中。
- en: You may have heard such terms as para-virtualization, **Virtual Machines** (**VMs**),
    BSD jails, and Solaris containers, which can also isolate the resources of a host.
    However, since their designs differ, they are fundamentally distinct but provide
    a similar isolation concept. For example, the implementation of a VM is for virtualizing
    the hardware layer with a hypervisor. If you want to run an application on a Virtual
    Machine, you have to install a full operating system first. In other words, the
    resources are isolated between guest operating systems on the same hypervisor.
    In contrast, container is built on top of Linux primitives, which means it can
    only run in an operating system with those capabilities. BSD jails and Solaris
    containers also work in a similar fashion on other operating systems. The isolation
    relationship of container and VMs is illustrated in the following diagram. Container
    isolates an application at the OS-layer, while VM-based separation is achieved
    by the operating system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过诸如para-virtualization、虚拟机（VMs）、BSD jails和Solaris容器等术语，它们也可以隔离主机的资源。然而，由于它们的设计不同，它们在根本上是不同的，但提供了类似的隔离概念。例如，虚拟机的实现是为了使用hypervisor对硬件层进行虚拟化。如果您想在虚拟机上运行应用程序，您必须首先安装完整的操作系统。换句话说，在同一hypervisor上的客户操作系统之间的资源是隔离的。相比之下，容器是建立在Linux原语之上的，这意味着它只能在具有这些功能的操作系统中运行。BSD
    jails和Solaris容器在其他操作系统上也以类似的方式工作。容器和虚拟机的隔离关系如下图所示。容器在操作系统层隔离应用程序，而基于VM的分离是通过操作系统实现的。
- en: '![](../images/00026.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: Linux container concept
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux容器概念
- en: Container comprises several building blocks, the two most important being **namespaces**
    and **cgroups** (**control groups**). Both of them are Linux kernel features.
    Namespaces provide logical partitions of certain kinds of system resources, such
    as mounting point (`mnt`), process ID (`PID`), network (net), and so on. To explain
    the concept of isolation, let's look at some simple examples on the `pid` namespace.
    The following examples are all from Ubuntu 16.04.2 and util-linux 2.27.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器由几个构建模块组成，其中最重要的两个是**命名空间**和**控制组**（**cgroups**）。它们都是 Linux 内核的特性。命名空间提供了对某些类型的系统资源的逻辑分区，例如挂载点（`mnt`）、进程
    ID（`PID`）、网络（net）等。为了解释隔离的概念，让我们看一些关于 `pid` 命名空间的简单示例。以下示例均来自 Ubuntu 16.04.2 和
    util-linux 2.27.1。
- en: 'When we type `ps axf`, we will see a long list of running processes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入 `ps axf` 时，会看到一个长长的正在运行的进程列表：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ps` is a utility to report current processes on the system. `ps axf` is to
    list all processes in forest.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 是一个报告系统上当前进程的实用程序。`ps axf` 是列出所有进程的命令。'
- en: 'Now let''s enter a new `pid` namespace with `unshare`, which is able to disassociate
    a process resource part-by-part to a new namespace, and check the processes again:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `unshare` 进入一个新的 `pid` 命名空间，它能够逐部分将进程资源与新的命名空间分离，并再次检查进程：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will find the `pid` of the shell process at the new namespace becoming
    `1`, with all other processes disappearing. That is to say, you have created a
    `pid` container. Let''s switch to another session outside the namespace, and list
    the processes again:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现新命名空间中 shell 进程的 `pid` 变为 `1`，而所有其他进程都消失了。也就是说，您已经创建了一个 `pid` 容器。让我们切换到命名空间外的另一个会话，并再次列出进程：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can still see the other processes and your shell process within the new
    namespace.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的命名空间中，您仍然可以看到其他进程和您的 shell 进程。
- en: With the `pid` namespace isolation, processes in different namespaces cannot
    see each other. Nonetheless, if one process eats up a considerable amount of system
    resources, such as memory, it could cause the system to run out of memory and
    become unstable. In other words, an isolated process could still disrupt other
    processes or even crash a whole system if we don't impose resource usage restrictions
    on it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `pid` 命名空间隔离，不同命名空间中的进程无法看到彼此。然而，如果一个进程占用了大量系统资源，比如内存，它可能会导致系统内存耗尽并变得不稳定。换句话说，一个被隔离的进程仍然可能干扰其他进程，甚至导致整个系统崩溃，如果我们不对其施加资源使用限制。
- en: 'The following diagram illustrates the `PID` namespaces and how an **out-of-memory**
    (**OOM**) event can affect other processes outside a child namespace. The bubbles
    are the process in the system, and the numbers are their PID. Processes in the
    child namespace have their own PID. Initially, there is still free memory available
    in the system. Later, the processes in the child namespace exhaust the whole memory
    in the system. The kernel then starts the OOM killer to release memory, and the
    victims may be processes outside the child namespace:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了 `PID` 命名空间以及一个**内存不足**（**OOM**）事件如何影响子命名空间外的其他进程。气泡代表系统中的进程，数字代表它们的
    PID。子命名空间中的进程有自己的 PID。最初，系统中仍然有可用的空闲内存。后来，子命名空间中的进程耗尽了系统中的所有内存。内核随后启动了 OOM killer
    来释放内存，受害者可能是子命名空间外的进程：
- en: '![](../images/00027.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'In light of this, `cgroups` is utilized here to limit resource usage. Like
    namespaces, it can set constraint on different kinds of system resources. Let''s
    continue from our `pid` namespace, stress the CPU with `yes > /dev/null`, and
    monitor it with `top`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，`cgroups` 在这里被用来限制资源使用。与命名空间一样，它可以对不同类型的系统资源设置约束。让我们从我们的 `pid` 命名空间继续，用
    `yes > /dev/null` 来压力测试 CPU，并用 `top` 进行监控：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our CPU load reaches 100% as expected. Now let''s limit it with the CPU cgroup.
    Cgroups are organized as directories under `/sys/fs/cgroup/` (switch to the host
    session first):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CPU负载达到了预期的100%。现在让我们使用CPU cgroup来限制它。Cgroups组织为`/sys/fs/cgroup/`下的目录（首先切换到主机会话）：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each of the directories represents the resources they control. It''s pretty
    easy to create a cgroup and control processes with it: just create a directory
    under the resource type with any name, and append the process IDs you''d like
    to control to `tasks`. Here we want to throttle the CPU usage of our `yes` process,
    so create a new directory under `cpu` and find out the PID of the `yes` process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录代表它们控制的资源。创建一个cgroup并控制进程非常容易：只需在资源类型下创建一个任意名称的目录，并将您想要控制的进程ID附加到`tasks`中。这里我们想要限制`yes`进程的CPU使用率，所以在`cpu`下创建一个新目录，并找出`yes`进程的PID：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve just added `yes` into the newly created CPU group `box`, but the policy
    remains unset, and processes still run without restriction. Set a limit by writing
    the desired number into the corresponding file and check the CPU usage again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将`yes`添加到新创建的CPU组`box`中，但策略仍未设置，进程仍在没有限制地运行。通过将所需的数字写入相应的文件来设置限制，并再次检查CPU使用情况：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The CPU usage is dramatically reduced, meaning that our CPU throttle works.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用率显着降低，这意味着我们的CPU限制起作用了。
- en: These two examples elucidate how Linux container isolates system resources.
    By putting more confinements in an application, we can definitely build a fully
    isolated box, including filesystem and networks, without encapsulating an operating
    system within it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子阐明了Linux容器如何隔离系统资源。通过在应用程序中增加更多的限制，我们绝对可以构建一个完全隔离的盒子，包括文件系统和网络，而无需在其中封装操作系统。
- en: Containerized delivery
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化交付
- en: To deploy applications, the configuration management tool is often used. It's
    true that it works well with its modular and code-based configuration design until
    the application stacks grow complex and diverse. Maintaining a large configuration
    manifest base is complicated. When we want to change one package, we'll have to
    deal with entangled and fragile dependencies between the system and application
    packages. It's not uncommon that some applications break inadvertently after upgrading
    an unrelated package. Moreover, upgrading the configuration management tool itself
    is also a challenging task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署应用程序，通常会使用配置管理工具。它确实可以很好地处理模块化和基于代码的配置设计，直到应用程序堆栈变得复杂和多样化。维护一个庞大的配置清单基础是复杂的。当我们想要更改一个软件包时，我们将不得不处理系统和应用程序软件包之间纠缠不清和脆弱的依赖关系。经常会出现在升级一个无关的软件包后一些应用程序意外中断的情况。此外，升级配置管理工具本身也是一项具有挑战性的任务。
- en: In order to overcome such a conundrum, immutable deployments with pre-baked
    VM images are introduced. That is, whenever we have any update on the system or
    application packages, we'll build a full VM image against the change and deploy
    it accordingly. It solves a certain degree of package problems because we are
    now able to customize runtimes for applications that cannot share the same environments.
    Nevertheless, doing immutable deployment with VM images is costly. From another
    point of view, provisioning a VM for the sake of isolating applications rather
    than insufficient resources results in inefficient resource utilization, not to
    mention the overhead of booting, distributing, and running a bloating VM image.
    If we want to eliminate such inefficiency by sharing VM to multiple applications,
    we'll soon realize that we will run into further trouble, namely, resource management.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这样的困境，引入了使用预先烘焙的虚拟机镜像进行不可变部署。也就是说，每当系统或应用程序包有任何更新时，我们将根据更改构建一个完整的虚拟机镜像，并相应地部署它。这解决了一定程度的软件包问题，因为我们现在能够为无法共享相同环境的应用程序定制运行时。然而，使用虚拟机镜像进行不可变部署是昂贵的。从另一个角度来看，为了隔离应用程序而不是资源不足而配置虚拟机会导致资源利用效率低下，更不用说启动、分发和运行臃肿的虚拟机镜像的开销了。如果我们想通过共享虚拟机来消除这种低效，很快就会意识到我们将遇到进一步的麻烦，即资源管理。
- en: Container, here, is a jigsaw piece that snugly fits the deployment needs. A
    manifest of a container can be managed within VCS, and built into a blob image;
    no doubt the image can be deployed immutably as well. This enables developers
    to abstract from actual resources, and infrastructure engineers can escape from
    their dependency hell. Besides, since we only need to pack up the application
    itself and its dependent libraries, its image size would be significantly smaller
    than a VM's. Consequently, distributing a container image is more economical than
    a VM's. Additionally, we have already known that running a process inside a container
    is basically identical to running it on its Linux host and as such almost no overhead
    will be produced. To summarize, container is lightweight, self-contained, and
    immutable. This also gives a clear border to distinguish responsibilities between
    applications and infrastructure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在这里是一个完美适应部署需求的拼图块。容器的清单可以在版本控制系统中进行管理，并构建成一个blob图像；毫无疑问，该图像也可以被不可变地部署。这使开发人员可以抽象出实际资源，基础设施工程师可以摆脱他们的依赖地狱。此外，由于我们只需要打包应用程序本身及其依赖库，其图像大小将明显小于虚拟机的。因此，分发容器图像比虚拟机更经济。此外，我们已经知道，在容器内运行进程基本上与在其Linux主机上运行是相同的，因此几乎不会产生额外开销。总之，容器是轻量级的、自包含的和不可变的。这也清晰地划定了应用程序和基础设施之间的责任边界。
- en: Getting started with container
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用容器。
- en: There are many mature container engines such as Docker ([https://www.docker.com](https://www.docker.com))
    and rkt ([https://coreos.com/rkt](https://coreos.com/rkt)) that have already implemented
    features for production usages, so you don't need to start building one from scratch.
    Besides, the **Open Container Initiative** ([https://www.opencontainers.org](https://www.opencontainers.org)),
    an organization formed by container industry leaders, has framed some container
    specifications. Any implementation of those standards, regardless of the underlying
    platform, should have similar properties as OCI aims to provide, with seamless
    experience of containers across a variety of operating systems. In this book,
    we will use the Docker (community edition) container engine to fabricate our containerized
    applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多成熟的容器引擎，如Docker（[https://www.docker.com](https://www.docker.com)）和rkt（[https://coreos.com/rkt](https://coreos.com/rkt)），它们已经实现了用于生产的功能，因此您无需从头开始构建一个。此外，由容器行业领导者组成的**Open
    Container Initiative**（[https://www.opencontainers.org](https://www.opencontainers.org)）已经制定了一些容器规范。这些标准的任何实现，无论基础平台如何，都应具有与OCI旨在提供的类似属性，以便在各种操作系统上无缝体验容器。在本书中，我们将使用Docker（社区版）容器引擎来构建我们的容器化应用程序。
- en: Installing Docker for Ubuntu
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Ubuntu安装Docker
- en: 'Docker requires a 64-bit version of Yakkety 16.10, Xenial 16.04LTS, and Trusty
    14.04LTS. You can install Docker with `apt-get install docker.io`, but it usually
    updates more slowly than the Docker official repository. Here are the installation
    steps from Docker ([https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce)):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker需要Yakkety 16.10、Xenial 16.04LTS和Trusty 14.04LTS的64位版本。您可以使用`apt-get install
    docker.io`安装Docker，但它通常更新速度比Docker官方存储库慢。以下是来自Docker的安装步骤（[https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce)）：
- en: 'Make sure you have the packages to allow `apt` repositories; get them if not:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您拥有允许`apt`存储库的软件包；如果没有，请获取它们：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add Docker''s `gpg` key and verify if its fingerprint matches `9DC8 5822 9FC7
    DD38 854A E2D8 8D81 803C 0EBF CD88`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Docker的`gpg`密钥并验证其指纹是否匹配`9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set up the repository of `amd64` arch:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`amd64`架构的存储库：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update the package index and install Docker CE:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新软件包索引并安装Docker CE：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing Docker for CentOS
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CentOS上安装Docker
- en: 'CentOS 7 64-bit is required to run Docker. Similarly, you can get the Docker
    package from CentOS''s repository via `sudo yum install docker`. Again, the installation
    steps from Docker official guide ([https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository](https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository))
    are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要CentOS 7 64位才能运行Docker。同样，您可以通过`sudo yum install docker`从CentOS的存储库获取Docker软件包。同样，Docker官方指南（[https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository](https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository)）中的安装步骤如下：
- en: 'Install the utility to enable `yum` to use the extra repository:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装实用程序以启用`yum`使用额外的存储库：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set up Docker''s repository:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Docker的存储库：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the repository and verify if the fingerprint matches:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新存储库并验证指纹是否匹配：
- en: '`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`：'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Install Docker CE and start it:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker CE并启动它：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Installing Docker for macOS
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为macOS安装Docker
- en: Docker wraps a micro Linux moby with the hypervisor framework to build a native
    application on macOS, which means we don't need third-party virtualization tools
    to develop Docker in Mac. To benefit from the Hypervisor framework, you must upgrade
    your macOS to 10.10.3 or above.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用微型Linux moby和Hypervisor框架来在macOS上构建本机应用程序，这意味着我们不需要第三方虚拟化工具来开发Mac上的Docker。要从Hypervisor框架中受益，您必须将您的macOS升级到10.10.3或更高版本。
- en: 'Download the Docker package and install it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Docker软件包并安装它：
- en: '[https://download.docker.com/mac/stable/Docker.dmg](https://download.docker.com/mac/stable/Docker.dmg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://download.docker.com/mac/stable/Docker.dmg](https://download.docker.com/mac/stable/Docker.dmg)'
- en: 'Likewise, Docker for Windows requires no third-party tools. Check here for
    the installation guide: [https://docs.docker.com/docker-for-windows/install](https://docs.docker.com/docker-for-windows/install)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Docker for Windows不需要第三方工具。请查看此处的安装指南：[https://docs.docker.com/docker-for-windows/install](https://docs.docker.com/docker-for-windows/install)
- en: 'Now you are in Docker. Try creating and running your first Docker container;
    run it with `sudo` if you are on Linux:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经进入了Docker。尝试创建和运行您的第一个Docker容器；如果您在Linux上，请使用 `sudo` 运行：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see that you''re under a `root` directory instead of your current
    one. Let''s check the processes list again:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现您处于 `root` 目录下而不是当前目录。让我们再次检查进程列表：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is isolated, as expected. You are all ready to work with container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它是隔离的，正如预期的那样。您已经准备好使用容器了。
- en: Alpine is a Linux distribution. Since it's really small in size, many people
    use it as their base image to build their application container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine是一个Linux发行版。由于其体积非常小，许多人使用它作为构建应用程序容器的基础图像。
- en: Container life cycle
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器生命周期
- en: Using containers is not as intuitive as the tools that we are used to work with.
    In this section, we will go through Docker usages from the most fundamental ideas
    to the extent that we are able to benefit from containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器并不像我们习惯的工具那样直观。在本节中，我们将从最基本的想法开始介绍Docker的用法，直到我们能够从容器中受益为止。
- en: Docker basics
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker基础知识
- en: 'When `docker run alpine ls` is executed, what Docker did behind the scenes
    is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `docker run alpine ls` 时，Docker在幕后所做的是：
- en: Find the image `alpine` locally. If not found, Docker will try to find and pull
    it from the public Docker registry to the local image storage.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地找到图像 `alpine`。如果找不到，Docker 将尝试从公共Docker注册表中找到并将其拉取到本地图像存储中。
- en: Extract the image and create a container accordingly.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取图像并相应地创建一个容器。
- en: Execute the entry point defined in the image with commands, which are the arguments
    after the image name. In this example, it is `ls`. The entry point by default
    is `/bin/sh -c` on the Linux-based Docker.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令执行图像中定义的入口点，这些命令是图像名称后面的参数。在本例中，它是 `ls`。在基于Linux的Docker中，默认的入口点是 `/bin/sh
    -c`。
- en: When the entry point process is exited, the container then exits.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当入口点进程退出时，容器也会退出。
- en: An image is an immutable bundle of codes, libraries, configurations, and everything
    needed to run an application. A container is an instance of an image, which would
    actually be executed during runtime. You can use the `docker inspect IMAGE` and
    `docker inspect CONTAINER` commands to see the difference.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是一组不可变的代码、库、配置和运行应用程序所需的一切。容器是图像的一个实例，在运行时实际上会被执行。您可以使用 `docker inspect IMAGE`
    和 `docker inspect CONTAINER` 命令来查看区别。
- en: 'Sometimes when we need to enter a container for checking the image or updating
    something inside, we''ll use the option `-i` and `-t` (`--interactive` and `--tty`).
    Besides, option `-d` (`--detach`) enables you to run a container in detached mode.
    If you would like to interact with a detached container, `exec` and `attach` commands
    can do us a favor. The `exec` command allows us run a process in a running container,
    and `attach` works, as per its literal meaning. The following example demonstrates
    how to use them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们需要进入容器检查镜像或在内部更新某些内容时，我们将使用选项`-i`和`-t`（`--interactive`和`--tty`）。此外，选项`-d`（`--detach`）使您可以以分离模式运行容器。如果您想与分离的容器进行交互，`exec`和`attach`命令可以帮助我们。`exec`命令允许我们在运行的容器中运行进程，而`attach`按照其字面意思工作。以下示例演示了如何使用它们：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your Terminal should be flooded with `meow~` now. Switch to another Terminal
    and run `docker ps`, a command to get the status of containers, to find out the
    name and ID of the meowing container. Both the name and ID here are generated
    by Docker, and you can access a container with either of them. As a matter of
    convenience, the name can be assigned upon `create` or `run` with the `--name`
    flag:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您的终端现在应该被“喵喵喵”淹没了。切换到另一个终端并运行`docker ps`命令，以获取容器的状态，找出喵喵叫的容器的名称和ID。这里的名称和ID都是由Docker生成的，您可以使用其中任何一个访问容器。为了方便起见，名称可以在`create`或`run`时使用`--name`标志进行分配：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we get in the container and inspect its processes, we will see two shells:
    one is meowing and another one is where we are. Kill it with `kill -s 2 1` inside
    the container and we''ll see the whole container stopped as the entry point is
    exited. Finally, let''s list the stopped containers with `docker ps -a`, and clean
    them up with `docker rm CONTAINER_NAME` or `docker rm CONTAINER_ID`. Since Docker
    1.13, the `docker system prune` command has been introduced, which helps us clean
    up stopped containers and occupied resources with ease.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入容器并检查其进程，我们会看到两个shell：一个是喵喵叫，另一个是我们所在的位置。在容器内部使用`kill -s 2 1`杀死它，我们会看到整个容器停止，因为入口点已经退出。最后，让我们使用`docker
    ps -a`列出已停止的容器，并使用`docker rm CONTAINER_NAME`或`docker rm CONTAINER_ID`清理它们。自Docker
    1.13以来，引入了`docker system prune`命令，它可以帮助我们轻松清理已停止的容器和占用的资源。
- en: Layer, image, container, and volume
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层、镜像、容器和卷
- en: We know that an image is immutable; a container is ephemeral, and we know how
    to run an image as a container. Nevertheless, there's still a missing step on
    packing an image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道镜像是不可变的；容器是短暂的，我们知道如何将镜像作为容器运行。然而，在打包镜像时仍然缺少一步。
- en: An image is a read-only stack that consists of one or more layers, and a layer
    is a collection of files and directories in the filesystem. To improve the disk
    size usage, layers are not locked to only one image but shared among images; which
    means that Docker simply stores only one copy of a base image locally regardless
    of how many images are derived from it. You can utilize the `docker history [image]`
    command to understand how an image is built. For example, there's only one layer
    in an Alpine Linux image if you type `docker history alpine`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是一个只读的堆栈，由一个或多个层组成，而层是文件系统中的文件和目录的集合。为了改善磁盘使用情况，层不仅被锁定在一个镜像上，而且在镜像之间共享；这意味着Docker只在本地存储基础镜像的一个副本，而不管从它派生了多少镜像。您可以使用`docker
    history [image]`命令来了解镜像是如何构建的。例如，如果您键入`docker history alpine`，则Alpine Linux镜像中只有一个层。
- en: Whenever a container is created, it adds a writable layer on top of the base
    image. Docker adopts the **copy-on-write** (**COW**) strategy on the layer. That
    is to say, a container reads against the layers of the base image where the target
    files are stored, and copies the file to its own writable layer if the file is
    modified. Such an approach prevents containers created from the same image intervening
    with each other. The `docker diff [CONTAINER]` command shows the difference between
    the container and its base image in terms of filesystem states. For example, if
    `/etc/hosts` in the base image is modified, Docker copies the file to the writable
    layer, and it will also be the only one file in the output of `docker diff`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个容器时，它会在基础镜像的顶部添加一个可写层。Docker 在该层上采用了**写时复制**（**COW**）策略。也就是说，容器读取存储目标文件的基础镜像的层，并且如果文件被修改，就会将文件复制到自己的可写层。这种方法可以防止从相同镜像创建的容器相互干扰。`docker
    diff [CONTAINER]` 命令显示容器与其基础镜像在文件系统状态方面的差异。例如，如果基础镜像中的 `/etc/hosts` 被修改，Docker
    会将文件复制到可写层，并且在 `docker diff` 的输出中也只会有这一个文件。
- en: 'The following diagram illustrates the hierarchical structure of Docker''s images:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了 Docker 镜像的层次结构：
- en: '![](../images/00028.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: It's important to note that data in the writable layer is deleted along with
    its container. To persist data, you commit the container layer with the `docker
    commit [CONTAINER]` command as a new image, or mount data volumes into a container.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可写层中的数据会随着容器的删除而被删除。为了持久化数据，您可以使用 `docker commit [CONTAINER]` 命令将容器层提交为新镜像，或者将数据卷挂载到容器中。
- en: 'A data volume allows a container''s reading and writing to bypass Docker''s
    filesystem, and it can be on a host''s directory or other storages, such as Ceph
    or GlusterFS. Therefore, any disk I/O against the volume can operate at native
    speeds depending on the underlying storage. Since the data is persistent outside
    a container, it can be reused and shared by multiple containers. Mounting a volume
    is done by specifying the `-v`(`--volume`) flag at `docker run` or `docker create`.
    The following example mounts a volume under `/chest` in the container, and leaves
    a file there. Afterwards, we use `docker inspect` to locate the data volume:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷允许容器的读写绕过 Docker 的文件系统，它可以位于主机的目录或其他存储中，比如 Ceph 或 GlusterFS。因此，对卷的磁盘 I/O
    可以根据底层存储的实际速度进行操作。由于数据在容器外是持久的，因此可以被多个容器重复使用和共享。通过在 `docker run` 或 `docker create`
    中指定 `-v`（`--volume`）标志来挂载卷。以下示例在容器中挂载了一个卷到 `/chest`，并在其中留下一个文件。然后，我们使用 `docker
    inspect` 来定位数据卷：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The default `tty` path of moby Linux provided by Docker CE on macOS is under:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CE 在 macOS 上提供的 moby Linux 的默认 `tty` 路径位于：
- en: '`~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty`.'
- en: You can attach to it with `screen`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `screen` 连接到它。
- en: 'One use case of data volumes is sharing data between containers. To do so,
    we first create a container and mount volumes on it, and then mount one or more
    containers and reference the volume with `--volumes-from` flag. The following
    examples create a container with a data volume, `/share-vol`. Container A can
    put a file into it, and container B can read it as well:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷的一个用例是在容器之间共享数据。为此，我们首先创建一个容器并在其上挂载卷，然后挂载一个或多个容器，并使用 `--volumes-from` 标志引用卷。以下示例创建了一个带有数据卷
    `/share-vol` 的容器。容器 A 可以向其中放入一个文件，容器 B 也可以读取它：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition, data volumes can be mounted under a given host path, and of course
    the data inside is persistent:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据卷可以挂载在给定的主机路径下，当然其中的数据是持久的：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Distributing images
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发镜像
- en: Registry is a service that stores, manages, and distributes images. Public services,
    such as Docker Hub ([https://hub.docker.com](https://hub.docker.com)) and Quay
    ([https://quay.io](https://quay.io)), converge all kinds of pre-built images of
    popular tools, such as Ubuntu and Nginx, and custom images from other developers.
    The Alpine Linux we have used many times is actually pulled from Docker Hub ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)).
    Absolutely, you can upload your tool onto such services and share with everyone
    as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是一个存储、管理和分发图像的服务。公共服务，如Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    和 Quay ([https://quay.io](https://quay.io))，汇集了各种流行工具的预构建图像，如Ubuntu和Nginx，以及其他开发人员的自定义图像。我们多次使用的Alpine
    Linux实际上是从Docker Hub ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine))中拉取的。当然，你也可以将你的工具上传到这样的服务并与所有人分享。
- en: If you need a private registry, but for some reason you don't want to subscribe
    to paid plans of registry service providers, you can always set up one on your
    own with registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个私有注册表，但出于某种原因不想订阅注册表服务提供商的付费计划，你总是可以使用registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry))在自己的计算机上设置一个。
- en: 'Before provisioning a container, Docker will try to locate the specified image
    in a rule indicated in the image name. An image name consists of three sections
    `[registry/]name[:tag]`, and it''s resolved with the following rules:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置容器之前，Docker将尝试在图像名称中指示的规则中定位指定的图像。图像名称由三个部分`[registry/]name[:tag]`组成，并根据以下规则解析：
- en: If the `registry` field is left out, search for the name on Docker Hub
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了`registry`字段，则在Docker Hub上搜索该名称
- en: If the `registry` field is a registry server, search the name for it
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`registry`字段是注册表服务器，则在其中搜索该名称
- en: You can have more than one slash in a name
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中可以有多个斜杠
- en: The tag defaults to `latest` if it's omitted
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了标记，则默认为`latest`
- en: 'For example, an image name such as `gcr.io/google-containers/guestbook:v3`
    instructs Docker to download `v3` of `google-containers/guestbook` from `gcr.io`.
    Likewise, if you want to push an image to a registry, tag your image in the same
    manner and push it. To list the images you currently own in the local disk, use
    `docker images`, and remove an image with `docker rmi [IMAGE]`. The following
    example shows how to work between different registries: Download an `nginx` image
    from Docker Hub, tag it to a private registry path, and push it accordingly. Notice
    that though the default tag is `latest`, you have to tag and push it explicitly.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图像名称`gcr.io/google-containers/guestbook:v3`指示Docker从`gcr.io`下载`google-containers/guestbook`的`v3`版本。同样，如果你想将图像推送到注册表，也要以相同的方式标记你的图像并推送它。要列出当前在本地磁盘上拥有的图像，使用`docker
    images`，并使用`docker rmi [IMAGE]`删除图像。以下示例显示了如何在不同的注册表之间工作：从Docker Hub下载`nginx`图像，将其标记为私有注册表路径，并相应地推送它。请注意，尽管默认标记是`latest`，但你必须显式地标记和推送它。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Most registry services ask for authentications if you are going to push images.
    The `docker login` is designed for this purpose. Sometimes you may receive an
    `image not found error` when attempting to pull an image, even though the image
    path is valid. It''s very likely that you are unauthorized with the registry that
    keeps the image. To resolve this problem, log in first:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数注册表服务在你要推送图像时都会要求进行身份验证。`docker login`就是为此目的而设计的。有时，当尝试拉取图像时，你可能会收到`image
    not found error`的错误，即使图像路径是有效的。这很可能是你未经授权访问保存图像的注册表。要解决这个问题，首先要登录：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In addition to distributed images via the registry service, there are options
    to dump images as a TAR archive, and import them back into the local repository:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过注册表服务分发图像外，还有将图像转储为TAR存档文件，并将其导入到本地存储库的选项：
- en: '`docker commit [CONTAINER]`: Commits the changes of the container layer into
    a new image'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker commit [CONTAINER]`：将容器层的更改提交为新镜像'
- en: '`docker save --output [filename] IMAGE1 IMAGE2 ...`: Saves one or more images
    to a TAR archive'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker save --output [filename] IMAGE1 IMAGE2 ...`：将一个或多个镜像保存到TAR存档中'
- en: '`docker load -i [filename]`: Loads a `tarball` image into the local repository'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker load -i [filename]`：将`tarball`镜像加载到本地存储库'
- en: '`docker export --output [filename] [CONTAINER]`: Exports a container''s filesystem
    as a TAR archive'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker export --output [filename] [CONTAINER]`：将容器的文件系统导出为TAR存档'
- en: '`docker import --output [filename] IMAGE1 IMAGE2`: Imports a filesystem `tarball`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker import --output [filename] IMAGE1 IMAGE2`：导入文件系统`tarball`'
- en: The `commit` command with `save` and `export` looks pretty much the same. The
    main difference is that a saved image preserves files in-between layers even if
    they are to be deleted eventually; on the other hand, an exported image squashes
    all intermediate layers into one final layer. Another difference is that a saved
    image keeps metadata such as layer histories, but those are not available at the
    exported one. As a result, the exported image is usually smaller in size.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit`命令与`save`和`export`看起来基本相同。主要区别在于保存的镜像即使最终将被删除，也会保留层之间的文件；另一方面，导出的镜像将所有中间层压缩为一个最终层。另一个区别是保存的镜像保留元数据，例如层历史记录，但这些在导出的镜像中不可用。因此，导出的镜像通常体积较小。'
- en: 'The following diagram depicts the relationship of states between container
    and images. The captions on the arrows are the corresponding sub-commands of Docker:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了容器和镜像之间状态的关系。箭头上的标题是Docker的相应子命令：
- en: '![](../images/00029.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: Connect containers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接容器
- en: Docker provides three kinds of networks to manage communications within containers
    and between the hosts, namely `bridge`, `host`, and `none`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了三种网络类型来管理容器内部和主机之间的通信，即`bridge`、`host`和`none`。
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, every container is connected to the bridge network upon creation.
    In this mode, every container is allocated a virtual interface as well as a private
    IP address, and the traffic going through the interface is bridged to the host''s
    `docker0` interface. Also, other containers within the same bridge network can
    connect to each other via their IP address. Let''s run one container that is feeding
    a short message over port `5000`, and observe its configuration. The `--expose`
    flag opens the given ports to the world outside a container:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个容器在创建时都连接到桥接网络。在这种模式下，每个容器都被分配一个虚拟接口和一个私有IP地址，通过该接口传输的流量被桥接到主机的`docker0`接口。此外，同一桥接网络中的其他容器可以通过它们的IP地址相互连接。让我们运行一个通过端口`5000`发送短消息的容器，并观察其配置。`--expose`标志将给定端口开放给容器外部的世界：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here the container `greeter` is allocated with IP `172.17.0.2`. Now run another
    container connecting to it with this IP address:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器`greeter`被分配了IP`172.17.0.2`。现在运行另一个连接到该IP地址的容器：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `docker network inspect bridge` command gives configuration details, such
    as subnet segments and the gateway information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network inspect bridge`命令提供配置详细信息，例如子网段和网关信息。'
- en: 'On top of that, you can group some containers into one user-defined bridge
    network. It''s also the recommended way to connect multiple containers on a single
    host. The user-defined bridge network slightly differs from the default one, the
    major difference being that you can access a container from other containers with
    its name rather than IP address. Creating a network is done by `docker network
    create [NW-NAME]`, and attaching containers to it is done by the flag `--network
    [NW-NAME]` at the time of creation. The network name of a container defaults to
    its name, but it can be given another alias name with the `--network-alias` flag
    as well:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以将一些容器分组到一个用户定义的桥接网络中。这也是连接单个主机上多个容器的推荐方式。用户定义的桥接网络与默认的桥接网络略有不同，主要区别在于您可以通过名称而不是
    IP 地址访问其他容器。创建网络是通过`docker network create [NW-NAME]`完成的，将容器附加到它是通过创建时的标志`--network
    [NW-NAME]`完成的。容器的网络名称默认为其名称，但也可以使用`--network-alias`标志给它另一个别名：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The host network works literally according to its name; every connected container
    shares the host''s network, but it loses the isolation property at the same time.
    The none network is a completely separated box. Regardless of ingress or egress,
    traffic is isolated inside as there is no network interface attached to the container.
    Here we attach a container that listens on port `5000` to the host network, and
    communicates with it locally:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主机网络按照其名称的字面意思工作；每个连接的容器共享主机的网络，但同时失去了隔离属性。none 网络是一个完全分离的盒子。无论是入口还是出口，流量都在内部隔离，因为容器上没有网络接口。在这里，我们将一个监听端口`5000`的容器连接到主机网络，并在本地与其通信：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are using Docker CE for macOS, the host means the moby Linux on top of
    the hypervisor framework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 macOS 上使用 Docker CE，主机指的是 hypervisor 框架上的 moby Linux。
- en: The interaction between the host and three network modes are shown in the following
    diagram. Containers in the host and bridge networks are attached with proper network
    interfaces and communicate with containers within the same network as well as
    the outside world, but the none network is kept away from the host interfaces.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 主机和三种网络模式之间的交互如下图所示。主机和桥接网络中的容器都连接了适当的网络接口，并与相同网络内的容器以及外部世界进行通信，但 none 网络与主机接口保持分离。
- en: '![](../images/00030.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: Other than sharing the host network, the flag `-p(--publish) [host]:[container]`,
    on creating a container, also allows you to map a host port to a container. This
    flag implies `-expose`, as you'll need to open a container's port in any case.
    The following command launches a simple HTTP server at port `80`. You can view
    it with a browser as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享主机网络外，在创建容器时，标志`-p(--publish) [host]:[container]`还允许您将主机端口映射到容器。这个标志意味着`-expose`，因为您无论如何都需要打开容器的端口。以下命令在端口`80`启动一个简单的HTTP服务器。您也可以用浏览器查看它。
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with Dockerfile
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile
- en: When assembling an image, whether by a Docker commit or export, optimizing the
    outcome in a managed way is a challenge, let alone integrating with a CI/CD pipeline.
    On the other hand, `Dockerfile` represents the building task in the form of as-a-code,
    which significantly reduces the complexities of building a task for us. In this
    section, we will describe how to map Docker commands into a `Dockerfile` and go
    a step further to optimizing it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装镜像时，无论是通过 Docker commit 还是 export，以受控的方式优化结果都是一个挑战，更不用说与 CI/CD 管道集成了。另一方面，`Dockerfile`
    以代码的形式表示构建任务，这显著减少了我们构建任务的复杂性。在本节中，我们将描述如何将 Docker 命令映射到 `Dockerfile` 中，并进一步对其进行优化。
- en: Writing your first Dockerfile
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个 Dockerfile
- en: 'A `Dockerfile` consists of a series of text instructions to guide the Docker
    daemon to form a Docker image. Generally, a `Dockerfile` is and must be starting
    with the directive `FROM`, and follows zero or more instructions. For example,
    we may have an image built from the following one liner:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`由一系列文本指令组成，指导Docker守护程序形成一个Docker镜像。通常，`Dockerfile`是以指令`FROM`开头的，后面跟着零个或多个指令。例如，我们可以从以下一行指令构建一个镜像：'
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It roughly equates to the following `Dockerfile`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它大致相当于以下`Dockerfile`：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Obviously, building with a `Dockerfile` is more concise and clear.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用`Dockerfile`构建更加简洁和清晰。
- en: The `docker build [OPTIONS] [CONTEXT]` command is the only one command associated
    with building tasks. A context can be a local path, URL, or `stdin`; which denotes
    the location of the `Dockerfile`. Once a build is triggered, the `Dockerfile`,
    alongside everything under the context, will be sent to the Docker daemon beforehand,
    and then the daemon will start to execute instructions in the `Dockerfile` sequentially.
    Every execution of instructions results in a new cache layer, and the ensuing
    instruction is executed at the new cache layer in the cascade. Since the context
    will be sent to somewhere that is not guaranteed to be a local path, it's a good
    practice to put the `Dockerfile`, codes, the necessary files, and a `.dockerignore`
    file in an empty folder to make sure the resultant image encloses only the desired
    files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build [OPTIONS] [CONTEXT]`命令是与构建任务相关的唯一命令。上下文可以是本地路径、URL或`stdin`；表示`Dockerfile`的位置。一旦触发构建，`Dockerfile`以及上下文中的所有内容将首先被发送到Docker守护程序，然后守护程序将开始按顺序执行`Dockerfile`中的指令。每次执行指令都会产生一个新的缓存层，随后的指令会在级联中的新缓存层上执行。由于上下文将被发送到不一定是本地路径的地方，将`Dockerfile`、代码、必要的文件和`.dockerignore`文件放在一个空文件夹中是一个良好的做法，以确保生成的镜像仅包含所需的文件。'
- en: 'The `.dockerignore` file is a list indicating which files under the same directory
    can be ignored during the building time, and it typically looks like the following
    file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件是一个列表，指示在构建时可以忽略同一目录下的哪些文件，它通常看起来像下面的文件：'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Generally, `docker build` will try to find a file named `Dockerfile` under
    the `context` to start a build; but sometimes we may like to give it another name
    for some reason. The `-f`(`--file`) flag is for this purpose. Also, another useful
    flag, `-t`(`--tag`), is able to give an image of one or more repository tags after
    an image is built. Say we want to build a `Dockerfile` named `builder.dck` under
    `./deploy` and label it with the current date and the latest tag, the command
    will be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`docker build`将尝试在`context`下找到一个名为`Dockerfile`的文件来开始构建；但有时出于某些原因，我们可能希望给它另一个名称。`-f`（`--file`）标志就是为了这个目的。另外，另一个有用的标志`-t`（`--tag`）在构建完镜像后能够给一个或多个仓库标签。假设我们想要在`./deploy`下构建一个名为`builder.dck`的`Dockerfile`，并用当前日期和最新标签标记它，命令将是：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Dockerfile syntax
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile语法
- en: 'The building blocks of a `Dockerfile` are a dozen or more directives; most
    of them are a counterpart of the functions of `docker run/create` flags. Here
    we list the most essential ones:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的构建块是十几个或更多的指令；其中大多数是`docker run/create`标志的对应物。这里我们列出最基本的几个：'
- en: '`FROM <IMAGE>[:TAG|[@DIGEST]`: This is to tell the Docker daemon which image
    the current `Dockerfile` is based on. It''s also the one and only instruction
    that must be in a `Dockerfile`, which means that you can have a `Dockerfile` that
    contains only one line. Like all the other image-relevant commands, the tag defaults
    to the latest if unspecified.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM <IMAGE>[:TAG|[@DIGEST]`：这是告诉Docker守护程序当前`Dockerfile`基于哪个镜像。这也是唯一必须在`Dockerfile`中的指令，这意味着你可以有一个只包含一行的`Dockerfile`。像所有其他与镜像相关的命令一样，如果未指定标签，则默认为最新的。'
- en: '`RUN`:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：'
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `RUN` instruction runs one line of a command at the current cache layer,
    and commits out the outcome. The main discrepancy between the two forms is in
    how the command is executed. The first one is called **shell form**, which actually
    executes commands in the form of `/bin/sh -c <commands>`; the other form is called
    **exec form**, and it treats the command with `exec` directly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令在当前缓存层运行一行命令，并提交结果。两种形式之间的主要差异在于命令的执行方式。第一种称为**shell形式**，实际上以`/bin/sh
    -c <commands>`的形式执行命令；另一种形式称为**exec形式**，它直接使用`exec`处理命令。'
- en: Using the shell form is similar to writing shell scripts, thus concatenating
    multiple commands by shell operators and line continuation, condition tests, or
    variable substitutions are totally valid. But bear in mind that commands are not
    processed by `bash` but `sh`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shell形式类似于编写shell脚本，因此通过shell运算符和行继续、条件测试或变量替换来连接多个命令是完全有效的。但请记住，命令不是由`bash`而是由`sh`处理。
- en: The exec form is parsed as a JSON array, which means that you have to wrap texts
    with double quotes and escape reserved characters. Besides, as the command is
    not processed by any shell, the shell variables in the array will not be evaluated.
    On the other hand, if the shell doesn't exist in the base image, you can still
    use the exec form to invoke executables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: exec形式被解析为JSON数组，这意味着您必须用双引号包装文本并转义保留字符。此外，由于命令不会由任何shell处理，数组中的shell变量将不会被评估。另一方面，如果基本图像中不存在shell，则仍然可以使用exec形式来调用可执行文件。
- en: '`CMD`:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `CMD` sets default commands for the built image; it doesn't run the command
    during build time. If arguments are supplied at Docker run, the `CMD` configurations
    here are overridden. The syntax rule of `CMD` is almost identical to `RUN`; the
    first form is the exec form, and the third one is the shell form, which is the
    prepend a `/bin/sh -c` as well. There is another directive in which `ENTRYPOINT`
    interacts with `CMD`; three forms of `CMD` actually would be a prepend with `ENTRYPOINT`
    when a container starts. There can be many `CMD` directives in a `Dockerfile`,
    but only the last one will take effect.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`设置了构建图像的默认命令；它不会在构建时运行命令。如果在Docker run时提供了参数，则这里的`CMD`配置将被覆盖。`CMD`的语法规则几乎与`RUN`相同；第一种形式是exec形式，第三种形式是shell形式，也就是在前面加上`/bin/sh
    -c`。`ENTRYPOINT`与`CMD`交互的另一个指令；实际上，三种`CMD`形式在容器启动时都会被`ENTRYPOINT`所覆盖。在`Dockerfile`中可以有多个`CMD`指令，但只有最后一个会生效。'
- en: '`ENTRYPOINT`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：'
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These two forms are, respectively, the exec form and the shell form, and the
    syntax rules are the same as `RUN`. The entry point is the default executable
    for an image. That is to say, when a container spins up, it runs the executable
    configured by the `ENTRYPOINT`. When the `ENTRYPOINT` is combined with `CMD` and
    `docker run` arguments, writing in a different form would lead to very diverse
    behavior. Here are the organized rules of their combinations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式分别是执行形式和shell形式，语法规则与`RUN`相同。入口点是图像的默认可执行文件。也就是说，当容器启动时，它会运行由`ENTRYPOINT`配置的可执行文件。当`ENTRYPOINT`与`CMD`和`docker
    run`参数结合使用时，以不同形式编写会导致非常不同的行为。以下是它们组合的规则：
- en: 'If the `ENTRYPOINT` is in shell form, then the `CMD` and Docker `run` arguments
    would be ignored. The command will become:'
  id: totrans-168
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`是shell形式，则`CMD`和Docker `run`参数将被忽略。命令将变成：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the `ENTRYPOINT` is in exec form and the Docker `run` arguments are specified,
    then the `CMD` commands are overridden. The runtime command would be:'
  id: totrans-170
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`是exec形式，并且指定了Docker `run`参数，则`CMD`命令将被覆盖。运行时命令将是：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the `ENTRYPOINT` is in exec form and only `CMD` is configured, the runtime
    command would become the following for the three forms:'
  id: totrans-172
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`以执行形式存在，并且只配置了`CMD`，则三种形式的运行时命令将变为以下形式：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`ENV`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：'
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ENV` instruction sets environment variables for the consequent instructions
    and the built image. The first form sets the key to the string after the first
    space, including special characters. The second form allows us to set multiple
    variables in a line, separated with spaces. If there are spaces in a value, either
    enclose it with double quotes or escape the space character. Moreover, the key
    defined with `ENV` also takes effect on variables in the same documents. See the
    following examples to observe the behavior of `ENV`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`指令为随后的指令和构建的镜像设置环境变量。第一种形式将键设置为第一个空格后面的字符串，包括特殊字符。第二种形式允许我们在一行中设置多个变量，用空格分隔。如果值中有空格，可以用双引号括起来或转义空格字符。此外，使用`ENV`定义的键也会影响同一文档中的变量。查看以下示例以观察`ENV`的行为：'
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the output during the Docker build would be:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker构建期间的输出将是：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`LABEL key1=value1 key2=value2 ...`: The usage of `LABEL` resembles `ENV`,
    but a label is stored only in the metadata section of the images and is used by
    other host programs instead of programs in a container. It deprecates the `maintainer`
    instruction in the following form:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL key1=value1 key2=value2 ...`：`LABEL`的用法类似于`ENV`，但标签仅存储在镜像的元数据部分，并由其他主机程序使用，而不是容器中的程序。它取代了以下形式的`maintainer`指令：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And we can filter objects with labels if a command has the `-f(--filter)` flag.
    For example, `docker images --filter label=maintainer=johndoe@example.com` queries
    out the images labeled with the preceding maintainer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令带有`-f(--filter)`标志，则可以使用标签过滤对象。例如，`docker images --filter label=maintainer=johndoe@example.com`会查询出带有前面维护者标签的镜像。
- en: '`EXPOSE <port> [<port> ...]`: This instruction is identical to the `--expose`
    flag at `docker run/create`, exposing ports at the container created by the resulting
    image.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE <port> [<port> ...]`：此指令与`docker run/create`中的`--expose`标志相同，会在由生成的镜像创建的容器中暴露端口。'
- en: '`USER <name|uid>[:<group|gid>]`: The `USER` instruction switches the user to
    run the subsequent instructions. However, it cannot work properly if the user
    doesn''t exist in the image. Otherwise, you have to run `adduser` before using
    the `USER` directive.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER <name|uid>[:<group|gid>]`：`USER`指令切换用户以运行随后的指令。但是，如果用户在镜像中不存在，则无法正常工作。否则，在使用`USER`指令之前，您必须运行`adduser`。'
- en: '`WORKDIR <path>`: This instruction sets the working directory to a certain
    path. The path would be created automatically if the path doesn''t exist. It works
    like `cd` in a `Dockerfile`, as it takes both relative and absolute paths and
    can be used multiple times. If an absolute path is followed by a relative path,
    the result would be relative to the previous path:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR <path>`：此指令将工作目录设置为特定路径。如果路径不存在，路径将被自动创建。它的工作原理类似于`Dockerfile`中的`cd`，因为它既可以接受相对路径也可以接受绝对路径，并且可以多次使用。如果绝对路径后面跟着一个相对路径，结果将相对于前一个路径：'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Also, environment variables set with `ENV` take effect on the path.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`ENV`设置的环境变量会影响路径。
- en: '`COPY:`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY：`'
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This directive copies the source to a file or a directory in the building container.
    The source could be files or directories, as could be the destination. The source
    must be within the context path, as only files under the context path will be
    sent to the Docker daemon. Additionally, `COPY` makes use of `.dockerignore` to
    filter files that would be copied into the building container. The second form
    is for a use case where the path contains spaces.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将源复制到构建容器中的文件或目录。源可以是文件或目录，目的地也可以是文件或目录。源必须在上下文路径内，因为只有上下文路径下的文件才会被发送到Docker守护程序。此外，`COPY`利用`.dockerignore`来过滤将被复制到构建容器中的文件。第二种形式适用于路径包含空格的情况。
- en: '`ADD`:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：'
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ADD` is quite analogous to `COPY` in terms of functionality: moving files
    into an image. More than copying files, `<src>` can also be URL or a compressed
    file. If `<src>` is a URL, `ADD` will download it and copy it into the image.
    If `<src>` is inferred as a compressed file, it will be extracted into `<dest>`
    path.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`在功能上与`COPY`非常类似：将文件移动到镜像中。除了复制文件外，`<src>`也可以是URL或压缩文件。如果`<src>`是一个URL，`ADD`将下载并将其复制到镜像中。如果`<src>`被推断为压缩文件，它将被提取到`<dest>`路径中。'
- en: '`VOLUME`:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`：'
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `VOLUME` instruction creates data volumes at the given mount points. Once
    it has been declared during build time, any change in the data volume at consequent
    directives would not persist. Besides, mounting host directories in a `Dockerfile`
    or `docker build` isn''t doable because of portability issues: there''s no guarantee
    that the specified path would exist in the host. The effect of both syntax forms
    is identical; they only differ in syntax parsing; The second form is a JSON array,
    so characters such as `"\"` should be escaped.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令在给定的挂载点创建数据卷。一旦在构建时声明了数据卷，后续指令对数据卷的任何更改都不会持久保存。此外，在`Dockerfile`或`docker
    build`中挂载主机目录是不可行的，因为存在可移植性问题：无法保证指定的路径在主机中存在。两种语法形式的效果是相同的；它们只在语法解析上有所不同；第二种形式是JSON数组，因此需要转义字符，如`"\"`。'
- en: '`ONBUILD [Other directives]`: `ONBUILD` allows you to postpone some instructions
    to later builds in the derived image. For example, we may have the following two
    Dockerfiles:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD [其他指令]`：`ONBUILD`允许您将一些指令推迟到派生图像的后续构建中。例如，我们可能有以下两个Dockerfiles：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The instruction then would be evaluated in the following order on `docker build`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指令将按以下顺序在`docker build`中进行评估：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Organizing a Dockerfile
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织Dockerfile
- en: Even though writing a `Dockerfile` is the same as composing a building script,
    there are some more factors we should consider to build efficient, secure, and
    stable images. Moreover, a `Dockerfile` itself is also a document, and keeping
    its readability eases management efforts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编写`Dockerfile`与编写构建脚本相同，但我们还应考虑一些因素来构建高效、安全和稳定的镜像。此外，`Dockerfile`本身也是一个文档，保持其可读性可以简化管理工作。
- en: 'Say we have an application stack that consists of application codes, a database,
    and cache, we''ll probably start from a `Dockerfile`, such as the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序堆栈，其中包括应用程序代码、数据库和缓存，我们可能会从一个`Dockerfile`开始，例如以下内容：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first suggestion is making a container dedicated to one thing and one thing
    only. So, we''ll remove the installation and configuration at both `mysql` and
    `redis` in this `Dockerfile` at the beginning. Next, the code is moved into the
    container with `ADD`, which means we will very likely move the whole code repository
    into the container. Usually there are lots of files that are not directly relevant
    to the application, including VCS files, CI server configurations, or even build
    caches, and we probably wouldn''t like to pack them into an image. Thus, using
    a `.dockerignore` to filter out those files is suggested as well. Incidentally,
    due to the `ADD` instruction, we could do more than just add files into a build
    container. Using `COPY` is preferred in general, unless there is a real need not
    to do so. Now our `Dockerfile` is simpler, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建议是创建一个专门用于一件事情的容器。因此，我们将在这个`Dockerfile`的开头删除`mysql`和`redis`的安装和配置。接下来，代码将被移入容器中，使用`ADD`，这意味着我们很可能将整个代码库移入容器。通常有许多与应用程序直接相关的文件，包括VCS文件、CI服务器配置，甚至构建缓存，我们可能不希望将它们打包到镜像中。因此，建议使用`.dockerignore`来过滤掉这些文件。顺便说一句，由于`ADD`指令，我们可以做的不仅仅是将文件添加到构建容器中。通常情况下，使用`COPY`更为合适，除非确实有不这样做的真正需要。现在我们的`Dockerfile`更简单了，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'While building an image, the Docker engine will try to reuse the cache layer
    as much as possible, which notably reduces the build time. In our `Dockerfile`,
    we have to go through whole updating and dependency installation processes as
    long as there''s any update in our repository. To benefit from building caches,
    we''ll re-order the directives based on a rule of thumb: run less frequent instructions
    first.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，Docker引擎将尽可能地重用缓存层，这显著减少了构建时间。在我们的`Dockerfile`中，只要存储库有任何更新，我们就必须经历整个更新和依赖项安装过程。为了从构建缓存中受益，我们将根据一个经验法则重新排序指令：首先运行不太频繁的指令。
- en: Additionally, as we've described before, any change to the container filesystem
    results in a new image layer. Even though we deleted certain files in the consequent
    layer, those files are still occupied image sizes as they are still being kept
    at intermediate layers. Therefore, our next step is to minimize the image layers
    by simply compacting multiple `RUN` instructions. Moreover, to keep the readability
    of the `Dockerfile`, we tend to format the compacted `RUN` with the line continuation
    character, "`\`".
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如我们之前所描述的，对容器文件系统的任何更改都会导致新的镜像层。即使我们在随后的层中删除了某些文件，这些文件仍然占用着镜像大小，因为它们仍然保存在中间层。因此，我们的下一步是通过简单地压缩多个`RUN`指令来最小化镜像层。此外，为了保持`Dockerfile`的可读性，我们倾向于使用行继续字符“`\`”格式化压缩的`RUN`。
- en: 'In addition to working with the building mechanisms of Docker, we''d also like
    to write a maintainable `Dockerfile` to make it more clear, predictable, and stable.
    Here are some suggestions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与Docker的构建机制一起工作之外，我们还希望编写一个可维护的`Dockerfile`，使其更清晰、可预测和稳定。以下是一些建议：
- en: Use `WORKDIR` instead of inline `cd`, and use absolute path for `WORKDIR`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WORKDIR`而不是内联`cd`，并为`WORKDIR`使用绝对路径。
- en: Explicitly expose the required ports
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确公开所需的端口
- en: Specify a tag for the base image
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基础镜像指定标签
- en: Use the exec form to launch an application
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行形式启动应用程序
- en: 'The first three suggestions are pretty straightforward, aimed at eliminating
    ambiguity. The last one is about how an application is terminated. When a stop
    request from the Docker daemon is sent to a running container, the main process
    (PID 1) will receive a stop signal (`SIGTERM`). If the process is not stopped
    after a certain period of time, the Docker daemon will send another signal (`SIGKILL`)
    to kill the container. The exec form and shell form differ here. In the shell
    form, the PID 1 process is "`/bin/sh -c`", not the application. Further, different
    shells don''t handle signals in the same way. Some forward the stop signal to
    child processes while some do not. The shell at Alpine Linux doesn''t forward
    them. As a result, to stop and clean up our application properly, using the `exec`
    form is encouraged. Combining those principles, we have the following `Dockerfile`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个建议非常直接，旨在消除歧义。最后一个建议是关于应用程序如何终止。当来自Docker守护程序的停止请求发送到正在运行的容器时，主进程（PID 1）将接收到一个停止信号（`SIGTERM`）。如果进程在一定时间后仍未停止，Docker守护程序将发送另一个信号（`SIGKILL`）来终止容器。在这里，exec形式和shell形式有所不同。在shell形式中，PID
    1进程是"`/bin/sh -c`"，而不是应用程序。此外，不同的shell处理信号的方式也不同。有些将停止信号转发给子进程，而有些则不会。Alpine Linux的shell不会转发它们。因此，为了正确停止和清理我们的应用程序，建议使用`exec`形式。结合这些原则，我们有以下`Dockerfile`：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are still other practices to make a `Dockerfile` better, including starting
    from a dedicated and smaller base image such as Alpine-based ones rather than
    generic purpose distributions, using users other than `root` for security, and
    removing unnecessary files in the `RUN` in which they are joined.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些实践可以使`Dockerfile`更好，包括从专用和更小的基础镜像开始，例如基于Alpine的镜像，而不是通用目的的发行版，使用除`root`之外的用户以提高安全性，并在`RUN`中删除不必要的文件。
- en: Multi-containers orchestration
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多容器编排
- en: As we pack more and more applications into isolated boxes, we'll soon realize
    that we need a tool that is able to help us tackle many containers simultaneously.
    In this section, we'll move a step up from spinning up simply one single container
    to orchestrating containers in a band.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们将越来越多的应用程序打包到隔离的容器中，我们很快就会意识到我们需要一种工具，能够帮助我们同时处理多个容器。在这一部分，我们将从仅仅启动单个容器上升一步，开始编排一组容器。
- en: Piling up containers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆叠容器
- en: Modern systems are usually built as a stack made up of multiple components that
    are distributed over networks, such as application servers, caches, databases,
    message queues, and so on. Meanwhile, a component itself is also a self-contained
    system with many sub-components. What's more, the trend of microservices introduces
    additional degrees of complexity into such entangled relationships between systems.
    From this fact, even though container technology gives us a certain degree of
    relief regarding deployment tasks, launching a system is still difficult.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统通常构建为由多个组件组成的堆栈，这些组件分布在网络上，如应用服务器、缓存、数据库、消息队列等。同时，一个组件本身也是一个包含许多子组件的自包含系统。此外，微服务的趋势为系统之间纠缠不清的关系引入了额外的复杂性。由于这个事实，即使容器技术在部署任务方面给了我们一定程度的缓解，启动一个系统仍然很困难。
- en: Say we have a simple application called kiosk, which connects to a Redis to
    manage how many tickets we currently have. Once a ticket is sold, it publishes
    an event through a Redis channel. The recorder subscribes the Redis channel and
    writes a timestamp log into a MySQL database upon receiving any event.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为kiosk的简单应用程序，它连接到Redis来管理我们当前拥有的门票数量。一旦门票售出，它会通过Redis频道发布一个事件。记录器订阅了Redis频道，并在接收到任何事件时将时间戳日志写入MySQL数据库。
- en: 'For the **kiosk** and the **recorder**, you can find the code as well as the
    Dockerfiles here: [https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter2](https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter2).
    The architecture is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**kiosk**和**recorder**，你可以在这里找到代码以及Dockerfiles：[https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter2](https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter2)。架构如下：
- en: '![](../images/00031.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: 'We know how to start those containers separately, and connect them to each
    other. Based on what we have discussed before, we would first create a bridge
    network, and run the containers inside:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何分别启动这些容器，并将它们连接在一起。基于我们之前讨论的内容，我们首先会创建一个桥接网络，并在其中运行容器：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Everything works well so far. However, if next time we want to launch the same
    stack again, our applications are very likely to start up prior to the databases,
    and they might fail if any incoming connection requests any change against the
    databases. In other words, we have to consider the startup order in our startup
    scripts. Additionally, scripts are also inept with problems such as how to deal
    with a random components crash, how to manage variables, how to scale out certain
    components, and so on.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都运行良好。然而，如果下次我们想再次启动相同的堆栈，我们的应用很可能会在数据库之前启动，并且如果有任何传入连接请求对数据库进行任何更改，它们可能会失败。换句话说，我们必须在启动脚本中考虑启动顺序。此外，脚本还存在一些问题，比如如何处理随机组件崩溃，如何管理变量，如何扩展某些组件等等。
- en: Docker Compose overview
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose概述
- en: 'Docker Compose is the very tool that enables us to run multiple containers
    with ease, and it''s a built-in tool in the Docker CE distribution. All it does
    is read `docker-compose.yml` (or `.yaml`) to run defined containers. A `docker-compose`
    file is a YAML-based template, and it typically looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个非常方便地运行多个容器的工具，它是Docker CE发行版中的内置工具。它的作用就是读取`docker-compose.yml`（或`.yaml`）来运行定义的容器。`docker-compose`文件是基于YAML的模板，通常是这样的：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Launching it is pretty simple: save the template to `docker-compose.yml` and
    use the `docker-compose up` command to start it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 启动它非常简单：将模板保存为`docker-compose.yml`，然后使用`docker-compose up`命令启动它。
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's see what `docker-compose` did behind the `up` command.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`docker-compose`在`up`命令后面做了什么。
- en: 'Docker Compose is basically a medley of Docker functions for multiple containers.
    For example, the counterpart of `docker build` is `docker-compose build`; the
    previous one builds a Docker image, and so the later one builds Docker images
    listed in the `docker-compose.yml`. But there''s one thing that needs to be pointed
    out: the `docker-compose run` command is not the correspondent of `docker run`;
    it''s running a specific container from the configuration in the `docker-compose.yml`.
    In fact, the closest command to `docker run` is `docker-compose up`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose基本上是Docker的多个容器功能的混合体。例如，`docker build`的对应命令是`docker-compose build`；前者构建一个Docker镜像，后者构建`docker-compose.yml`中列出的Docker镜像。但需要指出的是：`docker-compose
    run`命令并不是`docker run`的对应命令；它是从`docker-compose.yml`中的配置中运行特定容器。实际上，与`docker run`最接近的命令是`docker-compose
    up`。
- en: The `docker-compose.yml` file consists of configurations of volumes, networks,
    and services. Besides, there should be a version definition to indicate which
    version of the `docker-compose` format is used. With such an understanding of
    the template structure, what the previous `hello-world` example does is quite
    clear; it creates a service called `hello-world` and it is created by the image
    `hello-world:latest`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件包括卷、网络和服务的配置。此外，应该有一个版本定义来指示使用的`docker-compose`格式的版本。通过对模板结构的理解，前面的`hello-world`示例所做的事情就很清楚了；它创建了一个名为`hello-world`的服务，它是由`hello-world:latest`镜像创建的。'
- en: Since there is no network defined, `docker-compose` would create a new network
    with a default driver and connect services to the same network as shown in lines
    1 to 3 of the example's output.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有定义网络，`docker-compose`将使用默认驱动程序创建一个新网络，并将服务连接到与示例输出中的1到3行相同的网络。
- en: Additionally, the network name of a container would be the service's name. You
    may notice that the name displayed in the console slightly differs from its original
    one in the `docker-compose.yml`. It's because Docker Compose tries to avoid name
    conflicts between containers. As a result, Docker Compose runs the container with
    the name it generated, and makes a network-alias with the service name. In this
    example, both "`hello-world`" and "`cwd_hello-world_1`" are resolvable to other
    containers within the same network.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，容器的网络名称将是服务的名称。您可能会注意到控制台中显示的名称与`docker-compose.yml`中的原始名称略有不同。这是因为Docker
    Compose尝试避免容器之间的名称冲突。因此，Docker Compose使用生成的名称运行容器，并使用服务名称创建网络别名。在此示例中，“hello-world”和“cwd_hello-world_1”都可以在同一网络中解析到其他容器。
- en: Composing containers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合容器
- en: 'As Docker Compose is the same as Docker in many aspects, it''s more efficient
    to understand how to write a `docker-compose.yml` with examples than start from
    `docker-compose` syntaxes. Here let''s go back to the `kiosk-example` earlier
    and start with a `version` definition and four `services`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker Compose在许多方面与Docker相同，因此更有效的方法是了解如何使用示例编写`docker-compose.yml`，而不是从`docker-compose`语法开始。现在让我们回到之前的`kiosk-example`，并从`version`定义和四个`services`开始：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `docker run` arguments for the `kiosk-example` are pretty simple, including
    a publishing port and an environment variable. On the Docker Compose side, we
    fill the source image, publishing port, and environment variables accordingly.
    Because Docker Compose is able to handle `docker build`, it would build images
    if those images cannot be found locally. We are very likely to want to leverage
    it to further decrease the effort of image management:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`kiosk-example`的`docker run`参数非常简单，包括发布端口和环境变量。在Docker Compose方面，我们相应地填写源镜像、发布端口和环境变量。因为Docker
    Compose能够处理`docker build`，如果本地找不到这些镜像，它将构建镜像。我们很可能希望利用它来进一步减少镜像管理的工作量。'
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Converting the Docker run of the `recorder-example` and `redis` in the same
    manner, we have a template like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式转换`recorder-example`和`redis`的Docker运行，我们得到了以下模板：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the MySQL part, it requires a data volume to keep its data as well as configurations.
    Therefore, in addition to the `lmysql` section, we add `volumes` at the level
    of `services` and an empty map `mysql-vol` to claim a data volume:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL部分，它需要一个数据卷来保存数据以及配置。因此，除了`lmysql`部分之外，我们在`services`级别添加`volumes`，并添加一个空映射`mysql-vol`来声明一个数据卷：
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Combining all of preceding configurations, we have the final template, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 结合所有前述的配置，我们得到了最终的模板，如下所示：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This file is put in the root folder of a project. The corresponding file tree
    is shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件放在项目的根文件夹中。相应的文件树如下所示：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Lastly, run `docker-compose up` to check if everything is fine. And we can check
    if our kiosk is up by sending a `GET /tickets` request.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`docker-compose up`来检查一切是否正常。我们可以通过发送`GET /tickets`请求来检查我们的售票亭是否正常运行。
- en: Writing a template for Docker Compose is nothing more than this. We are now
    able to run an application in the stack with ease.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Docker Compose的模板就是这样简单。现在我们可以轻松地在堆栈中运行应用程序。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Starting from the very primitive elements of Linux container to Docker tool
    stacks, we went through every aspect of containerizing an application, including
    packing and running a Docker container, writing a `Dockerfile` for code-based
    immutable deployment, and manipulating multi-containers with Docker Compose. However,
    our abilities gained in this chapter only allow us to run and connect containers
    within the same host, which limits the possibility to build larger applications.
    As such, in the next chapter, we'll meet Kubernetes, unleashing the power of Container
    beyond the limits of scale.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux容器的最原始元素到Docker工具栈，我们经历了容器化应用的每个方面，包括打包和运行Docker容器，为基于代码的不可变部署编写`Dockerfile`，以及使用Docker
    Compose操作多个容器。然而，本章获得的能力只允许我们在同一主机上运行和连接容器，这限制了构建更大应用的可能性。因此，在下一章中，我们将遇到Kubernetes，释放容器的力量，超越规模的限制。
