["```java\npublic class ConcurrentDataLoader {\n\n    public static List<Record> load(Path path) throws IOException {\n        System.out.println(\"Loading data\");\n\n        List<String> lines = Files.readAllLines(path);\n```", "```java\n        List<Record> records = lines\n                .parallelStream()\n                .skip(1)\n                .map(l -> l.split(\";\"))\n                .map(t -> new Record(t))\n                .collect(Collectors.toList());\n```", "```java\n        return records;\n    }\n}\n```", "```java\npublic class ConcurrentStatistics {\n\n    public static void jobDataFromSubscribers(List<Record> records) {\n        System.out.println (\"****************************************\");\n        System.out.println(\"Job info for Deposit subscribers\");\n\n        ConcurrentMap<String, List<Record>> map = records.parallelStream()\n                .filter(r -> r.getSubscribe().equals(\"yes\"))\n                .collect(Collectors.groupingByConcurrent (Record::getJob));\n\n        map.forEach((k, l) -> System.out.println(k + \": \" + l.size()));\n\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void ageDataFromSubscribers(List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Age info for Deposit subscribers\");\n\n        DoubleSummaryStatistics statistics = records.parallelStream()\n                .filter(r -> r.getSubscribe().equals(\"yes\"))\n                .collect(Collectors.summarizingDouble (Record::getAge));\n\n        System.out.println(\"Min: \" + statistics.getMin());\n        System.out.println(\"Max: \" + statistics.getMax());\n        System.out.println(\"Average: \" + statistics.getAverage());\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void maritalDataFromSubscribers(List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Marital info for Deposit subscribers\");\n\n        records.parallelStream()\n                .filter(r -> r.getSubscribe().equals(\"yes\"))\n                .map(r -> r.getMarital())\n                .distinct()\n                .sorted()\n                .forEachOrdered(System.out::println);\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void campaignDataFromNonSubscribersBad (List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Number of contacts for Non Subscriber\");\n\n        IntStream stream = records.parallelStream()\n                .filter(Record::isNotSubscriber)\n                .mapToInt(r -> r.getCampaign());\n\n        System.out\n                .println(\"Max number of contacts: \" + stream.max().getAsInt());\n        System.out\n                .println(\"Min number of contacts: \" + stream.min().getAsInt());\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void campaignDataFromNonSubscribersOk (List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Number of contacts for Non Subscriber\");\n        int value = records.parallelStream()\n                .filter(Record::isNotSubscriber)\n                .map(r -> r.getCampaign())\n                .mapToInt(Integer::intValue)\n                .max()\n                .getAsInt();\n\n        System.out.println(\"Max number of contacts: \" + value);\n\n        value = records.parallelStream()\n                .filter(Record::isNotSubscriber)\n                .map(r -> r.getCampaign())\n                .mapToInt(Integer::intValue)\n                .min()\n                .getAsInt();\n\n        System.out.println(\"Min number of contacts: \" + value);\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void multipleFilterData(List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Multiple filter\");\n\n        Stream<Record> stream1 = records.parallelStream()\n                .filter(Record::isDefaultCredit);\n        Stream<Record> stream2 = records.parallelStream()\n                .filter(r -> !(r.isHousing()));\n        Stream<Record> stream3 = records.parallelStream()\n                .filter(r -> !(r.isLoan()));\n\n        Stream<Record> complete = Stream.concat(stream1, stream2);\n        complete = Stream.concat(complete, stream3);\n\n        long value = complete.parallel().unordered().distinct().count();\n\n        System.out.println(\"Number of people: \" + value);\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void multipleFilterDataPredicate (List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Multiple filter with Predicate\");\n\n        Predicate<Record> p1 = r -> r.isDefaultCredit();\n        Predicate<Record> p2 = r -> !r.isHousing();\n        Predicate<Record> p3 = r -> !r.isLoan();\n\n        Predicate<Record> pred = Stream.of(p1, p2, p3)\n                    .reduce(Predicate::or).get();\n\n        long value = records.parallelStream().filter(pred).count();\n\n        System.out.println(\"Number of people: \" + value);\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void durationDataForNonSubscribers(List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"Duration data for non subscribers\");\n        records.parallelStream().filter(r -> r.isNotSubscriber()) .sorted(Comparator.comparingInt (Record::getDuration) .reversed()).limit(10) .forEachOrdered(\n            r -> System.out.println(\"Education: \" + r.getEducation() + \"; Duration: \" + r.getDuration()));\n        System.out.println (\"****************************************\");\n    }\n```", "```java\n    public static void peopleBetween25and50(List<Record> records) {\n\n        System.out.println (\"****************************************\");\n        System.out.println(\"People between 25 and 50\");\n        int count=records.parallelStream() .map(r -> r.getAge()) .filter(a -> (a >=25 ) && (a <=50)) .mapToInt(a -> 1) .reduce(0, Integer::sum);\n        System.out.println(\"People between 25 and 50: \"+count);\n        System.out.println (\"****************************************\");\n    }\n```", "```java\npublic class ConcurrentMain {\n    static Map<String, List<Double>> totalTimes = new LinkedHashMap<>();\n    static List<Record> records;\n\n    private static void measure(String name, Runnable r) {\n        long start = System.nanoTime();\n        r.run();\n        long end = System.nanoTime();\n        totalTimes.computeIfAbsent(name, k -> new ArrayList<>()).add((end - start) / 1_000_000.0);\n    }\n```", "```java\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"data\\\\bank-additional-full.csv\");\n\n        for (int i = 0; i < 10; i++) {\n            records = ConcurrentDataLoader.load(path);\n            measure(\"Job Info\", () -> ConcurrentStatistics.jobDataFromSubscribers (records));\n            measure(\"Age Info\", () -> ConcurrentStatistics.ageDataFromSubscribers (records));\n            measure(\"Marital Info\", () -> ConcurrentStatistics.maritalDataFromSubscribers (records));\n            measure(\"Multiple Filter\", () -> ConcurrentStatistics.multipleFilterData(records));\n            measure(\"Multiple Filter Predicate\", () -> ConcurrentStatistics.multipleFilterDataPredicate (records));\n            measure(\"Duration Data\", () -> ConcurrentStatistics.durationDataForNonSubscribers (records));\n            measure(\"Number of Contacts Bad: \", () -> ConcurrentStatistics .campaignDataFromNonSubscribersBad(records));\n            measure(\"Number of Contacts\", () -> ConcurrentStatistics .campaignDataFromNonSubscribersOk(records));\n            measure(\"People Between 25 and 50\", () -> ConcurrentStatistics.peopleBetween25and50(records));\n        }\n```", "```java\n                times.stream().map(t -> String.format(\"%6.2f\", t)).collect(Collectors.joining(\" \")), times .stream().mapToDouble (Double::doubleValue).average().getAsDouble()));\n    }\n}\n```", "```java\nvelankanni:4,18005302.txt:10.13,20681361.txt:10.13,45672176.txt:10 .13,6592085.txt:10.13\n```", "```java\n        public static void basicSearch(String query[]) throws IOException {\n\n        Path path = Paths.get(\"index\", \"invertedIndex.txt\");\n        HashSet<String> set = new HashSet<>(Arrays.asList(query));\n        QueryResult results = new QueryResult(new ConcurrentHashMap<>());\n\n        try (Stream<String> invertedIndex = Files.lines(path)) {\n\n            invertedIndex.parallel() .filter(line -> set.contains(Utils.getWord(line))) .flatMap(ConcurrentSearch::basicMapper) .forEach(results::append);\n\n            results .getAsList() .stream() .sorted() .limit(100) .forEach(System.out::println);\n\n            System.out.println(\"Basic Search Ok\");\n        }\n\n    }\n```", "```java\n    public static Stream<Token> basicMapper(String input) {\n        ConcurrentLinkedDeque<Token> list = new ConcurrentLinkedDeque();\n        String word = Utils.getWord(input);\n        Arrays .stream(input.split(\",\"))\n          .skip(1) .parallel() .forEach(token -> list.add(new Token(word, token)));\n\n        return list.stream();\n    }\n```", "```java\npublic class Token {\n\n    private final String word;\n    private final double tfxidf;\n    private final String file;\n```", "```java\n    public Token(String word, String token) {\n        this.word=word;\n        String[] parts=token.split(\":\");\n        this.file=parts[0];\n        this.tfxidf=Double.parseDouble(parts[1]);\n    }\n```", "```java\n    @Override\n    public String toString() {\n        return word+\":\"+file+\":\"+tfxidf;\n    }\n```", "```java\npublic class QueryResult {\n\n    private Map<String, Document> results;\n```", "```java\n    public QueryResult(Map<String, Document> results) {\n        this.results=results;\n    }\n```", "```java\n    public void append(Token token) {\n        results.computeIfAbsent(token.getFile(), s -> new Document(s)).addTfxidf(token.getTfxidf());\n    }\n```", "```java\n    public List<Document> getAsList() {\n        return new ArrayList<>(results.values());\n    }\n```", "```java\n        invertedIndex.parallel() .filter(line -> set.contains(Utils.getWord(line))) .flatMap(ConcurrentSearch::limitedMapper) .forEach(results::append);\n```", "```java\n    public static Stream<Token> limitedMapper(String input) {\n        ConcurrentLinkedDeque<Token> list = new ConcurrentLinkedDeque();\n        String word = Utils.getWord(input);\n\n        Arrays.stream(input.split(\",\")) .skip(1) .limit(100) .parallel() .forEach(token -> {\n            list.add(new Token(word, token));\n          });\n\n        return list.stream();\n    }\n```", "```java\n    public static void htmlSearch(String query[], String fileName) throws IOException {\n        Path path = Paths.get(\"index\", \"invertedIndex.txt\");\n        HashSet<String> set = new HashSet<>(Arrays.asList(query));\n        QueryResult results = new QueryResult(new ConcurrentHashMap<>());\n\n        try (Stream<String> invertedIndex = Files.lines(path)) {\n\n            invertedIndex.parallel() .filter(line -> set.contains(Utils.getWord(line))) .flatMap(ConcurrentSearch::limitedMapper) .forEach(results::append);\n```", "```java\n                         path = Paths.get(\"output\", fileName + \"_results.html\");\n            try (BufferedWriter fileWriter = Files.newBufferedWriter(path, StandardOpenOption.CREATE)) {\n\n                fileWriter.write(\"<HTML>\");\n                fileWriter.write(\"<HEAD>\");\n                fileWriter.write(\"<TITLE>\");\n                fileWriter.write(\"Search Results with Streams\");\n                fileWriter.write(\"</TITLE>\");\n                fileWriter.write(\"</HEAD>\");\n                fileWriter.write(\"<BODY>\");\n                fileWriter.newLine();\n```", "```java\n                            results.getAsList()\n                    .stream()\n                    .sorted()\n                    .limit(100)\n                    .map(new ContentMapper(query)).forEach(l -> {\n                        try {\n                            fileWriter.write(l);\n                            fileWriter.newLine();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                });\n\n                fileWriter.write(\"</BODY>\");\n                fileWriter.write(\"</HTML>\");\n\n            }\n```", "```java\npublic class ContentMapper implements Function<Document, String> {\n    private String query[];\n\n    public ContentMapper(String query[]) {\n        this.query = query;\n    }\n```", "```java\n    public String apply(Document d) {\n        String result = \"\";\n\n        try (Stream<String> content = Files.lines(Paths.get(\"docs\",d.getDocumentName()))) {\n            result = \"<h2>\" + d.getDocumentName() + \": \"\n                    + content.findFirst().get()\n                    + \": \" + d.getTfxidf() + \"</h2>\";\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new UncheckedIOException(e);\n        }\n```", "```java\n                try (Stream<String> content = Files.lines(Paths.get (\"docs\",d.getDocumentName()))) {\n            result += content\n                    .filter(l -> Arrays.stream(query).anyMatch (l.toLowerCase()::contains))\n                    .limit(3)\n                    .map(l -> \"<p>\"+l+\"</p>\")\n                    .reduce(\"\",String::concat);\n            return result;\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new UncheckedIOException(e);\n        }\n    }\n```", "```java\n        public static void preloadSearch(String[] query, ConcurrentInvertedIndex invertedIndex) {\n\n        HashSet<String> set = new HashSet<>(Arrays.asList(query));\n        QueryResult results = new QueryResult(new ConcurrentHashMap<>());\n\n        invertedIndex.getIndex()\n            .parallelStream()\n            .filter(token -> set.contains(token.getWord()))\n            .forEach(results::append);\n\n        results\n            .getAsList()\n            .stream()\n            .sorted()\n            .limit(100)\n            .forEach(document -> System.out.println(document));\n\n        System.out.println(\"Preload Search Ok.\");\n    }\n```", "```java\npublic class ConcurrentFileLoader {\n\n    public ConcurrentInvertedIndex load(Path path) throws IOException {\n        ConcurrentInvertedIndex invertedIndex = new ConcurrentInvertedIndex();\n        ConcurrentLinkedDeque<Token> results=new ConcurrentLinkedDeque<>();\n```", "```java\n        try (Stream<String> fileStream = Files.lines(path)) {\n            fileStream\n            .parallel()\n            .flatMap(ConcurrentSearch::limitedMapper)\n            .forEach(results::add);\n        }\n\n        invertedIndex.setIndex(new ArrayList<>(results));\n        return invertedIndex;\n    }\n}\n```", "```java\n    public static void executorSearch(String[] query, ConcurrentInvertedIndex invertedIndex, ForkJoinPool pool) {\n        HashSet<String> set = new HashSet<>(Arrays.asList(query));\n        QueryResult results = new QueryResult(new ConcurrentHashMap<>());\n\n        pool.submit(() -> {\n            invertedIndex.getIndex()\n                .parallelStream()\n                .filter(token -> set.contains(token.getWord()))\n                .forEach(results::append);\n\n            results\n                .getAsList()\n                .stream()\n                .sorted()\n                .limit(100)\n                .forEach(document -> System.out.println(document));\n        }).join();\n\n        System.out.println(\"Executor Search Ok.\");\n\n    }\n```", "```java\n    public static void getWordsInFile1(String fileName, ConcurrentInvertedIndex index) {\n        long value = index\n                .getIndex()\n                .parallelStream()\n                .filter(token -> fileName.equals(token.getFile()))\n                .count();\n        System.out.println(\"Words in File \"+fileName+\": \"+value);\n    }\n```", "```java\n    public static void getWordsInFile2(String fileName, ConcurrentInvertedIndex index) {\n\n        long value = index\n                .getIndex()\n                .parallelStream()\n                .filter(token -> fileName.equals(token.getFile()))\n                .mapToLong(token -> 1)\n                .reduce(0, Long::sum);\n        System.out.println(\"Words in File \"+fileName+\": \"+value);\n    }\n```", "```java\n    public static void getAverageTfxidf(String fileName, ConcurrentInvertedIndex index) {\n\n        long wordCounter = index\n                .getIndex()\n                .parallelStream()\n                .filter(token -> fileName.equals(token.getFile()))\n                .mapToLong(token -> 1)\n                .reduce(0, Long::sum);\n\n        double tfxidf = index\n                .getIndex()\n                .parallelStream()\n                .filter(token -> fileName.equals(token.getFile()))\n                .reduce(0d, (n,t) -> n+t.getTfxidf(), (n1,n2) -> n1+n2);\n\n        System.out.println(\"Words in File \"+fileName+\": \"+(tfxidf/wordCounter));\n    }\n```", "```java\n    public static void maxTfxidf(ConcurrentInvertedIndex index) {\n        Token token = index\n                .getIndex()\n                .parallelStream()\n                .reduce(new Token(\"\", \"xxx:0\"), (t1, t2) -> {\n                    if (t1.getTfxidf()>t2.getTfxidf()) {\n                        return t1;\n                    } else {\n                        return t2;\n                    }\n                });\n        System.out.println(token.toString());\n    }\n```", "```java\n    public static void minTfxidf(ConcurrentInvertedIndex index) {\n        Token token = index\n                .getIndex()\n                .parallelStream()\n                .reduce(new Token(\"\", \"xxx:1000000\"), (t1, t2) -> {\n                    if (t1.getTfxidf()<t2.getTfxidf()) {\n                        return t1;\n                    } else {\n                        return t2;\n                    }\n                });\n        System.out.println(token.toString());\n    }\n```", "```java\npublic class ConcurrentMain {\n\n    public static void main(String[] args) {\n\n        String query1[]={\"james\",\"bond\"};\n        String query2[]={\"gone\",\"with\",\"the\",\"wind\"};\n        String query3[]={\"rocky\"};\n\n            Date start, end;\n\n        bufferResults.append(\"Version 1, query 1, concurrent\\n\");\n        start = new Date();\n        ConcurrentSearch.basicSearch(query1);\n        end = new Date();\n        bufferResults.append(\"Execution Time: \"\n                + (end.getTime() - start.getTime()) + \"\\n\");\n```", "```java\n        ConcurrentInvertedIndex invertedIndex = new ConcurrentInvertedIndex();\n        ConcurrentFileLoader loader = new ConcurrentFileLoader();\n        invertedIndex = loader.load(Paths.get(\"index\",\"invertedIndex.txt\"));\n```", "```java\n        ForkJoinPool pool = new ForkJoinPool();\n```"]