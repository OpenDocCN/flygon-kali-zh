- en: '*Chapter 3*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*'
- en: Node.js APIs and Web Scraping
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js API和Web抓取
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Implement Node.js applications using global objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局对象实现Node.js应用程序
- en: Create readable and writable Streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可读和可写流
- en: Read and write to files using asynchronous and synchronous APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步和同步API读写文件
- en: Create static and dynamic web servers using the http module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用http模块创建静态和动态Web服务器
- en: Download content from websites using the http/https modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用http/https模块从网站下载内容
- en: Query and extract data from parsed HTML content
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和提取解析后的HTML内容中的数据
- en: In this chapter, we will learn about global objects and functions. Then, we
    will learn how to write efficient web servers, both static and dynamic, using
    the http module. Finally, we will use the http and https modules to scrape web
    pages and extract data from them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习全局对象和函数。然后，我们将学习如何使用http模块编写高效的Web服务器，包括静态和动态的。最后，我们将使用http和https模块来抓取网页并从中提取数据。
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: From the outset, Node.js was created to provide an alternative to the thread-per-request
    model of the first generation of HTTP servers. The event loop and the asynchronous
    nature of Node.js make it ideal for I/O-intensive servers that need to provide
    high throughput for a high number of concurrent clients. Because of that, it came
    armed with powerful and simple-to-use APIs to build HTTP servers out of the box.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Node.js就被创建为第一代HTTP服务器的每个请求模型的替代方案。Node.js的事件循环和异步特性使其非常适合需要为大量并发客户端提供高吞吐量的I/O密集型服务器。因此，它配备了强大且易于使用的API，可以直接构建HTTP服务器。
- en: In the previous chapter, we talked about what Node.js and NPM are and how they
    work. In this chapter, you will learn about the basic global objects that are
    available to every script in Node.js. You will learn about readable and writable
    streams and how you can use them to read and write to files asynchronously. You
    will also learn how to read and write to files using the synchronous filesystem
    APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Node.js和NPM是什么以及它们是如何工作的。在本章中，您将了解Node.js中每个脚本都可以使用的基本全局对象。您将学习可读和可写流，以及如何使用它们来异步读写文件。您还将学习如何使用同步文件系统API来读写文件。
- en: In the last couple of sections, you will learn how to use the HTTP module to
    write web servers and make HTTP requests. You will build a static and a dynamic
    web server. Then, you will learn the basics of web scraping and how to use it
    to extract data from websites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几节中，您将学习如何使用HTTP模块来编写Web服务器和发起HTTP请求。您将构建一个静态和一个动态Web服务器。然后，您将学习Web抓取的基础知识，以及如何使用它来从网站中提取数据。
- en: Globals
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局对象
- en: The Node.js execution context contains a few **global** variables and functions
    that can be used from anywhere in any script. The most widely used of all is the
    `require` function, since it is the function that helps you load other modules
    and access the non-global functions, classes, and variables that are available
    from the Node.js APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js执行上下文包含一些**全局**变量和函数，可以在任何脚本中的任何地方使用。其中最常用的是`require`函数，因为它是帮助您加载其他模块并访问来自Node.js
    API的非全局函数、类和变量的函数。
- en: 'You must have noticed this function being used in the previous chapter when
    we loaded the `commander` module from the package you installed in your application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定注意到了在上一章中使用了这个函数，当我们从您的应用程序中安装的包中加载`commander`模块时：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It receives one parameter, which is a string representing the ID of the module
    you want to load, and returns the module's content. Internal modules, such as
    the ones we will discuss in this chapter, and the modules that are loaded from
    packages and installed by npm, are identified directly by their names, such as
    commander, fs, and http. In *Chapter 5, Modular JavaScript*, you will see how
    to create your own modules and how to use this function to load them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个参数，这个参数是一个表示您想要加载的模块的ID的字符串，并返回模块的内容。内部模块，比如我们将在本章讨论的模块，以及从npm安装的包中加载的模块，都可以直接通过它们的名称来识别，比如commander、fs和http。在*第5章，模块化JavaScript*中，您将学习如何创建自己的模块，以及如何使用这个函数来加载它们。
- en: Another important and widely used global is the console. Just like in the Chrome
    Developer tools, the console can be used to print text to the Terminal using standard
    output and standard error. It can also be used to print text to files for logging.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要且广泛使用的全局对象是控制台。就像在Chrome开发者工具中一样，控制台可以用来使用标准输出和标准错误将文本打印到终端。它也可以用来将文本打印到文件进行日志记录。
- en: 'So far, you have used console many times, like in the last exercise of the
    previous chapter, where you printed the following manipulated HTML:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经多次使用了控制台，比如在上一章的最后一个练习中，您打印了以下操作过的HTML：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The console has a lot more to offer than just the `log` function. Let's take
    a deeper look at some of its applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台不仅仅只有`log`函数。让我们更深入地了解一些它的应用。
- en: 'When you want to print some text to the console, you can use any of the following
    functions: `debug`, `error`, `info`, and `warn`. The difference between them is
    where the text ends up. When you use the `debug` and `info` methods, the text
    will be printed to standard output. For `warn` and `error`, the messages will
    be printed to standard error.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将一些文本打印到控制台时，您可以使用以下任何一个函数：`debug`、`error`、`info`和`warn`。它们之间的区别在于文本的输出位置。当您使用`debug`和`info`方法时，文本将被打印到标准输出。对于`warn`和`error`，消息将被打印到标准错误。
- en: 'Ensure that you have the following code inside `index.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在`index.js`中有以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, run the script and redirect to different files, and then print their content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行脚本并重定向到不同的文件，然后打印它们的内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the preceding functions, as well as the log function, can format text if
    you want, which they do by providing extra arguments and a format string. You
    can read more about format strings in the `util.format` function documentation:
    [https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args](https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args).
    You can also use backticks if you prefer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的函数以及log函数都可以根据需要格式化文本，方法是提供额外的参数和格式字符串。您可以在`util.format`函数文档中阅读更多关于格式字符串的信息：[https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args](https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args)。如果愿意，您也可以使用反引号：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output would be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you need to print some text conditionally, you can use `assert`. Assert
    can be used to check whether a condition is true. If it''s false, then it will
    print the text using `console.warn`, with some text explaining that the assertion
    failed. If it''s true, then it will not print anything. Here is an example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要有条件地打印一些文本，可以使用`assert`。Assert可用于检查条件是否为真。如果为假，则它将使用`console.warn`打印文本，并解释断言失败的原因。如果为真，则不会打印任何内容。以下是一个示例：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This would only output the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只输出以下内容：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `trace` function is used to identify the source file and line of the output.
    It receives the same arguments as log and the others, but it will also print the
    stack trace for the log statement; that is, the filenames and lines where the
    call happened:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace`函数用于标识输出的源文件和行。它接收与log和其他函数相同的参数，但它还将打印日志语句的堆栈跟踪；也就是调用发生的文件名和行：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would print the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you have an array of data and want to show it as a table, you can use the
    table method. It receives two arguments: the tabular data and the properties you
    want to see in the table. For example, consider the following tabular data (array
    of objects):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一组数据并希望将其显示为表格，可以使用table方法。它接收两个参数：表格数据和您希望在表格中看到的属性。例如，考虑以下表格数据（对象数组）：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You could print all the columns by passing the data to `console.table`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将数据传递给`console.table`来打印所有列：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would give us the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '![Figure 3.1: Output of the console.table function'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：console.table函数的输出'
- en: '](Images/C14587_03_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_01.jpg)'
- en: 'Figure 3.1: Output of the console.table function'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：console.table函数的输出
- en: 'Alternatively, you could pass a list of the property names that you want:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以传递要显示的属性名称列表：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output of the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](Images/C14587_03_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_03_02.jpg)'
- en: 'Figure 3.2: Output of console.table when passing a list of properties to print'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：当传递要打印的属性列表时，console.table的输出
- en: 'Another interesting thing you can use `console` for is to time how long specific
    parts of your code will take to run. To do that, you use the `time` and `timeEnd`
    methods, as shown in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`console`来计算代码中特定部分运行所需的时间。为此，您可以使用`time`和`timeEnd`方法，如下例所示：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This would output the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also give your timer a name and use multiple timers at the same time:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为计时器命名，并同时使用多个计时器：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would output the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sometimes, you want to know where a script was loaded from or what the full
    path of the file is. For that, every script has two globals defined: `__filename`
    and `__dirname` (that''s two underscores, and then filename/dirname). An example
    is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您想知道脚本是从哪里加载的，或者文件的完整路径是什么。为此，每个脚本都有两个全局变量：`__filename`和`__dirname`（两个下划线，然后是文件名/目录名）。示例如下：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would output the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the browser, when you want to execute a certain function in the future or
    at regular intervals, you can use `setTimeout` and `setInterval`, respectively.
    These functions are also available in the Node.js execution context and work the
    same way as in the browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，当您想要在将来的某个时间执行特定函数或定期执行时，可以分别使用`setTimeout`和`setInterval`。这些函数也在Node.js执行上下文中可用，并且与在浏览器中的工作方式相同。
- en: 'You can schedule code to execute some time from now by passing a callback function
    to be executed and the amount of time in milliseconds in the future you want it
    to be executed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将回调函数传递给它以及您希望它在未来的毫秒数中执行的时间量来安排代码在未来的某个时间执行：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the browser, `setTimeout` returns a timer ID, which is an integer and can''t
    do more than canceling the timer through the `clearTimeout` function. In Node.js,
    `setTimeout` returns a `Timeout` object that has some methods itself. An interesting
    one is the `refresh` method, which resets the start time of the timer to the current
    time and restarts counting the timer as if it had been scheduled at that moment.
    Take a look at the following example code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，`setTimeout`返回一个定时器ID，这是一个整数，除了通过`clearTimeout`函数取消定时器外，不能做更多事情。在Node.js中，`setTimeout`返回一个`Timeout`对象，它本身具有一些方法。一个有趣的方法是`refresh`方法，它将定时器的开始时间重置为当前时间，并重新开始计时，就好像它是在那一刻被安排的一样。看看下面的示例代码：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This prints the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印以下内容：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the output, you can see that even though `secondTimer` was scheduled to
    run 3 seconds in the future, it ran 5 seconds in the future. That's because the
    second `setTimeout`, which was set to 2 seconds, refreshes it, restarting the
    count at that time, adding 2 seconds to the 3-second timer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，即使`secondTimer`被安排在未来3秒运行，它实际上是在未来5秒运行。这是因为第二个`setTimeout`设置为2秒，刷新了它，重新从那个时间开始计时，将2秒添加到3秒计时器上。
- en: 'As we mentioned previously, you can use the `Timeout` instance to cancel the
    timer using the `clearTimeout` function. The following code is an example of this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以使用`Timeout`实例使用`clearTimeout`函数取消定时器。以下代码是此示例：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output for this code would be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`setTimeout` executes only once. You can use `setInterval` to do a specific
    task every specific amount of time. `setInterval` also returns a `Timeout` instance
    that can be used to cancel the timer using `clearInterval`. The following example
    sets a timer to run every second and keeps track of the number of times it ran.
    After a certain number of executions, it cancels the timer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`只执行一次。您可以使用`setInterval`每隔一段时间执行特定任务。`setInterval`还返回一个`Timeout`实例，可以使用`clearInterval`取消定时器。以下示例设置了一个定时器，每秒运行一次，并跟踪它运行的次数。在一定数量的执行之后，它会取消定时器：'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output for this code looks something like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出看起来像以下内容：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the browser, we have a global object called window that represents the browser.
    In Node.js, we have process, which represents the currently running application.
    Through it, we can access the arguments that are passed into the application,
    including standard inputs and outputs and other information about the process,
    such as version or process ID.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们有一个称为window的全局对象，代表浏览器。在Node.js中，我们有process，它代表当前运行的应用程序。通过它，我们可以访问传递给应用程序的参数，包括标准输入和输出以及有关进程的其他信息，例如版本或进程ID。
- en: To access the arguments that are passed into the process, you can use the `argv`
    attribute of the global variable process. `argv` is an array that contains each
    argument in a position. It includes the path to the Node.js binary and the full
    path of the script as the first two elements. After that, all the other extra
    arguments are passed in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问传递给进程的参数，可以使用全局变量process的`argv`属性。`argv`是一个包含每个参数的数组。它包括Node.js二进制文件的路径和脚本的完整路径作为前两个元素。之后，所有其他额外的参数都被传递进来。
- en: 'The following code would print all the arguments passed in, each in one line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印传入的所有参数，每个参数一行：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's go over some sample outputs for this single-line application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个单行应用程序的一些示例输出。
- en: 'No extra argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 无额外参数：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Many arguments separated one by one:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多参数一个接一个地分开：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One argument all in one string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个参数都在一个字符串中：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous chapter, we used the `commander` library to parse command-line
    arguments. When configuring `commander`, the last call to it was `parse(process.argv)`,
    which gave `commander` access to all the options that were passed in:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了`commander`库来解析命令行参数。在配置`commander`时，对它的最后一次调用是`parse(process.argv)`，这使`commander`可以访问传入的所有选项：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another important role that the process variable holds is access to standard
    inputs and outputs. If you want to print something to the console, you can use
    `stdout` and `stderr`. These two attributes are what `console.log` and all the
    other methods in the console use under the hood. The difference is that `stdout`
    and `stderr` do not add a new line at the end of each call, so you have to do
    that yourself if you want each output to go into its own line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: process变量扮演的另一个重要角色是访问标准输入和输出。如果要向控制台打印内容，可以使用`stdout`和`stderr`。这两个属性是控制台中的`console.log`和所有其他方法在内部使用的。不同之处在于`stdout`和`stderr`在每次调用时不会在末尾添加新行，因此如果希望每个输出都进入自己的行，您必须自己添加新行：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These are two examples that print something with a new line at the end. For
    most cases, it is recommended to use the console since it gives you some extra
    stuff on top, such as logging levels and formatting.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个示例，打印出以换行结束的内容。在大多数情况下，建议使用控制台，因为它可以提供一些额外的东西，例如日志级别和格式化。
- en: 'If you want to read input from the command line, you can use `process.stdin`.
    `stdin` is a Stream, which we''re going to talk more about in the next section.
    For now, you just need to know that Streams are based on events. That means that
    when input comes in, it will arrive in the form of a data event. To receive input
    from the user, you need to listen to that event:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从命令行读取输入，可以使用`process.stdin`。`stdin`是一个流，我们将在下一节中更多地讨论。现在，您只需要知道流是基于事件的。这意味着当输入进来时，它将以数据事件的形式到达。要从用户那里接收输入，您需要监听该事件：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When there''s no more code to be executed, the event loop will block, waiting
    for input from standard input. When the input is read, it will be passed into
    the callback function as a Buffer of bytes. You can convert it into a string by
    calling its `toString` method, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的代码需要执行时，事件循环将阻塞，等待标准输入的输入。当读取输入时，它将作为字节缓冲传递到回调函数中。您可以通过调用其`toString`方法将其转换为字符串，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, you can use it like any normal string. The following sample application
    demonstrates how you can use `stdout`, `stderr`, and `stdin` to request input
    from the user from the command line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，您可以像普通字符串一样使用它。以下示例应用程序演示了如何使用`stdout`、`stderr`和`stdin`从命令行请求用户输入： '
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code shows what it would look like after running the application
    and typing some words, pressing *Enter*, and then typing "exit" to quit the application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了在运行应用程序并输入一些单词，按*Enter*，然后输入“exit”以退出应用程序后的样子：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, you can see that when the user types "exit", it executes
    a special branch of the application code that calls `process.exit`, which is a
    function that exits the whole process and returns the specified exit code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到当用户输入“exit”时，它执行应用程序代码的特殊分支，调用`process.exit`，这是一个退出整个进程并返回指定退出代码的函数。
- en: 'Exercise 11: Creating a Task Reminder Application'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：创建任务提醒应用程序
- en: In this exercise, we will create a task reminder application. Now that we have
    learned how to interact with the user using the global variable process and also
    learned how to create timers, let's write an application that will use these new
    skills to manage reminders from the command line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个任务提醒应用程序。现在我们已经学会了如何使用全局变量process与用户进行交互，还学会了如何创建定时器，让我们编写一个应用程序，利用这些新技能来管理命令行中的提醒。
- en: The application will receive inputs from the user and collect information to
    build a reminder. It will use a message, a time unit, and an amount of time. The
    input to the application will be provided in phases. Each phase will ask the user
    for some input, collect it, validate it, and then set the value of a variable
    to move to the next phase.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将接收用户输入并收集信息以构建提醒。它将使用消息、时间单位和一定的时间。应用程序的输入将分阶段提供。每个阶段都会要求用户输入一些内容，收集它，验证它，然后设置一个变量的值以进入下一个阶段。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'In an empty folder, create a new package using `npm init` and a file called
    `index.js`. In the `index.js` file, we will start by adding some constants and
    variables where we will store the state to create the timer:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空文件夹中，使用`npm init`创建一个新的包，并创建一个名为`index.js`的文件。在`index.js`文件中，我们将首先添加一些常量和变量，用于存储创建计时器的状态：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will add the function that is the heart of the application. This is
    what the function looks like:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加应用程序的核心函数。该函数如下所示：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function processes all the input from the user in a set of conditions that
    will be based on the current state, based on what variables are already available.
    When the input is processed, it's then set back to null so that the next stage
    can be executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数处理用户的所有输入，根据当前状态的一组条件进行处理，根据已经可用的变量。处理输入后，将其设置为null，以便可以执行下一个阶段。
- en: 'The preceding function calls some functions that don''t exist yet: `askForMessage`,
    `askForTimeUnit`, and `askForAmount`. These functions are responsible for validating
    the input and setting the variables according to each phase so that the code can
    move to the next phase.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数调用了一些尚不存在的函数：`askForMessage`，`askForTimeUnit`和`askForAmount`。这些函数负责验证输入并根据每个阶段设置变量，以便代码可以进入下一个阶段。
- en: Add some details to the `askForMessage` function. The first thing the function
    does is check whether the input is null, which means that it's changing phase
    for the first time. This means it needs to print the prompt for input for the
    user.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些细节到`askForMessage`函数。该函数首先检查输入是否为null，这意味着它正在首次更改阶段。这意味着它需要为用户打印输入提示。
- en: 'This is what the code looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE38]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the input is not `null`, this means that the user already inputted information
    for the current state and it needs to be validated. If validation fails, print
    more information and wait for the next input.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入不是`null`，这意味着用户已经为当前状态输入了信息，需要进行验证。如果验证失败，打印更多信息并等待下一个输入。
- en: If the input is valid, then it sets the variable for the current state, which
    is `message` in this case, which will move the code to the next phase.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入有效，则设置当前状态的变量，这种情况下是`message`，这将使代码进入下一个阶段。
- en: 'Next, we create the `askForTimeUnit` function, which is the function that will
    handle the next phase of the code. This function uses the constants listed in
    the first step to print the supported time units and lets the user pick one. It
    works similar to the `askForMessage` function: `prompt`, `validate`, and `set
    value`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`askForTimeUnit`函数，这是处理代码的下一个阶段的函数。该函数使用第一步列出的常量来打印支持的时间单位，并让用户选择一个。它的工作方式类似于`askForMessage`函数：`prompt`，`validate`和`set
    value`：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Lastly, we create the `askForAmount` function, which handles the last phase.
    This function prompts the user for some amount of time to create the timer. Like
    before, it has three parts: `prompt`, `validate`, and `set value`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建`askForAmount`函数，处理最后一个阶段。该函数提示用户输入一定的时间来创建计时器。与之前一样，它有三个部分：`prompt`，`validate`和`set
    value`：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At the end of the `askForAmount` function, it calls the `setTimerAndRestart`
    function. Let''s create that function, which creates the timer and resets all
    states so that the loop can start again, and the user can create new timers. This
    is what the `setTimerAndRestart` function looks like:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`askForAmount`函数的末尾，它调用`setTimerAndRestart`函数。让我们创建该函数，它创建计时器并重置所有状态，以便循环可以重新开始，并且用户可以创建新的计时器。该`setTimerAndRestart`函数如下所示：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: One important bit here is the special character, `\x07`. This will cause your
    Terminal to make a beep and then print the text set in the message. Also, the
    text is specially formatted with new lines at the beginning and end so that it
    doesn't disrupt the usage of the tool that much since the timers will print while
    the user continues to use the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要部分是特殊字符`\x07`。这将导致您的终端发出哔哔声，然后打印消息中设置的文本。此外，文本经过特殊格式化，在开头和结尾都有换行，以便不会太大干扰工具的使用，因为计时器将在用户继续使用应用程序的同时打印。
- en: 'The final piece of the application needs to register the listener to the data
    event in standard input and start the cycle by asking the user for the message:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的最后一部分需要在标准输入中注册数据事件的监听器，并通过询问用户消息来启动循环：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, you can run the application from your Terminal, set up a couple of reminds,
    and hear it beep back at you as the timers expire:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以从终端运行应用程序，设置一些提醒，并在计时器到期时听到它发出哔哔声：
- en: '![](Images/C14587_03_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_03_03.jpg)'
- en: 'Figure 3.3: Output after running the application'
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：运行应用程序后的输出
- en: You will notice that the only way to exit the application is to send the interrupt
    signal by pressing the *Ctrl+C* keys at the same time. As an extra challenge,
    try adding some code that will create an exit point so that the user can exit
    in a friendlier way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到退出应用程序的唯一方法是同时按下*Ctrl+C*键发送中断信号。作为额外的挑战，尝试添加一些代码，以创建一个退出点，使用户可以以更友好的方式退出。
- en: Dealing with user inputs is fundamental for every command-line application.
    In this exercise, you learned how to master the asynchronous nature of Node.js
    so that you could handle a complex set of inputs to guide the user in the decision-making
    process of creating a reminder.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户输入对于每个命令行应用程序都是至关重要的。在这个练习中，您学会了如何掌握Node.js的异步特性，以便处理一组复杂的输入，引导用户在创建提醒的决策过程中。
- en: FileSystem APIs
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统API
- en: In the previous section, we learned about the global variables available to
    us in the Node.js execution context. In this section, we will learn about the
    FileSystem APIs, which are the APIs that are used to access files and directories,
    read and write data to files, and much more.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了在Node.js执行上下文中可用的全局变量。在本节中，我们将了解文件系统API，这些API用于访问文件和目录，读取和写入文件等等。
- en: But before we dig into the FileSystem APIs, we need to understand streams. In
    Node.js, a Stream is an abstract interface that represents streaming data. In
    the previous section, we used the standard I/O and briefly mentioned that they
    are streams, so let's understand them in detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入研究文件系统API之前，我们需要了解流。在Node.js中，流是表示流数据的抽象接口。在上一节中，我们使用了标准I/O，并简要提到它们是流，所以让我们详细了解它们。
- en: 'Streams can be readable, writable, or both. They are event emitters, which
    means that to receive data, you need to register event listeners, just like we
    did with standard input in the previous section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以是可读的、可写的，或者两者兼有。它们是事件发射器，这意味着要接收数据，你需要注册事件监听器，就像我们在上一节中对标准输入所做的那样：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the next section, we will continue to build on our understanding of the previous
    sections and see that streams are used as an abstraction to represent all the
    things that data can flow through, including standard input and outputs, files,
    and network sockets.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续建立对前几节的理解，并看到流被用作抽象来表示数据可以流经的所有东西，包括标准输入和输出、文件和网络套接字。
- en: 'To start understanding how this works, we will write an application that reads
    its own code by using `createReadStream` from the filesystem package. To use the
    FileSystem APIs, we need to import them, since they are not globally available:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始理解这是如何工作的，我们将编写一个应用程序，通过使用文件系统包中的`createReadStream`来读取自己的代码。要使用文件系统API，我们需要导入它们，因为它们不是全局可用的：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we can create a readable stream that points to the script file itself:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个指向脚本文件本身的可读流：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we register for the events of the stream so that we can understand
    what''s going on. The read stream has four events that you should care about:
    ready, data, close, and error.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注册流的事件，以便了解发生了什么。读取流有四个你应该关心的事件：ready、data、close和error。
- en: Ready tells you when the file is ready to start reading, although when you create
    a readable stream that points to a file, it will start reading the file immediately
    when it is available.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ready会告诉你文件何时准备好开始读取，尽管当你创建一个指向文件的可读流时，它会在文件可用时立即开始读取文件。
- en: Data, as we saw with standard input, will be called by passing in the data that
    was read from the stream as a byte buffer. The buffer needs to be transformed
    into a string by either calling its `toString` method or by concatenating it with
    another string.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数据，正如我们在标准输入中看到的，将通过传递从流中读取的数据作为字节缓冲区来调用。缓冲区需要通过调用它的`toString`方法或与另一个字符串连接来转换为字符串。
- en: Close is called when all the bytes have been read, and the stream is not readable
    anymore.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有字节都被读取完毕，流不再可读时，将调用close。
- en: '`Error` is called if an error occurs while reading from the stream.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在从流中读取时发生错误，将调用`Error`。
- en: 'The following code demonstrates how we can register for the events by printing
    content to the console as the events occur:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了我们如何通过在控制台打印内容来注册事件：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of this application appears as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的输出如下：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that you know how to read a file and how to use read streams, let''s take
    a look at writable streams in more detail. You saw some of their usage in the
    previous section, since standard output is a writable stream:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何读取文件和使用读取流，让我们更详细地了解可写流。你在上一节中看到了一些它们的用法，因为标准输出是一个可写流：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `write` method is the one most frequently used in writable streams. If
    you want to create a writable stream that writes to a file, you just need to pass
    the name of the filename:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法是可写流中最常用的方法。如果你想创建一个写入文件的可写流，你只需要传递文件名即可：'
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, you can start writing to it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以开始写入它：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Don't forget to add the newline character at the end, otherwise everything will
    be printed in the same line.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在最后添加换行符，否则所有内容将打印在同一行。
- en: 'After you''re done writing to the file, you call the `end` method to close
    it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入文件完成后，调用`end`方法来关闭它：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Writable streams also have events you can listen to. The two most important
    ones are `error` and `close`. The error event will be triggered when an error
    occurs while writing to the stream. The `close` event will be called when the
    stream is closed. There''s also the `finish` event, which will be triggered when
    the `end` method is called. The following code is the final part of the sample
    code that can be found on GitHub: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流也有你可以监听的事件。最重要的两个事件是`error`和`close`。当写入流时发生错误时，将触发`error`事件。当流关闭时，将调用`close`事件。还有`finish`事件，当调用`end`方法时将触发。以下代码是可以在GitHub上找到的示例代码的最后部分：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js)：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After running the application, you will see that it will create the `todo.txt`
    file with the expected content in it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，你会看到它会创建`todo.txt`文件，并在其中包含预期的内容：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Creating a stream that points to a file will create a stream that overwrites
    the file content by default. To create a stream to append to the file, you need
    to pass an option object with the "a" flag, as in append, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个指向文件的流将默认创建一个覆盖文件内容的流。要创建一个追加到文件的流，你需要传递一个带有"a"标志的选项对象，如追加一样：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Another interesting thing about streams is that you can pipe them. This means
    that you can send all the bytes from a read stream to a write stream. You could
    easily copy the content of one file to another with the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于流的另一个有趣的事情是你可以将它们连接起来。这意味着你可以将读取流中的所有字节发送到写入流中。你可以使用以下代码轻松地将一个文件的内容复制到另一个文件中：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Besides reading and writing to files, the FileSystem APIs also provide methods
    so that you can list files in directories, check a file's status, watch a directory
    or file for changes, copy, delete, change file permissions, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读写文件外，文件系统API还提供了方法，可以列出目录中的文件，检查文件状态，监视目录或文件的更改，复制，删除，更改文件权限等。
- en: 'When dealing with filesystem operations, you have to remember that the operations
    are asynchronous. This means that all the operations receive a callback that gets
    called when the operation has finished. When making a directory, for example,
    you could write the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件系统操作时，你必须记住这些操作是异步的。这意味着所有操作都会接收一个回调函数，在操作完成时调用。例如，当创建目录时，你可以编写以下代码：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The callback receives an error argument if something goes wrong while trying
    to create a directory, for example, if the directory already exists. Running the
    code for the first time would work:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试创建目录时出现问题，例如目录已经存在，回调函数会接收一个错误参数。第一次运行代码会成功：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But when running it for the second time, it would fail as the directory has
    already been created:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当第二次运行时，它会失败，因为目录已经被创建了：
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you want to create a file in the directory you just created, you need to
    create the file inside the callback that is passed into `mkdir`. Doing it the
    following way can fail:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在刚刚创建的目录中创建一个文件，你需要在传递给`mkdir`的回调函数中创建文件。以下方式可能会失败：
- en: '[PRE59]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This happens when you try to run it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试运行它时会发生这种情况：
- en: '[PRE60]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That''s because when the call to `writeFile` happens, there''s a chance that
    the directory still doesn''t exist. The correct way to do it is to call `writeFile`
    inside the callback that''s passed into `mkdir`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当调用`writeFile`时，目录可能还不存在。正确的做法是在传递给`mkdir`的回调函数中调用`writeFile`：
- en: '[PRE61]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since dealing with the preceding asynchronous calls is complicated and not
    all cases require high-performance asynchronous operations, in the filesystem
    module, almost all operations include a synchronous version of the same API. So,
    if you wanted to make a directory and create a file with some content in it, and
    there''s nothing else your application can be doing while the directory doesn''t
    exist, you could write the code in the following way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理前面的异步调用很复杂，并且并非所有情况都需要高性能的异步操作，在文件系统模块中，几乎所有操作都包括相同API的同步版本。因此，如果你想在目录中创建一个文件并在其中创建一些内容，而在目录不存在时应用程序没有其他事情可做，你可以按照以下方式编写代码：
- en: '[PRE62]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice the `Sync` word at the end of each method name. The output of the preceding
    code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个方法名称末尾的`Sync`单词。上述代码的输出如下：
- en: '[PRE63]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In Node.js 10, a promise-based API was also added to the filesystem module.
    Promises and other techniques that deal with asynchronous operations will be discussed
    in further chapters, so we will skip this for now.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js 10中，文件系统模块还添加了基于Promise的API。关于Promise和其他处理异步操作的技术将在后续章节中讨论，所以我们暂时跳过这部分。
- en: 'Now that you know how to create directories and read and write data to files,
    let''s move on to the next most frequently used filesystem operation: listing
    directories.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建目录和读写文件数据，让我们继续下一个最常用的文件系统操作：列出目录。
- en: 'To list files in a directory, you can use the `readdir` method. The callback
    that''s passed to the function will receive an error object if something goes
    wrong when you''re trying to read the directory and a list of filenames. The following
    code will print the names of all the files in the current directory:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出目录中的文件，可以使用`readdir`方法。传递给函数的回调函数如果在尝试读取目录时出现问题，将会接收到一个错误对象和一个文件名列表。以下代码将打印当前目录中所有文件的名称：
- en: '[PRE64]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is a sample output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'But sometimes, you want more than just filenames. Here, the `readdir` function
    accepts an options object, which can be provided with the `withFileTypes` flag.
    If the flag is passed, then what the callback gets, instead of filenames, is an
    array of `Dirents`, which contains some extra information about the file, such
    as if it is a directory or a file. The following example will print the filenames
    in the current directory and prepend it with a (D) or (F), depending on whether
    it is a directory or file, respectively:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，你不仅仅想要文件名。在这里，`readdir`函数接受一个选项对象，可以提供`withFileTypes`标志。如果传递了该标志，那么回调函数得到的不是文件名，而是一个包含有关文件的额外信息的`Dirents`数组，例如它是目录还是文件。以下示例将打印当前目录中的文件名，并根据它是目录还是文件分别添加(D)或(F)：
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The sample output looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The last operation of the FileSystem APIs that is important to be aware of
    is concerned with how to check the status of a file. If you just need to know
    whether a file exists and is readable, you can use the `access` function, which
    receives the path to the file and a set of status flags to check for. If the file
    state matches the specified flags, then no error will be passed to the callback.
    Let''s take a look at an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统API的最后一个重要操作是如何检查文件状态。如果你只需要知道文件是否存在且可读，可以使用`access`函数，它接收文件路径和一组状态标志来检查。如果文件状态与指定的标志匹配，那么错误将不会传递给回调函数。让我们看一个例子：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example, we're combining two flags, `F_OK` and `R_OK`. The first checks
    whether the file exists, while the second checks whether it's readable. You can
    combine multiple flags with the `|` (or) operator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们结合了两个标志，`F_OK`和`R_OK`。第一个检查文件是否存在，而第二个检查文件是否可读。你可以使用`|`（或）运算符组合多个标志。
- en: 'After executing the preceding code, you would see the following output if the
    file exists:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，如果文件存在，你会看到以下输出：
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the file doesn''t exist, then you would see the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，那么你会看到以下输出：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, if the file exists but is not readable, you would receive the following
    message:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果文件存在但不可读，你将收到以下消息：
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All of this looks interesting, but if you need to know whether a path is a file
    or a directory, when it was last modified, and so on, then you need to use the
    `lstat` function, which will return a Stats instance. Stats contains everything
    you need to know about a path.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些看起来很有趣，但如果你需要知道一个路径是文件还是目录，它是何时最后修改的等等，那么你需要使用`lstat`函数，它将返回一个Stats实例。Stats包含了你需要了解的关于路径的一切。
- en: 'The following example checks whether the path is a file or directory, when
    it was created and last modified, and prints that information to the console:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例检查路径是文件还是目录，它是何时创建和最后修改的，并将该信息打印到控制台：
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is a sample output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出：
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Globs are path-like strings that contain parts of the path replaced by wildcards,
    represented by `*`. When you have two `*`, for example, `**`, this means any directory
    or subdirectory. A simple example is to search for all the `.txt` files in any
    subdirectory of the current directory:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Globs是包含路径部分的字符串，通配符`*`代表。当你有两个`*`时，例如`**`，这意味着任何目录或子目录。一个简单的例子是在当前目录的任何子目录中搜索所有的`.txt`文件：
- en: '[PRE74]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Exercise 12: Searching for a File through a Directory Using Glob Pattern'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：使用Glob模式通过目录搜索文件
- en: In this exercise, we will create an application that will scan through a directory
    tree and search for files based on glob. To achieve this, we will recursively
    call the synchronous version of the `readdir` function and use the `commander`
    and the `glob-to-regexp` modules to help us with processing the user's input.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个应用程序，它将扫描目录树并根据glob搜索文件。为了实现这一点，我们将递归调用`readdir`函数的同步版本，并使用`commander`和`glob-to-regexp`模块来帮助我们处理用户的输入。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: In an empty directory, start a new application using `npm` `init` and add an
    `index.js` file, which will be our entry point.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个空目录中，使用`npm` `init`开始一个新的应用程序，并添加一个`index.js`文件，这将是我们的入口点。
- en: 'Install the two external modules that we will be using: `commander` and `glob-to-regexp`.
    For that, execute the `npm install` command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们将使用的两个外部模块：`commander`和`glob-to-regexp`。为此，执行`npm install`命令：
- en: '[PRE75]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Inside the `index.js` file, using your favorite editor, import all the necessary
    modules for this project at the beginning of the file:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，使用你喜欢的编辑器，在文件开头导入所有这个项目所需的模块：
- en: '[PRE76]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We are already aware of the `fs` and commander modules. The `globToRegExp` module
    and `join` function will be explained in the upcoming steps.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了`fs`和commander模块。`globToRegExp`模块和`join`函数将在接下来的步骤中进行解释。
- en: 'Initialize the `counter` and `found` variables. These will be used to show
    some statistics relating to the search being executed:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`counter`和`found`变量。这些将用于显示与正在执行的搜索相关的一些统计信息：
- en: '[PRE77]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Configure the `commander` to receive the glob as the argument and an extra
    option for the user to set the initial directory to start the search from:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`commander`以接收glob作为参数，并为用户设置初始目录开始搜索的额外选项：
- en: '[PRE78]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For this exercise, we will use a recursive function to walk through the directory
    tree. The `walkDirectory` function calls `readdirSync`, with the `withFileTypes`
    flag set to `true`. The `walkDirectory` function receives two arguments: the path
    to start reading from and the callback to be called for each file. When a directory
    is found, it is passed to the `walkDirectory` function so that the recursion continues:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用递归函数来遍历目录树。`walkDirectory`函数调用`readdirSync`，并将`withFileTypes`标志设置为`true`。`walkDirectory`函数接收两个参数：要开始读取的路径和要为每个文件调用的回调函数。当找到一个目录时，它被传递给`walkDirectory`函数，以便递归继续：
- en: '[PRE79]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When a file is found, the path is passed to the callback and the counter is
    incremented. Here, we use the `path.join` function to join the filename to the
    parent path to reconstruct the whole path to the file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到一个文件时，路径被传递给回调函数，并且计数器被递增。在这里，我们使用`path.join`函数将文件名连接到父路径，以重建文件的整个路径。
- en: 'Now that we have the `walkDirectory` tree function, we will validate the arguments
    that have been passed to the application:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`walkDirectory`树函数，我们将验证传递给应用程序的参数：
- en: '[PRE80]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, we use the `globToRegExp` module to transform the glob to a `RegExp`
    that can be used to test files:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`globToRegExp`模块将glob转换为`RegExp`，以便用于测试文件：
- en: '[PRE81]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'With the matcher and the walk directory tree function ready, we can now walk
    the directory tree and test each file we find:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了匹配器和遍历目录树函数，我们现在可以遍历目录树并测试我们找到的每个文件：
- en: '[PRE82]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, since all the code is executing synchronously, after the call to `walkDirectory`
    finishes, all the directories and subdirectories will have been processed. Now,
    we can print the statistics of what we found:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于所有的代码都是同步执行的，在调用`walkDirectory`完成后，所有的目录和子目录都将被处理。现在，我们可以打印出我们找到的统计信息：
- en: '![Figure 3.4: Statistics of the files found'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4：找到的文件的统计信息'
- en: '](Images/C14587_03_04.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_04.jpg)'
- en: 'Figure 3.4: Statistics of the files found'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：找到的文件的统计信息
- en: 'You can execute the search by starting in the parent directory:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在父目录中开始执行搜索：
- en: '![Figure 3.5: Executing the search in the parent directory'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：在父目录中执行搜索'
- en: '](Images/C14587_03_05.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_05.jpg)'
- en: 'Figure 3.5: Executing the search in the parent directory'
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：在父目录中执行搜索
- en: In this exercise, you learned how to use the FileSystem APIs to traverse a directory
    tree. You also used regular expressions to filter files by name.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学会了如何使用文件系统API来遍历目录树。你还使用了正则表达式来按名称过滤文件。
- en: The FileSystem APIs provide the foundation for almost every application. Learning
    how to use them synchronously and asynchronously is fundamental for anything you
    will be doing in the backend world. In the next section, we will use these APIs
    to build a basic web server to serve files to the browser.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统API为几乎每个应用程序提供了基础。学习如何同步和异步地使用它们对于后端世界中的任何事情都是至关重要的。在下一节中，我们将使用这些API来构建一个基本的Web服务器，以便向浏览器提供文件。
- en: HTTP APIs
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP API
- en: 'In the beginning, Node.js was created with the objective of replacing old web
    servers that used the traditional model of one thread per connection. In the thread-per-request
    model, the server keeps a port open, and when a new connection comes in, it uses
    a thread from the pool or creates a new one to execute the work the user asked
    for. All of the operations on the server side happen synchronously, which means
    that while a file is being read from disk or a record from the database, the thread
    sleeps. The following illustration depicts this model:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，Node.js的目标是取代使用传统的每个连接一个线程模型的旧Web服务器。在线程每请求模型中，服务器保持一个端口开放，当新连接进来时，它使用线程池中的一个线程或创建一个新线程来执行用户请求的工作。服务器端的所有操作都是同步进行的，这意味着当从磁盘读取文件或从数据库中读取记录时，线程会休眠。以下插图描述了这个模型：
- en: '![Figure 3.6: On the thread-per-request model, threads sleep while the I/O
    and other blocking operations happen'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6：在线程每请求模型中，线程在I/O和其他阻塞操作发生时处于休眠状态'
- en: '](Images/C14587_03_06.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_06.jpg)'
- en: 'Figure 3.6: On the thread-per-request model, threads sleep while the I/O and
    other blocking operations happen'
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：在线程每请求模型中，线程在I/O和其他阻塞操作发生时处于休眠状态
- en: 'The problem with the thread-per-request model is that threads are expensive
    to create, and having them sleep while there''s more work to do means a waste
    of resources. Another issue is that when the number of threads is higher than
    the number of CPUs, they start losing their most precious value: concurrency.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 线程每请求模型的问题在于创建线程的成本很高，而当它们在有更多工作要做时处于休眠状态，这意味着资源的浪费。另一个问题是，当线程的数量高于CPU的数量时，它们开始失去并发的最宝贵的价值。
- en: 'Because of these issues, web servers that used the thread-per-request model
    would have a thread pool that''s not big enough so that the server can still respond
    to many requests in parallel. And because the number of threads is limited when
    the number of concurrent users making requests grows too much, the server runs
    out of threads and the users now have to wait:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，使用线程每请求模型的Web服务器将拥有一个不够大的线程池，以便服务器仍然可以并行响应许多请求。并且因为线程数量是有限的，当并发用户发出请求的数量增加时，服务器会耗尽线程，用户现在必须等待：
- en: '![](Images/C14587_03_07.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_03_07.jpg)'
- en: 'Figure 3.7: Users have to wait for threads to become available when the number
    of concurrent requests grows'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：当并发请求数量增加时，用户必须等待线程可用
- en: 'Node.js, with its asynchronous model and the event loop, brought the idea that
    you can be more efficient if you have only one thread to execute work and move
    the blocking and I/O operations to the background, only coming back to it when
    data is available to be processed. When you have data-intensive work to be done,
    such as with web servers, which mostly read and write from files, disks, and records
    from databases, the asynchronous model becomes much more efficient. The following
    illustration depicts this model:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js以其异步模型和事件循环，提出了这样一个观念：如果只有一个线程来执行工作并将阻塞和I/O操作移到后台，只有在数据可用于处理时才返回到它，那么您可以更加高效。当您需要进行数据密集型工作时，比如Web服务器，它主要从文件、磁盘和数据库中读取和写入记录时，异步模型变得更加高效。以下插图描述了这个模型：
- en: '![Figure 3.8: Asynchronous model with an event loop'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8：带有事件循环的异步模型'
- en: '](Images/C14587_03_08.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_08.jpg)'
- en: 'Figure 3.8: Asynchronous model with an event loop'
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.8：带有事件循环的异步模型
- en: Of course, this model is no silver bullet and, under heavy load and a high number
    of concurrent users, the amount of work on the queue will become so high that
    users will eventually start blocking each other.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个模型并不是万能的，在高负载和大量并发用户的情况下，队列中的工作量会变得如此之大，以至于用户最终会开始相互阻塞。
- en: Now that you know the history of the asynchronous model and why Node.js implemented
    it, let's build a simple hello world web server. In the upcoming chapters, you
    will learn more about REST APIs and how to use some libraries to help you do some
    more advanced things. For now, we will use the http module to build a server that
    returns a "hello world" string.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了异步模型的历史以及Node.js为什么实现它，让我们来构建一个简单的hello world Web服务器。在接下来的章节中，您将学习更多关于REST
    API以及如何使用一些库来帮助您做一些更高级的事情。现在，我们将使用http模块来构建一个返回"hello world"字符串的服务器。
- en: 'To create an HTTP server, you can use the `createServer` function from the
    http module. It''s as simple as doing the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个HTTP服务器，您可以使用http模块中的`createServer`函数。只需按照以下步骤即可：
- en: '[PRE83]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The server is driven by events, and the event that we''re most interested in
    is the request. This event is triggered when an HTTP client connects to the server
    and initiates a request. We can listen to this event with a callback that receives
    two parameters:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器由事件驱动，我们最感兴趣的事件是请求。当HTTP客户端连接到服务器并发起请求时，将触发此事件。我们可以使用一个接收两个参数的回调来监听此事件：
- en: 'request: The request the client is sending to the server.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求：客户端发送给服务器的请求。
- en: 'response: The response object used to communicate with the client.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：用于与客户端通信的响应对象。
- en: 'The response is a writable stream, which means we already know how to send
    data to it: by calling the `write` method. But it also contains a special method
    called `writeHead`, which will send back the HTTP status code and any additional
    headers. The following is an example of how to send the hello world string back
    to the client:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是一个可写流，这意味着我们已经知道如何向其发送数据：通过调用`write`方法。但它还包含一个特殊的方法叫做`writeHead`，它将返回HTTP状态码和任何额外的标头。以下是将hello
    world字符串发送回客户端的示例：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We have the server and the request handler. Now, we can start listening for
    requests on a specific port. To do that, we call the `listen` method on the server
    instance:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了服务器和请求处理程序。现在，我们可以开始在特定端口上监听请求。为此，我们在服务器实例上调用`listen`方法：
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The code for this sample is available in GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可在GitHub上找到：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js)。
- en: 'If you start the hello world server by running this application, you will see
    something like this in your console:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过运行此应用程序启动hello world服务器，您将在控制台中看到类似以下内容：
- en: '[PRE86]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And if you open your browser and go to the specified path, you will see the
    following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开浏览器并转到指定路径，您将看到以下内容：
- en: '![Figure 3.9: Hello world web server example response'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：Hello world web服务器示例响应'
- en: '](Images/C14587_03_09.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_09.jpg)'
- en: 'Figure 3.9: Hello world web server example response'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.9：Hello world web服务器示例响应
- en: 'You can try reaching other paths such as `http://localhost:3000/index.html`,
    for example. The result will be the same:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试访问其他路径，例如`http://localhost:3000/index.html`。结果将是相同的：
- en: '![Figure 3.10: Hello world server always responds with Hello world'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10：Hello world服务器始终以Hello world响应'
- en: '](Images/C14587_03_10.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_10.jpg)'
- en: 'Figure 3.10: Hello world server always responds with Hello world'
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.10：Hello world服务器始终以Hello world响应
- en: 'If you go back to the console where you''re running your server from, you will
    see something like the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您返回到运行服务器的控制台，您将看到类似以下内容：
- en: '[PRE87]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can see that the server is receiving the path correctly from the browser.
    However, because the code doesn't handle any special case, it just returns Hello
    world. Clients always get the same result, no matter what path they request.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到服务器正确地从浏览器接收到路径。但是，由于代码没有处理任何特殊情况，它只是返回Hello world。客户端无论请求什么路径，始终会得到相同的结果。
- en: 'Exercise 13: Serving Static Files'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习13：提供静态文件
- en: We have learned how to build a hello world web server that always responds with
    the same string, no matter what the client asks for. In this exercise, we're going
    to create an HTTP server that serves files from a directory. This type of server
    is called a static HTTP server since it only finds files in a directory and returns
    them to the client without any modification.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何构建一个始终以相同字符串响应的hello world web服务器，无论客户端请求什么。在这个练习中，我们将创建一个HTTP服务器，从目录中提供文件。这种类型的服务器称为静态HTTP服务器，因为它只在目录中查找文件并将它们无修改地返回给客户端。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'In an empty directory, initialize a new npm application using the `init` command
    and add an `index.js` file to it. Also, install the `mime` package using `npm
    install`. We will use this package to determine what the content type is for the
    files we will be serving:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空目录中，使用`init`命令初始化一个新的npm应用程序，并向其添加一个`index.js`文件。还要使用`npm install`安装`mime`包。我们将使用此包确定我们将提供的文件的内容类型是什么：
- en: '[PRE88]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let''s start by importing all the modules we will need for this project:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先导入我们在这个项目中需要的所有模块：
- en: '[PRE89]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We will use the `fs` module to load files from disk. The http module will be
    used to create the HTTP server and handle the HTTP requests. The `mime` module
    is the one we installed in the previous step and will be used to determine the
    content type for each file. The path module is used to handle paths in a platform-independent
    way. Finally, the `url` module is used to parse URLs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fs`模块从磁盘加载文件。http模块将用于创建HTTP服务器和处理HTTP请求。`mime`模块是我们在上一步中安装的，将用于确定每个文件的内容类型。path模块用于以平台无关的方式处理路径。最后，`url`模块用于解析URL。
- en: 'To know which files we will have to serve, we will scan the directory using
    the `walkDirectory` function from the previous exercise:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了知道我们将要提供哪些文件，我们将使用上一个练习中的`walkDirectory`函数扫描目录：
- en: '[PRE90]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, we will pick the root directory, which can be passed as an argument.
    Otherwise, we will just assume it is the directory from where we''re running the
    script:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将选择根目录，可以将其作为参数传递。否则，我们将假定它是我们运行脚本的目录：
- en: '[PRE91]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we can scan the directory tree and store the path to all files in a `Set`,
    which will make the process of checking the availability of the file quicker:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以扫描目录树并将所有文件的路径存储在`Set`中，这将使文件可用性检查的过程更快：
- en: '[PRE92]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'With the list of files ready to serve, we will create the HTTP server instance:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好提供文件列表后，我们将创建HTTP服务器实例：
- en: '[PRE93]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Start the request handler function:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动请求处理程序函数：
- en: '[PRE94]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside the handler function, parse what the user is requesting to a URL. For
    this, we will use the url module and, from the parsed URL, we will fetch the pathname
    that points to the file the client wants:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序函数内部，将用户请求的内容解析为URL。为此，我们将使用url模块，并从解析后的URL中获取指向客户端想要的文件的路径名：
- en: '[PRE95]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With the path to the file, we will check whether the file is in the list we
    collected before and, if not, respond with a 404 (not found) error message, log
    the result of the request, and return it:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了文件路径，我们将检查文件是否在之前收集的列表中，如果不在，则响应404（未找到）错误消息，记录请求的结果并返回它：
- en: '[PRE96]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If the file is in the `Set`, we will use the path module to extract its extension
    and resolve the content type using the `mime` module. Then, we will respond with
    a 200 (ok) error message, create a read stream to the file, and pipe it to the
    response:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件在`Set`中，我们将使用path模块提取其扩展名，并使用`mime`模块解析内容类型。然后，我们将以200（ok）错误消息响应，创建一个读取文件的流，并将其传输到响应中：
- en: '[PRE97]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'That''s all for the handler function. After that, we can start the server by
    picking a port, letting the user know what that is, and calling what to listen
    to the method in the http server:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序函数到此为止。之后，我们可以通过选择一个端口来启动服务器，让用户知道那是什么，并调用http服务器中的监听方法：
- en: '[PRE98]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can start the server by running the following command:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来启动服务器：
- en: '[PRE99]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'From another Terminal window, we can use the command-line HTTP client curl
    to call our server and see the response:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个终端窗口，我们可以使用命令行HTTP客户端curl来调用我们的服务器并查看响应：
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can also do the same from the browser:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从浏览器中进行相同操作：
- en: '![Figure 3.11: Static index.js served from our HTTP server as viewed from the
    browser'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11：从浏览器中查看的静态index.js从我们的HTTP服务器提供的'
- en: '](Images/C14587_03_11.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_11.jpg)'
- en: 'Figure 3.11: Static index.js served from our HTTP server as viewed from the
    browser'
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.11：从浏览器中查看的静态index.js从我们的HTTP服务器提供的
- en: 'You can also try this with a file that doesn''t exist to see the result:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试使用一个不存在的文件来查看结果：
- en: '[PRE101]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'From the browser, the 404 response looks like an error page:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器中，404响应看起来像一个错误页面：
- en: '![Figure 3.12: The server responds with a 404 error when asked for a file that
    doesn''t exist'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12：当请求一个不存在的文件时，服务器会以404错误响应'
- en: '](Images/C14587_03_12.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_12.jpg)'
- en: 'Figure 3.12: The server responds with a 404 error when asked for a file that
    doesn''t exist'
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.12：当请求一个不存在的文件时，服务器会以404错误响应
- en: 'On the Terminal where you''re running the server, you can see that it prints
    information about what''s being served:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行服务器的终端上，您可以看到它打印了有关正在提供的信息：
- en: '[PRE102]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: With just a few lines of code, you were able to build an HTTP server that serves
    static content.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，您就能够构建一个提供静态内容的HTTP服务器。
- en: An HTTP server is one of the fundamental components of the internet. Node.js
    makes it simple to build powerful servers. In this exercise, with just a few lines
    of code, we have built a static HTTP server. In the rest of this section, we will
    learn how to build a dynamic server that can generate HTML using templates and
    data that have passed in the request and also loaded from other data sources,
    such as a JSON file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器是互联网的基本组件之一。Node.js使构建强大的服务器变得简单。在这个练习中，只需几行代码，我们就建立了一个静态HTTP服务器。在本节的其余部分，我们将学习如何构建一个动态服务器，它可以使用模板和从请求中传递的数据生成HTML，并且还可以从其他数据源加载，比如JSON文件。
- en: 'Before we move on to building a dynamic HTTP server, let''s take a look at
    the HTTP client APIs that are available in Node.js. To test the HTTP client APIs,
    we will be using HTTP Bin, a free service that can be used to test HTTP requests.
    You can read more about it here: [https://httpbin.org](https://httpbin.org).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续构建动态HTTP服务器之前，让我们看看Node.js中可用的HTTP客户端API。为了测试HTTP客户端API，我们将使用HTTP Bin，这是一个免费的服务，可以用来测试HTTP请求。您可以在这里阅读更多信息：[https://httpbin.org](https://httpbin.org)。
- en: 'In the upcoming chapters, you will learn about what each HTTP method means,
    but for now, we will just explore two of them: GET and POST. HTTP GET is what
    we have been using until now. It tells the server: "Go get this URL for me." HTTP
    POST means: "Store this content at this URL for me." In the static server we built
    in the previous exercise, it was a real path to a real file on disk. But it can
    be used in whatever way the server sees fit.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将了解每个HTTP方法的含义，但现在，我们将只探索其中的两个：GET和POST。HTTP GET是我们到目前为止一直在使用的。它告诉服务器：“为我获取这个URL。”
    HTTP POST的意思是：“将这个内容存储在这个URL上。”在我们之前构建的静态服务器中，它是磁盘上一个真实文件的真实路径。但它可以以服务器认为合适的任何方式使用。
- en: 'Let''s use Node.js to execute a GET request to the `httpbin` API. The HTTP
    client module lives in the same module as the server since it uses a lot of the
    same constructs. Therefore, we have to require the http module:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Node.js执行对`httpbin` API的GET请求。HTTP客户端模块与服务器位于同一模块中，因为它使用了许多相同的构造。因此，我们必须要求http模块：
- en: '[PRE103]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Since GET is such a widely used HTTP method, the http module has an alias for
    it. We can execute GET by calling the `get` function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GET是一个广泛使用的HTTP方法，http模块为其设置了别名。我们可以通过调用`get`函数来执行GET：
- en: '[PRE104]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `get` function receives the URL and a callback, which will be called and
    passed to the response as soon as the server starts sending it. The response that''s
    passed to the callback is a readable stream that we can get data from by listening
    to the data event:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`函数接收URL和回调函数，一旦服务器开始发送它，回调就会被调用并传递给响应。传递给回调的响应是一个可读流，我们可以通过监听数据事件来从中获取数据：'
- en: '[PRE105]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The data here is the body of the response. If we just print it to the console,
    we will see the response in the Terminal.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的数据是响应的主体。如果我们只是将其打印到控制台，我们将在终端中看到响应。
- en: 'The request instance that''s returned by the `get` method is a writable stream.
    To tell the server that we''re done with the request, we need to call the `end`
    method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法返回的请求实例是一个可写流。要告诉服务器我们已经完成了请求，我们需要调用`end`方法：'
- en: '[PRE106]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The following is some sample output from the preceding code, which can be found
    on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的一些示例输出，可以在GitHub上找到[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js)：
- en: '[PRE107]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You can see that it printed the response body to the Terminal.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它将响应主体打印到终端。
- en: 'Sometimes, you need to send some extra headers or use HTTP basic authentication.
    For that, the `get` method accepts an `options` object, where you can set headers,
    basic authentication, and so on. The following is a sample options object where
    a custom header and basic authentication have been set:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要发送一些额外的标头或使用HTTP基本身份验证。为此，`get`方法接受一个`options`对象，您可以在其中设置标头、基本身份验证等。以下是一个示例选项对象，其中设置了自定义标头和基本身份验证：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Then, you pass the options object before the callback function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在回调函数之前传递选项对象：
- en: '[PRE109]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The following snippet is the output of preceding code, which is also available
    on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是前述代码的输出，也可在GitHub上找到[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js)：
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`httpbin` responds with all the information that we passed in our request.
    You can see that there are two extra headers now, Test and Authorization, with
    the values we specified. The authorization header is base64-encoded, as specified
    in the Basic Authentication spec.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpbin`响应我们在请求中传递的所有信息。您可以看到现在有两个额外的标头，Test和Authorization，其值与我们指定的相同。授权标头是base64编码的，如基本身份验证规范中指定的。'
- en: 'As we mentioned previously, the get method is just an alias. The request method
    is the more flexible version of it and can be used to execute an HTTP POST request.
    Even though it is more flexible, the request method receives the same arguments:
    `url`, `options`, and `callback`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，get方法只是一个别名。request方法是其更灵活的版本，可用于执行HTTP POST请求。尽管它更灵活，但request方法接收相同的参数：`url`、`options`和`callback`。
- en: 'To specify the HTTP method to be executed, we set it in the options object:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定要执行的HTTP方法，我们在选项对象中设置它：
- en: '[PRE111]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, we call the request function, instead of the get function:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用request函数，而不是get函数：
- en: '[PRE112]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If you want to post data to the server, you can use the request object we created.
    Remember that it is a writable stream, so we can write the content directly to
    it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要向服务器发送数据，可以使用我们创建的请求对象。请记住，它是一个可写流，因此我们可以直接将内容写入其中：
- en: '[PRE113]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'After you''re done writing the data to the request, call the `end` method and
    the request is done:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在向请求写入数据后，调用`end`方法，请求就完成了：
- en: '[PRE114]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Some sample code that uses the write and `end` methods we explained previously
    is available on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前解释过的write和`end`方法的一些示例代码可在GitHub上找到[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js)。
- en: 'The following is the output of running the preceding code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行上述代码的输出：
- en: '[PRE115]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can see that the http module automatically sets the Content-Length header,
    based on the amount of data you sent. You can also see that the data attribute
    is set on the response, indicating the data that the server received.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到http模块会根据您发送的数据量自动设置Content-Length标头。您还可以看到响应中设置了数据属性，指示服务器接收到的数据。
- en: 'Exercise 14: Serving Dynamic Content'
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14：提供动态内容
- en: In this exercise, we will be rewriting the storefront from the previous chapter.
    But now, the content will be served dynamically, and the HTML will be generated
    on the server side. For that, we will have an array of products stored in a JSON
    file, which will be loaded and used to generate an HTML file to return to the
    client.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将重写上一章的商店前端。但现在，内容将以动态方式提供，并且HTML将在服务器端生成。为此，我们将有一个存储在JSON文件中的产品数组，该数组将被加载并用于生成要返回给客户端的HTML文件。
- en: 'There are many ways of generating HTML to send to clients: concatenating strings,
    search and replace, template strings, and even a library such as cheerio could
    be used. Templating is, in general, the easiest since you can store the template
    in a separate file that can be written just like a normal HTML file but with some
    placeholders. For this exercise, we will use the handlebars templating library
    to do the hard work.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多生成要发送给客户端的HTML的方法：连接字符串，搜索和替换，模板字符串，甚至可以使用诸如cheerio之类的库。模板化通常是最简单的，因为您可以将模板存储在一个单独的文件中，就像普通的HTML文件一样，但其中有一些占位符。在本练习中，我们将使用handlebars模板库来完成这项艰苦的工作。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Create a new npm package with an `index.js` file in it. Install the two external
    packages that we will use in this exercise:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的npm包，其中包含一个`index.js`文件。安装我们在本练习中将使用的两个外部包：
- en: '[PRE116]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The handlebars package is a template engine. It can be used to render template
    text with placeholders and some basic logic, such as for loops and if/else statements.
    We will also be using the `mime` package we used previously to determine the content
    type of files that are going to be served statically.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: handlebars包是一个模板引擎。它可用于渲染带有占位符和一些基本逻辑（如for循环和if/else语句）的模板文本。我们还将使用之前使用过的`mime`包来确定静态提供的文件的内容类型。
- en: 'Require all the modules that will be used in the application:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中需要所有将使用的模块：
- en: '[PRE117]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Check the path for static files using a base directory. That directory will
    be the static directory where the script is loaded from. We store that path in
    a variable so that we can use it later:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基本目录检查静态文件的路径。该目录将是脚本加载的静态目录。我们将该路径存储在变量中，以便以后使用：
- en: '[PRE118]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, we load the product array from the JSON file using `readFileSync`. We
    parse the JSON using the built-in `JSON.parse` function and then print the number
    of products found to the console:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`readFileSync`从JSON文件中加载产品数组。我们使用内置的`JSON.parse`函数解析JSON，然后将找到的产品数量打印到控制台：
- en: '[PRE119]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Handlebars have a concept of helper functions. These are functions that can
    be registered and used from within your templates. To register a helper function,
    you call the `registerHelp` function, passing the name of your helper as the first
    argument and the handler function as the second.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars有一个辅助函数的概念。这些是可以在模板内注册和使用的函数。要注册一个辅助函数，您调用`registerHelp`函数，将您的辅助函数的名称作为第一个参数传递，并将处理程序函数作为第二个参数传递。
- en: 'Let''s add a helper function that can be used to format currency:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个辅助函数，用于格式化货币：
- en: '[PRE120]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To initialize the HTTP handler and start listening to connections, we will
    use the following function:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了初始化HTTP处理程序并开始监听连接，我们将使用以下函数：
- en: '[PRE121]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We registered a function called `handleRequest` with our HTTP server. This
    is the root handler, and all requests will go through it. For this application,
    we''re expecting two types of requests: the first is static requests that will
    point to css, images, and other static files, while the second is a request to
    get the storefront HTML. This means that our root handler will only care about
    these two.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在HTTP服务器中注册了一个名为`handleRequest`的函数。这是根处理程序，所有请求都将通过它。对于这个应用程序，我们期望有两种类型的请求：第一种是指向css、图像和其他静态文件的静态请求，而第二种是获取商店HTML的请求。这意味着我们的根处理程序只关心这两种情况。
- en: 'To request the storefront, we will assume that when the user requests `/` or
    `/index.html` (`http://localhost:3000/` or `http://localhost:3000/index.html`),
    the user is trying to access the store, also known as the base or root page of
    an application. Everything else will be considered a static resource. To handle
    these requests, we will parse the URL, check the pathname, and use an `if` statement:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要请求商店，我们将假设当用户请求`/`或`/index.html`(`http://localhost:3000/`或`http://localhost:3000/index.html`)时，用户正在尝试访问商店，也就是应用程序的基本页面或根页面。其他一切都将被视为静态资源。为了处理这些请求，我们将解析URL，检查路径名，并使用`if`语句：
- en: '[PRE122]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'To handle static files, we will prepend the path to the directory where the
    static files should come from and use that as the full path. Then, we will check
    whether the file exists and is readable using the `access` function from the filesystem
    API. If there''s an error, then return a `404` error; otherwise, just create a
    readable stream and pipe the content of the file to the response. We also want
    to use the mime library to check the content type for each file and add a header
    to the response:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理静态文件，我们将在静态文件应该来自的目录前面添加路径，并将其用作完整路径。然后，我们将使用文件系统API中的`access`函数来检查文件是否存在并且可读。如果有错误，那么返回`404`错误；否则，只需创建一个可读流并将文件的内容传输到响应。我们还希望使用mime库来检查每个文件的内容类型，并向响应添加一个头部：
- en: '[PRE123]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Now that we have the function to serve static files, let's use handlebars to
    serve the dynamic content. For that, we need to load the HTML template using `readFileSync`
    and then compile it. The compiled script is transformed into a function that,
    when called, returns a string of the processed template.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了用于提供静态文件的函数，让我们使用handlebars来提供动态内容。为此，我们需要使用`readFileSync`加载HTML模板，然后编译它。编译后的脚本被转换为一个函数，当调用时返回处理过的模板的字符串。
- en: 'The template function receives the context that will be used to render the
    template. The context can be accessed in the template, which will be demonstrated
    in the next step. For this application, the context will be an object with one
    attribute called `products`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数接收将用于呈现模板的上下文。上下文可以在模板中访问，这将在下一步中演示。对于这个应用程序，上下文将是一个带有一个名为`products`的属性的对象：
- en: '[PRE124]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'With the template handling in place, we need a template. Handlebars uses double
    curly braces as placeholders (for example, `{{variable}}`), and you can execute
    a for loop using the double curly braces with a hash: `{{#arrayVariable}}`. In
    a separate `html/index.html` file, relative to the `index.js` file, add the following
    HTML template:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板处理就位后，我们需要一个模板。Handlebars使用双花括号作为占位符（例如，`{{variable}}`），你可以使用双花括号和井号来执行for循环：`{{#arrayVariable}}`。在一个相对于`index.js`文件的`html/index.html`文件中，添加以下HTML模板：
- en: '[PRE125]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Notice the helper function, currency, which is called to render the price:
    `{{currency price}}.`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意辅助函数`currency`，它被调用来呈现价格：`{{currency price}}.`
- en: 'Don''t forget to call the `initialize` function at the end to start listening
    for HTTP connections:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在最后调用`initialize`函数以开始监听HTTP连接：
- en: '[PRE126]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: To make the storefront load and render correctly, you will also need the css
    files and images. Just put them all in a folder called **static**. You can find
    the files on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使商店正确加载和呈现，你还需要css文件和图像。只需将它们放在一个名为**static**的文件夹中。你可以在GitHub上找到这些文件：[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14)。
- en: 'With all the files in place, run the server:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有文件就位后，运行服务器：
- en: '[PRE127]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Open a browser window and go to `http://localhost:3000`. You should see the
    storefront:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器窗口，转到`http://localhost:3000`。你应该看到商店：
- en: '![Figure 3.13: Storefront served from the dynamic web server'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：从动态网络服务器提供的商店'
- en: '](Images/C14587_03_13.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_13.jpg)'
- en: 'Figure 3.13: Storefront served from the dynamic web server'
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.13：从动态网络服务器提供的商店
- en: In this exercise, we transformed the storefront application into a dynamic web
    application that reads data from a JSON file and renders an HTML request when
    the user requests it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将商店应用程序转换为一个动态的网络应用程序，它从一个JSON文件中读取数据，并在用户请求时呈现一个HTML请求。
- en: Dynamic web servers are the basis of all online applications, from Uber to Facebook.
    You can summarize the work as loading data/processing data to generate HTML. In
    *Chapter 2, Node.js and npm*, we used some simple HTML and did the processing
    in the frontend. In this exercise, you learned how to do the same work on the
    backend using a template engine. Each methodology has its pros and cons and most
    applications end up with a combination of both.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 动态网络服务器是所有在线应用程序的基础，从Uber到Facebook。你可以总结这项工作为加载数据/处理数据以生成HTML。在*第2章，Node.js和npm*中，我们在前端使用了一些简单的HTML并进行了处理。在这个练习中，你学会了如何在后端使用模板引擎来完成相同的工作。每种方法都有其优缺点，大多数应用程序最终会结合两者。
- en: You can add filtering options to the storefront web page as an improvement.
    Let's say the users want to filter the products by tag or a combination of them.
    In your `handleProductsPage` function, you could use query parameters to filter
    the list of products you're passing to the template for rendering. See if you
    can make this improvement yourself.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将过滤选项添加到商店前端网页作为改进。比如说用户想要按标签或它们的组合来筛选产品。在你的`handleProductsPage`函数中，你可以使用查询参数来过滤你传递给模板渲染的产品列表。看看你是否可以自己做出这个改进。
- en: What is Scraping?
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是爬取？
- en: For the remainder of this chapter, we will be talking about web **scraping**.
    But what exactly is web scraping? It's the process of downloading a page and processing
    its content to execute some repetitive automated tasks that would otherwise take
    too long to do manually.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将讨论网络**爬取**。但网络爬取到底是什么？这是下载页面并处理其内容以执行一些重复的自动化任务的过程，否则这些任务将需要手动执行太长时间。
- en: 'For example, if you want to get car insurance, you need to go to each insurance
    company website and get a quote. That process normally takes hours since you have
    to fill in a form, submit it, wait for them to send you an email on each website,
    compare prices, and pick the one you want:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要购买汽车保险，你需要去每家保险公司的网站获取报价。这个过程通常需要几个小时，因为你需要填写表单，提交表单，等待他们在每个网站给你发送电子邮件，比较价格，然后选择你想要的：
- en: '![Figure 3.14: The user downloads content, types data in, submits it, and then
    wait for the results'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14：用户下载内容，输入数据，提交数据，然后等待结果'
- en: '](Images/C14587_03_14.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_14.jpg)'
- en: 'Figure 3.14: The user downloads content, types data in, submits it, and then
    wait for the results'
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.14：用户下载内容，输入数据，提交数据，然后等待结果
- en: So why not make a program that can do that for you? That's what web scraping
    is all about. A program downloads a page as if it were a human, scrapes information
    from it, and makes decisions based on some algorithm, and submits the necessary
    data back to the website.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么不制作一个可以为你做到这一点的程序呢？这就是网络爬取的全部内容。一个程序像人一样下载页面，从中提取信息，并根据某种算法做出决策，然后将必要的数据提交回网站。
- en: When you're getting insurance for your car, it doesn't seem like automating
    would bring much value. Writing an application that does that correctly for different
    websites would take many hours – more than doing it yourself manually. But what
    if you were an insurance broker? Then you would have to do this hundreds of times
    a day, maybe more.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为你的汽车购买保险时，似乎自动化不会带来太多价值。为不同的网站编写正确执行此操作的应用程序将花费很多时间——比手动操作自己做要多得多。但如果你是一家保险经纪公司呢？那么你每天可能要做这个动作数百次，甚至更多。
- en: 'If you are an insurance broker company, and if you spend your time building
    one robot (that''s what these applications are called), you will start to become
    more efficient. That''s because, for that one website, you won''t be spending
    time filling out the forms. With the efficiency that you got from building your
    first robot, you can save time and be able to build a second one, then a third
    one, and so forth:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个保险经纪公司，如果你花时间建立一个机器人（这些应用程序就是这样称呼的），你将开始变得更加高效。这是因为对于那个网站，你不需要花时间填写表单。通过建立第一个机器人获得的效率，你可以节省时间并能够建立第二个，然后是第三个，依此类推：
- en: '![Figure 3.15: Robot executing the task automatically by downloading content
    and making decisions based on an algorithm'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15：机器人通过下载内容并根据算法做出决策自动执行任务'
- en: '](Images/C14587_03_15.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_15.jpg)'
- en: 'Figure 3.15: Robot executing the task automatically by downloading content
    and making decisions based on an algorithm'
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：机器人通过下载内容并根据算法做出决策自动执行任务
- en: Web scraping started in the early days of the internet when Yahoo! was trying
    to manually index all the websites that existed. Then, a start-up, out of two
    college students' garages, started using robots to pull the data and index everything.
    In a very short amount of time, Google became the number one search website, a
    position that only gets harder and harder for competitors to challenge.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫始于互联网早期，当时雅虎！试图手动索引所有存在的网站。然后，一家初创公司，由两名大学生在车库里开始使用机器人来提取数据并索引一切。在很短的时间内，谷歌成为了第一大搜索网站，这个位置对竞争对手来说越来越难以挑战。
- en: Web scraping is a widely used technique to extract data from websites that do
    not provide APIs, such as most insurance companies and banks. Search and indexing
    is also another very common case. Some companies use scraping to analyze a website's
    performance and grade them, such as HubSpot ([https://website.grader.com](https://website.grader.com)).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬取是一种广泛使用的技术，用于从不提供API的网站提取数据，比如大多数保险公司和银行。搜索和索引也是另一个非常常见的情况。一些公司使用爬取来分析网站的性能并对其进行评分，比如HubSpot（[https://website.grader.com](https://website.grader.com)）。
- en: 'There are many techniques for web scraping, depending on what goal you''re
    trying to achieve. The most basic one is to download the base HTML from a website
    and read the content from there. If you only need to download data or fill in
    a form, this might be more than enough:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫有许多技术，取决于你想要实现的目标。最基本的技术是从网站下载基本的HTML并从中读取内容。如果你只需要下载数据或填写表单，这可能已经足够了：
- en: '![Figure 3.16: The basic scraping technique involves downloading and processing
    the base HTML file'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16：基本的爬取技术涉及下载和处理基本的HTML文件'
- en: '](Images/C14587_03_16.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_16.jpg)'
- en: 'Figure 3.16: The basic scraping technique involves downloading and processing
    the base HTML file'
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：基本的爬取技术涉及下载和处理基本的HTML文件
- en: 'But sometimes, websites use Ajax to dynamically load the content after the
    HTML has been rendered. For those cases, just downloading the HTML wouldn''t be
    enough since it would just be an empty template. To solve that, you can use a
    headless browser, which works like a browser, parsing all HTML, downloading and
    parsing the related files (CSS, JavaScript, and so on), rendering everything together,
    and executing the dynamic code. That way, you can wait for the data to be available:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，网站使用Ajax在HTML渲染后动态加载内容。对于这些情况，仅下载HTML是不够的，因为它只是一个空模板。为了解决这个问题，您可以使用一个无头浏览器，它像浏览器一样工作，解析所有HTML，下载和解析相关文件（CSS、JavaScript等），将所有内容一起渲染，并执行动态代码。这样，您就可以等待数据可用：
- en: '![Figure 3.17: Depending on the use case, scraping requires a simulated or
    a fully headless browser to download and render the page more accurately'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17：根据用例，抓取需要一个模拟或完全无头浏览器来更准确地下载和渲染页面'
- en: '](Images/C14587_03_17.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_17.jpg)'
- en: 'Figure 3.17: Depending on the use case, scraping requires a simulated or a
    fully headless browser to download and render the page more accurately'
  id: totrans-426
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：根据用例，抓取需要一个模拟或完全无头浏览器来更准确地下载和渲染页面
- en: The second technique is much slower since it requires the whole page to download,
    parse, and render. It is also much more brittle since executing the extra calls
    can fail, and waiting for JavaScript to finish processing the data can be hard
    to predict.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术要慢得多，因为它需要下载、解析和渲染整个页面。它也更加脆弱，因为执行额外的调用可能会失败，等待JavaScript完成处理数据可能很难预测。
- en: Downloading and Parsing Web Pages
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载和解析网页
- en: Let's examine the simpler approach to web scraping. Suppose we wanted to follow
    the latest posts about JavaScript in Medium. We could write an application to
    download the JavaScript topic page, then search for anchors (links), and use that
    to navigate around.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看更简单的网页抓取方法。假设我们想要关注Medium上关于JavaScript的最新帖子。我们可以编写一个应用程序来下载JavaScript主题页面，然后搜索锚点（链接），并使用它来导航。
- en: To start, having a generic download function that will do some basic wrapping
    on the HTTP client is a good idea. We could use an external library, such as request,
    but let's see how we would go about wrapping that kind of logic.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，拥有一个通用的下载函数，它将对HTTP客户端进行一些基本的封装，是一个好主意。我们可以使用外部库，比如request，但让我们看看如何封装这种逻辑。
- en: 'We will need the http module, but in this case, we will use the https version
    of it, since most websites these days will redirect you to their secure version
    if you try to reach the plain HTTP version. The https module provides the same
    APIs except it understands HTTPS protocol, which is the secure version of HTTP:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要http模块，但在这种情况下，我们将使用它的https版本，因为大多数网站这些天会在你尝试访问普通HTTP版本时将你重定向到它们的安全版本。https模块提供了相同的API，只是它理解HTTPS协议，这是HTTP的安全版本。
- en: '[PRE128]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `downloadPage` function receives a URL to download and a callback function
    that will be called after the content of the page has finished downloading:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`downloadPage`函数接收要下载的URL和在页面内容下载完成后将被调用的回调函数：'
- en: '[PRE129]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Inside that function, we will start by making a request and ensuring that we
    are calling the end function to complete the request:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数内部，我们将首先发出一个请求，并确保我们调用end函数来完成请求：
- en: '[PRE130]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In the callback we pass to the get function, the first thing we will do is
    check for the response status and print an error message if it doesn''t match
    200, which is the HTTP code that means we have a successful request. We also stop
    everything by returning from the callback since the body will probably not be
    what we''re expecting if this happens:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们传递给get函数的回调中，我们首先要做的是检查响应状态，并在它不匹配200时打印错误消息，这是表示我们有一个成功请求的HTTP代码。如果发生这种情况，我们还会通过从回调中返回来停止一切，因为如果发生这种情况，body可能不是我们所期望的。
- en: '[PRE131]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'After that `if` statement, we can accumulate the content of the page in a variable
    using the data event. When the connection is closed, in the `close` event, we
    call the callback function with the full content that was accumulated in the content
    variable:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`if`语句之后，我们可以使用数据事件在一个变量中累积页面的内容。当连接关闭时，在`close`事件中，我们调用回调函数，并将累积在content变量中的全部内容传递给它。
- en: '[PRE132]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The full code for this sample is available on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在GitHub上找到：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js)。
- en: 'A simple usage of this function would be as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的一个简单用法如下：
- en: '[PRE133]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This would download the page and print it to the console. But we want to do
    more, so we will use the `jsdom` library to parse the HTML and fetch some information
    from it. `jsdom` is a library that parses HTML and generates a DOM representation
    of it that can be queried and manipulated, just like the DOM in a browser.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载页面并将其打印到控制台。但我们想做更多的事情，所以我们将使用`jsdom`库来解析HTML并从中获取一些信息。`jsdom`是一个解析HTML并生成DOM表示的库，可以像浏览器中的DOM一样进行查询和操作。
- en: 'After installing it using the `npm install` command, you can require it in
    your code. The module exposes a constructor that receives a string. After being
    instantiated, the `JSDOM` instance contains a window object that works exactly
    like the window object in the browser. The following is an example of using it
    to fetch all the anchors, filter out the ones that are empty, and print their
    texts:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm install`命令安装后，您可以在代码中引用它。该模块公开了一个接收字符串的构造函数。在被实例化后，`JSDOM`实例包含一个窗口对象，其工作方式与浏览器中的窗口对象完全相同。以下是使用它来获取所有锚点、过滤掉空的锚点并打印它们的文本的示例：
- en: '[PRE134]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The following is the sample output of the preceding code:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的示例输出：
- en: '[PRE135]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Exercise 15: Scraping Medium Articles'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习15：抓取Medium文章
- en: In this exercise, we will use scraping to print articles in the console. Let's
    use this knowledge to build an application that will download topic pages from
    Medium, parse the information, and print it in a consumable way. The application
    will have a hardcoded list of topics and will download the HTML for each of the
    pages. Then, it will use `jsdom` to parse the downloaded content, fetch information
    about each article, and print that in a pretty format in the console to make each
    article just a click away.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用爬虫在控制台上打印文章。让我们利用这些知识构建一个应用程序，该应用程序将从Medium下载主题页面，解析信息，并以可消化的方式打印出来。该应用程序将有一个硬编码的主题列表，并将下载每个页面的HTML。然后，它将使用`jsdom`解析已下载的内容，获取有关每篇文章的信息，并以漂亮的格式在控制台上打印出来，使每篇文章都只是一个点击之遥。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Create a new folder, with an `index.js` file in it. Then, run `npm init` and
    `install jsdom` using `npm install`:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹，其中包含一个`index.js`文件。然后，运行`npm init`并使用`npm install`安装`jsdom`：
- en: '[PRE136]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'In the `index.js` file, use the require function for all the modules we will
    be using:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，使用require函数引入我们将使用的所有模块：
- en: '[PRE137]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Create a constant array that will contain all the topics we will be downloading
    pages for:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们将下载页面的所有主题的常量数组：
- en: '[PRE138]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Copy the `downloadPage` function we created in the previous section:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制我们在上一节中创建的`downloadPage`函数：
- en: '[PRE139]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Iterate over each topic calling the `downloadPage` function for each topic:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代每个主题，为每个主题调用`downloadPage`函数：
- en: '[PRE140]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In the preceding code, we call two functions: `findArticles` and `printArticle`.
    The first will go through the DOM parsed from the page and return an object, of
    which the keys are the article titles and the values are objects containing information
    about each article.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们调用了两个函数：`findArticles`和`printArticle`。第一个函数将遍历从页面解析的DOM，并返回一个对象，其中键是文章标题，值是包含每篇文章信息的对象。
- en: 'Next, we write the `findArticles` function. We start by initializing the object,
    which will be the result of the function, and then querying the document that
    was passed in for all the anchor elements inside the H1 and H3 elements, which
    represent the title of the articles:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写`findArticles`函数。我们首先初始化对象，该对象将是函数的结果，然后查询传递的文档中所有H1和H3元素内的所有锚点元素，这些元素代表文章的标题：
- en: '[PRE141]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Filter the anchors based on the fact that Medium article paths have two parts:
    `/author/articleId`. This means we can parse the `href` of the anchor as a URL,
    get the pathname, split using "/" as a separator, and ignore anyone that doesn''t
    have exactly two parts:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Medium文章路径有两部分：`/author/articleId`，过滤锚点。这意味着我们可以将锚点的`href`解析为URL，获取路径名，使用“/”作为分隔符拆分，并忽略那些不完全有两部分的锚点：
- en: '[PRE142]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Using the Chrome Developer Tools on the page, you can see that the title of
    the article lives inside a header element whose next sibling is a DIV that contains
    the following short description:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具在页面上，您可以看到文章的标题位于一个标题元素内，其下一个兄弟元素是一个包含以下简短描述的DIV：
- en: '![Figure 3.18: The next sibling of the parent contains a short description
    of the article'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18：父级的下一个兄弟元素包含文章的简短描述'
- en: '](Images/C14587_03_18.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_18.jpg)'
- en: 'Figure 3.18: The next sibling of the parent contains a short description of
    the article'
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.18：父级的下一个兄弟元素包含文章的简短描述
- en: This means that for each anchor element, we can get that DIV, query for an anchor,
    and fetch its text as the description for the article.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于每个锚元素，我们可以获取该DIV，查询一个锚点，并获取其文本作为文章的描述。
- en: 'Set the article information in the result object using the title as the key.
    We use the title of the article as the key because that will automatically deduplicate
    articles from the result:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文章标题作为键，将文章信息设置在结果对象中。我们使用文章的标题作为键，因为这将自动去重结果中的文章：
- en: '[PRE143]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Lastly, from the `findArticles` function, we return the array containing all
    the articles:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`findArticles`函数中返回包含所有文章的数组：
- en: '[PRE144]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The other function we call inside the callback passed to `downloadPage` is `printArticle`.
    It is also the last piece of code to make this application.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在传递给`downloadPage`的回调中调用的另一个函数是`printArticle`。这也是使该应用程序完整的最后一部分代码。
- en: 'Let''s write the `printArticle` function, which receives an article object
    and prints it to the console in a pretty way:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`printArticle`函数，它接收一个文章对象，并以漂亮的方式将其打印到控制台上：
- en: '[PRE145]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Run the application to print the articles to the console with the extra information
    in a nice format:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，以漂亮的格式将文章打印到控制台上，附加额外信息：
- en: '![Figure 3.19: Article printed to the console after running the application'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19：运行应用程序后在控制台上打印的文章'
- en: '](Images/C14587_03_19.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_03_19.jpg)'
- en: 'Figure 3.19: Article printed to the console after running the application'
  id: totrans-482
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.19：运行应用程序后在控制台上打印的文章
- en: In this exercise, we wrote an application that pulls data from Medium and prints
    a summary of the articles found to the console.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们编写了一个从Medium获取数据并将找到的文章摘要打印到控制台的应用程序。
- en: Web scraping is a powerful way of fetching data when no API is available. Many
    companies use scraping to sync data between systems, to analyze the performance
    of websites, and to optimize processes that otherwise would not scale, thus blocking
    some important business needs. Understanding the concepts behind scraping allows
    you to build systems that would otherwise be impossible to build.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫是在没有API可用时获取数据的强大方式。许多公司使用爬虫在系统之间同步数据，分析网站的性能，并优化否则无法扩展的流程，从而阻碍了一些重要的业务需求。了解爬虫背后的概念使您能够构建否则不可能构建的系统。
- en: 'Activity 4: Scraping Products and Prices from Storefront'
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：从商店前端爬取产品和价格
- en: In *Chapter 2, Node.js and npm*, we wrote some code that would fetch information
    about the products in the storefront example page. At the time, we said that the
    site wasn't going to be updated that frequently, so manually doing it from the
    Chrome Developer Console was fine. For some scenarios, this is fine, but when
    the content is dynamically generated, like in the newer version of the storefront
    that we wrote in this chapter, we might need to eliminate all manual intervention.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章，Node.js和npm*中，我们编写了一些代码，用于获取商店示例页面中产品的信息。当时，我们说网站不会经常更新，因此可以从Chrome开发者控制台手动执行。对于某些情况，这是可以接受的，但是当内容是动态生成的，就像我们在本章中编写的商店的新版本一样，我们可能需要消除所有手动干预。
- en: In this activity, you will write an application that will scrape the storefront
    web page by downloading it using the http module and parsing it using `jsdom`.
    Then, you will extract the data from the DOM and generate a `CSV` file with the
    data.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您将编写一个应用程序，通过使用http模块下载商店网页并使用`jsdom`解析它来抓取商店网页。然后，您将从DOM中提取数据并生成一个带有数据的`CSV`文件。
- en: 'You will need to perform the following steps to complete this activity:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤才能完成此活动：
- en: Use the previous code you built or use a copy of it to serve the storefront
    website in `localhost:3000`. The code can be found on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04).
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您之前构建的代码或其副本来为`localhost:3000`提供商店前端网站。 代码可以在GitHub上找到[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04)。
- en: Create a new `npm` package, install the `jsdom` library, and create an entry
    file called `index.js`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`npm`包，安装`jsdom`库，并创建一个名为`index.js`的入口文件。
- en: In the entry file, call the `require()` method to load all the modules that
    are needed in the project.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在入口文件中，调用`require()`方法加载项目中所需的所有模块。
- en: Make an HTTP request to `localhost:3000`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`localhost:3000`发出HTTP请求。
- en: Ensure a successful response and collect data from the body.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保成功响应并从主体中收集数据。
- en: Parse the HTML using `jsdom`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`jsdom`解析HTML。
- en: Extract the product data from DOM; you will want the name, price, and unit.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从DOM中提取产品数据； 您将需要名称，价格和单位。
- en: Open the `CSV` file where the data will be written to.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CSV`文件，数据将被写入其中。
- en: Write the product data to a `CSV` file, which is one product line.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品数据写入`CSV`文件，这是一个产品行。
- en: Run the application and check the results.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并检查结果。
- en: 'The output should look something like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE146]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 591.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第591页找到。
- en: Summary
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the global variables that are available to
    every Node.js script. We learned how to set timers and read from, and write to,
    the console. After that, we learned about streams and how to use them to read
    and write data from files. We also learned how to use the synchronous filesystem
    APIs. Then, we learned how to use the HTTP module to build web servers and scrape
    content from web pages.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了每个Node.js脚本都可以使用的全局变量。我们学习了如何设置定时器并从控制台读取和写入数据。之后，我们学习了有关流的知识以及如何使用它们从文件中读取和写入数据。我们还学习了如何使用同步文件系统API。然后，我们学习了如何使用HTTP模块构建Web服务器并从Web页面中抓取内容。
- en: Now that you are well acquainted with the web scraping concept, you are ready
    to explore opportunities where you can build your own web applications and build
    automated robots to scrape content from other web applications. A good idea is
    to try and build a simple content management application to serve your blog, where
    you're going to write about all the new things you just learned about.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对Web抓取概念有了很好的了解，可以开始探索机会，构建自己的Web应用程序，并构建自动机器人来从其他Web应用程序中抓取内容。一个好主意是尝试构建一个简单的内容管理应用程序来为您的博客提供服务，您将在其中写有关您刚学到的所有新事物的内容。
- en: In the next chapter, you will learn about REST APIs and use some frameworks
    to help you build them. In further chapters, you will learn about techniques you
    can use to manage asynchronous operations to make your Node.js applications powerful,
    but keep the code easy to write and maintain.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习有关REST API，并使用一些框架来帮助您构建它们。在后续章节中，您将学习有关可以使用的技术，以管理异步操作，使您的Node.js应用程序功能强大，但代码易于编写和维护。
