- en: JUnit 5 Standard Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5标准测试
- en: Talk is cheap. Show me the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 言语是廉价的。给我看代码。
- en: '*- Linus Torvalds*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*- Linus Torvalds*'
- en: 'JUnit 5 provides a brand-new programming model called Jupiter. We can see this
    programming model as an API for software engineers and testers which allow to
    create JUnit 5 tests. These tests are later executed on the JUnit Platform. As
    we will discover, the Jupiter programming model allows to create many different
    types of tests. This chapter tackles the basics of Jupiter. To that aim, this
    chapter is structured as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5提供了一个全新的编程模型，称为Jupiter。我们可以将这个编程模型看作是软件工程师和测试人员的API，允许创建JUnit 5测试。这些测试随后在JUnit平台上执行。正如我们将要发现的那样，Jupiter编程模型允许创建许多不同类型的测试。本章介绍了Jupiter的基础知识。为此，本章结构如下：
- en: '**Test lifecycle**: In this section, we analyze the structure of the Jupiter
    tests, describing the annotations involved in the management of the test life
    cycle in the JUnit 5 programming model. Then, we discover how to skip tests, and
    also how to annotate tests with a custom display name.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试生命周期**：在本节中，我们分析了Jupiter测试的结构，描述了在JUnit 5编程模型中管理测试生命周期的注解。然后，我们了解如何跳过测试，以及如何为测试添加自定义显示名称的注解。'
- en: '**Assertions**: In this section, first we present a brief overview of the verification
    assets, called assertions (also known as predicates). Second, we study how the
    assertions have been implemented in Jupiter. Finally, we present several third-party
    libraries about assertions, providing some examples for Hamcrest.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：在本节中，首先我们简要介绍了称为断言（也称为谓词）的验证资产。其次，我们研究了Jupiter中如何实现这些断言。最后，我们介绍了一些关于断言的第三方库，提供了一些Hamcrest的示例。'
- en: '**Tagging and filtering tests**: In this section, first we will learn how to
    label Jupiter tests, that is, how to create tags in JUnit 5\. Then, we will learn
    how to filter our tests using Maven and Gradle. Finally, we are going to analyze
    how to create meta-annotations using Jupiter.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记和过滤测试**：在本节中，首先我们将学习如何为Jupiter测试创建标签，即如何在JUnit 5中创建标签。然后，我们将学习如何使用Maven和Gradle来过滤我们的测试。最后，我们将分析如何使用Jupiter创建元注解。'
- en: '**Conditional test execution**: In this section, we will learn how to disable
    tests based on a given condition. After that, we make a review of the so-called
    assumptions in Jupiter, which are a mechanism provided out of the box by Jupiter
    to run tests only if certain conditions are as expected.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件测试执行**：在本节中，我们将学习如何根据给定条件禁用测试。之后，我们将回顾Jupiter中所谓的假设，这是Jupiter提供的一个机制，只有在某些条件符合预期时才运行测试。'
- en: '**Nested tests**: This section presents how Jupiter allows to express the relationship
    among a group of tests, called nested tests.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套测试**：本节介绍了Jupiter如何允许表达一组测试之间的关系，称为嵌套测试。'
- en: '**Repeated tests**: This section reviews how Jupiter provides the ability to
    repeat a test a specified number of times.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复测试**：本节回顾了Jupiter如何提供重复执行指定次数的测试的能力。'
- en: '**Migration from JUnit 4 to JUnit 5**: This section provides a set of hints
    about the main differences between JUnit 5 and its immediate antecessor, that
    is, JUnit 4\. Then, this section presents the support for several JUnit 4 rules
    within Jupiter tests.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从JUnit 4迁移到JUnit 5**：本节提供了一组关于JUnit 5和其直接前身JUnit 4之间主要区别的提示。然后，本节介绍了Jupiter测试中对几个JUnit
    4规则的支持。'
- en: Test lifecycle
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试生命周期
- en: 'As we saw in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb), *Retrospective
    on software quality and Java testing*, a unit test case is composed of four stages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)中所看到的，一个单元测试用例由四个阶段组成：
- en: '**Setup** (optional): First, the test initializes the test fixture (before
    the picture of the SUT).'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置**（可选）：首先，测试初始化测试夹具（在SUT的图片之前）。'
- en: '**Exercise**: Second, the test interacts with the SUT, getting some outcome
    from it as a result.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**练习**：其次，测试与SUT进行交互，从中获取一些结果。'
- en: '**Verify**: Third, the outcome from the system under test is compared to the
    expected value using one or several assertions (also known as predicates). As
    a result, a test verdict is created.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证**：第三，将来自被测试系统的结果与预期值进行比较，使用一个或多个断言（也称为谓词）。因此，创建了一个测试判决。'
- en: '**Teardown** (optional): Finally, the test releases the test fixture to put
    the SUT back into the initial state.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拆卸**（可选）：最后，测试释放测试夹具，将SUT恢复到初始状态。'
- en: In JUnit 4, there were different annotations to control these test phases. JUnit
    5 follows the same approach, that is, Java annotations are used to identify different
    methods within Java classes, implementing the test life cycle. In Jupiter, all
    these annotations are contained in the package `org.junit.jupiter.api`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 4中，有不同的注解来控制这些测试阶段。JUnit 5遵循相同的方法，即使用Java注解来标识Java类中的不同方法，实现测试生命周期。在Jupiter中，所有这些注解都包含在`org.junit.jupiter.api`包中。
- en: The most basic JUnit annotation is `@Test`, which identifies the methods that
    have to be executed as tests. Therefore, a Java method annotated with `org.junit.jupiter.api.Test`
    will be treated as a test. The difference of this annotation with respect to JUnit
    4's `@Test` is two folded. On the one hand, the Jupiter `@Test` annotation does
    not declare any attributes. In JUnit 4,  `@Test` can declare the test timeout
    (as long attribute with the timeout in milliseconds), on the other hand, in JUnit
    5, neither test classes nor test methods need to be public (this was a requirement
    in JUnit 4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit的最基本注解是`@Test`，它标识了必须作为测试执行的方法。因此，使用`org.junit.jupiter.api.Test`注解的Java方法将被视为测试。这个注解与JUnit
    4的`@Test`的区别有两个方面。一方面，Jupiter的`@Test`注解不声明任何属性。在JUnit 4中，`@Test`可以声明测试超时（作为长属性，以毫秒为单位的超时时间），另一方面，在JUnit
    5中，测试类和测试方法都不需要是public（这是JUnit 4中的要求）。
- en: Take a look at the following Java class. Possibly, it is the simplest test case
    we can create with Jupiter. It has simply a method with the `@Test` annotation. The
    test logic (that is the exercise and verify stages as described before) would
    be contained inside the method `myTest`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的Java类。可能，这是我们可以用Jupiter创建的最简单的测试用例。它只是一个带有`@Test`注解的方法。测试逻辑（即前面描述的练习和验证阶段）将包含在`myTest`方法中。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Jupiter annotations (also located in the package `org.junit.jupiter.api`)
    aimed to control the setup and tear down stages in JUnit 5 tests are described
    in the following table:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter注解（也位于包`org.junit.jupiter.api`中）旨在控制JUnit 5测试中的设置和拆卸阶段，如下表所述：
- en: '| **JUnit 5 annotation** | **Description** | **JUnit 4''s equivalence** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **JUnit 5注解** | **描述** | **JUnit 4的等效** |'
- en: '| `@BeforeEach` | Method executed before each `@Test` in the current class
    | `@Before` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `@BeforeEach` | 在当前类中的每个`@Test`之前执行的方法 | `@Before` |'
- en: '| `@AfterEach` | Method executed after each `@Test` in the current class |
    `@After` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterEach` | 在当前类中的每个`@Test`之后执行的方法 | `@After` |'
- en: '| `@BeforeAll` | Method executed before all `@Test` in the current class |
    `@BeforeClass` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `@BeforeAll` | 在当前类中的所有`@Test`之前执行的方法 | `@BeforeClass` |'
- en: '| `@AfterAll` | Method executed after all `@Test` in the current class | `@AfterClass`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `@AfterAll` | 在当前类中的所有`@Test`之后执行的方法 | `@AfterClass` |'
- en: Methods annotated with these annotations (`@BeforeEach`, `@AfterEach`, `@AfterAll`,
    and `@BeforeAll`) are always inherited.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注解（`@BeforeEach`，`@AfterEach`，`@AfterAll`和`@BeforeAll`）注解的方法始终会被继承。
- en: 'The following picture depicts the order of execution of these annotations in
    a Java class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了这些注解在Java类中的执行顺序：
- en: '![](img/00035.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: Jupiter annotations to control the test lyfecycle
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 控制测试生命周期的Jupiter注解
- en: Let's go back to the generic structure for tests we saw at the beginning of
    this section. Now, we are able to map the Jupiter annotations to control the test
    lifecycle with the different parts of a test case. As illustrated in the following
    picture, we carry out the setup stage by annotating methods with `@BeforeAll`
    and `@BeforeEach`. Then, we carry out the exercise and verify stages in methods
    annotated with `@Test`. Finally, we carry out the tear down process in the methods
    with `@AfterEach` and `@AfterAll`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本节开头看到的测试的通用结构。现在，我们能够将Jupiter注解映射到测试用例的不同部分，以控制测试生命周期。如下图所示，我们通过使用`@BeforeAll`和`@BeforeEach`注解的方法进行设置阶段。然后，我们在使用`@Test`注解的方法中进行练习和验证阶段。最后，我们在使用`@AfterEach`和`@AfterAll`注解的方法中进行拆卸过程。
- en: '![](img/00036.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: Relationship among the unit test cases stages and the Jupiter annotations
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试阶段与Jupiter注解之间的关系
- en: 'Let''s see a simple example, which uses all these annotations in a single Java
    class. This example defines two tests (that is, two methods annotated with `@Test`),
    and we define additional methods for the rest of the test life cycle with the
    annotations `@BeforeAll`, `@BeforeEach`, `@AfterEach`, and `@AfterAll`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，它在一个单独的Java类中使用了所有这些注解。这个例子定义了两个测试（即，使用`@Test`注解的两个方法），并且我们使用`@BeforeAll`，`@BeforeEach`，`@AfterEach`和`@AfterAll`注解为测试生命周期的其余部分定义了额外的方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we run this test class, first `@BeforeAll` will be executed. Then, the two
    test methods will be executed sequentially, that is, the first one and then the
    other. In each execution, the setup method annotated with `@BeforeEach` will be
    executed before the test, and then the `@AfterEach` method. The following screenshot
    shows an execution of the tests using Maven and the command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个测试类，首先会执行`@BeforeAll`。然后，两个测试方法将按顺序执行，即先执行第一个，然后执行另一个。在每次执行中，测试之前使用`@BeforeEach`注解的设置方法将在测试之前执行，然后执行`@AfterEach`方法。以下截图显示了使用Maven和命令行执行测试的情况：
- en: '![](img/00037.gif)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.gif)'
- en: Execution of a Jupiter test which controls its lifecycle
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 控制其生命周期的Jupiter测试的执行
- en: Test instance lifecycle
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试实例生命周期
- en: In order to provide execution in isolation, the JUnit 5 framework creates a
    new test instance before executing the actual test (that is, the method annotated
    with `@Test`). This *per-method* test instance life cycle is the behavior in the
    Jupiter test and also in its antecessors (JUnit 3 and 4). As a novelty, this default
    behavior can be changed in JUnit 5, simply by annotating a `test` class with `@TestInstance(Lifecycle.PER_CLASS)`.
    Using this mode, the test instance will be created once per class, instead of
    once per test method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供隔离的执行，JUnit 5框架在执行实际测试（即使用`@Test`注解的方法）之前创建一个新的测试实例。这种*每方法*的测试实例生命周期是Jupiter测试和其前身（JUnit
    3和4）的行为。作为新功能，这种默认行为可以在JUnit 5中通过简单地使用`@TestInstance(Lifecycle.PER_CLASS)`注解来改变。使用这种模式，测试实例将每个类创建一次，而不是每个测试方法创建一次。
- en: This *per-class* behavior implies that it is possible to declare the `@BeforeAll`
    and `@AfterAll` methods as non-static. This is beneficial to be used in conjunction
    with some advanced capabilities, such as nested test or default test interfaces
    (explained in the next chapter).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '这种*每类*的行为意味着可以将`@BeforeAll`和`@AfterAll`方法声明为非静态的。这对于与一些高级功能一起使用非常有益，比如嵌套测试或默认测试接口（在下一章中解释）。 '
- en: 'All in all, and taking into account the extension callback (as explained in
    the  *The extension model of JUnit 5* section of Chapter 2, *What''s new in JUnit
    5*), the relative execution order of user code and extensions is depicted in the
    following picture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，考虑到扩展回调（如第2章*JUnit 5中的新功能*中所述的*JUnit 5的扩展模型*），用户代码和扩展的相对执行顺序如下图所示：
- en: '![](img/00038.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Relative execution order of user code and extensions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代码和扩展的相对执行顺序
- en: Skipping tests
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过测试
- en: 'The Jupiter annotation `@Disabled` (located in the package `org.junit.jupiter.api`)
    can be used to skip tests. It can be used at class level or method level. The
    following example uses the annotation `@Disabled` at method level and therefore
    it forces to skip the test:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter注释`@Disabled`（位于包`org.junit.jupiter.api`中）可用于跳过测试。它可以在类级别或方法级别使用。以下示例在方法级别使用注释`@Disabled`，因此强制跳过测试：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As shown in the following screenshot, when we execute this example, the test
    will be counted as skipped:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，当我们执行此示例时，测试将被视为已跳过：
- en: '![](img/00039.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.gif)'
- en: Disabled test method console output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用测试方法的控制台输出
- en: 'In this other example, the annotation `@Disabled` is placed at the class level
    and therefore all the tests contained in the class will be skipped. Note that
    a custom message, typically with the reason of the disabling, can be specified
    within the annotation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注释`@Disabled`放置在类级别，因此类中包含的所有测试都将被跳过。请注意，通常可以在注释中指定自定义消息，通常包含禁用的原因：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows how the test case is skipped when it is executed
    (in this example using Maven and the command line):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在执行测试用例时（在此示例中使用Maven和命令行）跳过测试案例的情况：
- en: '![](img/00040.gif)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.gif)'
- en: Disabled test class console output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用测试类的控制台输出
- en: Display names
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示名称
- en: JUnit 4 identified tests basically with the name of the method annotated with
    `@Test`. This imposes a limitation on name tests, since these names are constrained
    by the way of declaring methods in Java.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4基本上通过使用带有`@Test`注释的方法的名称来识别测试。这对测试名称施加了限制，因为这些名称受到在Java中声明方法的方式的限制。
- en: To overcome this problem, Jupiter provides the ability of declaring a custom
    display name (different to the test name) for tests. This is done with the annotation
    `@DisplayName`. This annotation declares a custom display name for a test class
    or a test method. This name will be displayed by test runners and reporting tools,
    and it can contain spaces, special characters, and even emojis.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Jupiter提供了声明自定义显示名称（与测试名称不同）的能力。这是通过注释`@DisplayName`完成的。此注释为测试类或测试方法声明了自定义显示名称。此名称将由测试运行器和报告工具显示，并且可以包含空格、特殊字符，甚至表情符号。
- en: 'Take a look at the following example. We are annotating the test class, and
    also the three test methods declared inside the class with a custom test name
    using `@DisplayName`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例。我们使用`@DisplayName`为测试类和类中声明的三个测试方法注释了自定义测试名称：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a result, we see these labels when executing this test in a JUnit 5 compliant
    IDE. The following picture shows the execution of the example on IntelliJ 2016.2+:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当在符合JUnit 5的IDE中执行此测试时，我们会看到这些标签。以下图片显示了在IntelliJ 2016.2+上执行示例的情况：
- en: '![](img/00042.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Execution of a test case using *@DisplayName* in IntelliJ
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ中使用*@DisplayName*执行测试案例
- en: 'On the other hand, the display name can be also seen in Eclipse 4.7 (Oxygen)
    or newer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，显示名称也可以在Eclipse 4.7（Oxygen）或更新版本中看到：
- en: '![](img/00043.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: Execution of a test case using *@DisplayName* in Eclipse
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中使用*@DisplayName*执行测试案例
- en: Assertions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: 'As we know, the general structure of a test case is composed of four stages:
    setup, exercise, verify, and tear down. The actual test happens during the second
    and third stage, when the test logic interacts with the system under test, getting
    some kind of outcome from it. This outcome is compared with the expected result
    in the verify stage. In this stage, we find what we call assertions. In this section,
    we take a closer look at them.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，测试案例的一般结构由四个阶段组成：设置、执行、验证和拆卸。实际测试发生在第二和第三阶段，当测试逻辑与被测试系统交互时，从中获得某种结果。这个结果在验证阶段与预期结果进行比较。在这个阶段，我们找到了我们所谓的断言。在本节中，我们将更仔细地研究它们。
- en: 'An assertion (also known as a predicate) is a `boolean` statement typically
    used to reason about software correctness. From a technical point of view, an
    assertion is composed of three parts (see the image after the list):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（也称为谓词）是一个`boolean`语句，通常用于推理软件的正确性。从技术角度来看，断言由三部分组成（见列表后的图像）：
- en: First, we find the expected value, which comes from what we call test oracles.
    A test oracle is a reliable source of expected outputs, for example, the system
    specification.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们找到预期值，这些值来自我们称之为测试预言的东西。测试预言是预期输出的可靠来源，例如，系统规范。
- en: Second, we find the real outcome, which comes from the exercise stage made by
    the test against the SUT.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们找到真正的结果，这是由测试对SUT进行的练习阶段产生的。
- en: Finally, these two values are compared using some logic comparator. This comparison
    can be done in many different ways, for example, we can compare the object identity
    (equals or not), the magnitude (higher or lower value), and so on. As a result,
    we obtain a test verdict, which, in the end, is going to define if the test has
    succeeded or failed.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这两个值使用一些逻辑比较器进行比较。这种比较可以通过许多不同的方式进行，例如，我们可以比较对象的身份（相等或不相等），大小（更高或更低的值），等等。结果，我们得到一个测试结论，最终将定义测试是否成功或失败。
- en: '![](img/00044.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: Schematic view of an assertion
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 断言的示意图
- en: Jupiter assertions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jupiter断言
- en: Let's move on to the JUnit 5 programming model. Jupiter comes with many of the
    assertion methods such as the ones in JUnit 4, and also adds several that can
    be used with Java 8 lambdas. All JUnit Jupiter assertions are static methods in
    the `Assertions` class located in `org.junit.jupiter package`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论JUnit 5编程模型。Jupiter提供了许多断言方法，例如JUnit 4中的方法，并且还添加了一些可以与Java 8 lambda一起使用的方法。所有JUnit
    Jupiter断言都是位于`org.junit.jupiter`包中的`Assertions`类中的静态方法。
- en: 'The following picture shows the complete list of these methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了这些方法的完整列表：
- en: '![](img/00045.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: Complete list of Jupiter assertions (class *org.junit.jupiter.Assertions*)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter断言的完整列表（类*org.junit.jupiter.Assertions*）
- en: 'The following table reviews the different types of basic assertions in Jupiter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格回顾了Jupiter中不同类型的基本断言：
- en: '| **Assertion** | **Description** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **断言** | **描述** |'
- en: '| `fail` | Fails a test with a given message and/or exception |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `fail` | 以给定的消息和/或异常失败测试 |'
- en: '| `assertTrue` | Asserts that a supplied condition is true |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue` | 断言提供的条件为真 |'
- en: '| `assertFalse` | Asserts that a supplied condition is false |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse` | 断言提供的条件为假 |'
- en: '| `assertNull` | Asserts that a supplied object is `null` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `assertNull` | 断言提供的对象为 `null` |'
- en: '| `assertNotNull` | Asserts that a supplied object is not `null` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `assertNotNull` | 断言提供的对象不是 `null` |'
- en: '| `assertEquals` | Asserts that two supplied objects are equal |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `assertEquals` | 断言两个提供的对象相等 |'
- en: '| `assertArrayEquals` | Asserts that two supplied arrays are equal |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `assertArrayEquals` | 断言两个提供的数组相等 |'
- en: '| `assertIterableEquals` | Asserts that two iterable objects are deeply equal
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `assertIterableEquals` | 断言两个可迭代对象深度相等 |'
- en: '| `assertLinesMatch` | Asserts that two lists of Strings are equals |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `assertLinesMatch` | 断言两个字符串列表相等 |'
- en: '| `assertNotEquals` | Asserts that two supplied objects are not equal |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `assertNotEquals` | 断言两个提供的对象不相等 |'
- en: '| `assertSame` | Asserts that two objects are the same, compared with `==`
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `assertSame` | 断言两个对象相同，使用 `==` 进行比较 |'
- en: '| `assertNotSame` | Asserts that two objects are different, compared with `!=`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `assertNotSame` | 断言两个对象不同，使用 `!=` 进行比较 |'
- en: For each of the assertions contained in the table, an optional failure message
    (String) can be provided. This message is always the last parameter in the assertion
    method. This is a small difference with respect to JUnit 4, in which this message
    was the first parameter in the method invocation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表中包含的每个断言，都可以提供一个可选的失败消息（String）。这个消息始终是断言方法中的最后一个参数。这与 JUnit 4 有一点小区别，因为在
    JUnit 4 中，这个消息是方法调用中的第一个参数。
- en: 'The following example shows a test using the  `assertEquals`, `assertTrue`,
    and `assertFalse `assertion. Note that we are importing the static assertion methods
    at the beginning of the class in order to improve the readability of the test
    logic. In the example, we find the `assertEquals `method, in this case comparing
    two primitive types (it could also be used for objects). Second, the method `assertTrue`
    evaluates if a `boolean` expression is true. Third, the method `assertFalse` evaluates
    if a Boolean expression is false. In this case, notice that the message is created
    as a Lamdba expression. This way, assertion messages are lazily evaluated to avoid
    constructing complex messages unnecessarily:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个使用 `assertEquals`、`assertTrue` 和 `assertFalse` 断言的测试。请注意，我们在类的开头导入了静态断言方法，以提高测试逻辑的可读性。在示例中，我们找到了
    `assertEquals` 方法，这里比较了两种原始类型（也可以用于对象）。其次，`assertTrue` 方法评估一个 `boolean` 表达式是否为真。第三，`assertFalse`
    方法评估一个布尔表达式是否为假。在这种情况下，请注意消息是作为 Lamdba 表达式创建的。这样，断言消息会被懒惰地评估，以避免不必要地构造复杂的消息：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following parts of this section review the advance assertions provided
    by Jupiter: `assertAll`, `assertThrows`, `assertTimeout`, and `assertTimeoutPreemptively`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的以下部分将回顾 Jupiter 提供的高级断言：`assertAll`、`assertThrows`、`assertTimeout` 和 `assertTimeoutPreemptively`。
- en: Group of assertions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言组
- en: An important Jupiter assertion is `assertAll`. This method allows to group different
    assertions at the same time. In a grouped assertion, all assertions are always
    executed, and any failures will be reported together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的 Jupiter 断言是 `assertAll`。这个方法允许同时对不同的断言进行分组。在分组断言中，所有断言都会被执行，任何失败都将一起报告。
- en: The method `assertAll` accepts a vargargs of lambda expressions (`Executable…`)
    or a stream of those (`Stream<Executable>`). Optionally, the first parameter of
    `assertAll` can be a String message aimed to label the assertion group.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `assertAll` 接受 lambda 表达式（`Executable…`）的可变参数或这些表达式的流（`Stream<Executable>`）。可选地，`assertAll`
    的第一个参数可以是一个用于标记断言组的字符串消息。
- en: 'Let’s see an example. In the following test, we are grouping a couple of `assertEquals`
    using lambda expressions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。在以下测试中，我们使用 lambda 表达式对一对 `assertEquals` 进行分组：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When executing this test, all assertions of the group will be evaluated. Since
    the second assertion fails (`lastname` does not match), one failure is reported
    in the final verdict, as can be seen in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这个测试时，将评估组中的所有断言。由于第二个断言失败（`lastname` 不匹配），在最终的判决中报告了一个失败，如下截图所示：
- en: '![](img/00046.gif)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.gif)'
- en: Console output of grouped assertions example
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 分组断言示例的控制台输出
- en: Asserting exceptions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言异常
- en: 'Another important Jupiter assertion is `assertThrows`. This assertion allows
    to verify if a given exception is raised in a piece of code. To that aim, the
    method `assertThrows` accepts two arguments. First, the exception class expected,
    and second, an executable object (lambda expression), in which the exception is
    supposed to happen:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的 Jupiter 断言是 `assertThrows`。这个断言允许验证在一段代码中是否引发了给定的异常。为此，`assertThrows`
    方法接受两个参数。首先是预期的异常类，其次是可执行对象（lambda 表达式），其中应该发生异常：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The is expecting  `IllegalArgumentException` to be thrown, and this is actually
    happening inside this lambda expression. The following screenshot shows that the
    test actually succeeds:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里期望抛出 `IllegalArgumentException`，而这实际上是在这个 lambda 表达式中发生的。下面的截图显示了测试实际上成功了：
- en: '![](img/00047.gif)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.gif)'
- en: Console output of *assertThrows* example
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*assertThrows* 示例的控制台输出'
- en: Asserting timeouts
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言超时
- en: 'To assess timeouts in JUnit 5 tests, Jupiter provides two assertions: `assertTimeout`
    and `assertTimeoutPreemptively`. On the one hand, `assertTimeout`, allows us to
    verify the timeout of a given operation. In this assertion, the expected time
    is defined using the class `Duration` of the standard Java package `java.time`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估 JUnit 5 测试中的超时，Jupiter 提供了两个断言：`assertTimeout` 和 `assertTimeoutPreemptively`。一方面，`assertTimeout`
    允许我们验证给定操作的超时。在这个断言中，使用标准 Java 包 `java.time` 的 `Duration` 类定义了预期时间。
- en: We are going to see several running examples to clarify the use of this assertion
    method. In the following class, we find two tests using `assertTimeout`. The first
    test is designed to be succeeded, due to the fact that we are expecting that a
    given operation takes less than 2 minutes, and we are doing nothing there. On
    the other side, the second test will fail, since we are expecting that a given
    operation takes a maximum of 10 milliseconds, and we are forcing it to last 100
    milliseconds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到几个运行示例，以阐明这个断言方法的使用。在下面的类中，我们找到两个使用`assertTimeout`的测试。第一个测试旨在成功，因为我们期望给定操作的持续时间少于2分钟，而我们在那里什么也没做。另一方面，第二个测试将失败，因为我们期望给定操作的持续时间最多为10毫秒，而我们强制它持续100毫秒。
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we execute this test, the second test is declared as failed because the
    timeout has been exceeded in 90 milliseconds:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个测试时，第二个测试被声明为失败，因为超时已经超过了90毫秒：
- en: '![](img/00048.gif)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.gif)'
- en: Console output of *assertTimeout* first example
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*assertTimeout*第一个示例的控制台输出'
- en: 'Let''s see a couple more tests using `assertTimeout`. In the first test, `assertTimeout`
    evaluates a piece of code as a lambda expression in a given timeout, obtaining
    its result. In the second test, `assertTimeout` evaluates a method in a given
    timeout, obtaining its result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`assertTimeout`的另外两个测试。在第一个测试中，`assertTimeout`在给定的超时时间内将代码作为lambda表达式进行评估，获取其结果。在第二个测试中，`assertTimeout`在给定的超时时间内评估一个方法，获取其结果：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In both cases, the tests take less time than expected and therefore both of
    them are succeeded:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，测试所花费的时间都少于预期，因此它们都成功了：
- en: '![](img/00049.gif)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.gif)'
- en: Console output of *assertTimeout* second example
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*assertTimeout*第二个示例的控制台输出'
- en: The other Jupiter assertion for timeouts is called `assertTimeoutPreemptively`.
    The difference with `assertTimeoutPreemptively` with respect to `assertTimeout`
    is that `assertTimeoutPreemptively` does not wait until the end of the operation,
    and the execution is aborted when the expected timeout is exceeded.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Jupiter断言超时的方法称为`assertTimeoutPreemptively`。与`assertTimeout`相比，`assertTimeoutPreemptively`的区别在于`assertTimeoutPreemptively`不会等到操作结束，当超过预期的超时时，执行会被中止。
- en: 'In this example, the test will fail since we are simulating an operation which
    lasts 100 milliseconds, and we have defined a timeout of 10 milliseconds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，测试将失败，因为我们模拟了一个持续100毫秒的操作，并且我们定义了10毫秒的超时：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, when the timeout of 10 ms is reached, instantly the test is
    declared as a failure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当达到10毫秒的超时时，测试立即被声明为失败：
- en: '![](img/00050.gif)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.gif)'
- en: Console output of *assertTimeoutPreemptively* example
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*assertTimeoutPreemptively*示例的控制台输出'
- en: Third-party assertion libraries
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方断言库
- en: 'As we have seen, the built-in assertions provided out of the box for Jupiter
    are sufficient for many testing scenarios. Nevertheless, there are times when
    more additional functionality, such as matchers, can be desired or required. In
    such situations, the JUnit team recommends the use of the following third-party
    assertion libraries:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Jupiter提供的内置断言已经足够满足许多测试场景。然而，在某些情况下，可能需要更多的额外功能，比如匹配器。在这种情况下，JUnit团队建议使用以下第三方断言库：
- en: 'Hamcrest ([http://hamcrest.org/](http://hamcrest.org/)): an assertion framework
    to write matcher objects allowing rules to be defined declaratively.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hamcrest（[http://hamcrest.org/](http://hamcrest.org/)）：一个断言框架，用于编写允许以声明方式定义规则的匹配器对象。
- en: 'AssertJ ([http://joel-costigliola.github.io/assertj/](http://joel-costigliola.github.io/assertj/)):
    fluent assertions for Java.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AssertJ（[http://joel-costigliola.github.io/assertj/](http://joel-costigliola.github.io/assertj/)）：用于Java的流畅断言。
- en: 'Truth ([https://google.github.io/truth/](https://google.github.io/truth/)):
    an assertions Java library designed to make test assertions and failure messages
    more readable.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truth（[https://google.github.io/truth/](https://google.github.io/truth/)）：一个用于使测试断言和失败消息更易读的断言Java库。
- en: 'In this section, we are going to make a brief review of Hamcrest. This library
    provided the assertion `assertThat`, which allows to create readable highly configurable
    assertions. The method `assertThat` accepts two arguments: first the actual object,
    and second a `Matcher` object. This matcher implements the interface `org.hamcrest.Matcher`,
    and enables a partial or an exact match for an expectation. Hamcrest provides
    different matcher utilities, such as `is`, `either`, `or`, `not`, and `hasItem`.
    The Matcher methods use the builder pattern, allowing to combine one or more matchers
    to build a matcher chain.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾一下Hamcrest。这个库提供了断言`assertThat`，它允许创建可读性高且高度可配置的断言。方法`assertThat`接受两个参数：第一个是实际对象，第二个是`Matcher`对象。这个匹配器实现了接口`org.hamcrest.Matcher`，并允许对期望进行部分或完全匹配。Hamcrest提供了不同的匹配器实用程序，比如`is`，`either`，`or`，`not`和`hasItem`。匹配器方法使用了构建器模式，允许组合一个或多个匹配器来构建一个匹配器链。
- en: 'In order to use Hamcrest, first we need to import the dependency in our project.
    In a Maven project, this means that we have to include the following dependency
    in our `pom.xml` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Hamcrest，首先我们需要在项目中导入依赖项。在Maven项目中，这意味着我们必须在`pom.xml`文件中包含以下依赖项：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we are using Gradle, we need to add the equivalent configuration within
    the `build.gradle` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Gradle，我们需要在`build.gradle`文件中添加相应的配置：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As usual, it is recommended using the latest version of Hamcrest. We can check
    it on the Maven central web ([http://search.maven.org/](http://search.maven.org/)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，建议使用最新版本的Hamcrest。我们可以在Maven中央网站上检查它（[http://search.maven.org/](http://search.maven.org/)）。
- en: 'The following example demonstrates how to use Hamcrest inside a Jupiter test.
    Concretely, this test uses the assertion `assertThat` together with the matchers
    `containsString`, `equalTo`, and `notNullValue`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在Jupiter测试中使用Hamcrest。具体来说，这个测试使用了断言`assertThat`，以及匹配器`containsString`，`equalTo`和`notNullValue`：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As shown in the following screenshot, this test is executed with no failure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，这个测试执行时没有失败：
- en: '![](img/00051.gif)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.gif)'
- en: Console output of example using the Hamcrest assertion library
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hamcrest断言库的示例的控制台输出
- en: Tagging and filtering tests
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记和过滤测试
- en: 'Test classes and methods can be tagged in the JUnit 5 programming model by
    means of the annotation `@Tag` (package `org.junit.jupiter.api`). Those tags can
    later be used to filter test discovery and execution. In the following example,
    we see the use of `@Tag` at class level and also at method level:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 5编程模型中，可以通过注解`@Tag`（包`org.junit.jupiter.api`）为测试类和方法打标签。这些标签可以后来用于过滤测试的发现和执行。在下面的示例中，我们看到了在类级别和方法级别使用`@Tag`的情况：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As of JUnit 5 M6, the label for tagging tests should meet the following syntax
    rules:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从JUnit 5 M6开始，标记测试的标签应满足以下语法规则：
- en: A tag must not be null or blank.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签不能为空或空白。
- en: A trimmed tag (that is, tags in which leading and trailing whitespace have been
    removed) must not contain a white space.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修剪的标签（即去除了前导和尾随空格的标签）不得包含空格。
- en: 'A trimmed tag must not contain ISO control characters nor the following reserved
    characters: `,`, `(`, `)`, `&`, `|`, and `!`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修剪的标签不得包含ISO控制字符，也不得包含以下保留字符：`,`，`(`，`)`，`&`，`|`和`!`。
- en: Filtering tests with Maven
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven过滤测试
- en: 'As we already know, we need to use  `maven-surefire-plugin` in a Maven project
    to execute Jupiter test. Moreover, this plugin allows us to filter the test execution
    in several ways: filtering by JUnit 5 tags and also using the regular inclusion/exclusion
    support of `maven-surefire-plugin`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，我们需要在Maven项目中使用`maven-surefire-plugin`来执行Jupiter测试。此外，该插件允许我们以多种方式过滤测试执行：通过JUnit
    5标签进行过滤，还可以使用`maven-surefire-plugin`的常规包含/排除支持。
- en: In order to filter by tags, the properties `includeTags` and `excludeTags` of
    the `maven-surefire-plugin` configuration should be used. Let's see an example
    to demonstrate how. Consider the following tests contained in the same Maven project.
    On the one hand, all tests in this class are tagged with the  `functional` word.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按标签过滤，应该使用`maven-surefire-plugin`配置的属性`includeTags`和`excludeTags`。让我们看一个示例来演示如何。考虑同一个Maven项目中包含的以下测试。一方面，这个类中的所有测试都被标记为`functional`。
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the other hand, all tests in the second class are tagged as `non-functional`
    and each individual test is also labeled with more tags (`performance`, `security`,
    `usability`, and so on):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第二个类中的所有测试都被标记为`non-functional`，每个单独的测试也被标记为更多的标签（`performance`，`security`，`usability`等）：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As described before, we use the configuration keywords `includeTags` and `excludeTags`
    in the Maven `pom.xml` file. In this example, we include the test with the tag
    `functional` and exclude `non-functional`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在Maven的`pom.xml`文件中使用配置关键字`includeTags`和`excludeTags`。在这个例子中，我们包含了带有标签`functional`的测试，并排除了`non-functional`：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a result, when we try to execute all the tests within the project, only
    two will be executed (those with the tag `functional`), and the rest are not recognized
    as tests:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当我们尝试执行项目中的所有测试时，只有两个测试会被执行（带有标签`functional`的测试），其余的测试不被识别为测试：
- en: '![](img/00052.gif)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.gif)'
- en: Maven execution of test filtering by tags
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签过滤的Maven执行
- en: Maven regular support
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven常规支持
- en: 'The regular inclusion/exclusion support of the Maven plugin can still be used
    to select which tests are going to be executed by `maven-surefire-plugin`. To
    that aim, we use the keywords `includes` and `excludes` to configure the test
    name pattern used to filter the execution by the plugin. Notice that for both
    inclusions and exclusions, regular expressions can be used to specify a pattern
    of the test filenames:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Maven插件的常规包含/排除支持仍然可以用于选择由`maven-surefire-plugin`执行的测试。为此，我们使用关键字`includes`和`excludes`来配置插件执行时用于过滤的测试名称模式。请注意，对于包含和排除，可以使用正则表达式来指定测试文件名的模式：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These three patterns, that is, the Java files containing the word *Test* or
    ending with *TestCase*, are included by default by a *maven-surefire plugin*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模式，即包含单词*Test*或以*TestCase*结尾的Java文件，默认情况下由*maven-surefire插件*包含。
- en: Filtering tests with Gradle
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle过滤测试
- en: 'Let''s move now to Gradle. As we already know, we can also use Gradle to run
    JUnit 5 tests. Regarding the filtering process, we can select the test to be executed
    based on:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到Gradle。正如我们已经知道的，我们也可以使用Gradle来运行JUnit 5测试。关于过滤过程，我们可以根据以下选择要执行的测试：
- en: 'The test engine: Using the keyword engines we can include or exclude the test
    engine to be used (that is `junit-jupiter` or `junit-vintage`).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试引擎：使用关键字引擎，我们可以包含或排除要使用的测试引擎（即`junit-jupiter`或`junit-vintage`）。
- en: 'The Jupiter tags: Using the keyword `tags`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupiter标签：使用关键字`tags`。
- en: 'The Java packages: Using the keyword `packages`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java包：使用关键字`packages`。
- en: 'The class name patterns: Using the keyword `includeClassNamePattern`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名模式：使用关键字`includeClassNamePattern`。
- en: 'By default, all engines and tags are included in the test plan. Only the classname
    containing the word `Tests` is applied. Let''s see a working example. We reuse
    the same tests presented in the former Maven project, but this time in a Gradle
    project:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，测试计划中包含所有引擎和标签。只应用包含单词`Tests`的类名。让我们看一个工作示例。我们在前一个Maven项目中重用相同的测试，但这次是在一个Gradle项目中：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that we are including the tags `non-functional` and excluding `functional`, and
    therefore we execute four tests:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们包含标签`non-functional`并排除`functional`，因此我们执行了四个测试：
- en: '![](img/00053.gif)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.gif)'
- en: Gradle execution of test filtering by tags
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签过滤的Gradle执行
- en: Meta-annotations
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元注解
- en: The final part of this section is about the definition of meta-annotations.
    The JUnit Jupiter annotations can be used in the definition of other annotations
    (that is, can be used as meta-annotations). That means that we can define our
    own composed annotation that will automatically inherit the semantics of its meta-annotations.
    This feature is very convenient to create our custom test taxonomy by reusing
    the JUnit 5 annotation `@Tag`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后部分是关于元注释的定义。JUnit Jupiter注释可以在其他注释的定义中使用（即可以用作元注释）。这意味着我们可以定义自己的组合注释，它将自动继承其元注释的语义。这个特性非常方便，可以通过重用JUnit
    5注释`@Tag`来创建我们自定义的测试分类。
- en: 'Let''s see an example. Consider the following classification for test cases,
    in which we classify all tests as functional and non-functional, and then we make
    another level under the non-functional tests:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。考虑测试用例的以下分类，其中我们将所有测试分类为功能和非功能，然后在非功能测试下再进行另一级分类：
- en: '![](img/00054.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Example taxonomy for tests (functional and non-functional)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的示例分类（功能和非功能）
- en: 'With that scheme in mind, we are going to create our custom meta-annotations
    for leaves of that tree structure: `@Functional`, `@Security`, `@Usability`, `@Accessiblity`,
    `@Load`, and `@Stress`. Notice that in each annotation we are using one or more
    `@Tag` annotations, depending on the structure previously defined. First, we can
    see the declaration of `@Functional`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个方案，我们将为树结构的叶子创建我们自定义的元注释：`@Functional`，`@Security`，`@Usability`，`@Accessiblity`，`@Load`和`@Stress`。请注意，在每个注释中，我们使用一个或多个`@Tag`注释，具体取决于先前定义的结构。首先，我们可以看到`@Functional`的声明：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we define the annotation `@Security` with tags `non-functional` and `security`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用标签`non-functional`和`security`定义注释`@Security`：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, we define the annotation `@Load`, but this time tagging with `non-functional`,
    `performance`, and `load`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义注释`@Load`，但这次标记为`non-functional`，`performance`和`load`：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally we create the annotation `@Stress` (with tags `non-functional`, `performance`,
    and `stress`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建注释`@Stress`（带有标签`non-functional`，`performance`和`stress`）：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can use our annotations to tag (and later filter) tests. For instance,
    in the following example we are using the annotation `@Functional` at class level:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的注释来标记（以及稍后过滤）测试。例如，在以下示例中，我们在类级别使用注释`@Functional`：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also out annotations at method level. In the following test, we annotate
    the different tests (methods) with different annotations (`@Load`, `@Stress`,
    `@Security`, and `@Accessibility`):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在方法级别使用注释。在以下测试中，我们使用不同的注释（`@Load`，`@Stress`，`@Security`和`@Accessibility`）对不同的测试（方法）进行注释：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All in all, we can filter the test by simply changing the included tags. On
    the one hand, we can filter by the tag `functional`. Notice that in this case,
    only two tests are executed. The following snippet shows the output of this kind
    of filtering using Maven:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以通过简单地更改包含的标签来过滤测试。一方面，我们可以按标签`functional`进行过滤。请注意，在这种情况下，只有两个测试被执行。以下代码片段显示了使用Maven进行此类过滤的输出：
- en: '![](img/00055.gif)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.gif)'
- en: Filtering test by tags (functional) using Maven and the command line
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven和命令行按标签（功能）过滤测试
- en: 'On the other hand, we can also filter with different tags, such as `non-functional`.
    The following picture shows an example of this type of filtering, this time using
    Gradle. As usual, we can play with these examples by forking the GitHub repository
    ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们也可以使用不同的标签进行过滤，例如`non-functional`。以下图片显示了这种类型的过滤示例，这次使用Gradle。和往常一样，我们可以通过分叉GitHub存储库（[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)）来玩这些示例：
- en: '>![](img/00056.gif)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/00056.gif)'
- en: Filtering test by tags (non-functional) using Gradle and the command line
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle和命令行按标签（非功能）过滤测试
- en: Conditional test execution
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件测试执行
- en: In order to establish custom conditions for test execution, we need to use the
    JUnit 5 extension model (introduced in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What's new in JUnit 5*, in the section *The extension model of JUnit 5*). Concretely,
    we need to use the conditional extension point called `ExecutionCondition`. This
    extension can be used to deactivate either all tests in a class or individual
    tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为测试执行建立自定义条件，我们需要使用JUnit 5扩展模型（在[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中介绍，*JUnit
    5的新功能*，在*JUnit 5的扩展模型*部分引入）。具体来说，我们需要使用名为`ExecutionCondition`的条件扩展点。此扩展可以用于停用类中的所有测试或单个测试。
- en: 'We are going to see a working example in which we create a custom annotation
    to disable tests based on the operative system. First of all, we create a custom
    utility enumeration to select one operative system (`WINDOWS`, `MAC`, `LINUX`,
    and `OTHER`):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个工作示例，其中我们创建一个自定义注释来基于操作系统禁用测试。首先，我们创建一个自定义实用枚举来选择一个操作系统（`WINDOWS`，`MAC`，`LINUX`和`OTHER`）：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we create an extension of `ExecutionCondition`. In this example, the evaluation
    is done by checking whether or not the custom annotation `@DisabledOnOs` is present.
    When the annotation `@DisabledOnOs` is present, the value of the operative system
    is compared with the current platform. Depending on the result of that condition,
    the test is disabled or enabled.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建`ExecutionCondition`的扩展。在这个例子中，通过检查自定义注释`@DisabledOnOs`是否存在来进行评估。当存在注释`@DisabledOnOs`时，操作系统的值将与当前平台进行比较。根据该条件的结果，测试将被禁用或启用。
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Moreover, we need to create our custom annotation `@DisabledOnOs`, which is
    also annotated with `@ExtendWith` pointing to our extension point.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要创建我们的自定义注释`@DisabledOnOs`，该注释也使用`@ExtendWith`进行注释，指向我们的扩展点。
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we use our annotation `@DisabledOnOs` in a Jupiter test.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在Jupiter测试中使用我们的注释`@DisabledOnOs`。
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we execute this test in a Windows machine, the test is not skipped, as we
    can see in this snapshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Windows机器上执行此测试，则测试不会被跳过，如下面的快照所示：
- en: '![](img/00057.gif)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.gif)'
- en: Execution of conditional test example
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 条件测试示例的执行
- en: Assumptions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: 'In this part of this section is about the so-called assumptions. Assumptions
    allow us to only run tests if certain conditions are as expected. All JUnit Jupiter
    assumptions are static methods in the class `Assumptions`, located inside the
    `org.junit.jupiter` package. The following screenshot shows all the methods of
    this class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的这一部分是关于所谓的假设。假设允许我们仅在某些条件符合预期时运行测试。所有JUnit Jupiter假设都是位于`org.junit.jupiter`包内的`Assumptions`类中的静态方法。以下截图显示了该类的所有方法：
- en: '![](img/00058.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: Methods of the class *org.junit.jupiter.Assumptions*
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*org.junit.jupiter.Assumptions*类的方法'
- en: 'On the one hand, the methods `assumeTrue` and `assumeFalse` can be used to
    skip tests whose preconditions are not met. On the other hand, the method `assumingThat`
    is used to condition the execution of a part in a test:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，`assumeTrue`和`assumeFalse`方法可用于跳过未满足前提条件的测试。另一方面，`assumingThat`方法用于条件测试中的一部分的执行：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that in this example, the two first tests (`assumeTrueTest` and `assumeFalseTest`)
    are skipped since the assumptions are not met. Nevertheless, in the `assummingThatTest` test,
    only this part of the test (a lambda expression in this case) is not executed,
    but the whole test is not skipped:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，前两个测试（`assumeTrueTest`和`assumeFalseTest`）由于假设条件不满足而被跳过。然而，在`assummingThatTest`测试中，只有测试的这一部分（在这种情况下是一个lambda表达式）没有被执行，但整个测试并没有被跳过：
- en: '![](img/00059.gif)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.gif)'
- en: Execution of assumptions test example
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设测试示例的执行
- en: Nested tests
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套测试
- en: Nested tests give the test writer more capabilities to express the relationship
    and order in a group of tests. JUnit 5 makes it effortless to nest test classes.
    We simply need to annotate inner classes with `@Nested` and all test methods in
    there will be executed as well, going from the regular tests (defined in the top-level
    class) to the tests defined in each of the inner classes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套测试使测试编写者能够更多地表达一组测试中的关系和顺序。JUnit 5使得嵌套测试类变得轻而易举。我们只需要用`@Nested`注解内部类，其中的所有测试方法也将被执行，从顶级类中定义的常规测试到每个内部类中定义的测试。
- en: The first thing we need to take into account is that only non-static nested
    classes (that is inner classes) can serve as `@Nested` tests. Nesting can be arbitrarily
    deep, and the setup and tear down for each test (that is, `@BeforeEach` and `@AfterEach`
    methods) are inherited in the nested tests. Nevertheless, inner classes cannot
    define the `@BeforeAll` and `@AfterAll` methods, due to the fact that Java does
    not allow static members in inner classes. However, this restriction can be avoided
    using the annotation `@TestInstance(Lifecycle.PER_CLASS)` in the test class. As
    described in the section *Test instance lifecycle* in this chapter, this annotation
    force to instance a test instance per class, instead of a test instance per method
    (default behavior). This way, the methods `@BeforeAll` and `@AfterAll` do not
    need to be static and therefore it can be used in nested tests.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的第一件事是，只有非静态嵌套类（即内部类）才能作为`@Nested`测试。嵌套可以任意深入，并且每个测试的设置和拆卸（即`@BeforeEach`和`@AfterEach`方法）都会在嵌套测试中继承。然而，内部类不能定义`@BeforeAll`和`@AfterAll`方法，因为Java不允许内部类中有静态成员。然而，可以使用`@TestInstance(Lifecycle.PER_CLASS)`注解在测试类中避免这种限制。正如本章节中的*测试实例生命周期*部分所描述的，该注解强制每个类实例化一个测试实例，而不是每个方法实例化一个测试实例（默认行为）。这样，`@BeforeAll`和`@AfterAll`方法就不需要是静态的，因此可以在嵌套测试中使用。
- en: 'Let''s see a simple example composed by a Java class with two levels of inner
    classes, that is, the class contains two nested inner classes annotated with `@Nested`.
    As we can see, there are tests in the three levels of the class. Notice that the
    top class defined a setup method (`@BeforeEach`), and also the first nested class
    (called `InnerClass1` in the example). In the top-level class, we define a single
    test (called `topTest`), and in each nested class we find another test (called
    `innerTest1` and `innerTest2`, respectively):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个由一个Java类组成的简单示例，该类有两个级别的内部类，即，该类包含两个嵌套的内部类，这些内部类带有`@Nested`注解。正如我们所看到的，该类的三个级别都有测试。请注意，顶级类定义了一个设置方法（`@BeforeEach`），并且第一个嵌套类（在示例中称为`InnerClass1`）也是如此。在顶级类中，我们定义了一个单一的测试（称为`topTest`），并且在每个嵌套类中，我们找到另一个测试（分别称为`innerTest1`和`innerTest2`）：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we execute this example, we can trace the execution of the nested tests by
    simply looking to the console traces. Note that the top `@BeforeEach` method (called
    `setup1`) is always executed before each test. Therefore, the trace `Setup 1` is
    always present in the console before the actual test execution. Each test also
    writes a line the console. As we can see, the first test logs `Test 1`. After
    that, the tests defined in the inner classes are executed. The first inner class
    executes the test `innerTest1`, but after that, the setup method of the top-level
    class and the first inner class are executed (logging `Setup 1` and `Setup 2`,
    respectively).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个示例，我们可以通过简单地查看控制台跟踪来追踪嵌套测试的执行。请注意，顶级`@BeforeEach`方法（称为`setup1`）总是在每个测试之前执行。因此，在实际测试执行之前，控制台中始终存在`Setup
    1`的跟踪。每个测试也会在控制台上写一行。正如我们所看到的，第一个测试记录了`Test 1`。之后，执行了内部类中定义的测试。第一个内部类执行了测试`innerTest1`，但在此之后，顶级类和第一个内部类的设置方法被执行（分别记录了`Setup
    1`和`Setup 2`）。
- en: 'Finally, the test defined in the last inner class (`innerTest2`) is executed,
    but as usual, the cascade of setup methods is executed before the test:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行了最后一个内部类中定义的测试（`innerTest2`），但通常情况下，在测试之前会执行一系列的设置方法：
- en: '![](img/00060.gif)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.gif)'
- en: Console output of the execution of the nested test example
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套测试示例的控制台输出
- en: 'Nested tests can be used in conjunction with the display name (that is, the
    annotation `@DisplayName`) to help to produce a nicely readable test output. The
    following example demonstrates how. This class contains the structure to test
    the implementation of a stack, that is, a *last-in-first-out* (LIFO) collection.
    The class is designed to first test the stack when it is just instantiated (the
    method `isInstantiatedWithNew`). After that, the first inner class (`WhenNew`)
    is supposed to test the stack as an empty collection (methods `isEmpty`, `throwsExceptionWhenPopped` and `throwsExceptionWhenPeeked`).
    Finally, the second inner class is supposed to test when the stack is not empty
    (methods `isNotEmpty`, `returnElementWhenPopped`, and `returnElementWhenPeeked`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套测试可以与显示名称（即注解`@DisplayName`）一起使用，以帮助生成易读的测试输出。以下示例演示了如何使用。这个类包含了测试栈实现的结构，即*后进先出*（LIFO）集合。该类首先设计了在栈刚实例化时进行测试（方法`isInstantiatedWithNew`）。之后，第一个内部类（`WhenNew`）应该测试栈作为空集合（方法`isEmpty`，`throwsExceptionWhenPopped`和`throwsExceptionWhenPeeked`）。最后，第二个内部类应该测试栈不为空时的情况（方法`isNotEmpty`，`returnElementWhenPopped`和`returnElementWhenPeeked`）：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The objective of this type of test is two folded. On the one hand, the class
    structure provides an order for the execution of the tests. On the other hand,
    the use of `@DisplayName` improves the readability of the test execution. We can
    see that when the test is executed in an IDE, concretely in IntelliJ IDEA.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试的目的是双重的。一方面，类结构为测试的执行提供了顺序。另一方面，使用`@DisplayName`提高了测试执行的可读性。我们可以看到，当测试在IDE中执行时，特别是在IntelliJ
    IDEA中。
- en: '![](img/00061.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: Execution of nested test using *@DisplayName* on Intellij IDEA
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intellij IDEA上使用*@DisplayName*执行嵌套测试
- en: Repeated tests
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复测试
- en: JUnit Jupiter provides for the ability to repeat a test a specified number of
    times simply by annotating a method with `@RepeatedTest`, specifying the total
    number of repetitions desired. Each repeated test behaves exactly as a regular
    `@Test` method. Moreover, each repeated test preserves the same lifecycle callbacks
    (`@BeforeEach`, `@AfterEach`, and so on).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Jupiter提供了通过简单地使用`@RepeatedTest`方法对测试进行指定次数的重复的能力，指定所需的总重复次数。每次重复的测试行为与常规的`@Test`方法完全相同。此外，每次重复的测试都保留相同的生命周期回调（`@BeforeEach`，`@AfterEach`等）。
- en: 'The following Java class contains a test that is going to be repeated five
    times:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java类包含一个将重复五次的测试：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Due to the fact that this test only writes a line (`Repeated test`) in the
    standard output, when executing this test in the console, we will see that trace
    five times:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个测试只在标准输出中写了一行（`Repeated test`），当在控制台中执行这个测试时，我们会看到这个迹象出现五次：
- en: '![](img/00062.gif)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.gif)'
- en: Execution of repeated test in the console
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中执行重复测试
- en: 'In addition to specifying the number of repetitions, a custom display name
    can be configured for each repetition via the name attribute of the `@RepeatedTest`
    annotation. The display name can be a pattern composed of a combination of static
    text and dynamic placeholders. The following are currently supported:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定重复次数外，还可以通过`@RepeatedTest`注解的name属性为每次重复配置自定义显示名称。显示名称可以是由静态文本和动态占位符组成的模式。目前支持以下内容：
- en: '`{displayName}`: This is the name of the `@RepeatedTest` method.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{displayName}`：这是`@RepeatedTest`方法的名称。'
- en: '`{currentRepetition}`: This is the current repetition count.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{currentRepetition}`：这是当前的重复次数。'
- en: '`{totalRepetitions}`: This is the total number of repetitions.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{totalRepetitions}`：这是总的重复次数。'
- en: 'The following example shows a class with three repeated tests in which the
    display name is configured with the property name of `@RepeatedTest`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个类，其中有三个重复测试，其中显示名称使用了`@RepeatedTest`的属性名称：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this test, the display name for these repeated tests will be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，这些重复测试的显示名称将如下所示：
- en: 'For the test `customDisplayName`, the display name will follow the long display
    format:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于测试`customDisplayName`，显示名称将遵循长显示格式：
- en: '`Repeat 1 out of 2`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重复1次，共2次`。'
- en: '`Repeat 2 out of 2`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重复2次，共2次`。'
- en: 'For the test `customDisplayNameWithLongPattern`, the display name will follow
    the long display format:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于测试`customDisplayNameWithLongPattern`，显示名称将遵循长显示格式：
- en: '`Repeat! 1/2`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重复！1/2`。'
- en: '`Repeat! 2/2`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重复！2/2`。'
- en: 'For the test `customDisplayNameWithShortPattern`, the display name in this
    test will follow the short display format:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于测试`customDisplayNameWithShortPattern`，此测试中的显示名称将遵循短显示格式：
- en: '`Test using long display name :: repetition 1 of 2`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`使用长显示名称的测试::重复1次，共2次`。'
- en: '`Test using long display name :: repetition 2 of 2`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`使用长显示名称的测试::重复2次，共2次`。'
- en: '![](img/00063.gif)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.gif)'
- en: Execution of repeated test example in conjunction with *@DisplayName*
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*@DisplayName*结合使用的重复测试示例中执行
- en: Migration from JUnit 4 to JUnit 5
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JUnit 4迁移到JUnit 5
- en: JUnit 5 does not support JUnit 4 features, such as Rules and Runners, natively.
    Nevertheless, JUnit 5 provides a gentle migration path via the JUnit Vintage test
    engine, which allows us to execute legacy test cases (including JUnit 4 but also
    JUnit 3) on the top of the JUnit Platform.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5不支持JUnit 4的功能，比如规则和运行器。然而，JUnit 5通过JUnit Vintage测试引擎提供了一个渐进的迁移路径，允许我们在JUnit平台上执行传统的测试用例（包括JUnit
    4和JUnit 3）。
- en: 'The following table can be used to summarize the main differences between JUnit
    4 and 5:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格可用于总结JUnit 4和5之间的主要区别：
- en: '| **Feature** | **JUnit 4** | **JUnit 5** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **JUnit 4** | **JUnit 5** |'
- en: '| Annotations package | `org.junit` | `org.junit.jupiter.api` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 注解包 | `org.junit` | `org.junit.jupiter.api` |'
- en: '| Declaring a test | `@Test` | `@Test` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 声明测试 | `@Test` | `@Test` |'
- en: '| Setup for all tests | `@BeforeClass` | `@BeforeAll` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 所有测试的设置 | `@BeforeClass` | `@BeforeAll` |'
- en: '| Setup per test | `@Before` | `@BeforeEach` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 每个测试的设置 | `@Before` | `@BeforeEach` |'
- en: '| Tear down per test | `@After` | `@AfterEach` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 每个测试的拆卸 | `@After` | `@AfterEach` |'
- en: '| Tear down for all tests | `@AfterClass` | `@AfterAll` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 所有测试的拆卸 | `@AfterClass` | `@AfterAll` |'
- en: '| Tagging and filtering | `@Category` | `@Tag` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 标记和过滤 | `@Category` | `@Tag` |'
- en: '| Disable a test method or class | `@Ignore` | `@Disabled` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 禁用测试方法或类 | `@Ignore` | `@Disabled` |'
- en: '| Nested tests | NA | `@Nested` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 嵌套测试 | 不适用 | `@Nested` |'
- en: '| Repeated test | Using custom rule | `@Repeated` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 重复测试 | 使用自定义规则 | `@Repeated` |'
- en: '| Dynamic tests | NA | `@TestFactory` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 动态测试 | 不适用 | `@TestFactory` |'
- en: '| Test templates | NA | `@TestTemaplate` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 测试模板 | 不适用 | `@TestTemaplate` |'
- en: '| Runners | `@RunWith` | This feature is superseded by the extension model
    (`@ExtendWith`) |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 运行器 | `@RunWith` | 此功能已被扩展模型 (`@ExtendWith`) 取代 |'
- en: '| Rules | `@Rule` and `@ClassRule` | This feature is superseded by the extension
    model (`@ExtendWith`) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | `@Rule` 和 `@ClassRule` | 此功能已被扩展模型 (`@ExtendWith`) 取代 |'
- en: Rule support in Jupiter
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jupiter 中的规则支持
- en: 'As described before, Jupiter does not support JUnit 4 rules natively. Nevertheless,
    the JUnit 5 team realized that JUnit 4 rules are widely adopted in many test codebases
    nowadays. In order to provide a seamless migration from JUnit 4 to JUnit 5, the
    JUnit 5 team implemented the `junit-jupiter-migrationsupport` module. If this
    module is going to be used in a project, the module dependency should be imported.
    Examples for Maven are shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Jupiter 不原生支持 JUnit 4 规则。然而，JUnit 5 团队意识到 JUnit 4 规则如今在许多测试代码库中被广泛采用。为了实现从
    JUnit 4 到 JUnit 5 的无缝迁移，JUnit 5 团队实现了 `junit-jupiter-migrationsupport` 模块。如果要在项目中使用这个模块，应该导入模块依赖。Maven
    的示例在这里：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Gradle declaration for this dependency is like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖的 Gradle 声明是这样的：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The rule support in JUnit 5 is limited to those rules semantically compatible
    with the Jupiter extension model, including the following rules:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5 中的规则支持仅限于与 Jupiter 扩展模型在语义上兼容的规则，包括以下规则：
- en: '`junit.rules.ExternalResource` (including `org.junit.rules.TemporaryFolder`).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit.rules.ExternalResource` (包括 `org.junit.rules.TemporaryFolder`)。'
- en: '`junit.rules.Verifier` (including `org.junit.rules.ErrorCollector`).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit.rules.Verifier` (包括 `org.junit.rules.ErrorCollector`)。'
- en: '`junit.rules.ExpectedException`.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit.rules.ExpectedException`。'
- en: 'In order to enable these rules in Jupiter tests, the test class should be annotated
    with the class-level annotation `@EnableRuleMigrationSupport` (located in the
    package `org.junit.jupiter.migrationsupport.rules`). Let us see several examples.
    First, the following test case defines and uses a `TemporaryFolder` JUnit 4 rule
    within a Jupiter test:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Jupiter 测试中启用这些规则，测试类应该用类级别的注解 `@EnableRuleMigrationSupport` 进行注解（位于包 `org.junit.jupiter.migrationsupport.rules`
    中）。让我们看几个例子。首先，以下测试用例在 Jupiter 测试中定义并使用了 `TemporaryFolder` JUnit 4 规则：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When executing this test, the path of the temporary folder will be logged on
    the standard output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这个测试时，临时文件夹的路径将被记录在标准输出中：
- en: '![](img/00064.gif)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.gif)'
- en: Execution of Jupiter test using a JUnit 4 *TemporaryFolder* rule
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit 4 的 *TemporaryFolder* 规则执行 Jupiter 测试
- en: 'The following test demonstrates the use of the `ErrorCollector` rule in a Jupiter
    test. Notice that the collector rule allows the execution of a test to continue
    after one or more problems are found:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试演示了在 Jupiter 测试中使用 `ErrorCollector` 规则。请注意，收集器规则允许在发现一个或多个问题后继续执行测试：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These problems are reported together at the end of the test:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题将在测试结束时一起报告：
- en: '![](img/00065.gif)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.gif)'
- en: Execution of Jupiter test using a JUnit 4 *ErrorCollector* rule
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit 4 的 *ErrorCollector* 规则执行 Jupiter 测试
- en: 'Finally, the `ExpectedException` rule allows us to configure a test to anticipate
    a given exception to be thrown within the test logic:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ExpectedException` 规则允许我们配置测试以预期在测试逻辑中抛出给定的异常：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, even when the second test raises a `NullPointerException`,
    the test will be marked as having succeeded since that exception was expected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，即使第二个测试引发了 `NullPointerException`，由于预期到了这个异常，测试将被标记为成功。
- en: '![](img/00066.gif)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.gif)'
- en: Execution of Jupiter test using a JUnit 4 *ExpectedException* rule
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit 4 的 *ExpectedException* 规则执行 Jupiter 测试
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the basics of the brand-new programming model
    of the JUnit 5 framework, known as Jupiter. This programming model provides a
    rich API that can be used by practitioners to create test cases. The most basic
    element of Jupiter is the annotation `@Test`, which identifies the methods in
    Java classes treated as tests (that is logic which exercises and verifies a SUT).
    Moreover, there are different annotations that can be used to control the test
    life cycle, namely, `@BeforeAll`, `@BeforeEach`, `@AfterEach` , and `@AfterAll`.
    Other useful Jupiter annotations are `@Disabled` (to skip tests), `@DisplayName`
    (to provide a test name), `@Tag` (to label and filter tests).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 JUnit 5 框架全新编程模型 Jupiter 的基础知识。这个编程模型提供了丰富的 API，可以被从业者用来创建测试用例。Jupiter
    最基本的元素是注解 `@Test`，它标识 Java 类中作为测试的方法（即对 SUT 进行测试和验证的逻辑）。此外，还有不同的注解可以用来控制测试生命周期，即
    `@BeforeAll`、`@BeforeEach`、`@AfterEach` 和 `@AfterAll`。其他有用的 Jupiter 注解包括 `@Disabled`（跳过测试）、`@DisplayName`（提供测试名称）、`@Tag`（标记和过滤测试）。
- en: Jupiter provides a rich set of assertions, which are static methods in the class
    `Assertions` used to verify if the outcome obtained from the SUT corresponds with
    some expected value. We can impose conditions for the test execution in several
    ways. On the one hand, we can use `Assumptions` to only run tests (or a part of
    those) if certain conditions are as expected.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter 提供了丰富的断言集，这些断言是 `Assertions` 类中的静态方法，用于验证从 SUT 获取的结果是否与某个预期值相对应。我们可以通过多种方式对测试执行施加条件。一方面，我们可以使用
    `Assumptions` 仅在某些条件符合预期时运行测试（或其中的一部分）。
- en: We have learned how nested tests can be created simple annotating inner Java
    classes with `@Nested`. This can be used to create test executions following an
    order given the nested classes relationship. We have also studied how easy is
    to created repeated test using the JUnit 5 programming model. The annotation `@RepeatedTest`
    is used to that aim, providing the ability to repeat a test a specified number
    of times. Finally, we have seen how Jupiter provides support for several legacy
    JUnit 4 test rules, including `ExternalResource`, `Verifier`, and `ExpectedException`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用`@Nested`注解简单地创建嵌套测试，这可以用来按照嵌套类的关系顺序执行测试。我们还学习了使用JUnit 5编程模型创建重复测试的简便方法。`@RepeatedTest`注解用于此目的，可以重复执行指定次数的测试。最后，我们看到Jupiter为几个传统的JUnit
    4测试规则提供了支持，包括`ExternalResource`、`Verifier`和`ExpectedException`。
- en: In the [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb), *Simplifying
    Testing With Advanced JUnit Features,* we continue discovering the JUnit programming
    model. Concretely, we review the advance features of JUnit 5, namely, dependency
    injection, dynamic tests, test interfaces, test templates, parameterized tests,
    compatibility of JUnit 5 and Java 9\. Finally, we review some of the planned features
    in the backlog for JUnit 5.1, not implemented yet at the time of this writing.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb)中，*使用高级JUnit功能简化测试*，我们继续探索JUnit编程模型。具体来说，我们回顾了JUnit
    5的高级功能，包括依赖注入、动态测试、测试接口、测试模板、参数化测试、JUnit 5与Java 9的兼容性。最后，我们回顾了JUnit 5.1中计划的一些功能，这些功能在撰写本文时尚未实现。
